/*! 
* DevExtreme Web
* Version: 15.2.4
* Build date: Dec 8, 2015
*
* Copyright (c) 2012 - 2015 Developer Express Inc. ALL RIGHTS RESERVED
* EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
*/

"use strict";

if (!window.DevExpress || !DevExpress.MOD_CORE) {
    /*! Module core, file modules.js */
    (function(global, $) {
        global.DevExpress = global.DevExpress || {};
        var ModuleDefinitions = function(DevExpress) {
                var DeferModule = function() {
                        var loadedModules = {};
                        return function(name) {
                                var __definition = null;
                                this.define = function(definition) {
                                    if (__definition)
                                        throw"'" + name + "' module definition is already present";
                                    __definition = definition
                                };
                                this.load = function() {
                                    loadedModules[name] = loadedModules[name] || __definition();
                                    return loadedModules[name]
                                }
                            }
                    }();
                var deferModules = {};
                var requireSingle = function(name) {
                        var module = deferModules[name];
                        if (!module)
                            throw"'" + name + "' module definition is absent";
                        return module.load()
                    };
                var mapDependencies = function(dependencies) {
                        return $.map(dependencies, function(name) {
                                switch (name) {
                                    case"jquery":
                                    case"domReady":
                                        return jQuery;
                                    case"domReady!":
                                        return name;
                                    case"require":
                                        return require;
                                    default:
                                        return requireSingle(name)
                                }
                            })
                    };
                var require = function(dependencies, callback) {
                        if (!$.isArray(dependencies))
                            return requireSingle(dependencies);
                        if (DevExpress.preserveRequire)
                            return;
                        dependencies = mapDependencies(dependencies);
                        callback = callback || $.noop;
                        var exec = function() {
                                callback.apply(global, dependencies)
                            };
                        $.inArray("domReady!", dependencies) ? $(exec) : exec()
                    };
                var define = function(name, dependencies, definition) {
                        deferModules[name] = deferModules[name] || new DeferModule(name);
                        deferModules[name].define(function() {
                            return definition.apply(global, mapDependencies(dependencies))
                        })
                    };
                return {
                        require: require,
                        define: define
                    }
            }(global.DevExpress);
        global.DevExpress.require = ModuleDefinitions.require;
        global.DevExpress.define = ModuleDefinitions.define
    })(this, jQuery);
    /*! Module core, file utils.animationFrame.js */
    DevExpress.define("/utils/utils.animationFrame", ["jquery"], function($) {
        var FRAME_ANIMATION_STEP_TIME = 1000 / 60,
            requestAnimationFrame = function(callback) {
                return this.setTimeout(callback, FRAME_ANIMATION_STEP_TIME)
            },
            cancelAnimationFrame = function(requestID) {
                this.clearTimeout(requestID)
            },
            nativeRequestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame,
            nativeCancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
        if (nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
            requestAnimationFrame = nativeRequestAnimationFrame;
            cancelAnimationFrame = nativeCancelAnimationFrame
        }
        if (nativeRequestAnimationFrame && !nativeCancelAnimationFrame) {
            var cancelledRequests = {};
            requestAnimationFrame = function(callback) {
                var requestId = nativeRequestAnimationFrame.call(window, function() {
                        try {
                            if (requestId in cancelledRequests)
                                return;
                            callback.apply(this, arguments)
                        }
                        finally {
                            delete cancelledRequests[requestId]
                        }
                    });
                return requestId
            };
            cancelAnimationFrame = function(requestId) {
                cancelledRequests[requestId] = true
            }
        }
        requestAnimationFrame = $.proxy(requestAnimationFrame, window);
        cancelAnimationFrame = $.proxy(cancelAnimationFrame, window);
        return {
                request: requestAnimationFrame,
                cancel: cancelAnimationFrame
            }
    });
    /*! Module core, file utils.array.js */
    DevExpress.define("/utils/utils.array", ["jquery", "/utils/utils.common", "/utils/utils.object"], function($, commonUtils, objectUtils) {
        var isEmpty = function(entity) {
                return $.isArray(entity) && !entity.length
            };
        var wrapToArray = function(entity) {
                return $.isArray(entity) ? entity : [entity]
            };
        var intersection = function(a, b) {
                if (!$.isArray(a) || a.length === 0 || !$.isArray(b) || b.length === 0)
                    return [];
                var result = [];
                $.each(a, function(_, value) {
                    var index = $.inArray(value, b);
                    if (index !== -1)
                        result.push(value)
                });
                return result
            };
        var removeDublicates = function(from, what) {
                if (!$.isArray(from) || from.length === 0)
                    return [];
                if (!$.isArray(what) || what.length === 0)
                    return from.slice();
                var result = [];
                $.each(from, function(_, value) {
                    var index = $.inArray(value, what);
                    if (index === -1)
                        result.push(value)
                });
                return result
            };
        var normalizeIndexes = function(items, indexParameterName, currentItem, needIndexCallback) {
                var indexedItems = {},
                    parameterIndex = 0;
                $.each(items, function(index, item) {
                    index = item[indexParameterName];
                    if (commonUtils.isDefined(index)) {
                        indexedItems[index] = indexedItems[index] || [];
                        if (item === currentItem)
                            indexedItems[index].unshift(item);
                        else
                            indexedItems[index].push(item);
                        delete item[indexParameterName]
                    }
                });
                objectUtils.orderEach(indexedItems, function(index, items) {
                    $.each(items, function() {
                        if (index >= 0)
                            this[indexParameterName] = parameterIndex++
                    })
                });
                $.each(items, function() {
                    if (!commonUtils.isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this)))
                        this[indexParameterName] = parameterIndex++
                });
                return parameterIndex
            };
        return {
                isEmpty: isEmpty,
                wrapToArray: wrapToArray,
                intersection: intersection,
                removeDublicates: removeDublicates,
                normalizeIndexes: normalizeIndexes
            }
    });
    /*! Module core, file utils.browser.js */
    DevExpress.define("/utils/utils.browser", ["jquery"], function($) {
        var webkitRegExp = /(webkit)[ \/]([\w.]+)/,
            ieRegExp = /(msie) (\d{1,2}\.\d)/,
            ie11RegExp = /(trident).*rv:(\d{1,2}\.\d)/,
            msEdge = /(edge)\/((\d+)?[\w\.]+)/,
            mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;
        var browserFromUA = function(ua) {
                ua = ua.toLowerCase();
                var result = {},
                    matches = ieRegExp.exec(ua) || ie11RegExp.exec(ua) || msEdge.exec(ua) || ua.indexOf("compatible") < 0 && mozillaRegExp.exec(ua) || webkitRegExp.exec(ua) || [],
                    browserName = matches[1],
                    browserVersion = matches[2];
                if (browserName === "trident" || browserName === "edge")
                    browserName = "msie";
                if (browserName) {
                    result[browserName] = true;
                    result.version = browserVersion
                }
                return result
            };
        return $.extend({_fromUA: browserFromUA}, browserFromUA(navigator.userAgent))
    });
    /*! Module core, file utils.caret.js */
    DevExpress.define("/utils/utils.caret", ["jquery", "/utils/utils.common"], function($, commonUtils) {
        var getCaret = function(input) {
                if (isObsoleteBrowser(input))
                    return getCaretForObsoleteBrowser(input);
                return {
                        start: input.selectionStart,
                        end: input.selectionEnd
                    }
            };
        var setCaret = function(input, position) {
                if (isObsoleteBrowser(input)) {
                    setCaretForObsoleteBrowser(input, position);
                    return
                }
                if (!$.contains(document, input))
                    return;
                input.selectionStart = position.start;
                input.selectionEnd = position.end
            };
        var isObsoleteBrowser = function(input) {
                return !input.setSelectionRange
            };
        var getCaretForObsoleteBrowser = function(input) {
                var range = document.selection.createRange();
                var rangeCopy = range.duplicate();
                range.move('character', -input.value.length);
                range.setEndPoint('EndToStart', rangeCopy);
                return {
                        start: range.text.length,
                        end: range.text.length + rangeCopy.text.length
                    }
            };
        var setCaretForObsoleteBrowser = function(input, position) {
                var range = input.createTextRange();
                range.collapse(true);
                range.moveStart("character", position.start);
                range.moveEnd("character", position.end - position.start);
                range.select()
            };
        var caret = function(input, position) {
                input = $(input).get(0);
                if (!commonUtils.isDefined(position))
                    return getCaret(input);
                setCaret(input, position)
            };
        return caret
    });
    /*! Module core, file utils.common.js */
    DevExpress.define("/utils/utils.common", ["jquery"], function($) {
        var isDefined = function(object) {
                return object !== null && object !== undefined
            };
        var isString = function(object) {
                return $.type(object) === 'string'
            };
        var isNumber = function(object) {
                return typeof object === "number" && isFinite(object) || $.isNumeric(object)
            };
        var isObject = function(object) {
                return $.type(object) === 'object'
            };
        var isArray = function(object) {
                return $.type(object) === 'array'
            };
        var isDate = function(object) {
                return $.type(object) === 'date'
            };
        var isFunction = function(object) {
                return $.type(object) === 'function'
            };
        var isPrimitive = function(value) {
                return $.inArray($.type(value), ["object", "array", "function"]) === -1
            };
        var isExponential = function(value) {
                return isNumber(value) && value.toString().indexOf('e') !== -1
            };
        var ensureDefined = function(value, defaultValue) {
                return isDefined(value) ? value : defaultValue
            };
        var getDefaultAlignment = function(isRtlEnabled) {
                var rtlEnabled = isRtlEnabled || DevExpress.rtlEnabled;
                return rtlEnabled ? "right" : "left"
            };
        var executeAsync = function(action, context) {
                var deferred = $.Deferred(),
                    normalizedContext = context || this,
                    timerId,
                    task = {
                        promise: deferred.promise(),
                        abort: function() {
                            clearTimeout(timerId);
                            deferred.rejectWith(normalizedContext)
                        }
                    },
                    callback = function() {
                        var result = action.call(normalizedContext);
                        if (result && result.done && $.isFunction(result.done))
                            result.done(function() {
                                deferred.resolveWith(normalizedContext)
                            });
                        else
                            deferred.resolveWith(normalizedContext)
                    };
                timerId = (arguments[2] || setTimeout)(callback, 0);
                return task
            };
        var findBestMatches = function(targetFilter, items, mapFn) {
                var bestMatches = [],
                    maxMatchCount = 0;
                $.each(items, function(index, itemSrc) {
                    var matchCount = 0,
                        item = mapFn ? mapFn(itemSrc) : itemSrc;
                    $.each(targetFilter, function(paramName) {
                        var value = item[paramName];
                        if (value === undefined)
                            return;
                        if (value === targetFilter[paramName]) {
                            matchCount++;
                            return
                        }
                        matchCount = -1;
                        return false
                    });
                    if (matchCount < maxMatchCount)
                        return;
                    if (matchCount > maxMatchCount) {
                        bestMatches.length = 0;
                        maxMatchCount = matchCount
                    }
                    bestMatches.push(itemSrc)
                });
                return bestMatches
            };
        var splitPair = function(raw) {
                switch (typeof raw) {
                    case"string":
                        return raw.split(/\s+/, 2);
                    case"object":
                        return [raw.x || raw.h, raw.y || raw.v];
                    case"number":
                        return [raw];
                    default:
                        return raw
                }
            };
        var splitQuad = function(raw) {
                switch (typeof raw) {
                    case"string":
                        return raw.split(/\s+/, 4);
                    case"object":
                        return [raw.x || raw.h || raw.left, raw.y || raw.v || raw.top, raw.x || raw.h || raw.right, raw.y || raw.v || raw.bottom];
                    case"number":
                        return [raw];
                    default:
                        return raw
                }
            };
        return {
                isDefined: isDefined,
                isString: isString,
                isNumber: isNumber,
                isObject: isObject,
                isArray: isArray,
                isDate: isDate,
                isFunction: isFunction,
                isPrimitive: isPrimitive,
                isExponential: isExponential,
                ensureDefined: ensureDefined,
                executeAsync: executeAsync,
                splitPair: splitPair,
                splitQuad: splitQuad,
                findBestMatches: findBestMatches,
                getDefaultAlignment: getDefaultAlignment
            }
    });
    /*! Module core, file utils.console.js */
    DevExpress.define("/utils/utils.console", ["jquery"], function($) {
        var logger = function() {
                var console = window.console;
                function info(text) {
                    if (!console || !$.isFunction(console.info))
                        return;
                    console.info(text)
                }
                function warn(text) {
                    if (!console || !$.isFunction(console.warn))
                        return;
                    console.warn(text)
                }
                function error(text) {
                    if (!console || !$.isFunction(console.error))
                        return;
                    console.error(text)
                }
                return {
                        info: info,
                        warn: warn,
                        error: error
                    }
            }();
        var debug = function() {
                function assert(condition, message) {
                    if (!condition)
                        throw new Error(message);
                }
                function assertParam(parameter, message) {
                    assert(parameter !== null && parameter !== undefined, message)
                }
                return {
                        assert: assert,
                        assertParam: assertParam
                    }
            }();
        return {
                logger: logger,
                debug: debug
            }
    });
    /*! Module core, file utils.date.js */
    DevExpress.define("/utils/utils.date", ["jquery", "/utils/utils.common", "/utils/utils.inflector"], function($, commonUtils, inflector) {
        var isObject = commonUtils.isObject,
            isString = commonUtils.isString,
            isDate = commonUtils.isDate,
            isDefined = commonUtils.isDefined,
            camelize = inflector.camelize;
        var dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'];
        var addSubValues = function(value1, value2, isSub) {
                return value1 + (isSub ? -1 : 1) * value2
            };
        var toMilliseconds = function(value) {
                switch (value) {
                    case'millisecond':
                        return 1;
                    case'second':
                        return toMilliseconds('millisecond') * 1000;
                    case'minute':
                        return toMilliseconds('second') * 60;
                    case'hour':
                        return toMilliseconds('minute') * 60;
                    case'day':
                        return toMilliseconds('hour') * 24;
                    case'week':
                        return toMilliseconds('day') * 7;
                    case'month':
                        return toMilliseconds('day') * 30;
                    case'quarter':
                        return toMilliseconds('month') * 3;
                    case'year':
                        return toMilliseconds('day') * 365;
                    default:
                        return 0
                }
            };
        var getDatesInterval = function(startDate, endDate, intervalUnit) {
                var delta = endDate.getTime() - startDate.getTime(),
                    millisecondCount = toMilliseconds(intervalUnit) || 1;
                return Math.floor(delta / millisecondCount)
            };
        var convertMillisecondsToDateUnits = function(value) {
                var i,
                    dateUnitCount,
                    dateUnitInterval,
                    dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'],
                    result = {};
                for (i = dateUnitIntervals.length - 1; i >= 0; i--) {
                    dateUnitInterval = dateUnitIntervals[i];
                    dateUnitCount = Math.floor(value / toMilliseconds(dateUnitInterval));
                    if (dateUnitCount > 0) {
                        result[dateUnitInterval + 's'] = dateUnitCount;
                        value -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount)
                    }
                }
                return result
            };
        var dateToMilliseconds = function(tickInterval) {
                var milliseconds = 0;
                if (isObject(tickInterval))
                    $.each(tickInterval, function(key, value) {
                        milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value)
                    });
                if (isString(tickInterval))
                    milliseconds = convertDateUnitToMilliseconds(tickInterval, 1);
                return milliseconds
            };
        var convertDateUnitToMilliseconds = function(dateUnit, count) {
                return toMilliseconds(dateUnit) * count
            };
        var getDateUnitInterval = function(tickInterval) {
                var maxInterval = -1,
                    i;
                if (isString(tickInterval))
                    return tickInterval;
                if (isObject(tickInterval)) {
                    $.each(tickInterval, function(key, value) {
                        for (i = 0; i < dateUnitIntervals.length; i++)
                            if (value && (key === dateUnitIntervals[i] + 's' || key === dateUnitIntervals[i]) && maxInterval < i)
                                maxInterval = i
                    });
                    return dateUnitIntervals[maxInterval]
                }
                return ''
            };
        var getQuarter = function(month) {
                return Math.floor(month / 3)
            };
        var getFirstQuarterMonth = function(month) {
                return getQuarter(month) * 3
            };
        var correctDateWithUnitBeginning = function(date, dateInterval, withCorrection) {
                var oldDate = new Date(date.getTime()),
                    dayMonth,
                    firstQuarterMonth,
                    dateUnitInterval = getDateUnitInterval(dateInterval);
                switch (dateUnitInterval) {
                    case'second':
                        date.setMilliseconds(0);
                        break;
                    case'minute':
                        date.setSeconds(0, 0);
                        break;
                    case'hour':
                        date.setMinutes(0, 0, 0);
                        break;
                    case'year':
                        date.setMonth(0);
                    case'month':
                        date.setDate(1);
                    case'day':
                        date.setHours(0, 0, 0, 0);
                        break;
                    case'week':
                        dayMonth = date.getDate();
                        if (date.getDay() !== 0)
                            dayMonth += 7 - date.getDay();
                        date.setDate(dayMonth);
                        date.setHours(0, 0, 0, 0);
                        break;
                    case'quarter':
                        firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
                        if (date.getMonth() !== firstQuarterMonth)
                            date.setMonth(firstQuarterMonth);
                        date.setDate(1);
                        date.setHours(0, 0, 0, 0);
                        break
                }
                if (withCorrection && dateUnitInterval !== "hour" && dateUnitInterval !== "minute" && dateUnitInterval !== "second")
                    fixTimezoneGap(oldDate, date)
            };
        var getDatesDifferences = function(date1, date2) {
                var differences,
                    counter = 0;
                differences = {
                    year: date1.getFullYear() !== date2.getFullYear(),
                    month: date1.getMonth() !== date2.getMonth(),
                    day: date1.getDate() !== date2.getDate(),
                    hour: date1.getHours() !== date2.getHours(),
                    minute: date1.getMinutes() !== date2.getMinutes(),
                    second: date1.getSeconds() !== date2.getSeconds()
                };
                $.each(differences, function(key, value) {
                    if (value)
                        counter++
                });
                differences.count = counter;
                return differences
            };
        var addInterval = function(value, interval, isNegative) {
                var result = null,
                    intervalObject;
                if (isDate(value)) {
                    intervalObject = isString(interval) ? getDateIntervalByString(interval.toLowerCase()) : interval;
                    result = new Date(value.getTime());
                    if (intervalObject.years)
                        result.setFullYear(addSubValues(result.getFullYear(), intervalObject.years, isNegative));
                    if (intervalObject.quarters)
                        result.setMonth(addSubValues(result.getMonth(), 3 * intervalObject.quarters, isNegative));
                    if (intervalObject.months)
                        result.setMonth(addSubValues(result.getMonth(), intervalObject.months, isNegative));
                    if (intervalObject.weeks)
                        result.setDate(addSubValues(result.getDate(), 7 * intervalObject.weeks, isNegative));
                    if (intervalObject.days)
                        result.setDate(addSubValues(result.getDate(), intervalObject.days, isNegative));
                    if (intervalObject.hours)
                        result.setHours(addSubValues(result.getHours(), intervalObject.hours, isNegative));
                    if (intervalObject.minutes)
                        result.setMinutes(addSubValues(result.getMinutes(), intervalObject.minutes, isNegative));
                    if (intervalObject.seconds)
                        result.setSeconds(addSubValues(result.getSeconds(), intervalObject.seconds, isNegative));
                    if (intervalObject.milliseconds)
                        result.setMilliseconds(addSubValues(value.getMilliseconds(), intervalObject.milliseconds, isNegative))
                }
                else
                    result = addSubValues(value, interval, isNegative);
                return result
            };
        var getViewFirstCellDate = function(viewType, date) {
                if (viewType === "month")
                    return new Date(date.getFullYear(), date.getMonth(), 1);
                if (viewType === "year")
                    return new Date(date.getFullYear(), 0, date.getDate());
                if (viewType === "decade")
                    return new Date(getFirstYearInDecade(date), date.getMonth(), date.getDate());
                if (viewType === "century")
                    return new Date(getFirstDecadeInCentury(date), date.getMonth(), date.getDate())
            };
        var getViewLastCellDate = function(viewType, date) {
                if (viewType === "month")
                    return new Date(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
                if (viewType === "year")
                    return new Date(date.getFullYear(), 11, date.getDate());
                if (viewType === "decade")
                    return new Date(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate());
                if (viewType === "century")
                    return new Date(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate())
            };
        var getViewMinBoundaryDate = function(viewType, date) {
                var resultDate = new Date(date.getFullYear(), date.getMonth(), 1);
                if (viewType === "month")
                    return resultDate;
                resultDate.setMonth(0);
                if (viewType === "year")
                    return resultDate;
                if (viewType === "decade")
                    resultDate.setFullYear(getFirstYearInDecade(date));
                if (viewType === "century")
                    resultDate.setFullYear(getFirstDecadeInCentury(date));
                return resultDate
            };
        var getViewMaxBoundaryDate = function(viewType, date) {
                var resultDate = new Date(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
                if (viewType === "month")
                    return resultDate;
                resultDate.setMonth(11);
                resultDate.setDate(getLastMonthDay(resultDate));
                if (viewType === "year")
                    return resultDate;
                if (viewType === "decade")
                    resultDate.setFullYear(getFirstYearInDecade(date) + 9);
                if (viewType === "century")
                    resultDate.setFullYear(getFirstDecadeInCentury(date) + 99);
                return resultDate
            };
        var getLastMonthDay = function(date) {
                var resultDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                return resultDate.getDate()
            };
        var sameView = function(view, date1, date2) {
                return dateUtils[camelize("same " + view)](date1, date2)
            };
        var getViewUp = function(typeView) {
                switch (typeView) {
                    case"month":
                        return "year";
                    case"year":
                        return "decade";
                    case"decade":
                        return "century";
                    default:
                        break
                }
            };
        var getViewDown = function(typeView) {
                switch (typeView) {
                    case"century":
                        return "decade";
                    case"decade":
                        return "year";
                    case"year":
                        return "month";
                    default:
                        break
                }
            };
        var getDifferenceInMonth = function(typeView) {
                var difference = 1;
                if (typeView === "year")
                    difference = 12;
                if (typeView === "decade")
                    difference = 12 * 10;
                if (typeView === "century")
                    difference = 12 * 100;
                return difference
            };
        var getDifferenceInMonthForCells = function(typeView) {
                var difference = 1;
                if (typeView === "decade")
                    difference = 12;
                if (typeView === "century")
                    difference = 12 * 10;
                return difference
            };
        var getDateIntervalByString = function(intervalString) {
                var result = {};
                switch (intervalString) {
                    case'year':
                        result.years = 1;
                        break;
                    case'month':
                        result.months = 1;
                        break;
                    case'quarter':
                        result.months = 3;
                        break;
                    case'week':
                        result.days = 7;
                        break;
                    case'day':
                        result.days = 1;
                        break;
                    case'hour':
                        result.hours = 1;
                        break;
                    case'minute':
                        result.minutes = 1;
                        break;
                    case'second':
                        result.seconds = 1;
                        break;
                    case'millisecond':
                        result.milliseconds = 1;
                        break
                }
                return result
            };
        var sameMonthAndYear = function(date1, date2) {
                return date1 && date2 && date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth()
            };
        var sameYear = function(date1, date2) {
                return date1 && date2 && date1.getFullYear() === date2.getFullYear()
            };
        var sameDecade = function(date1, date2) {
                if (!isDefined(date1) || !isDefined(date2))
                    return;
                var startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10,
                    startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
                return date1 && date2 && startDecadeDate1 === startDecadeDate2
            };
        var sameCentury = function(date1, date2) {
                if (!isDefined(date1) || !isDefined(date2))
                    return;
                var startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100,
                    startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
                return date1 && date2 && startCenturyDate1 === startCenturyDate2
            };
        var getFirstDecadeInCentury = function(date) {
                return date && date.getFullYear() - date.getFullYear() % 100
            };
        var getFirstYearInDecade = function(date) {
                return date && date.getFullYear() - date.getFullYear() % 10
            };
        var getShortDate = function(date) {
                return Globalize.format(date, "yyyy/M/d")
            };
        var getFirstMonthDate = function(date) {
                if (!isDefined(date))
                    return;
                var newDate = new Date(date.getFullYear(), date.getMonth(), 1);
                return newDate
            };
        var getLastMonthDate = function(date) {
                if (!isDefined(date))
                    return;
                var newDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                return newDate
            };
        var getFirstWeekDate = function(date, firstDayOfWeek) {
                firstDayOfWeek = firstDayOfWeek || Globalize.culture().calendar.firstDay;
                var delta = (date.getDay() - firstDayOfWeek + 7) % 7;
                var result = new Date(date);
                result.setDate(date.getDate() - delta);
                return result
            };
        var dateInRange = function(date, min, max, format) {
                if (format === "date") {
                    min = min && new Date(min.getFullYear(), min.getMonth(), min.getDate());
                    max = max && new Date(max.getFullYear(), max.getMonth(), max.getDate());
                    date = date && new Date(date.getFullYear(), date.getMonth(), date.getDate())
                }
                return normalizeDate(date, min, max) === date
            };
        var normalizeDate = function(date, min, max) {
                var normalizedDate = date;
                if (!isDefined(date))
                    return date;
                if (isDefined(min) && date < min)
                    normalizedDate = min;
                if (isDefined(max) && date > max)
                    normalizedDate = max;
                return normalizedDate
            };
        var fixTimezoneGap = function(oldDate, newDate) {
                if (!isDefined(oldDate))
                    return;
                var diff = newDate.getHours() - oldDate.getHours(),
                    sign,
                    trial;
                if (diff === 0)
                    return;
                sign = diff === 1 || diff === -23 ? -1 : 1,
                trial = new Date(newDate.getTime() + sign * 3600000);
                if (sign > 0 || trial.getDate() === newDate.getDate())
                    newDate.setTime(trial.getTime())
            };
        var makeDate = function(date) {
                if (!(date instanceof Date))
                    date = new Date(date);
                return date
            };
        var deserializeDate = function(value, serializationFormat) {
                var parsedValue;
                if (!serializationFormat || serializationFormat === "number" || serializationFormat === "yyyy/MM/dd") {
                    parsedValue = serializationFormat === "number" ? value : !isDate(value) && Date.parse(value);
                    return parsedValue ? new Date(parsedValue) : value
                }
                if (value !== undefined)
                    return Globalize.parseDate(value, serializationFormat)
            };
        var serializeDate = function(value, serializationFormat) {
                if (serializationFormat === "number")
                    return value && value.valueOf && value.valueOf();
                if (serializationFormat)
                    return Globalize.format(value, serializationFormat);
                return value
            };
        var dateUtils = {
                dateUnitIntervals: dateUnitIntervals,
                convertMillisecondsToDateUnits: convertMillisecondsToDateUnits,
                dateToMilliseconds: dateToMilliseconds,
                convertDateUnitToMilliseconds: convertDateUnitToMilliseconds,
                getDateUnitInterval: getDateUnitInterval,
                getDatesDifferences: getDatesDifferences,
                correctDateWithUnitBeginning: correctDateWithUnitBeginning,
                addInterval: addInterval,
                getDateIntervalByString: getDateIntervalByString,
                sameMonthAndYear: sameMonthAndYear,
                sameMonth: sameMonthAndYear,
                sameYear: sameYear,
                sameDecade: sameDecade,
                sameCentury: sameCentury,
                sameView: sameView,
                getDifferenceInMonth: getDifferenceInMonth,
                getDifferenceInMonthForCells: getDifferenceInMonthForCells,
                getFirstYearInDecade: getFirstYearInDecade,
                getFirstDecadeInCentury: getFirstDecadeInCentury,
                getShortDate: getShortDate,
                getViewFirstCellDate: getViewFirstCellDate,
                getViewLastCellDate: getViewLastCellDate,
                getViewDown: getViewDown,
                getViewUp: getViewUp,
                getLastMonthDay: getLastMonthDay,
                getLastMonthDate: getLastMonthDate,
                getFirstMonthDate: getFirstMonthDate,
                getFirstWeekDate: getFirstWeekDate,
                getQuarter: getQuarter,
                getFirstQuarterMonth: getFirstQuarterMonth,
                dateInRange: dateInRange,
                normalizeDate: normalizeDate,
                getViewMinBoundaryDate: getViewMinBoundaryDate,
                getViewMaxBoundaryDate: getViewMaxBoundaryDate,
                fixTimezoneGap: fixTimezoneGap,
                makeDate: makeDate,
                deserializeDate: deserializeDate,
                serializeDate: serializeDate,
                getDatesInterval: getDatesInterval
            };
        return dateUtils
    });
    /*! Module core, file utils.dom.js */
    DevExpress.define("/utils/utils.dom", ["jquery", "/errors", "/utils/utils.support", "/utils/utils.window", "/utils/utils.common", "/devices"], function($, errors, support, windowUtils, commonUtils, devices) {
        var resetActiveElement = function() {
                var activeElement = document.activeElement;
                if (activeElement && activeElement !== document.body && activeElement.blur)
                    activeElement.blur()
            };
        var clearSelection = function() {
                if (window.getSelection) {
                    if (window.getSelection().empty)
                        window.getSelection().empty();
                    else if (window.getSelection().removeAllRanges)
                        window.getSelection().removeAllRanges()
                }
                else if (document.selection)
                    document.selection.empty()
            };
        var closestCommonParent = function(startTarget, endTarget) {
                var $startParents = $(startTarget).parents().addBack(),
                    $endParents = $(endTarget).parents().addBack(),
                    startingParent = Math.min($startParents.length, $endParents.length) - 1;
                for (var i = startingParent; i >= 0; i--)
                    if ($startParents.eq(i).is($endParents.eq(i)))
                        return $startParents.get(i)
            };
        var initMobileViewport = function(options) {
                options = $.extend({}, options);
                var realDevice = devices.real();
                var allowZoom = options.allowZoom;
                var allowPan = options.allowPan;
                var allowSelection = "allowSelection" in options ? options.allowSelection : realDevice.platform === "generic";
                var metaSelector = "meta[name=viewport]";
                if (!$(metaSelector).length)
                    $("<meta />").attr("name", "viewport").appendTo("head");
                var metaVerbs = ["width=device-width"],
                    msTouchVerbs = [];
                if (allowZoom)
                    msTouchVerbs.push("pinch-zoom");
                else
                    metaVerbs.push("initial-scale=1.0", "maximum-scale=1.0, user-scalable=no");
                if (allowPan)
                    msTouchVerbs.push("pan-x", "pan-y");
                if (!allowPan && !allowZoom)
                    $("html, body").css({
                        "-ms-content-zooming": "none",
                        "-ms-user-select": "none",
                        overflow: "hidden"
                    });
                else
                    $("html").css("-ms-overflow-style", "-ms-autohiding-scrollbar");
                if (!allowSelection && support.supportProp("user-select"))
                    $(".dx-viewport").css(support.styleProp("user-select"), "none");
                $(metaSelector).attr("content", metaVerbs.join());
                $("html").css("-ms-touch-action", msTouchVerbs.join(" ") || "none");
                if (support.touch)
                    $(document).off(".dxInitMobileViewport").on("dxpointermove.dxInitMobileViewport", function(e) {
                        var count = e.pointers.length,
                            isTouchEvent = e.pointerType === "touch",
                            zoomDisabled = !allowZoom && count > 1,
                            panDisabled = !allowPan && count === 1 && !e.isScrollingEvent;
                        if (isTouchEvent && (zoomDisabled || panDisabled))
                            e.preventDefault()
                    });
                realDevice = devices.real();
                if (realDevice.ios) {
                    var isPhoneGap = document.location.protocol === "file:";
                    if (!isPhoneGap)
                        windowUtils.resizeCallbacks.add(function() {
                            var windowWidth = $(window).width();
                            $("body").width(windowWidth)
                        })
                }
                if (realDevice.android)
                    windowUtils.resizeCallbacks.add(function() {
                        document.activeElement.scrollIntoViewIfNeeded()
                    })
            };
        var triggerVisibilityChangeEvent = function(eventName) {
                var VISIBILITY_CHANGE_SELECTOR = ".dx-visibility-change-handler";
                return function(element) {
                        var $element = $(element || "body");
                        var $changeHandlers = $element.find(VISIBILITY_CHANGE_SELECTOR).add($element.filter(VISIBILITY_CHANGE_SELECTOR));
                        $changeHandlers.each(function() {
                            $(this).triggerHandler(eventName)
                        })
                    }
            };
        var uniqueId = function() {
                var counter = 0;
                return function(prefix) {
                        return (prefix || "") + counter++
                    }
            }();
        var dataOptionsAttributeName = "data-options";
        var getElementOptions = function(element) {
                var optionsString = $(element).attr(dataOptionsAttributeName),
                    result;
                if ($.trim(optionsString).charAt(0) !== "{")
                    optionsString = "{" + optionsString + "}";
                try {
                    result = new Function("return " + optionsString)()
                }
                catch(ex) {
                    throw errors.Error("E3018", ex, optionsString);
                }
                return result
            };
        var createComponents = function(elements, componentTypes) {
                var result = [],
                    selector = "[" + dataOptionsAttributeName + "]";
                elements.find(selector).addBack(selector).each(function(index, element) {
                    var $element = $(element),
                        options = getElementOptions(element);
                    for (var componentName in options)
                        if (!componentTypes || $.inArray(componentName, componentTypes) > -1)
                            if ($element[componentName]) {
                                $element[componentName](options[componentName]);
                                result.push($element[componentName]("instance"))
                            }
                });
                return result
            };
        var createMarkupFromString = function(str) {
                var tempElement = $("<div />");
                if (window.WinJS)
                    WinJS.Utilities.setInnerHTMLUnsafe(tempElement.get(0), str);
                else
                    tempElement.append(str);
                return tempElement.contents()
            };
        var normalizeTemplateElement = function(element) {
                var $element = commonUtils.isDefined(element) && (element.nodeType || element.jquery) ? $(element) : $("<div>").html(element).contents();
                if ($element.length === 1 && $element.is("script"))
                    $element = normalizeTemplateElement(element.html());
                return $element
            };
        var toggleAttr = function($target, attr, value) {
                value ? $target.attr(attr, value) : $target.removeAttr(attr)
            };
        var clipboardText = function(event, text) {
                var clipboard = event.originalEvent && event.originalEvent.clipboardData || window.clipboardData;
                if (arguments.length === 1)
                    return clipboard && clipboard.getData("Text");
                clipboard && clipboard.setData("Text", text)
            };
        return {
                resetActiveElement: resetActiveElement,
                createMarkupFromString: createMarkupFromString,
                triggerShownEvent: triggerVisibilityChangeEvent("dxshown"),
                triggerHidingEvent: triggerVisibilityChangeEvent("dxhiding"),
                triggerResizeEvent: triggerVisibilityChangeEvent("dxresize"),
                initMobileViewport: initMobileViewport,
                getElementOptions: getElementOptions,
                createComponents: createComponents,
                normalizeTemplateElement: normalizeTemplateElement,
                clearSelection: clearSelection,
                uniqueId: uniqueId,
                closestCommonParent: closestCommonParent,
                clipboardText: clipboardText,
                toggleAttr: toggleAttr
            }
    });
    /*! Module core, file utils.error.js */
    DevExpress.define("/utils/utils.error", ["jquery", "/utils/utils.console", "/utils/utils.string", "/version"], function($, consoleUtils, stringUtils, version) {
        var ERROR_URL = "http://js.devexpress.com/error/" + version.split(".").slice(0, 2).join("_") + "/";
        return function(baseErrors, errors) {
                var exports = {
                        ERROR_MESSAGES: $.extend(errors, baseErrors),
                        Error: function() {
                            return makeError($.makeArray(arguments))
                        },
                        log: function(id) {
                            var method = "log";
                            if (/^E\d+$/.test(id))
                                method = "error";
                            else if (/^W\d+$/.test(id))
                                method = "warn";
                            consoleUtils.logger[method](method === "log" ? id : combineMessage($.makeArray(arguments)))
                        }
                    };
                var combineMessage = function(args) {
                        var id = args[0];
                        args = args.slice(1);
                        return formatMessage(id, formatDetails(id, args))
                    };
                var formatDetails = function(id, args) {
                        args = [exports.ERROR_MESSAGES[id]].concat(args);
                        return stringUtils.format.apply(this, args).replace(/\.*\s*?$/, '')
                    };
                var formatMessage = function(id, details) {
                        return stringUtils.format.apply(this, ["{0} - {1}. See:\n{2}", id, details, ERROR_URL + id])
                    };
                var makeError = function(args) {
                        var id,
                            details,
                            message;
                        id = args[0];
                        args = args.slice(1);
                        details = formatDetails(id, args);
                        message = formatMessage(id, details);
                        return $.extend(new Error(message), {
                                __id: id,
                                __details: details
                            })
                    };
                return exports
            }
    });
    /*! Module core, file utils.formatHelper.js */
    DevExpress.define("/utils/utils.formatHelper", ["jquery", "/utils/utils.common", "/utils/utils.string", "/utils/utils.date"], function($, commonUtils, stringUtils, dateUtils) {
        var MAX_LARGE_NUMBER_POWER = 4,
            DECIMAL_BASE = 10;
        var NumericFormat = {
                currency: 'C',
                fixedpoint: 'N',
                exponential: '',
                percent: 'P',
                decimal: 'D'
            };
        var LargeNumberFormatPostfixes = {
                1: 'K',
                2: 'M',
                3: 'B',
                4: 'T'
            };
        var LargeNumberFormatPowers = {
                largenumber: 'auto',
                thousands: 1,
                millions: 2,
                billions: 3,
                trillions: 4
            };
        var DateTimeFormat = {
                longdate: 'D',
                longtime: 'T',
                monthandday: 'M',
                monthandyear: 'Y',
                quarterandyear: 'qq',
                shortdate: 'd',
                shorttime: 't',
                millisecond: 'fff',
                second: 'T',
                minute: 't',
                hour: 't',
                day: 'dd',
                week: 'dd',
                month: 'MMMM',
                quarter: 'qq',
                year: 'yyyy',
                longdatelongtime: 'D',
                shortdateshorttime: 'd',
                shortyear: 'yy'
            };
        var formatHelper = {
                defaultQuarterFormat: 'Q{0}',
                defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
                defaultDateTimeFormat: DateTimeFormat,
                romanDigits: ['I', 'II', 'III', 'IV'],
                _addFormatSeparator: function(format1, format2) {
                    var separator = ' ';
                    if (format2)
                        return format1 + separator + format2;
                    return format1
                },
                _getDateTimeFormatPattern: function(dateTimeFormat) {
                    return Globalize.findClosestCulture().calendar.patterns[DateTimeFormat[dateTimeFormat.toLowerCase()]]
                },
                _isDateFormatContains: function(format) {
                    return format.toLowerCase() in DateTimeFormat
                },
                _getQuarterString: function(date, format) {
                    var quarter = dateUtils.getQuarter(date.getMonth());
                    switch (format) {
                        case'q':
                            return formatHelper.romanDigits[quarter];
                        case'qq':
                            return stringUtils.format(formatHelper.defaultQuarterFormat, formatHelper.romanDigits[quarter]);
                        case'Q':
                            return (quarter + 1).toString();
                        case'QQ':
                            return stringUtils.format(formatHelper.defaultQuarterFormat, (quarter + 1).toString())
                    }
                    return ''
                },
                _formatCustomString: function(value, format) {
                    var regExp = /qq|q|QQ|Q/g,
                        quarterFormat,
                        result = '',
                        index = 0;
                    regExp.lastIndex = 0;
                    while (index < format.length) {
                        quarterFormat = regExp.exec(format);
                        if (!quarterFormat || quarterFormat.index > index)
                            result += Globalize.format(value, format.substring(index, quarterFormat ? quarterFormat.index : format.length));
                        if (quarterFormat) {
                            result += formatHelper._getQuarterString(value, quarterFormat[0]);
                            index = quarterFormat.index + quarterFormat[0].length
                        }
                        else
                            index = format.length
                    }
                    return result
                },
                _parseNumberFormatString: function(format) {
                    var formatList,
                        formatObject = {};
                    if (!format || typeof format !== 'string')
                        return;
                    formatList = format.toLowerCase().split(' ');
                    $.each(formatList, function(index, value) {
                        if (value in NumericFormat)
                            formatObject.formatType = value;
                        else if (value in LargeNumberFormatPowers)
                            formatObject.power = LargeNumberFormatPowers[value]
                    });
                    if (formatObject.power && !formatObject.formatType)
                        formatObject.formatType = 'fixedpoint';
                    if (formatObject.formatType)
                        return formatObject
                },
                _calculateNumberPower: function(value, base, minPower, maxPower) {
                    var number = Math.abs(value);
                    var power = 0;
                    if (number > 1)
                        while (number && number >= base && (maxPower === undefined || power < maxPower)) {
                            power++;
                            number = number / base
                        }
                    else if (number > 0 && number < 1)
                        while (number < 1 && (minPower === undefined || power > minPower)) {
                            power--;
                            number = number * base
                        }
                    return power
                },
                _getNumberByPower: function(number, power, base) {
                    var result = number;
                    while (power > 0) {
                        result = result / base;
                        power--
                    }
                    while (power < 0) {
                        result = result * base;
                        power++
                    }
                    return result
                },
                _formatNumber: function(value, formatObject, precision) {
                    var powerPostfix;
                    if (formatObject.power === 'auto')
                        formatObject.power = formatHelper._calculateNumberPower(value, 1000, 0, MAX_LARGE_NUMBER_POWER);
                    if (formatObject.power)
                        value = formatHelper._getNumberByPower(value, formatObject.power, 1000);
                    powerPostfix = formatHelper.defaultLargeNumberFormatPostfixes[formatObject.power] || '';
                    return formatHelper._formatNumberCore(value, formatObject.formatType, precision) + powerPostfix
                },
                _formatNumberExponential: function(value, precision) {
                    var power = formatHelper._calculateNumberPower(value, DECIMAL_BASE),
                        number = formatHelper._getNumberByPower(value, power, DECIMAL_BASE),
                        powString;
                    precision = precision === undefined ? 1 : precision;
                    if (number.toFixed(precision || 0) >= DECIMAL_BASE) {
                        power++;
                        number = number / DECIMAL_BASE
                    }
                    powString = (power >= 0 ? '+' : '') + power.toString();
                    return formatHelper._formatNumberCore(number, 'fixedpoint', precision) + 'E' + powString
                },
                _formatNumberCore: function(value, format, precision) {
                    if (format === 'exponential')
                        return formatHelper._formatNumberExponential(value, precision);
                    else
                        return Globalize.format(value, NumericFormat[format] + (commonUtils.isNumber(precision) ? precision : 0))
                },
                _formatDate: function(date, format) {
                    var resultFormat = DateTimeFormat[format.toLowerCase()];
                    format = format.toLowerCase();
                    if (format === 'quarterandyear')
                        resultFormat = formatHelper._getQuarterString(date, resultFormat) + ' yyyy';
                    if (format === 'quarter')
                        return formatHelper._getQuarterString(date, resultFormat);
                    if (format === 'longdatelongtime')
                        return formatHelper._formatDate(date, 'longdate') + ' ' + formatHelper._formatDate(date, 'longtime');
                    if (format === 'shortdateshorttime')
                        return formatHelper._formatDate(date, 'shortDate') + ' ' + formatHelper._formatDate(date, 'shortTime');
                    return Globalize.format(date, resultFormat)
                },
                format: function(value, format, precision) {
                    if ($.isPlainObject(format) && format.format)
                        if (format.dateType)
                            return formatHelper._formatDateEx(value, format);
                        else if (commonUtils.isNumber(value) && isFinite(value))
                            return formatHelper._formatNumberEx(value, format);
                    return formatHelper._format(value, format, precision)
                },
                _format: function(value, format, precision) {
                    var numberFormatObject;
                    if (!commonUtils.isString(format) || format === '' || !commonUtils.isNumber(value) && !commonUtils.isDate(value))
                        return commonUtils.isDefined(value) ? value.toString() : '';
                    numberFormatObject = formatHelper._parseNumberFormatString(format);
                    if (commonUtils.isNumber(value) && numberFormatObject)
                        return formatHelper._formatNumber(value, numberFormatObject, precision);
                    if (commonUtils.isDate(value) && formatHelper._isDateFormatContains(format))
                        return formatHelper._formatDate(value, format);
                    if (!numberFormatObject && !formatHelper._isDateFormatContains(format))
                        return formatHelper._formatCustomString(value, format)
                },
                _formatNumberEx: function(value, formatInfo) {
                    var that = formatHelper,
                        numericFormatType = NumericFormat[formatInfo.format.toLowerCase()],
                        numberFormat = Globalize.culture().numberFormat,
                        currencyFormat = formatInfo.currencyCulture && Globalize.cultures[formatInfo.currencyCulture] ? Globalize.cultures[formatInfo.currencyCulture].numberFormat.currency : numberFormat.currency,
                        percentFormat = numberFormat.percent,
                        formatSettings = that._getUnitFormatSettings(value, formatInfo),
                        unitPower = formatSettings.unitPower,
                        precision = formatSettings.precision,
                        showTrailingZeros = formatSettings.showTrailingZeros,
                        includeGroupSeparator = formatSettings.includeGroupSeparator,
                        groupSymbol = numberFormat[","],
                        floatingSymbol = numberFormat["."],
                        number,
                        isNegative,
                        pattern,
                        currentFormat,
                        regexParts = /n|\$|-|%/g,
                        result = "";
                    if (!commonUtils.isDefined(value))
                        return '';
                    value = formatHelper._getNumberByPower(value, unitPower, 1000);
                    number = Math.abs(value);
                    isNegative = value < 0;
                    switch (numericFormatType) {
                        case NumericFormat.decimal:
                            pattern = "n";
                            number = Math[isNegative ? "ceil" : "floor"](number);
                            if (precision > 0) {
                                var str = "" + number;
                                for (var i = str.length; i < precision; i += 1)
                                    str = "0" + str;
                                number = str
                            }
                            if (isNegative)
                                number = "-" + number;
                            break;
                        case NumericFormat.fixedpoint:
                            currentFormat = numberFormat;
                        case NumericFormat.currency:
                            currentFormat = currentFormat || currencyFormat;
                        case NumericFormat.percent:
                            currentFormat = currentFormat || percentFormat;
                            pattern = isNegative ? currentFormat.pattern[0] : currentFormat.pattern[1] || "n";
                            number = Globalize.format(number * (numericFormatType === NumericFormat.percent ? 100 : 1), "N" + precision);
                            if (!showTrailingZeros)
                                number = that._excludeTrailingZeros(number, floatingSymbol);
                            if (!includeGroupSeparator)
                                number = number.replace(new RegExp('\\' + groupSymbol, 'g'), '');
                            break;
                        case NumericFormat.exponential:
                            return that._formatNumberExponential(value, precision);
                        default:
                            throw"Illegal numeric format: '" + numericFormatType + "'";
                    }
                    for (; ; ) {
                        var lastIndex = regexParts.lastIndex,
                            matches = regexParts.exec(pattern);
                        result += pattern.slice(lastIndex, matches ? matches.index : pattern.length);
                        if (matches)
                            switch (matches[0]) {
                                case"-":
                                    if (/[1-9]/.test(number))
                                        result += numberFormat["-"];
                                    break;
                                case"$":
                                    result += currencyFormat.symbol;
                                    break;
                                case"%":
                                    result += percentFormat.symbol;
                                    break;
                                case"n":
                                    result += number + (unitPower > 0 ? formatHelper.defaultLargeNumberFormatPostfixes[unitPower] : "");
                                    break
                            }
                        else
                            break
                    }
                    return (formatInfo.plus && value > 0 ? "+" : '') + result
                },
                _excludeTrailingZeros: function(strValue, floatingSymbol) {
                    var floatingIndex = strValue.indexOf(floatingSymbol),
                        stopIndex,
                        i;
                    if (floatingIndex < 0)
                        return strValue;
                    stopIndex = strValue.length;
                    for (i = stopIndex - 1; i >= floatingIndex && (strValue[i] === '0' || i === floatingIndex); i--)
                        stopIndex--;
                    return strValue.substring(0, stopIndex)
                },
                _getUnitFormatSettings: function(value, formatInfo) {
                    var unitPower = formatInfo.unitPower || '',
                        precision = formatInfo.precision || 0,
                        includeGroupSeparator = formatInfo.includeGroupSeparator || false,
                        showTrailingZeros = formatInfo.showTrailingZeros === undefined ? true : formatInfo.showTrailingZeros,
                        significantDigits = formatInfo.significantDigits || 1,
                        absValue;
                    if (unitPower.toString().toLowerCase() === 'auto') {
                        showTrailingZeros = false;
                        absValue = Math.abs(value);
                        if (significantDigits < 1)
                            significantDigits = 1;
                        if (absValue >= 1000000000) {
                            unitPower = 3;
                            absValue /= 1000000000
                        }
                        else if (absValue >= 1000000) {
                            unitPower = 2;
                            absValue /= 1000000
                        }
                        else if (absValue >= 1000) {
                            unitPower = 1;
                            absValue /= 1000
                        }
                        else
                            unitPower = 0;
                        if (absValue === 0)
                            precision = 0;
                        else if (absValue < 1) {
                            precision = significantDigits;
                            var smallValue = Math.pow(10, -significantDigits);
                            while (absValue < smallValue) {
                                smallValue /= 10;
                                precision++
                            }
                        }
                        else if (absValue >= 100)
                            precision = significantDigits - 3;
                        else if (absValue >= 10)
                            precision = significantDigits - 2;
                        else
                            precision = significantDigits - 1
                    }
                    if (precision < 0)
                        precision = 0;
                    return {
                            unitPower: unitPower,
                            precision: precision,
                            showTrailingZeros: showTrailingZeros,
                            includeGroupSeparator: includeGroupSeparator
                        }
                },
                _formatDateEx: function(value, formatInfo) {
                    var that = formatHelper,
                        format = formatInfo.format,
                        dateType = formatInfo.dateType,
                        calendar = Globalize.culture().calendars.standard,
                        time,
                        index,
                        dateStr;
                    format = format.toLowerCase();
                    if (!commonUtils.isDefined(value))
                        return '';
                    if (dateType !== 'num' || format === 'dayofweek')
                        switch (format) {
                            case'monthyear':
                                return that._formatDate(value, 'monthandyear');
                            case'quarteryear':
                                return that._getQuarterString(value, 'QQ') + ' ' + value.getFullYear();
                            case'daymonthyear':
                                return that._formatDate(value, dateType + 'Date');
                            case'datehour':
                                time = new Date(value.getTime());
                                time.setMinutes(0);
                                dateStr = dateType === 'timeOnly' ? '' : that._formatDate(value, dateType + 'Date');
                                return dateType === 'timeOnly' ? that._formatDate(time, 'shorttime') : dateStr + ' ' + that._formatDate(time, 'shorttime');
                            case'datehourminute':
                                dateStr = dateType === 'timeOnly' ? '' : that._formatDate(value, dateType + 'Date');
                                return dateType === 'timeOnly' ? that._formatDate(value, 'shorttime') : dateStr + ' ' + that._formatDate(value, 'shorttime');
                            case'datehourminutesecond':
                                dateStr = dateType === 'timeOnly' ? '' : that._formatDate(value, dateType + 'Date');
                                return dateType === 'timeOnly' ? that._formatDate(value, 'longtime') : dateStr + ' ' + that._formatDate(value, 'longtime');
                            case'year':
                                dateStr = value.toString();
                                return dateType === 'abbr' ? dateStr.slice(2, 4) : dateStr;
                            case'dateyear':
                                return dateType === 'abbr' ? that._formatDate(value, 'shortyear') : that._formatDate(value, 'year');
                            case'quarter':
                                return stringUtils.format(that.defaultQuarterFormat, value.toString());
                            case'month':
                                index = value - 1;
                                return dateType === 'abbr' ? calendar.months.namesAbbr[index] : calendar.months.names[index];
                            case'hour':
                                if (dateType === 'long') {
                                    time = new Date;
                                    time.setHours(value);
                                    time.setMinutes(0);
                                    return that._formatDate(time, 'shorttime')
                                }
                                return value.toString();
                            case'dayofweek':
                                index = commonUtils.isString(value) ? $.inArray(value, ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']) : value;
                                if (dateType !== 'num')
                                    return dateType === 'abbr' ? calendar.days.namesAbbr[index] : calendar.days.names[index];
                                return ((index - calendar.firstDay + 1 + 7) % 8).toString();
                            default:
                                return value.toString()
                        }
                    else
                        return value.toString()
                },
                getTimeFormat: function(showSecond) {
                    if (showSecond)
                        return formatHelper._getDateTimeFormatPattern('longtime');
                    return formatHelper._getDateTimeFormatPattern('shorttime')
                },
                getDateFormatByDifferences: function(dateDifferences) {
                    var resultFormat = '';
                    if (dateDifferences.millisecond)
                        resultFormat = DateTimeFormat.millisecond;
                    if (dateDifferences.hour || dateDifferences.minute || dateDifferences.second)
                        resultFormat = formatHelper._addFormatSeparator(formatHelper.getTimeFormat(dateDifferences.second), resultFormat);
                    if (dateDifferences.year && dateDifferences.month && dateDifferences.day)
                        return formatHelper._addFormatSeparator(formatHelper._getDateTimeFormatPattern('shortdate'), resultFormat);
                    if (dateDifferences.year && dateDifferences.month)
                        return DateTimeFormat['monthandyear'];
                    if (dateDifferences.year)
                        return DateTimeFormat['year'];
                    if (dateDifferences.month && dateDifferences.day)
                        return formatHelper._addFormatSeparator(formatHelper._getDateTimeFormatPattern('monthandday'), resultFormat);
                    if (dateDifferences.month)
                        return DateTimeFormat['month'];
                    if (dateDifferences.day)
                        return formatHelper._addFormatSeparator('dddd, dd', resultFormat);
                    return resultFormat
                },
                getDateFormatByTicks: function(ticks) {
                    var resultFormat,
                        maxDif,
                        currentDif,
                        i;
                    if (ticks.length > 1) {
                        maxDif = dateUtils.getDatesDifferences(ticks[0], ticks[1]);
                        for (i = 1; i < ticks.length - 1; i++) {
                            currentDif = dateUtils.getDatesDifferences(ticks[i], ticks[i + 1]);
                            if (maxDif.count < currentDif.count)
                                maxDif = currentDif
                        }
                    }
                    else
                        maxDif = {
                            year: true,
                            month: true,
                            day: true,
                            hour: ticks[0].getHours() > 0,
                            minute: ticks[0].getMinutes() > 0,
                            second: ticks[0].getSeconds() > 0
                        };
                    resultFormat = formatHelper.getDateFormatByDifferences(maxDif);
                    return resultFormat
                },
                getDateFormatByTickInterval: function(startValue, endValue, tickInterval) {
                    var resultFormat,
                        dateDifferences,
                        dateUnitInterval,
                        dateDifferencesConverter = {
                            quarter: 'month',
                            week: 'day'
                        },
                        correctDateDifferences = function(dateDifferences, tickInterval, value) {
                            switch (tickInterval) {
                                case'year':
                                    dateDifferences.month = value;
                                case'quarter':
                                case'month':
                                    dateDifferences.day = value;
                                case'week':
                                case'day':
                                    dateDifferences.hour = value;
                                case'hour':
                                    dateDifferences.minute = value;
                                case'minute':
                                    dateDifferences.second = value;
                                case'second':
                                    dateDifferences.millisecond = value
                            }
                        },
                        correctDifferencesByMaxDate = function(differences, minDate, maxDate) {
                            if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
                                if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
                                    differences.millisecond = true;
                                    differences.second = false
                                }
                            }
                            else if (!maxDate.getSeconds() && maxDate.getMinutes()) {
                                if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
                                    differences.second = true;
                                    differences.minute = false
                                }
                            }
                            else if (!maxDate.getMinutes() && maxDate.getHours()) {
                                if (maxDate.getHours() - minDate.getHours() === 1) {
                                    differences.minute = true;
                                    differences.hour = false
                                }
                            }
                            else if (!maxDate.getHours() && maxDate.getDate() > 1) {
                                if (maxDate.getDate() - minDate.getDate() === 1) {
                                    differences.hour = true;
                                    differences.day = false
                                }
                            }
                            else if (maxDate.getDate() === 1 && maxDate.getMonth()) {
                                if (maxDate.getMonth() - minDate.getMonth() === 1) {
                                    differences.day = true;
                                    differences.month = false
                                }
                            }
                            else if (!maxDate.getMonth() && maxDate.getFullYear())
                                if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
                                    differences.month = true;
                                    differences.year = false
                                }
                        };
                    tickInterval = commonUtils.isString(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
                    dateDifferences = dateUtils.getDatesDifferences(startValue, endValue);
                    if (startValue !== endValue)
                        correctDifferencesByMaxDate(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue);
                    dateUnitInterval = dateUtils.getDateUnitInterval(dateDifferences);
                    correctDateDifferences(dateDifferences, dateUnitInterval, true);
                    dateUnitInterval = dateUtils.getDateUnitInterval(tickInterval || 'second');
                    correctDateDifferences(dateDifferences, dateUnitInterval, false);
                    dateDifferences[dateDifferencesConverter[dateUnitInterval] || dateUnitInterval] = true;
                    resultFormat = formatHelper.getDateFormatByDifferences(dateDifferences);
                    return resultFormat
                }
            };
        return formatHelper
    });
    /*! Module core, file utils.hardwareBack.js */
    DevExpress.define("/utils/utils.hardwareBack", ["jquery"], function($) {
        var hardwareBack = $.Callbacks();
        return {
                process: function() {
                    hardwareBack.fire()
                },
                processCallback: hardwareBack
            }
    });
    /*! Module core, file utils.icon.js */
    DevExpress.define("/utils/utils.icon", ["jquery"], function($) {
        var getImageSourceType = function(source) {
                if (!source || typeof source !== "string")
                    return false;
                if (/data:.*base64|\.|\//.test(source))
                    return "image";
                if (/^[\w-_]+$/.test(source))
                    return "dxIcon";
                return "fontIcon"
            };
        var getImageContainer = function(source) {
                var imageType = getImageSourceType(source),
                    ICON_CLASS = "dx-icon";
                switch (imageType) {
                    case"image":
                        return $("<img>", {src: source}).addClass(ICON_CLASS);
                    case"fontIcon":
                        return $("<i>", {"class": ICON_CLASS + " " + source});
                    case"dxIcon":
                        return $("<i>", {"class": ICON_CLASS + " " + ICON_CLASS + "-" + source});
                    default:
                        return null
                }
            };
        return {
                getImageSourceType: getImageSourceType,
                getImageContainer: getImageContainer
            }
    });
    /*! Module core, file utils.inflector.js */
    DevExpress.define("/utils/utils.inflector", ["jquery"], function($) {
        var _normalize = function(text) {
                if (text === undefined || text === null)
                    return "";
                return String(text)
            };
        var _ucfirst = function(text) {
                return _normalize(text).charAt(0).toUpperCase() + text.substr(1)
            };
        var _chop = function(text) {
                return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/)
            };
        var dasherize = function(text) {
                return $.map(_chop(text), function(p) {
                        return p.toLowerCase()
                    }).join("-")
            };
        var underscore = function(text) {
                return dasherize(text).replace(/-/g, "_")
            };
        var camelize = function(text, upperFirst) {
                return $.map(_chop(text), function(p, i) {
                        p = p.toLowerCase();
                        if (upperFirst || i > 0)
                            p = _ucfirst(p);
                        return p
                    }).join("")
            };
        var humanize = function(text) {
                return _ucfirst(dasherize(text).replace(/-/g, " "))
            };
        var titleize = function(text) {
                return $.map(_chop(text), function(p) {
                        return _ucfirst(p.toLowerCase())
                    }).join(" ")
            };
        var captionize = function(name) {
                var captionList = [],
                    i,
                    char,
                    isPrevCharNewWord = false,
                    isNewWord = false;
                for (i = 0; i < name.length; i++) {
                    char = name.charAt(i);
                    isNewWord = char === char.toUpperCase() || char in ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
                    if (char === "_" || char === ".") {
                        char = " ";
                        isNewWord = true
                    }
                    else if (i === 0) {
                        char = char.toUpperCase();
                        isNewWord = true
                    }
                    else if (!isPrevCharNewWord && isNewWord)
                        if (captionList.length > 0)
                            captionList.push(" ");
                    captionList.push(char);
                    isPrevCharNewWord = isNewWord
                }
                return captionList.join("")
            };
        return {
                dasherize: dasherize,
                camelize: camelize,
                humanize: humanize,
                titleize: titleize,
                underscore: underscore,
                captionize: captionize
            }
    });
    /*! Module core, file utils.inkRipple.js */
    DevExpress.define("/utils/utils.inkRipple", ["jquery", "/action"], function($, Action) {
        var DX = DevExpress,
            fx = DX.fx;
        var INKRIPPLE_CLASS = "dx-inkripple",
            INKRIPPLE_WAVE_CLASS = "dx-inkripple-wave",
            INKRIPPLE_REMOVING_CLASS = "dx-inkripple-removing";
        var DEFAULT_WAVE_SIZE_COEFFICIENT = 2.8,
            MAX_WAVE_SIZE = 4000;
        var render = function(args) {
                args = args || {};
                var config = {
                        waveSizeCoefficient: args.waveSizeCoefficient || DEFAULT_WAVE_SIZE_COEFFICIENT,
                        isCentered: args.isCentered || false
                    };
                return {
                        renderWave: $.proxy(renderWave, null, config),
                        removeWave: $.proxy(removeWave, null, config)
                    }
            };
        var renderWave = function(args, config) {
                var element = config.element,
                    inkRipple = element.children("." + INKRIPPLE_CLASS);
                if (inkRipple.length === 0)
                    inkRipple = $("<div>").addClass(INKRIPPLE_CLASS).appendTo(element);
                var elementWidth = element.width(),
                    elementHeight = element.height(),
                    maxContentSize = Math.max(elementWidth, elementHeight),
                    rippleSize = Math.min(MAX_WAVE_SIZE, parseInt(maxContentSize * args.waveSizeCoefficient)),
                    left,
                    top;
                var $wave = $("<div>").appendTo(inkRipple).addClass(INKRIPPLE_WAVE_CLASS);
                if (args.isCentered) {
                    left = (elementWidth - rippleSize) / 2;
                    top = (elementHeight - rippleSize) / 2
                }
                else {
                    var event = config.jQueryEvent,
                        position = element.offset(),
                        x = event.pageX - position.left,
                        y = event.pageY - position.top;
                    left = x - rippleSize / 2;
                    top = y - rippleSize / 2
                }
                var duration = parseInt(rippleSize * 3);
                $wave.css({
                    left: left,
                    top: top,
                    height: rippleSize,
                    width: rippleSize
                });
                fx.animate($wave, {
                    type: "pop",
                    from: {scale: 0},
                    to: {scale: 1},
                    duration: duration
                })
            };
        var removeWave = function(args, config) {
                var $inkRipple = config.element.find("." + INKRIPPLE_CLASS),
                    $wave = $inkRipple.children(":not(." + INKRIPPLE_REMOVING_CLASS + ")").eq(0);
                if ($wave.length === 0)
                    return;
                if (fx.isAnimating($wave))
                    fx.stop($wave);
                $wave.addClass(INKRIPPLE_REMOVING_CLASS);
                fx.animate($wave, {
                    complete: function() {
                        $wave.remove()
                    },
                    type: "fadeOut",
                    duration: 100
                })
            };
        return {render: render}
    });
    /*! Module core, file utils.knockout.js */
    DevExpress.define("/utils/utils.knockout", ["/utils/utils.support"], function(support) {
        var ko = window.ko;
        var unwrapObservable = function(value) {
                if (support.hasKo)
                    return ko.utils.unwrapObservable(value);
                return value
            };
        var isObservable = function(value) {
                return support.hasKo && ko.isObservable(value)
            };
        return {
                unwrapObservable: unwrapObservable,
                isObservable: isObservable
            }
    });
    /*! Module core, file utils.math.js */
    DevExpress.define("/utils/utils.math", ["/utils/utils.common"], function(commonUtils) {
        var PI = Math.PI,
            LN10 = Math.LN10;
        var cos = Math.cos,
            sin = Math.sin,
            abs = Math.abs,
            log = Math.log,
            floor = Math.floor,
            ceil = Math.ceil,
            max = Math.max,
            isNaN = window.isNaN,
            Number = window.Number,
            NaN = window.NaN;
        var isNumber = commonUtils.isNumber,
            isExponential = commonUtils.isExponential;
        var getPrecision = function(value) {
                var stringFraction,
                    stringValue = value.toString(),
                    pointIndex = stringValue.indexOf('.'),
                    startIndex,
                    precision;
                if (isExponential(value)) {
                    precision = getDecimalOrder(value);
                    if (precision < 0)
                        return Math.abs(precision);
                    else
                        return 0
                }
                if (pointIndex !== -1) {
                    startIndex = pointIndex + 1;
                    stringFraction = stringValue.substring(startIndex, startIndex + 20);
                    return stringFraction.length
                }
                return 0
            };
        var getLog = function(value, base) {
                if (!value)
                    return NaN;
                return Math.log(value) / Math.log(base)
            };
        var raiseTo = function(power, base) {
                return Math.pow(base, power)
            };
        var sign = function(value) {
                if (value === 0)
                    return 0;
                return value / abs(value)
            };
        var normalizeAngle = function(angle) {
                return (angle % 360 + 360) % 360
            };
        var convertAngleToRendererSpace = function(angle) {
                return 90 - angle
            };
        var degreesToRadians = function(value) {
                return PI * value / 180
            };
        var getCosAndSin = function(angle) {
                var angleInRadians = degreesToRadians(angle);
                return {
                        cos: cos(angleInRadians),
                        sin: sin(angleInRadians)
                    }
            };
        var DECIMAL_ORDER_THRESHOLD = 1E-14;
        var getDistance = function(x1, y1, x2, y2) {
                var diffX = x2 - x1,
                    diffY = y2 - y1;
                return Math.sqrt(diffY * diffY + diffX * diffX)
            };
        var getDecimalOrder = function(number) {
                var n = abs(number),
                    cn;
                if (!isNaN(n)) {
                    if (n > 0) {
                        n = log(n) / LN10;
                        cn = ceil(n);
                        return cn - n < DECIMAL_ORDER_THRESHOLD ? cn : floor(n)
                    }
                    return 0
                }
                return NaN
            };
        var getAppropriateFormat = function(start, end, count) {
                var order = max(getDecimalOrder(start), getDecimalOrder(end)),
                    precision = -getDecimalOrder(abs(end - start) / count),
                    format;
                if (!isNaN(order) && !isNaN(precision)) {
                    if (abs(order) <= 4) {
                        format = 'fixedPoint';
                        precision < 0 && (precision = 0);
                        precision > 4 && (precision = 4)
                    }
                    else {
                        format = 'exponential';
                        precision += order - 1;
                        precision > 3 && (precision = 3)
                    }
                    return {
                            format: format,
                            precision: precision
                        }
                }
                return null
            };
        var getFraction = function(value) {
                var valueString,
                    dotIndex;
                if (isNumber(value)) {
                    valueString = value.toString();
                    dotIndex = valueString.indexOf('.');
                    if (dotIndex >= 0)
                        if (isExponential(value))
                            return valueString.substr(dotIndex + 1, valueString.indexOf('e') - dotIndex - 1);
                        else {
                            valueString = value.toFixed(20);
                            return valueString.substr(dotIndex + 1, valueString.length - dotIndex + 1)
                        }
                }
                return ''
            };
        var getSignificantDigitPosition = function(value) {
                var fraction = getFraction(value),
                    i;
                if (fraction)
                    for (i = 0; i < fraction.length; i++)
                        if (fraction.charAt(i) !== '0')
                            return i + 1;
                return 0
            };
        var adjustValue = function(value) {
                var fraction = getFraction(value),
                    nextValue,
                    i;
                if (fraction)
                    for (i = 1; i <= fraction.length; i++) {
                        nextValue = roundValue(value, i);
                        if (nextValue !== 0 && fraction[i - 2] && fraction[i - 1] && fraction[i - 2] === fraction[i - 1])
                            return nextValue
                    }
                return value
            };
        var roundValue = function(value, precision) {
                if (precision > 20)
                    precision = 20;
                if (isNumber(value))
                    if (isExponential(value))
                        return Number(value.toExponential(precision));
                    else
                        return Number(value.toFixed(precision))
            };
        var applyPrecisionByMinDelta = function(min, delta, value) {
                var minPrecision = getPrecision(min),
                    deltaPrecision = getPrecision(delta);
                return roundValue(value, minPrecision < deltaPrecision ? deltaPrecision : minPrecision)
            };
        var fitIntoRange = function(value, minValue, maxValue) {
                return Math.min(Math.max(value, minValue), maxValue)
            };
        var getPower = function(value) {
                return value.toExponential().split("e")[1]
            };
        return {
                getPrecision: getPrecision,
                getLog: getLog,
                raiseTo: raiseTo,
                sign: sign,
                normalizeAngle: normalizeAngle,
                convertAngleToRendererSpace: convertAngleToRendererSpace,
                degreesToRadians: degreesToRadians,
                getCosAndSin: getCosAndSin,
                getDecimalOrder: getDecimalOrder,
                getAppropriateFormat: getAppropriateFormat,
                getDistance: getDistance,
                getFraction: getFraction,
                adjustValue: adjustValue,
                roundValue: roundValue,
                applyPrecisionByMinDelta: applyPrecisionByMinDelta,
                getSignificantDigitPosition: getSignificantDigitPosition,
                getPower: getPower,
                fitIntoRange: fitIntoRange
            }
    });
    /*! Module core, file utils.memorizedCallbacks.js */
    DevExpress.define("/utils/utils.memorizedCallbacks", ["jquery"], function($) {
        var MemorizedCallbacks = function() {
                var memory = [];
                var callbacks = $.Callbacks();
                this.add = function(fn) {
                    $.each(memory, function(_, item) {
                        fn.apply(fn, item)
                    });
                    callbacks.add(fn)
                };
                this.fire = function() {
                    memory.push(arguments);
                    callbacks.fire.apply(callbacks, arguments)
                }
            };
        return MemorizedCallbacks
    });
    /*! Module core, file utils.object.js */
    DevExpress.define("/utils/utils.object", ["jquery", "/utils/utils.common"], function($, commonUtils) {
        var clone = function() {
                function Clone(){}
                return function(obj) {
                        Clone.prototype = obj;
                        return new Clone
                    }
            }();
        var extendFromObject = function(target, source, overrideExistingValues) {
                target = target || {};
                for (var prop in source)
                    if (source.hasOwnProperty(prop)) {
                        var value = source[prop];
                        if (!(prop in target) || overrideExistingValues)
                            target[prop] = value
                    }
                return target
            };
        var orderEach = function(map, func) {
                var keys = [],
                    key,
                    i;
                for (key in map)
                    keys.push(key);
                keys.sort(function(x, y) {
                    var isNumberX = commonUtils.isNumber(x),
                        isNumberY = commonUtils.isNumber(y);
                    if (isNumberX && isNumberY)
                        return x - y;
                    if (isNumberX && !isNumberY)
                        return -1;
                    if (!isNumberX && isNumberY)
                        return 1;
                    if (x < y)
                        return -1;
                    if (x > y)
                        return 1;
                    return 0
                });
                for (i = 0; i < keys.length; i++) {
                    key = keys[i];
                    func(key, map[key])
                }
            };
        var deepExtendArraySafe = function(target, changes) {
                var prevValue,
                    newValue;
                for (var name in changes) {
                    prevValue = target[name];
                    newValue = changes[name];
                    if (target === newValue)
                        continue;
                    if ($.isPlainObject(newValue) && !(newValue instanceof $.Event))
                        target[name] = deepExtendArraySafe($.isPlainObject(prevValue) ? prevValue : {}, newValue);
                    else if (newValue !== undefined)
                        target[name] = newValue
                }
                return target
            };
        return {
                clone: clone,
                extendFromObject: extendFromObject,
                orderEach: orderEach,
                deepExtendArraySafe: deepExtendArraySafe
            }
    });
    /*! Module core, file utils.position.js */
    DevExpress.define("/utils/utils.position", ["/utils/utils.translator", "/utils/utils.string", "/utils/utils.support", "/utils/utils.common"], function(translator, stringUtils, support, commonUtils) {
        var horzRe = /left|right/,
            vertRe = /top|bottom/,
            collisionRe = /fit|flip|none/;
        var normalizeAlign = function(raw) {
                var result = {
                        h: "center",
                        v: "center"
                    };
                var pair = commonUtils.splitPair(raw);
                if (pair)
                    $.each(pair, function() {
                        var w = String(this).toLowerCase();
                        if (horzRe.test(w))
                            result.h = w;
                        else if (vertRe.test(w))
                            result.v = w
                    });
                return result
            };
        var normalizeOffset = function(raw) {
                return stringUtils.pairToObject(raw)
            };
        var normalizeCollision = function(raw) {
                var pair = commonUtils.splitPair(raw),
                    h = String(pair && pair[0]).toLowerCase(),
                    v = String(pair && pair[1]).toLowerCase();
                if (!collisionRe.test(h))
                    h = "none";
                if (!collisionRe.test(v))
                    v = h;
                return {
                        h: h,
                        v: v
                    }
            };
        var getAlignFactor = function(align) {
                switch (align) {
                    case"center":
                        return 0.5;
                    case"right":
                    case"bottom":
                        return 1;
                    default:
                        return 0
                }
            };
        var inverseAlign = function(align) {
                switch (align) {
                    case"left":
                        return "right";
                    case"right":
                        return "left";
                    case"top":
                        return "bottom";
                    case"bottom":
                        return "top";
                    default:
                        return align
                }
            };
        var calculateOversize = function(data, bounds) {
                var oversize = 0;
                if (data.myLocation < bounds.min)
                    oversize += bounds.min - data.myLocation;
                if (data.myLocation > bounds.max)
                    oversize += data.myLocation - bounds.max;
                return oversize
            };
        var collisionSide = function(direction, data, bounds) {
                if (data.myLocation < bounds.min)
                    return direction === "h" ? "left" : "top";
                if (data.myLocation > bounds.max)
                    return direction === "h" ? "right" : "bottom";
                return "none"
            };
        var initMyLocation = function(data) {
                data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset
            };
        var decolliders = {
                fit: function(data, bounds) {
                    var result = false;
                    if (data.myLocation > bounds.max) {
                        data.myLocation = bounds.max;
                        result = true
                    }
                    if (data.myLocation < bounds.min) {
                        data.myLocation = bounds.min;
                        result = true
                    }
                    data.fit = result
                },
                flip: function(data, bounds) {
                    data.flip = false;
                    if (data.myAlign === "center" && data.atAlign === "center")
                        return;
                    if (data.myLocation < bounds.min || data.myLocation > bounds.max) {
                        var inverseData = $.extend({}, data, {
                                myAlign: inverseAlign(data.myAlign),
                                atAlign: inverseAlign(data.atAlign),
                                offset: -data.offset
                            });
                        initMyLocation(inverseData);
                        inverseData.oversize = calculateOversize(inverseData, bounds);
                        if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {
                            data.myLocation = inverseData.myLocation;
                            data.oversize = inverseData.oversize;
                            data.flip = true
                        }
                    }
                },
                flipfit: function(data, bounds) {
                    this.flip(data, bounds);
                    this.fit(data, bounds)
                },
                none: function(data, bounds) {
                    data.oversize = 0
                }
            };
        var scrollbarWidth;
        var calculateScrollbarWidth = function() {
                var $scrollDiv = $("<div>").css({
                        width: 100,
                        height: 100,
                        overflow: "scroll",
                        position: "absolute",
                        top: -9999
                    }).appendTo($("body")),
                    result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
                $scrollDiv.remove();
                scrollbarWidth = result
            };
        var defaultPositionResult = {
                h: {
                    location: 0,
                    flip: false,
                    fit: false,
                    oversize: 0
                },
                v: {
                    location: 0,
                    flip: false,
                    fit: false,
                    oversize: 0
                }
            };
        var calculatePosition = function(what, options) {
                var $what = $(what),
                    currentOffset = $what.offset(),
                    result = $.extend(true, {}, defaultPositionResult, {
                        h: {location: currentOffset.left},
                        v: {location: currentOffset.top}
                    });
                if (!options)
                    return result;
                var my = normalizeAlign(options.my),
                    at = normalizeAlign(options.at),
                    of = options.of || window,
                    offset = normalizeOffset(options.offset),
                    collision = normalizeCollision(options.collision),
                    boundary = options.boundary,
                    boundaryOffset = normalizeOffset(options.boundaryOffset);
                var h = {
                        mySize: $what.outerWidth(),
                        myAlign: my.h,
                        atAlign: at.h,
                        offset: offset.h,
                        collision: collision.h,
                        boundaryOffset: boundaryOffset.h
                    };
                var v = {
                        mySize: $what.outerHeight(),
                        myAlign: my.v,
                        atAlign: at.v,
                        offset: offset.v,
                        collision: collision.v,
                        boundaryOffset: boundaryOffset.v
                    };
                if (of.preventDefault) {
                    h.atLocation = of.pageX;
                    v.atLocation = of.pageY;
                    h.atSize = 0;
                    v.atSize = 0
                }
                else {
                    of = $(of);
                    if ($.isWindow(of[0])) {
                        h.atLocation = of.scrollLeft();
                        v.atLocation = of.scrollTop();
                        h.atSize = of.width();
                        v.atSize = of.height()
                    }
                    else if (of[0].nodeType === 9) {
                        h.atLocation = 0;
                        v.atLocation = 0;
                        h.atSize = of.width();
                        v.atSize = of.height()
                    }
                    else {
                        var o = of.offset();
                        h.atLocation = o.left;
                        v.atLocation = o.top;
                        h.atSize = of.outerWidth();
                        v.atSize = of.outerHeight()
                    }
                }
                initMyLocation(h);
                initMyLocation(v);
                var bounds = function() {
                        var win = $(window),
                            windowWidth = win.width(),
                            windowHeight = win.height(),
                            left = win.scrollLeft(),
                            top = win.scrollTop(),
                            hScrollbar = document.width > document.documentElement.clientWidth,
                            vScrollbar = document.height > document.documentElement.clientHeight,
                            hZoomLevel = support.touch ? document.documentElement.clientWidth / (vScrollbar ? windowWidth - scrollbarWidth : windowWidth) : 1,
                            vZoomLevel = support.touch ? document.documentElement.clientHeight / (hScrollbar ? windowHeight - scrollbarWidth : windowHeight) : 1;
                        if (scrollbarWidth === undefined)
                            calculateScrollbarWidth();
                        var boundaryWidth = windowWidth,
                            boundaryHeight = windowHeight;
                        if (boundary) {
                            var $boundary = $(boundary),
                                boundaryPosition = $boundary.offset();
                            left = boundaryPosition.left;
                            top = boundaryPosition.top;
                            boundaryWidth = $boundary.width();
                            boundaryHeight = $boundary.height()
                        }
                        return {
                                h: {
                                    min: left + h.boundaryOffset,
                                    max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset
                                },
                                v: {
                                    min: top + v.boundaryOffset,
                                    max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
                                }
                            }
                    }();
                h.oversize = calculateOversize(h, bounds.h);
                v.oversize = calculateOversize(v, bounds.v);
                h.collisionSide = collisionSide("h", h, bounds.h);
                v.collisionSide = collisionSide("v", v, bounds.v);
                if (decolliders[h.collision])
                    decolliders[h.collision](h, bounds.h);
                if (decolliders[v.collision])
                    decolliders[v.collision](v, bounds.v);
                var preciser = function(number) {
                        return options.precise ? number : Math.round(number)
                    };
                $.extend(true, result, {
                    h: {
                        location: preciser(h.myLocation),
                        oversize: preciser(h.oversize),
                        fit: h.fit,
                        flip: h.flip,
                        collisionSide: h.collisionSide
                    },
                    v: {
                        location: preciser(v.myLocation),
                        oversize: preciser(v.oversize),
                        fit: v.fit,
                        flip: v.flip,
                        collisionSide: v.collisionSide
                    },
                    precise: options.precise
                });
                return result
            };
        var position = function(what, options) {
                var $what = $(what);
                if (!options)
                    return $what.offset();
                translator.resetPosition($what);
                var offset = $what.offset(),
                    targetPosition = options.h && options.v ? options : calculatePosition($what, options);
                var preciser = function(number) {
                        return options.precise ? number : Math.round(number)
                    };
                translator.move($what, {
                    left: targetPosition.h.location - preciser(offset.left),
                    top: targetPosition.v.location - preciser(offset.top)
                });
                return targetPosition
            };
        $.extend(position, {
            inverseAlign: inverseAlign,
            normalizeAlign: normalizeAlign
        });
        return {
                calculateScrollbarWidth: calculateScrollbarWidth,
                calculate: calculatePosition,
                setup: position
            }
    });
    /*! Module core, file utils.proxyUrlFormatter.js */
    DevExpress.define("/utils/utils.proxyUrlFormatter", ["jquery"], function($) {
        var location = window.location,
            DXPROXY_HOST = "dxproxy.devexpress.com:8000",
            IS_DXPROXY_ORIGIN = location.host === DXPROXY_HOST,
            urlMapping = {};
        var parseUrl = function() {
                var a = document.createElement("a"),
                    props = ["protocol", "hostname", "port", "pathname", "search", "hash"];
                var normalizePath = function(value) {
                        if (value.charAt(0) !== "/")
                            value = "/" + value;
                        return value
                    };
                return function(url) {
                        a.href = url;
                        var result = {};
                        $.each(props, function() {
                            result[this] = a[this]
                        });
                        result.pathname = normalizePath(result.pathname);
                        return result
                    }
            }();
        var extractProxyAppId = function() {
                return location.pathname.split("/")[1]
            };
        return {
                parseUrl: parseUrl,
                isProxyUsed: function() {
                    return IS_DXPROXY_ORIGIN
                },
                formatProxyUrl: function(localUrl) {
                    var urlData = parseUrl(localUrl);
                    if (!/^(localhost$|127\.)/i.test(urlData.hostname))
                        return localUrl;
                    var proxyUrlPart = DXPROXY_HOST + "/" + extractProxyAppId() + "_" + urlData.port;
                    urlMapping[proxyUrlPart] = urlData.hostname + ":" + urlData.port;
                    var resultUrl = "http://" + proxyUrlPart + urlData.pathname + urlData.search;
                    return resultUrl
                },
                formatLocalUrl: function(proxyUrl) {
                    if (proxyUrl.indexOf(DXPROXY_HOST) < 0)
                        return proxyUrl;
                    var resultUrl = proxyUrl;
                    for (var proxyUrlPart in urlMapping)
                        if (urlMapping.hasOwnProperty(proxyUrlPart))
                            if (proxyUrl.indexOf(proxyUrlPart) >= 0) {
                                resultUrl = proxyUrl.replace(proxyUrlPart, urlMapping[proxyUrlPart]);
                                break
                            }
                    return resultUrl
                }
            }
    });
    /*! Module core, file utils.publicComponent.js */
    DevExpress.define("/utils/utils.publicComponent", ["jquery", "/utils/utils.weakMap", "/utils/utils.common"], function($, WeakMap, commonUtils) {
        var COMPONENT_NAMES_DATA_KEY = "dxComponents",
            ANONIMIOUS_COMPONENT_DATA_KEY = "dxPrivateComponent";
        var componentNames = new WeakMap,
            nextAnonimiousComponent = 0;
        return {
                attachInstanceToElement: function(element, name, component) {
                    element = $(element).get(0);
                    $.data(element, name, component);
                    if (!$.data(element, COMPONENT_NAMES_DATA_KEY))
                        $.data(element, COMPONENT_NAMES_DATA_KEY, []);
                    $.data(element, COMPONENT_NAMES_DATA_KEY).push(name)
                },
                getInstanceByElement: function(element, name) {
                    element = $(element).get(0);
                    return $.data(element, name)
                },
                getName: function(newName) {
                    if (commonUtils.isDefined(newName)) {
                        componentNames.set(this, newName);
                        return
                    }
                    if (!componentNames.has(this)) {
                        var generatedName = ANONIMIOUS_COMPONENT_DATA_KEY + nextAnonimiousComponent++;
                        componentNames.set(this, generatedName);
                        return generatedName
                    }
                    return componentNames.get(this)
                }
            }
    });
    /*! Module core, file utils.queue.js */
    DevExpress.define("/utils/utils.queue", ["jquery", "/errors"], function($, errors) {
        function createQueue(discardPendingTasks) {
            var _tasks = [],
                _busy = false;
            function exec() {
                while (_tasks.length) {
                    _busy = true;
                    var task = _tasks.shift(),
                        result = task();
                    if (result === undefined)
                        continue;
                    if (result.then) {
                        $.when(result).always(exec);
                        return
                    }
                    throw errors.Error("E0015");
                }
                _busy = false
            }
            function add(task, removeTaskCallback) {
                if (!discardPendingTasks)
                    _tasks.push(task);
                else {
                    if (_tasks[0] && removeTaskCallback)
                        removeTaskCallback(_tasks[0]);
                    _tasks = [task]
                }
                if (!_busy)
                    exec()
            }
            function busy() {
                return _busy
            }
            return {
                    add: add,
                    busy: busy
                }
        }
        return {
                create: createQueue,
                enqueue: createQueue().add
            }
    });
    /*! Module core, file utils.recurrence.js */
    DevExpress.define("/utils/utils.recurrence", ["jquery", "/errors", "/utils/utils.date"], function($, errors, dateUtils) {
        var intervalMap = {
                secondly: "seconds",
                minutely: "minutes",
                hourly: "hours",
                daily: "days",
                weekly: "weeks",
                monthly: "months",
                yearly: "years"
            };
        var dateSetterMap = {
                bysecond: function(date, value) {
                    date.setSeconds(value)
                },
                byminute: function(date, value) {
                    date.setMinutes(value)
                },
                byhour: function(date, value) {
                    date.setHours(value)
                },
                bymonth: function(date, value) {
                    date.setMonth(value)
                },
                bymonthday: function(date, value) {
                    date.setDate(value)
                },
                byday: function(date, dayOfWeek) {
                    date.setDate(date.getDate() - date.getDay() + dayOfWeek)
                }
            };
        var dateGetterMap = {
                bysecond: "getSeconds",
                byminute: "getMinutes",
                byhour: "getHours",
                bymonth: "getMonth",
                bymonthday: "getDate",
                byday: "getDay"
            };
        var ruleNames = ["freq", "interval", "byday", "bymonth", "bymonthday", "count", "until", "byhour", "byminute", "bysecond"],
            freqNames = ["DAILY", "WEEKLY", "MONTHLY", "YEARLY", "SECONDLY", "MINUTELY", "HOURLY"],
            days = {
                SU: 0,
                MO: 1,
                TU: 2,
                WE: 3,
                TH: 4,
                FR: 5,
                SA: 6
            };
        var dateInRecurrenceRange = function(recurrenceString, currentDate, viewStartDate, viewEndDate, recurrenceException) {
                var result = [];
                if (recurrenceString)
                    result = getDatesByRecurrence(recurrenceString, currentDate, viewStartDate, viewEndDate, recurrenceException);
                return !!result.length
            };
        var normalizeInterval = function(freq, interval) {
                var intervalObject = {},
                    intervalField = intervalMap[freq.toLowerCase()];
                intervalObject[intervalField] = interval;
                return intervalObject
            };
        var getDatesByRecurrenceException = function(recurrenceException) {
                var result = [];
                if (!recurrenceException)
                    return result;
                var ruleValues = recurrenceException.split(",");
                for (var i = 0, len = ruleValues.length; i < len; i++)
                    result[i] = getDateByAsciiString(ruleValues[i]);
                return result
            };
        var dateInArray = function(date, dates) {
                var result = false;
                for (var i = 0, len = dates.length; i < len; i++)
                    if (date.getTime() === dates[i].getTime())
                        result = true;
                return result
            };
        var getDatesByRecurrence = function(recurrenceString, recurrenceStartDate, viewStartDate, viewEndDate, recurrenceException) {
                var result = [],
                    recurrenceRule = getRecurrenceRule(recurrenceString);
                if (!recurrenceRule.isValid)
                    return [];
                var rule = recurrenceRule.rule;
                if (!rule.freq)
                    return result;
                rule.interval = normalizeInterval(rule.freq, rule.interval);
                viewEndDate = dateUtils.normalizeDate(viewEndDate, viewStartDate, rule.until);
                var recurrenceCounter = 0,
                    dateCounter = 0,
                    dateRules = splitDateRules(rule),
                    ruleDates = getDatesByRules(dateRules, recurrenceStartDate),
                    currentDate = ruleDates[0],
                    firstDate = new Date(recurrenceStartDate),
                    exceptDates = getDatesByRecurrenceException(recurrenceException);
                dateUtils.correctDateWithUnitBeginning(firstDate, rule.interval);
                var firstDateInterval = getDatePartDiffs(recurrenceStartDate, firstDate);
                while (currentDate <= viewEndDate && rule.count !== recurrenceCounter) {
                    if (checkDateByRule(currentDate, dateRules)) {
                        if (currentDate >= viewStartDate && !dateInArray(currentDate, exceptDates)) {
                            viewStartDate = new Date(currentDate);
                            viewStartDate.setMilliseconds(viewStartDate.getMilliseconds() + 1);
                            result.push(new Date(currentDate))
                        }
                        recurrenceCounter++
                    }
                    dateCounter++;
                    currentDate = ruleDates[dateCounter % ruleDates.length];
                    if (dateCounter / ruleDates.length >= 1) {
                        dateCounter = 0;
                        firstDate = dateUtils.addInterval(firstDate, rule.interval);
                        ruleDates = getDatesByRules(dateRules, dateUtils.addInterval(firstDate, firstDateInterval));
                        currentDate = ruleDates[0]
                    }
                }
                return result
            };
        var getDatePartDiffs = function(date1, date2) {
                return {
                        years: date1.getFullYear() - date2.getFullYear(),
                        months: date1.getMonth() - date2.getMonth(),
                        days: date1.getDate() - date2.getDate(),
                        hours: date1.getHours() - date2.getHours(),
                        minutes: date1.getMinutes() - date2.getMinutes(),
                        seconds: date1.getSeconds() - date2.getSeconds()
                    }
            };
        var getRecurrenceRule = function(recurrence) {
                var result = {
                        rule: {},
                        isValid: false
                    };
                if (recurrence) {
                    result.rule = parseRecurrenceRule(recurrence);
                    result.isValid = validateRRule(result.rule, recurrence)
                }
                return result
            };
        var loggedWarnings = [];
        var validateRRule = function(rule, recurrence) {
                if (brokenRuleNameExists(rule) || $.inArray(rule.freq, freqNames) === -1 || wrongCountRule(rule) || wrongIntervalRule(rule) || wrongDayOfWeek(rule) || wrongByMonthDayRule(rule) || wrongByMonth(rule) || wrongUntilRule(rule)) {
                    logBrokenRule(recurrence);
                    return false
                }
                return true
            };
        var wrongUntilRule = function(rule) {
                var wrongUntil = false,
                    until = rule.until;
                if (until !== undefined && !(until instanceof Date))
                    wrongUntil = true;
                return wrongUntil
            };
        var wrongCountRule = function(rule) {
                var wrongCount = false,
                    count = rule.count;
                if (count && typeof count === "string")
                    wrongCount = true;
                return wrongCount
            };
        var wrongByMonthDayRule = function(rule) {
                var wrongByMonthDay = false,
                    byMonthDay = rule.bymonthday;
                if (byMonthDay && isNaN(parseInt(byMonthDay)))
                    wrongByMonthDay = true;
                return wrongByMonthDay
            };
        var wrongByMonth = function(rule) {
                var wrongByMonth = false,
                    byMonth = rule.bymonth;
                if (byMonth && isNaN(parseInt(byMonth)))
                    wrongByMonth = true;
                return wrongByMonth
            };
        var wrongIntervalRule = function(rule) {
                var wrongInterval = false,
                    interval = rule.interval;
                if (interval && typeof interval === "string")
                    wrongInterval = true;
                return wrongInterval
            };
        var wrongDayOfWeek = function(rule) {
                var daysByRule = daysFromByDayRule(rule),
                    brokenDaysExist = false;
                $.each(daysByRule, function(_, day) {
                    if (!days.hasOwnProperty(day)) {
                        brokenDaysExist = true;
                        return false
                    }
                });
                return brokenDaysExist
            };
        var brokenRuleNameExists = function(rule) {
                var brokenRuleExists = false;
                $.each(rule, function(ruleName, _) {
                    if ($.inArray(ruleName, ruleNames) === -1) {
                        brokenRuleExists = true;
                        return false
                    }
                });
                return brokenRuleExists
            };
        var logBrokenRule = function(recurrence) {
                if ($.inArray(recurrence, loggedWarnings) === -1) {
                    errors.log("W0006", recurrence);
                    loggedWarnings.push(recurrence)
                }
            };
        var parseRecurrenceRule = function(recurrence) {
                var ruleObject = {},
                    ruleParts = recurrence.split(";");
                for (var i = 0, len = ruleParts.length; i < len; i++) {
                    var rule = ruleParts[i].split("="),
                        ruleName = rule[0].toLowerCase(),
                        ruleValue = rule[1];
                    ruleObject[ruleName] = ruleValue
                }
                var count = parseInt(ruleObject.count);
                if (!isNaN(count))
                    ruleObject.count = count;
                if (ruleObject.interval) {
                    var interval = parseInt(ruleObject.interval);
                    if (!isNaN(interval))
                        ruleObject.interval = interval
                }
                else
                    ruleObject.interval = 1;
                if (ruleObject.freq && ruleObject.until)
                    ruleObject.until = getDateByAsciiString(ruleObject.until);
                return ruleObject
            };
        var getDateByAsciiString = function(string) {
                if (typeof string !== "string")
                    return string;
                var date = Globalize.parseDate(string, "yyyyMMddThhmmss");
                if (!date)
                    date = Globalize.parseDate(string, "yyyyMMdd");
                return date
            };
        var daysFromByDayRule = function(rule) {
                var result = [];
                if (rule.byday)
                    result = rule.byday.split(",");
                return result
            };
        var getAsciiStringByDate = function(date) {
                return date.getFullYear() + ('0' + (date.getMonth() + 1)).slice(-2) + ('0' + date.getDate()).slice(-2)
            };
        var splitDateRules = function(rule) {
                var result = [];
                for (var field in dateSetterMap) {
                    if (!rule[field])
                        continue;
                    var ruleFieldValues = rule[field].split(","),
                        ruleArray = getDateRuleArray(field, ruleFieldValues);
                    result = result.length ? extendObjectArray(ruleArray, result) : ruleArray
                }
                return result
            };
        var getDateRuleArray = function(field, values) {
                var result = [];
                for (var i = 0, length = values.length; i < length; i++) {
                    var dateRule = {};
                    dateRule[field] = handleRuleFieldValue(field, values[i]);
                    result.push(dateRule)
                }
                return result
            };
        var handleRuleFieldValue = function(field, value) {
                var result = parseInt(value);
                if (field === "bymonth")
                    result -= 1;
                if (field === "byday")
                    result = days[value];
                return result
            };
        var extendObjectArray = function(firstArray, secondArray) {
                var result = [];
                for (var i = 0, firstArrayLength = firstArray.length; i < firstArrayLength; i++)
                    for (var j = 0, secondArrayLength = secondArray.length; j < secondArrayLength; j++)
                        result.push($.extend({}, firstArray[i], secondArray[j]));
                return result
            };
        var getDatesByRules = function(dateRules, startDate) {
                var updatedDate = new Date(startDate),
                    result = [];
                for (var i = 0, len = dateRules.length; i < len; i++) {
                    var current = dateRules[i];
                    for (var field in current)
                        dateSetterMap[field](updatedDate, current[field]);
                    result.push(new Date(updatedDate))
                }
                if (!result.length)
                    result.push(updatedDate);
                return result
            };
        var checkDateByRule = function(date, rules) {
                var result = false;
                for (var i = 0; i < rules.length; i++) {
                    var current = rules[i],
                        currentRuleResult = true;
                    for (var field in current)
                        if (current[field] !== date[dateGetterMap[field]]())
                            currentRuleResult = false;
                    result = result || currentRuleResult
                }
                return result || !rules.length
            };
        var getRecurrenceString = function(object) {
                if (!object || !object.freq)
                    return;
                var result = "";
                for (var field in object) {
                    var value = object[field];
                    if (field === "interval" && value < 2)
                        continue;
                    if (field === "until")
                        value = getAsciiStringByDate(value);
                    result += field + "=" + value + ";"
                }
                result = result.substring(0, result.length - 1);
                return result.toUpperCase()
            };
        return {
                getRecurrenceString: getRecurrenceString,
                getRecurrenceRule: getRecurrenceRule,
                getAsciiStringByDate: getAsciiStringByDate,
                getDatesByRecurrence: getDatesByRecurrence,
                dateInRecurrenceRange: dateInRecurrenceRange,
                getDateByAsciiString: getDateByAsciiString,
                daysFromByDayRule: daysFromByDayRule
            }
    });
    /*! Module core, file utils.storage.js */
    DevExpress.define("/utils/utils.storage", [], function() {
        var getSessionStorage = function() {
                var sessionStorage;
                try {
                    sessionStorage = window.sessionStorage
                }
                catch(e) {}
                return sessionStorage
            };
        return {sessionStorage: getSessionStorage}
    });
    /*! Module core, file utils.string.js */
    DevExpress.define("/utils/utils.string", ["jquery", "/utils/utils.common"], function($, commonUtils) {
        var encodeHtml = function() {
                var exncodeRegExp = [new RegExp("&", "g"), new RegExp('"', "g"), new RegExp("'", "g"), new RegExp("<", "g"), new RegExp(">", "g")];
                return function(str) {
                        return String(str).replace(exncodeRegExp[0], '&amp;').replace(exncodeRegExp[1], '&quot;').replace(exncodeRegExp[2], '&#39;').replace(exncodeRegExp[3], '&lt;').replace(exncodeRegExp[4], '&gt;')
                    }
            }();
        var pairToObject = function(raw) {
                var pair = commonUtils.splitPair(raw),
                    h = parseInt(pair && pair[0], 10),
                    v = parseInt(pair && pair[1], 10);
                if (!isFinite(h))
                    h = 0;
                if (!isFinite(v))
                    v = h;
                return {
                        h: h,
                        v: v
                    }
            };
        var quadToObject = function(raw) {
                var quad = commonUtils.splitQuad(raw),
                    left = parseInt(quad && quad[0], 10),
                    top = parseInt(quad && quad[1], 10),
                    right = parseInt(quad && quad[2], 10),
                    bottom = parseInt(quad && quad[3], 10);
                if (!isFinite(left))
                    left = 0;
                if (!isFinite(top))
                    top = left;
                if (!isFinite(right))
                    right = left;
                if (!isFinite(bottom))
                    bottom = top;
                return {
                        top: top,
                        right: right,
                        bottom: bottom,
                        left: left
                    }
            };
        var stringFormat = function() {
                var s = arguments[0],
                    replaceDollarCount,
                    reg,
                    argument;
                for (var i = 0; i < arguments.length - 1; i++) {
                    reg = new RegExp("\\{" + i + "\\}", "gm");
                    argument = arguments[i + 1];
                    if ($.type(argument) === "string" && argument.indexOf("$") >= 0) {
                        replaceDollarCount = "$".replace("$", "$$").length;
                        argument = argument.replace("$", replaceDollarCount === 1 ? "$$$$" : "$$")
                    }
                    s = s.replace(reg, argument)
                }
                return s
            };
        var replaceAll = function() {
                var preg_quote = function(str) {
                        return (str + "").replace(/([\+\*\?\\\.\[\^\]\$\(\)\{\}\><\|\=\!\:])/g, "\\$1")
                    };
                return function(text, searchToken, replacementToken) {
                        return text.replace(new RegExp("(" + preg_quote(searchToken) + ")", "gi"), replacementToken)
                    }
            }();
        return {
                encodeHtml: encodeHtml,
                pairToObject: pairToObject,
                quadToObject: quadToObject,
                format: stringFormat,
                replaceAll: replaceAll
            }
    });
    /*! Module core, file utils.support.js */
    DevExpress.define("/utils/utils.support", ["jquery", "/utils/utils.inflector", "/devices"], function($, inflector, devices) {
        var camelize = inflector.camelize;
        var jsPrefixes = ["", "Webkit", "Moz", "O", "Ms"],
            cssPrefixes = {
                "": "",
                Webkit: "-webkit-",
                Moz: "-moz-",
                O: "-o-",
                ms: "-ms-"
            },
            styles = document.createElement("dx").style;
        var transitionEndEventNames = {
                webkitTransition: 'webkitTransitionEnd',
                MozTransition: 'transitionend',
                OTransition: 'oTransitionEnd',
                msTransition: 'MsTransitionEnd',
                transition: 'transitionend'
            };
        var forEachPrefixes = function(prop, callBack) {
                prop = camelize(prop, true);
                var result;
                for (var i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
                    var jsPrefix = jsPrefixes[i];
                    var prefixedProp = jsPrefix + prop;
                    var lowerPrefixedProp = camelize(prefixedProp);
                    result = callBack(lowerPrefixedProp, jsPrefix);
                    if (result === undefined)
                        result = callBack(prefixedProp, jsPrefix);
                    if (result !== undefined)
                        break
                }
                return result
            };
        var styleProp = function(prop) {
                return forEachPrefixes(prop, function(specific) {
                        if (specific in styles)
                            return specific
                    })
            };
        var stylePropPrefix = function(prop) {
                return forEachPrefixes(prop, function(specific, jsPrefix) {
                        if (specific in styles)
                            return cssPrefixes[jsPrefix]
                    })
            };
        var supportProp = function(prop) {
                return !!styleProp(prop)
            };
        var isNativeScrollingSupported = function() {
                var realDevice = devices.real(),
                    realPlatform = realDevice.platform,
                    realVersion = realDevice.version,
                    isObsoleteAndroid = realVersion && realVersion[0] < 4 && realPlatform === "android",
                    isNativeScrollDevice = !isObsoleteAndroid && $.inArray(realPlatform, ["ios", "android", "win"]) > -1 || realDevice.mac;
                return isNativeScrollDevice
            };
        var inputType = function(type) {
                if (type === "text")
                    return true;
                var input = document.createElement("input");
                try {
                    input.setAttribute("type", type);
                    input.value = "wrongValue";
                    return !input.value
                }
                catch(e) {
                    return false
                }
            };
        var touchEvents = "ontouchstart" in window && !('callPhantom' in window),
            pointerEvents = !!window.navigator.pointerEnabled || !!window.navigator.msPointerEnabled;
        return {
                touchEvents: touchEvents,
                pointer: pointerEvents,
                touch: touchEvents || pointerEvents,
                transform: supportProp("transform"),
                transition: supportProp("transition"),
                transitionEndEventName: transitionEndEventNames[styleProp("transition")],
                animation: supportProp("animation"),
                nativeScrolling: isNativeScrollingSupported(),
                winJS: "WinJS" in window,
                styleProp: styleProp,
                stylePropPrefix: stylePropPrefix,
                supportProp: supportProp,
                hasKo: !!window.ko,
                hasNg: !!window.angular,
                inputType: inputType
            }
    });
    /*! Module core, file utils.topOverlay.js */
    DevExpress.define("/utils/utils.topOverlay", ["jquery"], function($) {
        var hideCallback = function() {
                var callbacks = [];
                return {
                        add: function(callback) {
                            var indexOfCallback = $.inArray(callback, callbacks);
                            if (indexOfCallback === -1)
                                callbacks.push(callback)
                        },
                        remove: function(callback) {
                            var indexOfCallback = $.inArray(callback, callbacks);
                            if (indexOfCallback !== -1)
                                callbacks.splice(indexOfCallback, 1)
                        },
                        fire: function() {
                            var callback = callbacks.pop(),
                                result = !!callback;
                            if (result)
                                callback();
                            return result
                        },
                        hasCallback: function() {
                            return callbacks.length > 0
                        },
                        reset: function() {
                            callbacks = []
                        }
                    }
            }();
        return {
                hide: function() {
                    return hideCallback.fire()
                },
                hideCallback: hideCallback
            }
    });
    /*! Module core, file utils.translator.js */
    DevExpress.define("/utils/utils.translator", ["jquery", "/utils/utils.support"], function($, support) {
        var TRANSLATOR_DATA_KEY = "dxTranslator",
            TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/,
            TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
        var locate = function($element) {
                var translate = support.transform ? getTranslate($element) : getTranslateFallback($element);
                return {
                        left: translate.x,
                        top: translate.y
                    }
            };
        var move = function($element, position) {
                if (!support.transform) {
                    $element.css(position);
                    return
                }
                var translate = getTranslate($element),
                    left = position.left,
                    top = position.top;
                if (left !== undefined)
                    translate.x = left || 0;
                if (top !== undefined)
                    translate.y = top || 0;
                $element.css({transform: getTranslateCss(translate)});
                if (isPersentValue(left) || isPersentValue(top))
                    clearCache($element)
            };
        var isPersentValue = function(value) {
                return $.type(value) === "string" && value[value.length - 1] === "%"
            };
        var getTranslateFallback = function($element) {
                var result;
                try {
                    var originalTop = $element.css("top"),
                        originalLeft = $element.css("left");
                    var position = $element.position();
                    $element.css({
                        transform: "none",
                        top: 0,
                        left: 0
                    });
                    clearCache($element);
                    var finalPosition = $element.position();
                    result = {
                        x: position.left - finalPosition.left || parseInt(originalLeft) || 0,
                        y: position.top - finalPosition.top || parseInt(originalTop) || 0
                    };
                    $element.css({
                        top: originalTop,
                        left: originalLeft
                    })
                }
                catch(e) {
                    result = {
                        x: 0,
                        y: 0
                    }
                }
                return result
            };
        var getTranslate = function($element) {
                var result = $element.length ? $.data($element.get(0), TRANSLATOR_DATA_KEY) : null;
                if (!result) {
                    var transformValue = $element.css("transform") || getTranslateCss({
                            x: 0,
                            y: 0
                        }),
                        matrix = transformValue.match(TRANSFORM_MATRIX_REGEX),
                        is3D = matrix && matrix[1];
                    if (matrix) {
                        matrix = matrix[2].split(",");
                        if (is3D === "3d")
                            matrix = matrix.slice(12, 15);
                        else {
                            matrix.push(0);
                            matrix = matrix.slice(4, 7)
                        }
                    }
                    else
                        matrix = [0, 0, 0];
                    result = {
                        x: parseFloat(matrix[0]),
                        y: parseFloat(matrix[1]),
                        z: parseFloat(matrix[2])
                    };
                    cacheTranslate($element, result)
                }
                return result
            };
        var cacheTranslate = function($element, translate) {
                if ($element.length)
                    $.data($element.get(0), TRANSLATOR_DATA_KEY, translate)
            };
        var clearCache = function($element) {
                if ($element.length)
                    $.removeData($element.get(0), TRANSLATOR_DATA_KEY)
            };
        var resetPosition = function($element) {
                $element.css({
                    left: 0,
                    top: 0,
                    transform: "none"
                });
                clearCache($element)
            };
        var parseTranslate = function(translateString) {
                var result = translateString.match(TRANSLATE_REGEX);
                if (!result || !result[1])
                    return;
                result = result[1].split(",");
                result = {
                    x: parseFloat(result[0]),
                    y: parseFloat(result[1]),
                    z: parseFloat(result[2])
                };
                return result
            };
        var getTranslateCss = function(translate) {
                translate.x = translate.x || 0;
                translate.y = translate.y || 0;
                var xValueString = isPersentValue(translate.x) ? translate.x : translate.x + "px";
                var yValueString = isPersentValue(translate.y) ? translate.y : translate.y + "px";
                return "translate(" + xValueString + ", " + yValueString + ")"
            };
        return {
                move: move,
                locate: locate,
                clearCache: clearCache,
                parseTranslate: parseTranslate,
                getTranslate: getTranslate,
                getTranslateCss: getTranslateCss,
                resetPosition: resetPosition
            }
    });
    /*! Module core, file utils.version.js */
    DevExpress.define("/utils/utils.version", ["jquery"], function($) {
        var compare = function(x, y, maxLevel) {
                function normalizeArg(value) {
                    if (typeof value === "string")
                        return value.split(".");
                    if (typeof value === "number")
                        return [value];
                    return value
                }
                x = normalizeArg(x);
                y = normalizeArg(y);
                var length = Math.max(x.length, y.length);
                if (isFinite(maxLevel))
                    length = Math.min(length, maxLevel);
                for (var i = 0; i < length; i++) {
                    var xItem = parseInt(x[i] || 0, 10),
                        yItem = parseInt(y[i] || 0, 10);
                    if (xItem < yItem)
                        return -1;
                    if (xItem > yItem)
                        return 1
                }
                return 0
            };
        return {compare: compare}
    });
    /*! Module core, file utils.viewPort.js */
    DevExpress.define("/utils/utils.viewPort", ["jquery"], function($) {
        var changeCallback = $.Callbacks();
        var value = function() {
                var $current;
                return function(element) {
                        if (!arguments.length)
                            return $current;
                        var $element = $(element);
                        var isNewViewportFound = !!$element.length;
                        var prevViewPort = value();
                        $current = isNewViewportFound ? $element : $("body");
                        changeCallback.fire(isNewViewportFound ? value() : $(), prevViewPort)
                    }
            }();
        $(function() {
            value(".dx-viewport")
        });
        return {
                value: value,
                changeCallback: changeCallback
            }
    });
    /*! Module core, file utils.weakMap.js */
    DevExpress.define("/utils/utils.weakMap", ["jquery"], function($) {
        var WeakMap = window.WeakMap;
        if (!WeakMap)
            WeakMap = function() {
                var keys = [],
                    values = [];
                this.set = function(key, value) {
                    keys.push(key);
                    values.push(value)
                };
                this.get = function(key) {
                    var index = $.inArray(key, keys);
                    if (index === -1)
                        return undefined;
                    return values[index]
                };
                this.has = function(key) {
                    var index = $.inArray(key, keys);
                    if (index === -1)
                        return false;
                    return true
                }
            };
        return WeakMap
    });
    /*! Module core, file utils.window.js */
    DevExpress.define("/utils/utils.window", ["jquery"], function($) {
        var resizeCallbacks = function() {
                var prevSize,
                    callbacks = $.Callbacks(),
                    jqWindow = $(window),
                    resizeEventHandlerAttached = false,
                    originalCallbacksAdd = callbacks.add,
                    originalCallbacksRemove = callbacks.remove;
                var formatSize = function() {
                        return [jqWindow.width(), jqWindow.height()].join()
                    };
                var handleResize = function() {
                        var now = formatSize();
                        if (now === prevSize)
                            return;
                        prevSize = now;
                        setTimeout(callbacks.fire)
                    };
                prevSize = formatSize();
                callbacks.add = function() {
                    var result = originalCallbacksAdd.apply(callbacks, arguments);
                    if (!resizeEventHandlerAttached && callbacks.has()) {
                        jqWindow.on("resize", handleResize);
                        resizeEventHandlerAttached = true
                    }
                    return result
                };
                callbacks.remove = function() {
                    var result = originalCallbacksRemove.apply(callbacks, arguments);
                    if (!callbacks.has() && resizeEventHandlerAttached) {
                        jqWindow.off("resize", handleResize);
                        resizeEventHandlerAttached = false
                    }
                    return result
                };
                return callbacks
            }();
        return {resizeCallbacks: resizeCallbacks}
    });
    /*! Module core, file utilsNamespace.js */
    DevExpress.define("/utils/utilsNamespace", ["/coreNamespace"], function(baseNamespace) {
        var ns = baseNamespace.utils = baseNamespace.utils || {};
        return ns
    });
    /*! Module core, file utils.js */
    DevExpress.define("/utils/utils", ["/utils/utilsNamespace", "/utils/utils.animationFrame", "/utils/utils.object", "/utils/utils.dom", "/utils/utils.date", "/utils/utils.common"], function(namespace, animationFrame, objectUtils, domUtils, dateUtils, commonUtils) {
        namespace.requestAnimationFrame = animationFrame.request;
        namespace.cancelAnimationFrame = animationFrame.cancel;
        namespace.initMobileViewport = domUtils.initMobileViewport;
        namespace.extendFromObject = objectUtils.extendFromObject;
        namespace.createComponents = domUtils.createComponents;
        namespace.triggerShownEvent = domUtils.triggerShownEvent;
        namespace.triggerHiddingEvent = domUtils.triggerHiddingEvent;
        namespace.makeDate = dateUtils.makeDate;
        namespace.resetActiveElement = domUtils.resetActiveElement;
        namespace.findBestMatches = commonUtils.findBestMatches;
        return namespace
    });
    /*! Module core, file localization.js */
    (function($, DX, undefined) {
        var humanize = DX.require("/utils/utils.inflector").humanize;
        Globalize._findClosestNeutralCulture = function(cultureSelector) {
            var neutral = (cultureSelector || this.cultureSelector || "").substring(0, 2),
                culture = this.findClosestCulture(neutral);
            return culture || {messages: {}}
        };
        Globalize.localize = function(key, cultureSelector) {
            return this.findClosestCulture(cultureSelector).messages[key] || this._findClosestNeutralCulture(cultureSelector).messages[key] || this.cultures["default"].messages[key]
        };
        var localization = function() {
                var newMessages = {};
                return {
                        setup: function(localizablePrefix) {
                            this.localizeString = function(text) {
                                var regex = new RegExp("(^|[^a-zA-Z_0-9" + localizablePrefix + "-]+)(" + localizablePrefix + "{1,2})([a-zA-Z_0-9-]+)", "g"),
                                    escapeString = localizablePrefix + localizablePrefix;
                                return text.replace(regex, function(str, prefix, escape, localizationKey) {
                                        var result = prefix + localizablePrefix + localizationKey;
                                        if (escape !== escapeString)
                                            if (Globalize.cultures["default"].messages[localizationKey])
                                                result = prefix + Globalize.localize(localizationKey);
                                            else
                                                newMessages[localizationKey] = humanize(localizationKey);
                                        return result
                                    })
                            }
                        },
                        localizeNode: function(node) {
                            var that = this;
                            $(node).each(function(index, nodeItem) {
                                if (!nodeItem.nodeType)
                                    return;
                                if (nodeItem.nodeType === 3)
                                    nodeItem.nodeValue = that.localizeString(nodeItem.nodeValue);
                                else if (!$(nodeItem).is("iframe")) {
                                    $.each(nodeItem.attributes || [], function(index, attr) {
                                        if (typeof attr.value === "string") {
                                            var localizedValue = that.localizeString(attr.value);
                                            if (attr.value !== localizedValue)
                                                attr.value = localizedValue
                                        }
                                    });
                                    $(nodeItem).contents().each(function(index, node) {
                                        that.localizeNode(node)
                                    })
                                }
                            })
                        },
                        getDictionary: function(onlyNew) {
                            if (onlyNew)
                                return newMessages;
                            return $.extend({}, newMessages, Globalize.cultures["default"].messages)
                        }
                    }
            }();
        localization.setup("@");
        DX.localization = localization
    })(jQuery, DevExpress);
    /*! Module core, file core.en.js */
    Globalize.addCultureInfo("default", {messages: {
            Yes: "Yes",
            No: "No",
            Cancel: "Cancel",
            Clear: "Clear",
            Done: "Done",
            Loading: "Loading...",
            Select: "Select...",
            Search: "Search",
            Back: "Back",
            OK: "OK",
            "dxCollectionWidget-noDataText": "No data to display",
            "validation-required": "Required",
            "validation-required-formatted": "{0} is required",
            "validation-numeric": "Value must be a number",
            "validation-numeric-formatted": "{0} must be a number",
            "validation-range": "Value is out of range",
            "validation-range-formatted": "{0} is out of range",
            "validation-stringLength": "The length of the value is not correct",
            "validation-stringLength-formatted": "The length of {0} is not correct",
            "validation-custom": "Value is invalid",
            "validation-custom-formatted": "{0} is invalid",
            "validation-compare": "Values do not match",
            "validation-compare-formatted": "{0} does not match",
            "validation-pattern": "Value does not match pattern",
            "validation-pattern-formatted": "{0} does not match pattern",
            "validation-email": "Email is invalid",
            "validation-email-formatted": "{0} is invalid",
            "validation-mask": "Value is invalid"
        }});
    /*! Module core, file widgets-base.en.js */
    Globalize.addCultureInfo("default", {messages: {
            "dxLookup-searchPlaceholder": "Minimum character number: {0}",
            "dxList-pullingDownText": "Pull down to refresh...",
            "dxList-pulledDownText": "Release to refresh...",
            "dxList-refreshingText": "Refreshing...",
            "dxList-pageLoadingText": "Loading...",
            "dxList-nextButtonText": "More",
            "dxList-selectAll": "Select All",
            "dxListEditDecorator-delete": "Delete",
            "dxListEditDecorator-more": "More",
            "dxScrollView-pullingDownText": "Pull down to refresh...",
            "dxScrollView-pulledDownText": "Release to refresh...",
            "dxScrollView-refreshingText": "Refreshing...",
            "dxScrollView-reachBottomText": "Loading...",
            "dxDateBox-simulatedDataPickerTitleTime": "Select time",
            "dxDateBox-simulatedDataPickerTitleDate": "Select date",
            "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
            "dxDateBox-validation-datetime": "Value must be a date or time",
            "dxFileUploader-selectFile": "Select file",
            "dxFileUploader-dropFile": "or Drop file here",
            "dxFileUploader-bytes": "bytes",
            "dxFileUploader-kb": "kb",
            "dxFileUploader-Mb": "Mb",
            "dxFileUploader-Gb": "Gb",
            "dxFileUploader-upload": "Upload",
            "dxFileUploader-uploaded": "Uploaded",
            "dxFileUploader-readyToUpload": "Ready to upload",
            "dxFileUploader-uploadFailedMessage": "Upload failed",
            "dxRangeSlider-ariaFrom": "From {0}",
            "dxRangeSlider-ariaTill": "Till {0}",
            "dxSwitch-onText": "ON",
            "dxSwitch-offText": "OFF",
            "dxForm-optionalMark": "optional"
        }});
    /*! Module core, file widgets-mobile.en.js */
    /*! Module core, file widgets-web.en.js */
    Globalize.addCultureInfo("default", {messages: {
            "dxDataGrid-columnChooserTitle": "Column Chooser",
            "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
            "dxDataGrid-groupContinuesMessage": "Continues on the next page",
            "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
            "dxDataGrid-editingEditRow": "Edit",
            "dxDataGrid-editingSaveRowChanges": "Save",
            "dxDataGrid-editingCancelRowChanges": "Cancel",
            "dxDataGrid-editingDeleteRow": "Delete",
            "dxDataGrid-editingUndeleteRow": "Undelete",
            "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
            "dxDataGrid-editingConfirmDeleteTitle": "",
            "dxDataGrid-validationCancelChanges": "Cancel changes",
            "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
            "dxDataGrid-noDataText": "No data",
            "dxDataGrid-searchPanelPlaceholder": "Search...",
            "dxDataGrid-filterRowShowAllText": "(All)",
            "dxDataGrid-filterRowResetOperationText": "Reset",
            "dxDataGrid-filterRowOperationEquals": "Equals",
            "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
            "dxDataGrid-filterRowOperationLess": "Less than",
            "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
            "dxDataGrid-filterRowOperationGreater": "Greater than",
            "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
            "dxDataGrid-filterRowOperationStartsWith": "Starts with",
            "dxDataGrid-filterRowOperationContains": "Contains",
            "dxDataGrid-filterRowOperationNotContains": "Does not contain",
            "dxDataGrid-filterRowOperationEndsWith": "Ends with",
            "dxDataGrid-filterRowOperationBetween": "Between",
            "dxDataGrid-filterRowOperationBetweenStartText": "Start",
            "dxDataGrid-filterRowOperationBetweenEndText": "End",
            "dxDataGrid-applyFilterText": "Apply filter",
            "dxDataGrid-trueText": "true",
            "dxDataGrid-falseText": "false",
            "dxDataGrid-sortingAscendingText": "Sort Ascending",
            "dxDataGrid-sortingDescendingText": "Sort Descending",
            "dxDataGrid-sortingClearText": "Clear Sorting",
            "dxDataGrid-editingSaveAllChanges": "Save changes",
            "dxDataGrid-editingCancelAllChanges": "Discard changes",
            "dxDataGrid-editingAddRow": "Add a row",
            "dxDataGrid-summaryMin": "Min: {0}",
            "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
            "dxDataGrid-summaryMax": "Max: {0}",
            "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
            "dxDataGrid-summaryAvg": "Avg: {0}",
            "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
            "dxDataGrid-summarySum": "Sum: {0}",
            "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
            "dxDataGrid-summaryCount": "Count: {0}",
            "dxDataGrid-columnFixingFix": "Fix",
            "dxDataGrid-columnFixingUnfix": "Unfix",
            "dxDataGrid-columnFixingLeftPosition": "To the left",
            "dxDataGrid-columnFixingRightPosition": "To the right",
            "dxDataGrid-exportTo": "Export to",
            "dxDataGrid-exportToExcel": "Export to Excel file",
            "dxDataGrid-excelFormat": "Excel file",
            "dxDataGrid-selectedRows": "Selected rows",
            "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
            "dxDataGrid-headerFilterOK": "OK",
            "dxDataGrid-headerFilterCancel": "Cancel",
            "dxDataGrid-ariaColumn": "Column",
            "dxDataGrid-ariaValue": "Value",
            "dxDataGrid-ariaFilterCell": "Filter cell",
            "dxDataGrid-ariaCollapse": "Collapse",
            "dxDataGrid-ariaExpand": "Expand",
            "dxDataGrid-ariaDataGrid": "Data grid",
            "dxDataGrid-ariaSearchInGrid": "Search in data grid",
            "dxDataGrid-ariaSelectAll": "Select all",
            "dxDataGrid-ariaSelectRow": "Select row",
            "dxPager-infoText": "Page {0} of {1} ({2} items)",
            "dxPivotGrid-grandTotal": "Grand Total",
            "dxPivotGrid-total": "{0} Total",
            "dxPivotGrid-fieldChooserTitle": "Field Chooser",
            "dxPivotGrid-showFieldChooser": "Show Field Chooser",
            "dxPivotGrid-expandAll": "Expand All",
            "dxPivotGrid-collapseAll": "Collapse All",
            "dxPivotGrid-sortColumnBySummary": "Sort \"{0}\" by This Column",
            "dxPivotGrid-sortRowBySummary": "Sort \"{0}\" by This Row",
            "dxPivotGrid-removeAllSorting": "Remove All Sorting",
            "dxPivotGrid-rowFields": "Row Fields",
            "dxPivotGrid-columnFields": "Column Fields",
            "dxPivotGrid-dataFields": "Data Fields",
            "dxPivotGrid-filterFields": "Filter Fields",
            "dxPivotGrid-allFields": "All Fields",
            "dxScheduler-editorLabelTitle": "Subject",
            "dxScheduler-editorLabelStartDate": "Start Date",
            "dxScheduler-editorLabelEndDate": "End Date",
            "dxScheduler-editorLabelDescription": "Description",
            "dxScheduler-editorLabelRecurrence": "Repeat",
            "dxScheduler-openAppointment": "Open appointment",
            "dxScheduler-recurrenceNever": "Never",
            "dxScheduler-recurrenceDaily": "Daily",
            "dxScheduler-recurrenceWeekly": "Weekly",
            "dxScheduler-recurrenceMonthly": "Monthly",
            "dxScheduler-recurrenceYearly": "Yearly",
            "dxScheduler-recurrenceEvery": "Every",
            "dxScheduler-recurrenceEnd": "End repeat",
            "dxScheduler-recurrenceAfter": "After",
            "dxScheduler-recurrenceOn": "On",
            "dxScheduler-recurrenceRepeatDaily": "day(s)",
            "dxScheduler-recurrenceRepeatWeekly": "week(s)",
            "dxScheduler-recurrenceRepeatMonthly": "month(s)",
            "dxScheduler-recurrenceRepeatYearly": "year(s)",
            "dxScheduler-switcherDay": "Day",
            "dxScheduler-switcherWeek": "Week",
            "dxScheduler-switcherWorkWeek": "Work week",
            "dxScheduler-switcherMonth": "Month",
            "dxScheduler-switcherTimelineDay": "Timeline Day",
            "dxScheduler-switcherTimelineWeek": "Timeline Week",
            "dxScheduler-switcherTimelineWorkWeek": "Timeline Work week",
            "dxScheduler-switcherTimelineMonth": "Timeline Month",
            "dxScheduler-recurrenceRepeatOnDate": "on date",
            "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
            "dxScheduler-allDay": "All day",
            "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
            "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
            "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
            "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
            "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
            "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
            "dxCalendar-todayButtonText": "Today",
            "dxCalendar-ariaWidgetName": "Calendar",
            "dxColorView-ariaRed": "Red",
            "dxColorView-ariaGreen": "Green",
            "dxColorView-ariaBlue": "Blue",
            "dxColorView-ariaAlpha": "Transparency",
            "dxColorView-ariaHex": "Color code"
        }});
    /*! Module core, file coreNamespace.js */
    DevExpress.define("/coreNamespace", ["/version", "/actionExecutors"], function(version) {
        var ns = window.DevExpress = window.DevExpress || {};
        ns.VERSION = version;
        ns.rtlEnabled = false;
        return ns
    });
    /*! Module core, file componentRegistrator.js */
    DevExpress.define("/componentRegistrator", ["jquery", "/errors", "/coreNamespace", "/utils/utils.memorizedCallbacks", "/utils/utils.publicComponent"], function($, errors, coreNamespace, MemorizedCallbacks, publicComponentUtils) {
        var callbacks = new MemorizedCallbacks;
        var registerComponent = function(name, namespace, componentClass) {
                if (!componentClass) {
                    componentClass = namespace;
                    namespace = coreNamespace
                }
                namespace[name] = componentClass;
                componentClass.publicName(name);
                callbacks.fire(name, componentClass)
            };
        registerComponent.callbacks = callbacks;
        var registerJQueryComponent = function(name, componentClass) {
                $.fn[name] = function(options) {
                    var isMemberInvoke = typeof options === "string",
                        result;
                    if (isMemberInvoke) {
                        var memberName = options,
                            memberArgs = $.makeArray(arguments).slice(1);
                        this.each(function() {
                            var instance = componentClass.getInstance(this);
                            if (!instance)
                                throw errors.Error("E0009", name);
                            var member = instance[memberName],
                                memberValue = member.apply(instance, memberArgs);
                            if (result === undefined)
                                result = memberValue
                        })
                    }
                    else {
                        this.each(function() {
                            var instance = componentClass.getInstance(this);
                            if (instance)
                                instance.option(options);
                            else
                                new componentClass(this, options)
                        });
                        result = this
                    }
                    return result
                }
            };
        callbacks.add(registerJQueryComponent);
        return registerComponent
    });
    /*! Module core, file component.js */
    DevExpress.define("/component", ["/class", "/eventsMixin", "/action", "/errors", "/utils/utils.inflector", "/utils/utils.common", "/utils/utils.publicComponent", "/devices"], function(Class, EventsMixin, Action, errors, inflector, commonUtils, publicComponentUtils, devices) {
        var dataUtils = DevExpress.data.utils;
        var cachedGetters = {};
        var cachedSetters = {};
        var Component = Class.inherit({
                _setDeprecatedOptions: function() {
                    this._deprecatedOptions = {}
                },
                _getDeprecatedOptions: function() {
                    return this._deprecatedOptions
                },
                _setOptionAliases: function() {
                    var aliases = this._optionAliases = {};
                    $.each(this._getDeprecatedOptions(), function(optionName, info) {
                        var optionAlias = info.alias;
                        if (optionAlias)
                            aliases[optionName] = optionAlias
                    })
                },
                _getOptionAliases: function() {
                    return this._optionAliases
                },
                _getOptionAliasesByName: function(optionName) {
                    return $.map(this._getOptionAliases(), function(aliasedOption, aliasName) {
                            return optionName === aliasedOption ? aliasName : undefined
                        })
                },
                _getDefaultOptions: function() {
                    return {
                            onInitialized: null,
                            onOptionChanged: null,
                            onDisposing: null,
                            defaultOptionsRules: null
                        }
                },
                _setDefaultOptions: function() {
                    $.extend(this._options, this._getDefaultOptions())
                },
                _defaultOptionsRules: function() {
                    return []
                },
                _setOptionsByDevice: function(userRules) {
                    var rules = this._defaultOptionsRules();
                    if (this._customRules)
                        rules = rules.concat(this._customRules);
                    if ($.isArray(userRules))
                        rules = rules.concat(userRules);
                    this.option(this._convertRulesToOptions(rules))
                },
                _convertRulesToOptions: function(rules) {
                    var options = {};
                    var currentDevice = devices.current();
                    var deviceMatch = function(device, filter) {
                            filter = $.makeArray(filter);
                            return filter.length === 1 && $.isEmptyObject(filter[0]) || commonUtils.findBestMatches(device, filter).length > 0
                        };
                    $.each(rules, function(index, rule) {
                        var deviceFilter = rule.device || {},
                            match;
                        if ($.isFunction(deviceFilter))
                            match = deviceFilter(currentDevice);
                        else
                            match = deviceMatch(currentDevice, deviceFilter);
                        if (match)
                            $.extend(options, rule.options)
                    });
                    return options
                },
                _isInitialOptionValue: function(name) {
                    var isCustomOption = this._customRules && this._convertRulesToOptions(this._customRules).hasOwnProperty(name);
                    var isInitialOption = this.option(name) === this._initialOptions[name];
                    return !isCustomOption && isInitialOption
                },
                _setOptionsByReference: function() {
                    this._optionsByReference = {}
                },
                _getOptionsByReference: function() {
                    return this._optionsByReference
                },
                ctor: function(options) {
                    this.NAME = this.constructor.publicName();
                    options = options || {};
                    this._options = {};
                    this._updateLockCount = 0;
                    this._optionChangedCallbacks = options._optionChangedCallbacks || $.Callbacks();
                    this._disposingCallbacks = options._disposingCallbacks || $.Callbacks();
                    this.beginUpdate();
                    try {
                        this._suppressDeprecatedWarnings();
                        this._setOptionsByReference();
                        this._setDeprecatedOptions();
                        this._setOptionAliases();
                        this._setDefaultOptions();
                        this._setOptionsByDevice(options.defaultOptionsRules);
                        this._resumeDeprecatedWarnings();
                        this._initialOptions = $.extend({}, this.option());
                        this._initOptions(options)
                    }
                    finally {
                        this.endUpdate()
                    }
                },
                _initOptions: function(options) {
                    this.option(options)
                },
                _optionValuesEqual: function(name, oldValue, newValue) {
                    oldValue = dataUtils.toComparable(oldValue, true);
                    newValue = dataUtils.toComparable(newValue, true);
                    if (oldValue && newValue && oldValue.jquery && newValue.jquery)
                        return newValue.is(oldValue);
                    var oldValueIsNaN = oldValue !== oldValue,
                        newValueIsNaN = newValue !== newValue;
                    if (oldValueIsNaN && newValueIsNaN)
                        return true;
                    if (oldValue === null || typeof oldValue !== "object")
                        return oldValue === newValue;
                    return false
                },
                _init: function() {
                    this._createOptionChangedAction();
                    this.on("optionChanged", function(args) {
                        this._optionChangedCallbacks.fireWith(this, [args])
                    });
                    this.on("disposing", function(args) {
                        this._disposingCallbacks.fireWith(this, [args])
                    })
                },
                _createOptionChangedAction: function() {
                    this._optionChangedAction = this._createActionByOption("onOptionChanged", {excludeValidators: ["disabled", "readOnly", "designMode"]})
                },
                _createDisposingAction: function() {
                    this._disposingAction = this._createActionByOption("onDisposing", {excludeValidators: ["disabled", "readOnly", "designMode"]})
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"onDisposing":
                        case"onInitialized":
                            break;
                        case"onOptionChanged":
                            this._createOptionChangedAction();
                            break;
                        case"defaultOptionsRules":
                            break
                    }
                },
                _dispose: function() {
                    this._createDisposingAction();
                    this._disposingAction();
                    this._disposeEvents();
                    this._disposed = true
                },
                instance: function() {
                    return this
                },
                beginUpdate: function() {
                    this._updateLockCount++
                },
                endUpdate: function() {
                    this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
                    if (!this._updateLockCount)
                        if (!this._initializing && !this._initialized) {
                            this._initializing = true;
                            try {
                                this._init()
                            }
                            finally {
                                this._initializing = false;
                                this._updateLockCount++;
                                this._createActionByOption("onInitialized", {excludeValidators: ["disabled", "readOnly", "designMode"]})();
                                this._updateLockCount--;
                                this._initialized = true
                            }
                        }
                },
                _logWarningIfDeprecated: function(option) {
                    var info = this._getDeprecatedOptions()[option];
                    if (info && !this._deprecatedOptionsSuppressed)
                        this._logDeprecatedWarning(option, info)
                },
                _logDeprecatedWarningCount: 0,
                _logDeprecatedWarning: function(option, info) {
                    var message = info.message || "Use the '" + info.alias + "' option instead";
                    errors.log("W0001", this.NAME, option, info.since, message);
                    ++this._logDeprecatedWarningCount
                },
                _suppressDeprecatedWarnings: function() {
                    this._deprecatedOptionsSuppressed = true
                },
                _resumeDeprecatedWarnings: function() {
                    this._deprecatedOptionsSuppressed = false
                },
                _notifyOptionChanged: function(option, value, previousValue) {
                    var that = this;
                    if (this._initialized)
                        $.each(that._getOptionAliasesByName(option).concat([option]), function(index, name) {
                            var args = {
                                    name: name.split(/[.\[]/)[0],
                                    fullName: name,
                                    value: value,
                                    previousValue: previousValue
                                };
                            that._optionChangedAction($.extend({}, args));
                            if (!that._disposed)
                                that._optionChanged(args)
                        })
                },
                initialOption: function(optionName) {
                    var options = this._initialOptions;
                    return options[optionName]
                },
                _defaultActionConfig: function() {
                    return {
                            context: this,
                            component: this
                        }
                },
                _defaultActionArgs: function() {
                    return {component: this}
                },
                _createAction: function(actionSource, config) {
                    var that = this,
                        action;
                    return function(e) {
                            if (!arguments.length)
                                e = {};
                            if (e instanceof $.Event)
                                throw Error("Action must be executed with jQuery.Event like action({ jQueryEvent: event })");
                            if (!$.isPlainObject(e))
                                e = {actionValue: e};
                            action = action || new Action(actionSource, $.extend(config, that._defaultActionConfig()));
                            return action.execute.call(action, $.extend(e, that._defaultActionArgs()))
                        }
                },
                _createActionByOptionCore: function(optionName, config) {
                    config = config || {};
                    if (typeof optionName !== "string")
                        throw errors.Error("E0008");
                    var matches = /^on(\w+)/.exec(optionName);
                    if (matches) {
                        var eventName = inflector.camelize(matches[1]),
                            beforeExecute = config.beforeExecute || $.noop,
                            that = this;
                        config.beforeExecute = function(args) {
                            that.fireEvent(eventName, args.args);
                            return beforeExecute.apply(this, arguments)
                        }
                    }
                    else
                        throw Error("The '" + optionName + "' option name should start with 'on' prefix");
                    this._suppressDeprecatedWarnings();
                    var action = this._createAction(this.option(optionName), config);
                    this._resumeDeprecatedWarnings();
                    return action
                },
                _createActionByOption: function(optionName, config) {
                    var that = this,
                        action;
                    var result = function() {
                            action = action || that._createActionByOptionCore(optionName, config);
                            return action.apply(that, arguments)
                        };
                    var onActionCreated = this.option("onActionCreated") || $.noop;
                    result = onActionCreated(this, result, config) || result;
                    return result
                },
                option: function(options) {
                    var that = this,
                        name = options,
                        value = arguments[1],
                        optionAliases = this._getOptionAliases();
                    var normalizeOptionName = function(name) {
                            if (name) {
                                that._logWarningIfDeprecated(name);
                                if (optionAliases[name])
                                    name = optionAliases[name]
                            }
                            return name
                        };
                    var getOptionValue = function(name, unwrapObservables) {
                            if (!cachedGetters[name])
                                cachedGetters[name] = dataUtils.compileGetter(name);
                            return cachedGetters[name](that._options, {
                                    functionsAsIs: true,
                                    unwrapObservables: unwrapObservables
                                })
                        };
                    var setOptionValue = function(name, value) {
                            if (!cachedSetters[name])
                                cachedSetters[name] = dataUtils.compileSetter(name);
                            cachedSetters[name](that._options, value, {
                                functionsAsIs: true,
                                merge: !that._getOptionsByReference()[name],
                                unwrapObservables: false
                            });
                            if ($.isPlainObject(value))
                                $.each(value, function(optionName, optionValue) {
                                    optionName = name + "." + optionName;
                                    var normalizedOptionName = normalizeOptionName(optionName);
                                    if (normalizedOptionName !== optionName) {
                                        setOptionValue(optionName, undefined);
                                        setOptionValue(normalizedOptionName, optionValue)
                                    }
                                })
                        };
                    if (arguments.length < 2 && $.type(name) !== "object") {
                        name = normalizeOptionName(name);
                        return getOptionValue(name)
                    }
                    if (typeof name === "string") {
                        options = {};
                        options[name] = value
                    }
                    that.beginUpdate();
                    try {
                        $.each(options, function(name, value) {
                            name = normalizeOptionName(name);
                            var prevValue = getOptionValue(name, false);
                            if (that._optionValuesEqual(name, prevValue, value))
                                return;
                            setOptionValue(name, value);
                            that._notifyOptionChanged(name, value, prevValue)
                        })
                    }
                    finally {
                        that.endUpdate()
                    }
                }
            }).include(EventsMixin);
        Component.publicName = publicComponentUtils.getName;
        return Component
    });
    /*! Module core, file domComponent.js */
    DevExpress.define("/domComponent", ["jquery", "/component", "/errors", "/utils/utils.window", "/utils/utils.common", "/utils/utils.publicComponent", "/ui/events/ui.events.remove"], function($, Component, errors, windowUtils, commonUtils, publicComponentUtils, removeEvent) {
        var abstract = Component.abstract,
            windowResizeCallbacks = windowUtils.resizeCallbacks;
        var RTL_DIRECTION_CLASS = "dx-rtl",
            VISIBILITY_CHANGE_CLASS = "dx-visibility-change-handler",
            VISIBILITY_CHANGE_EVENTNAMESPACE = "VisibilityChange";
        var DOMComponent = Component.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            width: undefined,
                            height: undefined,
                            rtlEnabled: DevExpress.rtlEnabled,
                            disabled: false
                        })
                },
                ctor: function(element, options) {
                    this._$element = $(element);
                    publicComponentUtils.attachInstanceToElement(this._$element, this.constructor.publicName(), this);
                    this.element().one(removeEvent.name, $.proxy(function() {
                        this._dispose()
                    }, this));
                    this.callBase(options)
                },
                _visibilityChanged: abstract,
                _dimensionChanged: abstract,
                _init: function() {
                    this.callBase();
                    this._attachWindowResizeCallback()
                },
                _attachWindowResizeCallback: function() {
                    if (this._isDimensionChangeSupported()) {
                        var windowResizeCallBack = this._windowResizeCallBack = $.proxy(this._dimensionChanged, this);
                        windowResizeCallbacks.add(windowResizeCallBack)
                    }
                },
                _isDimensionChangeSupported: function() {
                    return this._dimensionChanged !== abstract
                },
                _render: function() {
                    this._toggleRTLDirection(this.option("rtlEnabled"));
                    this._renderVisibilityChange();
                    this._renderDimensions()
                },
                _renderVisibilityChange: function() {
                    if (this._isDimensionChangeSupported())
                        this._attachDimensionChangeHandlers();
                    if (!this._isVisibilityChangeSupported())
                        return;
                    this.element().addClass(VISIBILITY_CHANGE_CLASS);
                    this._attachVisiblityChangeHandlers()
                },
                _renderDimensions: function() {
                    var width = this.option("width"),
                        height = this.option("height"),
                        $element = this.element();
                    $element.outerWidth(width);
                    $element.outerHeight(height)
                },
                _attachDimensionChangeHandlers: function() {
                    var that = this;
                    var resizeEventName = "dxresize." + this.NAME + VISIBILITY_CHANGE_EVENTNAMESPACE;
                    that.element().off(resizeEventName).on(resizeEventName, function() {
                        that._dimensionChanged()
                    })
                },
                _attachVisiblityChangeHandlers: function() {
                    var that = this;
                    var hiddingEventName = "dxhiding." + this.NAME + VISIBILITY_CHANGE_EVENTNAMESPACE;
                    var shownEventName = "dxshown." + this.NAME + VISIBILITY_CHANGE_EVENTNAMESPACE;
                    that._isHidden = !that._isVisible();
                    that.element().off(hiddingEventName).on(hiddingEventName, function() {
                        that._checkVisibilityChanged("hiding")
                    }).off(shownEventName).on(shownEventName, function() {
                        that._checkVisibilityChanged("shown")
                    })
                },
                _isVisible: function() {
                    return this.element().is(":visible")
                },
                _checkVisibilityChanged: function(event) {
                    if (event === "hiding" && this._isVisible() && !this._isHidden) {
                        this._visibilityChanged(false);
                        this._isHidden = true
                    }
                    else if (event === "shown" && this._isVisible() && this._isHidden) {
                        this._isHidden = false;
                        this._visibilityChanged(true)
                    }
                },
                _isVisibilityChangeSupported: function() {
                    return this._visibilityChanged !== abstract
                },
                _clean: $.noop,
                _modelByElement: function() {
                    var modelByElement = this.option("modelByElement") || $.noop;
                    return modelByElement(this.element())
                },
                _invalidate: function() {
                    if (!this._updateLockCount)
                        throw errors.Error("E0007");
                    this._requireRefresh = true
                },
                _refresh: function() {
                    this._clean();
                    this._render()
                },
                _dispose: function() {
                    this.callBase();
                    this._clean();
                    this._detachWindowResizeCallback()
                },
                _detachWindowResizeCallback: function() {
                    if (this._isDimensionChangeSupported())
                        windowResizeCallbacks.remove(this._windowResizeCallBack)
                },
                _toggleRTLDirection: function(rtl) {
                    this.element().toggleClass(RTL_DIRECTION_CLASS, rtl)
                },
                _createComponent: function(element, component, config) {
                    var that = this;
                    config = config || {};
                    var synchronizableOptions = $.grep(["rtlEnabled", "disabled"], function(value) {
                            return !(value in config)
                        });
                    var nestedComponentOptions = that.option("nestedComponentOptions") || $.noop;
                    that._extendConfig(config, $.extend({
                        rtlEnabled: this.option("rtlEnabled"),
                        disabled: this.option("disabled")
                    }, nestedComponentOptions(this)));
                    var instance;
                    if (commonUtils.isString(component)) {
                        var $element = $(element)[component](config);
                        instance = $element[component]("instance")
                    }
                    else {
                        instance = component.getInstance(element);
                        if (instance)
                            instance.option(config);
                        else
                            instance = new component(element, config)
                    }
                    if (instance) {
                        var optionChangedHandler = function(args) {
                                if ($.inArray(args.name, synchronizableOptions) >= 0)
                                    instance.option(args.name, args.value)
                            };
                        that.on("optionChanged", optionChangedHandler);
                        instance.on("disposing", function() {
                            that.off("optionChanged", optionChangedHandler)
                        })
                    }
                    return instance
                },
                _extendConfig: function(config, extendConfig) {
                    $.each(extendConfig, function(key, value) {
                        config[key] = config.hasOwnProperty(key) ? config[key] : value
                    })
                },
                _defaultActionConfig: function() {
                    return $.extend(this.callBase(), {context: this._modelByElement(this.element())})
                },
                _defaultActionArgs: function() {
                    var element = this.element(),
                        model = this._modelByElement(this.element());
                    return $.extend(this.callBase(), {
                            element: element,
                            model: model
                        })
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"width":
                        case"height":
                            this._renderDimensions();
                            break;
                        case"rtlEnabled":
                            this._invalidate();
                            break;
                        case"disabled":
                            break;
                        default:
                            this.callBase(args);
                            break
                    }
                },
                endUpdate: function() {
                    var requireRender = !this._initializing && !this._initialized;
                    this.callBase.apply(this, arguments);
                    if (!this._updateLockCount)
                        if (requireRender)
                            this._render();
                        else if (this._requireRefresh) {
                            this._requireRefresh = false;
                            this._refresh()
                        }
                },
                element: function() {
                    return this._$element
                }
            });
        DOMComponent.getInstance = function($element) {
            return publicComponentUtils.getInstanceByElement($element, this.publicName())
        };
        DOMComponent.defaultOptions = function(rule) {
            this.prototype._customRules = this.prototype._customRules || [];
            this.prototype._customRules.push(rule)
        };
        return DOMComponent
    });
    /*! Module core, file version.js */
    DevExpress.define("/version", [], function() {
        return "15.2.4"
    });
    /*! Module core, file errors.js */
    DevExpress.define("/errors", ["/utils/utils.error"], function(errorUtils) {
        return errorUtils({
                E0001: "Method is not implemented",
                E0002: "Member name collision: {0}",
                E0003: "A class must be instantiated using the 'new' keyword",
                E0004: "The NAME property of the component is not specified",
                E0005: "Unknown device",
                E0006: "Unknown endpoint key is requested",
                E0007: "'Invalidate' method is called outside the update transaction",
                E0008: "Type of the option name is not appropriate to create an action",
                E0009: "Component '{0}' has not been initialized for an element",
                E0010: "Animation configuration with the '{0}' type requires '{1}' configuration as {2}",
                E0011: "Unknown animation type '{0}'",
                E0012: "jQuery version is too old. Please upgrade jQuery to 1.10.0 or later",
                E0013: "KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later",
                E0014: "The 'release' method shouldn't be called for an unlocked Lock object",
                E0015: "Queued task returned an unexpected result",
                E0017: "Event namespace is not defined",
                E0018: "DevExpress.ui.DevExpressPopup widget is required",
                E0020: "Template engine '{0}' is not supported",
                E0021: "Unknown theme is set: {0}",
                E0022: "LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts",
                E0023: "Template name is not specified",
                E0100: "Unknown validation type is detected",
                E0101: "Misconfigured range validation rule is detected",
                E0102: "Misconfigured comparison validation rule is detected",
                E0110: "Unknown validation group is detected",
                E0120: "Adapter for a DevExpressValidator component cannot be configured",
                W0000: "'{0}' is deprecated in {1}. {2}",
                W0001: "{0} - '{1}' option is deprecated in {2}. {3}",
                W0002: "{0} - '{1}' method is deprecated in {2}. {3}",
                W0003: "{0} - '{1}' property is deprecated in {2}. {3}",
                W0004: "Timeout for theme loading is over: {0}",
                W0005: "'{0}' event is deprecated in {1}. {2}",
                W0006: "Invalid recurrence rule: '{0}'",
                W0007: "The cellDuration option value is invalid"
            })
    });
    /*! Module core, file eventsMixin.js */
    DevExpress.define("/eventsMixin", ["jquery", "/errors"], function($, errors) {
        return {
                ctor: function() {
                    this._events = {}
                },
                fireEvent: function(eventName, eventArgs) {
                    var callbacks = this._events[eventName];
                    if (callbacks)
                        callbacks.fireWith(this, eventArgs);
                    return this
                },
                on: function(eventName, eventHandler) {
                    if ($.isPlainObject(eventName))
                        $.each(eventName, $.proxy(function(e, h) {
                            this.on(e, h)
                        }, this));
                    else {
                        var callbacks = this._events[eventName],
                            addFn;
                        if (!callbacks) {
                            callbacks = $.Callbacks();
                            this._events[eventName] = callbacks
                        }
                        addFn = callbacks.originalAdd || callbacks.add;
                        addFn.call(callbacks, eventHandler)
                    }
                    return this
                },
                off: function(eventName, eventHandler) {
                    var callbacks = this._events[eventName];
                    if (callbacks)
                        if ($.isFunction(eventHandler))
                            callbacks.remove(eventHandler);
                        else
                            callbacks.empty();
                    return this
                },
                _disposeEvents: function() {
                    $.each(this._events, function() {
                        this.empty()
                    })
                }
            }
    });
    /*! Module core, file class.js */
    DevExpress.define("/class", ["jquery", "/errors"], function($, errors) {
        var wrapOverridden = function(baseProto, methodName, method) {
                return function() {
                        var prevCallBase = this.callBase;
                        this.callBase = baseProto[methodName];
                        try {
                            return method.apply(this, arguments)
                        }
                        finally {
                            this.callBase = prevCallBase
                        }
                    }
            };
        var clonePrototype = function(obj) {
                var func = function(){};
                func.prototype = obj.prototype;
                return new func
            };
        var redefine = function(members) {
                var that = this;
                if (!members)
                    return that;
                var memberNames = $.map(members, function(_, k) {
                        return k
                    });
                $.each(["toString", "toLocaleString", "valueOf"], function() {
                    if (members[this])
                        memberNames.push(this)
                });
                $.each(memberNames, function() {
                    var overridden = $.isFunction(that.prototype[this]) && $.isFunction(members[this]);
                    that.prototype[this] = overridden ? wrapOverridden(that.parent.prototype, this, members[this]) : members[this]
                });
                return that
            };
        var include = function() {
                var classObj = this;
                $.each(arguments, function() {
                    if (this.ctor)
                        classObj._includedCtors.push(this.ctor);
                    if (this.postCtor)
                        classObj._includedPostCtors.push(this.postCtor);
                    for (var name in this) {
                        if (name === "ctor" || name === "postCtor")
                            continue;
                        if (name in classObj.prototype)
                            throw errors.Error("E0002", name);
                        classObj.prototype[name] = this[name]
                    }
                });
                return classObj
            };
        var subclassOf = function(parentClass) {
                if (this.parent === parentClass)
                    return true;
                if (!this.parent || !this.parent.subclassOf)
                    return false;
                return this.parent.subclassOf(parentClass)
            };
        var abstract = function() {
                throw errors.Error("E0001");
            };
        var copyStatic = function() {
                var hasOwn = Object.prototype.hasOwnProperty;
                return function(source, destination) {
                        $.each(source, function(key) {
                            if (!hasOwn.call(source, key))
                                return;
                            destination[key] = source[key]
                        })
                    }
            }();
        var classImpl = function(){};
        classImpl.inherit = function(members) {
            var inheritor = function() {
                    if (!this || this === window || typeof this.constructor !== "function")
                        throw errors.Error("E0003");
                    var instance = this,
                        ctor = instance.ctor;
                    $.each(instance.constructor._includedCtors, function() {
                        this.call(instance)
                    });
                    if (ctor)
                        ctor.apply(instance, arguments);
                    $.each(instance.constructor._includedPostCtors, function() {
                        this.call(instance)
                    })
                };
            inheritor.prototype = clonePrototype(this);
            copyStatic(this, inheritor);
            inheritor.inherit = this.inherit;
            inheritor.abstract = abstract;
            inheritor.redefine = redefine;
            inheritor.include = include;
            inheritor.subclassOf = subclassOf;
            inheritor.parent = this;
            inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
            inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
            inheritor.prototype.constructor = inheritor;
            inheritor.redefine(members);
            return inheritor
        };
        classImpl.abstract = abstract;
        return classImpl
    });
    /*! Module core, file devices.js */
    DevExpress.define("/devices", ["jquery", "/class", "/eventsMixin", "/errors", "/utils/utils.storage", "/utils/utils.viewPort", "/utils/utils.window"], function($, Class, EventsMixin, errors, storageUtils, viewPort, windowUtils) {
        var KNOWN_UA_TABLE = {
                iPhone: "iPhone",
                iPhone5: "iPhone",
                iPhone6: "iPhone",
                iPhone6plus: "iPhone",
                iPad: "iPad",
                iPadMini: "iPad Mini",
                androidPhone: "Android Mobile",
                androidTablet: "Android",
                win8: "MSAppHost",
                win8Phone: "Windows Phone 8.0",
                msSurface: "MSIE ARM Tablet PC",
                desktop: "desktop",
                win10Phone: "Windows Phone 10.0",
                win10: "MSAppHost/3.0"
            };
        var DEFAULT_DEVICE = {
                deviceType: "",
                platform: "",
                version: [],
                phone: false,
                tablet: false,
                android: false,
                ios: false,
                win: false,
                generic: false,
                grade: "A",
                mac: false
            };
        $.extend(DEFAULT_DEVICE, {
            platform: "generic",
            deviceType: "desktop",
            generic: true
        });
        var uaParsers = {
                win: function(userAgent) {
                    var isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/),
                        isTablet = !isPhone && /arm(.*)trident/i.test(userAgent),
                        isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
                    if (!(isPhone || isTablet || isDesktop))
                        return;
                    var matches = userAgent.match(/windows phone (\d+).(\d+)/i) || userAgent.match(/windows nt (\d+).(\d+)/i),
                        version = [];
                    if (matches)
                        version.push(parseInt(matches[1], 10), parseInt(matches[2], 10));
                    else {
                        matches = userAgent.match(/msapphost(\/(\d+).(\d+))?/i);
                        matches && version.push(parseInt(matches[2], 10) === 3 ? 10 : 8)
                    }
                    return {
                            deviceType: isPhone ? "phone" : isTablet ? "tablet" : "desktop",
                            platform: "win",
                            version: version,
                            grade: "A"
                        }
                },
                ios: function(userAgent) {
                    if (!/ip(hone|od|ad)/i.test(userAgent))
                        return;
                    var isPhone = /ip(hone|od)/i.test(userAgent),
                        matches = userAgent.match(/os (\d+)_(\d+)_?(\d+)?/i),
                        version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [],
                        isIPhone4 = window.screen.height === 960 / 2,
                        grade = isIPhone4 ? "B" : "A";
                    return {
                            deviceType: isPhone ? "phone" : "tablet",
                            platform: "ios",
                            version: version,
                            grade: grade
                        }
                },
                android: function(userAgent) {
                    if (!/android|htc_|silk/i.test(userAgent))
                        return;
                    var isPhone = /mobile/i.test(userAgent),
                        matches = userAgent.match(/android (\d+)\.(\d+)\.?(\d+)?/i),
                        version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [],
                        worseThan4_4 = version.length > 1 && (version[0] < 4 || version[0] === 4 && version[1] < 4),
                        grade = worseThan4_4 ? "B" : "A";
                    return {
                            deviceType: isPhone ? "phone" : "tablet",
                            platform: "android",
                            version: version,
                            grade: grade
                        }
                }
            };
        var Devices = Class.inherit({
                ctor: function(options) {
                    this._window = options && options.window || window;
                    this._realDevice = this._getDevice();
                    this._currentDevice = undefined;
                    this._currentOrientation = undefined;
                    this.changed = $.Callbacks();
                    this._recalculateOrientation();
                    windowUtils.resizeCallbacks.add($.proxy(this._recalculateOrientation, this))
                },
                current: function(deviceOrName) {
                    if (deviceOrName) {
                        this._currentDevice = this._getDevice(deviceOrName);
                        this._forced = true;
                        this.changed.fire()
                    }
                    else {
                        if (!this._currentDevice) {
                            deviceOrName = undefined;
                            try {
                                deviceOrName = this._getDeviceOrNameFromWindowScope()
                            }
                            catch(e) {
                                deviceOrName = this._getDeviceNameFromSessionStorage()
                            }
                            finally {
                                if (!deviceOrName)
                                    deviceOrName = this._getDeviceNameFromSessionStorage();
                                if (deviceOrName)
                                    this._forced = true
                            }
                            this._currentDevice = this._getDevice(deviceOrName)
                        }
                        return this._currentDevice
                    }
                },
                real: function() {
                    var forceDevice = arguments[0];
                    if ($.isPlainObject(forceDevice)) {
                        $.extend(this._realDevice, forceDevice);
                        return
                    }
                    return $.extend({}, this._realDevice)
                },
                orientation: function() {
                    return this._currentOrientation
                },
                isForced: function() {
                    return this._forced
                },
                isRippleEmulator: function() {
                    return !!this._window.tinyHippos
                },
                _getCssClasses: function(device) {
                    var result = [];
                    var realDevice = this._realDevice;
                    device = device || this.current();
                    if (device.deviceType) {
                        result.push("dx-device-" + device.deviceType);
                        if (device.deviceType !== "desktop")
                            result.push("dx-device-mobile")
                    }
                    result.push("dx-device-" + realDevice.platform);
                    if (realDevice.version && realDevice.version.length)
                        result.push("dx-device-" + realDevice.platform + "-" + realDevice.version[0]);
                    if (devices.isSimulator())
                        result.push("dx-simulator");
                    if (DevExpress.rtlEnabled)
                        result.push("dx-rtl");
                    return result
                },
                attachCssClasses: function(element, device) {
                    this._deviceClasses = this._getCssClasses(device).join(" ");
                    $(element).addClass(this._deviceClasses)
                },
                detachCssClasses: function(element) {
                    $(element).removeClass(this._deviceClasses)
                },
                isSimulator: function() {
                    try {
                        return this._isSimulator || this._window.top !== this._window.self && this._window.top["dx-force-device"] || this.isRippleEmulator()
                    }
                    catch(e) {
                        return false
                    }
                },
                forceSimulator: function() {
                    this._isSimulator = true
                },
                _getDevice: function(deviceName) {
                    if (deviceName === "genericPhone")
                        deviceName = {
                            deviceType: "phone",
                            platform: "generic",
                            generic: true
                        };
                    if ($.isPlainObject(deviceName))
                        return this._fromConfig(deviceName);
                    else {
                        var ua;
                        if (deviceName) {
                            ua = KNOWN_UA_TABLE[deviceName];
                            if (!ua)
                                throw errors.Error("E0005");
                        }
                        else
                            ua = navigator.userAgent;
                        return this._fromUA(ua)
                    }
                },
                _getDeviceOrNameFromWindowScope: function() {
                    var result;
                    if (this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"])
                        result = this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"];
                    return result
                },
                _getDeviceNameFromSessionStorage: function() {
                    var sessionStorage = storageUtils.sessionStorage();
                    if (!sessionStorage)
                        return;
                    var deviceOrName = sessionStorage.getItem("dx-force-device");
                    try {
                        return $.parseJSON(deviceOrName)
                    }
                    catch(ex) {
                        return deviceOrName
                    }
                },
                _fromConfig: function(config) {
                    var result = $.extend({}, DEFAULT_DEVICE, this._currentDevice, config),
                        shortcuts = {
                            phone: result.deviceType === "phone",
                            tablet: result.deviceType === "tablet",
                            android: result.platform === "android",
                            ios: result.platform === "ios",
                            win: result.platform === "win",
                            generic: result.platform === "generic"
                        };
                    return $.extend(result, shortcuts)
                },
                _fromUA: function(ua) {
                    var config;
                    $.each(uaParsers, function(platform, parser) {
                        config = parser(ua);
                        return !config
                    });
                    if (config)
                        return this._fromConfig(config);
                    var isMac = /(mac os)/.test(ua.toLowerCase()),
                        deviceWithOS = DEFAULT_DEVICE;
                    deviceWithOS.mac = isMac;
                    return deviceWithOS
                },
                _changeOrientation: function() {
                    var $window = $(this._window),
                        orientation = $window.height() > $window.width() ? "portrait" : "landscape";
                    if (this._currentOrientation === orientation)
                        return;
                    this._currentOrientation = orientation;
                    this.fireEvent("orientationChanged", [{orientation: orientation}])
                },
                _recalculateOrientation: function() {
                    var windowWidth = $(this._window).width();
                    if (this._currentWidth === windowWidth)
                        return;
                    this._currentWidth = windowWidth;
                    this._changeOrientation()
                }
            }).include(EventsMixin);
        var devices = new Devices;
        viewPort.changeCallback.add(function(viewPort, prevViewport) {
            devices.detachCssClasses(prevViewport);
            devices.attachCssClasses(viewPort)
        });
        return devices
    });
    /*! Module core, file action.js */
    DevExpress.define("/action", ["jquery", "/class"], function($, Class) {
        var Action = Class.inherit({
                ctor: function(action, config) {
                    config = config || {};
                    this._action = action;
                    this._context = config.context || window;
                    this._beforeExecute = config.beforeExecute;
                    this._afterExecute = config.afterExecute;
                    this._component = config.component;
                    this._validatingTargetName = config.validatingTargetName;
                    var excludeValidators = this._excludeValidators = {};
                    $.each(config.excludeValidators || [], function(_, name) {
                        excludeValidators[name] = true
                    })
                },
                execute: function() {
                    var e = {
                            action: this._action,
                            args: Array.prototype.slice.call(arguments),
                            context: this._context,
                            component: this._component,
                            validatingTargetName: this._validatingTargetName,
                            cancel: false,
                            handled: false
                        };
                    var beforeExecute = this._beforeExecute,
                        afterExecute = this._afterExecute;
                    if (!this._validateAction(e))
                        return;
                    beforeExecute && beforeExecute.call(this._context, e);
                    if (e.cancel)
                        return;
                    var result = this._executeAction(e);
                    var argsBag = e.args[0];
                    if (argsBag && argsBag.cancel)
                        return;
                    afterExecute && afterExecute.call(this._context, e);
                    return result
                },
                _validateAction: function(e) {
                    var excludeValidators = this._excludeValidators,
                        executors = Action.executors;
                    for (var name in executors)
                        if (!excludeValidators[name]) {
                            var executor = executors[name];
                            if (executor.validate)
                                executor.validate(e);
                            if (e.cancel)
                                return false
                        }
                    return true
                },
                _executeAction: function(e) {
                    var result,
                        executors = Action.executors;
                    for (var name in executors) {
                        var executor = executors[name];
                        if (executor.execute)
                            executor.execute(e);
                        if (e.handled) {
                            result = e.result;
                            break
                        }
                    }
                    return result
                }
            });
        Action.executors = {};
        Action.registerExecutor = function(name, executor) {
            if ($.isPlainObject(name)) {
                $.each(name, Action.registerExecutor);
                return
            }
            Action.executors[name] = executor
        };
        Action.unregisterExecutor = function() {
            var args = $.makeArray(arguments);
            $.each(args, function() {
                delete Action.executors[this]
            })
        };
        return Action
    });
    /*! Module core, file actionExecutors.js */
    DevExpress.define("/actionExecutors", ["jquery", "/action"], function($, Action) {
        Action.registerExecutor({
            undefined: {execute: function(e) {
                    if (!e.action) {
                        e.result = undefined;
                        e.handled = true
                    }
                }},
            func: {execute: function(e) {
                    if ($.isFunction(e.action)) {
                        e.result = e.action.call(e.context, e.args[0]);
                        e.handled = true
                    }
                }},
            url: {execute: function(e) {
                    if (typeof e.action === "string" && e.action.charAt(0) !== "#")
                        document.location = e.action
                }},
            hash: {execute: function(e) {
                    if (typeof e.action === "string" && e.action.charAt(0) === "#")
                        document.location.hash = e.action
                }}
        })
    });
    /*! Module core, file animator.js */
    DevExpress.define("/animator", ["jquery", "/class", "/utils/utils.animationFrame"], function($, Class, animationFrame) {
        var abstract = Class.abstract;
        return Class.inherit({
                ctor: function() {
                    this._finished = true;
                    this._stopped = false;
                    this._proxiedStepCore = $.proxy(this._stepCore, this)
                },
                start: function() {
                    this._stopped = false;
                    this._finished = false;
                    this._stepCore()
                },
                stop: function() {
                    this._stopped = true;
                    animationFrame.cancel(this._stepAnimationFrame)
                },
                _stepCore: function() {
                    if (this._isStopped()) {
                        this._stop();
                        return
                    }
                    if (this._isFinished()) {
                        this._finished = true;
                        this._complete();
                        return
                    }
                    this._step();
                    this._stepAnimationFrame = animationFrame.request(this._proxiedStepCore)
                },
                _step: abstract,
                _isFinished: $.noop,
                _stop: $.noop,
                _complete: $.noop,
                _isStopped: function() {
                    return this._stopped
                },
                inProgress: function() {
                    return !(this._stopped || this._finished)
                }
            })
    });
    /*! Module core, file endpointSelector.js */
    DevExpress.define("/endpointSelector", ["jquery", "/errors", "/utils/utils.proxyUrlFormatter"], function($, errors, proxyUrlFormatter) {
        var location = window.location,
            IS_WINJS_ORIGIN = location.protocol === "ms-appx:",
            IS_LOCAL_ORIGIN = isLocalHostName(location.hostname);
        function isLocalHostName(url) {
            return /^(localhost$|127\.)/i.test(url)
        }
        var EndpointSelector = function(config) {
                this.config = config
            };
        EndpointSelector.prototype = {urlFor: function(key) {
                var bag = this.config[key];
                if (!bag)
                    throw errors.Error("E0006");
                if (proxyUrlFormatter.isProxyUsed())
                    return proxyUrlFormatter.formatProxyUrl(bag.local);
                if (bag.production)
                    if (IS_WINJS_ORIGIN && !Debug.debuggerEnabled || !IS_WINJS_ORIGIN && !IS_LOCAL_ORIGIN)
                        return bag.production;
                return bag.local
            }};
        return EndpointSelector
    });
    /*! Module core, file color.js */
    DevExpress.define("/color", [], function() {
        var standardColorNames = {
                aliceblue: 'f0f8ff',
                antiquewhite: 'faebd7',
                aqua: '00ffff',
                aquamarine: '7fffd4',
                azure: 'f0ffff',
                beige: 'f5f5dc',
                bisque: 'ffe4c4',
                black: '000000',
                blanchedalmond: 'ffebcd',
                blue: '0000ff',
                blueviolet: '8a2be2',
                brown: 'a52a2a',
                burlywood: 'deb887',
                cadetblue: '5f9ea0',
                chartreuse: '7fff00',
                chocolate: 'd2691e',
                coral: 'ff7f50',
                cornflowerblue: '6495ed',
                cornsilk: 'fff8dc',
                crimson: 'dc143c',
                cyan: '00ffff',
                darkblue: '00008b',
                darkcyan: '008b8b',
                darkgoldenrod: 'b8860b',
                darkgray: 'a9a9a9',
                darkgreen: '006400',
                darkkhaki: 'bdb76b',
                darkmagenta: '8b008b',
                darkolivegreen: '556b2f',
                darkorange: 'ff8c00',
                darkorchid: '9932cc',
                darkred: '8b0000',
                darksalmon: 'e9967a',
                darkseagreen: '8fbc8f',
                darkslateblue: '483d8b',
                darkslategray: '2f4f4f',
                darkturquoise: '00ced1',
                darkviolet: '9400d3',
                deeppink: 'ff1493',
                deepskyblue: '00bfff',
                dimgray: '696969',
                dodgerblue: '1e90ff',
                feldspar: 'd19275',
                firebrick: 'b22222',
                floralwhite: 'fffaf0',
                forestgreen: '228b22',
                fuchsia: 'ff00ff',
                gainsboro: 'dcdcdc',
                ghostwhite: 'f8f8ff',
                gold: 'ffd700',
                goldenrod: 'daa520',
                gray: '808080',
                green: '008000',
                greenyellow: 'adff2f',
                honeydew: 'f0fff0',
                hotpink: 'ff69b4',
                indianred: 'cd5c5c',
                indigo: '4b0082',
                ivory: 'fffff0',
                khaki: 'f0e68c',
                lavender: 'e6e6fa',
                lavenderblush: 'fff0f5',
                lawngreen: '7cfc00',
                lemonchiffon: 'fffacd',
                lightblue: 'add8e6',
                lightcoral: 'f08080',
                lightcyan: 'e0ffff',
                lightgoldenrodyellow: 'fafad2',
                lightgrey: 'd3d3d3',
                lightgreen: '90ee90',
                lightpink: 'ffb6c1',
                lightsalmon: 'ffa07a',
                lightseagreen: '20b2aa',
                lightskyblue: '87cefa',
                lightslateblue: '8470ff',
                lightslategray: '778899',
                lightsteelblue: 'b0c4de',
                lightyellow: 'ffffe0',
                lime: '00ff00',
                limegreen: '32cd32',
                linen: 'faf0e6',
                magenta: 'ff00ff',
                maroon: '800000',
                mediumaquamarine: '66cdaa',
                mediumblue: '0000cd',
                mediumorchid: 'ba55d3',
                mediumpurple: '9370d8',
                mediumseagreen: '3cb371',
                mediumslateblue: '7b68ee',
                mediumspringgreen: '00fa9a',
                mediumturquoise: '48d1cc',
                mediumvioletred: 'c71585',
                midnightblue: '191970',
                mintcream: 'f5fffa',
                mistyrose: 'ffe4e1',
                moccasin: 'ffe4b5',
                navajowhite: 'ffdead',
                navy: '000080',
                oldlace: 'fdf5e6',
                olive: '808000',
                olivedrab: '6b8e23',
                orange: 'ffa500',
                orangered: 'ff4500',
                orchid: 'da70d6',
                palegoldenrod: 'eee8aa',
                palegreen: '98fb98',
                paleturquoise: 'afeeee',
                palevioletred: 'd87093',
                papayawhip: 'ffefd5',
                peachpuff: 'ffdab9',
                peru: 'cd853f',
                pink: 'ffc0cb',
                plum: 'dda0dd',
                powderblue: 'b0e0e6',
                purple: '800080',
                red: 'ff0000',
                rosybrown: 'bc8f8f',
                royalblue: '4169e1',
                saddlebrown: '8b4513',
                salmon: 'fa8072',
                sandybrown: 'f4a460',
                seagreen: '2e8b57',
                seashell: 'fff5ee',
                sienna: 'a0522d',
                silver: 'c0c0c0',
                skyblue: '87ceeb',
                slateblue: '6a5acd',
                slategray: '708090',
                snow: 'fffafa',
                springgreen: '00ff7f',
                steelblue: '4682b4',
                tan: 'd2b48c',
                teal: '008080',
                thistle: 'd8bfd8',
                tomato: 'ff6347',
                turquoise: '40e0d0',
                violet: 'ee82ee',
                violetred: 'd02090',
                wheat: 'f5deb3',
                white: 'ffffff',
                whitesmoke: 'f5f5f5',
                yellow: 'ffff00',
                yellowgreen: '9acd32'
            };
        var standardColorTypes = [{
                    re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                    process: function(colorString) {
                        return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10)]
                    }
                }, {
                    re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*\.*\d+)\)$/,
                    process: function(colorString) {
                        return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10), parseFloat(colorString[4])]
                    }
                }, {
                    re: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/,
                    process: function(colorString) {
                        return [parseInt(colorString[1], 16), parseInt(colorString[2], 16), parseInt(colorString[3], 16)]
                    }
                }, {
                    re: /^#([a-f0-9]{1})([a-f0-9]{1})([a-f0-9]{1})$/,
                    process: function(colorString) {
                        return [parseInt(colorString[1] + colorString[1], 16), parseInt(colorString[2] + colorString[2], 16), parseInt(colorString[3] + colorString[3], 16)]
                    }
                }, {
                    re: /^hsv\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                    process: function(colorString) {
                        var h = parseInt(colorString[1], 10),
                            s = parseInt(colorString[2], 10),
                            v = parseInt(colorString[3], 10),
                            rgb = hsvToRgb(h, s, v);
                        return [rgb[0], rgb[1], rgb[2], 1, [h, s, v]]
                    }
                }, {
                    re: /^hsl\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                    process: function(colorString) {
                        var h = parseInt(colorString[1], 10),
                            s = parseInt(colorString[2], 10),
                            l = parseInt(colorString[3], 10),
                            rgb = hslToRgb(h, s, l);
                        return [rgb[0], rgb[1], rgb[2], 1, null, [h, s, l]]
                    }
                }];
        function Color(value) {
            this.baseColor = value;
            var color;
            if (value) {
                color = String(value).toLowerCase().replace(/ /g, '');
                color = standardColorNames[color] ? '#' + standardColorNames[color] : color;
                color = parseColor(color)
            }
            if (!color)
                this.colorIsInvalid = true;
            color = color || {};
            this.r = normalize(color[0]);
            this.g = normalize(color[1]);
            this.b = normalize(color[2]);
            this.a = normalize(color[3], 1, 1);
            if (color[4])
                this.hsv = {
                    h: color[4][0],
                    s: color[4][1],
                    v: color[4][2]
                };
            else
                this.hsv = toHsvFromRgb(this.r, this.g, this.b);
            if (color[5])
                this.hsl = {
                    h: color[5][0],
                    s: color[5][1],
                    l: color[5][2]
                };
            else
                this.hsl = toHslFromRgb(this.r, this.g, this.b)
        }
        function parseColor(color) {
            if (color === "transparent")
                return [0, 0, 0, 0];
            var i = 0,
                ii = standardColorTypes.length,
                str;
            for (; i < ii; ++i) {
                str = standardColorTypes[i].re.exec(color);
                if (str)
                    return standardColorTypes[i].process(str)
            }
            return null
        }
        function normalize(colorComponent, def, max) {
            def = def || 0;
            max = max || 255;
            return colorComponent < 0 || isNaN(colorComponent) ? def : colorComponent > max ? max : colorComponent
        }
        function toHexFromRgb(r, g, b) {
            return '#' + (0X01000000 | r << 16 | g << 8 | b).toString(16).slice(1)
        }
        function toHsvFromRgb(r, g, b) {
            var max = Math.max(r, g, b),
                min = Math.min(r, g, b),
                delta = max - min,
                H,
                S,
                V;
            V = max;
            S = max === 0 ? 0 : 1 - min / max;
            if (max === min)
                H = 0;
            else
                switch (max) {
                    case r:
                        H = 60 * ((g - b) / delta);
                        if (g < b)
                            H = H + 360;
                        break;
                    case g:
                        H = 60 * ((b - r) / delta) + 120;
                        break;
                    case b:
                        H = 60 * ((r - g) / delta) + 240;
                        break
                }
            S *= 100;
            V *= 100 / 255;
            return {
                    h: Math.round(H),
                    s: Math.round(S),
                    v: Math.round(V)
                }
        }
        function hsvToRgb(h, s, v) {
            var Vdec,
                Vinc,
                Vmin,
                Hi,
                a,
                r,
                g,
                b;
            Hi = Math.floor(h % 360 / 60);
            Vmin = (100 - s) * v / 100;
            a = (v - Vmin) * (h % 60 / 60);
            Vinc = Vmin + a;
            Vdec = v - a;
            switch (Hi) {
                case 0:
                    r = v;
                    g = Vinc;
                    b = Vmin;
                    break;
                case 1:
                    r = Vdec;
                    g = v;
                    b = Vmin;
                    break;
                case 2:
                    r = Vmin;
                    g = v;
                    b = Vinc;
                    break;
                case 3:
                    r = Vmin;
                    g = Vdec;
                    b = v;
                    break;
                case 4:
                    r = Vinc;
                    g = Vmin;
                    b = v;
                    break;
                case 5:
                    r = v;
                    g = Vmin;
                    b = Vdec;
                    break
            }
            return [Math.round(r * 2.55), Math.round(g * 2.55), Math.round(b * 2.55)]
        }
        function calculateHue(r, g, b, delta) {
            var max = Math.max(r, g, b);
            switch (max) {
                case r:
                    return (g - b) / delta + (g < b ? 6 : 0);
                case g:
                    return (b - r) / delta + 2;
                case b:
                    return (r - g) / delta + 4
            }
        }
        function toHslFromRgb(r, g, b) {
            r = convertTo01Bounds(r, 255);
            g = convertTo01Bounds(g, 255);
            b = convertTo01Bounds(b, 255);
            var max = Math.max(r, g, b),
                min = Math.min(r, g, b),
                maxMinSumm = max + min,
                h,
                s,
                l = maxMinSumm / 2;
            if (max === min)
                h = s = 0;
            else {
                var delta = max - min;
                if (l > 0.5)
                    s = delta / (2 - maxMinSumm);
                else
                    s = delta / maxMinSumm;
                h = calculateHue(r, g, b, delta);
                h /= 6
            }
            return {
                    h: _round(h * 360),
                    s: _round(s * 100),
                    l: _round(l * 100)
                }
        }
        function makeTc(colorPart, h) {
            var Tc = h;
            if (colorPart === "r")
                Tc = h + 1 / 3;
            if (colorPart === "b")
                Tc = h - 1 / 3;
            return Tc
        }
        function modifyTc(Tc) {
            if (Tc < 0)
                Tc += 1;
            if (Tc > 1)
                Tc -= 1;
            return Tc
        }
        function hueToRgb(p, q, Tc) {
            Tc = modifyTc(Tc);
            if (Tc < 1 / 6)
                return p + (q - p) * 6 * Tc;
            if (Tc < 1 / 2)
                return q;
            if (Tc < 2 / 3)
                return p + (q - p) * (2 / 3 - Tc) * 6;
            return p
        }
        function hslToRgb(h, s, l) {
            var r,
                g,
                b;
            h = convertTo01Bounds(h, 360),
            s = convertTo01Bounds(s, 100),
            l = convertTo01Bounds(l, 100);
            if (s === 0)
                r = g = b = l;
            else {
                var q = l < 0.5 ? l * (1 + s) : l + s - l * s,
                    p = 2 * l - q;
                r = hueToRgb(p, q, makeTc("r", h));
                g = hueToRgb(p, q, makeTc("g", h));
                b = hueToRgb(p, q, makeTc("b", h))
            }
            return [_round(r * 255), _round(g * 255), _round(b * 255)]
        }
        function convertTo01Bounds(n, max) {
            n = Math.min(max, Math.max(0, parseFloat(n)));
            if (Math.abs(n - max) < 0.000001)
                return 1;
            return n % max / parseFloat(max)
        }
        function isIntegerBtwMinAndMax(number, min, max) {
            min = min || 0;
            max = max || 255;
            if (number % 1 !== 0 || number < min || number > max || typeof number !== 'number' || isNaN(number))
                return false;
            return true
        }
        var _round = Math.round;
        Color.prototype = {
            constructor: Color,
            highlight: function(step) {
                step = step || 10;
                return this.alter(step).toHex()
            },
            darken: function(step) {
                step = step || 10;
                return this.alter(-step).toHex()
            },
            alter: function(step) {
                var result = new Color;
                result.r = normalize(this.r + step);
                result.g = normalize(this.g + step);
                result.b = normalize(this.b + step);
                return result
            },
            blend: function(blendColor, opacity) {
                var other = blendColor instanceof Color ? blendColor : new Color(blendColor),
                    result = new Color;
                result.r = normalize(_round(this.r * (1 - opacity) + other.r * opacity));
                result.g = normalize(_round(this.g * (1 - opacity) + other.g * opacity));
                result.b = normalize(_round(this.b * (1 - opacity) + other.b * opacity));
                return result
            },
            toHex: function() {
                return toHexFromRgb(this.r, this.g, this.b)
            },
            getPureColor: function() {
                var rgb = hsvToRgb(this.hsv.h, 100, 100);
                return new Color("rgb(" + rgb.join(",") + ")")
            },
            isValidHex: function(hex) {
                return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex)
            },
            isValidRGB: function(r, g, b) {
                if (!isIntegerBtwMinAndMax(r) || !isIntegerBtwMinAndMax(g) || !isIntegerBtwMinAndMax(b))
                    return false;
                return true
            },
            isValidAlpha: function(a) {
                if (isNaN(a) || a < 0 || a > 1 || typeof a !== 'number')
                    return false;
                return true
            },
            colorIsInvalid: false
        };
        return Color
    });
    /*! Module core, file data.errors.js */
    DevExpress.define("/data/data.errors", ["/utils/utils.error", "/errors"], function(errorUtils, errors) {
        return errorUtils(errors.ERROR_MESSAGES, {
                E4000: "[DevExpress.data]: {0}",
                E4001: "Unknown aggregating function is detected: '{0}'",
                E4002: "Unsupported OData protocol version is used",
                E4003: "Unknown filter operation is used: {0}",
                E4004: "The thenby() method is called before the sortby() method",
                E4005: "Store requires a key expression for this operation",
                E4006: "ArrayStore 'data' option must be an array",
                E4007: "Compound keys cannot be auto-generated",
                E4008: "Attempt to insert an item with the a duplicated key",
                E4009: "Data item cannot be found",
                E4010: "CustomStore does not support creating queries",
                E4011: "Custom Store method is not implemented or is not a function: {0}",
                E4012: "Custom Store method returns an invalid value: {0}",
                E4013: "Local Store requires the 'name' configuration option is specified",
                E4014: "Unknown key type is detected: {0}",
                E4015: "Unknown entity name or alias is used: {0}",
                E4016: "The compileSetter(expr) method is called with 'self' passed as a parameter",
                E4017: "Keys cannot be modified",
                E4018: "The server has returned a non-numeric value in a response to an item count request",
                E4019: "Mixing of group operators inside a single group of filter expression is not allowed"
            })
    });
    /*! Module core, file data.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            errors = DevExpress.require("/data/data.errors"),
            objectUtils = DX.require("/utils/utils.object"),
            knockoutUtils = DX.require("/utils/utils.knockout"),
            unwrapObservable = knockoutUtils.unwrapObservable,
            isObservable = knockoutUtils.isObservable;
        var bracketsToDots = function(expr) {
                return expr.replace(/\[/g, ".").replace(/\]/g, "")
            };
        var readPropValue = function(obj, propName) {
                if (propName === "this")
                    return obj;
                return obj[propName]
            };
        var assignPropValue = function(obj, propName, value, options) {
                if (propName === "this")
                    throw new errors.Error("E4016");
                var propValue = obj[propName];
                if (options.unwrapObservables && isObservable(propValue))
                    propValue(value);
                else
                    obj[propName] = value
            };
        var prepareOptions = function(options) {
                options = options || {};
                options.unwrapObservables = options.unwrapObservables !== undefined ? options.unwrapObservables : true;
                return options
            };
        var unwrap = function(value, options) {
                return options.unwrapObservables ? unwrapObservable(value) : value
            };
        var compileGetter = function(expr) {
                if (arguments.length > 1)
                    expr = $.makeArray(arguments);
                if (!expr || expr === "this")
                    return function(obj) {
                            return obj
                        };
                if (typeof expr === "string") {
                    expr = bracketsToDots(expr);
                    var path = expr.split(".");
                    return function(obj, options) {
                            options = prepareOptions(options);
                            var functionAsIs = options.functionsAsIs,
                                current = unwrap(obj, options);
                            for (var i = 0; i < path.length; i++) {
                                if (!current)
                                    break;
                                var next = unwrap(current[path[i]], options);
                                if (!functionAsIs && $.isFunction(next))
                                    next = next.call(current);
                                current = next
                            }
                            return current
                        }
                }
                if ($.isArray(expr))
                    return combineGetters(expr);
                if ($.isFunction(expr))
                    return expr
            };
        var combineGetters = function(getters) {
                var compiledGetters = {};
                for (var i = 0, l = getters.length; i < l; i++) {
                    var getter = getters[i];
                    compiledGetters[getter] = compileGetter(getter)
                }
                return function(obj, options) {
                        var result;
                        $.each(compiledGetters, function(name) {
                            var value = this(obj, options),
                                current,
                                path,
                                last,
                                i;
                            if (value === undefined)
                                return;
                            current = result || (result = {});
                            path = name.split(".");
                            last = path.length - 1;
                            for (i = 0; i < last; i++)
                                current = current[path[i]] = {};
                            current[path[i]] = value
                        });
                        return result
                    }
            };
        var compileSetter = function(expr) {
                expr = expr || "this";
                expr = bracketsToDots(expr);
                var pos = expr.lastIndexOf("."),
                    targetGetter = compileGetter(expr.substr(0, pos)),
                    targetPropName = expr.substr(1 + pos);
                return function(obj, value, options) {
                        options = prepareOptions(options);
                        var target = targetGetter(obj, {
                                functionsAsIs: options.functionsAsIs,
                                unwrapObservables: options.unwrapObservables
                            }),
                            prevTargetValue = readPropValue(target, targetPropName);
                        if (!options.functionsAsIs && $.isFunction(prevTargetValue) && !isObservable(prevTargetValue))
                            target[targetPropName](value);
                        else {
                            prevTargetValue = unwrap(prevTargetValue, options);
                            if (options.merge && $.isPlainObject(value) && (prevTargetValue === undefined || $.isPlainObject(prevTargetValue)) && !(value instanceof $.Event)) {
                                if (!prevTargetValue)
                                    assignPropValue(target, targetPropName, {}, options);
                                objectUtils.deepExtendArraySafe(unwrap(readPropValue(target, targetPropName), options), value)
                            }
                            else
                                assignPropValue(target, targetPropName, value, options)
                        }
                    }
            };
        var normalizeBinaryCriterion = function(crit) {
                return [crit[0], crit.length < 3 ? "=" : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]]
            };
        var normalizeSortingInfo = function(info) {
                if (!$.isArray(info))
                    info = [info];
                return $.map(info, function(i) {
                        return {
                                selector: $.isFunction(i) || typeof i === "string" ? i : i.getter || i.field || i.selector,
                                desc: !!(i.desc || String(i.dir).charAt(0).toLowerCase() === "d")
                            }
                    })
            };
        var Guid = Class.inherit({
                ctor: function(value) {
                    if (value)
                        value = String(value);
                    this._value = this._normalize(value || this._generate())
                },
                _normalize: function(value) {
                    value = value.replace(/[^a-f0-9]/ig, "").toLowerCase();
                    while (value.length < 32)
                        value += "0";
                    return [value.substr(0, 8), value.substr(8, 4), value.substr(12, 4), value.substr(16, 4), value.substr(20, 12)].join("-")
                },
                _generate: function() {
                    var value = "";
                    for (var i = 0; i < 32; i++)
                        value += Math.round(Math.random() * 15).toString(16);
                    return value
                },
                toString: function() {
                    return this._value
                },
                valueOf: function() {
                    return this._value
                },
                toJSON: function() {
                    return this._value
                }
            });
        var toComparable = function(value, caseSensitive) {
                if (value instanceof Date)
                    return value.getTime();
                if (value instanceof Guid)
                    return value.valueOf();
                if (!caseSensitive && typeof value === "string")
                    return value.toLowerCase();
                return value
            };
        var keysEqual = function(keyExpr, key1, key2) {
                if ($.isArray(keyExpr)) {
                    var names = $.map(key1, function(v, k) {
                            return k
                        }),
                        name;
                    for (var i = 0; i < names.length; i++) {
                        name = names[i];
                        if (toComparable(key1[name], true) != toComparable(key2[name], true))
                            return false
                    }
                    return true
                }
                return toComparable(key1, true) == toComparable(key2, true)
            };
        var BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var base64_encode = function(input) {
                if (!$.isArray(input))
                    input = stringToByteArray(String(input));
                var result = "";
                function getBase64Char(index) {
                    return BASE64_CHARS.charAt(index)
                }
                for (var i = 0; i < input.length; i += 3) {
                    var octet1 = input[i],
                        octet2 = input[i + 1],
                        octet3 = input[i + 2];
                    result += $.map([octet1 >> 2, (octet1 & 3) << 4 | octet2 >> 4, isNaN(octet2) ? 64 : (octet2 & 15) << 2 | octet3 >> 6, isNaN(octet3) ? 64 : octet3 & 63], getBase64Char).join("")
                }
                return result
            };
        var stringToByteArray = function(str) {
                var bytes = [],
                    code,
                    i;
                for (i = 0; i < str.length; i++) {
                    code = str.charCodeAt(i);
                    if (code < 128)
                        bytes.push(code);
                    else if (code < 2048)
                        bytes.push(192 + (code >> 6), 128 + (code & 63));
                    else if (code < 65536)
                        bytes.push(224 + (code >> 12), 128 + (code >> 6 & 63), 128 + (code & 63));
                    else if (code < 2097152)
                        bytes.push(240 + (code >> 18), 128 + (code >> 12 & 63), 128 + (code >> 6 & 63), 128 + (code & 63))
                }
                return bytes
            };
        var errorMessageFromXhr = function() {
                var textStatusMessages = {
                        timeout: "Network connection timeout",
                        error: "Unspecified network error",
                        parsererror: "Unexpected server response"
                    };
                var textStatusDetails = {
                        timeout: "possible causes: the remote host is not accessible, overloaded or is not included into the domain white-list when being run in the native container",
                        error: "if the remote host is located on another domain, make sure it properly supports cross-origin resource sharing (CORS), or use the JSONP approach instead",
                        parsererror: "the remote host did not respond with valid JSON data"
                    };
                var explainTextStatus = function(textStatus) {
                        var result = textStatusMessages[textStatus];
                        if (!result)
                            return textStatus;
                        result += " (" + textStatusDetails[textStatus] + ")";
                        return result
                    };
                return function(xhr, textStatus) {
                        if (xhr.status < 400)
                            return explainTextStatus(textStatus);
                        return xhr.statusText
                    }
            }();
        var aggregators = {
                count: {
                    seed: 0,
                    step: function(count) {
                        return 1 + count
                    }
                },
                sum: {
                    seed: 0,
                    step: function(sum, item) {
                        return sum + item
                    }
                },
                min: {step: function(min, item) {
                        return item < min ? item : min
                    }},
                max: {step: function(max, item) {
                        return item > max ? item : max
                    }},
                avg: {
                    seed: [0, 0],
                    step: function(pair, value) {
                        return [pair[0] + value, pair[1] + 1]
                    },
                    finalize: function(pair) {
                        return pair[1] ? pair[0] / pair[1] : NaN
                    }
                }
            };
        function handleError(error) {
            var id = "E4000";
            if (error && "__id" in error)
                id = error.__id;
            errors.log(id, error)
        }
        var processRequestResultLock = function() {
                var lockCount = 0,
                    lockDeferred;
                var obtain = function() {
                        if (lockCount === 0)
                            lockDeferred = $.Deferred();
                        lockCount++
                    };
                var release = function() {
                        lockCount--;
                        if (lockCount < 1)
                            lockDeferred.resolve()
                    };
                var promise = function() {
                        var deferred = lockCount === 0 ? $.Deferred().resolve() : lockDeferred;
                        return deferred.promise()
                    };
                var reset = function() {
                        lockCount = 0;
                        if (lockDeferred)
                            lockDeferred.resolve()
                    };
                return {
                        obtain: obtain,
                        release: release,
                        promise: promise,
                        reset: reset
                    }
            }();
        function isDisjunctiveOperator(condition) {
            return /^(or|\|\||\|)$/i.test(condition)
        }
        function isConjunctiveOperator(condition) {
            return /^(and|\&\&|\&)$/i.test(condition)
        }
        var data = DX.data = {
                utils: {
                    compileGetter: compileGetter,
                    compileSetter: compileSetter,
                    normalizeBinaryCriterion: normalizeBinaryCriterion,
                    normalizeSortingInfo: normalizeSortingInfo,
                    toComparable: toComparable,
                    keysEqual: keysEqual,
                    errorMessageFromXhr: errorMessageFromXhr,
                    aggregators: aggregators,
                    isDisjunctiveOperator: isDisjunctiveOperator,
                    isConjunctiveOperator: isConjunctiveOperator,
                    processRequestResultLock: processRequestResultLock
                },
                Guid: Guid,
                base64_encode: base64_encode,
                queryImpl: {},
                queryAdapters: {},
                query: function() {
                    var impl = $.isArray(arguments[0]) ? "array" : "remote";
                    return data.queryImpl[impl].apply(this, arguments)
                },
                errorHandler: null,
                _errorHandler: function(error) {
                    handleError(error);
                    if (data.errorHandler)
                        data.errorHandler(error)
                }
            }
    })(jQuery, DevExpress);
    /*! Module core, file data.aggregateCalculator.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            errors = DevExpress.require("/data/data.errors"),
            data = DX.data,
            utils = data.utils;
        function isCount(aggregator) {
            return aggregator === utils.aggregators.count
        }
        function normalizeAggregate(aggregate) {
            var selector = utils.compileGetter(aggregate.selector),
                aggregator = aggregate.aggregator;
            if (typeof aggregator === "string") {
                aggregator = data.utils.aggregators[aggregator];
                if (!aggregator)
                    throw errors.Error("E4001", aggregate.aggregator);
            }
            return {
                    selector: selector,
                    aggregator: aggregator
                }
        }
        data.AggregateCalculator = Class.inherit({
            ctor: function(options) {
                this._data = options.data;
                this._groupLevel = options.groupLevel || 0;
                this._totalAggregates = $.map(options.totalAggregates || [], normalizeAggregate);
                this._groupAggregates = $.map(options.groupAggregates || [], normalizeAggregate);
                this._totals = []
            },
            calculate: function() {
                if (this._totalAggregates.length)
                    this._calculateTotals(0, {items: this._data});
                if (this._groupAggregates.length && this._groupLevel > 0)
                    this._calculateGroups(0, {items: this._data})
            },
            totalAggregates: function() {
                return this._totals
            },
            _aggregate: function(data, aggregates, container) {
                var i,
                    j;
                for (i = 0; i < aggregates.length; i++) {
                    if (isCount(aggregates[i].aggregator)) {
                        container[i] = (container[i] || 0) + data.items.length;
                        continue
                    }
                    for (j = 0; j < data.items.length; j++)
                        this._accumulate(i, aggregates[i], container, data.items[j])
                }
            },
            _calculateTotals: function(level, data) {
                var i;
                if (level === 0)
                    this._totals = this._seed(this._totalAggregates);
                if (level === this._groupLevel)
                    this._aggregate(data, this._totalAggregates, this._totals);
                else
                    for (i = 0; i < data.items.length; i++)
                        this._calculateTotals(level + 1, data.items[i]);
                if (level === 0)
                    this._totals = this._finalize(this._totalAggregates, this._totals)
            },
            _calculateGroups: function(level, data, outerAggregates) {
                var i,
                    innerAggregates;
                if (level === this._groupLevel)
                    this._aggregate(data, this._groupAggregates, outerAggregates);
                else
                    for (i = 0; i < data.items.length; i++) {
                        innerAggregates = this._seed(this._groupAggregates);
                        this._calculateGroups(level + 1, data.items[i], innerAggregates);
                        data.items[i].aggregates = this._finalize(this._groupAggregates, innerAggregates);
                        if (level > 0) {
                            outerAggregates = outerAggregates || this._seed(this._groupAggregates);
                            this._calculateGroups(level + 1, data.items[i], outerAggregates)
                        }
                    }
            },
            _seed: function(aggregates) {
                return $.map(aggregates, function(aggregate) {
                        var aggregator = aggregate.aggregator,
                            seed = "seed" in aggregator ? $.isFunction(aggregator.seed) ? aggregator.seed() : aggregator.seed : NaN;
                        return $.isArray(seed) ? [seed] : seed
                    })
            },
            _accumulate: function(aggregateIndex, aggregate, results, item) {
                var value = aggregate.selector(item),
                    aggregator = aggregate.aggregator;
                results[aggregateIndex] = results[aggregateIndex] !== results[aggregateIndex] ? value : aggregator.step(results[aggregateIndex], value)
            },
            _finalize: function(aggregates, results) {
                return $.map(aggregates, function(aggregate, index) {
                        var fin = aggregate.aggregator.finalize;
                        return fin ? fin(results[index]) : results[index]
                    })
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.query.array.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            errors = DevExpress.require("/data/data.errors"),
            commonUtils = DX.require("/utils/utils.common"),
            data = DX.data,
            queryImpl = data.queryImpl,
            compileGetter = data.utils.compileGetter,
            toComparable = data.utils.toComparable;
        var Iterator = Class.inherit({
                toArray: function() {
                    var result = [];
                    this.reset();
                    while (this.next())
                        result.push(this.current());
                    return result
                },
                countable: function() {
                    return false
                }
            });
        var ArrayIterator = Iterator.inherit({
                ctor: function(array) {
                    this.array = array;
                    this.index = -1
                },
                next: function() {
                    if (this.index + 1 < this.array.length) {
                        this.index++;
                        return true
                    }
                    return false
                },
                current: function() {
                    return this.array[this.index]
                },
                reset: function() {
                    this.index = -1
                },
                toArray: function() {
                    return this.array.slice(0)
                },
                countable: function() {
                    return true
                },
                count: function() {
                    return this.array.length
                }
            });
        var WrappedIterator = Iterator.inherit({
                ctor: function(iter) {
                    this.iter = iter
                },
                next: function() {
                    return this.iter.next()
                },
                current: function() {
                    return this.iter.current()
                },
                reset: function() {
                    return this.iter.reset()
                }
            });
        var MapIterator = WrappedIterator.inherit({
                ctor: function(iter, mapper) {
                    this.callBase(iter);
                    this.index = -1;
                    this.mapper = mapper
                },
                current: function() {
                    return this.mapper(this.callBase(), this.index)
                },
                next: function() {
                    var hasNext = this.callBase();
                    if (hasNext)
                        this.index++;
                    return hasNext
                }
            });
        var SortIterator = Iterator.inherit({
                ctor: function(iter, getter, desc) {
                    if (!(iter instanceof MapIterator))
                        iter = new MapIterator(iter, this._wrap);
                    this.iter = iter;
                    this.rules = [{
                            getter: getter,
                            desc: desc
                        }]
                },
                thenBy: function(getter, desc) {
                    var result = new SortIterator(this.sortedIter || this.iter, getter, desc);
                    if (!this.sortedIter)
                        result.rules = this.rules.concat(result.rules);
                    return result
                },
                next: function() {
                    this._ensureSorted();
                    return this.sortedIter.next()
                },
                current: function() {
                    this._ensureSorted();
                    return this.sortedIter.current()
                },
                reset: function() {
                    delete this.sortedIter
                },
                countable: function() {
                    return this.sortedIter || this.iter.countable()
                },
                count: function() {
                    if (this.sortedIter)
                        return this.sortedIter.count();
                    return this.iter.count()
                },
                _ensureSorted: function() {
                    var that = this;
                    if (that.sortedIter)
                        return;
                    $.each(that.rules, function() {
                        this.getter = compileGetter(this.getter)
                    });
                    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function(x, y) {
                        return that._compare(x, y)
                    })), that._unwrap)
                },
                _wrap: function(record, index) {
                    return {
                            index: index,
                            value: record
                        }
                },
                _unwrap: function(wrappedItem) {
                    return wrappedItem.value
                },
                _compare: function(x, y) {
                    var xIndex = x.index,
                        yIndex = y.index;
                    x = x.value;
                    y = y.value;
                    if (x === y)
                        return xIndex - yIndex;
                    for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
                        var rule = this.rules[i],
                            xValue = toComparable(rule.getter(x)),
                            yValue = toComparable(rule.getter(y)),
                            factor = rule.desc ? -1 : 1;
                        if (xValue === null || yValue === undefined)
                            return -factor;
                        if (yValue === null || xValue === undefined)
                            return factor;
                        if (xValue < yValue)
                            return -factor;
                        if (xValue > yValue)
                            return factor;
                        if (xValue !== yValue)
                            return !xValue ? -factor : factor
                    }
                    return xIndex - yIndex
                }
            });
        var compileCriteria = function() {
                var compileGroup = function(crit) {
                        var idx = 0,
                            bag = [],
                            ops = [],
                            groupOperator,
                            nextGroupOperator;
                        $.each(crit, function() {
                            if ($.isArray(this) || $.isFunction(this)) {
                                if (bag.length > 1 && groupOperator !== nextGroupOperator)
                                    throw new errors.Error("E4019");
                                ops.push(compileCriteria(this));
                                bag.push("op[" + idx + "](d)");
                                idx++;
                                groupOperator = nextGroupOperator;
                                nextGroupOperator = "&&"
                            }
                            else
                                nextGroupOperator = data.utils.isConjunctiveOperator(this) ? "&&" : "||"
                        });
                        return new Function("op", "return function(d) { return " + bag.join(" " + groupOperator + " ") + " }")(ops)
                    };
                var toString = function(value) {
                        return commonUtils.isDefined(value) ? value.toString() : ''
                    };
                var compileBinary = function(crit) {
                        crit = data.utils.normalizeBinaryCriterion(crit);
                        var getter = compileGetter(crit[0]),
                            op = crit[1],
                            value = crit[2];
                        value = toComparable(value);
                        switch (op.toLowerCase()) {
                            case"=":
                                return compileEquals(getter, value);
                            case"<>":
                                return compileEquals(getter, value, true);
                            case">":
                                return function(obj) {
                                        return toComparable(getter(obj)) > value
                                    };
                            case"<":
                                return function(obj) {
                                        return toComparable(getter(obj)) < value
                                    };
                            case">=":
                                return function(obj) {
                                        return toComparable(getter(obj)) >= value
                                    };
                            case"<=":
                                return function(obj) {
                                        return toComparable(getter(obj)) <= value
                                    };
                            case"startswith":
                                return function(obj) {
                                        return toComparable(toString(getter(obj))).indexOf(value) === 0
                                    };
                            case"endswith":
                                return function(obj) {
                                        var getterValue = toComparable(toString(getter(obj))),
                                            searchValue = toString(value);
                                        if (getterValue.length < searchValue.length)
                                            return false;
                                        return getterValue.lastIndexOf(value) === getterValue.length - value.length
                                    };
                            case"contains":
                                return function(obj) {
                                        return toComparable(toString(getter(obj))).indexOf(value) > -1
                                    };
                            case"notcontains":
                                return function(obj) {
                                        return toComparable(toString(getter(obj))).indexOf(value) === -1
                                    }
                        }
                        throw errors.Error("E4003", op);
                    };
                function compileEquals(getter, value, negate) {
                    return function(obj) {
                            obj = toComparable(getter(obj));
                            var result = useStrictComparison(value) ? obj === value : obj == value;
                            if (negate)
                                result = !result;
                            return result
                        }
                }
                function useStrictComparison(value) {
                    return value === "" || value === 0 || value === false
                }
                return function(crit) {
                        if ($.isFunction(crit))
                            return crit;
                        if ($.isArray(crit[0]))
                            return compileGroup(crit);
                        return compileBinary(crit)
                    }
            }();
        var FilterIterator = WrappedIterator.inherit({
                ctor: function(iter, criteria) {
                    this.callBase(iter);
                    this.criteria = compileCriteria(criteria)
                },
                next: function() {
                    while (this.iter.next())
                        if (this.criteria(this.current()))
                            return true;
                    return false
                }
            });
        var GroupIterator = Iterator.inherit({
                ctor: function(iter, getter) {
                    this.iter = iter;
                    this.getter = getter
                },
                next: function() {
                    this._ensureGrouped();
                    return this.groupedIter.next()
                },
                current: function() {
                    this._ensureGrouped();
                    return this.groupedIter.current()
                },
                reset: function() {
                    delete this.groupedIter
                },
                countable: function() {
                    return !!this.groupedIter
                },
                count: function() {
                    return this.groupedIter.count()
                },
                _ensureGrouped: function() {
                    if (this.groupedIter)
                        return;
                    var hash = {},
                        keys = [],
                        iter = this.iter,
                        getter = compileGetter(this.getter);
                    iter.reset();
                    while (iter.next()) {
                        var current = iter.current(),
                            key = getter(current);
                        if (key in hash)
                            hash[key].push(current);
                        else {
                            hash[key] = [current];
                            keys.push(key)
                        }
                    }
                    this.groupedIter = new ArrayIterator($.map(keys, function(key) {
                        return {
                                key: key,
                                items: hash[key]
                            }
                    }))
                }
            });
        var SelectIterator = WrappedIterator.inherit({
                ctor: function(iter, getter) {
                    this.callBase(iter);
                    this.getter = compileGetter(getter)
                },
                current: function() {
                    return this.getter(this.callBase())
                },
                countable: function() {
                    return this.iter.countable()
                },
                count: function() {
                    return this.iter.count()
                }
            });
        var SliceIterator = WrappedIterator.inherit({
                ctor: function(iter, skip, take) {
                    this.callBase(iter);
                    this.skip = Math.max(0, skip);
                    this.take = Math.max(0, take);
                    this.pos = 0
                },
                next: function() {
                    if (this.pos >= this.skip + this.take)
                        return false;
                    while (this.pos < this.skip && this.iter.next())
                        this.pos++;
                    this.pos++;
                    return this.iter.next()
                },
                reset: function() {
                    this.callBase();
                    this.pos = 0
                },
                countable: function() {
                    return this.iter.countable()
                },
                count: function() {
                    return Math.min(this.iter.count() - this.skip, this.take)
                }
            });
        queryImpl.array = function(iter, queryOptions) {
            queryOptions = queryOptions || {};
            if (!(iter instanceof Iterator))
                iter = new ArrayIterator(iter);
            var handleError = function(error) {
                    var handler = queryOptions.errorHandler;
                    if (handler)
                        handler(error);
                    data._errorHandler(error)
                };
            var aggregateCore = function(aggregator) {
                    var d = $.Deferred().fail(handleError),
                        seed,
                        step = aggregator.step,
                        finalize = aggregator.finalize;
                    try {
                        iter.reset();
                        if ("seed" in aggregator)
                            seed = aggregator.seed;
                        else
                            seed = iter.next() ? iter.current() : NaN;
                        var accumulator = seed;
                        while (iter.next())
                            accumulator = step(accumulator, iter.current());
                        d.resolve(finalize ? finalize(accumulator) : accumulator)
                    }
                    catch(x) {
                        d.reject(x)
                    }
                    return d.promise()
                };
            var aggregate = function(seed, step, finalize) {
                    if (arguments.length < 2)
                        return aggregateCore({step: arguments[0]});
                    return aggregateCore({
                            seed: seed,
                            step: step,
                            finalize: finalize
                        })
                };
            var standardAggregate = function(name) {
                    return aggregateCore(data.utils.aggregators[name])
                };
            var select = function(getter) {
                    if (!$.isFunction(getter) && !$.isArray(getter))
                        getter = $.makeArray(arguments);
                    return chainQuery(new SelectIterator(iter, getter))
                };
            var selectProp = function(name) {
                    return select(compileGetter(name))
                };
            var chainQuery = function(iter) {
                    return queryImpl.array(iter, queryOptions)
                };
            return {
                    toArray: function() {
                        return iter.toArray()
                    },
                    enumerate: function() {
                        var d = $.Deferred().fail(handleError);
                        try {
                            d.resolve(iter.toArray())
                        }
                        catch(x) {
                            d.reject(x)
                        }
                        return d.promise()
                    },
                    sortBy: function(getter, desc) {
                        return chainQuery(new SortIterator(iter, getter, desc))
                    },
                    thenBy: function(getter, desc) {
                        if (iter instanceof SortIterator)
                            return chainQuery(iter.thenBy(getter, desc));
                        throw errors.Error("E4004");
                    },
                    filter: function(criteria) {
                        if (!$.isArray(criteria))
                            criteria = $.makeArray(arguments);
                        return chainQuery(new FilterIterator(iter, criteria))
                    },
                    slice: function(skip, take) {
                        if (take === undefined)
                            take = Number.MAX_VALUE;
                        return chainQuery(new SliceIterator(iter, skip, take))
                    },
                    select: select,
                    groupBy: function(getter) {
                        return chainQuery(new GroupIterator(iter, getter))
                    },
                    aggregate: aggregate,
                    count: function() {
                        if (iter.countable()) {
                            var d = $.Deferred().fail(handleError);
                            try {
                                d.resolve(iter.count())
                            }
                            catch(x) {
                                d.reject(x)
                            }
                            return d.promise()
                        }
                        return standardAggregate("count")
                    },
                    sum: function(getter) {
                        if (getter)
                            return selectProp(getter).sum();
                        return standardAggregate("sum")
                    },
                    min: function(getter) {
                        if (getter)
                            return selectProp(getter).min();
                        return standardAggregate("min")
                    },
                    max: function(getter) {
                        if (getter)
                            return selectProp(getter).max();
                        return standardAggregate("max")
                    },
                    avg: function(getter) {
                        if (getter)
                            return selectProp(getter).avg();
                        return standardAggregate("avg")
                    }
                }
        }
    })(jQuery, DevExpress);
    /*! Module core, file data.query.remote.js */
    (function($, DX, undefined) {
        var data = DX.data,
            queryImpl = data.queryImpl,
            errors = DevExpress.require("/data/data.errors");
        queryImpl.remote = function(url, queryOptions, tasks) {
            tasks = tasks || [];
            queryOptions = queryOptions || {};
            var createTask = function(name, args) {
                    return {
                            name: name,
                            args: args
                        }
                };
            var exec = function(executorTask) {
                    var d = $.Deferred(),
                        _adapterFactory,
                        _adapter,
                        _taskQueue,
                        _currentTask,
                        _mergedSortArgs;
                    var rejectWithNotify = function(error) {
                            var handler = queryOptions.errorHandler;
                            if (handler)
                                handler(error);
                            data._errorHandler(error);
                            d.reject(error)
                        };
                    function mergeSortTask(task) {
                        switch (task.name) {
                            case"sortBy":
                                _mergedSortArgs = [task.args];
                                return true;
                            case"thenBy":
                                if (!_mergedSortArgs)
                                    throw errors.Error("E4004");
                                _mergedSortArgs.push(task.args);
                                return true
                        }
                        return false
                    }
                    function unmergeSortTasks() {
                        var head = _taskQueue[0],
                            unmergedTasks = [];
                        if (head && head.name === "multiSort") {
                            _taskQueue.shift();
                            $.each(head.args[0], function() {
                                unmergedTasks.push(createTask(unmergedTasks.length ? "thenBy" : "sortBy", this))
                            })
                        }
                        _taskQueue = unmergedTasks.concat(_taskQueue)
                    }
                    try {
                        _adapterFactory = queryOptions.adapter || "odata";
                        if (!$.isFunction(_adapterFactory))
                            _adapterFactory = data.queryAdapters[_adapterFactory];
                        _adapter = _adapterFactory(queryOptions);
                        _taskQueue = [].concat(tasks).concat(executorTask);
                        while (_taskQueue.length) {
                            _currentTask = _taskQueue[0];
                            if (!mergeSortTask(_currentTask)) {
                                if (_mergedSortArgs) {
                                    _taskQueue.unshift(createTask("multiSort", [_mergedSortArgs]));
                                    _mergedSortArgs = null;
                                    continue
                                }
                                if (String(_currentTask.name) !== "enumerate")
                                    if (!_adapter[_currentTask.name] || _adapter[_currentTask.name].apply(_adapter, _currentTask.args) === false)
                                        break
                            }
                            _taskQueue.shift()
                        }
                        unmergeSortTasks();
                        _adapter.exec(url).done(function(result, extra) {
                            if (!_taskQueue.length)
                                d.resolve(result, extra);
                            else {
                                var clientChain = queryImpl.array(result, {errorHandler: queryOptions.errorHandler});
                                $.each(_taskQueue, function() {
                                    clientChain = clientChain[this.name].apply(clientChain, this.args)
                                });
                                clientChain.done(d.resolve).fail(d.reject)
                            }
                        }).fail(rejectWithNotify)
                    }
                    catch(x) {
                        rejectWithNotify(x)
                    }
                    return d.promise()
                };
            var query = {};
            $.each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
                var name = String(this);
                query[name] = function() {
                    return queryImpl.remote(url, queryOptions, tasks.concat(createTask(name, arguments)))
                }
            });
            $.each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
                var name = String(this);
                query[name] = function() {
                    return exec.call(this, createTask(name, arguments))
                }
            });
            return query
        }
    })(jQuery, DevExpress);
    /*! Module core, file data.odata.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            errors = DevExpress.require("/data/data.errors"),
            data = DX.data,
            Guid = data.Guid,
            commonUtils = DX.require("/utils/utils.common"),
            isDefined = commonUtils.isDefined;
        var DEFAULT_PROTOCOL_VERSION = 2;
        var GUID_REGEX = /^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$/;
        var VERBOSE_DATE_REGEX = /^\/Date\((-?\d+)((\+|-)?(\d+)?)\)\/$/;
        var ISO8601_DATE_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[-+]{1}\d{2}(:?)(\d{2})?)?$/;
        var JSON_VERBOSE_MIME_TYPE = "application/json;odata=verbose";
        function formatISO8601(date, skipZeroTime, skipTimezone) {
            var ret = [];
            var pad = function(n) {
                    if (n < 10)
                        return "0".concat(n);
                    return String(n)
                };
            var isZeroTime = function() {
                    return date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1
                };
            ret.push(date.getFullYear());
            ret.push("-");
            ret.push(pad(date.getMonth() + 1));
            ret.push("-");
            ret.push(pad(date.getDate()));
            if (!(skipZeroTime && isZeroTime())) {
                ret.push("T");
                ret.push(pad(date.getHours()));
                ret.push(":");
                ret.push(pad(date.getMinutes()));
                ret.push(":");
                ret.push(pad(date.getSeconds()));
                if (date.getMilliseconds()) {
                    ret.push(".");
                    ret.push(date.getMilliseconds())
                }
                if (!skipTimezone)
                    ret.push("Z")
            }
            return ret.join("")
        }
        function parseISO8601(isoString) {
            var result = new Date(0);
            var chunks = isoString.replace("Z", "").split("T"),
                date = /(\d{4})-(\d{2})-(\d{2})/.exec(chunks[0]),
                time = /(\d{2}):(\d{2}):(\d{2})\.?(\d{0,7})?/.exec(chunks[1]);
            result.setDate(Number(date[3]));
            result.setMonth(Number(date[2]) - 1);
            result.setFullYear(Number(date[1]));
            if ($.isArray(time) && time.length) {
                result.setHours(Number(time[1]));
                result.setMinutes(Number(time[2]));
                result.setSeconds(Number(time[3]));
                result.setMilliseconds(Number(String(time[4]).substr(0, 3)) || 0)
            }
            return result
        }
        function isAbsoluteUrl(url) {
            return /^(?:[a-z]+:)?\/\//i.test(url)
        }
        function toAbsoluteUrl(basePath, relativePath) {
            var part;
            var baseParts = stripParams(basePath).split("/");
            var relativeParts = relativePath.split("/");
            function stripParams(url) {
                var index = url.indexOf("?");
                if (index > -1)
                    return url.substr(0, index);
                return url
            }
            baseParts.pop();
            while (relativeParts.length) {
                part = relativeParts.shift();
                if (part === "..")
                    baseParts.pop();
                else
                    baseParts.push(part)
            }
            return baseParts.join("/")
        }
        var ajaxOptionsForRequest = function(protocolVersion, request, requestOptions) {
                request = $.extend({
                    async: true,
                    method: "get",
                    url: "",
                    params: {},
                    payload: null,
                    headers: {},
                    timeout: 30000
                }, request);
                requestOptions = requestOptions || {};
                var beforeSend = requestOptions.beforeSend;
                if (beforeSend)
                    beforeSend(request);
                var method = (request.method || "get").toLowerCase(),
                    isGet = method === "get",
                    useJsonp = isGet && requestOptions.jsonp,
                    params = $.extend({}, request.params),
                    ajaxData = isGet ? params : formatPayload(request.payload),
                    qs = !isGet && $.param(params),
                    url = request.url,
                    contentType = !isGet && JSON_VERBOSE_MIME_TYPE;
                if (qs)
                    url += (url.indexOf("?") > -1 ? "&" : "?") + qs;
                if (useJsonp)
                    ajaxData["$format"] = "json";
                return {
                        url: url,
                        data: ajaxData,
                        dataType: useJsonp ? "jsonp" : "json",
                        jsonp: useJsonp && "$callback",
                        type: method,
                        async: request.async,
                        timeout: request.timeout,
                        headers: request.headers,
                        contentType: contentType,
                        accepts: {json: [JSON_VERBOSE_MIME_TYPE, "text/plain"].join()},
                        xhrFields: {withCredentials: requestOptions.withCredentials}
                    };
                function formatPayload(payload) {
                    return JSON.stringify(payload, function(key, value) {
                            if (!(this[key] instanceof Date))
                                return value;
                            value = formatISO8601(this[key]);
                            switch (protocolVersion) {
                                case 2:
                                    return value.substr(0, value.length - 1);
                                case 3:
                                case 4:
                                    return value;
                                default:
                                    throw errors.Error("E4002");
                            }
                        })
                }
            };
        var sendRequest = function(protocolVersion, request, requestOptions, deserializeDates) {
                var d = $.Deferred();
                var options = ajaxOptionsForRequest(protocolVersion, request, requestOptions);
                $.ajax(options).always(function(obj, textStatus) {
                    var tuplet = interpretJsonFormat(obj, textStatus, deserializeDates),
                        error = tuplet.error,
                        data = tuplet.data,
                        nextUrl = tuplet.nextUrl,
                        extra;
                    if (error)
                        d.reject(error);
                    else if (requestOptions.countOnly)
                        if (isFinite(tuplet.count))
                            d.resolve(tuplet.count);
                        else
                            d.reject(new errors.Error("E4018"));
                    else if (nextUrl) {
                        if (!isAbsoluteUrl(nextUrl))
                            nextUrl = toAbsoluteUrl(options.url, nextUrl);
                        sendRequest(protocolVersion, {url: nextUrl}, requestOptions, deserializeDates).fail(d.reject).done(function(nextData) {
                            d.resolve(data.concat(nextData))
                        })
                    }
                    else {
                        if (isFinite(tuplet.count))
                            extra = {totalCount: tuplet.count};
                        d.resolve(data, extra)
                    }
                });
                return d.promise()
            };
        var formatDotNetError = function(errorObj) {
                var message,
                    currentError = errorObj;
                if ("message" in errorObj)
                    if (errorObj.message.value)
                        message = errorObj.message.value;
                    else
                        message = errorObj.message;
                while (currentError = currentError.innererror || currentError.internalexception) {
                    message = currentError.message;
                    if (currentError.internalexception && message.indexOf("inner exception") === -1)
                        break
                }
                return message
            };
        var errorFromResponse = function(obj, textStatus) {
                if (textStatus === "nocontent")
                    return null;
                var httpStatus = 200,
                    message = "Unknown error",
                    response = obj;
                if (textStatus !== "success") {
                    httpStatus = obj.status;
                    message = data.utils.errorMessageFromXhr(obj, textStatus);
                    try {
                        response = $.parseJSON(obj.responseText)
                    }
                    catch(x) {}
                }
                var errorObj = response && (response.error || response["odata.error"] || response["@odata.error"]);
                if (errorObj) {
                    message = formatDotNetError(errorObj) || message;
                    if (httpStatus === 200)
                        httpStatus = 500;
                    if (errorObj.code)
                        httpStatus = Number(errorObj.code);
                    return $.extend(Error(message), {
                            httpStatus: httpStatus,
                            errorDetails: errorObj
                        })
                }
                else if (httpStatus !== 200)
                    return $.extend(Error(message), {httpStatus: httpStatus})
            };
        var interpretJsonFormat = function(obj, textStatus, deserializeDates) {
                var error = errorFromResponse(obj, textStatus),
                    value;
                if (error)
                    return {error: error};
                if (!$.isPlainObject(obj))
                    return {data: obj};
                if ("d" in obj && (commonUtils.isArray(obj.d) || commonUtils.isObject(obj.d)))
                    value = interpretVerboseJsonFormat(obj, textStatus);
                else
                    value = interpretLightJsonFormat(obj, textStatus);
                transformTypes(value, deserializeDates);
                return value
            };
        var interpretVerboseJsonFormat = function(obj) {
                var data = obj.d;
                if (!isDefined(data))
                    return {error: Error("Malformed or unsupported JSON response received")};
                data = data;
                if (isDefined(data.results))
                    data = data.results;
                return {
                        data: data,
                        nextUrl: obj.d.__next,
                        count: parseInt(obj.d.__count, 10)
                    }
            };
        var interpretLightJsonFormat = function(obj) {
                var data = obj;
                if (isDefined(data.value))
                    data = data.value;
                return {
                        data: data,
                        nextUrl: obj["@odata.nextLink"],
                        count: parseInt(obj["@odata.count"], 10)
                    }
            };
        var EdmLiteral = Class.inherit({
                ctor: function(value) {
                    this._value = value
                },
                valueOf: function() {
                    return this._value
                }
            });
        var transformTypes = function(obj, deserializeDates) {
                $.each(obj, function(key, value) {
                    if (value !== null && typeof value === "object") {
                        if ("results" in value)
                            obj[key] = value.results;
                        transformTypes(obj[key], deserializeDates)
                    }
                    else if (typeof value === "string") {
                        if (GUID_REGEX.test(value))
                            obj[key] = new Guid(value);
                        if (deserializeDates !== false)
                            if (value.match(VERBOSE_DATE_REGEX)) {
                                var date = new Date(Number(RegExp.$1) + RegExp.$2 * 60 * 1000);
                                obj[key] = new Date(date.valueOf() + date.getTimezoneOffset() * 60 * 1000)
                            }
                            else if (ISO8601_DATE_REGEX.test(value))
                                obj[key] = new Date(parseISO8601(obj[key]).valueOf())
                    }
                })
            };
        var serializeDate = function(date) {
                return "datetime'" + formatISO8601(date, true, true) + "'"
            };
        var serializeString = function(value) {
                return "'" + value.replace(/'/g, "''") + "'"
            };
        var serializePropName = function(propName) {
                if (propName instanceof EdmLiteral)
                    return propName.valueOf();
                return propName.replace(/\./g, "/")
            };
        var serializeValueV4 = function(value) {
                if (value instanceof Date)
                    return formatISO8601(value, false, false);
                if (value instanceof Guid)
                    return value.valueOf();
                return serializeValueV2(value)
            };
        var serializeValueV2 = function(value) {
                if (value instanceof Date)
                    return serializeDate(value);
                if (value instanceof Guid)
                    return "guid'" + value + "'";
                if (value instanceof EdmLiteral)
                    return value.valueOf();
                if (typeof value === "string")
                    return serializeString(value);
                return String(value)
            };
        var serializeValue = function(value, protocolVersion) {
                switch (protocolVersion) {
                    case 2:
                    case 3:
                        return serializeValueV2(value);
                    case 4:
                        return serializeValueV4(value);
                    default:
                        throw errors.Error("E4002");
                }
            };
        var serializeKey = function(key, protocolVersion) {
                if ($.isPlainObject(key)) {
                    var parts = [];
                    $.each(key, function(k, v) {
                        parts.push(serializePropName(k) + "=" + serializeValue(v, protocolVersion))
                    });
                    return parts.join()
                }
                return serializeValue(key, protocolVersion)
            };
        var keyConverters = {
                String: function(value) {
                    return value + ""
                },
                Int32: function(value) {
                    return Math.floor(value)
                },
                Int64: function(value) {
                    if (value instanceof EdmLiteral)
                        return value;
                    return new EdmLiteral(value + "L")
                },
                Guid: function(value) {
                    if (value instanceof Guid)
                        return value;
                    return new Guid(value)
                },
                Boolean: function(value) {
                    return !!value
                },
                Single: function(value) {
                    if (value instanceof EdmLiteral)
                        return value;
                    return new EdmLiteral(value + "f")
                },
                Decimal: function(value) {
                    if (value instanceof EdmLiteral)
                        return value;
                    return new EdmLiteral(value + "m")
                }
            };
        var compileCriteria = function() {
                var createBinaryOperationFormatter = function(op) {
                        return function(prop, val) {
                                return prop + " " + op + " " + val
                            }
                    };
                var createStringFuncFormatter = function(op, reverse) {
                        return function(prop, val) {
                                var bag = [op, "("];
                                if (reverse)
                                    bag.push(val, ",", prop);
                                else
                                    bag.push(prop, ",", val);
                                bag.push(")");
                                return bag.join("")
                            }
                    };
                var formatters = {
                        "=": createBinaryOperationFormatter("eq"),
                        "<>": createBinaryOperationFormatter("ne"),
                        ">": createBinaryOperationFormatter("gt"),
                        ">=": createBinaryOperationFormatter("ge"),
                        "<": createBinaryOperationFormatter("lt"),
                        "<=": createBinaryOperationFormatter("le"),
                        startswith: createStringFuncFormatter("startswith"),
                        endswith: createStringFuncFormatter("endswith")
                    };
                var formattersV2 = $.extend({}, formatters, {
                        contains: createStringFuncFormatter("substringof", true),
                        notcontains: createStringFuncFormatter("not substringof", true)
                    });
                var formattersV4 = $.extend({}, formatters, {
                        contains: createStringFuncFormatter("contains"),
                        notcontains: createStringFuncFormatter("not contains")
                    });
                var compileBinary = function(criteria, protocolVersion) {
                        criteria = data.utils.normalizeBinaryCriterion(criteria);
                        var op = criteria[1],
                            formatters = protocolVersion === 4 ? formattersV4 : formattersV2,
                            formatter = formatters[op.toLowerCase()];
                        if (!formatter)
                            throw errors.Error("E4003", op);
                        return formatter(serializePropName(criteria[0]), serializeValue(criteria[2], protocolVersion))
                    };
                var compileGroup = function(criteria, protocolVersion) {
                        var bag = [],
                            groupOperator,
                            nextGroupOperator;
                        $.each(criteria, function(index, criterion) {
                            if ($.isArray(criterion)) {
                                if (bag.length > 1 && groupOperator !== nextGroupOperator)
                                    throw new errors.Error("E4019");
                                bag.push("(" + compileCore(criterion, protocolVersion) + ")");
                                groupOperator = nextGroupOperator;
                                nextGroupOperator = "and"
                            }
                            else
                                nextGroupOperator = data.utils.isConjunctiveOperator(this) ? "and" : "or"
                        });
                        return bag.join(" " + groupOperator + " ")
                    };
                var compileCore = function(criteria, protocolVersion) {
                        if ($.isArray(criteria[0]))
                            return compileGroup(criteria, protocolVersion);
                        return compileBinary(criteria, protocolVersion)
                    };
                return function(criteria, protocolVersion) {
                        return compileCore(criteria, protocolVersion)
                    }
            }();
        var createODataQueryAdapter = function(queryOptions) {
                var _sorting = [],
                    _criteria = [],
                    _select,
                    _skip,
                    _take,
                    _countQuery;
                var hasSlice = function() {
                        return _skip || _take !== undefined
                    };
                var hasFunction = function(criterion) {
                        for (var i = 0; i < criterion.length; i++) {
                            if ($.isFunction(criterion[i]))
                                return true;
                            if ($.isArray(criterion[i]) && hasFunction(criterion[i]))
                                return true
                        }
                        return false
                    };
                var generateExpand = function() {
                        var hash = {};
                        if (queryOptions.expand)
                            $.each($.makeArray(queryOptions.expand), function() {
                                hash[serializePropName(this)] = 1
                            });
                        if (_select)
                            $.each(_select, function() {
                                var path = this.split(".");
                                if (path.length < 2)
                                    return;
                                path.pop();
                                hash[serializePropName(path.join("."))] = 1
                            });
                        return $.map(hash, function(k, v) {
                                return v
                            }).join() || undefined
                    };
                var requestData = function() {
                        var result = {};
                        if (!_countQuery) {
                            if (_sorting.length)
                                result["$orderby"] = _sorting.join(",");
                            if (_skip)
                                result["$skip"] = _skip;
                            if (_take !== undefined)
                                result["$top"] = _take;
                            if (_select)
                                result["$select"] = serializePropName(_select.join());
                            result["$expand"] = generateExpand()
                        }
                        if (_criteria.length)
                            result["$filter"] = compileCriteria(_criteria.length < 2 ? _criteria[0] : _criteria, queryOptions.version);
                        if (_countQuery)
                            result["$top"] = 0;
                        if (queryOptions.requireTotalCount || _countQuery)
                            if (queryOptions.version !== 4)
                                result["$inlinecount"] = "allpages";
                            else
                                result["$count"] = "true";
                        return result
                    };
                queryOptions.version = queryOptions.version || DEFAULT_PROTOCOL_VERSION;
                return {
                        exec: function(url) {
                            return sendRequest(queryOptions.version, {
                                    url: url,
                                    params: $.extend(requestData(), queryOptions && queryOptions.params)
                                }, {
                                    beforeSend: queryOptions.beforeSend,
                                    jsonp: queryOptions.jsonp,
                                    withCredentials: queryOptions.withCredentials,
                                    countOnly: _countQuery
                                })
                        },
                        multiSort: function(args) {
                            var rules;
                            if (hasSlice())
                                return false;
                            for (var i = 0; i < args.length; i++) {
                                var getter = args[i][0],
                                    desc = !!args[i][1],
                                    rule;
                                if (typeof getter !== "string")
                                    return false;
                                rule = serializePropName(getter);
                                if (desc)
                                    rule += " desc";
                                rules = rules || [];
                                rules.push(rule)
                            }
                            _sorting = rules
                        },
                        slice: function(skipCount, takeCount) {
                            if (hasSlice())
                                return false;
                            _skip = skipCount;
                            _take = takeCount
                        },
                        filter: function(criterion) {
                            if (hasSlice())
                                return false;
                            if (!$.isArray(criterion))
                                criterion = $.makeArray(arguments);
                            if (hasFunction(criterion))
                                return false;
                            if (_criteria.length)
                                _criteria.push("and");
                            _criteria.push(criterion)
                        },
                        select: function(expr) {
                            if (_select || $.isFunction(expr))
                                return false;
                            if (!$.isArray(expr))
                                expr = $.makeArray(arguments);
                            _select = expr
                        },
                        count: function() {
                            _countQuery = true
                        }
                    }
            };
        $.extend(true, data, {
            EdmLiteral: EdmLiteral,
            utils: {odata: {
                    sendRequest: sendRequest,
                    serializePropName: serializePropName,
                    serializeValue: serializeValue,
                    serializeKey: serializeKey,
                    keyConverters: keyConverters
                }},
            queryAdapters: {odata: createODataQueryAdapter}
        });
        data.OData__internals = {interpretJsonFormat: interpretJsonFormat}
    })(jQuery, DevExpress);
    /*! Module core, file data.store.abstract.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            EventsMixin = DX.require("/eventsMixin"),
            abstract = Class.abstract,
            errors = DevExpress.require("/data/data.errors"),
            data = DX.data,
            normalizeSortingInfo = data.utils.normalizeSortingInfo;
        function multiLevelGroup(query, groupInfo) {
            query = query.groupBy(groupInfo[0].selector);
            if (groupInfo.length > 1)
                query = query.select(function(g) {
                    return $.extend({}, g, {items: multiLevelGroup(data.query(g.items), groupInfo.slice(1)).toArray()})
                });
            return query
        }
        data.utils.multiLevelGroup = multiLevelGroup;
        function arrangeSortingInfo(groupInfo, sortInfo) {
            var filteredGroup = [];
            $.each(groupInfo, function(_, group) {
                var collision = $.grep(sortInfo, function(sort) {
                        return group.selector === sort.selector
                    });
                if (collision.length < 1)
                    filteredGroup.push(group)
            });
            return filteredGroup.concat(sortInfo)
        }
        data.utils.arrangeSortingInfo = arrangeSortingInfo;
        data.Store = Class.inherit({
            ctor: function(options) {
                var that = this;
                options = options || {};
                $.each(["onLoaded", "onLoading", "onInserted", "onInserting", "onUpdated", "onUpdating", "onRemoved", "onRemoving", "onModified", "onModifying"], function(_, optionName) {
                    if (optionName in options)
                        that.on(optionName.slice(2).toLowerCase(), options[optionName])
                });
                this._key = options.key;
                this._errorHandler = options.errorHandler;
                this._useDefaultSearch = true
            },
            _customLoadOptions: function() {
                return null
            },
            key: function() {
                return this._key
            },
            keyOf: function(obj) {
                if (!this._keyGetter)
                    this._keyGetter = data.utils.compileGetter(this.key());
                return this._keyGetter(obj)
            },
            _requireKey: function() {
                if (!this.key())
                    throw errors.Error("E4005");
            },
            load: function(options) {
                var that = this;
                options = options || {};
                this.fireEvent("loading", [options]);
                return this._withLock(this._loadImpl(options)).done(function(result, extra) {
                        that.fireEvent("loaded", [result, options])
                    })
            },
            _loadImpl: function(options) {
                var filter = options.filter,
                    sort = options.sort,
                    select = options.select,
                    group = options.group,
                    skip = options.skip,
                    take = options.take,
                    q = this.createQuery(options);
                if (filter)
                    q = q.filter(filter);
                if (group)
                    group = normalizeSortingInfo(group);
                if (sort || group) {
                    sort = normalizeSortingInfo(sort || []);
                    if (group)
                        sort = arrangeSortingInfo(group, sort);
                    $.each(sort, function(index) {
                        q = q[index ? "thenBy" : "sortBy"](this.selector, this.desc)
                    })
                }
                if (select)
                    q = q.select(select);
                if (group)
                    q = multiLevelGroup(q, group);
                if (take || skip)
                    q = q.slice(skip || 0, take);
                return q.enumerate()
            },
            _withLock: function(task) {
                var result = $.Deferred();
                task.done(function() {
                    var that = this,
                        args = arguments;
                    DX.data.utils.processRequestResultLock.promise().done(function() {
                        result.resolveWith(that, args)
                    })
                }).fail(function() {
                    result.rejectWith(this, arguments)
                });
                return result
            },
            createQuery: abstract,
            totalCount: function(options) {
                return this._totalCountImpl(options)
            },
            _totalCountImpl: function(options) {
                options = options || {};
                var q = this.createQuery(),
                    group = options.group,
                    filter = options.filter;
                if (filter)
                    q = q.filter(filter);
                if (group) {
                    group = normalizeSortingInfo(group);
                    q = multiLevelGroup(q, group)
                }
                return q.count()
            },
            byKey: function(key, extraOptions) {
                return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)))
            },
            _byKeyImpl: abstract,
            insert: function(values) {
                var that = this;
                that.fireEvent("modifying");
                that.fireEvent("inserting", [values]);
                return that._addFailHandlers(that._insertImpl(values).done(function(callbackValues, callbackKey) {
                        that.fireEvent("inserted", [callbackValues, callbackKey]);
                        that.fireEvent("modified")
                    }))
            },
            _insertImpl: abstract,
            update: function(key, values) {
                var that = this;
                that.fireEvent("modifying");
                that.fireEvent("updating", [key, values]);
                return that._addFailHandlers(that._updateImpl(key, values).done(function(callbackKey, callbackValues) {
                        that.fireEvent("updated", [callbackKey, callbackValues]);
                        that.fireEvent("modified")
                    }))
            },
            _updateImpl: abstract,
            remove: function(key) {
                var that = this;
                that.fireEvent("modifying");
                that.fireEvent("removing", [key]);
                return that._addFailHandlers(that._removeImpl(key).done(function(callbackKey) {
                        that.fireEvent("removed", [callbackKey]);
                        that.fireEvent("modified")
                    }))
            },
            _removeImpl: abstract,
            _addFailHandlers: function(deferred) {
                return deferred.fail(this._errorHandler, data._errorHandler)
            }
        }).include(EventsMixin)
    })(jQuery, DevExpress);
    /*! Module core, file data.store.array.js */
    (function($, DX, undefined) {
        var data = DX.data,
            Guid = data.Guid,
            errors = DevExpress.require("/data/data.errors"),
            objectUtils = DX.require("/utils/utils.object");
        var trivialPromise = function() {
                var d = $.Deferred();
                return d.resolve.apply(d, arguments).promise()
            };
        var rejectedPromise = function() {
                var d = $.Deferred();
                return d.reject.apply(d, arguments).promise()
            };
        data.ArrayStore = data.Store.inherit({
            ctor: function(options) {
                if ($.isArray(options))
                    options = {data: options};
                else
                    options = options || {};
                this.callBase(options);
                var initialArray = options.data;
                if (initialArray && !$.isArray(initialArray))
                    throw errors.Error("E4006");
                this._array = initialArray || []
            },
            createQuery: function() {
                return data.query(this._array, {errorHandler: this._errorHandler})
            },
            _byKeyImpl: function(key) {
                var index = this._indexByKey(key);
                if (index === -1)
                    return rejectedPromise(errors.Error("E4009"));
                return trivialPromise(this._array[index])
            },
            _insertImpl: function(values) {
                var keyExpr = this.key(),
                    keyValue,
                    obj;
                if ($.isPlainObject(values))
                    obj = $.extend({}, values);
                else
                    obj = values;
                if (keyExpr) {
                    keyValue = this.keyOf(obj);
                    if (keyValue === undefined || typeof keyValue === "object" && $.isEmptyObject(keyValue)) {
                        if ($.isArray(keyExpr))
                            throw errors.Error("E4007");
                        keyValue = obj[keyExpr] = String(new Guid)
                    }
                    else if (this._array[this._indexByKey(keyValue)] !== undefined)
                        return rejectedPromise(errors.Error("E4008"))
                }
                else
                    keyValue = obj;
                this._array.push(obj);
                return trivialPromise(values, keyValue)
            },
            _updateImpl: function(key, values) {
                var target,
                    index;
                if (this.key()) {
                    if (this.keyOf(values))
                        if (!data.utils.keysEqual(this.key(), key, this.keyOf(values)))
                            return rejectedPromise(errors.Error("E4017"));
                    index = this._indexByKey(key);
                    if (index < 0)
                        return rejectedPromise(errors.Error("E4009"));
                    target = this._array[index]
                }
                else
                    target = key;
                objectUtils.deepExtendArraySafe(target, values);
                return trivialPromise(key, values)
            },
            _removeImpl: function(key) {
                var index = this._indexByKey(key);
                if (index > -1)
                    this._array.splice(index, 1);
                return trivialPromise(key)
            },
            _indexByKey: function(key) {
                for (var i = 0, arrayLength = this._array.length; i < arrayLength; i++)
                    if (data.utils.keysEqual(this.key(), this.keyOf(this._array[i]), key))
                        return i;
                return -1
            },
            clear: function() {
                this._array = []
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.store.local.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            abstract = Class.abstract,
            errors = DevExpress.require("/data/data.errors"),
            data = DX.data;
        var LocalStoreBackend = Class.inherit({
                ctor: function(store, storeOptions) {
                    this._store = store;
                    this._dirty = false;
                    var immediate = this._immediate = storeOptions.immediate;
                    var flushInterval = Math.max(100, storeOptions.flushInterval || 10 * 1000);
                    if (!immediate) {
                        var saveProxy = $.proxy(this.save, this);
                        setInterval(saveProxy, flushInterval);
                        $(window).on("beforeunload", saveProxy);
                        if (window.cordova)
                            document.addEventListener("pause", saveProxy, false)
                    }
                },
                notifyChanged: function() {
                    this._dirty = true;
                    if (this._immediate)
                        this.save()
                },
                load: function() {
                    this._store._array = this._loadImpl();
                    this._dirty = false
                },
                save: function() {
                    if (!this._dirty)
                        return;
                    this._saveImpl(this._store._array);
                    this._dirty = false
                },
                _loadImpl: abstract,
                _saveImpl: abstract
            });
        var DomLocalStoreBackend = LocalStoreBackend.inherit({
                ctor: function(store, storeOptions) {
                    this.callBase(store, storeOptions);
                    var name = storeOptions.name;
                    if (!name)
                        throw errors.Error("E4013");
                    this._key = "dx-data-localStore-" + name
                },
                _loadImpl: function() {
                    var raw = localStorage.getItem(this._key);
                    if (raw)
                        return JSON.parse(raw);
                    return []
                },
                _saveImpl: function(array) {
                    if (!array.length)
                        localStorage.removeItem(this._key);
                    else
                        localStorage.setItem(this._key, JSON.stringify(array))
                }
            });
        var localStoreBackends = {dom: DomLocalStoreBackend};
        data.LocalStore = data.ArrayStore.inherit({
            ctor: function(options) {
                if (typeof options === "string")
                    options = {name: options};
                else
                    options = options || {};
                this.callBase(options);
                this._backend = new localStoreBackends[options.backend || "dom"](this, options);
                this._backend.load()
            },
            clear: function() {
                this.callBase();
                this._backend.notifyChanged()
            },
            _insertImpl: function(values) {
                var b = this._backend;
                return this.callBase(values).done($.proxy(b.notifyChanged, b))
            },
            _updateImpl: function(key, values) {
                var b = this._backend;
                return this.callBase(key, values).done($.proxy(b.notifyChanged, b))
            },
            _removeImpl: function(key) {
                var b = this._backend;
                return this.callBase(key).done($.proxy(b.notifyChanged, b))
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.store.odata.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            errors = DevExpress.require("/data/data.errors"),
            proxyUrlFormatter = DX.require("/utils/utils.proxyUrlFormatter"),
            stringUtils = DX.require("/utils/utils.string"),
            commonUtils = DX.require("/utils/utils.common"),
            data = DX.data,
            odataUtils = data.utils.odata;
        var DEFAULT_PROTOCOL_VERSION = 2;
        var formatFunctionInvocationUrl = function(baseUrl, args) {
                return stringUtils.format("{0}({1})", baseUrl, $.map(args || {}, function(value, key) {
                        return stringUtils.format("{0}={1}", key, value)
                    }).join(","))
            };
        var escapeServiceOperationParams = function(params, version) {
                if (!params)
                    return params;
                var result = {};
                $.each(params, function(k, v) {
                    result[k] = odataUtils.serializeValue(v, version)
                });
                return result
            };
        var convertSimpleKey = function(keyType, keyValue) {
                var converter = odataUtils.keyConverters[keyType];
                if (!converter)
                    throw errors.Error("E4014", keyType);
                return converter(keyValue)
            };
        var SharedMethods = {
                _extractServiceOptions: function(options) {
                    options = options || {};
                    this._url = String(options.url).replace(/\/+$/, "");
                    this._beforeSend = options.beforeSend;
                    this._jsonp = options.jsonp;
                    this._version = options.version || DEFAULT_PROTOCOL_VERSION;
                    this._withCredentials = options.withCredentials
                },
                _sendRequest: function(url, method, params, payload) {
                    return odataUtils.sendRequest(this.version(), {
                            url: url,
                            method: method,
                            params: params || {},
                            payload: payload
                        }, {
                            beforeSend: this._beforeSend,
                            jsonp: this._jsonp,
                            withCredentials: this._withCredentials
                        }, this._deserializeDates)
                },
                version: function() {
                    return this._version
                }
            };
        var ODataStore = data.Store.inherit({
                ctor: function(options) {
                    this.callBase(options);
                    this._extractServiceOptions(options);
                    this._keyType = options.keyType;
                    this._deserializeDates = options.deserializeDates;
                    if (this.version() === 2)
                        this._updateMethod = "MERGE";
                    else
                        this._updateMethod = "PATCH"
                },
                _customLoadOptions: function() {
                    return ["expand", "customQueryParams"]
                },
                _byKeyImpl: function(key, extraOptions) {
                    var params = {};
                    if (extraOptions)
                        if (extraOptions.expand)
                            params["$expand"] = $.map($.makeArray(extraOptions.expand), odataUtils.serializePropName).join();
                    return this._sendRequest(this._byKeyUrl(key), "GET", params)
                },
                createQuery: function(loadOptions) {
                    var url,
                        queryOptions;
                    loadOptions = loadOptions || {};
                    queryOptions = {
                        beforeSend: this._beforeSend,
                        errorHandler: this._errorHandler,
                        jsonp: this._jsonp,
                        version: this._version,
                        withCredentials: this._withCredentials,
                        deserializeDates: this._deserializeDates,
                        expand: loadOptions.expand,
                        requireTotalCount: loadOptions.requireTotalCount
                    };
                    if (commonUtils.isDefined(loadOptions.urlOverride))
                        url = loadOptions.urlOverride;
                    else
                        url = this._url;
                    if ("customQueryParams" in loadOptions) {
                        var params = escapeServiceOperationParams(loadOptions.customQueryParams, this.version());
                        if (this.version() === 4)
                            url = formatFunctionInvocationUrl(url, params);
                        else
                            queryOptions.params = params
                    }
                    return data.query(url, queryOptions)
                },
                _insertImpl: function(values) {
                    this._requireKey();
                    var that = this,
                        d = $.Deferred();
                    $.when(this._sendRequest(this._url, "POST", null, values)).done(function(serverResponse) {
                        d.resolve(values, that.keyOf(serverResponse))
                    }).fail(d.reject);
                    return d.promise()
                },
                _updateImpl: function(key, values) {
                    var d = $.Deferred();
                    $.when(this._sendRequest(this._byKeyUrl(key), this._updateMethod, null, values)).done(function() {
                        d.resolve(key, values)
                    }).fail(d.reject);
                    return d.promise()
                },
                _removeImpl: function(key) {
                    var d = $.Deferred();
                    $.when(this._sendRequest(this._byKeyUrl(key), "DELETE")).done(function() {
                        d.resolve(key)
                    }).fail(d.reject);
                    return d.promise()
                },
                _byKeyUrl: function(key, useOriginalHost) {
                    var keyObj = key,
                        keyType = this._keyType,
                        baseUrl = useOriginalHost ? proxyUrlFormatter.formatLocalUrl(this._url) : this._url;
                    if ($.isPlainObject(keyType)) {
                        keyObj = {};
                        $.each(keyType, function(subKeyName, subKeyType) {
                            keyObj[subKeyName] = convertSimpleKey(subKeyType, key[subKeyName])
                        })
                    }
                    else if (keyType)
                        keyObj = convertSimpleKey(keyType, key);
                    return baseUrl + "(" + encodeURIComponent(odataUtils.serializeKey(keyObj, this._version)) + ")"
                }
            }).include(SharedMethods);
        var ODataContext = Class.inherit({
                ctor: function(options) {
                    var that = this;
                    that._extractServiceOptions(options);
                    that._errorHandler = options.errorHandler;
                    $.each(options.entities || [], function(entityAlias, entityOptions) {
                        that[entityAlias] = new ODataStore($.extend({}, options, {url: that._url + "/" + encodeURIComponent(entityOptions.name || entityAlias)}, entityOptions))
                    })
                },
                get: function(operationName, params) {
                    return this.invoke(operationName, params, "GET")
                },
                invoke: function(operationName, params, httpMethod) {
                    params = params || {};
                    httpMethod = (httpMethod || "POST").toLowerCase();
                    var d = $.Deferred(),
                        url = this._url + "/" + encodeURIComponent(operationName),
                        payload;
                    if (this.version() === 4)
                        if (httpMethod === "get") {
                            url = formatFunctionInvocationUrl(url, escapeServiceOperationParams(params, this.version()));
                            params = null
                        }
                        else if (httpMethod === "post") {
                            payload = params;
                            params = null
                        }
                    $.when(this._sendRequest(url, httpMethod, escapeServiceOperationParams(params, this.version()), payload)).done(function(r) {
                        if ($.isPlainObject(r) && operationName in r)
                            r = r[operationName];
                        d.resolve(r)
                    }).fail([this._errorHandler, data._errorHandler, d.reject]);
                    return d.promise()
                },
                objectLink: function(entityAlias, key) {
                    var store = this[entityAlias];
                    if (!store)
                        throw errors.Error("E4015", entityAlias);
                    if (!commonUtils.isDefined(key))
                        return null;
                    return {__metadata: {uri: store._byKeyUrl(key, true)}}
                }
            }).include(SharedMethods);
        $.extend(data, {
            ODataStore: ODataStore,
            ODataContext: ODataContext
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.store.custom.js */
    (function($, DX, undefined) {
        var data = DX.data,
            errors = DevExpress.require("/data/data.errors");
        var TOTAL_COUNT = "totalCount",
            LOAD = "load",
            BY_KEY = "byKey",
            INSERT = "insert",
            UPDATE = "update",
            REMOVE = "remove";
        function isPromise(obj) {
            return obj && $.isFunction(obj.then)
        }
        function trivialPromise(value) {
            return $.Deferred().resolve(value).promise()
        }
        function ensureRequiredFuncOption(name, obj) {
            if (!$.isFunction(obj))
                throw errors.Error("E4011", name);
        }
        function throwInvalidUserFuncResult(name) {
            throw errors.Error("E4012", name);
        }
        function createUserFuncFailureHandler(pendingDeferred) {
            function errorMessageFromXhr(promiseArguments) {
                var xhr = promiseArguments[0],
                    textStatus = promiseArguments[1];
                if (!xhr || !xhr.getResponseHeader)
                    return null;
                return data.utils.errorMessageFromXhr(xhr, textStatus)
            }
            return function(arg) {
                    var error;
                    if (arg instanceof Error)
                        error = arg;
                    else
                        error = new Error(errorMessageFromXhr(arguments) || arg && String(arg) || "Unknown error");
                    pendingDeferred.reject(error)
                }
        }
        data.CustomStore = data.Store.inherit({
            ctor: function(options) {
                options = options || {};
                this.callBase(options);
                this._useDefaultSearch = false;
                this._loadFunc = options[LOAD];
                this._totalCountFunc = options[TOTAL_COUNT];
                this._byKeyFunc = options[BY_KEY];
                this._insertFunc = options[INSERT];
                this._updateFunc = options[UPDATE];
                this._removeFunc = options[REMOVE]
            },
            createQuery: function() {
                throw errors.Error("E4010");
            },
            _totalCountImpl: function(options) {
                var userFunc = this._totalCountFunc,
                    userResult,
                    d = $.Deferred();
                ensureRequiredFuncOption(TOTAL_COUNT, userFunc);
                userResult = userFunc.apply(this, [options]);
                if (!isPromise(userResult)) {
                    userResult = Number(userResult);
                    if (!isFinite(userResult))
                        throwInvalidUserFuncResult(TOTAL_COUNT);
                    userResult = trivialPromise(userResult)
                }
                userResult.then(function(count) {
                    d.resolve(Number(count))
                }, createUserFuncFailureHandler(d));
                return this._addFailHandlers(d.promise())
            },
            _loadImpl: function(options) {
                var userFunc = this._loadFunc,
                    userResult,
                    d = $.Deferred();
                ensureRequiredFuncOption(LOAD, userFunc);
                userResult = userFunc.apply(this, [options]);
                if ($.isArray(userResult))
                    userResult = trivialPromise(userResult);
                else if (userResult === null || userResult === undefined)
                    userResult = trivialPromise([]);
                else if (!isPromise(userResult))
                    throwInvalidUserFuncResult(LOAD);
                userResult.then(function(data, extra) {
                    d.resolve(data, extra)
                }, createUserFuncFailureHandler(d));
                return this._addFailHandlers(d.promise())
            },
            _byKeyImpl: function(key, extraOptions) {
                var userFunc = this._byKeyFunc,
                    userResult,
                    d = $.Deferred();
                ensureRequiredFuncOption(BY_KEY, userFunc);
                userResult = userFunc.apply(this, [key, extraOptions]);
                if (!isPromise(userResult))
                    userResult = trivialPromise(userResult);
                userResult.then(function(obj) {
                    d.resolve(obj)
                }, createUserFuncFailureHandler(d));
                return d.promise()
            },
            _insertImpl: function(values) {
                var userFunc = this._insertFunc,
                    userResult,
                    d = $.Deferred();
                ensureRequiredFuncOption(INSERT, userFunc);
                userResult = userFunc.apply(this, [values]);
                if (!isPromise(userResult))
                    userResult = trivialPromise(userResult);
                userResult.then(function(newKey) {
                    d.resolve(values, newKey)
                }, createUserFuncFailureHandler(d));
                return d.promise()
            },
            _updateImpl: function(key, values) {
                var userFunc = this._updateFunc,
                    userResult,
                    d = $.Deferred();
                ensureRequiredFuncOption(UPDATE, userFunc);
                userResult = userFunc.apply(this, [key, values]);
                if (!isPromise(userResult))
                    userResult = trivialPromise();
                userResult.then(function() {
                    d.resolve(key, values)
                }, createUserFuncFailureHandler(d));
                return d.promise()
            },
            _removeImpl: function(key) {
                var userFunc = this._removeFunc,
                    userResult,
                    d = $.Deferred();
                ensureRequiredFuncOption(REMOVE, userFunc);
                userResult = userFunc.apply(this, [key]);
                if (!isPromise(userResult))
                    userResult = trivialPromise();
                userResult.then(function() {
                    d.resolve(key)
                }, createUserFuncFailureHandler(d));
                return d.promise()
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file data.dataSource.js */
    (function($, DX, undefined) {
        var data = DX.data,
            CustomStore = data.CustomStore,
            Class = DX.require("/class"),
            EventsMixin = DX.require("/eventsMixin"),
            errors = DX.require("/data/data.errors"),
            array = DX.require("/utils/utils.array"),
            queue = DX.require("/utils/utils.queue"),
            commonUtils = DX.require("/utils/utils.common");
        var CANCELED_TOKEN = "canceled";
        function OperationManager() {
            this._counter = -1;
            this._deferreds = {}
        }
        OperationManager.prototype.constructor = OperationManager;
        OperationManager.prototype.add = function addOperation(deferred) {
            this._counter += 1;
            this._deferreds[this._counter] = deferred;
            return this._counter
        };
        OperationManager.prototype.remove = function removeOperation(operationId) {
            return delete this._deferreds[operationId]
        };
        OperationManager.prototype.cancel = function cancelOperation(operationId) {
            if (operationId in this._deferreds) {
                this._deferreds[operationId].reject(CANCELED_TOKEN);
                return true
            }
            return false
        };
        var operationManager = new OperationManager;
        var storeTypeRegistry = {
                jaydata: "JayDataStore",
                breeze: "BreezeStore",
                odata: "ODataStore",
                local: "LocalStore",
                array: "ArrayStore"
            };
        function isPending(deferred) {
            return deferred.state() === "pending"
        }
        function normalizeDataSourceOptions(options) {
            var store;
            function createCustomStoreFromLoadFunc() {
                var storeConfig = {};
                $.each(["key", "load", "byKey", "lookup", "totalCount", "insert", "update", "remove"], function() {
                    storeConfig[this] = options[this];
                    delete options[this]
                });
                return new CustomStore(storeConfig)
            }
            function createStoreFromConfig(storeConfig) {
                var storeCtor = data[storeTypeRegistry[storeConfig.type]];
                delete storeConfig.type;
                return new storeCtor(storeConfig)
            }
            function createCustomStoreFromUrl(url) {
                return new CustomStore({load: function() {
                            return $.getJSON(url)
                        }})
            }
            if (typeof options === "string")
                options = {
                    paginate: false,
                    store: createCustomStoreFromUrl(options)
                };
            if (options === undefined)
                options = [];
            if ($.isArray(options) || options instanceof data.Store)
                options = {store: options};
            else
                options = $.extend({}, options);
            if (options.store === undefined)
                options.store = [];
            store = options.store;
            if ("load" in options)
                store = createCustomStoreFromLoadFunc();
            else if ($.isArray(store))
                store = new data.ArrayStore(store);
            else if ($.isPlainObject(store))
                store = createStoreFromConfig($.extend({}, store));
            options.store = store;
            return options
        }
        function normalizeStoreLoadOptionAccessorArguments(originalArguments) {
            switch (originalArguments.length) {
                case 0:
                    return undefined;
                case 1:
                    return originalArguments[0]
            }
            return $.makeArray(originalArguments)
        }
        function generateStoreLoadOptionAccessor(optionName) {
            return function() {
                    var args = normalizeStoreLoadOptionAccessorArguments(arguments);
                    if (args === undefined)
                        return this._storeLoadOptions[optionName];
                    this._storeLoadOptions[optionName] = args
                }
        }
        function mapDataRespectingGrouping(items, mapper, groupInfo) {
            function mapRecursive(items, level) {
                if (!commonUtils.isArray(items))
                    return items;
                return level ? mapGroup(items, level) : $.map(items, mapper)
            }
            function mapGroup(group, level) {
                return $.map(group, function(item) {
                        var result = {
                                key: item.key,
                                items: mapRecursive(item.items, level - 1)
                            };
                        if ("aggregates" in item)
                            result.aggregates = item.aggregates;
                        return result
                    })
            }
            return mapRecursive(items, groupInfo ? data.utils.normalizeSortingInfo(groupInfo).length : 0)
        }
        var DataSource = Class.inherit({
                ctor: function(options) {
                    var that = this;
                    options = normalizeDataSourceOptions(options);
                    this._store = options.store;
                    this._storeLoadOptions = this._extractLoadOptions(options);
                    this._mapFunc = options.map;
                    this._postProcessFunc = options.postProcess;
                    this._pageIndex = options.pageIndex !== undefined ? options.pageIndex : 0;
                    this._pageSize = options.pageSize !== undefined ? options.pageSize : 20;
                    this._items = [];
                    this._totalCount = -1;
                    this._isLoaded = false;
                    this._loadingCount = 0;
                    this._loadQueue = this._createLoadQueue();
                    this._searchValue = "searchValue" in options ? options.searchValue : null;
                    this._searchOperation = options.searchOperation || "contains";
                    this._searchExpr = options.searchExpr;
                    this._paginate = options.paginate;
                    if (this._paginate === undefined)
                        this._paginate = !this.group();
                    this._isLastPage = !this._paginate;
                    this._userData = {};
                    $.each(["onChanged", "onLoadError", "onLoadingChanged", "onCustomizeLoadResult", "onCustomizeStoreLoadOptions"], function(_, optionName) {
                        if (optionName in options)
                            that.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options[optionName])
                    })
                },
                dispose: function() {
                    this._disposeEvents();
                    delete this._store;
                    if (this._delayedLoadTask)
                        this._delayedLoadTask.abort();
                    this._disposed = true
                },
                _extractLoadOptions: function(options) {
                    var result = {},
                        names = ["sort", "filter", "select", "group", "requireTotalCount"],
                        customNames = this._store._customLoadOptions();
                    if (customNames)
                        names = names.concat(customNames);
                    $.each(names, function() {
                        result[this] = options[this]
                    });
                    return result
                },
                loadOptions: function() {
                    return this._storeLoadOptions
                },
                items: function() {
                    return this._items
                },
                pageIndex: function(newIndex) {
                    if (newIndex === undefined)
                        return this._pageIndex;
                    this._pageIndex = newIndex;
                    this._isLastPage = !this._paginate
                },
                paginate: function(value) {
                    if (arguments.length < 1)
                        return this._paginate;
                    value = !!value;
                    if (this._paginate !== value) {
                        this._paginate = value;
                        this.pageIndex(0)
                    }
                },
                pageSize: function(value) {
                    if (arguments.length < 1)
                        return this._pageSize;
                    this._pageSize = value
                },
                isLastPage: function() {
                    return this._isLastPage
                },
                sort: generateStoreLoadOptionAccessor("sort"),
                filter: function() {
                    var newFilter = normalizeStoreLoadOptionAccessorArguments(arguments);
                    if (newFilter === undefined)
                        return this._storeLoadOptions.filter;
                    this._storeLoadOptions.filter = newFilter;
                    this.pageIndex(0)
                },
                group: generateStoreLoadOptionAccessor("group"),
                select: generateStoreLoadOptionAccessor("select"),
                requireTotalCount: generateStoreLoadOptionAccessor("requireTotalCount"),
                searchValue: function(value) {
                    if (value === undefined)
                        return this._searchValue;
                    this.pageIndex(0);
                    this._searchValue = value
                },
                searchOperation: function(op) {
                    if (op === undefined)
                        return this._searchOperation;
                    this.pageIndex(0);
                    this._searchOperation = op
                },
                searchExpr: function(expr) {
                    var argc = arguments.length;
                    if (argc === 0)
                        return this._searchExpr;
                    if (argc > 1)
                        expr = $.makeArray(arguments);
                    this.pageIndex(0);
                    this._searchExpr = expr
                },
                store: function() {
                    return this._store
                },
                key: function() {
                    return this._store && this._store.key()
                },
                totalCount: function() {
                    return this._totalCount
                },
                isLoaded: function() {
                    return this._isLoaded
                },
                isLoading: function() {
                    return this._loadingCount > 0
                },
                _createLoadQueue: function() {
                    return queue.create()
                },
                _changeLoadingCount: function(increment) {
                    var oldLoading = this.isLoading(),
                        newLoading;
                    this._loadingCount += increment;
                    newLoading = this.isLoading();
                    if (oldLoading ^ newLoading)
                        this.fireEvent("loadingChanged", [newLoading])
                },
                _scheduleLoadCallbacks: function(deferred) {
                    var that = this;
                    that._changeLoadingCount(1);
                    deferred.always(function() {
                        that._changeLoadingCount(-1)
                    })
                },
                _scheduleFailCallbacks: function(deferred) {
                    var that = this;
                    deferred.fail(function() {
                        if (arguments[0] === CANCELED_TOKEN)
                            return;
                        that.fireEvent("loadError", arguments)
                    })
                },
                _scheduleChangedCallbacks: function(deferred) {
                    var that = this;
                    deferred.done(function() {
                        that.fireEvent("changed")
                    })
                },
                loadSingle: function(propName, propValue) {
                    var that = this;
                    var d = $.Deferred(),
                        key = this.key(),
                        store = this._store,
                        options = this._createStoreLoadOptions(),
                        handleDone = function(data) {
                            if (!commonUtils.isDefined(data) || array.isEmpty(data))
                                d.reject(new errors.Error("E4009"));
                            else
                                d.resolve(that._applyMapFunction($.makeArray(data))[0])
                        };
                    this._scheduleFailCallbacks(d);
                    if (arguments.length < 2) {
                        propValue = propName;
                        propName = key
                    }
                    delete options.skip;
                    delete options.group;
                    delete options.refresh;
                    delete options.pageIndex;
                    delete options.searchString;
                    (function() {
                        if (propName === key || store instanceof data.CustomStore)
                            return store.byKey(propValue, options);
                        options.take = 1;
                        options.filter = options.filter ? [options.filter, [propName, propValue]] : [propName, propValue];
                        return store.load(options)
                    })().fail(d.reject).done(handleDone);
                    return d.promise()
                },
                load: function() {
                    var that = this,
                        d = $.Deferred(),
                        loadOperation;
                    function loadTask() {
                        if (that._disposed)
                            return undefined;
                        if (!isPending(d))
                            return;
                        return that._loadFromStore(loadOperation, d)
                    }
                    this._scheduleLoadCallbacks(d);
                    this._scheduleFailCallbacks(d);
                    this._scheduleChangedCallbacks(d);
                    loadOperation = this._createLoadOperation(d);
                    this.fireEvent("customizeStoreLoadOptions", [loadOperation]);
                    this._loadQueue.add(function() {
                        if (typeof loadOperation.delay === "number")
                            that._delayedLoadTask = commonUtils.executeAsync(loadTask, loadOperation.delay);
                        else
                            loadTask();
                        return d.promise()
                    });
                    return d.promise({operationId: loadOperation.operationId})
                },
                _createLoadOperation: function(deferred) {
                    var id = operationManager.add(deferred),
                        options = this._createStoreLoadOptions();
                    deferred.always(function() {
                        operationManager.remove(id)
                    });
                    return {
                            operationId: id,
                            storeLoadOptions: options
                        }
                },
                reload: function() {
                    var prop,
                        userData = this._userData;
                    for (prop in userData)
                        if (userData.hasOwnProperty(prop))
                            delete userData[prop];
                    this._totalCount = -1;
                    this._isLoaded = false;
                    return this.load()
                },
                cancel: function(loadOperationId) {
                    return operationManager.cancel(loadOperationId)
                },
                _addSearchOptions: function(storeLoadOptions) {
                    if (this._disposed)
                        return;
                    if (this.store()._useDefaultSearch)
                        this._addSearchFilter(storeLoadOptions);
                    else {
                        storeLoadOptions.searchOperation = this._searchOperation;
                        storeLoadOptions.searchValue = this._searchValue;
                        storeLoadOptions.searchExpr = this._searchExpr
                    }
                },
                _createStoreLoadOptions: function() {
                    var result = $.extend({}, this._storeLoadOptions);
                    this._addSearchOptions(result);
                    if (this._paginate)
                        if (this._pageSize) {
                            result.skip = this._pageIndex * this._pageSize;
                            result.take = this._pageSize
                        }
                    result.userData = this._userData;
                    return result
                },
                _addSearchFilter: function(storeLoadOptions) {
                    var value = this._searchValue,
                        op = this._searchOperation,
                        selector = this._searchExpr,
                        searchFilter = [];
                    if (!value)
                        return;
                    if (!selector)
                        selector = "this";
                    if (!$.isArray(selector))
                        selector = [selector];
                    $.each(selector, function(i, item) {
                        if (searchFilter.length)
                            searchFilter.push("or");
                        searchFilter.push([item, op, value])
                    });
                    if (storeLoadOptions.filter)
                        storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter];
                    else
                        storeLoadOptions.filter = searchFilter
                },
                _loadFromStore: function(loadOptions, pendingDeferred) {
                    var that = this;
                    function handleSuccess(data, extra) {
                        function processResult() {
                            var loadResult;
                            loadResult = $.extend({
                                data: data,
                                extra: extra
                            }, loadOptions);
                            that.fireEvent("customizeLoadResult", [loadResult]);
                            $.when(loadResult.data).done(function(data) {
                                loadResult.data = data;
                                that._processStoreLoadResult(loadResult, pendingDeferred)
                            }).fail(pendingDeferred.reject)
                        }
                        if (that._disposed)
                            return;
                        if (!isPending(pendingDeferred))
                            return;
                        processResult()
                    }
                    if (loadOptions.data)
                        return $.Deferred().resolve(loadOptions.data).done(handleSuccess);
                    return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject)
                },
                _processStoreLoadResult: function(loadResult, pendingDeferred) {
                    var that = this;
                    var data = $.makeArray(loadResult.data),
                        extra = loadResult.extra,
                        storeLoadOptions = loadResult.storeLoadOptions;
                    function resolvePendingDeferred() {
                        that._isLoaded = true;
                        that._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
                        return pendingDeferred.resolve(data, extra)
                    }
                    function proceedLoadingTotalCount() {
                        that.store().totalCount(storeLoadOptions).done(function(count) {
                            extra.totalCount = count;
                            resolvePendingDeferred()
                        }).fail(pendingDeferred.reject)
                    }
                    if (that._disposed)
                        return;
                    data = that._applyPostProcessFunction(that._applyMapFunction(data));
                    if (!$.isPlainObject(extra))
                        extra = {};
                    that._items = data;
                    if (!data.length || !that._paginate || that._pageSize && data.length < that._pageSize)
                        that._isLastPage = true;
                    if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount))
                        proceedLoadingTotalCount();
                    else
                        resolvePendingDeferred()
                },
                _applyMapFunction: function(data) {
                    if (this._mapFunc)
                        return mapDataRespectingGrouping(data, this._mapFunc, this.group());
                    return data
                },
                _applyPostProcessFunction: function(data) {
                    if (this._postProcessFunc)
                        return this._postProcessFunc(data);
                    return data
                }
            }).include(EventsMixin);
        $.extend(true, data, {
            DataSource: DataSource,
            utils: {
                storeTypeRegistry: storeTypeRegistry,
                normalizeDataSourceOptions: normalizeDataSourceOptions
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file uiNamespace.js */
    DevExpress.define("/ui/uiNamespace", ["/coreNamespace", "/ui/ui.themes", "/ui/templates/ui.templateBase", "/integration/jquery/jquery.template", "/ui/ui.actionExecutors"], function(coreNamespace, themes, TemplateBase, Template) {
        var uiNamespace = coreNamespace.ui = coreNamespace.ui || {};
        uiNamespace.themes = {current: themes.current};
        uiNamespace.setTemplateEngine = Template.setTemplateEngine;
        uiNamespace.templateRendered = TemplateBase.renderedCallbacks;
        return uiNamespace
    });
    /*! Module core, file ui.themes.js */
    DevExpress.define("/ui/ui.themes", ["jquery", "/ui/ui.errors", "/utils/utils.dom", "/devices", "/utils/utils.viewPort"], function($, errors, domUtils, devices, viewPortUtils) {
        var viewPort = viewPortUtils.value,
            viewPortChanged = viewPortUtils.changeCallback;
        var DX_LINK_SELECTOR = "link[rel=dx-theme]",
            THEME_ATTR = "data-theme",
            ACTIVE_ATTR = "data-active",
            DX_HAIRLINES_CLASS = "dx-hairlines";
        var context,
            $activeThemeLink,
            knownThemes,
            currentThemeName,
            pendingThemeName;
        var THEME_MARKER_PREFIX = "dx.";
        function readThemeMarker() {
            var element = $("<div></div>", context).addClass("dx-theme-marker").appendTo(context.documentElement),
                result;
            try {
                result = element.css("font-family");
                if (!result)
                    return null;
                result = result.replace(/["']/g, "");
                if (result.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX)
                    return null;
                return result.substr(THEME_MARKER_PREFIX.length)
            }
            finally {
                element.remove()
            }
        }
        function waitForThemeLoad(themeName, callback) {
            var timerId,
                waitStartTime;
            pendingThemeName = themeName;
            function handleLoaded() {
                pendingThemeName = null;
                callback()
            }
            if (isPendingThemeLoaded())
                handleLoaded();
            else {
                waitStartTime = $.now();
                timerId = setInterval(function() {
                    var isLoaded = isPendingThemeLoaded(),
                        isTimeout = !isLoaded && $.now() - waitStartTime > 15 * 1000;
                    if (isTimeout)
                        errors.log("W0004", pendingThemeName);
                    if (isLoaded || isTimeout) {
                        clearInterval(timerId);
                        handleLoaded()
                    }
                }, 10)
            }
        }
        function isPendingThemeLoaded() {
            return !pendingThemeName || readThemeMarker() === pendingThemeName
        }
        function processMarkup() {
            var $allThemeLinks = $(DX_LINK_SELECTOR, context);
            if (!$allThemeLinks.length)
                return;
            knownThemes = {};
            $activeThemeLink = $(domUtils.createMarkupFromString("<link rel=stylesheet>"), context);
            $allThemeLinks.each(function() {
                var link = $(this, context),
                    fullThemeName = link.attr(THEME_ATTR),
                    url = link.attr("href"),
                    isActive = link.attr(ACTIVE_ATTR) === "true";
                knownThemes[fullThemeName] = {
                    url: url,
                    isActive: isActive
                }
            });
            $allThemeLinks.last().after($activeThemeLink);
            $allThemeLinks.remove()
        }
        function resolveFullThemeName(desiredThemeName) {
            var desiredThemeParts = desiredThemeName.split("."),
                result = null;
            if (knownThemes)
                $.each(knownThemes, function(knownThemeName, themeData) {
                    var knownThemeParts = knownThemeName.split(".");
                    if (knownThemeParts[0] !== desiredThemeParts[0])
                        return;
                    if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1])
                        return;
                    if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2])
                        return;
                    if (!result || themeData.isActive)
                        result = knownThemeName;
                    if (themeData.isActive)
                        return false
                });
            return result
        }
        function initContext(newContext) {
            try {
                if (newContext !== context)
                    knownThemes = null
            }
            catch(x) {
                knownThemes = null
            }
            context = newContext
        }
        function init(options) {
            options = options || {};
            initContext(options.context || document);
            processMarkup();
            currentThemeName = undefined;
            current(options)
        }
        function current(options) {
            if (!arguments.length)
                return currentThemeName || readThemeMarker();
            detachCssClasses(viewPort(), currentThemeName);
            options = options || {};
            if (typeof options === "string")
                options = {theme: options};
            var isAutoInit = options._autoInit,
                loadCallback = options.loadCallback,
                currentThemeData;
            currentThemeName = options.theme || currentThemeName;
            if (isAutoInit && !currentThemeName)
                currentThemeName = themeNameFromDevice(devices.current());
            currentThemeName = resolveFullThemeName(currentThemeName);
            if (currentThemeName)
                currentThemeData = knownThemes[currentThemeName];
            if (currentThemeData) {
                $activeThemeLink.attr("href", knownThemes[currentThemeName].url);
                if (loadCallback)
                    waitForThemeLoad(currentThemeName, loadCallback);
                else if (pendingThemeName)
                    pendingThemeName = currentThemeName
            }
            else if (isAutoInit) {
                if (loadCallback)
                    loadCallback()
            }
            else
                throw errors.Error("E0021", currentThemeName);
            attachCssClasses(viewPort(), currentThemeName)
        }
        function themeNameFromDevice(device) {
            var themeName = device.platform;
            var majorVersion = device.version && device.version[0];
            var isForced = devices.isForced();
            switch (themeName) {
                case"ios":
                    themeName += "7";
                    break;
                case"android":
                    themeName += "5";
                    break;
                case"win":
                    themeName += majorVersion && majorVersion === 8 && isForced ? "8" : "10";
                    break
            }
            return themeName
        }
        function getCssClasses(themeName) {
            themeName = themeName || current();
            var result = [],
                themeNameParts = themeName && themeName.split(".");
            if (themeNameParts) {
                result.push("dx-theme-" + themeNameParts[0], "dx-theme-" + themeNameParts[0] + "-typography");
                if (themeNameParts.length > 1)
                    result.push("dx-color-scheme-" + themeNameParts[1])
            }
            return result
        }
        var themeClasses;
        function attachCssClasses(element, themeName) {
            themeClasses = getCssClasses(themeName).join(" ");
            $(element).addClass(themeClasses);
            var activateHairlines = function() {
                    var pixelRatio = window.devicePixelRatio;
                    if (!pixelRatio || pixelRatio < 2)
                        return;
                    var $tester = $("<div>");
                    $tester.css("border", ".5px solid transparent");
                    $("body").append($tester);
                    if ($tester.outerHeight() === 1) {
                        $(element).addClass(DX_HAIRLINES_CLASS);
                        themeClasses += " " + DX_HAIRLINES_CLASS
                    }
                    $tester.remove()
                };
            activateHairlines()
        }
        function detachCssClasses(element, themeName) {
            $(element).removeClass(themeClasses)
        }
        $.holdReady(true);
        init({
            _autoInit: true,
            loadCallback: function() {
                $.holdReady(false)
            }
        });
        $(function() {
            if ($(DX_LINK_SELECTOR, context).length)
                throw errors.Error("E0022");
        });
        viewPortChanged.add(function(viewPort, prevViewPort) {
            detachCssClasses(prevViewPort);
            attachCssClasses(viewPort)
        });
        devices.changed.add(function() {
            init({_autoInit: true})
        });
        return {
                init: init,
                current: current,
                attachCssClasses: attachCssClasses,
                detachCssClasses: detachCssClasses,
                themeNameFromDevice: themeNameFromDevice,
                waitForThemeLoad: waitForThemeLoad,
                resetTheme: function() {
                    $activeThemeLink.attr("href", "about:blank");
                    currentThemeName = null;
                    pendingThemeName = null
                }
            }
    });
    /*! Module core, file ui.keyboardProcessor.js */
    DevExpress.define("/ui/ui.keyboardProcessor", ["jquery", "/class", "/ui/events/ui.events.utils"], function($, Class, eventUtils) {
        var KeyboardProcessor = Class.inherit({
                _keydown: eventUtils.addNamespace("keydown", "KeyboardProcessor"),
                codes: {
                    "8": "backspace",
                    "9": "tab",
                    "13": "enter",
                    "27": "escape",
                    "33": "pageUp",
                    "34": "pageDown",
                    "35": "end",
                    "36": "home",
                    "37": "leftArrow",
                    "38": "upArrow",
                    "39": "rightArrow",
                    "40": "downArrow",
                    "46": "del",
                    "32": "space",
                    "70": "F",
                    "65": "A",
                    "106": "asterisk",
                    "109": "minus"
                },
                ctor: function(options) {
                    var _this = this;
                    options = options || {};
                    if (options.element)
                        this._element = $(options.element);
                    if (options.focusTarget)
                        this._focusTarget = options.focusTarget;
                    this._handler = options.handler;
                    this._context = options.context;
                    this._childProcessors = [];
                    if (this._element)
                        this._element.on(this._keydown, function(e) {
                            _this.process(e)
                        })
                },
                dispose: function() {
                    if (this._element)
                        this._element.off(this._keydown);
                    this._element = undefined;
                    this._handler = undefined;
                    this._context = undefined;
                    this._childProcessors = undefined
                },
                clearChildren: function() {
                    this._childProcessors = []
                },
                push: function(child) {
                    if (!this._childProcessors)
                        this.clearChildren();
                    this._childProcessors.push(child);
                    return child
                },
                attachChildProcessor: function() {
                    var childProcessor = new KeyboardProcessor;
                    this._childProcessors.push(childProcessor);
                    return childProcessor
                },
                reinitialize: function(childHandler, childContext) {
                    this._context = childContext;
                    this._handler = childHandler;
                    return this
                },
                process: function(e) {
                    if (this._focusTarget && this._focusTarget !== e.target && $.inArray(e.target, this._focusTarget) < 0)
                        return false;
                    var args = {
                            key: this.codes[e.which] || e.which,
                            ctrl: e.ctrlKey,
                            shift: e.shiftKey,
                            alt: e.altKey,
                            originalEvent: e
                        };
                    var handlerResult = this._handler && this._handler.call(this._context, args);
                    if (handlerResult && this._childProcessors)
                        $.each(this._childProcessors, function(index, childProcessor) {
                            childProcessor.process(e)
                        })
                }
            });
        return KeyboardProcessor
    });
    /*! Module core, file ui.widget.js */
    DevExpress.define("/ui/ui.widget", ["jquery", "/ui/ui.errors", "/action", "/utils/utils.dom", "/utils/utils.common", "/devices", "/domComponent", "/ui/templates/ui.templateBase", "/ui/templates/ui.template.dynamic", "/ui/templates/ui.template.empty", "/ui/templates/ui.template.move", "/integration/jquery/jquery.templateProvider", "/ui/ui.keyboardProcessor", "/integration/jquery/jquery.selectors", "/ui/events/ui.events.utils", "/ui/events/ui.events.hover", "/ui/events/ui.events.emitter.feedback"], function($, errors, Action, domUtils, commonUtils, devices, DOMComponent, TemplateBase, DynamicTemplate, EmptyTemplate, MoveTemplate, TemplateProvider, KeyboardProcessor, selectors, eventUtils, hoverEvents, feedbackEvents) {
        var UI_FEEDBACK = "UIFeedback",
            WIDGET_CLASS = "dx-widget",
            ACTIVE_STATE_CLASS = "dx-state-active",
            DISABLED_STATE_CLASS = "dx-state-disabled",
            INVISIBLE_STATE_CLASS = "dx-state-invisible",
            HOVER_STATE_CLASS = "dx-state-hover",
            FOCUSED_STATE_CLASS = "dx-state-focused",
            FEEDBACK_SHOW_TIMEOUT = 30,
            FEEDBACK_HIDE_TIMEOUT = 400,
            FOCUS_NAMESPACE = "Focus",
            ANONYMOUS_TEMPLATE_NAME = "template",
            TEXT_NODE = 3,
            TEMPLATE_SELECTOR = "[data-options*='dxTemplate']",
            TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
        var Widget = DOMComponent.inherit({
                _supportedKeys: function() {
                    return {}
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            disabled: false,
                            visible: true,
                            hint: undefined,
                            activeStateEnabled: false,
                            onContentReady: null,
                            hoverStateEnabled: false,
                            focusStateEnabled: false,
                            tabIndex: 0,
                            accessKey: null,
                            onFocusIn: null,
                            onFocusOut: null,
                            templateProvider: TemplateProvider,
                            _keyboardProcessor: undefined,
                            _templates: {}
                        })
                },
                _init: function() {
                    this.callBase();
                    this._feedbackShowTimeout = FEEDBACK_SHOW_TIMEOUT;
                    this._feedbackHideTimeout = FEEDBACK_HIDE_TIMEOUT;
                    this._tempTemplates = [];
                    this._dynamicTemplates = {};
                    this._initTemplates();
                    this._initContentReadyAction()
                },
                _initTemplates: function() {
                    this._extractTemplates();
                    this._extractAnonymousTemplate()
                },
                _extractTemplates: function() {
                    var templates = this.option("_templates"),
                        templateElements = this.element().contents().filter(TEMPLATE_SELECTOR);
                    var templatesMap = {};
                    templateElements.each(function(_, template) {
                        var templateOptions = domUtils.getElementOptions(template).dxTemplate;
                        if (!templateOptions)
                            return;
                        if (!templateOptions.name)
                            throw errors.Error("E0023");
                        $(template).addClass(TEMPLATE_WRAPPER_CLASS).detach();
                        templatesMap[templateOptions.name] = templatesMap[templateOptions.name] || [];
                        templatesMap[templateOptions.name].push(template)
                    });
                    $.each(templatesMap, $.proxy(function(templateName, value) {
                        var deviceTemplate = this._findTemplateByDevice(value);
                        if (deviceTemplate)
                            templates[templateName] = this._createTemplate(deviceTemplate, this)
                    }, this))
                },
                _findTemplateByDevice: function(templates) {
                    var suitableTemplate = commonUtils.findBestMatches(devices.current(), templates, function(template) {
                            return domUtils.getElementOptions(template).dxTemplate
                        })[0];
                    $.each(templates, function(index, template) {
                        if (template !== suitableTemplate)
                            $(template).remove()
                    });
                    return suitableTemplate
                },
                _extractAnonymousTemplate: function() {
                    var templates = this.option("_templates"),
                        anonymiousTemplateName = this._getAnonymousTemplateName(),
                        $anonymiousTemplate = this.element().contents().detach();
                    var $notJunkTemplateContent = $anonymiousTemplate.filter(function(_, element) {
                            var isTextNode = element.nodeType === TEXT_NODE,
                                isEmptyText = $.trim($(element).text()).length < 1;
                            return !(isTextNode && isEmptyText)
                        }),
                        onlyJunkTemplateContent = $notJunkTemplateContent.length < 1;
                    if (!templates[anonymiousTemplateName] && !onlyJunkTemplateContent)
                        templates[anonymiousTemplateName] = this._createTemplate($anonymiousTemplate, this)
                },
                _getAriaTarget: function() {
                    return this._focusTarget()
                },
                _getAnonymousTemplateName: function() {
                    return ANONYMOUS_TEMPLATE_NAME
                },
                _getTemplateByOption: function(optionName) {
                    return this._getTemplate(this.option(optionName))
                },
                _getTemplate: function(templateSource) {
                    if ($.isFunction(templateSource)) {
                        var that = this;
                        return new DynamicTemplate(function() {
                                var templateSourceResult = templateSource.apply(that, arguments);
                                if (commonUtils.isDefined(templateSourceResult))
                                    return that._acquireTemplate(templateSourceResult, this, true);
                                else
                                    return new EmptyTemplate
                            }, this)
                    }
                    return this._acquireTemplate(templateSource, this)
                },
                _acquireTemplate: function(templateSource, owner, preferRenderer) {
                    if (templateSource == null)
                        return this._createTemplate(domUtils.normalizeTemplateElement(templateSource), owner);
                    if (templateSource instanceof TemplateBase)
                        return templateSource;
                    if (templateSource.nodeType || templateSource.jquery) {
                        templateSource = $(templateSource);
                        if (preferRenderer && !templateSource.is("script"))
                            return new MoveTemplate(templateSource, owner);
                        return this._createTemplate(templateSource, owner)
                    }
                    if (typeof templateSource === "string") {
                        var userTemplate = this.option("_templates")[templateSource];
                        if (userTemplate)
                            return userTemplate;
                        var dynamicTemplate = this._dynamicTemplates[templateSource];
                        if (dynamicTemplate)
                            return dynamicTemplate;
                        var defaultTemplate = this.option("templateProvider").getTemplates(this)[templateSource];
                        if (defaultTemplate)
                            return defaultTemplate;
                        return this._createTemplate(domUtils.normalizeTemplateElement(templateSource), owner)
                    }
                    return this._acquireTemplate(templateSource.toString(), owner)
                },
                _createTemplate: function(element, owner) {
                    var template = this.option("templateProvider").createTemplate(element, owner);
                    this._tempTemplates.push(template);
                    return template
                },
                _cleanTemplates: function() {
                    var that = this;
                    $.each(this.option("_templates"), function(_, template) {
                        if (that === template.owner())
                            template.dispose()
                    });
                    $.each(this._tempTemplates, function(_, template) {
                        template.dispose()
                    })
                },
                _initContentReadyAction: function() {
                    this._contentReadyAction = this._createActionByOption("onContentReady", {excludeValidators: ["designMode", "disabled", "readOnly"]})
                },
                _render: function() {
                    this.element().addClass(WIDGET_CLASS);
                    this.callBase();
                    this._toggleDisabledState(this.option("disabled"));
                    this._toggleVisibility(this.option("visible"));
                    this._renderHint();
                    this._renderContent();
                    this._renderFocusState();
                    this._attachFeedbackEvents();
                    this._attachHoverEvents()
                },
                _renderHint: function() {
                    domUtils.toggleAttr(this.element(), "title", this.option("hint"))
                },
                _renderContent: function() {
                    this._renderContentImpl();
                    this._fireContentReadyAction()
                },
                _renderContentImpl: $.noop,
                _fireContentReadyAction: function() {
                    this._contentReadyAction()
                },
                _dispose: function() {
                    this._cleanTemplates();
                    this._contentReadyAction = null;
                    this.callBase()
                },
                _clean: function() {
                    this._cleanFocusState();
                    this.callBase();
                    this.element().empty()
                },
                _toggleVisibility: function(visible) {
                    this.element().toggleClass(INVISIBLE_STATE_CLASS, !visible);
                    this.setAria("hidden", !visible || undefined)
                },
                _renderFocusState: function() {
                    if (!this.option("focusStateEnabled") || this.option("disabled"))
                        return;
                    this._renderFocusTarget();
                    this._attachFocusEvents();
                    this._attachKeyboardEvents();
                    this._renderAccessKey()
                },
                _renderAccessKey: function() {
                    var focusTarget = this._focusTarget();
                    focusTarget.attr("accesskey", this.option("accessKey"));
                    var clickNamespace = eventUtils.addNamespace("dxclick", UI_FEEDBACK);
                    focusTarget.off(clickNamespace);
                    this.option("accessKey") && focusTarget.on(clickNamespace, $.proxy(function(e) {
                        if (eventUtils.isFakeClickEvent(e)) {
                            e.stopImmediatePropagation();
                            this.focus()
                        }
                    }, this))
                },
                _eventBindingTarget: function() {
                    return this.element()
                },
                _focusTarget: function() {
                    return this._getActiveElement()
                },
                _getActiveElement: function() {
                    var activeElement = this._eventBindingTarget();
                    if (this._activeStateUnit)
                        activeElement = activeElement.find(this._activeStateUnit).not("." + DISABLED_STATE_CLASS);
                    return activeElement
                },
                _renderFocusTarget: function() {
                    this._focusTarget().attr("tabindex", this.option("tabIndex"))
                },
                _keyboardEventBindingTarget: function() {
                    return this._eventBindingTarget()
                },
                _detachFocusEvents: function() {
                    var $element = this._focusTarget(),
                        focusInEvent = eventUtils.addNamespace("focusin", this.NAME + FOCUS_NAMESPACE),
                        focusOutEvent = eventUtils.addNamespace("focusout", this.NAME + FOCUS_NAMESPACE),
                        beforeactivateEvent = eventUtils.addNamespace("beforeactivate", this.NAME + FOCUS_NAMESPACE);
                    $element.off(focusInEvent + " " + focusOutEvent + " " + beforeactivateEvent)
                },
                _attachFocusEvents: function() {
                    var focusInEvent = eventUtils.addNamespace("focusin", this.NAME + FOCUS_NAMESPACE),
                        focusOutEvent = eventUtils.addNamespace("focusout", this.NAME + FOCUS_NAMESPACE),
                        beforeactivateEvent = eventUtils.addNamespace("beforeactivate", this.NAME + FOCUS_NAMESPACE);
                    this._focusTarget().on(focusInEvent, $.proxy(this._focusInHandler, this)).on(focusOutEvent, $.proxy(this._focusOutHandler, this)).on(beforeactivateEvent, function(e) {
                        if (!$(e.target).is(selectors.focusable))
                            e.preventDefault()
                    })
                },
                _refreshFocusEvent: function() {
                    this._detachFocusEvents();
                    this._attachFocusEvents()
                },
                _focusInHandler: function(e) {
                    var that = this;
                    that._createActionByOption("onFocusIn", {
                        beforeExecute: function() {
                            that._updateFocusState(e, true)
                        },
                        excludeValidators: ["readOnly"]
                    })({jQueryEvent: e})
                },
                _focusOutHandler: function(e) {
                    var that = this;
                    that._createActionByOption("onFocusOut", {
                        beforeExecute: function() {
                            that._updateFocusState(e, false)
                        },
                        excludeValidators: ["readOnly"]
                    })({jQueryEvent: e})
                },
                _updateFocusState: function(e, isFocused) {
                    var target = e.target;
                    if ($.inArray(target, this._focusTarget()) !== -1)
                        this._toggleFocusClass(isFocused, target)
                },
                _toggleFocusClass: function(isFocused, element) {
                    var $focusTarget = $(element || this._focusTarget());
                    $focusTarget.toggleClass(FOCUSED_STATE_CLASS, isFocused)
                },
                _hasFocusClass: function(element) {
                    var $focusTarget = $(element || this._focusTarget());
                    return $focusTarget.hasClass(FOCUSED_STATE_CLASS)
                },
                _attachKeyboardEvents: function() {
                    var processor = this.option("_keyboardProcessor") || new KeyboardProcessor({
                            element: this._keyboardEventBindingTarget(),
                            focusTarget: this._focusTarget()
                        });
                    this._keyboardProcessor = processor.reinitialize(this._keyboardHandler, this)
                },
                _keyboardHandler: function(options) {
                    var e = options.originalEvent,
                        key = options.key;
                    var keys = this._supportedKeys(),
                        func = keys[key];
                    if (func !== undefined) {
                        var handler = $.proxy(func, this);
                        return handler(e) || false
                    }
                    else
                        return true
                },
                _refreshFocusState: function() {
                    this._cleanFocusState();
                    this._renderFocusState()
                },
                _cleanFocusState: function() {
                    var $element = this._focusTarget();
                    this._detachFocusEvents();
                    this._toggleFocusClass(false);
                    $element.removeAttr("tabindex");
                    if (this._keyboardProcessor)
                        this._keyboardProcessor.dispose()
                },
                _attachHoverEvents: function() {
                    var that = this,
                        hoverableSelector = that._activeStateUnit,
                        nameStart = eventUtils.addNamespace(hoverEvents.start, UI_FEEDBACK),
                        nameEnd = eventUtils.addNamespace(hoverEvents.end, UI_FEEDBACK);
                    that._eventBindingTarget().off(nameStart, hoverableSelector).off(nameEnd, hoverableSelector);
                    if (that.option("hoverStateEnabled")) {
                        var startAction = new Action(function(args) {
                                that._hoverStartHandler(args.event);
                                var $target = args.element;
                                that._refreshHoveredElement($target)
                            });
                        that._eventBindingTarget().on(nameStart, hoverableSelector, function(e) {
                            startAction.execute({
                                element: $(e.target),
                                event: e
                            })
                        }).on(nameEnd, hoverableSelector, function(e) {
                            that._hoverEndHandler(e);
                            that._forgetHoveredElement()
                        })
                    }
                    else
                        that._toggleHoverClass(false)
                },
                _hoverStartHandler: $.noop,
                _hoverEndHandler: $.noop,
                _attachFeedbackEvents: function() {
                    var that = this,
                        feedbackSelector = that._activeStateUnit,
                        activeEventName = eventUtils.addNamespace(feedbackEvents.active, UI_FEEDBACK),
                        inactiveEventName = eventUtils.addNamespace(feedbackEvents.inactive, UI_FEEDBACK),
                        feedbackAction,
                        feedbackActionDisabled;
                    that._eventBindingTarget().off(activeEventName, feedbackSelector).off(inactiveEventName, feedbackSelector);
                    if (that.option("activeStateEnabled")) {
                        var feedbackActionHandler = function(args) {
                                var $element = args.element,
                                    value = args.value,
                                    jQueryEvent = args.jQueryEvent;
                                that._toggleActiveState($element, value, jQueryEvent)
                            };
                        that._eventBindingTarget().on(activeEventName, feedbackSelector, {timeout: that._feedbackShowTimeout}, function(e) {
                            feedbackAction = feedbackAction || new Action(feedbackActionHandler),
                            feedbackAction.execute({
                                element: $(e.currentTarget),
                                value: true,
                                jQueryEvent: e
                            })
                        }).on(inactiveEventName, feedbackSelector, {timeout: that._feedbackHideTimeout}, function(e) {
                            feedbackActionDisabled = feedbackActionDisabled || new Action(feedbackActionHandler, {excludeValidators: ["disabled", "readOnly"]}),
                            feedbackActionDisabled.execute({
                                element: $(e.currentTarget),
                                value: false,
                                jQueryEvent: e
                            })
                        })
                    }
                },
                _toggleActiveState: function($element, value) {
                    this._toggleHoverClass(!value);
                    $element.toggleClass(ACTIVE_STATE_CLASS, value)
                },
                _refreshHoveredElement: function(hoveredElement) {
                    var selector = this._activeStateUnit || this._eventBindingTarget();
                    this._forgetHoveredElement();
                    this._hoveredElement = hoveredElement.closest(selector);
                    this._toggleHoverClass(true)
                },
                _forgetHoveredElement: function() {
                    this._toggleHoverClass(false);
                    delete this._hoveredElement
                },
                _toggleHoverClass: function(value) {
                    if (this._hoveredElement)
                        this._hoveredElement.toggleClass(HOVER_STATE_CLASS, value && this.option("hoverStateEnabled"))
                },
                _toggleDisabledState: function(value) {
                    this.element().toggleClass(DISABLED_STATE_CLASS, Boolean(value));
                    this._toggleHoverClass(!value);
                    this.setAria("disabled", value || undefined)
                },
                _setWidgetOption: function(widgetName, args) {
                    if (!this[widgetName])
                        return;
                    if ($.isPlainObject(args[0])) {
                        $.each(args[0], $.proxy(function(option, value) {
                            this._setWidgetOption(widgetName, [option, value])
                        }, this));
                        return
                    }
                    var optionName = args[0];
                    var value = args[1];
                    if (args.length === 1)
                        value = this.option(optionName);
                    var widgetOptionMap = this[widgetName + "OptionMap"];
                    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value)
                },
                _createComponent: function(element, name, config) {
                    config = config || {};
                    this._extendConfig(config, {
                        templateProvider: this.option("templateProvider"),
                        _templates: this.option("_templates")
                    });
                    return this.callBase(element, name, config)
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"disabled":
                            this._toggleDisabledState(args.value);
                            this._refreshFocusState();
                            break;
                        case"hint":
                            this._renderHint();
                            break;
                        case"activeStateEnabled":
                            this._attachFeedbackEvents();
                            break;
                        case"hoverStateEnabled":
                            this._attachHoverEvents();
                            break;
                        case"tabIndex":
                        case"_keyboardProcessor":
                        case"focusStateEnabled":
                            this._refreshFocusState();
                            break;
                        case"onFocusIn":
                        case"onFocusOut":
                            break;
                        case"accessKey":
                            this._renderAccessKey();
                            break;
                        case"visible":
                            var visible = args.value;
                            this._toggleVisibility(visible);
                            if (this._isVisibilityChangeSupported())
                                this._checkVisibilityChanged(args.value ? "shown" : "hiding");
                            break;
                        case"onContentReady":
                            this._initContentReadyAction();
                            break;
                        case"_templates":
                        case"templateProvider":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _isVisible: function() {
                    return this.callBase() && this.option("visible")
                },
                beginUpdate: function() {
                    this._ready(false);
                    this.callBase()
                },
                endUpdate: function() {
                    this.callBase();
                    if (this._initialized)
                        this._ready(true)
                },
                _ready: function(value) {
                    if (arguments.length === 0)
                        return this._isReady;
                    this._isReady = value
                },
                setAria: function() {
                    var setAttribute = function(option) {
                            var attrName = $.inArray(option.name, ["role", "id"]) + 1 ? option.name : "aria-" + option.name,
                                attrValue = option.value;
                            if (attrValue === null || attrValue === undefined)
                                attrValue = undefined;
                            else
                                attrValue = attrValue.toString();
                            domUtils.toggleAttr(option.target, attrName, attrValue)
                        };
                    if (!$.isPlainObject(arguments[0]))
                        setAttribute({
                            name: arguments[0],
                            value: arguments[1],
                            target: arguments[2] || this._getAriaTarget()
                        });
                    else {
                        var $target = arguments[1] || this._getAriaTarget();
                        $.each(arguments[0], function(key, value) {
                            setAttribute({
                                name: key,
                                value: value,
                                target: $target
                            })
                        })
                    }
                },
                isReady: function() {
                    return this._ready()
                },
                repaint: function() {
                    this._refresh()
                },
                focus: function() {
                    this._focusTarget().focus()
                },
                registerKeyHandler: function(key, handler) {
                    var currentKeys = this._supportedKeys(),
                        addingKeys = {};
                    addingKeys[key] = handler;
                    this._supportedKeys = function() {
                        return $.extend(currentKeys, addingKeys)
                    }
                }
            });
        return Widget
    });
    /*! Module core, file ui.validationMixin.js */
    DevExpress.define("/ui/ui.validationMixin", ["jquery"], function($) {
        var ValidationMixin = {_findGroup: function() {
                    var group = this.option("validationGroup"),
                        $dxGroup;
                    if (!group) {
                        $dxGroup = this.element().parents(".dx-validationgroup:first");
                        if ($dxGroup.length)
                            group = $dxGroup.dxValidationGroup("instance");
                        else
                            group = this._modelByElement(this.element())
                    }
                    return group
                }};
        return ValidationMixin
    });
    /*! Module core, file ui.editor.js */
    DevExpress.define("/ui/ui.editor", ["jquery", "/ui/uiNamespace", "/utils/utils.common", "/ui/ui.themes", "/ui/ui.widget", "/ui/ui.validationMixin"], function($, uiNamespace, commonUtils, themes, Widget, ValidationMixin) {
        var READONLY_STATE_CLASS = "dx-state-readonly",
            INVALID_CLASS = "dx-invalid",
            INVALID_MESSAGE = "dx-invalid-message",
            INVALID_MESSAGE_AUTO = "dx-invalid-message-auto",
            INVALID_MESSAGE_ALWAYS = "dx-invalid-message-always";
        var Editor = Widget.inherit({
                _init: function() {
                    this.callBase();
                    this.validationRequest = $.Callbacks();
                    var $element = this.element();
                    if ($element) {
                        $element.data("dx-validation-target", this);
                        this.on("disposing", function() {
                            $element.data("dx-validation-target", null)
                        })
                    }
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            value: null,
                            onValueChanged: null,
                            readOnly: false,
                            isValid: true,
                            validationError: null,
                            validationMessageMode: "auto",
                            validationTooltipOffset: {
                                h: 0,
                                v: -10
                            }
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function() {
                                    var currentTheme = (themes.current() || "").split(".")[0];
                                    return currentTheme === "android5"
                                },
                                options: {validationTooltipOffset: {v: -18}}
                            }, {
                                device: function() {
                                    var currentTheme = (themes.current() || "").split(".")[0];
                                    return currentTheme === "win10"
                                },
                                options: {validationTooltipOffset: {v: -4}}
                            }])
                },
                _attachKeyboardEvents: function() {
                    if (this.option("readOnly"))
                        return;
                    this.callBase.apply(this, arguments);
                    this._attachChildKeyboardEvents()
                },
                _attachChildKeyboardEvents: $.noop,
                _setOptionsByReference: function() {
                    this.callBase();
                    $.extend(this._optionsByReference, {validationError: true})
                },
                _createValueChangeAction: function() {
                    this._valueChangeAction = this._createActionByOption("onValueChanged", {excludeValidators: ["disabled", "readOnly"]})
                },
                _suppressValueChangeAction: function() {
                    this._valueChangeActionSuppressed = true
                },
                _resumeValueChangeAction: function() {
                    this._valueChangeActionSuppressed = false
                },
                _render: function() {
                    this._renderValidationState();
                    this._toggleReadOnlyState();
                    this.callBase()
                },
                _raiseValueChangeAction: function(value, previousValue, extraArguments) {
                    if (!this._valueChangeAction)
                        this._createValueChangeAction();
                    this._valueChangeAction(this._valueChangeArgs(value, previousValue))
                },
                _valueChangeArgs: function(value, previousValue) {
                    return {
                            value: value,
                            previousValue: previousValue,
                            jQueryEvent: this._valueChangeEventInstance
                        }
                },
                _saveValueChangeEvent: function(e) {
                    this._valueChangeEventInstance = e
                },
                _renderValidationState: function() {
                    var isValid = this.option("isValid"),
                        validationError = this.option("validationError"),
                        validationMessageMode = this.option("validationMessageMode"),
                        $element = this.element();
                    $element.toggleClass(INVALID_CLASS, !isValid);
                    this.setAria("invalid", !isValid || undefined);
                    if (this._$validationMessage) {
                        this._$validationMessage.remove();
                        this._$validationMessage = null
                    }
                    if (!isValid && validationError && validationError.message) {
                        this._$validationMessage = $("<div/>", {"class": INVALID_MESSAGE}).text(validationError.message).appendTo($element);
                        this._createComponent(this._$validationMessage, "dxTooltip", {
                            target: this._getValidationTooltipTarget(),
                            container: $element,
                            position: this._getValidationTooltipPosition("below"),
                            closeOnOutsideClick: false,
                            closeOnTargetScroll: false,
                            animation: null,
                            visible: true
                        });
                        this._$validationMessage.toggleClass(INVALID_MESSAGE_AUTO, validationMessageMode === "auto").toggleClass(INVALID_MESSAGE_ALWAYS, validationMessageMode === "always")
                    }
                },
                _getValidationTooltipTarget: function() {
                    return this.element()
                },
                _getValidationTooltipPosition: function(positionRequest) {
                    var rtlEnabled = this.option("rtlEnabled"),
                        tooltipPositionSide = commonUtils.getDefaultAlignment(rtlEnabled),
                        tooltipOriginalOffset = this.option("validationTooltipOffset"),
                        tooltipOffset = {
                            h: tooltipOriginalOffset.h,
                            v: tooltipOriginalOffset.v
                        },
                        verticalPositions = positionRequest === "below" ? [" top", " bottom"] : [" bottom", " top"];
                    if (rtlEnabled)
                        tooltipOffset.h = -tooltipOffset.h;
                    if (positionRequest !== "below")
                        tooltipOffset.v = -tooltipOffset.v;
                    return {
                            offset: tooltipOffset,
                            my: tooltipPositionSide + verticalPositions[0],
                            at: tooltipPositionSide + verticalPositions[1],
                            collision: "none"
                        }
                },
                _toggleReadOnlyState: function() {
                    this.element().toggleClass(READONLY_STATE_CLASS, this.option("readOnly"));
                    this.setAria("readonly", this.option("readOnly") || undefined)
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"onValueChanged":
                            this._createValueChangeAction();
                            break;
                        case"isValid":
                        case"validationError":
                        case"validationMessageMode":
                            this._renderValidationState();
                            break;
                        case"readOnly":
                            this._toggleReadOnlyState();
                            this._refreshFocusState();
                            break;
                        case"value":
                            if (!this._valueChangeActionSuppressed) {
                                this._raiseValueChangeAction(args.value, args.previousValue);
                                this._saveValueChangeEvent(undefined)
                            }
                            if (args.value != args.previousValue)
                                this.validationRequest.fire({
                                    value: args.value,
                                    editor: this
                                });
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                reset: function() {
                    this.option("value", null)
                }
            }).include(ValidationMixin);
        return Editor
    });
    /*! Module core, file ui.errors.js */
    DevExpress.define("/ui/ui.errors", ["/utils/utils.error", "/errors"], function(errorUtils, errors) {
        return errorUtils(errors.ERROR_MESSAGES, {
                E1001: "Module '{0}'. Controller '{1}' is already registered",
                E1002: "Module '{0}'. Controller '{1}' must be inheritor of DevExpress.ui.dxDataGrid.Controller",
                E1003: "Module '{0}'. View '{1}' is already registered",
                E1004: "Module '{0}'. View '{1}' must be inheritor of DevExpress.ui.dxDataGrid.View",
                E1005: "Public method '{0}' is already registered",
                E1006: "Public method '{0}.{1}' is not exists",
                E1007: "State storing can not be provided due to the restrictions of your browser",
                E1010: "A template should contain dxTextBox widget",
                E1011: "You have to implement 'remove' method in dataStore used by dxList to be able to delete items",
                E1012: "Editing type '{0}' with name '{1}' not supported",
                E1016: "Unexpected type of data source is provided for a lookup column",
                E1018: "The 'collapseAll' method cannot be called when using a remote data source",
                E1019: "Search mode '{0}' is unavailable",
                E1020: "Type can not be changed after initialization",
                E1021: "{0} '{1}' you are trying to remove does not exist",
                E1022: "Markers option should be an array",
                E1023: "Routes option should be an array",
                E1024: "Google provider cannot be used in WinJS application",
                E1025: "This layout is too complex to render",
                E1026: "The 'custom' value is set to a summary item's summaryType option, but a function for calculating the custom summary is not assigned to the grid's calculateCustomSummary option",
                E1030: "Unknown dxScrollView refresh strategy: '{0}'",
                E1031: "Unknown subscription is detected in the dxScheduler widget: '{0}'",
                E1032: "Unknown start date is detected in an appointment of the dxScheduler widget: '{0}'",
                E1033: "Unknown step is specified for the scheduler's navigator: '{0}'",
                E1034: "The current browser does not implement an API required for saving files",
                E1035: "The editor could not be created because of the internal error: {0}",
                E1036: "Validation rules are not defined for any form item",
                W1001: "Key option can not be modified after initialization",
                W1002: "Item '{0}' you are trying to select does not exist",
                W1003: "Group with key '{0}' in which you are trying to select items does not exist",
                W1004: "Item '{0}' you are trying to select in group '{1}' does not exist",
                W1005: "Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns."
            })
    });
    /*! Module core, file ui.actionExecutors.js */
    DevExpress.define("/ui/ui.actionExecutors", ["jquery", "/action"], function($, Action) {
        var createValidatorByTargetElement = function(condition) {
                return function(e) {
                        if (!e.args.length)
                            return;
                        var args = e.args[0],
                            element = args[e.validatingTargetName] || args.element;
                        if (element && condition(element))
                            e.cancel = true
                    }
            };
        Action.registerExecutor({
            designMode: {validate: function(e) {
                    if (DevExpress.designMode)
                        e.cancel = true
                }},
            disabled: {validate: createValidatorByTargetElement(function($target) {
                    return $target.is(".dx-state-disabled, .dx-state-disabled *")
                })},
            readOnly: {validate: createValidatorByTargetElement(function($target) {
                    return $target.is(".dx-state-readonly, .dx-state-readonly *")
                })}
        })
    });
    /*! Module core, file ui.dialog.js */
    DevExpress.define("/ui/ui.dialog", ["jquery", "/component", "/action", "/ui/ui.errors", "/utils/utils.dom", "/utils/utils.viewPort", "/devices", "/ui/ui.themes"], function($, Component, Action, errors, domUtils, viewPortUtils, devices, themes) {
        var DEFAULT_BUTTON = {
                text: "OK",
                onClick: function() {
                    return true
                }
            };
        var DX_DIALOG_CLASSNAME = "dx-dialog",
            DX_DIALOG_WRAPPER_CLASSNAME = DX_DIALOG_CLASSNAME + "-wrapper",
            DX_DIALOG_ROOT_CLASSNAME = DX_DIALOG_CLASSNAME + "-root",
            DX_DIALOG_CONTENT_CLASSNAME = DX_DIALOG_CLASSNAME + "-content",
            DX_DIALOG_MESSAGE_CLASSNAME = DX_DIALOG_CLASSNAME + "-message",
            DX_DIALOG_BUTTONS_CLASSNAME = DX_DIALOG_CLASSNAME + "-buttons",
            DX_DIALOG_BUTTON_CLASSNAME = DX_DIALOG_CLASSNAME + "-button";
        var FakeDialogComponent = Component.inherit({
                ctor: function(element, options) {
                    this.callBase(options)
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: {platform: "ios"},
                                options: {width: 276}
                            }, {
                                device: {platform: "android"},
                                options: {
                                    lWidth: "60%",
                                    pWidth: "80%"
                                }
                            }, {
                                device: function(device) {
                                    var currentTheme = (themes.current() || "").split(".")[0];
                                    return !device.phone && currentTheme === "win8"
                                },
                                options: {width: function() {
                                        return $(window).width()
                                    }}
                            }, {
                                device: function(device) {
                                    var currentTheme = (themes.current() || "").split(".")[0];
                                    return device.phone && currentTheme === "win8"
                                },
                                options: {position: {
                                        my: "top center",
                                        at: "top center",
                                        of: window,
                                        offset: "0 0"
                                    }}
                            }])
                }
            });
        var dialog = function(options) {
                if (!DevExpress.ui.dxPopup)
                    throw errors.Error("E0018");
                var deferred = $.Deferred();
                var defaultOptions = (new FakeDialogComponent).option();
                options = $.extend(defaultOptions, options);
                var $element = $("<div>").addClass(DX_DIALOG_CLASSNAME).appendTo(viewPortUtils.value());
                var $message = $("<div>").addClass(DX_DIALOG_MESSAGE_CLASSNAME).html(String(options.message));
                var popupButtons = [];
                $.each(options.buttons || [DEFAULT_BUTTON], function() {
                    var action = new Action(this.onClick, {context: popupInstance});
                    popupButtons.push({
                        toolbar: 'bottom',
                        location: devices.current().android ? 'after' : 'center',
                        widget: 'button',
                        options: {
                            text: this.text,
                            onClick: function() {
                                var result = action.execute(arguments);
                                hide(result)
                            }
                        }
                    })
                });
                var popupInstance = $element.dxPopup({
                        title: options.title || this.title,
                        showTitle: function() {
                            var isTitle = options.showTitle === undefined ? true : options.showTitle;
                            return isTitle
                        }(),
                        height: "auto",
                        width: function() {
                            var isPortrait = $(window).height() > $(window).width(),
                                key = (isPortrait ? "p" : "l") + "Width",
                                widthOption = options.hasOwnProperty(key) ? options[key] : options["width"];
                            return $.isFunction(widthOption) ? widthOption() : widthOption
                        },
                        showCloseButton: options.showCloseButton || false,
                        focusStateEnabled: false,
                        onContentReady: function(args) {
                            args.component.content().addClass(DX_DIALOG_CONTENT_CLASSNAME).append($message)
                        },
                        onShowing: function(e) {
                            e.component.bottomToolbar().addClass(DX_DIALOG_BUTTONS_CLASSNAME).find(".dx-button").addClass(DX_DIALOG_BUTTON_CLASSNAME);
                            domUtils.resetActiveElement()
                        },
                        onShown: function(e) {
                            e.component.bottomToolbar().find(".dx-button").first().focus()
                        },
                        onHiding: function() {
                            deferred.reject()
                        },
                        buttons: popupButtons,
                        animation: {
                            show: {
                                type: "pop",
                                duration: 400
                            },
                            hide: {
                                type: "pop",
                                duration: 400,
                                to: {
                                    opacity: 0,
                                    scale: 0
                                },
                                from: {
                                    opacity: 1,
                                    scale: 1
                                }
                            }
                        },
                        rtlEnabled: DevExpress.rtlEnabled,
                        boundaryOffset: {
                            h: 10,
                            v: 0
                        }
                    }).dxPopup("instance");
                popupInstance._wrapper().addClass(DX_DIALOG_WRAPPER_CLASSNAME);
                if (options.position)
                    popupInstance.option("position", options.position);
                popupInstance._wrapper().addClass(DX_DIALOG_ROOT_CLASSNAME);
                function show() {
                    popupInstance.show();
                    return deferred.promise()
                }
                function hide(value) {
                    deferred.resolve(value);
                    popupInstance.hide().done(function() {
                        popupInstance.element().remove()
                    })
                }
                return {
                        show: show,
                        hide: hide
                    }
            };
        var alert = function(message, title, showTitle) {
                var dialogInstance,
                    options = $.isPlainObject(message) ? message : {
                        title: title,
                        message: message,
                        showTitle: showTitle
                    };
                dialogInstance = this.custom(options);
                return dialogInstance.show()
            };
        var confirm = function(message, title, showTitle) {
                var dialogInstance,
                    options = $.isPlainObject(message) ? message : {
                        title: title,
                        message: message,
                        showTitle: showTitle,
                        buttons: [{
                                text: Globalize.localize("Yes"),
                                onClick: function() {
                                    return true
                                }
                            }, {
                                text: Globalize.localize("No"),
                                onClick: function() {
                                    return false
                                }
                            }]
                    };
                dialogInstance = this.custom(options);
                return dialogInstance.show()
            };
        var $notify = null;
        var notify = function(message, type, displayTime) {
                var options = $.isPlainObject(message) ? message : {message: message};
                if (!DevExpress.ui.dxToast) {
                    alert(options.message);
                    return
                }
                var userHiddenAction = options.onHidden;
                $.extend(options, {
                    type: type,
                    displayTime: displayTime,
                    onHidden: function(args) {
                        args.element.remove();
                        new Action(userHiddenAction, {context: args.model}).execute(arguments)
                    }
                });
                $notify = $("<div>").appendTo(viewPortUtils.value()).dxToast(options);
                $notify.dxToast("instance").show()
            };
        return {
                FakeDialogComponent: FakeDialogComponent,
                notify: notify,
                custom: dialog,
                alert: alert,
                confirm: confirm
            }
    });
    /*! Module core, file ui.templateBase.js */
    DevExpress.define("/ui/templates/ui.templateBase", ["jquery", "/utils/utils.dom", "/class"], function($, domUtils, Class) {
        var triggerShownEvent = domUtils.triggerShownEvent,
            abstract = Class.abstract;
        var renderedCallbacks = $.Callbacks();
        var TemplateBase = Class.inherit({
                ctor: function(element, owner) {
                    this._element = $(element);
                    this._owner = owner
                },
                owner: function() {
                    return this._owner
                },
                render: function(data, $container, index) {
                    if (data instanceof jQuery) {
                        $container = data;
                        data = undefined
                    }
                    if ($container)
                        data = this._prepareDataForContainer(data, $container);
                    var $result = this._renderCore(data, index, $container);
                    renderedCallbacks.fire($result);
                    this._ensureResultInContainer($result, $container);
                    return $result
                },
                _ensureResultInContainer: function($result, $container) {
                    if (!$container)
                        return;
                    var resultInContainer = $.contains($container.get(0), $result.get(0));
                    $container.append($result);
                    if (resultInContainer)
                        return;
                    var resultInBody = $.contains(document.body, $container.get(0));
                    if (!resultInBody)
                        return;
                    triggerShownEvent($result)
                },
                source: function() {
                    return this._element.clone()
                },
                _prepareDataForContainer: function(data) {
                    return data
                },
                _renderCore: abstract,
                dispose: function() {
                    this._owner = null
                }
            });
        TemplateBase.renderedCallbacks = renderedCallbacks;
        return TemplateBase
    });
    /*! Module core, file ui.template.function.js */
    DevExpress.define("/ui/templates/ui.template.function", ["jquery", "/ui/templates/ui.templateBase", "/utils/utils.dom"], function($, TemplateBase, domUtils) {
        var FunctionTemplate = TemplateBase.inherit({
                ctor: function(render, owner) {
                    this.callBase($(), owner);
                    this._render = render
                },
                _renderCore: function(data, index, container) {
                    return domUtils.normalizeTemplateElement(this._render(data, index, container))
                }
            });
        return FunctionTemplate
    });
    /*! Module core, file ui.template.dynamic.js */
    DevExpress.define("/ui/templates/ui.template.dynamic", ["jquery", "/ui/templates/ui.templateBase"], function($, TemplateBase) {
        var DynamicTemplate = TemplateBase.inherit({
                ctor: function(compileFunction, owner) {
                    this.callBase($(), owner);
                    this._compileFunction = compileFunction
                },
                _renderCore: function(data, index, container) {
                    if (data === undefined && index === undefined) {
                        data = container;
                        container = undefined
                    }
                    var compiledTemplate = index === undefined ? this._compileFunction(data, container) : this._compileFunction(data, index, container);
                    var renderResult = compiledTemplate.render(data, container, index);
                    if (compiledTemplate.owner() === this)
                        compiledTemplate.dispose();
                    return renderResult
                }
            });
        return DynamicTemplate
    });
    /*! Module core, file ui.template.empty.js */
    DevExpress.define("/ui/templates/ui.template.empty", ["jquery", "/ui/templates/ui.templateBase"], function($, TemplateBase) {
        var EmptyTemplate = TemplateBase.inherit({
                ctor: function(owner) {
                    this.callBase($(), owner)
                },
                _renderCore: function() {
                    return $()
                }
            });
        return EmptyTemplate
    });
    /*! Module core, file ui.template.move.js */
    DevExpress.define("/ui/templates/ui.template.move", ["jquery", "/ui/templates/ui.templateBase"], function($, TemplateBase) {
        var MoveTemplate = TemplateBase.inherit({_renderCore: function() {
                    return this._element
                }});
        return MoveTemplate
    });
    /*! Module core, file ui.templateProviderBase.js */
    DevExpress.define("/ui/templates/ui.templateProviderBase", ["jquery", "/class"], function($, Class) {
        var abstract = Class.abstract;
        var TemplateProviderBase = Class.inherit({
                ctor: function() {
                    this.widgetTemplatesCache = {}
                },
                createTemplate: abstract,
                getTemplates: function(widget) {
                    return this._getWidgetTemplates(widget.constructor)
                },
                _getWidgetTemplates: function(widgetConstructor) {
                    if (!widgetConstructor.publicName)
                        return {};
                    return this._getCachedWidgetTemplates(widgetConstructor)
                },
                _getCachedWidgetTemplates: function(widgetConstructor) {
                    var widgetName = widgetConstructor.publicName(),
                        templatesCache = this.widgetTemplatesCache;
                    if (!templatesCache[widgetName])
                        templatesCache[widgetName] = $.extend({}, this._getWidgetTemplates(widgetConstructor.parent), this._templatesForWidget(widgetName));
                    return templatesCache[widgetName]
                },
                _templatesForWidget: abstract
            });
        return TemplateProviderBase
    });
    /*! Module core, file ui.events.eventRegistrator.js */
    DevExpress.define("/ui/events/ui.events.eventRegistrator", ["jquery", "/utils/utils.memorizedCallbacks"], function($, MemorizedCallbacks) {
        var eventNS = $.event,
            hooksNS = eventNS.fixHooks,
            specialNS = $.event.special;
        var DX_EVENT_HOOKS = {props: eventNS.mouseHooks.props.concat(["pointerType", "pointerId", "pointers"])};
        var callbacks = new MemorizedCallbacks;
        var registerEvent = function(name, eventObject) {
                var strategy = {};
                if ("noBubble" in eventObject)
                    strategy.noBubble = eventObject.noBubble;
                if ("bindType" in eventObject)
                    strategy.bindType = eventObject.bindType;
                if ("delegateType" in eventObject)
                    strategy.delegateType = eventObject.delegateType;
                $.each(["setup", "teardown", "add", "remove", "trigger", "handle", "_default", "dispose"], function(_, methodName) {
                    if (!eventObject[methodName])
                        return;
                    strategy[methodName] = function() {
                        var args = $.makeArray(arguments);
                        args.unshift(this);
                        return eventObject[methodName].apply(eventObject, args)
                    }
                });
                hooksNS[name] = DX_EVENT_HOOKS;
                callbacks.fire(name, strategy)
            };
        registerEvent.callbacks = callbacks;
        var registerJQueryEvent = function(name, eventObject) {
                specialNS[name] = eventObject
            };
        callbacks.add(registerJQueryEvent);
        return registerEvent
    });
    /*! Module core, file ui.events.utils.js */
    DevExpress.define("/ui/events/ui.events.utils", ["jquery", "/ui/ui.errors"], function($, errors) {
        var eventNS = $.event,
            hooksNS = eventNS.fixHooks;
        var eventSource = function() {
                var EVENT_SOURCES_REGEX = {
                        dx: /^dx/i,
                        mouse: /(mouse|wheel)/i,
                        touch: /^touch/i,
                        keyboard: /^key/i,
                        pointer: /^(ms)?pointer/i
                    };
                return function(e) {
                        var result = "other";
                        $.each(EVENT_SOURCES_REGEX, function(key) {
                            if (this.test(e.type)) {
                                result = key;
                                return false
                            }
                        });
                        return result
                    }
            }();
        var isDxEvent = function(e) {
                return eventSource(e) === "dx"
            };
        var isNativeMouseEvent = function(e) {
                return eventSource(e) === "mouse"
            };
        var isNativeTouchEvent = function(e) {
                return eventSource(e) === "touch"
            };
        var isPointerEvent = function(e) {
                return eventSource(e) === "pointer"
            };
        var isMouseEvent = function(e) {
                return isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && e.pointerType === "mouse"
            };
        var isTouchEvent = function(e) {
                return isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && e.pointerType === "touch"
            };
        var isKeyboardEvent = function(e) {
                return eventSource(e) === "keyboard"
            };
        var isFakeClickEvent = function(e) {
                return e.screenX === 0 && !e.offsetX && e.pageX === 0
            };
        var eventData = function(e) {
                return {
                        x: e.pageX,
                        y: e.pageY,
                        time: e.timeStamp
                    }
            };
        var eventDelta = function(from, to) {
                return {
                        x: to.x - from.x,
                        y: to.y - from.y,
                        time: to.time - from.time || 1
                    }
            };
        var hasTouches = function(e) {
                if (isNativeTouchEvent(e))
                    return (e.originalEvent.touches || []).length;
                if (isDxEvent(e))
                    return (e.pointers || []).length;
                return 0
            };
        var needSkipEvent = function(e) {
                var $target = $(e.target),
                    touchInInput = $target.is("input, textarea, select");
                if ($target.is(".dx-skip-gesture-event *, .dx-skip-gesture-event"))
                    return true;
                if (e.type === 'dxmousewheel')
                    return $target.is("input[type='number'], textarea, select") && $target.is(':focus');
                if (isMouseEvent(e))
                    return touchInInput || e.which > 1;
                if (isTouchEvent(e))
                    return touchInInput && $target.is(":focus")
            };
        var createEvent = function(originalEvent, args) {
                var event = $.Event(originalEvent),
                    fixHook = hooksNS[originalEvent.type] || eventNS.mouseHooks;
                var props = fixHook.props ? eventNS.props.concat(fixHook.props) : eventNS.props,
                    propIndex = props.length;
                while (propIndex--) {
                    var prop = props[propIndex];
                    event[prop] = originalEvent[prop]
                }
                if (args)
                    $.extend(event, args);
                return fixHook.filter ? fixHook.filter(event, originalEvent) : event
            };
        var fireEvent = function(props) {
                var event = createEvent(props.originalEvent, props);
                eventNS.trigger(event, null, props.delegateTarget || event.target);
                return event
            };
        var addNamespace = function(eventNames, namespace) {
                if (!namespace)
                    throw errors.Error("E0017");
                if (typeof eventNames === "string")
                    return addNamespace(eventNames.split(/\s+/g), namespace);
                $.each(eventNames, function(index, eventName) {
                    eventNames[index] = eventName + "." + namespace
                });
                return eventNames.join(" ")
            };
        return {
                eventSource: eventSource,
                isPointerEvent: isPointerEvent,
                isMouseEvent: isMouseEvent,
                isTouchEvent: isTouchEvent,
                isKeyboardEvent: isKeyboardEvent,
                isFakeClickEvent: isFakeClickEvent,
                hasTouches: hasTouches,
                eventData: eventData,
                eventDelta: eventDelta,
                needSkipEvent: needSkipEvent,
                createEvent: createEvent,
                fireEvent: fireEvent,
                addNamespace: addNamespace
            }
    });
    /*! Module core, file ui.events.remove.js */
    DevExpress.define("/ui/events/ui.events.remove", ["jquery", "/ui/events/ui.events.eventRegistrator"], function($, registerEvent) {
        var eventName = "dxremove",
            eventPropName = "dxRemoveEvent",
            cleanData = $.cleanData;
        $.cleanData = function(elements) {
            for (var i = 0; i < elements.length; i++) {
                var $element = $(elements[i]);
                if ($element.prop(eventPropName)) {
                    $element.removeProp(eventPropName);
                    $element.triggerHandler(eventName)
                }
            }
            return cleanData(elements)
        };
        registerEvent(eventName, {
            noBubble: true,
            setup: function(element) {
                $(element).prop(eventPropName, true)
            }
        });
        return {name: eventName}
    });
    /*! Module core, file ui.events.pointer.touchHooks.js */
    DevExpress.define("/ui/events/pointer/ui.events.pointer.touchHooks", ["jquery"], function($) {
        var touchEventHook = {
                filter: function(event, originalEvent) {
                    var touches = originalEvent.touches.length ? originalEvent.touches : originalEvent.changedTouches;
                    $.each(["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"], function() {
                        event[this] = touches[0][this]
                    });
                    return event
                },
                props: $.event.mouseHooks.props.concat(["touches", "changedTouches", "targetTouches", "detail", "result", "originalTarget", "charCode", "prevValue"])
            };
        $.each(["touchstart", "touchmove", "touchend", "touchcancel"], function() {
            $.event.fixHooks[this] = touchEventHook
        })
    });
    /*! Module core, file ui.events.pointer.mspointerHooks.js */
    DevExpress.define("/ui/events/pointer/ui.events.pointer.mspointerHooks", ["jquery"], function($) {
        var POINTER_TYPE_MAP = {
                2: "touch",
                3: "pen",
                4: "mouse"
            };
        var pointerEventHook = {
                filter: function(event, originalEvent) {
                    var pointerType = originalEvent.pointerType;
                    if ($.isNumeric(pointerType))
                        event.pointerType = POINTER_TYPE_MAP[pointerType];
                    return event
                },
                props: $.event.mouseHooks.props.concat(["pointerId", "pointerType", "originalTarget", "width", "height", "pressure", "result", "tiltX", "charCode", "tiltY", "detail", "isPrimary", "prevValue"])
            };
        $.each(["MSPointerDown", "MSPointerMove", "MSPointerUp", "MSPointerCancel", "MSPointerOver", "MSPointerOut", "mouseenter", "mouseleave", "pointerdown", "pointermove", "pointerup", "pointercancel", "pointerover", "pointerout", "pointerenter", "pointerleave"], function() {
            $.event.fixHooks[this] = pointerEventHook
        })
    });
    /*! Module core, file ui.events.pointer.base.js */
    DevExpress.define("/ui/events/pointer/ui.events.pointer.base", ["jquery", "/utils/utils.browser", "/class", "/ui/events/ui.events.utils"], function($, browser, Class, eventUtils) {
        var POINTER_EVENTS_NAMESPACE = "dxPointerEvents";
        var BaseStrategy = Class.inherit({
                ctor: function(eventName, originalEvents) {
                    this._eventName = eventName;
                    this._originalEvents = eventUtils.addNamespace(originalEvents, POINTER_EVENTS_NAMESPACE);
                    this._handlerCount = 0;
                    this.noBubble = this._isNoBubble()
                },
                _isNoBubble: function() {
                    var eventName = this._eventName;
                    return eventName === "dxpointerenter" || eventName === "dxpointerleave"
                },
                _handler: function(e) {
                    var delegateTarget = this._getDelegateTarget(e);
                    return this._fireEvent({
                            type: this._eventName,
                            pointerType: e.pointerType || eventUtils.eventSource(e),
                            originalEvent: e,
                            delegateTarget: delegateTarget,
                            timeStamp: browser.mozilla ? (new Date).getTime() : e.timeStamp
                        })
                },
                _getDelegateTarget: function(e) {
                    var delegateTarget;
                    if (this.noBubble)
                        delegateTarget = e.delegateTarget;
                    return delegateTarget
                },
                _fireEvent: function(args) {
                    return eventUtils.fireEvent(args)
                },
                setup: function() {
                    return true
                },
                add: function(element, handleObj) {
                    if (this._handlerCount <= 0 || this.noBubble) {
                        this._selector = handleObj.selector;
                        element = this.noBubble ? element : document;
                        var that = this;
                        $(element).on(this._originalEvents, this._selector, function(e) {
                            that._handler(e)
                        })
                    }
                    if (!this.noBubble)
                        this._handlerCount++
                },
                remove: function(element) {
                    if (!this.noBubble)
                        this._handlerCount--
                },
                teardown: function(element) {
                    if (this._handlerCount && !this.noBubble)
                        return;
                    element = this.noBubble ? element : document;
                    $(element).off(this._originalEvents, this._selector)
                },
                dispose: function(element) {
                    element = this.noBubble ? element : document;
                    $(element).off(this._originalEvents)
                }
            });
        return BaseStrategy
    });
    /*! Module core, file ui.events.pointer.observer.js */
    DevExpress.define("/ui/events/pointer/ui.events.pointer.observer", [], function() {
        var addEventsListener = function(events, handler) {
                events = events.split(" ");
                $.each(events, function(_, event) {
                    if (document.addEventListener)
                        document.addEventListener(event, handler, true);
                    else
                        document.attachEvent("on" + event, handler)
                })
            };
        var Observer = function(eventMap, pointerEquals) {
                var pointers = [];
                var getPointerIndex = function(e) {
                        var index = -1;
                        $.each(pointers, function(i, pointer) {
                            if (!pointerEquals(e, pointer))
                                return true;
                            index = i;
                            return false
                        });
                        return index
                    };
                var addPointer = function(e) {
                        if (getPointerIndex(e) === -1)
                            pointers.push(e)
                    };
                var removePointer = function(e) {
                        var index = getPointerIndex(e);
                        if (index > -1)
                            pointers.splice(index, 1)
                    };
                var updatePointer = function(e) {
                        pointers[getPointerIndex(e)] = e
                    };
                addEventsListener(eventMap.dxpointerdown, addPointer);
                addEventsListener(eventMap.dxpointermove, updatePointer);
                addEventsListener(eventMap.dxpointerup, removePointer);
                addEventsListener(eventMap.dxpointercancel, removePointer);
                this.pointers = function() {
                    return pointers
                };
                this.reset = function() {
                    pointers = []
                }
            };
        return Observer
    });
    /*! Module core, file ui.events.pointer.mouse.js */
    DevExpress.define("/ui/events/pointer/ui.events.pointer.mouse", ["jquery", "/ui/events/pointer/ui.events.pointer.base", "/ui/events/pointer/ui.events.pointer.observer"], function($, BaseStrategy, Observer) {
        var eventMap = {
                dxpointerdown: "mousedown",
                dxpointermove: "mousemove",
                dxpointerup: "mouseup",
                dxpointercancel: "",
                dxpointerover: "mouseover",
                dxpointerout: "mouseout",
                dxpointerenter: "mouseenter",
                dxpointerleave: "mouseleave"
            };
        var normalizeMouseEvent = function(e) {
                e.pointerId = 1;
                return {
                        pointers: observer.pointers(),
                        pointerId: 1
                    }
            };
        var observer;
        var activated = false;
        var activateStrategy = function() {
                if (activated)
                    return;
                observer = new Observer(eventMap, function(a, b) {
                    return true
                });
                activated = true
            };
        var MouseStrategy = BaseStrategy.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    activateStrategy()
                },
                _fireEvent: function(args) {
                    return this.callBase($.extend(normalizeMouseEvent(args.originalEvent), args))
                }
            });
        MouseStrategy.map = eventMap;
        MouseStrategy.normalize = normalizeMouseEvent;
        MouseStrategy.activate = activateStrategy;
        MouseStrategy.resetObserver = function() {
            observer.reset()
        };
        return MouseStrategy
    });
    /*! Module core, file ui.events.pointer.touch.js */
    DevExpress.define("/ui/events/pointer/ui.events.pointer.touch", ["jquery", "/devices", "/ui/events/pointer/ui.events.pointer.base", "/ui/events/pointer/ui.events.pointer.touchHooks"], function($, devices, BaseStrategy) {
        var eventMap = {
                dxpointerdown: "touchstart",
                dxpointermove: "touchmove",
                dxpointerup: "touchend",
                dxpointercancel: "touchcancel",
                dxpointerover: "",
                dxpointerout: "",
                dxpointerenter: "",
                dxpointerleave: ""
            };
        var normalizeTouchEvent = function(e) {
                var pointers = [];
                $.each(e.touches, function(_, touch) {
                    pointers.push($.extend({pointerId: touch.identifier}, touch))
                });
                return {
                        pointers: pointers,
                        pointerId: e.changedTouches[0].identifier
                    }
            };
        var skipTouchWithSameIdentifier = function(pointerEvent) {
                return devices.real().platform === "ios" && (pointerEvent === "dxpointerdown" || pointerEvent === "dxpointerup")
            };
        var TouchStrategy = BaseStrategy.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    this._pointerId = 0
                },
                _handler: function(e) {
                    if (skipTouchWithSameIdentifier(this._eventName)) {
                        var touch = e.changedTouches[0];
                        if (this._pointerId === touch.identifier && this._pointerId !== 0)
                            return;
                        this._pointerId = touch.identifier
                    }
                    return this.callBase.apply(this, arguments)
                },
                _fireEvent: function(args) {
                    return this.callBase($.extend(normalizeTouchEvent(args.originalEvent), args))
                }
            });
        TouchStrategy.map = eventMap;
        TouchStrategy.normalize = normalizeTouchEvent;
        return TouchStrategy
    });
    /*! Module core, file ui.events.pointer.mouseAndTouch.js */
    DevExpress.define("/ui/events/pointer/ui.events.pointer.mouseAndTouch", ["jquery", "/ui/events/pointer/ui.events.pointer.base", "/ui/events/pointer/ui.events.pointer.mouse", "/ui/events/pointer/ui.events.pointer.touch", "/ui/events/ui.events.utils"], function($, BaseStrategy, MouseStrategy, TouchStrategy, eventUtils) {
        var eventMap = {
                dxpointerdown: "touchstart mousedown",
                dxpointermove: "touchmove mousemove",
                dxpointerup: "touchend mouseup",
                dxpointercancel: "touchcancel",
                dxpointerover: "mouseover",
                dxpointerout: "mouseout",
                dxpointerenter: "mouseenter",
                dxpointerleave: "mouseleave"
            };
        var activated = false;
        var activateStrategy = function() {
                if (activated)
                    return;
                MouseStrategy.activate();
                activated = true
            };
        var MouseAndTouchStrategy = BaseStrategy.inherit({
                EVENT_LOCK_TIMEOUT: 100,
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    activateStrategy()
                },
                _handler: function(e) {
                    var isMouseEvent = eventUtils.isMouseEvent(e);
                    if (!isMouseEvent)
                        this._skipNextEvents = true;
                    if (isMouseEvent && this._mouseLocked)
                        return;
                    if (isMouseEvent && this._skipNextEvents) {
                        this._skipNextEvents = false;
                        this._mouseLocked = true;
                        clearTimeout(this._unlockMouseTimer);
                        var that = this;
                        this._unlockMouseTimer = setTimeout(function() {
                            that._mouseLocked = false
                        }, this.EVENT_LOCK_TIMEOUT);
                        return
                    }
                    return this.callBase(e)
                },
                _fireEvent: function(args) {
                    var isMouseEvent = eventUtils.isMouseEvent(args.originalEvent),
                        normalizer = isMouseEvent ? MouseStrategy.normalize : TouchStrategy.normalize;
                    return this.callBase($.extend(normalizer(args.originalEvent), args))
                },
                dispose: function() {
                    this.callBase();
                    this._skipNextEvents = false;
                    this._mouseLocked = false;
                    clearTimeout(this._unlockMouseTimer)
                }
            });
        MouseAndTouchStrategy.map = eventMap;
        MouseAndTouchStrategy.resetObserver = MouseStrategy.resetObserver;
        return MouseAndTouchStrategy
    });
    /*! Module core, file ui.events.pointer.mspointer.js */
    DevExpress.define("/ui/events/pointer/ui.events.pointer.mspointer", ["jquery", "/ui/events/pointer/ui.events.pointer.base", "/ui/events/pointer/ui.events.pointer.observer", "/ui/events/pointer/ui.events.pointer.mspointerHooks"], function($, BaseStrategy, Observer) {
        var eventMap = {
                dxpointerdown: "MSPointerDown pointerdown",
                dxpointermove: "MSPointerMove pointermove",
                dxpointerup: "MSPointerUp pointerup",
                dxpointercancel: "MSPointerCancel pointercancel",
                dxpointerover: "MSPointerOver pointerover",
                dxpointerout: "MSPointerOut pointerout",
                dxpointerenter: "MSPointerEnter pointerenter",
                dxpointerleave: "MSPointerLeave pointerleave"
            };
        var observer;
        var activated = false;
        var activateStrategy = function() {
                if (activated)
                    return;
                observer = new Observer(eventMap, function(a, b) {
                    return a.pointerId === b.pointerId
                });
                activated = true
            };
        var MsPointerStrategy = BaseStrategy.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    activateStrategy()
                },
                _fireEvent: function(args) {
                    return this.callBase($.extend({
                            pointers: observer.pointers(),
                            pointerId: args.originalEvent.pointerId
                        }, args))
                }
            });
        MsPointerStrategy.map = eventMap;
        MsPointerStrategy.resetObserver = function() {
            observer.reset()
        };
        return MsPointerStrategy
    });
    /*! Module core, file ui.events.pointer.js */
    DevExpress.define("/ui/events/pointer/ui.events.pointer", ["jquery", "/utils/utils.support", "/devices", "/ui/events/ui.events.eventRegistrator", "/ui/events/pointer/ui.events.pointer.touch", "/ui/events/pointer/ui.events.pointer.mspointer", "/ui/events/pointer/ui.events.pointer.mouse", "/ui/events/pointer/ui.events.pointer.mouseAndTouch"], function($, support, devices, registerEvent, TouchStrategy, MsPointerStrategy, MouseStrategy, MouseAndTouchStrategy) {
        var EventStrategy = function() {
                if (support.pointer)
                    return MsPointerStrategy;
                var device = devices.real();
                if (support.touch && !(device.tablet || device.phone))
                    return MouseAndTouchStrategy;
                if (support.touch)
                    return TouchStrategy;
                return MouseStrategy
            }();
        $.each(EventStrategy.map, function(pointerEvent, originalEvents) {
            registerEvent(pointerEvent, new EventStrategy(pointerEvent, originalEvents))
        });
        return {
                down: "dxpointerdown",
                up: "dxpointerup",
                move: "dxpointermove",
                cancel: "dxpointercancel",
                enter: "dxpointerenter",
                leave: "dxpointerleave",
                over: "dxpointerover",
                out: "dxpointerout"
            }
    });
    /*! Module core, file ui.events.wheel.js */
    DevExpress.define("/ui/events/ui.events.wheel", ["jquery", "/ui/events/ui.events.eventRegistrator", "/ui/events/ui.events.utils"], function($, registerEvent, eventUtils) {
        var EVENT_NAME = "dxmousewheel",
            EVENT_NAMESPACE = "dxWheel";
        $.event.fixHooks["wheel"] = $.event.mouseHooks;
        var wheelEvent = document.onmousewheel !== undefined ? "mousewheel" : "wheel";
        var wheel = {
                setup: function(element, data) {
                    var $element = $(element);
                    $element.on(eventUtils.addNamespace(wheelEvent, EVENT_NAMESPACE), $.proxy(wheel._wheelHandler, wheel))
                },
                teardown: function(element) {
                    var $element = $(element);
                    $element.off("." + EVENT_NAMESPACE)
                },
                _wheelHandler: function(e) {
                    var delta = this._getWheelDelta(e.originalEvent);
                    eventUtils.fireEvent({
                        type: EVENT_NAME,
                        originalEvent: e,
                        delta: delta,
                        pointerType: "mouse"
                    });
                    e.stopPropagation()
                },
                _getWheelDelta: function(event) {
                    return event.wheelDelta ? event.wheelDelta : -event.deltaY * 30
                }
            };
        registerEvent(EVENT_NAME, wheel);
        return {name: EVENT_NAME}
    });
    /*! Module core, file ui.events.hover.js */
    DevExpress.define("/ui/events/ui.events.hover", ["jquery", "/class", "/devices", "/ui/events/ui.events.eventRegistrator", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer"], function($, Class, devices, registerEvent, eventUtils, pointerEvents) {
        var HOVERSTART_NAMESPACE = "dxHoverStart",
            HOVERSTART = "dxhoverstart",
            POINTERENTER_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(pointerEvents.enter, HOVERSTART_NAMESPACE),
            HOVEREND_NAMESPACE = "dxHoverEnd",
            HOVEREND = "dxhoverend",
            POINTERLEAVE_NAMESPACED_EVENT_NAME = eventUtils.addNamespace(pointerEvents.leave, HOVEREND_NAMESPACE);
        var Hover = Class.inherit({
                noBubble: true,
                add: function(element, handleObj) {
                    var that = this,
                        $element = $(element);
                    $element.off(this._originalEventName).on(this._originalEventName, handleObj.selector, function(e) {
                        that._handler(e)
                    })
                },
                _handler: function(e) {
                    if (eventUtils.isTouchEvent(e) || devices.isSimulator())
                        return;
                    eventUtils.fireEvent({
                        type: this._eventName,
                        originalEvent: e,
                        delegateTarget: e.delegateTarget
                    })
                },
                teardown: function(element) {
                    $(element).off(this._originalEventName)
                }
            });
        var HoverStart = Hover.inherit({
                ctor: function() {
                    this._eventName = HOVERSTART;
                    this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
                    this._isMouseDown = false
                },
                _handler: function(e) {
                    var pointers = e.pointers || [];
                    if (!pointers.length)
                        this.callBase(e)
                }
            });
        var HoverEnd = Hover.inherit({ctor: function() {
                    this._eventName = HOVEREND;
                    this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME
                }});
        registerEvent(HOVERSTART, new HoverStart);
        registerEvent(HOVEREND, new HoverEnd);
        return {
                start: HOVERSTART,
                end: HOVEREND
            }
    });
    /*! Module core, file ui.events.emitterRegistrator.js */
    DevExpress.define("/ui/events/ui.events.emitterRegistrator", ["jquery", "/class", "/ui/events/ui.events.eventRegistrator", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer", "/ui/events/ui.events.emitter.gesture", "/ui/events/ui.events.wheel"], function($, Class, registerEvent, eventUtils, pointerEvents, GestureEmitter, wheelEvent) {
        var MANAGER_EVENT = "dxEventManager",
            EMITTER_DATA = "dxEmitter";
        var EventManager = Class.inherit({
                ctor: function() {
                    this._attachHandlers();
                    this.reset();
                    this._proxiedCancelHandler = $.proxy(this._cancelHandler, this);
                    this._proxiedAcceptHandler = $.proxy(this._acceptHandler, this)
                },
                _attachHandlers: function() {
                    $(document).on(eventUtils.addNamespace(pointerEvents.down, MANAGER_EVENT), $.proxy(this._pointerDownHandler, this)).on(eventUtils.addNamespace(pointerEvents.move, MANAGER_EVENT), $.proxy(this._pointerMoveHandler, this)).on(eventUtils.addNamespace([pointerEvents.up, pointerEvents.cancel].join(" "), MANAGER_EVENT), $.proxy(this._pointerUpHandler, this)).on(eventUtils.addNamespace(wheelEvent.name, MANAGER_EVENT), $.proxy(this._mouseWheelHandler, this))
                },
                _eachEmitter: function(callback) {
                    var activeEmitters = this._activeEmitters || [];
                    var i = 0;
                    while (activeEmitters.length > i) {
                        var emitter = activeEmitters[i];
                        if (callback(emitter) === false)
                            break;
                        if (activeEmitters[i] === emitter)
                            i++
                    }
                },
                _applyToEmitters: function(method, arg) {
                    this._eachEmitter(function(emitter) {
                        emitter[method].call(emitter, arg)
                    })
                },
                reset: function() {
                    this._eachEmitter(this._proxiedCancelHandler);
                    this._activeEmitters = []
                },
                resetEmitter: function(emitter) {
                    this._proxiedCancelHandler(emitter)
                },
                _pointerDownHandler: function(e) {
                    if (eventUtils.isMouseEvent(e) && e.which > 1)
                        return;
                    this._updateEmitters(e)
                },
                _updateEmitters: function(e) {
                    if (!this._isSetChanged(e))
                        return;
                    this._cleanEmitters(e);
                    this._fetchEmitters(e)
                },
                _isSetChanged: function(e) {
                    var currentSet = this._closestEmitter(e);
                    var previousSet = this._emittersSet || [];
                    var setChanged = currentSet.length !== previousSet.length;
                    $.each(currentSet, function(index, emitter) {
                        setChanged = setChanged || previousSet[index] !== emitter;
                        return !setChanged
                    });
                    this._emittersSet = currentSet;
                    return setChanged
                },
                _closestEmitter: function(e) {
                    var that = this,
                        result = [],
                        $element = $(e.target);
                    function handleEmitter(_, emitter) {
                        if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
                            emitter.addCancelCallback(that._proxiedCancelHandler);
                            emitter.addAcceptCallback(that._proxiedAcceptHandler);
                            result.push(emitter)
                        }
                    }
                    while ($element.length) {
                        var emitters = $.data($element.get(0), EMITTER_DATA) || [];
                        $.each(emitters, handleEmitter);
                        $element = $element.parent()
                    }
                    return result
                },
                _acceptHandler: function(acceptedEmitter, e) {
                    var that = this;
                    this._eachEmitter(function(emitter) {
                        if (emitter !== acceptedEmitter)
                            that._cancelEmitter(emitter, e)
                    })
                },
                _cancelHandler: function(canceledEmitter, e) {
                    this._cancelEmitter(canceledEmitter, e)
                },
                _cancelEmitter: function(emitter, e) {
                    var activeEmitters = this._activeEmitters;
                    if (e)
                        emitter.cancel(e);
                    else
                        emitter.reset();
                    emitter.removeCancelCallback();
                    emitter.removeAcceptCallback();
                    var emitterIndex = $.inArray(emitter, activeEmitters);
                    if (emitterIndex > -1)
                        activeEmitters.splice(emitterIndex, 1)
                },
                _cleanEmitters: function(e) {
                    this._applyToEmitters("end", e);
                    this.reset(e)
                },
                _fetchEmitters: function(e) {
                    this._activeEmitters = this._emittersSet.slice();
                    this._applyToEmitters("start", e)
                },
                _pointerMoveHandler: function(e) {
                    this._applyToEmitters("move", e)
                },
                _pointerUpHandler: function(e) {
                    this._updateEmitters(e)
                },
                _mouseWheelHandler: function(e) {
                    if (!this._allowInterruptionByMousewheel())
                        return;
                    e.pointers = [null];
                    this._pointerDownHandler(e);
                    this._adjustWheelEvent(e);
                    this._pointerMoveHandler(e);
                    e.pointers = [];
                    this._pointerUpHandler(e)
                },
                _allowInterruptionByMousewheel: function() {
                    var allowInterruption = true;
                    this._eachEmitter(function(emitter) {
                        allowInterruption = emitter.allowInterruptionByMousewheel() && allowInterruption;
                        return allowInterruption
                    });
                    return allowInterruption
                },
                _adjustWheelEvent: function(e) {
                    var closestGestureEmitter = null;
                    this._eachEmitter(function(emitter) {
                        if (!(emitter instanceof GestureEmitter))
                            return;
                        var direction = emitter.getDirection(e);
                        if (direction !== "horizontal" && !e.shiftKey || direction !== "vertical" && e.shiftKey) {
                            closestGestureEmitter = emitter;
                            return false
                        }
                    });
                    if (!closestGestureEmitter)
                        return;
                    var direction = closestGestureEmitter.getDirection(e),
                        verticalGestureDirection = direction === "both" && !e.shiftKey || direction === "vertical",
                        prop = verticalGestureDirection ? "pageY" : "pageX";
                    e[prop] += e.delta
                },
                isActive: function(element) {
                    var result = false;
                    this._eachEmitter(function(emitter) {
                        result = result || emitter.getElement().is(element)
                    });
                    return result
                }
            });
        var eventManager = new EventManager;
        var EMITTER_SUBSCRIPTION_DATA = "dxEmitterSubscription";
        var registerEmitter = function(emitterConfig) {
                var emitterClass = emitterConfig.emitter,
                    emitterName = emitterConfig.events[0],
                    emitterEvents = emitterConfig.events;
                $.each(emitterEvents, function(_, eventName) {
                    registerEvent(eventName, {
                        noBubble: !emitterConfig.bubble,
                        setup: function(element, data) {
                            var subscriptions = $.data(element, EMITTER_SUBSCRIPTION_DATA) || {},
                                emitters = $.data(element, EMITTER_DATA) || {},
                                emitter = emitters[emitterName] || new emitterClass(element);
                            subscriptions[eventName] = true;
                            emitters[emitterName] = emitter;
                            $.data(element, EMITTER_DATA, emitters);
                            $.data(element, EMITTER_SUBSCRIPTION_DATA, subscriptions)
                        },
                        add: function(element, handleObj) {
                            var emitters = $.data(element, EMITTER_DATA),
                                emitter = emitters[emitterName];
                            emitter.configurate($.extend({delegateSelector: handleObj.selector}, handleObj.data), handleObj.type)
                        },
                        teardown: function(element) {
                            var subscriptions = $.data(element, EMITTER_SUBSCRIPTION_DATA),
                                emitters = $.data(element, EMITTER_DATA),
                                emitter = emitters[emitterName];
                            delete subscriptions[eventName];
                            var disposeEmitter = true;
                            $.each(emitterEvents, function(_, eventName) {
                                disposeEmitter = disposeEmitter && !subscriptions[eventName];
                                return disposeEmitter
                            });
                            if (disposeEmitter) {
                                if (eventManager.isActive(element))
                                    eventManager.resetEmitter(emitter);
                                emitter && emitter.dispose();
                                delete emitters[emitterName]
                            }
                        }
                    })
                })
            };
        return registerEmitter
    });
    /*! Module core, file ui.events.emitter.js */
    DevExpress.define("/ui/events/ui.events.emitter", ["jquery", "/class", "/ui/events/ui.events.utils"], function($, Class, eventUtils) {
        var Emitter = Class.inherit({
                ctor: function(element) {
                    this._$element = $(element);
                    this._cancelCallback = $.Callbacks();
                    this._acceptCallback = $.Callbacks()
                },
                getElement: function() {
                    return this._$element
                },
                validate: function(e) {
                    return e.type !== "dxmousewheel"
                },
                validatePointers: function(e) {
                    return eventUtils.hasTouches(e) === 1
                },
                allowInterruptionByMousewheel: function() {
                    return true
                },
                configurate: function(data) {
                    $.extend(this, data)
                },
                addCancelCallback: function(callback) {
                    this._cancelCallback.add(callback)
                },
                removeCancelCallback: function() {
                    this._cancelCallback.empty()
                },
                _cancel: function(e) {
                    this._cancelCallback.fire(this, e)
                },
                addAcceptCallback: function(callback) {
                    this._acceptCallback.add(callback)
                },
                removeAcceptCallback: function() {
                    this._acceptCallback.empty()
                },
                _accept: function(e) {
                    this._acceptCallback.fire(this, e)
                },
                _requestAccept: function(e) {
                    this._acceptRequestEvent = e
                },
                _forgetAccept: function() {
                    this._accept(this._acceptRequestEvent);
                    this._acceptRequestEvent = null
                },
                start: $.noop,
                move: $.noop,
                end: $.noop,
                cancel: $.noop,
                reset: function() {
                    if (this._acceptRequestEvent)
                        this._accept(this._acceptRequestEvent)
                },
                _fireEvent: function(eventName, e, params) {
                    var eventData = $.extend({
                            type: eventName,
                            originalEvent: e,
                            target: this._getEmitterTarget(e),
                            delegateTarget: this.getElement().get(0)
                        }, params);
                    e = eventUtils.fireEvent(eventData);
                    if (e.cancel)
                        this._cancel(e);
                    return e
                },
                _getEmitterTarget: function(e) {
                    return (this.delegateSelector ? $(e.target).closest(this.delegateSelector) : this.getElement()).get(0)
                },
                dispose: $.noop
            });
        return Emitter
    });
    /*! Module core, file ui.events.emitter.gesture.js */
    DevExpress.define("/ui/events/ui.events.emitter.gesture", ["jquery", "/devices", "/utils/utils.support", "/utils/utils.browser", "/utils/utils.dom", "/utils/utils.math", "/utils/utils.common", "/ui/events/ui.events.utils", "/ui/events/ui.events.emitter"], function($, devices, support, browser, domUtils, mathUtils, commonUtils, eventUtils, Emitter) {
        var sign = mathUtils.sign,
            abs = Math.abs;
        var SLEEP = 0,
            INITED = 1,
            STARTED = 2,
            TOUCH_BOUNDARY = 10,
            IMMEDIATE_TOUCH_BOUNDARY = 0,
            IMMEDIATE_TIMEOUT = 180;
        var isMousewheelEvent = function(e) {
                return e && e.type === "dxmousewheel"
            };
        var supportPointerEvents = function() {
                var cssSupport = support.styleProp("pointer-events");
                var msieLess11 = browser.msie && parseInt(browser.version, 10) < 11;
                return cssSupport && !msieLess11
            };
        var gestureCover = function() {
                var GESTURE_COVER_CLASS = "dx-gesture-cover";
                var isDesktop = devices.real().platform === "generic";
                if (!supportPointerEvents() || !isDesktop)
                    return $.noop;
                var $cover = $("<div>").addClass(GESTURE_COVER_CLASS).css("pointerEvents", "none");
                $(function() {
                    $cover.appendTo("body")
                });
                return function(toggle, cursor) {
                        $cover.css("pointerEvents", toggle ? "all" : "none");
                        toggle && $cover.css("cursor", cursor)
                    }
            }();
        var GestureEmitter = Emitter.inherit({
                configurate: function(data) {
                    this.getElement().css("msTouchAction", data.immediate ? "pinch-zoom" : "");
                    this.callBase(data)
                },
                allowInterruptionByMousewheel: function() {
                    return this._stage !== STARTED
                },
                getDirection: function() {
                    return this.direction
                },
                _cancel: function(e) {
                    this.callBase.apply(this, arguments);
                    this._toggleGestureCover(false);
                    this._stage = SLEEP
                },
                start: function(e) {
                    if (eventUtils.needSkipEvent(e)) {
                        this._cancel(e);
                        return
                    }
                    this._startEvent = eventUtils.createEvent(e);
                    this._startEventData = eventUtils.eventData(e);
                    this._prevEventData = this._startEventData;
                    this._stage = INITED;
                    this._init(e);
                    this._setupImmediateTimer()
                },
                _setupImmediateTimer: function() {
                    clearTimeout(this._immediateTimer);
                    this._immedeateAccepted = false;
                    if (!this.immediate)
                        return;
                    this._immediateTimer = setTimeout($.proxy(function() {
                        this._immedeateAccepted = true
                    }, this), IMMEDIATE_TIMEOUT)
                },
                move: function(e) {
                    if (this._stage === INITED && this._directionConfirmed(e)) {
                        this._stage = STARTED;
                        this._resetActiveElement();
                        this._toggleGestureCover(true, e);
                        this._clearSelection(e);
                        this._adjustStartEvent(e);
                        this._start(this._startEvent);
                        this._prevEventData = eventUtils.eventData(this._startEvent);
                        if (this._stage === SLEEP)
                            return;
                        this._requestAccept(e);
                        this._move(e);
                        this._forgetAccept()
                    }
                    else if (this._stage === STARTED) {
                        this._clearSelection(e);
                        this._move(e)
                    }
                    this._prevEventData = eventUtils.eventData(e)
                },
                _directionConfirmed: function(e) {
                    var touchBoundary = this._getTouchBoundary(e),
                        delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e)),
                        deltaX = abs(delta.x),
                        deltaY = abs(delta.y);
                    var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY),
                        verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
                    var direction = this.getDirection(e),
                        bothAccepted = direction === "both" && (horizontalMove || verticalMove),
                        horizontalAccepted = direction === "horizontal" && horizontalMove,
                        verticalAccepted = direction === "vertical" && verticalMove;
                    return bothAccepted || horizontalAccepted || verticalAccepted || this._immedeateAccepted
                },
                _validateMove: function(touchBoundary, mainAxis, crossAxis) {
                    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true)
                },
                _getTouchBoundary: function(e) {
                    return this.immediate || isMousewheelEvent(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY
                },
                _adjustStartEvent: function(e) {
                    var touchBoundary = this._getTouchBoundary(e),
                        delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));
                    this._startEvent.pageX += sign(delta.x) * touchBoundary;
                    this._startEvent.pageY += sign(delta.y) * touchBoundary
                },
                _resetActiveElement: function() {
                    if (devices.real().platform === "ios" && $(":focus", this.getElement()).length)
                        domUtils.resetActiveElement()
                },
                _toggleGestureCover: function(toggle, e) {
                    var isStarted = this._stage === STARTED;
                    if (isStarted)
                        gestureCover(toggle, this.getElement().css("cursor"))
                },
                _clearSelection: function(e) {
                    if (isMousewheelEvent(e) || eventUtils.isTouchEvent(e))
                        return;
                    domUtils.clearSelection()
                },
                end: function(e) {
                    this._toggleGestureCover(false, e);
                    if (this._stage === STARTED)
                        this._end(e);
                    else if (this._stage === INITED)
                        this._stop(e);
                    this._stage = SLEEP
                },
                dispose: function() {
                    clearTimeout(this._immediateTimer);
                    this.callBase.apply(this, arguments);
                    this._toggleGestureCover(false)
                },
                _init: $.noop,
                _start: $.noop,
                _move: $.noop,
                _stop: $.noop,
                _end: $.noop
            });
        GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;
        GestureEmitter.touchBoundary = function(newBoundary) {
            if (commonUtils.isDefined(newBoundary)) {
                TOUCH_BOUNDARY = newBoundary;
                return
            }
            return TOUCH_BOUNDARY
        };
        return GestureEmitter
    });
    /*! Module core, file ui.events.emitter.feedback.js */
    DevExpress.define("/ui/events/ui.events.emitter.feedback", ["jquery", "/class", "/utils/utils.common", "/devices", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer", "/ui/events/ui.events.emitter", "/ui/events/ui.events.emitterRegistrator"], function($, Class, commonUtils, devices, eventUtils, pointerEvents, Emitter, registerEmitter) {
        var ACTIVE_EVENT_NAME = "dxactive",
            INACTIVE_EVENT_NAME = "dxinactive",
            ACTIVE_TIMEOUT = 30,
            INACTIVE_TIMEOUT = 400;
        var FeedbackEvent = Class.inherit({
                ctor: function(timeout, fire) {
                    this._timeout = timeout;
                    this._fire = fire
                },
                start: function() {
                    var that = this;
                    this._schedule(function() {
                        that.force()
                    })
                },
                _schedule: function(fn) {
                    this._timer = window.setTimeout(fn, this._timeout)
                },
                stop: function() {
                    clearTimeout(this._timer)
                },
                force: function() {
                    if (this._fired)
                        return;
                    this.stop();
                    this._fire();
                    this._fired = true
                },
                fired: function() {
                    return this._fired
                }
            });
        var activeFeedback;
        var FeedbackEmitter = Emitter.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    this._active = new FeedbackEvent(0, $.noop);
                    this._inactive = new FeedbackEvent(0, $.noop)
                },
                configurate: function(data, eventName) {
                    switch (eventName) {
                        case ACTIVE_EVENT_NAME:
                            data.activeTimeout = data.timeout;
                            break;
                        case INACTIVE_EVENT_NAME:
                            data.inactiveTimeout = data.timeout;
                            break
                    }
                    this.callBase(data)
                },
                start: function(e) {
                    if (activeFeedback) {
                        var activeChildExists = $.contains(this.getElement().get(0), activeFeedback.getElement().get(0));
                        var childJustActivated = !activeFeedback._active.fired();
                        if (activeChildExists && childJustActivated) {
                            this._cancel();
                            return
                        }
                        activeFeedback._inactive.force()
                    }
                    activeFeedback = this;
                    this._initEvents(e);
                    this._active.start()
                },
                _initEvents: function(e) {
                    var that = this,
                        eventTarget = this._getEmitterTarget(e),
                        mouseEvent = eventUtils.isMouseEvent(e),
                        isSimulator = devices.isSimulator(),
                        deferFeedback = isSimulator || !mouseEvent,
                        activeTimeout = commonUtils.ensureDefined(this.activeTimeout, ACTIVE_TIMEOUT),
                        inactiveTimeout = commonUtils.ensureDefined(this.inactiveTimeout, INACTIVE_TIMEOUT);
                    this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, function() {
                        that._fireEvent(ACTIVE_EVENT_NAME, e, {target: eventTarget})
                    });
                    this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, function() {
                        that._fireEvent(INACTIVE_EVENT_NAME, e, {target: eventTarget});
                        activeFeedback = null
                    })
                },
                cancel: function(e) {
                    this.end(e)
                },
                end: function(e) {
                    var skipTimers = e.type !== pointerEvents.up;
                    if (skipTimers)
                        this._active.stop();
                    else
                        this._active.force();
                    this._inactive.start();
                    if (skipTimers)
                        this._inactive.force()
                },
                dispose: function() {
                    this._active.stop();
                    this._inactive.stop();
                    this.callBase()
                },
                lockInactive: function() {
                    this._active.force();
                    this._inactive.stop();
                    activeFeedback = null;
                    this._cancel();
                    return $.proxy(this._inactive.force, this._inactive)
                }
            });
        FeedbackEmitter.lock = function(deferred) {
            var lockInactive = activeFeedback ? activeFeedback.lockInactive() : $.noop;
            $.when(deferred).always(lockInactive)
        };
        registerEmitter({
            emitter: FeedbackEmitter,
            events: [ACTIVE_EVENT_NAME, INACTIVE_EVENT_NAME]
        });
        return {
                lock: FeedbackEmitter.lock,
                active: ACTIVE_EVENT_NAME,
                inactive: INACTIVE_EVENT_NAME
            }
    });
    /*! Module core, file fx.js */
    (function($, DX, undefined) {
        var errors = DX.require("/errors"),
            translator = DX.require("/utils/utils.translator"),
            animationFrame = DX.require("/utils/utils.animationFrame"),
            support = DX.require("/utils/utils.support"),
            positionUtils = DX.require("/utils/utils.position"),
            removeEvent = DX.require("/ui/events/ui.events.remove"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            transitionEndEventName = support.transitionEndEventName + ".dxFX",
            removeEventName = eventUtils.addNamespace(removeEvent.name, "dxFX");
        var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/,
            RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i,
            ANIM_DATA_KEY = "dxAnimData",
            ANIM_QUEUE_KEY = "dxAnimQueue",
            TRANSFORM_PROP = "transform";
        var TransitionAnimationStrategy = {
                initAnimation: function($element, config) {
                    $element.css({transitionProperty: "none"});
                    if (typeof config.from === "string")
                        $element.addClass(config.from);
                    else
                        setProps($element, config.from);
                    var that = this,
                        deferred = $.Deferred(),
                        cleanupWhen = config.cleanupWhen;
                    config.transitionAnimation = {
                        deferred: deferred,
                        finish: function() {
                            that._finishTransition($element, config);
                            if (cleanupWhen)
                                $.when(deferred, cleanupWhen).always(function() {
                                    that._cleanup($element, config)
                                });
                            else
                                that._cleanup($element, config);
                            deferred.resolveWith($element, [config, $element])
                        }
                    };
                    this._completeAnimationCallback($element, config).done(function() {
                        config.transitionAnimation.finish()
                    }).fail(function() {
                        deferred.rejectWith($element, [config, $element])
                    });
                    if (!config.duration)
                        config.transitionAnimation.finish();
                    $element.css("transform");
                    $element.css({
                        transitionProperty: "all",
                        transitionDelay: config.delay + "ms",
                        transitionDuration: config.duration + "ms",
                        transitionTimingFunction: config.easing
                    })
                },
                animate: function($element, config) {
                    this._startAnimation($element, config);
                    return config.transitionAnimation.deferred.promise()
                },
                _completeAnimationCallback: function($element, config) {
                    var that = this,
                        startTime = $.now() + config.delay,
                        deferred = $.Deferred(),
                        transitionEndFired = $.Deferred(),
                        simulatedTransitionEndFired = $.Deferred(),
                        simulatedEndEventTimer,
                        waitForJSCompleteTimer;
                    config.transitionAnimation.cleanup = function() {
                        clearTimeout(simulatedEndEventTimer);
                        clearTimeout(waitForJSCompleteTimer);
                        $element.off(transitionEndEventName);
                        $element.off(removeEventName)
                    };
                    $element.one(transitionEndEventName, function() {
                        if ($.now() - startTime >= config.duration)
                            transitionEndFired.reject()
                    }).off(removeEventName).on(removeEventName, function() {
                        that.stop($element, config);
                        deferred.reject()
                    });
                    waitForJSCompleteTimer = setTimeout(function() {
                        simulatedEndEventTimer = setTimeout(function() {
                            simulatedTransitionEndFired.reject()
                        }, config.duration + config.delay + DX.fx._simulatedTransitionEndDelay);
                        $.when(transitionEndFired, simulatedTransitionEndFired).fail($.proxy(function() {
                            deferred.resolve()
                        }, this))
                    });
                    return deferred.promise()
                },
                _startAnimation: function($element, config) {
                    if (typeof config.to === "string")
                        $element[0].className += " " + config.to;
                    else if (config.to)
                        setProps($element, config.to)
                },
                _finishTransition: function($element, config) {
                    $element.css("transition", "none")
                },
                _cleanup: function($element, config) {
                    config.transitionAnimation.cleanup();
                    if (typeof config.from === "string") {
                        $element.removeClass(config.from);
                        $element.removeClass(config.to)
                    }
                },
                stop: function($element, config, jumpToEnd) {
                    if (!config)
                        return;
                    if (jumpToEnd)
                        config.transitionAnimation.finish();
                    else {
                        if ($.isPlainObject(config.to))
                            $.each(config.to, function(key) {
                                $element.css(key, $element.css(key))
                            });
                        this._finishTransition($element, config);
                        this._cleanup($element, config)
                    }
                }
            };
        var FrameAnimationStrategy = {
                initAnimation: function($element, config) {
                    setProps($element, config.from)
                },
                animate: function($element, config) {
                    var deferred = $.Deferred(),
                        that = this;
                    if (!config)
                        return deferred.reject().promise();
                    $.each(config.to, function(prop) {
                        if (config.from[prop] === undefined)
                            config.from[prop] = that._normalizeValue($element.css(prop))
                    });
                    if (config.to[TRANSFORM_PROP]) {
                        config.from[TRANSFORM_PROP] = that._parseTransform(config.from[TRANSFORM_PROP]);
                        config.to[TRANSFORM_PROP] = that._parseTransform(config.to[TRANSFORM_PROP])
                    }
                    config.frameAnimation = {
                        to: config.to,
                        from: config.from,
                        currentValue: config.from,
                        easing: convertTransitionTimingFuncToJQueryEasing(config.easing),
                        duration: config.duration,
                        startTime: (new Date).valueOf(),
                        finish: function() {
                            this.currentValue = this.to;
                            this.draw();
                            animationFrame.cancel(config.frameAnimation.animationFrameId);
                            deferred.resolve()
                        },
                        draw: function() {
                            if (config.draw) {
                                config.draw(this.currentValue);
                                return
                            }
                            var currentValue = $.extend({}, this.currentValue);
                            if (currentValue[TRANSFORM_PROP])
                                currentValue[TRANSFORM_PROP] = $.map(currentValue[TRANSFORM_PROP], function(value, prop) {
                                    if (prop === "translate")
                                        return translator.getTranslateCss(value);
                                    else if (prop === "scale")
                                        return "scale(" + value + ")";
                                    else if (prop.substr(0, prop.length - 1) === "rotate")
                                        return prop + "(" + value + "deg)"
                                }).join(" ");
                            $element.css(currentValue)
                        }
                    };
                    if (config.delay) {
                        config.frameAnimation.startTime += config.delay;
                        config.frameAnimation.delayTimeout = setTimeout(function() {
                            that._startAnimation($element, config)
                        }, config.delay)
                    }
                    else
                        that._startAnimation($element, config);
                    return deferred.promise()
                },
                _startAnimation: function($element, config) {
                    $element.off(removeEventName).on(removeEventName, function() {
                        if (config.frameAnimation)
                            animationFrame.cancel(config.frameAnimation.animationFrameId)
                    });
                    this._animationStep($element, config)
                },
                _parseTransform: function(transformString) {
                    var result = {};
                    $.each(transformString.match(/(\w|\d)+\([^\)]*\)\s*/g), function(i, part) {
                        var translateData = translator.parseTranslate(part),
                            scaleData = part.match(/scale\((.+?)\)/),
                            rotateData = part.match(/(rotate.)\((.+)deg\)/);
                        if (translateData)
                            result.translate = translateData;
                        if (scaleData && scaleData[1])
                            result.scale = parseFloat(scaleData[1]);
                        if (rotateData && rotateData[1])
                            result[rotateData[1]] = parseFloat(rotateData[2])
                    });
                    return result
                },
                stop: function($element, config, jumpToEnd) {
                    var frameAnimation = config && config.frameAnimation;
                    if (!frameAnimation)
                        return;
                    animationFrame.cancel(frameAnimation.animationFrameId);
                    clearTimeout(frameAnimation.delayTimeout);
                    if (jumpToEnd)
                        frameAnimation.finish();
                    delete config.frameAnimation
                },
                _animationStep: function($element, config) {
                    var frameAnimation = config && config.frameAnimation;
                    if (!frameAnimation)
                        return;
                    var now = (new Date).valueOf();
                    if (now >= frameAnimation.startTime + frameAnimation.duration) {
                        frameAnimation.finish();
                        return
                    }
                    frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
                    frameAnimation.draw();
                    var that = this;
                    frameAnimation.animationFrameId = animationFrame.request(function() {
                        that._animationStep($element, config)
                    })
                },
                _calcStepValue: function(frameAnimation, currentDuration) {
                    var calcValueRecursively = function(from, to) {
                            var result = $.isArray(to) ? [] : {};
                            var calcEasedValue = function(propName) {
                                    var x = currentDuration / frameAnimation.duration,
                                        t = currentDuration,
                                        b = 1 * from[propName],
                                        c = to[propName] - from[propName],
                                        d = frameAnimation.duration;
                                    return $.easing[frameAnimation.easing](x, t, b, c, d)
                                };
                            $.each(to, function(propName, endPropValue) {
                                if (typeof endPropValue === "string" && parseFloat(endPropValue, 10) === false)
                                    return true;
                                result[propName] = typeof endPropValue === "object" ? calcValueRecursively(from[propName], endPropValue) : calcEasedValue(propName)
                            });
                            return result
                        };
                    return calcValueRecursively(frameAnimation.from, frameAnimation.to)
                },
                _normalizeValue: function(value) {
                    var numericValue = parseFloat(value, 10);
                    if (numericValue === false)
                        return value;
                    return numericValue
                }
            };
        var FallbackToNoAnimationStrategy = {
                initAnimation: function($element, config){},
                animate: function($element, config) {
                    return $.Deferred().resolve().promise()
                },
                stop: $.noop,
                isSynchronous: true
            };
        var animationStrategies = {
                transition: support.transition ? TransitionAnimationStrategy : FrameAnimationStrategy,
                frame: FrameAnimationStrategy,
                noAnimation: FallbackToNoAnimationStrategy
            };
        var getAnimationStrategy = function(config) {
                config = config || {};
                var strategy = config.strategy || "transition";
                if (config.type === "css" && !support.transition)
                    strategy = "noAnimation";
                return animationStrategies[strategy]
            };
        var TransitionTimingFuncMap = {
                linear: "cubic-bezier(0, 0, 1, 1)",
                ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
                "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
                "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
                "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
            };
        var convertTransitionTimingFuncToJQueryEasing = function(cssTransitionEasing) {
                cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
                var bezCoeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
                if (!bezCoeffs)
                    return "linear";
                bezCoeffs = bezCoeffs.slice(1, 5);
                $.each(bezCoeffs, function(index, value) {
                    bezCoeffs[index] = parseFloat(value)
                });
                var easingName = "cubicbezier_" + bezCoeffs.join("_").replace(/\./g, "p");
                if (!$.isFunction($.easing[easingName])) {
                    var polynomBezier = function(x1, y1, x2, y2) {
                            var Cx = 3 * x1,
                                Bx = 3 * (x2 - x1) - Cx,
                                Ax = 1 - Cx - Bx,
                                Cy = 3 * y1,
                                By = 3 * (y2 - y1) - Cy,
                                Ay = 1 - Cy - By;
                            var bezierX = function(t) {
                                    return t * (Cx + t * (Bx + t * Ax))
                                };
                            var bezierY = function(t) {
                                    return t * (Cy + t * (By + t * Ay))
                                };
                            var findXfor = function(t) {
                                    var x = t,
                                        i = 0,
                                        z;
                                    while (i < 14) {
                                        z = bezierX(x) - t;
                                        if (Math.abs(z) < 1e-3)
                                            break;
                                        x = x - z / derivativeX(x);
                                        i++
                                    }
                                    return x
                                };
                            var derivativeX = function(t) {
                                    return Cx + t * (2 * Bx + t * 3 * Ax)
                                };
                            return function(t) {
                                    return bezierY(findXfor(t))
                                }
                        };
                    $.easing[easingName] = function(x, t, b, c, d) {
                        return c * polynomBezier(bezCoeffs[0], bezCoeffs[1], bezCoeffs[2], bezCoeffs[3])(t / d) + b
                    }
                }
                return easingName
            };
        var baseConfigValidator = function(config, animationType, validate, typeMessage) {
                $.each(["from", "to"], function() {
                    if (!validate(config[this]))
                        throw errors.Error("E0010", animationType, this, typeMessage);
                })
            };
        var isObjectConfigValidator = function(config, animationType) {
                return baseConfigValidator(config, animationType, function(target) {
                        return $.isPlainObject(target)
                    }, "a plain object")
            };
        var isStringConfigValidator = function(config, animationType) {
                return baseConfigValidator(config, animationType, function(target) {
                        return typeof target === "string"
                    }, "a string")
            };
        var CustomAnimationConfigurator = {setup: function($element, config){}};
        var CssAnimationConfigurator = {
                validateConfig: function(config) {
                    isStringConfigValidator(config, "css")
                },
                setup: function($element, config){}
            };
        var positionAliases = {
                top: {
                    my: "bottom center",
                    at: "top center"
                },
                bottom: {
                    my: "top center",
                    at: "bottom center"
                },
                right: {
                    my: "left center",
                    at: "right center"
                },
                left: {
                    my: "right center",
                    at: "left center"
                }
            };
        var SlideAnimationConfigurator = {
                validateConfig: function(config) {
                    isObjectConfigValidator(config, "slide")
                },
                setup: function($element, config) {
                    var location = translator.locate($element);
                    if (config.type !== "slide") {
                        var positioningConfig = config.type === "slideIn" ? config.from : config.to;
                        positioningConfig.position = $.extend({of: window}, positionAliases[config.direction]);
                        setupPosition($element, positioningConfig)
                    }
                    this._setUpConfig(location, config.from);
                    this._setUpConfig(location, config.to);
                    translator.clearCache($element);
                    if (!support.transform && $element.css("position") === "static")
                        $element.css("position", "relative")
                },
                _setUpConfig: function(location, config) {
                    config.left = "left" in config ? config.left : "+=0";
                    config.top = "top" in config ? config.top : "+=0";
                    this._initNewPosition(location, config)
                },
                _initNewPosition: function(location, config) {
                    var position = {
                            left: config.left,
                            top: config.top
                        };
                    delete config.left;
                    delete config.top;
                    var relativeValue = this._getRelativeValue(position.left);
                    if (relativeValue !== undefined)
                        position.left = relativeValue + location.left;
                    else
                        config.left = 0;
                    relativeValue = this._getRelativeValue(position.top);
                    if (relativeValue !== undefined)
                        position.top = relativeValue + location.top;
                    else
                        config.top = 0;
                    var translate = {
                            x: 0,
                            y: 0
                        };
                    if (support.transform)
                        translate = {
                            x: position.left,
                            y: position.top
                        };
                    else {
                        config.left = position.left;
                        config.top = position.top
                    }
                    config[TRANSFORM_PROP] = translator.getTranslateCss(translate)
                },
                _getRelativeValue: function(value) {
                    var relativeValue;
                    if (typeof value === "string" && (relativeValue = RELATIVE_VALUE_REGEX.exec(value)))
                        return parseInt(relativeValue[1] + "1") * relativeValue[2]
                }
            };
        var FadeAnimationConfigurator = {setup: function($element, config) {
                    var from = config.from,
                        fromOpacity = $.isPlainObject(from) ? config.skipElementInitialStyles ? 0 : $element.css("opacity") : String(from),
                        toOpacity;
                    switch (config.type) {
                        case"fadeIn":
                            toOpacity = 1;
                            break;
                        case"fadeOut":
                            toOpacity = 0;
                            break;
                        default:
                            toOpacity = String(config.to)
                    }
                    config.from = {
                        visibility: "visible",
                        opacity: fromOpacity
                    };
                    config.to = {opacity: toOpacity}
                }};
        var PopAnimationConfigurator = {
                validateConfig: function(config) {
                    isObjectConfigValidator(config, "pop")
                },
                setup: function($element, config) {
                    var from = config.from,
                        to = config.to,
                        fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity"),
                        toOpacity = "opacity" in to ? to.opacity : 1,
                        fromScale = "scale" in from ? from.scale : 0,
                        toScale = "scale" in to ? to.scale : 1;
                    config.from = {opacity: fromOpacity};
                    var translate = translator.getTranslate($element);
                    config.from[TRANSFORM_PROP] = this._getCssTransform(translate, fromScale);
                    config.to = {opacity: toOpacity};
                    config.to[TRANSFORM_PROP] = this._getCssTransform(translate, toScale)
                },
                _getCssTransform: function(translate, scale) {
                    return translator.getTranslateCss(translate) + "scale(" + scale + ")"
                }
            };
        var animationConfigurators = {
                custom: CustomAnimationConfigurator,
                slide: SlideAnimationConfigurator,
                slideIn: SlideAnimationConfigurator,
                slideOut: SlideAnimationConfigurator,
                fade: FadeAnimationConfigurator,
                fadeIn: FadeAnimationConfigurator,
                fadeOut: FadeAnimationConfigurator,
                pop: PopAnimationConfigurator,
                css: CssAnimationConfigurator
            };
        var getAnimationConfigurator = function(config) {
                var result = animationConfigurators[config.type];
                if (!result)
                    throw errors.Error("E0011", config.type);
                return result
            };
        var defaultJSConfig = {
                type: "custom",
                from: {},
                to: {},
                duration: 400,
                start: $.noop,
                complete: $.noop,
                easing: "ease",
                delay: 0
            },
            defaultCssConfig = {
                duration: 400,
                easing: "ease",
                delay: 0
            };
        var setupAnimationOnElement = function() {
                var animation = this,
                    $element = animation.element,
                    config = animation.config;
                setupPosition($element, config.from);
                setupPosition($element, config.to);
                animation.configurator.setup($element, config);
                $element.data(ANIM_DATA_KEY, animation);
                if (DX.fx.off) {
                    config.duration = 0;
                    config.delay = 0
                }
                animation.strategy.initAnimation($element, config);
                if (config.start)
                    config.start.apply(this, [$element, config])
            };
        var onElementAnimationComplete = function(animation) {
                var $element = animation.element,
                    config = animation.config;
                $element.removeData(ANIM_DATA_KEY);
                if (config.complete)
                    config.complete.apply(this, [$element, config]);
                animation.deferred.resolveWith(this, [$element, config])
            };
        var startAnimationOnElement = function() {
                var animation = this,
                    $element = animation.element,
                    config = animation.config;
                animation.isStarted = true;
                return animation.strategy.animate($element, config).done(function() {
                        onElementAnimationComplete(animation)
                    }).fail(function() {
                        animation.deferred.rejectWith(this, [$element, config])
                    })
            };
        var stopAnimationOnElement = function(jumpToEnd) {
                var animation = this,
                    $element = animation.element,
                    config = animation.config;
                clearTimeout(animation.startTimeout);
                if (!animation.isStarted)
                    animation.start();
                animation.strategy.stop($element, config, jumpToEnd)
            };
        var createAnimation = function(element, initialConfig) {
                var defaultConfig = initialConfig.type === "css" ? defaultCssConfig : defaultJSConfig,
                    config = $.extend(true, {}, defaultConfig, initialConfig),
                    configurator = getAnimationConfigurator(config),
                    strategy = getAnimationStrategy(config),
                    animation = {
                        element: $(element),
                        config: config,
                        configurator: configurator,
                        strategy: strategy,
                        isSynchronous: strategy.isSynchronous,
                        setup: setupAnimationOnElement,
                        start: startAnimationOnElement,
                        stop: stopAnimationOnElement,
                        deferred: $.Deferred()
                    };
                if ($.isFunction(configurator.validateConfig))
                    configurator.validateConfig(config);
                return animation
            };
        var animate = function(element, config) {
                var $element = $(element);
                if (!$element.length)
                    return $.Deferred().resolve().promise();
                var animation = createAnimation($element, config);
                pushInAnimationQueue($element, animation);
                return animation.deferred.promise()
            };
        var pushInAnimationQueue = function($element, animation) {
                var queueData = getAnimQueueData($element);
                writeAnimQueueData($element, queueData);
                queueData.push(animation);
                if (!isAnimating($element))
                    shiftFromAnimationQueue($element, queueData)
            };
        var getAnimQueueData = function($element) {
                return $element.data(ANIM_QUEUE_KEY) || []
            };
        var writeAnimQueueData = function($element, queueData) {
                $element.data(ANIM_QUEUE_KEY, queueData)
            };
        var destroyAnimQueueData = function($element) {
                $element.removeData(ANIM_QUEUE_KEY)
            };
        var isAnimating = function($element) {
                return !!$element.data(ANIM_DATA_KEY)
            };
        var shiftFromAnimationQueue = function($element, queueData) {
                queueData = getAnimQueueData($element);
                if (!queueData.length)
                    return;
                var animation = queueData.shift();
                if (queueData.length === 0)
                    destroyAnimQueueData($element);
                executeAnimation(animation).done(function() {
                    shiftFromAnimationQueue($element)
                })
            };
        var executeAnimation = function(animation) {
                animation.setup();
                if (DX.fx.off || animation.isSynchronous)
                    animation.start();
                else {
                    animation.startTimeout = setTimeout(function() {
                        animation.start()
                    });
                    var namespacedRemoveEvent = eventUtils.addNamespace(removeEvent.name, "dxFXStartAnimation");
                    animation.element.off(namespacedRemoveEvent).on(namespacedRemoveEvent, function() {
                        clearTimeout(animation.startTimeout)
                    })
                }
                return animation.deferred.promise()
            };
        var setupPosition = function($element, config) {
                if (!config || !config.position)
                    return;
                var position = positionUtils.calculate($element, config.position),
                    offset = $element.offset(),
                    currentPosition = $element.position();
                $.extend(config, {
                    left: position.h.location - offset.left + currentPosition.left,
                    top: position.v.location - offset.top + currentPosition.top
                });
                delete config.position
            };
        var setProps = function($element, props) {
                $.each(props, function(key, value) {
                    try {
                        $element.css(key, value)
                    }
                    catch(e) {}
                })
            };
        var stop = function(element, jumpToEnd) {
                var $element = $(element),
                    queueData = getAnimQueueData($element);
                $.each(queueData, function(_, animation) {
                    animation.config.duration = 0;
                    animation.isSynchronous = true
                });
                if (!isAnimating($element))
                    shiftFromAnimationQueue($element, queueData);
                var animation = $element.data(ANIM_DATA_KEY);
                if (animation)
                    animation.stop(jumpToEnd);
                $element.removeData(ANIM_DATA_KEY);
                destroyAnimQueueData($element)
            };
        DX.fx = {
            off: false,
            animationTypes: animationConfigurators,
            animate: animate,
            createAnimation: createAnimation,
            isAnimating: isAnimating,
            stop: stop,
            _simulatedTransitionEndDelay: 100
        };
        DX.fx.__internals = {convertTransitionTimingFuncToJQueryEasing: convertTransitionTimingFuncToJQueryEasing}
    })(jQuery, DevExpress);
    /*! Module core, file validationEngine.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            EventsMixin = DX.require("/eventsMixin"),
            errors = DevExpress.require("/errors"),
            commonUtils = DX.require("/utils/utils.common");
        var rulesValidators = {
                required: {
                    validate: function(value, rule) {
                        if (!commonUtils.isDefined(value))
                            return false;
                        if (value === false)
                            return false;
                        value = String(value);
                        if (rule.trim || !commonUtils.isDefined(rule.trim))
                            value = $.trim(value);
                        return value !== ""
                    },
                    defaultMessage: function() {
                        return Globalize.localize("validation-required")
                    },
                    defaultFormattedMessage: function() {
                        return Globalize.localize("validation-required-formatted")
                    }
                },
                numeric: {
                    validate: function(value, rule) {
                        if (!rulesValidators.required.validate(value, {}))
                            return true;
                        if (rule.useCultureSettings && commonUtils.isString(value))
                            return !isNaN(Globalize.parseFloat(value));
                        else
                            return $.isNumeric(value)
                    },
                    defaultMessage: function() {
                        return Globalize.localize("validation-numeric")
                    },
                    defaultFormattedMessage: function() {
                        return Globalize.localize("validation-numeric-formatted")
                    }
                },
                range: {
                    validate: function(value, rule) {
                        if (!rulesValidators.required.validate(value, {}))
                            return true;
                        var validNumber = rulesValidators["numeric"].validate(value, rule),
                            validValue = commonUtils.isDefined(value),
                            number = validNumber ? parseFloat(value) : validValue && value.valueOf(),
                            min = rule.min,
                            max = rule.max;
                        if (!(validNumber || commonUtils.isDate(value)) && !validValue)
                            return false;
                        if (commonUtils.isDefined(min)) {
                            if (commonUtils.isDefined(max))
                                return number >= min && number <= max;
                            return number >= min
                        }
                        else if (commonUtils.isDefined(max))
                            return number <= max;
                        else
                            throw errors.Error("E0101");
                        return false
                    },
                    defaultMessage: function() {
                        return Globalize.localize("validation-range")
                    },
                    defaultFormattedMessage: function() {
                        return Globalize.localize("validation-range-formatted")
                    }
                },
                stringLength: {
                    validate: function(value, rule) {
                        value = commonUtils.isDefined(value) ? String(value) : "";
                        if (rule.trim || !commonUtils.isDefined(rule.trim))
                            value = $.trim(value);
                        return rulesValidators.range.validate(value.length, $.extend({}, rule))
                    },
                    defaultMessage: function() {
                        return Globalize.localize("validation-stringLength")
                    },
                    defaultFormattedMessage: function() {
                        return Globalize.localize("validation-stringLength-formatted")
                    }
                },
                custom: {
                    validate: function(value, rule) {
                        return rule.validationCallback({
                                value: value,
                                validator: rule.validator,
                                rule: rule
                            })
                    },
                    defaultMessage: function() {
                        return Globalize.localize("validation-custom")
                    },
                    defaultFormattedMessage: function() {
                        return Globalize.localize("validation-custom-formatted")
                    }
                },
                compare: {
                    validate: function(value, rule) {
                        if (!rule.comparisonTarget)
                            throw errors.Error("E0102");
                        $.extend(rule, {reevaluate: true});
                        var otherValue = rule.comparisonTarget(),
                            type = rule.comparisonType || "==";
                        switch (type) {
                            case"==":
                                return value == otherValue;
                            case"!=":
                                return value != otherValue;
                            case"===":
                                return value === otherValue;
                            case"!==":
                                return value !== otherValue;
                            case">":
                                return value > otherValue;
                            case">=":
                                return value >= otherValue;
                            case"<":
                                return value < otherValue;
                            case"<=":
                                return value <= otherValue
                        }
                    },
                    defaultMessage: function() {
                        return Globalize.localize("validation-compare")
                    },
                    defaultFormattedMessage: function() {
                        return Globalize.localize("validation-compare-formatted")
                    }
                },
                pattern: {
                    validate: function(value, rule) {
                        if (!rulesValidators.required.validate(value, {}))
                            return true;
                        var pattern = rule.pattern;
                        if (commonUtils.isString(pattern))
                            pattern = new RegExp(pattern);
                        return pattern.test(value)
                    },
                    defaultMessage: function() {
                        return Globalize.localize("validation-pattern")
                    },
                    defaultFormattedMessage: function() {
                        return Globalize.localize("validation-pattern-formatted")
                    }
                },
                email: {
                    validate: function(value, rule) {
                        if (!rulesValidators.required.validate(value, {}))
                            return true;
                        return rulesValidators.pattern.validate(value, $.extend({}, rule, {pattern: /^[\d\w\._\-]+@([\d\w\._\-]+\.)+[\w]+$/i}))
                    },
                    defaultMessage: function() {
                        return Globalize.localize("validation-email")
                    },
                    defaultFormattedMessage: function() {
                        return Globalize.localize("validation-email-formatted")
                    }
                }
            };
        var GroupConfig = Class.inherit({
                ctor: function(group) {
                    this.group = group;
                    this.validators = []
                },
                validate: function() {
                    var result = {
                            isValid: true,
                            brokenRules: [],
                            validators: []
                        };
                    $.each(this.validators, function(_, validator) {
                        var validatorResult = validator.validate();
                        result.isValid = result.isValid && validatorResult.isValid;
                        if (validatorResult.brokenRule)
                            result.brokenRules.push(validatorResult.brokenRule);
                        result.validators.push(validator)
                    });
                    this.fireEvent("validated", [{
                            validators: result.validators,
                            brokenRules: result.brokenRules,
                            isValid: result.isValid
                        }]);
                    return result
                },
                reset: function() {
                    $.each(this.validators, function(_, validator) {
                        validator.reset()
                    })
                }
            }).include(EventsMixin);
        DX.validationEngine = {
            groups: [],
            getGroupConfig: function(group) {
                var result = $.grep(this.groups, function(config) {
                        return config.group === group
                    });
                if (result.length)
                    return result[0]
            },
            initGroups: function() {
                this.groups = [];
                this.addGroup()
            },
            addGroup: function(group) {
                var config = this.getGroupConfig(group);
                if (!config) {
                    config = new GroupConfig(group);
                    this.groups.push(config)
                }
                return config
            },
            removeGroup: function(group) {
                var config = this.getGroupConfig(group),
                    index = $.inArray(config, this.groups);
                if (index > -1)
                    this.groups.splice(index, 1);
                return config
            },
            _setDefaultMessage: function(rule, validator, name) {
                if (!commonUtils.isDefined(rule.message))
                    if (validator.defaultFormattedMessage && commonUtils.isDefined(name))
                        rule.message = validator.defaultFormattedMessage().replace(/\{0\}/, name);
                    else
                        rule.message = validator.defaultMessage()
            },
            validate: function validate(value, rules, name) {
                var result = {
                        name: name,
                        value: value,
                        brokenRule: null,
                        isValid: true,
                        validationRules: rules
                    },
                    that = this;
                $.each(rules || [], function(_, rule) {
                    var ruleValidator = rulesValidators[rule.type],
                        ruleValidationResult;
                    if (ruleValidator) {
                        if (commonUtils.isDefined(rule.isValid) && rule.value === value && !rule.reevaluate) {
                            if (!rule.isValid) {
                                result.isValid = false;
                                result.brokenRule = rule;
                                return false
                            }
                            return true
                        }
                        rule.value = value;
                        ruleValidationResult = ruleValidator.validate(value, rule);
                        rule.isValid = ruleValidationResult;
                        if (!ruleValidationResult) {
                            result.isValid = false;
                            that._setDefaultMessage(rule, ruleValidator, name);
                            result.brokenRule = rule
                        }
                        if (!rule.isValid)
                            return false
                    }
                    else
                        throw errors.Error("E0100");
                });
                return result
            },
            registerValidatorInGroup: function(group, validator) {
                var groupConfig = DX.validationEngine.addGroup(group);
                if ($.inArray(validator, groupConfig.validators) < 0)
                    groupConfig.validators.push(validator)
            },
            removeRegistredValidator: function(group, validator) {
                var config = DX.validationEngine.getGroupConfig(group),
                    validatorsInGroup = config && config.validators;
                var index = $.inArray(validator, validatorsInGroup);
                if (index > -1)
                    validatorsInGroup.splice(index, 1)
            },
            validateGroup: function(group) {
                var groupConfig = DX.validationEngine.getGroupConfig(group);
                if (!groupConfig)
                    throw errors.Error("E0110");
                return groupConfig.validate()
            },
            resetGroup: function(group) {
                var groupConfig = DX.validationEngine.getGroupConfig(group);
                if (!groupConfig)
                    throw errors.Error("E0110");
                return groupConfig.reset()
            }
        };
        DX.validationEngine.initGroups()
    })(jQuery, DevExpress);
    /*! Module core, file transitionExecutor.js */
    (function($, DX) {
        var Class = DevExpress.require("/class"),
            commonUtils = DX.require("/utils/utils.common"),
            Component = DX.require("/component"),
            devices = DX.require("/devices");
        var directionPostfixes = {
                forward: " dx-forward",
                backward: " dx-backward",
                none: " dx-no-direction",
                undefined: " dx-no-direction"
            },
            DX_ANIMATING_CLASS = "dx-animating";
        var TransitionExecutor = Class.inherit({
                ctor: function() {
                    this._accumulatedDelays = {
                        enter: 0,
                        leave: 0
                    };
                    this._animations = [];
                    this.reset()
                },
                _createAnimations: function($elements, initialConfig, configModifier, type) {
                    var that = this,
                        result = [],
                        animationConfig;
                    configModifier = configModifier || {};
                    animationConfig = this._prepareElementAnimationConfig(initialConfig, configModifier, type);
                    if (animationConfig)
                        $elements.each(function() {
                            var animation = that._createAnimation($(this), animationConfig, configModifier);
                            if (animation) {
                                animation.element.addClass(DX_ANIMATING_CLASS);
                                animation.setup();
                                result.push(animation)
                            }
                        });
                    return result
                },
                _prepareElementAnimationConfig: function(config, configModifier, type) {
                    var result;
                    if (typeof config === "string") {
                        var presetName = config;
                        config = DX.animationPresets.getPreset(presetName)
                    }
                    if (!config)
                        result = undefined;
                    else if ($.isFunction(config[type]))
                        result = config[type];
                    else {
                        result = $.extend({
                            skipElementInitialStyles: true,
                            cleanupWhen: this._completePromise
                        }, config, configModifier);
                        if (!result.type || result.type === "css") {
                            var cssClass = "dx-" + type,
                                extraCssClasses = (result.extraCssClasses ? " " + result.extraCssClasses : "") + directionPostfixes[result.direction];
                            result.type = "css";
                            result.from = (result.from || cssClass) + extraCssClasses;
                            result.to = result.to || cssClass + "-active"
                        }
                        result.staggerDelay = result.staggerDelay || 0;
                        result.delay = result.delay || 0;
                        if (result.staggerDelay) {
                            result.delay += this._accumulatedDelays[type];
                            this._accumulatedDelays[type] += result.staggerDelay
                        }
                    }
                    return result
                },
                _createAnimation: function($element, animationConfig, configModifier) {
                    var result;
                    if ($.isPlainObject(animationConfig))
                        result = DX.fx.createAnimation($element, animationConfig);
                    else if ($.isFunction(animationConfig))
                        result = animationConfig($element, configModifier);
                    return result
                },
                _startAnimations: function() {
                    var animations = this._animations;
                    for (var i = 0; i < animations.length; i++)
                        animations[i].start()
                },
                _stopAnimations: function() {
                    var animations = this._animations;
                    for (var i = 0; i < animations.length; i++)
                        animations[i].stop()
                },
                _clearAnimations: function() {
                    var animations = this._animations;
                    for (var i = 0; i < animations.length; i++)
                        animations[i].element.removeClass(DX_ANIMATING_CLASS);
                    this._animations.length = 0
                },
                reset: function() {
                    this._accumulatedDelays.enter = 0;
                    this._accumulatedDelays.leave = 0;
                    this._clearAnimations();
                    this._completeDeferred = $.Deferred();
                    this._completePromise = this._completeDeferred.promise()
                },
                enter: function($elements, animationConfig, configModifier) {
                    var animations = this._createAnimations($elements, animationConfig, configModifier, "enter");
                    this._animations.push.apply(this._animations, animations)
                },
                leave: function($elements, animationConfig, configModifier) {
                    var animations = this._createAnimations($elements, animationConfig, configModifier, "leave");
                    this._animations.push.apply(this._animations, animations)
                },
                start: function() {
                    var that = this,
                        result;
                    if (!this._animations.length) {
                        that.reset();
                        result = $.Deferred().resolve().promise()
                    }
                    else {
                        var animationDeferreds = $.map(this._animations, function(animation) {
                                var result = $.Deferred();
                                animation.deferred.always(function() {
                                    result.resolve()
                                });
                                return result.promise()
                            });
                        result = $.when.apply($, animationDeferreds).always(function() {
                            that._completeDeferred.resolve();
                            that.reset()
                        });
                        commonUtils.executeAsync(function() {
                            that._startAnimations()
                        })
                    }
                    return result
                },
                stop: function() {
                    this._stopAnimations()
                }
            });
        var optionPrefix = "preset_";
        var AnimationPresetCollection = Component.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    this._customRules = [];
                    this._registeredPresets = [];
                    this.resetToDefaults()
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            defaultAnimationDuration: 400,
                            defaultAnimationDelay: 0,
                            defaultStaggerAnimationDuration: 300,
                            defaultStaggerAnimationDelay: 40,
                            defaultStaggerAnimationStartDelay: 500
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return device.phone
                                },
                                options: {
                                    defaultStaggerAnimationDuration: 350,
                                    defaultStaggerAnimationDelay: 50,
                                    defaultStaggerAnimationStartDelay: 0
                                }
                            }, {
                                device: function() {
                                    return devices.current().android || devices.real.android
                                },
                                options: {defaultAnimationDelay: 100}
                            }])
                },
                _getPresetOptionName: function(animationName) {
                    return optionPrefix + animationName
                },
                _createAndroidSlideAnimationConfig: function(throughOpacity, widthMultiplier) {
                    var that = this;
                    return {
                            enter: function($element, configModifier) {
                                var width = $element.parent().width() * widthMultiplier,
                                    direction = configModifier.direction,
                                    config = {
                                        type: "slide",
                                        delay: that.option("defaultAnimationDelay"),
                                        duration: configModifier.duration === undefined ? that.option("defaultAnimationDuration") : configModifier.duration,
                                        to: {
                                            left: 0,
                                            opacity: 1
                                        }
                                    };
                                if (direction === "forward")
                                    config.from = {
                                        left: width,
                                        opacity: throughOpacity
                                    };
                                else if (direction === "backward")
                                    config.from = {
                                        left: -width,
                                        opacity: throughOpacity
                                    };
                                else
                                    config.from = {
                                        left: 0,
                                        opacity: 0
                                    };
                                return DX.fx.createAnimation($element, config)
                            },
                            leave: function($element, configModifier) {
                                var width = $element.parent().width() * widthMultiplier,
                                    direction = configModifier.direction,
                                    config = {
                                        type: "slide",
                                        delay: that.option("defaultAnimationDelay"),
                                        duration: configModifier.duration === undefined ? that.option("defaultAnimationDuration") : configModifier.duration,
                                        from: {
                                            left: 0,
                                            opacity: 1
                                        }
                                    };
                                if (direction === "forward")
                                    config.to = {
                                        left: -width,
                                        opacity: throughOpacity
                                    };
                                else if (direction === "backward")
                                    config.to = {
                                        left: width,
                                        opacity: throughOpacity
                                    };
                                else
                                    config.to = {
                                        left: 0,
                                        opacity: 0
                                    };
                                return DX.fx.createAnimation($element, config)
                            }
                        }
                },
                _createOpenDoorConfig: function() {
                    var that = this,
                        baseConfig = {
                            type: "css",
                            extraCssClasses: "dx-opendoor-animation",
                            duration: that.option("defaultAnimationDuration")
                        };
                    return {
                            enter: function($element, configModifier) {
                                var config = baseConfig,
                                    direction = configModifier.direction;
                                config.delay = direction === "none" ? that.option("defaultAnimationDelay") : that.option("defaultAnimationDuration");
                                config.from = "dx-enter dx-opendoor-animation" + directionPostfixes[direction];
                                config.to = "dx-enter-active";
                                return DX.fx.createAnimation($element, config)
                            },
                            leave: function($element, configModifier) {
                                var config = baseConfig,
                                    direction = configModifier.direction;
                                config.delay = that.option("defaultAnimationDelay");
                                config.from = "dx-leave dx-opendoor-animation" + directionPostfixes[direction];
                                config.to = "dx-leave-active";
                                return DX.fx.createAnimation($element, config)
                            }
                        }
                },
                resetToDefaults: function() {
                    this.clear();
                    this.registerDefaultPresets();
                    this.applyChanges()
                },
                clear: function(name) {
                    var that = this,
                        newRegisteredPresets = [];
                    $.each(this._registeredPresets, function(index, preset) {
                        if (!name || name === preset.name)
                            that.option(that._getPresetOptionName(preset.name), undefined);
                        else
                            newRegisteredPresets.push(preset)
                    });
                    this._registeredPresets = newRegisteredPresets;
                    this.applyChanges()
                },
                registerPreset: function(name, config) {
                    this._registeredPresets.push({
                        name: name,
                        config: config
                    })
                },
                applyChanges: function() {
                    var that = this;
                    this._customRules.length = 0;
                    $.each(this._registeredPresets, function(index, preset) {
                        var rule = {
                                device: preset.config.device,
                                options: {}
                            };
                        rule.options[that._getPresetOptionName(preset.name)] = preset.config.animation;
                        that._customRules.push(rule)
                    });
                    this._setOptionsByDevice()
                },
                getPreset: function(name) {
                    var result = name;
                    while (typeof result === "string")
                        result = this.option(this._getPresetOptionName(result));
                    return result
                },
                registerDefaultPresets: function() {
                    this.registerPreset("pop", {animation: {
                            extraCssClasses: "dx-android-pop-animation",
                            delay: this.option("defaultAnimationDelay"),
                            duration: this.option("defaultAnimationDuration")
                        }});
                    this.registerPreset("openDoor", {animation: this._createOpenDoorConfig()});
                    this.registerPreset("fade", {animation: {
                            extraCssClasses: "dx-fade-animation",
                            delay: this.option("defaultAnimationDelay"),
                            duration: this.option("defaultAnimationDuration")
                        }});
                    this.registerPreset("slide", {
                        device: function() {
                            return devices.current().android || devices.real.android
                        },
                        animation: this._createAndroidSlideAnimationConfig(1, 1)
                    });
                    this.registerPreset("slide", {
                        device: function() {
                            return !devices.current().android && !devices.real.android
                        },
                        animation: {
                            extraCssClasses: "dx-slide-animation",
                            delay: this.option("defaultAnimationDelay"),
                            duration: this.option("defaultAnimationDuration")
                        }
                    });
                    this.registerPreset("ios7-slide", {animation: {
                            extraCssClasses: "dx-ios7-slide-animation",
                            delay: this.option("defaultAnimationDelay"),
                            duration: this.option("defaultAnimationDuration")
                        }});
                    this.registerPreset("overflow", {animation: {
                            extraCssClasses: "dx-overflow-animation",
                            delay: this.option("defaultAnimationDelay"),
                            duration: this.option("defaultAnimationDuration")
                        }});
                    this.registerPreset("ios7-toolbar", {
                        device: function() {
                            return !devices.current().android && !devices.real.android
                        },
                        animation: {
                            extraCssClasses: "dx-ios7-toolbar-animation",
                            delay: this.option("defaultAnimationDelay"),
                            duration: this.option("defaultAnimationDuration")
                        }
                    });
                    this.registerPreset("ios7-toolbar", {
                        device: function() {
                            return devices.current().android || devices.real.android
                        },
                        animation: this._createAndroidSlideAnimationConfig(0, 0.4)
                    });
                    this.registerPreset("stagger-fade", {animation: {
                            extraCssClasses: "dx-fade-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }});
                    this.registerPreset("stagger-slide", {animation: {
                            extraCssClasses: "dx-slide-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }});
                    this.registerPreset("stagger-fade-slide", {animation: {
                            extraCssClasses: "dx-fade-slide-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }});
                    this.registerPreset("stagger-drop", {animation: {
                            extraCssClasses: "dx-drop-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }});
                    this.registerPreset("stagger-fade-drop", {animation: {
                            extraCssClasses: "dx-fade-drop-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }});
                    this.registerPreset("stagger-3d-drop", {animation: {
                            extraCssClasses: "dx-3d-drop-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }});
                    this.registerPreset("stagger-fade-zoom", {animation: {
                            extraCssClasses: "dx-fade-zoom-animation",
                            staggerDelay: this.option("defaultStaggerAnimationDelay"),
                            duration: this.option("defaultStaggerAnimationDuration"),
                            delay: this.option("defaultStaggerAnimationStartDelay")
                        }})
                }
            });
        DX.TransitionExecutor = TransitionExecutor;
        DX.AnimationPresetCollection = AnimationPresetCollection;
        DX.animationPresets = new AnimationPresetCollection
    })(jQuery, DevExpress);
    /*! Module core, file jquery.defaultTemplates.js */
    DevExpress.define("/integration/jquery/jquery.defaultTemplates", ["jquery", "/utils/utils.inflector", "/utils/utils.icon", "/utils/utils.date"], function($, inflector, iconUtils, dateUtils) {
        var camelize = inflector.camelize;
        var TEMPLATE_GENERATORS = {};
        var emptyTemplate = function() {
                return $()
            };
        var ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder";
        TEMPLATE_GENERATORS.CollectionWidget = {
            item: function(itemData) {
                var $itemContent = $("<div>");
                if ($.isPlainObject(itemData)) {
                    if (itemData.text)
                        $itemContent.text(itemData.text);
                    if (itemData.html)
                        $itemContent.html(itemData.html)
                }
                else
                    $itemContent.text(String(itemData));
                return $itemContent
            },
            itemFrame: function(itemData) {
                var $itemFrame = $("<div>");
                $itemFrame.toggleClass("dx-state-invisible", itemData.visible !== undefined && !itemData.visible);
                $itemFrame.toggleClass("dx-state-disabled", !!itemData.disabled);
                var $placeholder = $("<div>").addClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
                $itemFrame.append($placeholder);
                return $itemFrame
            }
        };
        var BUTTON_TEXT_CLASS = "dx-button-text";
        TEMPLATE_GENERATORS.dxButton = {content: function(itemData) {
                var $itemContent = $("<div>"),
                    $iconElement = iconUtils.getImageContainer(itemData.icon),
                    $textContainer = itemData.text ? $("<span>").text(itemData.text).addClass(BUTTON_TEXT_CLASS) : undefined;
                $itemContent.append($iconElement).append($textContainer);
                return $itemContent
            }};
        var LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container",
            LIST_ITEM_BADGE_CLASS = "dx-list-item-badge",
            BADGE_CLASS = "dx-badge",
            LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container",
            LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
        TEMPLATE_GENERATORS.dxList = {
            item: function(itemData) {
                var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.item(itemData);
                if (itemData.key) {
                    var $key = $("<div>").text(itemData.key);
                    $key.appendTo($itemContent)
                }
                return $itemContent
            },
            itemFrame: function(itemData) {
                var $itemFrame = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(itemData);
                if (itemData.badge) {
                    var $badgeContainer = $("<div>").addClass(LIST_ITEM_BADGE_CONTAINER_CLASS),
                        $badge = $("<div>").addClass(LIST_ITEM_BADGE_CLASS).addClass(BADGE_CLASS);
                    $badge.text(itemData.badge);
                    $badgeContainer.append($badge).appendTo($itemFrame)
                }
                if (itemData.showChevron) {
                    var $chevronContainer = $("<div>").addClass(LIST_ITEM_CHEVRON_CONTAINER_CLASS),
                        $chevron = $("<div>").addClass(LIST_ITEM_CHEVRON_CLASS);
                    $chevronContainer.append($chevron).appendTo($itemFrame)
                }
                return $itemFrame
            },
            group: function(groupData) {
                var $groupContent = $("<div>");
                if ($.isPlainObject(groupData)) {
                    if (groupData.key)
                        $groupContent.text(groupData.key)
                }
                else
                    $groupContent.html(String(groupData));
                return $groupContent
            }
        };
        TEMPLATE_GENERATORS.dxDropDownMenu = {
            item: TEMPLATE_GENERATORS.dxList.item,
            content: TEMPLATE_GENERATORS.dxButton.content
        };
        TEMPLATE_GENERATORS.dxDropDownList = {item: TEMPLATE_GENERATORS.dxList.item};
        TEMPLATE_GENERATORS.dxRadioGroup = {item: TEMPLATE_GENERATORS.CollectionWidget.item};
        TEMPLATE_GENERATORS.dxScheduler = {
            item: function(itemData) {
                var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.item(itemData);
                var $details = $("<div>").addClass("dx-scheduler-appointment-content-details");
                if (itemData.startDate)
                    $("<div>").text(Globalize.format(dateUtils.makeDate(itemData.startDate), "t")).addClass("dx-scheduler-appointment-content-date").appendTo($details);
                if (itemData.endDate) {
                    $("<div>").text(" - ").addClass("dx-scheduler-appointment-content-date").appendTo($details);
                    $("<div>").text(Globalize.format(dateUtils.makeDate(itemData.endDate), "t")).addClass("dx-scheduler-appointment-content-date").appendTo($details)
                }
                $details.appendTo($itemContent);
                if (itemData.recurrenceRule)
                    $("<span>").addClass("dx-scheduler-appointment-recurrence-icon dx-icon-repeat").appendTo($itemContent);
                return $itemContent
            },
            appointmentTooltip: emptyTemplate,
            appointmentPopup: emptyTemplate
        };
        TEMPLATE_GENERATORS.dxOverlay = {content: emptyTemplate};
        TEMPLATE_GENERATORS.dxSlideOutView = {
            menu: emptyTemplate,
            content: emptyTemplate
        };
        TEMPLATE_GENERATORS.dxSlideOut = {
            menuItem: TEMPLATE_GENERATORS.dxList.item,
            menuGroup: TEMPLATE_GENERATORS.dxList.group,
            content: emptyTemplate
        };
        TEMPLATE_GENERATORS.dxAccordion = {
            title: function(titleData) {
                var $titleContent = $("<div>"),
                    icon = titleData.icon,
                    iconSrc = titleData.iconSrc,
                    $iconElement = iconUtils.getImageContainer(icon || iconSrc);
                if ($.isPlainObject(titleData)) {
                    if (titleData.title)
                        $titleContent.text(titleData.title)
                }
                else
                    $titleContent.html(String(titleData));
                $iconElement && $iconElement.prependTo($titleContent);
                return $titleContent
            },
            item: TEMPLATE_GENERATORS.CollectionWidget.item
        };
        TEMPLATE_GENERATORS.dxActionSheet = {item: function(itemData) {
                return $("<div>").append($("<div>").dxButton($.extend({onClick: itemData.click}, itemData)))
            }};
        var GALLERY_IMAGE_CLASS = "dx-gallery-item-image";
        TEMPLATE_GENERATORS.dxGallery = {item: function(itemData) {
                var $itemContent = $("<div>"),
                    $img = $('<img>').addClass(GALLERY_IMAGE_CLASS);
                if ($.isPlainObject(itemData))
                    $img.attr({
                        src: itemData.imageSrc,
                        alt: itemData.imageAlt
                    }).appendTo($itemContent);
                else
                    $img.attr('src', String(itemData)).appendTo($itemContent);
                return $itemContent
            }};
        var DX_MENU_ITEM_CAPTION_CLASS = 'dx-menu-item-text',
            DX_MENU_ITEM_POPOUT_CLASS = 'dx-menu-item-popout',
            DX_MENU_ITEM_POPOUT_CONTAINER_CLASS = 'dx-menu-item-popout-container';
        TEMPLATE_GENERATORS.dxMenuBase = {item: function(itemData) {
                var $itemContent = $("<div>"),
                    icon = itemData.icon,
                    iconSrc = itemData.iconSrc,
                    $iconElement = iconUtils.getImageContainer(icon || iconSrc);
                $iconElement && $iconElement.appendTo($itemContent);
                var $itemCaption;
                if ($.isPlainObject(itemData) && itemData.text)
                    $itemCaption = $('<span>').addClass(DX_MENU_ITEM_CAPTION_CLASS).text(itemData.text);
                else if (!$.isPlainObject(itemData))
                    $itemCaption = $('<span>').addClass(DX_MENU_ITEM_CAPTION_CLASS).html(String(itemData));
                $itemContent.append($itemCaption);
                var $popOutImage,
                    $popOutContainer;
                if (itemData.items && itemData.items.length > 0) {
                    $popOutContainer = $('<span>').addClass(DX_MENU_ITEM_POPOUT_CONTAINER_CLASS).appendTo($itemContent);
                    $popOutImage = $('<div>').addClass(DX_MENU_ITEM_POPOUT_CLASS).appendTo($popOutContainer)
                }
                return $itemContent
            }};
        var PANORAMA_ITEM_TITLE_CLASS = "dx-panorama-item-title";
        TEMPLATE_GENERATORS.dxPanorama = {itemFrame: function(itemData) {
                var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(itemData);
                if (itemData.title) {
                    var $itemHeader = $("<div>").addClass(PANORAMA_ITEM_TITLE_CLASS).text(itemData.title);
                    $itemContent.prepend($itemHeader)
                }
                return $itemContent
            }};
        TEMPLATE_GENERATORS.dxPivotTabs = {item: function(itemData) {
                var $itemContent = $("<div>");
                var $itemText;
                if (itemData && itemData.title)
                    $itemText = $("<span>").text(itemData.title);
                else
                    $itemText = $("<span>").text(String(itemData));
                $itemContent.html($itemText);
                return $itemContent
            }};
        TEMPLATE_GENERATORS.dxPivot = {
            title: TEMPLATE_GENERATORS.dxPivotTabs.item,
            content: emptyTemplate
        };
        var TABS_ITEM_TEXT_CLASS = "dx-tab-text";
        TEMPLATE_GENERATORS.dxTabs = {
            item: function(itemData) {
                var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.item(itemData);
                if (itemData.html)
                    return $itemContent;
                var icon = itemData.icon,
                    iconSrc = itemData.iconSrc,
                    $iconElement = iconUtils.getImageContainer(icon || iconSrc);
                if (!itemData.html)
                    $itemContent.wrapInner($("<span>").addClass(TABS_ITEM_TEXT_CLASS));
                $iconElement && $iconElement.prependTo($itemContent);
                return $itemContent
            },
            itemFrame: function(itemData) {
                var $badge = $(),
                    $itemFrame = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(itemData);
                if (itemData.badge)
                    $badge = $("<div>", {"class": "dx-tabs-item-badge dx-badge"}).text(itemData.badge);
                $itemFrame.append($badge);
                return $itemFrame
            }
        };
        TEMPLATE_GENERATORS.dxTabPanel = {
            item: TEMPLATE_GENERATORS.CollectionWidget.item,
            title: function(itemData) {
                var itemTitleData = itemData;
                if ($.isPlainObject(itemData))
                    itemTitleData = $.extend({}, itemData, {
                        text: itemData.title,
                        html: null
                    });
                var $title = TEMPLATE_GENERATORS.dxTabs.item(itemTitleData);
                return $title
            }
        };
        var NAVBAR_ITEM_BADGE_CLASS = "dx-navbar-item-badge";
        TEMPLATE_GENERATORS.dxNavBar = {itemFrame: function(itemData) {
                var $itemFrame = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(itemData);
                if (itemData.badge) {
                    var $badge = $("<div>").addClass(NAVBAR_ITEM_BADGE_CLASS).addClass(BADGE_CLASS);
                    $badge.text(itemData.badge);
                    $badge.appendTo($itemFrame)
                }
                return $itemFrame
            }};
        TEMPLATE_GENERATORS.dxToolbar = {
            item: function(itemData) {
                var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.item(itemData);
                var widget = itemData.widget;
                if (widget) {
                    var widgetElement = $("<div>").appendTo($itemContent),
                        widgetName = camelize("dx-" + widget),
                        options = itemData.options || {};
                    widgetElement[widgetName](options)
                }
                else if (itemData.text)
                    $itemContent.wrapInner("<div>");
                return $itemContent
            },
            menuItem: TEMPLATE_GENERATORS.dxList.item,
            actionSheetItem: TEMPLATE_GENERATORS.dxActionSheet.item
        };
        TEMPLATE_GENERATORS.dxTreeView = {item: function(itemData) {
                var $itemContent = $("<div>"),
                    icon = itemData.icon,
                    iconSrc = itemData.iconSrc,
                    $iconElement = iconUtils.getImageContainer(icon || iconSrc);
                if (itemData.html)
                    $itemContent.html(itemData.html);
                else {
                    $iconElement && $iconElement.appendTo($itemContent);
                    $("<span>").text(itemData.text).appendTo($itemContent)
                }
                return $itemContent
            }};
        var popupTitleAndBottom = function(itemData) {
                return $("<div>").append($("<div>").dxToolbar({items: itemData}))
            };
        TEMPLATE_GENERATORS.dxPopup = {
            title: popupTitleAndBottom,
            bottom: popupTitleAndBottom
        };
        TEMPLATE_GENERATORS.dxLookup = {
            title: TEMPLATE_GENERATORS.dxPopup.title,
            group: TEMPLATE_GENERATORS.dxList.group
        };
        TEMPLATE_GENERATORS.dxTagBox = {tag: function(itemData) {
                return $("<div>").append($("<span>").text(itemData))
            }};
        TEMPLATE_GENERATORS.dxCalendar = {cell: function(itemData) {
                return $("<div>").append($("<span>").text(itemData.text || String(itemData)))
            }};
        return TEMPLATE_GENERATORS
    });
    /*! Module core, file jquery.template.js */
    DevExpress.define("/integration/jquery/jquery.template", ["jquery", "/ui/templates/ui.templateBase", "/errors", "/utils/utils.common", "/utils/utils.dom"], function($, TemplateBase, errors, commonUtils, domUtils) {
        var templateEngines = {};
        var registerTemplateEngine = function(name, templateEngine) {
                templateEngines[name] = templateEngine
            };
        var outerHtml = function(element) {
                element = $(element);
                if (!element.length || element[0].nodeName.toLowerCase() !== "script")
                    element = $("<div>").append(element);
                return element.html()
            };
        registerTemplateEngine("default", {
            compile: function(element) {
                return domUtils.normalizeTemplateElement(element)
            },
            render: function(template, data) {
                return template.clone()
            }
        });
        registerTemplateEngine("jquery-tmpl", {
            compile: function(element) {
                return $("<div>").append(domUtils.normalizeTemplateElement(element))
            },
            render: function(template, data) {
                return template.tmpl(data)
            }
        });
        registerTemplateEngine("jsrender", {
            compile: function(element) {
                return $.templates(outerHtml(element))
            },
            render: function(template, data) {
                return template.render(data)
            }
        });
        registerTemplateEngine("mustache", {
            compile: function(element) {
                return Mustache.compile(outerHtml(element))
            },
            render: function(template, data) {
                return template(data)
            }
        });
        registerTemplateEngine("hogan", {
            compile: function(element) {
                return Hogan.compile(outerHtml(element))
            },
            render: function(template, data) {
                return template.render(data)
            }
        });
        registerTemplateEngine("underscore", {
            compile: function(element) {
                return _.template(outerHtml(element))
            },
            render: function(template, data) {
                return template(data)
            }
        });
        registerTemplateEngine("handlebars", {
            compile: function(element) {
                return Handlebars.compile(outerHtml(element))
            },
            render: function(template, data) {
                return template(data)
            }
        });
        registerTemplateEngine("doT", {
            compile: function(element) {
                return doT.template(outerHtml(element))
            },
            render: function(template, data) {
                return template(data)
            }
        });
        var currentTemplateEngine;
        var setTemplateEngine = function(templateEngine) {
                if (commonUtils.isString(templateEngine)) {
                    currentTemplateEngine = templateEngines[templateEngine];
                    if (!currentTemplateEngine)
                        throw errors.Error("E0020", templateEngine);
                }
                else
                    currentTemplateEngine = templateEngine
            };
        setTemplateEngine("default");
        var Template = TemplateBase.inherit({
                ctor: function(element, owner) {
                    this.callBase(element, owner);
                    this._compiledTemplate = currentTemplateEngine.compile(element)
                },
                _renderCore: function(data) {
                    return $("<div>").append(currentTemplateEngine.render(this._compiledTemplate, data)).contents()
                }
            });
        Template.setTemplateEngine = setTemplateEngine;
        return Template
    });
    /*! Module core, file jquery.templateProvider.js */
    DevExpress.define("/integration/jquery/jquery.templateProvider", ["jquery", "/ui/templates/ui.templateProviderBase", "/integration/jquery/jquery.template", "/ui/templates/ui.template.function", "/integration/jquery/jquery.defaultTemplates"], function($, TemplateProviderBase, Template, FunctionTempalte, defaultTemplates) {
        var TemplateProvider = TemplateProviderBase.inherit({
                createTemplate: function(element, owner) {
                    return new Template(element, owner)
                },
                _templatesForWidget: function(widgetName) {
                    var templateGenerators = defaultTemplates[widgetName] || {},
                        templates = {};
                    $.each(templateGenerators, function(name, generator) {
                        templates[name] = new FunctionTempalte(function() {
                            var $markup = generator.apply(this, arguments);
                            if (name !== "itemFrame")
                                $markup = $markup.contents();
                            return $markup
                        }, templateProvider)
                    });
                    return templates
                }
            });
        var templateProvider = new TemplateProvider;
        return templateProvider
    });
    /*! Module core, file jquery.selectors.js */
    DevExpress.define("/integration/jquery/jquery.selectors", ["jquery"], function($) {
        var focusable = function(element, tabIndex) {
                var nodeName = element.nodeName.toLowerCase(),
                    isTabIndexNotNaN = !isNaN(tabIndex),
                    isVisible = visible(element),
                    isDisabled = element.disabled,
                    isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName),
                    isHyperlink = nodeName === "a",
                    isFocusable = true;
                if (isDefaultFocus)
                    isFocusable = !isDisabled;
                else if (isHyperlink)
                    isFocusable = element.href || isTabIndexNotNaN;
                else
                    isFocusable = isTabIndexNotNaN;
                return isVisible ? isFocusable : false
            };
        var visible = function(element) {
                var $element = $(element);
                return $element.is(":visible") && $element.css("visibility") !== "hidden" && $element.parents().css("visibility") !== "hidden"
            };
        var icontains = function(elem, text) {
                var result = false;
                $.each($(elem).contents(), function(index, content) {
                    if (content.nodeType === 3 && (content.textContent || content.nodeValue || "").toLowerCase().indexOf((text || "").toLowerCase()) > -1) {
                        result = true;
                        return false
                    }
                });
                return result
            };
        $.extend($.expr[':'], {
            "dx-focusable": function(element) {
                return focusable(element, $.attr(element, "tabindex"))
            },
            "dx-tabbable": function(element) {
                var tabIndex = $.attr(element, "tabindex");
                return (isNaN(tabIndex) || tabIndex >= 0) && focusable(element, tabIndex)
            },
            "dx-icontains": $.expr.createPseudo(function(text) {
                return function(elem) {
                        return icontains(elem, text)
                    }
            })
        });
        return {
                focusable: ":dx-focusable",
                tabbable: ":dx-tabbable",
                icontains: ":dx-icontains"
            }
    });
    /*! Module core, file ko.componentRegistrator.js */
    DevExpress.define("/integration/knockout/ko.componentRegistrator", ["jquery", "/componentRegistrator", "/errors", "/ui/ui.widget", "/integration/knockout/ko.templateProvider", "/ui/ui.editor"], function($, registerComponent, errors, Widget, KoTemplateProvider, Editor) {
        var ko = window.ko;
        var LOCKS_DATA_KEY = "dxKoLocks",
            CREATED_WITH_KO_DATA_KEY = "dxKoCreation";
        var Locks = function() {
                var info = {};
                var currentCount = function(lockName) {
                        return info[lockName] || 0
                    };
                return {
                        obtain: function(lockName) {
                            info[lockName] = currentCount(lockName) + 1
                        },
                        release: function(lockName) {
                            var count = currentCount(lockName);
                            if (count < 1)
                                throw errors.Error("E0014");
                            if (count === 1)
                                delete info[lockName];
                            else
                                info[lockName] = count - 1
                        },
                        locked: function(lockName) {
                            return currentCount(lockName) > 0
                        }
                    }
            };
        var editorsBingindHandlers = [];
        var registerComponentKoBinding = function(componentName, componentClass) {
                if (componentClass.subclassOf(Editor))
                    editorsBingindHandlers.push(componentName);
                ko.bindingHandlers[componentName] = {init: function(domNode, valueAccessor) {
                        var $element = $(domNode),
                            optionChangedCallbacks = $.Callbacks(),
                            ctorOptions = {
                                templateProvider: KoTemplateProvider,
                                modelByElement: function($element) {
                                    if ($element.length)
                                        return ko.dataFor($element.get(0))
                                },
                                nestedComponentOptions: function(component) {
                                    return {
                                            modelByElement: component.option("modelByElement"),
                                            nestedComponentOptions: component.option("nestedComponentOptions")
                                        }
                                },
                                _optionChangedCallbacks: optionChangedCallbacks
                            },
                            optionNameToModelMap = {};
                        var applyModelValueToOption = function(optionName, modelValue) {
                                var component = $element.data(componentName),
                                    locks = $element.data(LOCKS_DATA_KEY),
                                    optionValue = ko.unwrap(modelValue);
                                if (ko.isWriteableObservable(modelValue))
                                    optionNameToModelMap[optionName] = modelValue;
                                if (component) {
                                    if (locks.locked(optionName))
                                        return;
                                    locks.obtain(optionName);
                                    try {
                                        component.option(optionName, optionValue)
                                    }
                                    finally {
                                        locks.release(optionName)
                                    }
                                }
                                else
                                    ctorOptions[optionName] = optionValue
                            };
                        var handleOptionChanged = function(args) {
                                var optionName = args.fullName,
                                    optionValue = args.value;
                                if (!(optionName in optionNameToModelMap))
                                    return;
                                var $element = this._$element,
                                    locks = $element.data(LOCKS_DATA_KEY);
                                if (locks.locked(optionName))
                                    return;
                                locks.obtain(optionName);
                                try {
                                    optionNameToModelMap[optionName](optionValue)
                                }
                                finally {
                                    locks.release(optionName)
                                }
                            };
                        var createComponent = function() {
                                optionChangedCallbacks.add(handleOptionChanged);
                                $element.data(CREATED_WITH_KO_DATA_KEY, true).data(LOCKS_DATA_KEY, new Locks)[componentName](ctorOptions);
                                ctorOptions = null
                            };
                        var unwrapModelValue = function(currentModel, propertyName, propertyPath) {
                                var unwrappedPropertyValue;
                                ko.computed(function() {
                                    var propertyValue = currentModel[propertyName];
                                    applyModelValueToOption(propertyPath, propertyValue);
                                    unwrappedPropertyValue = ko.unwrap(propertyValue)
                                }, null, {disposeWhenNodeIsRemoved: domNode});
                                if ($.isPlainObject(unwrappedPropertyValue))
                                    unwrapModel(unwrappedPropertyValue, propertyPath)
                            };
                        var unwrapModel = function(model, propertyPath) {
                                for (var propertyName in model)
                                    if (model.hasOwnProperty(propertyName))
                                        unwrapModelValue(model, propertyName, propertyPath ? [propertyPath, propertyName].join(".") : propertyName)
                            };
                        ko.computed(function() {
                            var component = $element.data(componentName),
                                model = ko.unwrap(valueAccessor());
                            if (component)
                                component.beginUpdate();
                            unwrapModel(model);
                            if (component)
                                component.endUpdate();
                            else
                                createComponent()
                        }, null, {disposeWhenNodeIsRemoved: domNode});
                        return {controlsDescendantBindings: componentClass.subclassOf(Widget)}
                    }};
                if (componentName === "dxValidator")
                    ko.bindingHandlers["dxValidator"].after = editorsBingindHandlers
            };
        registerComponent.callbacks.add(function(name, componentClass) {
            registerComponentKoBinding(name, componentClass)
        })
    });
    /*! Module core, file ko.components.js */
    DevExpress.define("/integration/knockout/ko.components", ["/utils/utils.icon", "/utils/utils.inflector", "/action"], function(iconUtils, inflector, Action) {
        var ko = window.ko;
        ko.bindingHandlers.dxAction = {update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
                var $element = $(element);
                var unwrappedValue = ko.utils.unwrapObservable(valueAccessor()),
                    actionSource = unwrappedValue,
                    actionOptions = {context: element};
                if (unwrappedValue.execute) {
                    actionSource = unwrappedValue.execute;
                    $.extend(actionOptions, unwrappedValue)
                }
                var action = new Action(actionSource, actionOptions);
                $element.off(".dxActionBinding").on("dxclick.dxActionBinding", function(e) {
                    action.execute({
                        element: $element,
                        model: viewModel,
                        evaluate: function(expression) {
                            var context = viewModel;
                            if (expression.length > 0 && expression[0] === "$")
                                context = ko.contextFor(element);
                            var getter = DevExpress.data.utils.compileGetter(expression);
                            return getter(context)
                        },
                        jQueryEvent: e
                    });
                    if (!actionOptions.bubbling)
                        e.stopPropagation()
                })
            }};
        ko.bindingHandlers.dxControlsDescendantBindings = {init: function(_, valueAccessor) {
                return {controlsDescendantBindings: ko.unwrap(valueAccessor())}
            }};
        ko.bindingHandlers.dxPolymorphWidget = {init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
                var widgetName = ko.utils.unwrapObservable(valueAccessor()).name;
                if (!widgetName)
                    return;
                ko.virtualElements.emptyNode(element);
                var markup = $("<div data-bind=\"" + inflector.camelize("dx-" + widgetName) + ": options\">").get(0);
                ko.virtualElements.prepend(element, markup);
                var innerBindingContext = bindingContext.extend(valueAccessor);
                ko.applyBindingsToDescendants(innerBindingContext, element);
                return {controlsDescendantBindings: true}
            }};
        ko.virtualElements.allowedBindings.dxPolymorphWidget = true;
        ko.bindingHandlers.dxIcon = {
            init: function(element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()) || {},
                    iconElement = iconUtils.getImageContainer(options);
                ko.virtualElements.emptyNode(element);
                if (iconElement)
                    ko.virtualElements.prepend(element, iconElement.get(0))
            },
            update: function(element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()) || {},
                    iconElement = iconUtils.getImageContainer(options);
                ko.virtualElements.emptyNode(element);
                if (iconElement)
                    ko.virtualElements.prepend(element, iconElement.get(0))
            }
        };
        ko.virtualElements.allowedBindings.dxIcon = true
    });
    /*! Module core, file ko.defaultTemplates.js */
    DevExpress.define("/integration/knockout/ko.defaultTemplates", ["jquery"], function($) {
        var TEMPLATE_GENERATORS = {};
        var createElementWithBindAttr = function(tagName, bindings, closeTag, additionalProperties) {
                closeTag = closeTag === undefined ? true : closeTag;
                var bindAttr = $.map(bindings, function(value, key) {
                        return key + ":" + value
                    }).join(",");
                additionalProperties = additionalProperties || "";
                return "<" + tagName + " data-bind=\"" + bindAttr + "\" " + additionalProperties + ">" + (closeTag ? "</" + tagName + ">" : "")
            };
        var defaultKoTemplateBasicBindings = {css: "{ 'dx-state-disabled': $data.disabled, 'dx-state-invisible': !($data.visible === undefined || ko.unwrap($data.visible)) }"};
        var emptyTemplate = function() {
                return ""
            };
        TEMPLATE_GENERATORS.CollectionWidget = {
            itemFrame: function() {
                var markup = [createElementWithBindAttr("div", defaultKoTemplateBasicBindings, false), "<div class='dx-item-content-placeholder'></div>", "</div>"];
                return markup.join("")
            },
            item: function() {
                var htmlBinding = createElementWithBindAttr("div", {html: "html"}),
                    textBinding = createElementWithBindAttr("div", {text: "text"}),
                    primitiveBinding = createElementWithBindAttr("div", {text: "String($data)"});
                var markup = ["<div>", "<!-- ko if: $data.html -->", htmlBinding, "<!-- /ko -->", "<!-- ko if: !$data.html && $data.text -->", textBinding, "<!-- /ko -->", "<!-- ko ifnot: $.isPlainObject($data) -->", primitiveBinding, "<!-- /ko -->", "</div>"];
                return markup.join("")
            }
        };
        var BUTTON_TEXT_CLASS = "dx-button-text";
        TEMPLATE_GENERATORS.dxButton = {content: function() {
                var textBinding = createElementWithBindAttr("span", {
                        text: "$data.text",
                        css: "{ '" + BUTTON_TEXT_CLASS + "' : !!$data.text }"
                    });
                var markup = ["<div>", "<!-- ko dxIcon: $data.icon || $data.iconSrc --><!-- /ko -->", textBinding, "</div>"];
                return markup.join("")
            }};
        var LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container",
            LIST_ITEM_BADGE_CLASS = "dx-list-item-badge",
            BADGE_CLASS = "dx-badge",
            LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container",
            LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
        TEMPLATE_GENERATORS.dxList = {
            item: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.item(),
                    keyBinding = createElementWithBindAttr("div", {text: "key"});
                template = [template.substring(0, template.length - 6), "<!-- ko if: $data.key -->" + keyBinding + "<!-- /ko -->", "</div>"];
                return template.join("")
            },
            itemFrame: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(),
                    badgeBinding = createElementWithBindAttr("div", {text: "badge"}, true, 'class="' + LIST_ITEM_BADGE_CLASS + " " + BADGE_CLASS + '"');
                var markup = [template.substring(0, template.length - 6), "<!-- ko if: $data.badge -->", "<div class=\"" + LIST_ITEM_BADGE_CONTAINER_CLASS + "\">", badgeBinding, "</div>", "<!-- /ko -->", "<!-- ko if: $data.showChevron -->", "<div class=\"" + LIST_ITEM_CHEVRON_CONTAINER_CLASS + "\">", "<div class=\"" + LIST_ITEM_CHEVRON_CLASS + "\"></div>", "</div>", "<!-- /ko -->", "</div>"];
                return markup.join("")
            },
            group: function() {
                var keyBinding = createElementWithBindAttr("div", {text: "key"}),
                    primitiveBinding = createElementWithBindAttr("div", {text: "String($data)"});
                var markup = ["<div>", "<!-- ko if: $data.key -->", keyBinding, "<!-- /ko -->", "<!-- ko ifnot: $.isPlainObject($data) -->", primitiveBinding, "<!-- /ko -->", "</div>"];
                return markup.join("")
            }
        };
        TEMPLATE_GENERATORS.dxDropDownMenu = {
            item: TEMPLATE_GENERATORS.dxList.item,
            content: TEMPLATE_GENERATORS.dxButton.content
        };
        TEMPLATE_GENERATORS.dxDropDownList = {item: TEMPLATE_GENERATORS.dxList.item};
        TEMPLATE_GENERATORS.dxRadioGroup = {item: TEMPLATE_GENERATORS.CollectionWidget.item};
        TEMPLATE_GENERATORS.dxScheduler = {
            item: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.item(),
                    startDateBinding = createElementWithBindAttr("div class='dx-scheduler-appointment-content-date'", {text: "Globalize.format(DevExpress.utils.makeDate($data.startDate), 't')"}),
                    endDateBinding = createElementWithBindAttr("div class='dx-scheduler-appointment-content-date'", {text: "Globalize.format(DevExpress.utils.makeDate($data.endDate), 't')"}),
                    dash = createElementWithBindAttr("div class='dx-scheduler-appointment-content-date'", {text: "' - '"});
                template = [template.substring(0, template.length - 6), "<div class='dx-scheduler-appointment-content-details'>", "<!-- ko if: $data.startDate -->" + startDateBinding + "<!-- /ko -->", "<!-- ko if: $data.endDate -->" + dash + "<!-- /ko -->", "<!-- ko if: $data.endDate -->" + endDateBinding + "<!-- /ko -->", "</div>", "<!-- ko if: $data.recurrenceRule --><span class='dx-scheduler-appointment-recurrence-icon dx-icon-repeat'></span><!-- /ko -->", "</div>"];
                return template.join("")
            },
            appointmentTooltip: emptyTemplate,
            appointmentPopup: emptyTemplate
        };
        TEMPLATE_GENERATORS.dxOverlay = {content: emptyTemplate};
        TEMPLATE_GENERATORS.dxSlideOutView = {
            menu: emptyTemplate,
            content: emptyTemplate
        };
        TEMPLATE_GENERATORS.dxSlideOut = {
            menuItem: TEMPLATE_GENERATORS.dxList.item,
            menuGroup: TEMPLATE_GENERATORS.dxList.group,
            content: emptyTemplate
        };
        TEMPLATE_GENERATORS.dxAccordion = {
            title: function() {
                var titleBinding = createElementWithBindAttr("span", {text: "$.isPlainObject($data) ? $data.title : String($data)"});
                var markup = ["<div>", "<!-- ko dxIcon: $data.icon || $data.iconSrc --><!-- /ko -->", titleBinding, "</div>"];
                return markup.join("")
            },
            item: TEMPLATE_GENERATORS.CollectionWidget.item
        };
        TEMPLATE_GENERATORS.dxResponsiveBox = {item: TEMPLATE_GENERATORS.CollectionWidget.item},
        TEMPLATE_GENERATORS.dxPivotTabs = {item: function() {
                var titleBinding = createElementWithBindAttr("span", {text: "title"}),
                    primitiveBinding = createElementWithBindAttr("div", {text: "String($data)"});
                var markup = ["<div>", "<!-- ko if: $data.title -->", titleBinding, "<!-- /ko -->", "<!-- ko ifnot: $data.title || $.isPlainObject($data) -->", primitiveBinding, "<!-- /ko -->", "</div>"];
                return markup.join("")
            }};
        TEMPLATE_GENERATORS.dxPivot = {
            title: TEMPLATE_GENERATORS.dxPivotTabs.item,
            content: emptyTemplate
        };
        var PANORAMA_ITEM_TITLE_CLASS = "dx-panorama-item-title";
        TEMPLATE_GENERATORS.dxPanorama = {itemFrame: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(),
                    headerBinding = createElementWithBindAttr("div", {text: "title"}, true, 'class="' + PANORAMA_ITEM_TITLE_CLASS + '"');
                var divInnerStart = template.indexOf(">") + 1;
                template = [template.substring(0, divInnerStart), "<!-- ko if: $data.title -->", headerBinding, "<!-- /ko -->", template.substring(divInnerStart, template.length)];
                return template.join("")
            }};
        TEMPLATE_GENERATORS.dxActionSheet = {item: function() {
                return ["<div>", createElementWithBindAttr("div", {dxButton: "{ text: $data.text, onClick: $data.clickAction || $data.onClick, type: $data.type, disabled: !!ko.unwrap($data.disabled) }"}), "</div>"].join("")
            }};
        TEMPLATE_GENERATORS.dxToolbar = {
            item: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.item();
                template = [template.substring(0, template.length - 6), "<!-- ko if: $data.widget -->"];
                template.push("<!-- ko dxPolymorphWidget: { name: $data.widget, options: $data.options } --><!-- /ko -->");
                template.push("<!-- /ko -->");
                return template.join("")
            },
            menuItem: TEMPLATE_GENERATORS.dxList.item,
            actionSheetItem: TEMPLATE_GENERATORS.dxActionSheet.item
        };
        var GALLERY_IMAGE_CLASS = "dx-gallery-item-image";
        TEMPLATE_GENERATORS.dxGallery = {item: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.item(),
                    primitiveBinding = createElementWithBindAttr("div", {text: "String($data)"}),
                    imgBinding = createElementWithBindAttr("img", {attr: "{ src: String($data) }"}, false, 'class="' + GALLERY_IMAGE_CLASS + '"');
                template = [template.substring(0, template.length - 6).replace(primitiveBinding, imgBinding), "<!-- ko if: $data.imageSrc -->", createElementWithBindAttr("img", {attr: "{ src: $data.imageSrc, alt: $data.imageAlt }"}, false, 'class="' + GALLERY_IMAGE_CLASS + '"'), "<!-- /ko -->"].join("");
                return template
            }};
        TEMPLATE_GENERATORS.dxTabs = {
            item: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.item(),
                    basePrimitiveBinding = createElementWithBindAttr("div", {text: "String($data)"}),
                    primitiveBinding = "<span class=\"dx-tab-text\" data-bind=\"text: String($data)\"></span>",
                    baseTextBinding = createElementWithBindAttr("div", {text: "text"}),
                    textBinding = "<!-- ko dxIcon: $data.icon || $data.iconSrc --><!-- /ko -->" + "<span class=\"dx-tab-text\" data-bind=\"text: $data.text\"></span>";
                template = template.replace("<!-- ko if: !$data.html && $data.text -->", "<!-- ko if: !$data.html && ($data.text || $data.icon || $data.iconSrc) -->").replace(basePrimitiveBinding, primitiveBinding).replace(baseTextBinding, textBinding);
                return template
            },
            itemFrame: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(),
                    badgeBinding = createElementWithBindAttr("div", {
                        attr: "{ 'class': 'dx-tabs-item-badge dx-badge' }",
                        text: "badge"
                    });
                var markup = [template.substring(0, template.length - 6), "<!-- ko if: $data.badge -->", badgeBinding, "<!-- /ko -->", "</div>"];
                return markup.join("")
            }
        };
        TEMPLATE_GENERATORS.dxTabPanel = {
            item: TEMPLATE_GENERATORS.CollectionWidget.item,
            title: function() {
                var template = TEMPLATE_GENERATORS.dxTabs.item(),
                    htmlBinding = "<!-- ko if: $data.html -->" + createElementWithBindAttr("div", {html: "html"}) + "<!-- /ko -->";
                return template.replace(/\$data\.text/g, '$data.title').replace(/\!\$data\.html\ \&\&\ /, "").replace(htmlBinding, "")
            }
        };
        var NAVBAR_ITEM_BADGE_CLASS = "dx-navbar-item-badge";
        TEMPLATE_GENERATORS.dxNavBar = {itemFrame: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.itemFrame(),
                    badgeBinding = createElementWithBindAttr("div", {text: "badge"}, true, 'class="' + NAVBAR_ITEM_BADGE_CLASS + " " + BADGE_CLASS + '"');
                var markup = [template.substring(0, template.length - 6), "<!-- ko if: $data.badge -->", badgeBinding, "<!-- /ko -->", "</div>"];
                return markup.join("")
            }};
        TEMPLATE_GENERATORS.dxMenuBase = {item: function() {
                var template = [createElementWithBindAttr("div", defaultKoTemplateBasicBindings, false)],
                    textBinding = createElementWithBindAttr("span", {
                        text: "text",
                        css: "{ 'dx-menu-item-text': true }"
                    }),
                    primitiveBinding = createElementWithBindAttr("span", {
                        text: "String($data)",
                        css: "{ 'dx-menu-item-text': true }"
                    }),
                    popout = "<span class='dx-menu-item-popout-container'><div class='dx-menu-item-popout'></div></span>";
                template.push("<!-- ko dxIcon: $data.icon || $data.iconSrc --><!-- /ko -->", "<!-- ko if: $.isPlainObject($data) && $data.text -->", textBinding, "<!-- /ko -->", "<!-- ko ifnot: $.isPlainObject($data) -->", primitiveBinding, "<!-- /ko -->", "<!-- ko if: $data.items -->", popout, "<!-- /ko -->", "</div>");
                return template.join("")
            }};
        TEMPLATE_GENERATORS.dxTreeView = {item: function() {
                var node = [],
                    link = createElementWithBindAttr("span", {text: "text"}, true),
                    htmlBinding = createElementWithBindAttr("div", {html: "html"});
                node.push("<div>", "<!-- ko if: $data.html && !$data.text -->", htmlBinding, "<!-- /ko -->", "<!-- ko dxIcon: $data.icon || $data.iconSrc --><!-- /ko -->", "<!-- ko if: !$data.html && $data.text -->" + link + "<!-- /ko -->", "</div>");
                return node.join("")
            }};
        var popupTitleAndBottom = function() {
                return ["<div>", createElementWithBindAttr("div", {dxToolbar: "{ items: $data }"}), "</div>"].join("")
            };
        TEMPLATE_GENERATORS.dxPopup = {
            title: popupTitleAndBottom,
            bottom: popupTitleAndBottom
        };
        TEMPLATE_GENERATORS.dxLookup = {
            title: TEMPLATE_GENERATORS.dxPopup.title,
            group: TEMPLATE_GENERATORS.dxList.group
        };
        TEMPLATE_GENERATORS.dxTagBox = {tag: function() {
                return ["<div>", createElementWithBindAttr("span", {text: "$data"})].join("")
            }};
        return TEMPLATE_GENERATORS
    });
    /*! Module core, file ko.template.js */
    DevExpress.define("/integration/knockout/ko.template", ["jquery", "/ui/templates/ui.templateBase", "/utils/utils.dom"], function($, TemplateBase, domUtils) {
        var ko = window.ko;
        var KoTemplate = TemplateBase.inherit({
                ctor: function(element, owner) {
                    this.callBase(element, owner);
                    this._template = $("<div>").append(domUtils.normalizeTemplateElement(element));
                    this._registerKoTemplate()
                },
                _registerKoTemplate: function() {
                    var template = this._template.get(0);
                    new ko.templateSources.anonymousTemplate(template)['nodes'](template)
                },
                _prepareDataForContainer: function(data, container) {
                    var result = data,
                        containerElement,
                        containerContext;
                    if (container.length) {
                        containerElement = container.get(0);
                        data = data !== undefined ? data : ko.dataFor(containerElement) || {};
                        containerContext = ko.contextFor(containerElement);
                        if (containerContext)
                            result = data === containerContext.$data ? containerContext : containerContext.createChildContext(data);
                        else
                            result = data
                    }
                    return result
                },
                _renderCore: function(data, index, $container) {
                    var $placeholder = $("<div>").appendTo($container);
                    var $result;
                    ko.renderTemplate(this._template.get(0), data, {afterRender: function(nodes) {
                            $result = $(nodes)
                        }}, $placeholder.get(0), "replaceNode");
                    return $result
                },
                dispose: function() {
                    this.callBase();
                    this._template.remove()
                }
            });
        return KoTemplate
    });
    /*! Module core, file ko.templateProvider.js */
    DevExpress.define("/integration/knockout/ko.templateProvider", ["jquery", "/utils/utils.dom", "/integration/jquery/jquery.templateProvider", "/integration/knockout/ko.template", "/integration/knockout/ko.defaultTemplates"], function($, domUtils, jqTemplateProvider, KoTemplate, defaultTemplates) {
        var ko = window.ko;
        var KoTemplateProvider = jqTemplateProvider.constructor.inherit({
                createTemplate: function(element, owner) {
                    return new KoTemplate(element, owner)
                },
                applyTemplate: function(element, model) {
                    ko.applyBindings(model, element)
                },
                _templatesForWidget: function(widgetName) {
                    var templateGenerators = defaultTemplates[widgetName];
                    if (!templateGenerators)
                        return this.callBase(widgetName);
                    var templates = {};
                    $.each(templateGenerators, function(name, generator) {
                        var $markup = domUtils.createMarkupFromString(generator());
                        if (name !== "itemFrame")
                            $markup = $markup.contents();
                        templates[name] = new KoTemplate($markup, koTemplateProvider)
                    });
                    return templates
                }
            });
        var koTemplateProvider = new KoTemplateProvider;
        return koTemplateProvider
    });
    /*! Module core, file ko.validation.js */
    DevExpress.define("/integration/knockout/ko.validation", ["jquery", "/class", "/eventsMixin"], function($, Class, EventsMixin) {
        var ko = window.ko;
        var koDxValidator = Class.inherit({
                ctor: function(target, option) {
                    var that = this;
                    that.target = target;
                    that.validationRules = option.validationRules;
                    that.name = option.name;
                    that.isValid = ko.observable(true);
                    that.validationError = ko.observable();
                    $.each(this.validationRules, function(_, rule) {
                        rule.validator = that
                    })
                },
                validate: function() {
                    var result = DevExpress.validationEngine.validate(this.target(), this.validationRules, this.name);
                    this._applyValidationResult(result);
                    return result
                },
                reset: function() {
                    this.target(null);
                    var result = {
                            isValid: true,
                            brokenRule: null
                        };
                    this._applyValidationResult(result);
                    return result
                },
                _applyValidationResult: function(result) {
                    result.validator = this;
                    this.target.dxValidator.isValid(result.isValid);
                    this.target.dxValidator.validationError(result.brokenRule);
                    this.fireEvent("validated", [result])
                }
            }).include(EventsMixin);
        ko.extenders.dxValidator = function(target, option) {
            target.dxValidator = new koDxValidator(target, option);
            target.subscribe($.proxy(target.dxValidator.validate, target.dxValidator));
            return target
        };
        DevExpress.validationEngine.registerModelForValidation = function(model) {
            $.each(model, function(name, member) {
                if (ko.isObservable(member) && member.dxValidator)
                    DevExpress.validationEngine.registerValidatorInGroup(model, member.dxValidator)
            })
        };
        DevExpress.validationEngine.validateModel = DevExpress.validationEngine.validateGroup
    });
    /*! Module core, file ko.eventRegistrator.js */
    DevExpress.define("/integration/knockout/ko.eventRegistrator", ["jquery", "/ui/events/ui.events.eventRegistrator", "/ui/events/ui.events.utils"], function($, eventRegistrator, eventUtils) {
        var ko = window.ko;
        eventRegistrator.callbacks.add(function(name, eventObject) {
            var koBindingEventName = eventUtils.addNamespace(name, name + "Binding");
            ko.bindingHandlers[name] = {update: function(element, valueAccessor, allBindingsAccessor, viewModel) {
                    var $element = $(element),
                        unwrappedValue = ko.utils.unwrapObservable(valueAccessor()),
                        eventSource = unwrappedValue.execute ? unwrappedValue.execute : unwrappedValue;
                    $element.off(koBindingEventName).on(koBindingEventName, $.isPlainObject(unwrappedValue) ? unwrappedValue : {}, function(e) {
                        eventSource.call(viewModel, viewModel, e)
                    })
                }}
        })
    });
    /*! Module core, file ko.cleanNode.js */
    DevExpress.define("/integration/knockout/ko.cleanNode", ["jquery"], function($) {
        var ko = window.ko,
            nodesToCleanByJquery,
            cleanData = $.cleanData,
            cleanNode = ko.cleanNode;
        $.cleanData = function(nodes) {
            var result = cleanData(nodes);
            for (var i = 0; i < nodes.length; i++) {
                if (!nodes[i].cleanedByKo)
                    cleanNode(nodes[i]);
                delete nodes[i].cleanedByKo
            }
            nodesToCleanByJquery = null;
            return result
        };
        ko.cleanNode = function(node) {
            var result = cleanNode(node);
            if (nodesToCleanByJquery)
                cleanData(nodesToCleanByJquery);
            return result
        };
        ko.utils.domNodeDisposal.cleanExternalData = function(node) {
            node.cleanedByKo = true;
            nodesToCleanByJquery = nodesToCleanByJquery || [];
            nodesToCleanByJquery.push(node)
        };
        return {
                cleanData: function(value) {
                    if (value)
                        cleanData = value;
                    return cleanData
                },
                cleanNode: function(value) {
                    if (value)
                        cleanNode = value;
                    return cleanNode
                }
            }
    });
    /*! Module core, file ko.cleanNodeIE8.js */
    DevExpress.define("/integration/knockout/ko.cleanNodeIE8", ["jquery"], function($) {
        var ko = window.ko;
        var cleanKoData = function(element, andSelf) {
                var cleanNode = function() {
                        ko.cleanNode(this)
                    };
                if (andSelf)
                    element.each(cleanNode);
                else
                    element.find("*").each(cleanNode)
            };
        var originalEmpty = $.fn.empty;
        $.fn.empty = function() {
            cleanKoData(this, false);
            return originalEmpty.apply(this, arguments)
        };
        var originalRemove = $.fn.remove;
        $.fn.remove = function(selector, keepData) {
            if (!keepData) {
                var subject = this;
                if (selector)
                    subject = subject.filter(selector);
                cleanKoData(subject, true)
            }
            return originalRemove.call(this, selector, keepData)
        };
        var originalHtml = $.fn.html;
        $.fn.html = function(value) {
            if (typeof value === "string")
                cleanKoData(this, false);
            return originalHtml.apply(this, arguments)
        };
        var originalReplaceWith = $.fn.replaceWith;
        $.fn.replaceWith = function(value) {
            var result = originalReplaceWith.apply(this, arguments);
            if (!this.parent().length)
                cleanKoData(this, true);
            return result
        }
    });
    /*! Module core, file ng.componentRegistrator.js */
    DevExpress.define("/integration/angular/ng.componentRegistrator", ["jquery", "/componentRegistrator", "/class", "/utils/utils.common", "/utils/utils.dom", "/ui/ui.widget", "/ui/ui.editor", "/integration/angular/ng.templateProvider", "/integration/angular/ng.module"], function($, registerComponent, Class, commonUtils, domUtils, Widget, Editor, NgTemplateProvider, ngModule) {
        var compileSetter = DevExpress.data.utils.compileSetter,
            compileGetter = DevExpress.data.utils.compileGetter;
        var ITEM_ALIAS_ATTRIBUTE_NAME = "dxItemAlias",
            DEFAULT_MODEL_ALIAS = "scopeValue",
            ELEMENT_MODEL_DATA_KEY = "dxElementModel",
            SKIP_APPLY_ACTION_CATEGORIES = ["rendering"];
        var safeApply = function(func, scope) {
                if (scope.$root.$$phase)
                    func(scope);
                else
                    scope.$apply(function() {
                        func(scope)
                    })
            };
        var ComponentBuilder = Class.inherit({
                ctor: function(options) {
                    this._componentDisposing = $.Callbacks();
                    this._optionChangedCallbacks = $.Callbacks();
                    this._scope = options.scope;
                    this._$element = options.$element;
                    this._$element.data(ELEMENT_MODEL_DATA_KEY, this._scope);
                    this._$templates = options.$templates;
                    this._componentClass = options.componentClass;
                    this._parse = options.parse;
                    this._compile = options.compile;
                    this._itemAlias = options.itemAlias;
                    this._normalizeOptions(options.ngOptions);
                    this._initComponentBindings();
                    this._initComponent(this._scope);
                    if (options.ngOptions)
                        this._triggerShownEvent();
                    else
                        this._addOptionsStringWatcher(options.ngOptionsString)
                },
                _addOptionsStringWatcher: function(optionsString) {
                    var that = this;
                    var clearOptionsStringWatcher = that._scope.$watch(optionsString, function(newOptions) {
                            if (!newOptions)
                                return;
                            clearOptionsStringWatcher();
                            that._normalizeOptions(newOptions);
                            that._initComponentBindings();
                            that._component.option(that._evalOptions(that._scope));
                            that._triggerShownEvent()
                        });
                    that._componentDisposing.add(clearOptionsStringWatcher)
                },
                _normalizeOptions: function(options) {
                    var that = this;
                    that._ngOptions = $.extend({}, options);
                    if (!options)
                        return;
                    if (options.bindingOptions)
                        $.each(options.bindingOptions, function(key, value) {
                            if ($.type(value) === 'string')
                                that._ngOptions.bindingOptions[key] = {dataPath: value}
                        });
                    if (options.data)
                        that._initDataScope(options.data)
                },
                _triggerShownEvent: function() {
                    var that = this;
                    that._shownEventTimer = setTimeout(function() {
                        domUtils.triggerShownEvent(that._$element)
                    });
                    that._componentDisposing.add(function() {
                        clearTimeout(that._shownEventTimer)
                    })
                },
                _initDataScope: function(data) {
                    if (typeof data === "string") {
                        var dataStr = data,
                            rootScope = this._scope;
                        data = rootScope.$eval(data);
                        this._scope = rootScope.$new();
                        this._synchronizeDataScopes(rootScope, this._scope, data, dataStr)
                    }
                    $.extend(this._scope, data)
                },
                _synchronizeDataScopes: function(parentScope, childScope, data, parentPrefix) {
                    var that = this;
                    $.each(data, function(fieldPath) {
                        that._synchronizeScopeField({
                            parentScope: parentScope,
                            childScope: childScope,
                            fieldPath: fieldPath,
                            parentPrefix: parentPrefix
                        })
                    })
                },
                _initComponent: function(scope) {
                    this._component = new this._componentClass(this._$element, this._evalOptions(scope));
                    this._component._isHidden = true
                },
                _initComponentBindings: function() {
                    var that = this,
                        optionDependencies = {};
                    if (!that._ngOptions.bindingOptions)
                        return;
                    $.each(that._ngOptions.bindingOptions, function(optionPath, value) {
                        var separatorIndex = optionPath.search(/\[|\./),
                            optionForSubscribe = separatorIndex > -1 ? optionPath.substring(0, separatorIndex) : optionPath,
                            prevWatchMethod,
                            clearWatcher,
                            valuePath = value.dataPath,
                            deepWatch = true,
                            forcePlainWatchMethod = false;
                        if (value.deep !== undefined)
                            forcePlainWatchMethod = deepWatch = !!value.deep;
                        if (!optionDependencies[optionForSubscribe])
                            optionDependencies[optionForSubscribe] = {};
                        optionDependencies[optionForSubscribe][optionPath] = valuePath;
                        var watchCallback = function(newValue) {
                                that._component.option(optionPath, newValue);
                                updateWatcher()
                            };
                        var updateWatcher = function() {
                                var watchMethod = $.isArray(that._scope.$eval(valuePath)) && !forcePlainWatchMethod ? "$watchCollection" : "$watch";
                                if (prevWatchMethod !== watchMethod) {
                                    if (clearWatcher)
                                        clearWatcher();
                                    clearWatcher = that._scope[watchMethod](valuePath, watchCallback, deepWatch);
                                    prevWatchMethod = watchMethod
                                }
                            };
                        updateWatcher();
                        that._componentDisposing.add(clearWatcher)
                    });
                    that._optionChangedCallbacks.add(function(args) {
                        var optionName = args.name,
                            component = args.component;
                        if (that._scope.$root.$$phase === "$digest" || !optionDependencies || !optionDependencies[optionName])
                            return;
                        safeApply(function(scope) {
                            $.each(optionDependencies[optionName], function(optionPath, valuePath) {
                                var value = component.option(optionPath);
                                that._parse(valuePath).assign(that._scope, value)
                            })
                        }, that._scope)
                    })
                },
                _compilerByTemplate: function(template) {
                    var that = this,
                        scopeItemsPath = this._getScopeItemsPath();
                    return function(data, index, $container) {
                            var $resultMarkup = $(template).clone(),
                                templateScope;
                            $resultMarkup.appendTo($container);
                            if (commonUtils.isDefined(data)) {
                                var dataIsScope = data.$id;
                                templateScope = dataIsScope ? data : that._createScopeWithData(data);
                                $resultMarkup.on("$destroy", function() {
                                    var destroyAlreadyCalled = !templateScope.$parent;
                                    if (destroyAlreadyCalled)
                                        return;
                                    templateScope.$destroy()
                                })
                            }
                            else
                                templateScope = that._scope;
                            if (scopeItemsPath)
                                that._synchronizeScopes(templateScope, scopeItemsPath, index);
                            safeApply(that._compile($resultMarkup), templateScope);
                            return $resultMarkup
                        }
                },
                _getScopeItemsPath: function() {
                    if (this._componentClass.subclassOf(DevExpress.ui.CollectionWidget) && this._ngOptions.bindingOptions && this._ngOptions.bindingOptions.items)
                        return this._ngOptions.bindingOptions.items.dataPath
                },
                _createScopeWithData: function(data) {
                    var newScope = this._scope.$new(true);
                    data = this._enshureDataIsPlainObject(data);
                    $.extend(newScope, data);
                    return newScope
                },
                _synchronizeScopes: function(itemScope, parentPrefix, itemIndex) {
                    var that = this,
                        item = compileGetter(parentPrefix + "[" + itemIndex + "]")(this._scope);
                    item = that._enshureDataIsPlainObject(item);
                    $.each(item, function(itemPath) {
                        that._synchronizeScopeField({
                            parentScope: that._scope,
                            childScope: itemScope,
                            fieldPath: itemPath,
                            parentPrefix: parentPrefix,
                            itemIndex: itemIndex
                        })
                    })
                },
                _synchronizeScopeField: function(args) {
                    var parentScope = args.parentScope,
                        childScope = args.childScope,
                        fieldPath = args.fieldPath,
                        parentPrefix = args.parentPrefix,
                        itemIndex = args.itemIndex;
                    var innerPathSuffix = fieldPath === (this._itemAlias || DEFAULT_MODEL_ALIAS) ? "" : "." + fieldPath,
                        collectionField = itemIndex !== undefined,
                        optionOuterBag = [parentPrefix],
                        optionOuterPath;
                    if (collectionField)
                        optionOuterBag.push("[", itemIndex, "]");
                    optionOuterBag.push(innerPathSuffix);
                    optionOuterPath = optionOuterBag.join("");
                    var clearParentWatcher = parentScope.$watch(optionOuterPath, function(newValue, oldValue) {
                            if (newValue !== oldValue)
                                compileSetter(fieldPath)(childScope, newValue)
                        });
                    var clearItemWatcher = childScope.$watch(fieldPath, function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                if (collectionField && !compileGetter(parentPrefix)(parentScope)[itemIndex]) {
                                    clearItemWatcher();
                                    return
                                }
                                compileSetter(optionOuterPath)(parentScope, newValue)
                            }
                        });
                    this._componentDisposing.add([clearParentWatcher, clearItemWatcher])
                },
                _evalOptions: function(scope) {
                    var result = $.extend({}, this._ngOptions);
                    delete result.data;
                    delete result.bindingOptions;
                    if (this._ngOptions.bindingOptions)
                        $.each(this._ngOptions.bindingOptions, function(key, value) {
                            result[key] = scope.$eval(value.dataPath)
                        });
                    result._optionChangedCallbacks = this._optionChangedCallbacks;
                    result._disposingCallbacks = this._componentDisposing;
                    result.templateProvider = NgTemplateProvider;
                    result.templateCompiler = $.proxy(function($template) {
                        return this._compilerByTemplate($template)
                    }, this);
                    result.modelByElement = function(element) {
                        if (element.length)
                            return element.data(ELEMENT_MODEL_DATA_KEY)
                    };
                    result.onActionCreated = function(component, action, config) {
                        if (config && $.inArray(config.category, SKIP_APPLY_ACTION_CATEGORIES) > -1)
                            return action;
                        var wrappedAction = function() {
                                var that = this,
                                    scope = result.modelByElement(component.element()),
                                    args = arguments;
                                if (!scope || !scope.$root || scope.$root.$$phase)
                                    return action.apply(that, args);
                                return scope.$apply(function() {
                                        return action.apply(that, args)
                                    })
                            };
                        return wrappedAction
                    };
                    result.nestedComponentOptions = function(component) {
                        return {
                                templateCompiler: component.option("templateCompiler"),
                                modelByElement: component.option("modelByElement"),
                                onActionCreated: component.option("onActionCreated"),
                                nestedComponentOptions: component.option("nestedComponentOptions")
                            }
                    };
                    return result
                },
                _enshureDataIsPlainObject: function(object) {
                    var result;
                    if ($.isPlainObject(object))
                        result = object;
                    else {
                        result = {};
                        result[DEFAULT_MODEL_ALIAS] = object
                    }
                    if (this._itemAlias)
                        result[this._itemAlias] = object;
                    return result
                }
            });
        ComponentBuilder = ComponentBuilder.inherit({
            ctor: function(options) {
                this._componentName = options.componentName;
                this._ngModel = options.ngModel;
                this._ngModelController = options.ngModelController;
                this.callBase.apply(this, arguments)
            },
            _isNgModelRequired: function() {
                return this._componentClass.subclassOf(Editor) && this._ngModel
            },
            _initComponentBindings: function() {
                this.callBase.apply(this, arguments);
                this._initNgModelBinding()
            },
            _initNgModelBinding: function() {
                if (!this._isNgModelRequired())
                    return;
                var that = this;
                var clearNgModelWatcher = this._scope.$watch(this._ngModel, function(newValue, oldValue) {
                        if (newValue === oldValue)
                            return;
                        that._component.option(that._ngModelOption(), newValue)
                    });
                that._optionChangedCallbacks.add(function(args) {
                    if (args.name !== that._ngModelOption())
                        return;
                    that._ngModelController.$setViewValue(args.value)
                });
                this._componentDisposing.add(clearNgModelWatcher)
            },
            _ngModelOption: function() {
                if ($.inArray(this._componentName, ["dxFileUploader", "dxTagBox"]) > -1)
                    return "values";
                return "value"
            },
            _evalOptions: function() {
                if (!this._isNgModelRequired())
                    return this.callBase.apply(this, arguments);
                var result = this.callBase.apply(this, arguments);
                result[this._ngModelOption()] = this._parse(this._ngModel)(this._scope);
                return result
            }
        });
        var registeredComponents = {};
        var registerComponentDirective = function(name) {
                var priority = name !== "dxValidator" ? 1 : 10;
                ngModule.directive(name, ["$compile", "$parse", function($compile, $parse) {
                        return {
                                restrict: "A",
                                require: "^?ngModel",
                                priority: priority,
                                compile: function($element) {
                                    var componentClass = registeredComponents[name],
                                        $content = componentClass.subclassOf(Widget) ? $element.contents().detach() : null;
                                    return function(scope, $element, attrs, ngModelController) {
                                            $element.append($content);
                                            new ComponentBuilder({
                                                componentClass: componentClass,
                                                componentName: name,
                                                compile: $compile,
                                                parse: $parse,
                                                $element: $element,
                                                scope: scope,
                                                ngOptionsString: attrs[name],
                                                ngOptions: attrs[name] ? scope.$eval(attrs[name]) : {},
                                                ngModel: attrs.ngModel,
                                                ngModelController: ngModelController,
                                                itemAlias: attrs[ITEM_ALIAS_ATTRIBUTE_NAME]
                                            })
                                        }
                                }
                            }
                    }])
            };
        registerComponent.callbacks.add(function(name, componentClass) {
            if (!registeredComponents[name])
                registerComponentDirective(name);
            registeredComponents[name] = componentClass
        })
    });
    /*! Module core, file ng.components.js */
    DevExpress.define("/integration/angular/ng.components", ["/integration/angular/ng.module", "/utils/utils.icon", "/utils/utils.inflector"], function(ngModule, iconUtils, inflector) {
        ngModule.filter('dxGlobalize', function() {
            return function(input, param) {
                    return Globalize.format(input, param)
                }
        });
        ngModule.directive("dxIcon", ["$compile", function($compile) {
                return {
                        restrict: 'E',
                        link: function($scope, $element, $attrs) {
                            var html = iconUtils.getImageContainer($scope.icon || $scope.iconSrc);
                            if (html) {
                                var e = $compile(html.get(0))($scope);
                                $element.replaceWith(e)
                            }
                        }
                    }
            }]);
        ngModule.directive("dxPolymorphWidget", ["$compile", function($compile) {
                return {
                        restrict: 'E',
                        scope: {
                            name: "=",
                            options: "="
                        },
                        link: function($scope, $element, $attrs) {
                            var widgetName = $scope.name;
                            if (!widgetName)
                                return;
                            var markup = $("<div " + inflector.dasherize("dx-" + widgetName) + "=\"options\">").get(0);
                            $element.after(markup);
                            $compile(markup)($scope)
                        }
                    }
            }])
    });
    /*! Module core, file ng.defaultTemplates.js */
    DevExpress.define("/integration/angular/ng.defaultTemplates", ["jquery"], function($) {
        var TEMPLATE_GENERATORS = {};
        var TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
        var baseElements = {
                container: function() {
                    return $("<div>").addClass(TEMPLATE_WRAPPER_CLASS)
                },
                html: function() {
                    return $("<div>").attr("ng-if", "html").attr("ng-bind-html", "html")
                },
                text: function(element) {
                    element = element || "<div>";
                    return $(element).attr("ng-if", "text").attr("ng-if", "!html").attr("ng-bind", "text")
                },
                primitive: function() {
                    return $("<div>").attr("ng-if", "scopeValue").attr("ng-bind", "'' + scopeValue")
                }
            };
        var emptyTemplate = function() {
                return $()
            };
        TEMPLATE_GENERATORS.CollectionWidget = {
            item: function() {
                return baseElements.container().append(baseElements.html()).append(baseElements.text()).append(baseElements.primitive())
            },
            itemFrame: function() {
                var $container = $("<div>").attr("ng-class", "{ 'dx-state-invisible': !visible && visible != undefined, 'dx-state-disabled': !!disabled }"),
                    $placeholder = $("<div>").addClass("dx-item-content-placeholder");
                $container.append($placeholder);
                return $container
            }
        };
        var BUTTON_TEXT_CLASS = "dx-button-text";
        TEMPLATE_GENERATORS.dxButton = {content: function() {
                var $titleBinding = $("<span>").attr("ng-bind", "text").attr("ng-class", "{ '" + BUTTON_TEXT_CLASS + "' : !!text }"),
                    icon = $("<dx-icon>");
                return baseElements.container().append(icon).append($titleBinding).append(baseElements.primitive())
            }};
        var LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container",
            LIST_ITEM_BADGE_CLASS = "dx-list-item-badge",
            BADGE_CLASS = "dx-badge",
            LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container",
            LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
        TEMPLATE_GENERATORS.dxList = {
            item: function() {
                return TEMPLATE_GENERATORS.CollectionWidget.item().append($("<div>").attr("ng-if", "key").attr("ng-bind", "key"))
            },
            itemFrame: function() {
                var $badgeContainer = $("<div>").addClass(LIST_ITEM_BADGE_CONTAINER_CLASS).attr("ng-if", "badge"),
                    $badge = $("<div>").addClass(LIST_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).attr("ng-bind", "badge");
                var $chevronContainer = $("<div>").addClass(LIST_ITEM_CHEVRON_CONTAINER_CLASS).attr("ng-if", "showChevron"),
                    $chevron = $("<div>").addClass(LIST_ITEM_CHEVRON_CLASS);
                return TEMPLATE_GENERATORS.CollectionWidget.itemFrame().append($badgeContainer.append($badge)).append($chevronContainer.append($chevron))
            },
            group: function() {
                var $keyBinding = $("<div>").attr("ng-if", "key").attr("ng-bind", "key");
                return baseElements.container().append($keyBinding).append(baseElements.primitive())
            }
        };
        TEMPLATE_GENERATORS.dxDropDownMenu = {
            item: TEMPLATE_GENERATORS.dxList.item,
            content: TEMPLATE_GENERATORS.dxButton.content
        };
        TEMPLATE_GENERATORS.dxDropDownList = {item: TEMPLATE_GENERATORS.dxList.item};
        TEMPLATE_GENERATORS.dxRadioGroup = {item: TEMPLATE_GENERATORS.CollectionWidget.item};
        TEMPLATE_GENERATORS.dxScheduler = {
            item: function() {
                var $itemContent = TEMPLATE_GENERATORS.CollectionWidget.item();
                var $details = $("<div>").addClass("dx-scheduler-appointment-content-details");
                $("<div>").attr("ng-if", "startDate").addClass("dx-scheduler-appointment-content-date").text("{{startDate | date : 'shortTime' }}").appendTo($details);
                $("<div>").attr("ng-if", "endDate").addClass("dx-scheduler-appointment-content-date").text(" - ").appendTo($details);
                $("<div>").attr("ng-if", "endDate").addClass("dx-scheduler-appointment-content-date").text("{{endDate | date : 'shortTime' }}").appendTo($details);
                $details.appendTo($itemContent);
                $("<span>").attr("ng-if", "recurrenceRule").addClass("dx-scheduler-appointment-recurrence-icon dx-icon-repeat").appendTo($itemContent);
                return $itemContent
            },
            appointmentTooltip: emptyTemplate,
            appointmentPopup: emptyTemplate
        };
        TEMPLATE_GENERATORS.dxOverlay = {content: emptyTemplate};
        TEMPLATE_GENERATORS.dxSlideOutView = {
            menu: emptyTemplate,
            content: emptyTemplate
        };
        TEMPLATE_GENERATORS.dxSlideOut = {
            menuItem: TEMPLATE_GENERATORS.dxList.item,
            menuGroup: TEMPLATE_GENERATORS.dxList.group,
            content: emptyTemplate
        };
        TEMPLATE_GENERATORS.dxAccordion = {
            title: function() {
                var $titleBinding = $("<span>").attr("ng-if", "title").attr("ng-bind", "title"),
                    icon = $("<dx-icon>");
                return baseElements.container().append(icon).append($titleBinding).append(baseElements.primitive())
            },
            content: TEMPLATE_GENERATORS.CollectionWidget.item
        };
        TEMPLATE_GENERATORS.dxPivotTabs = {item: function() {
                return baseElements.container().append($("<span>").attr("ng-if", "title || scopeValue && scopeValue.title").attr("ng-bind", "title || scopeValue && scopeValue.title")).append(baseElements.primitive().attr("ng-if", "scopeValue && !scopeValue.title"))
            }};
        TEMPLATE_GENERATORS.dxPivot = {
            title: TEMPLATE_GENERATORS.dxPivotTabs.item,
            content: emptyTemplate
        };
        var PANORAMA_ITEM_TITLE_CLASS = "dx-panorama-item-title";
        TEMPLATE_GENERATORS.dxPanorama = {itemFrame: function() {
                return TEMPLATE_GENERATORS.CollectionWidget.itemFrame().prepend($("<div>").addClass(PANORAMA_ITEM_TITLE_CLASS).attr("ng-if", "title").attr("ng-bind", "title"))
            }};
        TEMPLATE_GENERATORS.dxActionSheet = {item: function() {
                return baseElements.container().append($("<div>").attr("dx-button", "{ bindingOptions: { text: 'text', onClick: 'onClick', type: 'type', disabled: 'disabled' } }"))
            }};
        TEMPLATE_GENERATORS.dxToolbar = {
            item: function() {
                var template = TEMPLATE_GENERATORS.CollectionWidget.item();
                $("<dx-polymorph-widget name=\"widget\" options=\"options\">").appendTo(template);
                return template
            },
            menuItem: TEMPLATE_GENERATORS.dxList.item,
            actionSheetItem: TEMPLATE_GENERATORS.dxActionSheet.item
        };
        var GALLERY_IMAGE_CLASS = "dx-gallery-item-image";
        TEMPLATE_GENERATORS.dxGallery = {item: function() {
                return baseElements.container().append(baseElements.html()).append(baseElements.text()).append($("<img>").addClass(GALLERY_IMAGE_CLASS).attr("ng-if", "scopeValue").attr("ng-src", "{{'' + scopeValue}}")).append($("<img>").addClass(GALLERY_IMAGE_CLASS).attr("ng-if", "imageSrc").attr("ng-src", "{{imageSrc}}").attr("ng-attr-alt", "{{imageAlt}}"))
            }};
        var TABS_ITEM_TEXT_CLASS = "dx-tab-text";
        TEMPLATE_GENERATORS.dxTabs = {
            item: function() {
                var container = baseElements.container();
                var icon = $("<dx-icon>"),
                    text = baseElements.text("<span>").addClass(TABS_ITEM_TEXT_CLASS);
                return container.append(baseElements.html()).append(icon).append(text).append(baseElements.primitive().addClass(TABS_ITEM_TEXT_CLASS))
            },
            itemFrame: function() {
                var $badge = $("<div>").addClass("dx-tabs-item-badge dx-badge").attr("ng-bind", "badge").attr("ng-if", "badge");
                return TEMPLATE_GENERATORS.CollectionWidget.itemFrame().append($badge)
            }
        };
        var NAVBAR_ITEM_BADGE_CLASS = "dx-navbar-item-badge";
        TEMPLATE_GENERATORS.dxNavBar = {itemFrame: function() {
                var $badge = $("<div>").addClass(NAVBAR_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).attr("ng-if", "badge").attr("ng-bind", "badge");
                return TEMPLATE_GENERATORS.CollectionWidget.itemFrame().append($badge)
            }};
        TEMPLATE_GENERATORS.dxMenuBase = {item: function() {
                var container = baseElements.container();
                var text = $("<span>").attr("ng-if", "text").addClass("dx-menu-item-text").attr("ng-bind", "text"),
                    icon = $("<dx-icon>"),
                    popout = $("<span>").addClass("dx-menu-item-popout-container").attr("ng-if", "items").append($("<div>").addClass("dx-menu-item-popout"));
                container.append(baseElements.html()).append(icon).append(text).append(popout).append(baseElements.primitive()).appendTo(container);
                return container
            }};
        TEMPLATE_GENERATORS.dxTreeView = {item: function() {
                var content = baseElements.container(),
                    link = $("<span/>").attr("ng-bind", "text"),
                    icon = $("<dx-icon>");
                content.append(baseElements.html()).append(icon).append(link).append(baseElements.primitive());
                return content
            }};
        TEMPLATE_GENERATORS.dxTabPanel = {
            item: TEMPLATE_GENERATORS.CollectionWidget.item,
            title: function() {
                var content = TEMPLATE_GENERATORS.dxTabs.item();
                content.find(".dx-tab-text").eq(0).attr("ng-bind", "title").attr("ng-if", "title");
                content.find("[ng-if='html']").remove();
                return content
            }
        };
        var popupTitleAndBottom = function() {
                return $("<div>").attr("dx-toolbar", "{ bindingOptions: { items: 'scopeValue' } }")
            };
        TEMPLATE_GENERATORS.dxPopup = {
            title: popupTitleAndBottom,
            bottom: popupTitleAndBottom
        };
        TEMPLATE_GENERATORS.dxLookup = {
            title: TEMPLATE_GENERATORS.dxPopup.title,
            group: TEMPLATE_GENERATORS.dxList.group
        };
        TEMPLATE_GENERATORS.dxTagBox = {tag: function() {
                return $("<div>").append($("<span>").attr("ng-bind", "scopeValue"))
            }};
        return TEMPLATE_GENERATORS
    });
    /*! Module core, file ng.template.js */
    DevExpress.define("/integration/angular/ng.template", ["jquery", "/ui/templates/ui.templateBase", "/utils/utils.dom"], function($, TemplateBase, domUtils) {
        var NgTemplate = TemplateBase.inherit({
                ctor: function(element, owner) {
                    this.callBase(element, owner);
                    this.setCompiler(this._getParentTemplateCompiler())
                },
                _getParentTemplateCompiler: function() {
                    var templateCompiler = null,
                        owner = this.owner();
                    while (!templateCompiler && owner) {
                        templateCompiler = $.isFunction(owner.option) ? owner.option("templateCompiler") : null;
                        owner = $.isFunction(owner.owner) ? owner.owner() : null
                    }
                    return templateCompiler
                },
                _renderCore: function(data, index, $container) {
                    var compiledTemplate = this._compiledTemplate,
                        result = $.isFunction(compiledTemplate) ? compiledTemplate(data, index, $container) : compiledTemplate;
                    return result
                },
                setCompiler: function(templateCompiler) {
                    if (!templateCompiler)
                        return;
                    this._compiledTemplate = templateCompiler(domUtils.normalizeTemplateElement(this._element))
                }
            });
        return NgTemplate
    });
    /*! Module core, file ng.templateProvider.js */
    DevExpress.define("/integration/angular/ng.templateProvider", ["jquery", "/utils/utils.dom", "/integration/jquery/jquery.templateProvider", "/integration/angular/ng.template", "/integration/angular/ng.defaultTemplates"], function($, domUtils, jqTemplateProvider, NgTemplate, defaultTemplates) {
        var NgTemplateProvider = jqTemplateProvider.constructor.inherit({
                createTemplate: function(element, owner) {
                    return new NgTemplate(element, owner)
                },
                getTemplates: function(widget) {
                    var templateCompiler = widget.option("templateCompiler"),
                        templates = this.callBase.apply(this, arguments);
                    $.each(templates, function(_, template) {
                        template.setCompiler && template.setCompiler(templateCompiler)
                    });
                    return templates
                },
                _templatesForWidget: function(widgetName) {
                    var templateGenerators = defaultTemplates[widgetName];
                    if (!templateGenerators)
                        return this.callBase(widgetName);
                    var templates = {};
                    $.each(templateGenerators, function(name, generator) {
                        var $markup = domUtils.createMarkupFromString(generator());
                        templates[name] = new NgTemplate($markup.wrap(), ngTemplateProvider)
                    });
                    return templates
                }
            });
        var ngTemplateProvider = new NgTemplateProvider;
        return ngTemplateProvider
    });
    /*! Module core, file ng.eventRegistrator.js */
    DevExpress.define("/integration/angular/ng.eventRegistrator", ["jquery", "/ui/events/ui.events.eventRegistrator", "/integration/angular/ng.module"], function($, eventRegistrator, ngModule) {
        eventRegistrator.callbacks.add(function(name, eventObject) {
            var ngEventName = name.slice(0, 2) + name.charAt(2).toUpperCase() + name.slice(3);
            ngModule.directive(ngEventName, ['$parse', function($parse) {
                    return function(scope, element, attr) {
                            var attrValue = $.trim(attr[ngEventName]),
                                handler,
                                eventOptions = {};
                            if (attrValue.charAt(0) === "{") {
                                eventOptions = scope.$eval(attrValue);
                                handler = $parse(eventOptions.execute)
                            }
                            else
                                handler = $parse(attr[ngEventName]);
                            element.on(name, eventOptions, function(e) {
                                scope.$apply(function() {
                                    handler(scope, {$event: e})
                                })
                            })
                        }
                }])
        })
    });
    /*! Module core, file ng.module.js */
    DevExpress.define("/integration/angular/ng.module", [], function() {
        return window.angular.module("dx", ["ngSanitize"])
    });
    /*! Module core, file ui.events.js */
    DevExpress.define("/ui/events/ui.events", ["/ui/uiNamespace", "/ui/events/pointer/ui.events.pointer"], function(uiNamespace) {
        uiNamespace.events = {}
    });
    DevExpress.require("/ui/events/ui.events");
    /*! Module core, file core.js */
    DevExpress.define("/core", ["/coreNamespace", "/errors", "/utils/utils.animationFrame", "/utils/utils.viewPort", "/utils/utils.hardwareBack", "/utils/utils.topOverlay", "/utils/utils.queue", "/eventsMixin", "/endpointSelector", "/color", "/devices", "/componentRegistrator", "/utils/utils"], function(namespace, errors, animationFrame, viewPortUtils, hardwareBack, topOverlay, queueUtils, EventsMixin, EndpointSelector, Color, devices, componentRegistrator) {
        namespace.requestAnimationFrame = function() {
            errors.log("W0000", "DevExpress.requestAnimationFrame", "15.2", "Use the 'DevExpress.utils.requestAnimationFrame' method instead.");
            return animationFrame.request.apply(animationFrame, arguments)
        };
        namespace.cancelAnimationFrame = function() {
            errors.log("W0000", "DevExpress.cancelAnimationFrame", "15.2", "Use the 'DevExpress.utils.cancelAnimationFrame' method instead.");
            return animationFrame.cancel.apply(animationFrame, arguments)
        };
        namespace.processHardwareBackButton = hardwareBack.process;
        namespace.hideTopOverlay = topOverlay.hide;
        namespace.registerComponent = componentRegistrator;
        namespace.EventsMixin = EventsMixin;
        namespace.EndpointSelector = EndpointSelector;
        namespace.devices = devices;
        namespace.createQueue = queueUtils.create;
        namespace.viewPort = viewPortUtils.value;
        namespace.Color = Color;
        return namespace
    });
    DevExpress.require(["/core"]);
    /*! Module core, file ui.js */
    DevExpress.define("/ui/ui", ["/ui/uiNamespace", "/ui/ui.dialog", "/core", "/ui/events/ui.events"], function(uiNamespace, dialog) {
        uiNamespace.notify = dialog.notify;
        uiNamespace.dialog = {
            custom: dialog.custom,
            alert: dialog.alert,
            confirm: dialog.confirm
        };
        return uiNamespace
    });
    DevExpress.require(["/ui/ui"]);
    /*! Module core, file jquery.js */
    DevExpress.define("/integration/jquery/jquery", ["jquery", "/errors", "/utils/utils.version"], function($, errors, versionUtils) {
        if (versionUtils.compare($.fn.jquery, [1, 10]) < 0)
            throw errors.Error("E0012");
    });
    DevExpress.require(["/integration/jquery/jquery"]);
    /*! Module core, file ko.js */
    DevExpress.define("/integration/knockout/ko", ["/utils/utils.support", "/errors", "/utils/utils.version", "require"], function(support, errors, versionUtils, require) {
        if (!support.hasKo)
            return;
        var ko = window.ko;
        if (versionUtils.compare(ko.version, [2, 3]) < 0)
            throw errors.Error("E0013");
        require(["/integration/knockout/ko.componentRegistrator", "/integration/knockout/ko.eventRegistrator", "/integration/knockout/ko.components", "/integration/knockout/ko.validation"]);
        if (versionUtils.compare($.fn.jquery, [2, 0]) >= 0)
            require(["/integration/knockout/ko.cleanNode"]);
        else
            require(["/integration/knockout/ko.cleanNodeIE8"])
    });
    DevExpress.require(["/integration/knockout/ko"]);
    /*! Module core, file ng.js */
    DevExpress.define("/integration/angular/ng", ["/utils/utils.support", "require"], function(support, require) {
        if (!support.hasNg)
            return;
        require(["/integration/angular/ng.componentRegistrator", "/integration/angular/ng.eventRegistrator", "/integration/angular/ng.components"])
    });
    DevExpress.require(["/integration/angular/ng"]);
    /*! Module core, file ui.events.emitter.click.js */
    (function($, DX, wnd, undefined) {
        var abs = Math.abs,
            events = DX.ui.events,
            devices = DX.require("/devices"),
            domUtils = DX.require("/utils/utils.dom"),
            animationFrame = DX.require("/utils/utils.animationFrame"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer"),
            Emitter = DX.require("/ui/events/ui.events.emitter"),
            registerEmitter = DX.require("/ui/events/ui.events.emitterRegistrator"),
            CLICK_EVENT_NAME = "dxclick",
            TOUCH_BOUNDARY = 10;
        DX.ui.events.__internals = DX.ui.events.__internals || {};
        var isInput = function(element) {
                return $(element).is("input, textarea, select, button ,:focus, :focus *")
            };
        var misc = {requestAnimationFrame: animationFrame.request};
        var ClickEmitter = Emitter.inherit({
                ctor: function(element) {
                    this.callBase(element);
                    this._makeElementClickable($(element))
                },
                _makeElementClickable: function($element) {
                    if (!$element.attr("onclick"))
                        $element.attr("onclick", "void(0)")
                },
                start: function(e) {
                    this._blurPrevented = e.dxPreventBlur;
                    this._startTarget = e.target;
                    this._startEventData = eventUtils.eventData(e)
                },
                end: function(e) {
                    if (this._eventOutOfElement(e, this.getElement().get(0)) || e.type === pointerEvents.cancel) {
                        this._cancel(e);
                        return
                    }
                    if (!isInput(e.target) && !this._blurPrevented)
                        domUtils.resetActiveElement();
                    this._accept(e);
                    misc.requestAnimationFrame($.proxy(function() {
                        this._fireClickEvent(e)
                    }, this))
                },
                _eventOutOfElement: function(e, element) {
                    var target = e.target,
                        targetChanged = !$.contains(element, target) && element !== target,
                        gestureDelta = eventUtils.eventDelta(eventUtils.eventData(e), this._startEventData),
                        boundsExceeded = abs(gestureDelta.x) > TOUCH_BOUNDARY || abs(gestureDelta.y) > TOUCH_BOUNDARY;
                    return targetChanged || boundsExceeded
                },
                _fireClickEvent: function(e) {
                    this._fireEvent(CLICK_EVENT_NAME, e, {target: domUtils.closestCommonParent(this._startTarget, e.target)})
                }
            });
        (function() {
            var useNativeClick = devices.real().generic;
            if (useNativeClick) {
                var prevented = null;
                ClickEmitter = ClickEmitter.inherit({
                    start: function() {
                        prevented = null
                    },
                    end: $.noop,
                    cancel: function() {
                        prevented = true
                    }
                });
                var clickHandler = function(e) {
                        if ((!e.which || e.which === 1) && !prevented)
                            eventUtils.fireEvent({
                                type: CLICK_EVENT_NAME,
                                originalEvent: e
                            })
                    };
                $(document).on(eventUtils.addNamespace("click", "NATIVE_DXCLICK_STRATEGY"), clickHandler)
            }
            $.extend(events.__internals, {useNativeClick: useNativeClick})
        })();
        (function() {
            var fixBuggyInertia = devices.real().ios;
            if (fixBuggyInertia) {
                var GESTURE_LOCK_KEY = "dxGestureLock";
                ClickEmitter = ClickEmitter.inherit({_fireClickEvent: function(e) {
                        var $element = $(e.target);
                        while ($element.length) {
                            if ($.data($element.get(0), GESTURE_LOCK_KEY))
                                return;
                            $element = $element.parent()
                        }
                        this.callBase.apply(this, arguments)
                    }})
            }
            $.extend(events.__internals, {fixBuggyInertia: fixBuggyInertia})
        })();
        (function() {
            var desktopDevice = devices.real().generic;
            if (!desktopDevice) {
                var startTarget = null,
                    blurPrevented = false;
                var pointerDownHandler = function(e) {
                        startTarget = e.target;
                        blurPrevented = e.dxPreventBlur
                    };
                var clickHandler = function(e) {
                        var $target = $(e.target);
                        if (!blurPrevented && startTarget && !$target.is(startTarget) && !$(startTarget).is("label") && isInput($target))
                            domUtils.resetActiveElement();
                        startTarget = null;
                        blurPrevented = false
                    };
                var NATIVE_CLICK_FIXER_NAMESPACE = "NATIVE_CLICK_FIXER";
                $(document).on(eventUtils.addNamespace(pointerEvents.down, NATIVE_CLICK_FIXER_NAMESPACE), pointerDownHandler).on(eventUtils.addNamespace("click", NATIVE_CLICK_FIXER_NAMESPACE), clickHandler)
            }
        })();
        registerEmitter({
            emitter: ClickEmitter,
            bubble: true,
            events: [CLICK_EVENT_NAME]
        });
        $.extend(events.__internals, {
            useFastClick: !events.__internals.useNativeClick && !events.__internals.fixBuggyInertia,
            misc: misc
        })
    })(jQuery, DevExpress, window);
    /*! Module core, file ui.events.emitter.hold.js */
    (function($, DX, undefined) {
        var eventUtils = DX.require("/ui/events/ui.events.utils"),
            Emitter = DX.require("/ui/events/ui.events.emitter"),
            registerEmitter = DX.require("/ui/events/ui.events.emitterRegistrator"),
            abs = Math.abs,
            HOLD_EVENT_NAME = "dxhold",
            HOLD_TIMEOUT = 750,
            TOUCH_BOUNDARY = 5;
        var HoldEmitter = Emitter.inherit({
                start: function(e) {
                    this._startEventData = eventUtils.eventData(e);
                    this._startTimer(e)
                },
                _startTimer: function(e) {
                    var holdTimeout = "timeout" in this ? this.timeout : HOLD_TIMEOUT;
                    this._holdTimer = setTimeout($.proxy(function() {
                        this._requestAccept(e);
                        this._fireEvent(HOLD_EVENT_NAME, e, {target: e.target});
                        this._forgetAccept()
                    }, this), holdTimeout)
                },
                move: function(e) {
                    if (this._touchWasMoved(e))
                        this._cancel(e)
                },
                _touchWasMoved: function(e) {
                    var delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));
                    return abs(delta.x) > TOUCH_BOUNDARY || abs(delta.y) > TOUCH_BOUNDARY
                },
                end: function() {
                    this._stopTimer()
                },
                _stopTimer: function() {
                    clearTimeout(this._holdTimer)
                },
                cancel: function() {
                    this._stopTimer()
                }
            });
        registerEmitter({
            emitter: HoldEmitter,
            bubble: true,
            events: [HOLD_EVENT_NAME]
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.emitter.gesture.scroll.js */
    (function($, DX, undefined) {
        var eventUtils = DX.require("/ui/events/ui.events.utils"),
            GestureEmitter = DX.require("/ui/events/ui.events.emitter.gesture"),
            registerEmitter = DX.require("/ui/events/ui.events.emitterRegistrator");
        var SCROLL_INIT_EVENT = "dxscrollinit",
            SCROLL_START_EVENT = "dxscrollstart",
            SCROLL_MOVE_EVENT = "dxscroll",
            SCROLL_END_EVENT = "dxscrollend",
            SCROLL_STOP_EVENT = "dxscrollstop",
            SCROLL_CANCEL_EVENT = "dxscrollcancel",
            INERTIA_TIMEOUT = 100,
            VELOCITY_CALC_TIMEOUT = 200,
            FRAME_DURATION = Math.round(1000 / 60),
            GESTURE_LOCK_KEY = "dxGestureLock",
            GESTURE_UNLOCK_TIMEOUT = 400,
            NAMESPACED_SCROLL_EVENT = eventUtils.addNamespace("scroll", "dxScrollEmitter");
        var isWheelEvent = function(e) {
                return e.type === "dxmousewheel"
            };
        var ScrollEmitter = GestureEmitter.inherit({
                ctor: function(element) {
                    this.callBase.apply(this, arguments);
                    this.direction = "both";
                    this._lastWheelDirection = null;
                    this._proxiedTreatScroll = $.proxy(this._treatScroll, this);
                    $(element).on(NAMESPACED_SCROLL_EVENT, this._proxiedTreatScroll)
                },
                validate: function() {
                    return true
                },
                _domElement: function() {
                    return this.getElement().get(0)
                },
                _treatScroll: function() {
                    this._prepareGesture();
                    this._forgetGesture()
                },
                _prepareGesture: function() {
                    if (this._gestureEndTimer)
                        this._clearGestureTimer();
                    $.data(this._domElement(), GESTURE_LOCK_KEY, true)
                },
                _clearGestureTimer: function() {
                    clearTimeout(this._gestureEndTimer);
                    $.data(this._domElement(), GESTURE_LOCK_KEY, false);
                    this._gestureEndTimer = null
                },
                _forgetGesture: function() {
                    var that = this;
                    this._gestureEndTimer = setTimeout(function() {
                        that._clearGestureTimer()
                    }, GESTURE_UNLOCK_TIMEOUT)
                },
                _init: function(e) {
                    if (!this._wheelDirectionChanged(e) && $.data(this._domElement(), GESTURE_LOCK_KEY))
                        this._accept(e);
                    else
                        this._clearGestureTimer();
                    this._fireEvent(SCROLL_INIT_EVENT, e)
                },
                _wheelDirectionChanged: function(e) {
                    if (!isWheelEvent(e))
                        return false;
                    var direction = e.shiftKey;
                    var result = this._lastWheelDirection !== null && direction !== this._lastWheelDirection;
                    this._lastWheelDirection = direction;
                    return result
                },
                move: function(e) {
                    this.callBase.apply(this, arguments);
                    e.isScrollingEvent = this.isNative || e.isScrollingEvent
                },
                _start: function(e) {
                    this._savedEventData = eventUtils.eventData(e);
                    this._fireEvent(SCROLL_START_EVENT, e, {delta: eventUtils.eventDelta(this._savedEventData, eventUtils.eventData(e))})
                },
                _move: function(e) {
                    var currentEventData = eventUtils.eventData(e);
                    this._fireEvent(SCROLL_MOVE_EVENT, e, {delta: eventUtils.eventDelta(this._prevEventData, currentEventData)});
                    var eventDelta = eventUtils.eventDelta(this._savedEventData, currentEventData);
                    if (eventDelta.time > VELOCITY_CALC_TIMEOUT)
                        this._savedEventData = this._prevEventData
                },
                _end: function(e) {
                    var endEventDelta = eventUtils.eventDelta(this._prevEventData, eventUtils.eventData(e));
                    var velocity = {
                            x: 0,
                            y: 0
                        };
                    if (!isWheelEvent(e) && endEventDelta.time < INERTIA_TIMEOUT) {
                        var eventDelta = eventUtils.eventDelta(this._savedEventData, this._prevEventData),
                            velocityMultiplier = FRAME_DURATION / eventDelta.time;
                        velocity = {
                            x: eventDelta.x * velocityMultiplier,
                            y: eventDelta.y * velocityMultiplier
                        }
                    }
                    this._fireEvent(SCROLL_END_EVENT, e, {velocity: velocity})
                },
                _stop: function(e) {
                    this._fireEvent(SCROLL_STOP_EVENT, e)
                },
                cancel: function(e) {
                    this.callBase.apply(this, arguments);
                    this._fireEvent(SCROLL_CANCEL_EVENT, e)
                },
                dispose: function() {
                    this.callBase.apply(this, arguments);
                    this._clearGestureTimer();
                    this.getElement().off(NAMESPACED_SCROLL_EVENT, this._proxiedTreatScroll)
                }
            });
        registerEmitter({
            emitter: ScrollEmitter,
            events: [SCROLL_INIT_EVENT, SCROLL_START_EVENT, SCROLL_MOVE_EVENT, SCROLL_END_EVENT, SCROLL_STOP_EVENT, SCROLL_CANCEL_EVENT]
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.emitter.gesture.swipe.js */
    (function($, DX, undefined) {
        var eventUtils = DX.require("/ui/events/ui.events.utils"),
            GestureEmitter = DX.require("/ui/events/ui.events.emitter.gesture"),
            registerEmitter = DX.require("/ui/events/ui.events.emitterRegistrator"),
            SWIPE_START_EVENT = "dxswipestart",
            SWIPE_EVENT = "dxswipe",
            SWIPE_END_EVENT = "dxswipeend";
        var HorizontalStrategy = {
                defaultItemSizeFunc: function() {
                    return this.getElement().width()
                },
                getBounds: function() {
                    return [this._maxLeftOffset, this._maxRightOffset]
                },
                calcOffsetRatio: function(e) {
                    var endEventData = eventUtils.eventData(e);
                    return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e)
                },
                isFastSwipe: function(e) {
                    var endEventData = eventUtils.eventData(e);
                    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time
                }
            };
        var VerticalStrategy = {
                defaultItemSizeFunc: function() {
                    return this.getElement().height()
                },
                getBounds: function() {
                    return [this._maxTopOffset, this._maxBottomOffset]
                },
                calcOffsetRatio: function(e) {
                    var endEventData = eventUtils.eventData(e);
                    return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e)
                },
                isFastSwipe: function(e) {
                    var endEventData = eventUtils.eventData(e);
                    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time
                }
            };
        var STRATEGIES = {
                horizontal: HorizontalStrategy,
                vertical: VerticalStrategy
            };
        var SwipeEmitter = GestureEmitter.inherit({
                TICK_INTERVAL: 300,
                FAST_SWIPE_SPEED_LIMIT: 10,
                ctor: function(element) {
                    this.callBase(element);
                    this.direction = "horizontal";
                    this.elastic = true
                },
                _getStrategy: function() {
                    return STRATEGIES[this.direction]
                },
                _defaultItemSizeFunc: function() {
                    return this._getStrategy().defaultItemSizeFunc.call(this)
                },
                _itemSizeFunc: function() {
                    return this.itemSizeFunc || this._defaultItemSizeFunc
                },
                _init: function(e) {
                    this._tickData = eventUtils.eventData(e)
                },
                _start: function(e) {
                    this._savedEventData = eventUtils.eventData(e);
                    e = this._fireEvent(SWIPE_START_EVENT, e);
                    if (!e.cancel) {
                        this._maxLeftOffset = e.maxLeftOffset;
                        this._maxRightOffset = e.maxRightOffset;
                        this._maxTopOffset = e.maxTopOffset;
                        this._maxBottomOffset = e.maxBottomOffset
                    }
                },
                _move: function(e) {
                    var strategy = this._getStrategy(),
                        moveEventData = eventUtils.eventData(e),
                        offset = strategy.calcOffsetRatio.call(this, e);
                    offset = this._fitOffset(offset, this.elastic);
                    if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL)
                        this._tickData = moveEventData;
                    this._fireEvent(SWIPE_EVENT, e, {offset: offset});
                    e.preventDefault()
                },
                _end: function(e) {
                    var strategy = this._getStrategy(),
                        offsetRatio = strategy.calcOffsetRatio.call(this, e),
                        isFast = strategy.isFastSwipe.call(this, e),
                        startOffset = offsetRatio,
                        targetOffset = this._calcTargetOffset(offsetRatio, isFast);
                    startOffset = this._fitOffset(startOffset, this.elastic);
                    targetOffset = this._fitOffset(targetOffset, false);
                    this._fireEvent(SWIPE_END_EVENT, e, {
                        offset: startOffset,
                        targetOffset: targetOffset
                    })
                },
                _fitOffset: function(offset, elastic) {
                    var strategy = this._getStrategy(),
                        bounds = strategy.getBounds.call(this);
                    if (offset < -bounds[0])
                        return elastic ? (-2 * bounds[0] + offset) / 3 : -bounds[0];
                    if (offset > bounds[1])
                        return elastic ? (2 * bounds[1] + offset) / 3 : bounds[1];
                    return offset
                },
                _calcTargetOffset: function(offsetRatio, isFast) {
                    var result;
                    if (isFast) {
                        result = Math.ceil(Math.abs(offsetRatio));
                        if (offsetRatio < 0)
                            result = -result
                    }
                    else
                        result = Math.round(offsetRatio);
                    return result
                }
            });
        registerEmitter({
            emitter: SwipeEmitter,
            events: [SWIPE_START_EVENT, SWIPE_EVENT, SWIPE_END_EVENT]
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.emitter.gesture.drag.js */
    (function($, DX, undefined) {
        var wrapToArray = DX.require("/utils/utils.array").wrapToArray,
            registerEvent = DX.require("/ui/events/ui.events.eventRegistrator"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            GestureEmitter = DX.require("/ui/events/ui.events.emitter.gesture"),
            registerEmitter = DX.require("/ui/events/ui.events.emitterRegistrator");
        var DRAG_START_EVENT = "dxdragstart",
            DRAG_EVENT = "dxdrag",
            DRAG_END_EVENT = "dxdragend",
            DRAG_ENTER_EVENT = "dxdragenter",
            DRAG_LEAVE_EVENT = "dxdragleave",
            DROP_EVENT = "dxdrop";
        var knownDropTargets = [],
            knownDropTargetSelectors = [],
            knownDropTargetConfigs = [];
        var dropTargetRegistration = {
                setup: function(element, data) {
                    var knownDropTarget = $.inArray(element, knownDropTargets) !== -1;
                    if (!knownDropTarget) {
                        knownDropTargets.push(element);
                        knownDropTargetSelectors.push([]);
                        knownDropTargetConfigs.push(data || {})
                    }
                },
                add: function(element, handleObj) {
                    var index = $.inArray(element, knownDropTargets);
                    var selector = handleObj.selector;
                    if ($.inArray(selector, knownDropTargetSelectors[index]) === -1)
                        knownDropTargetSelectors[index].push(selector)
                },
                teardown: function(element, data) {
                    var elementEvents = $._data(element, "events"),
                        handlersCount = 0;
                    $.each([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT], function(_, eventName) {
                        var eventHandlers = elementEvents[eventName];
                        if (eventHandlers)
                            handlersCount += eventHandlers.length
                    });
                    if (!handlersCount) {
                        var index = $.inArray(element, knownDropTargets);
                        knownDropTargets.splice(index, 1);
                        knownDropTargetSelectors.splice(index, 1);
                        knownDropTargetConfigs.splice(index, 1)
                    }
                }
            };
        registerEvent(DRAG_ENTER_EVENT, dropTargetRegistration);
        registerEvent(DRAG_LEAVE_EVENT, dropTargetRegistration);
        registerEvent(DROP_EVENT, dropTargetRegistration);
        var getItemDelegatedTargets = function($element) {
                var dropTargetIndex = $.inArray($element.get(0), knownDropTargets),
                    dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex];
                var $delegatedTargets = $element.find(dropTargetSelectors.join(", "));
                if ($.inArray(undefined, dropTargetSelectors) !== -1)
                    $delegatedTargets = $delegatedTargets.addBack();
                return $delegatedTargets
            };
        var getItemConfig = function($element) {
                var dropTargetIndex = $.inArray($element.get(0), knownDropTargets);
                return knownDropTargetConfigs[dropTargetIndex]
            };
        var getItemPosition = function(dropTargetConfig, $element) {
                if (dropTargetConfig.itemPositionFunc)
                    return dropTargetConfig.itemPositionFunc($element);
                else
                    return $element.offset()
            };
        var getItemSize = function(dropTargetConfig, $element) {
                if (dropTargetConfig.itemSizeFunc)
                    return dropTargetConfig.itemSizeFunc($element);
                return {
                        width: $element.width(),
                        height: $element.height()
                    }
            };
        var DragEmitter = GestureEmitter.inherit({
                ctor: function(element) {
                    this.callBase(element);
                    this.direction = "both"
                },
                _init: function(e) {
                    this._initEvent = e
                },
                _start: function(e) {
                    e = this._fireEvent(DRAG_START_EVENT, this._initEvent);
                    this._maxLeftOffset = e.maxLeftOffset;
                    this._maxRightOffset = e.maxRightOffset;
                    this._maxTopOffset = e.maxTopOffset;
                    this._maxBottomOffset = e.maxBottomOffset;
                    var dropTargets = wrapToArray(e.targetElements || (e.targetElements === null ? [] : knownDropTargets));
                    this._dropTargets = $.map(dropTargets, function(element) {
                        return $(element).get(0)
                    })
                },
                _move: function(e) {
                    var eventData = eventUtils.eventData(e),
                        dragOffset = this._calculateOffset(eventData);
                    this._fireEvent(DRAG_EVENT, e, {offset: dragOffset});
                    this._processDropTargets(e, dragOffset);
                    e.preventDefault()
                },
                _calculateOffset: function(eventData) {
                    return {
                            x: this._calculateXOffset(eventData),
                            y: this._calculateYOffset(eventData)
                        }
                },
                _calculateXOffset: function(eventData) {
                    if (this.direction !== "vertical") {
                        var offset = eventData.x - this._startEventData.x;
                        return this._fitOffset(offset, this._maxLeftOffset, this._maxRightOffset)
                    }
                    return 0
                },
                _calculateYOffset: function(eventData) {
                    if (this.direction !== "horizontal") {
                        var offset = eventData.y - this._startEventData.y;
                        return this._fitOffset(offset, this._maxTopOffset, this._maxBottomOffset)
                    }
                    return 0
                },
                _fitOffset: function(offset, minOffset, maxOffset) {
                    if (minOffset != null)
                        offset = Math.max(offset, -minOffset);
                    if (maxOffset != null)
                        offset = Math.min(offset, maxOffset);
                    return offset
                },
                _processDropTargets: function(e, dragOffset) {
                    var target = this._findDropTarget(e),
                        sameTarget = target === this._currentDropTarget;
                    if (!sameTarget) {
                        this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
                        this._currentDropTarget = target;
                        this._fireDropTargetEvent(e, DRAG_ENTER_EVENT)
                    }
                },
                _fireDropTargetEvent: function(event, eventName) {
                    if (!this._currentDropTarget)
                        return;
                    var eventData = {
                            type: eventName,
                            originalEvent: event,
                            draggingElement: this._$element.get(0),
                            target: this._currentDropTarget
                        };
                    eventUtils.fireEvent(eventData)
                },
                _findDropTarget: function(e) {
                    var that = this,
                        result;
                    $.each(knownDropTargets, function(_, target) {
                        if (!that._checkDropTargetActive(target))
                            return;
                        var $target = $(target);
                        $.each(getItemDelegatedTargets($target), function(_, delegatedTarget) {
                            var $delegatedTarget = $(delegatedTarget);
                            if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, e))
                                result = delegatedTarget
                        })
                    });
                    return result
                },
                _checkDropTargetActive: function(target) {
                    var active = false;
                    $.each(this._dropTargets, function(_, activeTarget) {
                        active = active || activeTarget === target || $.contains(activeTarget, target);
                        return !active
                    });
                    return active
                },
                _checkDropTarget: function(config, $target, e) {
                    var isDraggingElement = $target.get(0) === this._$element.get(0);
                    if (isDraggingElement)
                        return false;
                    var targetPosition = getItemPosition(config, $target);
                    if (e.pageX < targetPosition.left)
                        return false;
                    if (e.pageY < targetPosition.top)
                        return false;
                    var targetSize = getItemSize(config, $target);
                    if (e.pageX > targetPosition.left + targetSize.width)
                        return false;
                    if (e.pageY > targetPosition.top + targetSize.height)
                        return false;
                    return $target
                },
                _end: function(e) {
                    var eventData = eventUtils.eventData(e);
                    this._fireEvent(DRAG_END_EVENT, e, {offset: this._calculateOffset(eventData)});
                    this._fireDropTargetEvent(e, DROP_EVENT);
                    delete this._currentDropTarget
                }
            });
        registerEmitter({
            emitter: DragEmitter,
            events: [DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT]
        });
        DX.ui.events.__internals = DX.ui.events.__internals || {};
        $.extend(DX.ui.events.__internals, {dropTargets: knownDropTargets})
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.emitter.transform.js */
    (function($, DX, undefined) {
        var mathUtils = DX.require("/utils/utils.math"),
            errors = DX.require("/ui/ui.errors"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            Emitter = DX.require("/ui/events/ui.events.emitter"),
            registerEmitter = DX.require("/ui/events/ui.events.emitterRegistrator");
        var DX_PREFIX = "dx",
            TRANSFORM = "transform",
            TRANSLATE = "translate",
            ZOOM = "zoom",
            PINCH = "pinch",
            ROTATE = "rotate",
            START_POSTFIX = "start",
            UPDATE_POSTFIX = "",
            END_POSTFIX = "end";
        var eventAliases = [];
        var addAlias = function(eventName, eventArgs) {
                eventAliases.push({
                    name: eventName,
                    args: eventArgs
                })
            };
        addAlias(TRANSFORM, {
            scale: true,
            deltaScale: true,
            rotation: true,
            deltaRotation: true,
            translation: true,
            deltaTranslation: true
        });
        addAlias(TRANSLATE, {
            translation: true,
            deltaTranslation: true
        });
        addAlias(ZOOM, {
            scale: true,
            deltaScale: true
        });
        addAlias(PINCH, {
            scale: true,
            deltaScale: true
        });
        addAlias(ROTATE, {
            rotation: true,
            deltaRotation: true
        });
        var getVector = function(first, second) {
                return {
                        x: second.pageX - first.pageX,
                        y: -second.pageY + first.pageY,
                        centerX: (second.pageX + first.pageX) * 0.5,
                        centerY: (second.pageY + first.pageY) * 0.5
                    }
            };
        var getEventVector = function(e) {
                var pointers = e.pointers;
                return getVector(pointers[0], pointers[1])
            };
        var getDistance = function(vector) {
                return Math.sqrt(vector.x * vector.x + vector.y * vector.y)
            };
        var getScale = function(firstVector, secondVector) {
                return getDistance(firstVector) / getDistance(secondVector)
            };
        var getRotation = function(firstVector, secondVector) {
                var scalarProduct = firstVector.x * secondVector.x + firstVector.y * secondVector.y;
                var distanceProduct = getDistance(firstVector) * getDistance(secondVector);
                if (distanceProduct === 0)
                    return 0;
                var sign = mathUtils.sign(firstVector.x * secondVector.y - secondVector.x * firstVector.y);
                var angle = Math.acos(mathUtils.fitIntoRange(scalarProduct / distanceProduct, -1, 1));
                return sign * angle
            };
        var getTranslation = function(firstVector, secondVector) {
                return {
                        x: firstVector.centerX - secondVector.centerX,
                        y: firstVector.centerY - secondVector.centerY
                    }
            };
        var TransformEmitter = Emitter.inherit({
                configurate: function(data, eventName) {
                    if (eventName.indexOf(ZOOM) > -1)
                        errors.log("W0005", eventName, "15.1", "Use '" + eventName.replace(ZOOM, PINCH) + "' event instead");
                    this.callBase(data)
                },
                validatePointers: function(e) {
                    return eventUtils.hasTouches(e) > 1
                },
                start: function(e) {
                    this._accept(e);
                    var startVector = getEventVector(e);
                    this._startVector = startVector;
                    this._prevVector = startVector;
                    this._fireEventAliases(START_POSTFIX, e)
                },
                move: function(e) {
                    var currentVector = getEventVector(e),
                        eventArgs = this._getEventArgs(currentVector);
                    this._fireEventAliases(UPDATE_POSTFIX, e, eventArgs);
                    this._prevVector = currentVector
                },
                end: function(e) {
                    var eventArgs = this._getEventArgs(this._prevVector);
                    this._fireEventAliases(END_POSTFIX, e, eventArgs)
                },
                _getEventArgs: function(vector) {
                    return {
                            scale: getScale(vector, this._startVector),
                            deltaScale: getScale(vector, this._prevVector),
                            rotation: getRotation(vector, this._startVector),
                            deltaRotation: getRotation(vector, this._prevVector),
                            translation: getTranslation(vector, this._startVector),
                            deltaTranslation: getTranslation(vector, this._prevVector)
                        }
                },
                _fireEventAliases: function(eventPostfix, originalEvent, eventArgs) {
                    eventArgs = eventArgs || {};
                    $.each(eventAliases, $.proxy(function(_, eventAlias) {
                        var args = {};
                        $.each(eventAlias.args, function(name) {
                            if (name in eventArgs)
                                args[name] = eventArgs[name]
                        });
                        this._fireEvent(DX_PREFIX + eventAlias.name + eventPostfix, originalEvent, args)
                    }, this))
                }
            });
        registerEmitter({
            emitter: TransformEmitter,
            events: $.map(eventAliases, function(eventAlias) {
                var eventNames = [];
                $.each([START_POSTFIX, UPDATE_POSTFIX, END_POSTFIX], function(_, eventPostfix) {
                    eventNames.push(DX_PREFIX + eventAlias.name + eventPostfix)
                });
                return eventNames
            })
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.dblclick.js */
    (function($, DX, undefined) {
        var domUtils = DX.require("/utils/utils.dom"),
            Class = DX.require("/class"),
            registerEvent = DX.require("/ui/events/ui.events.eventRegistrator"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            DBLCLICK_EVENT_NAME = "dxdblclick",
            DBLCLICK_NAMESPACE = "dxDblClick",
            NAMESPACED_CLICK_EVENT = eventUtils.addNamespace("dxclick", DBLCLICK_NAMESPACE),
            DBLCLICK_TIMEOUT = 300;
        var DblClick = Class.inherit({
                ctor: function() {
                    this._handlerCount = 0;
                    this._forgetLastClick()
                },
                _forgetLastClick: function() {
                    this._firstClickTarget = null;
                    this._lastClickTimeStamp = -DBLCLICK_TIMEOUT
                },
                add: function() {
                    if (this._handlerCount <= 0)
                        $(document).on(NAMESPACED_CLICK_EVENT, $.proxy(this._clickHandler, this));
                    this._handlerCount++
                },
                _clickHandler: function(e) {
                    var timeStamp = e.timeStamp || $.now();
                    if (timeStamp - this._lastClickTimeStamp < DBLCLICK_TIMEOUT) {
                        eventUtils.fireEvent({
                            type: DBLCLICK_EVENT_NAME,
                            target: domUtils.closestCommonParent(this._firstClickTarget, e.target),
                            originalEvent: e
                        });
                        this._forgetLastClick()
                    }
                    else {
                        this._firstClickTarget = e.target;
                        this._lastClickTimeStamp = timeStamp
                    }
                },
                remove: function() {
                    this._handlerCount--;
                    if (this._handlerCount <= 0) {
                        this._forgetLastClick();
                        $(document).off(NAMESPACED_CLICK_EVENT)
                    }
                }
            });
        registerEvent(DBLCLICK_EVENT_NAME, new DblClick)
    })(jQuery, DevExpress);
    /*! Module core, file ui.events.contextmenu.js */
    (function($, DX, undefined) {
        var support = DX.require("/utils/utils.support"),
            devices = DX.require("/devices"),
            Class = DX.require("/class"),
            registerEvent = DX.require("/ui/events/ui.events.eventRegistrator"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            CONTEXTMENU_NAMESPACE = "dxContexMenu",
            CONTEXTMENU_NAMESPACED_EVENT_NAME = eventUtils.addNamespace("contextmenu", CONTEXTMENU_NAMESPACE),
            HOLD_NAMESPACED_EVENT_NAME = eventUtils.addNamespace("dxhold", CONTEXTMENU_NAMESPACE),
            CONTEXTMENU_EVENT_NAME = "dxcontextmenu";
        var ContextMenu = Class.inherit({
                setup: function(element, data) {
                    var $element = $(element);
                    $element.on(CONTEXTMENU_NAMESPACED_EVENT_NAME, $.proxy(this._contextMenuHandler, this));
                    if (support.touch || devices.isSimulator())
                        $element.on(HOLD_NAMESPACED_EVENT_NAME, $.proxy(this._holdHandler, this))
                },
                _holdHandler: function(e) {
                    if (eventUtils.isMouseEvent(e) && !devices.isSimulator())
                        return;
                    this._fireContextMenu(e)
                },
                _contextMenuHandler: function(e) {
                    e = this._fireContextMenu(e);
                    if (!e.cancel)
                        e.preventDefault()
                },
                _fireContextMenu: function(e) {
                    return eventUtils.fireEvent({
                            type: CONTEXTMENU_EVENT_NAME,
                            originalEvent: e
                        })
                },
                teardown: function(element) {
                    $(element).off("." + CONTEXTMENU_NAMESPACE)
                }
            });
        registerEvent(CONTEXTMENU_EVENT_NAME, new ContextMenu)
    })(jQuery, DevExpress);
    /*! Module core, file ui.dataHelper.js */
    DevExpress.define("/ui/ui.dataHelper", ["jquery"], function($) {
        var data = DevExpress.data;
        var DATA_SOURCE_OPTIONS_METHOD = "_dataSourceOptions",
            DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler",
            DATA_SOURCE_LOAD_ERROR_METHOD = "_dataSourceLoadErrorHandler",
            DATA_SOURCE_LOADING_CHANGED_METHOD = "_dataSourceLoadingChangedHandler";
        var DataHelperMixin = {
                postCtor: function() {
                    this.on("disposing", function() {
                        this._disposeDataSource()
                    })
                },
                _refreshDataSource: function() {
                    this._initDataSource();
                    this._loadDataSource()
                },
                _initDataSource: function() {
                    var dataSourceOptions = this.option("dataSource"),
                        widgetDataSourceOptions,
                        dataSourceType;
                    this._disposeDataSource();
                    if (dataSourceOptions) {
                        if (dataSourceOptions instanceof data.DataSource) {
                            this._isSharedDataSource = true;
                            this._dataSource = dataSourceOptions
                        }
                        else {
                            widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {};
                            dataSourceType = this._dataSourceType ? this._dataSourceType() : data.DataSource;
                            this._dataSource = new dataSourceType($.extend(true, {}, widgetDataSourceOptions, data.utils.normalizeDataSourceOptions(dataSourceOptions)))
                        }
                        this._addDataSourceHandlers()
                    }
                },
                _addDataSourceHandlers: function() {
                    if (DATA_SOURCE_CHANGED_METHOD in this)
                        this._addDataSourceChangeHandler();
                    if (DATA_SOURCE_LOAD_ERROR_METHOD in this)
                        this._addDataSourceLoadErrorHandler();
                    if (DATA_SOURCE_LOADING_CHANGED_METHOD in this)
                        this._addDataSourceLoadingChangedHandler();
                    this._addReadyWatcher()
                },
                _addReadyWatcher: function() {
                    this._dataSource.on("loadingChanged", $.proxy(function(isLoading) {
                        this._ready && this._ready(!isLoading)
                    }, this))
                },
                _addDataSourceChangeHandler: function() {
                    var dataSource = this._dataSource;
                    this._proxiedDataSourceChangedHandler = $.proxy(function() {
                        this[DATA_SOURCE_CHANGED_METHOD](dataSource.items())
                    }, this);
                    dataSource.on("changed", this._proxiedDataSourceChangedHandler)
                },
                _addDataSourceLoadErrorHandler: function() {
                    this._proxiedDataSourceLoadErrorHandler = $.proxy(this[DATA_SOURCE_LOAD_ERROR_METHOD], this);
                    this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler)
                },
                _addDataSourceLoadingChangedHandler: function() {
                    this._proxiedDataSourceLoadingChangedHandler = $.proxy(this[DATA_SOURCE_LOADING_CHANGED_METHOD], this);
                    this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
                },
                _loadDataSource: function() {
                    if (this._dataSource) {
                        var dataSource = this._dataSource;
                        if (dataSource.isLoaded())
                            this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
                        else
                            dataSource.load()
                    }
                },
                _loadSingle: function(key, value) {
                    key = key === "this" ? this._dataSource.key() || "this" : key;
                    return this._dataSource.loadSingle(key, value)
                },
                _isLastPage: function() {
                    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize
                },
                _isDataSourceLoading: function() {
                    return this._dataSource && this._dataSource.isLoading()
                },
                _disposeDataSource: function() {
                    if (this._dataSource) {
                        if (this._isSharedDataSource) {
                            delete this._isSharedDataSource;
                            this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
                            this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
                            this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
                        }
                        else
                            this._dataSource.dispose();
                        delete this._dataSource;
                        delete this._proxiedDataSourceChangedHandler;
                        delete this._proxiedDataSourceLoadErrorHandler;
                        delete this._proxiedDataSourceLoadingChangedHandler
                    }
                }
            };
        return DataHelperMixin
    });
    /*! Module core, file ui.dataExpression.js */
    DevExpress.define("/ui/ui.dataExpression", ["jquery", "/utils/utils.knockout", "/utils/utils.common", "/ui/templates/ui.template.function", "/ui/ui.dataHelper"], function($, koUtils, commonUtils, FunctionTempalte, DataHelperMixin) {
        var dataUtils = DevExpress.data.utils;
        var DataExpressionMixin = $.extend(DataHelperMixin, {
                _dataExpressionDefaultOptions: function() {
                    return {
                            items: [],
                            dataSource: null,
                            itemTemplate: "item",
                            value: null,
                            valueExpr: "this",
                            displayExpr: undefined
                        }
                },
                _initDataExpressions: function() {
                    this._compileValueGetter();
                    this._compileDisplayGetter();
                    this._initDynamicTemplates();
                    this._initDataSource();
                    this._itemsToDataSource()
                },
                _itemsToDataSource: function() {
                    if (!this.option("dataSource"))
                        this._dataSource = new DevExpress.data.DataSource({
                            store: new DevExpress.data.ArrayStore(this.option("items")),
                            pageSize: 0
                        })
                },
                _compileDisplayGetter: function() {
                    this._displayGetter = dataUtils.compileGetter(this._displayGetterExpr())
                },
                _displayGetterExpr: function() {
                    return this.option("displayExpr")
                },
                _compileValueGetter: function() {
                    this._valueGetter = dataUtils.compileGetter(this._valueGetterExpr())
                },
                _valueGetterExpr: function() {
                    return this.option("valueExpr") || "this"
                },
                _loadValue: function(value) {
                    var deferred = $.Deferred();
                    value = this._unwrappedValue(value);
                    if (!commonUtils.isDefined(value))
                        return deferred.reject().promise();
                    this._loadSingle(this._valueGetterExpr(), value).done($.proxy(function(item) {
                        this._isValueEquals(this._valueGetter(item), value) ? deferred.resolve(item) : deferred.reject()
                    }, this)).fail(function() {
                        deferred.reject()
                    });
                    return deferred.promise()
                },
                _unwrappedValue: function(value) {
                    value = commonUtils.isDefined(value) ? value : this.option("value");
                    if (value && this._dataSource && this._valueGetterExpr() === "this") {
                        var key = this._dataSource.key();
                        if (key && typeof value === "object")
                            value = value[key]
                    }
                    return koUtils.unwrapObservable(value)
                },
                _isValueEquals: function(value1, value2) {
                    var isDefined = commonUtils.isDefined;
                    var ensureDefined = commonUtils.ensureDefined;
                    var unwrapObservable = koUtils.unwrapObservable;
                    var dataSourceKey = this._dataSource && this._dataSource.key();
                    var result = this._compareValues(value1, value2);
                    if (!result && isDefined(value1) && isDefined(value2) && dataSourceKey) {
                        var valueKey1 = ensureDefined(unwrapObservable(value1[dataSourceKey]), value1);
                        var valueKey2 = ensureDefined(unwrapObservable(value2[dataSourceKey]), value2);
                        result = this._compareValues(valueKey1, valueKey2)
                    }
                    return result
                },
                _compareValues: function(value1, value2) {
                    return dataUtils.toComparable(value1) === dataUtils.toComparable(value2)
                },
                _initDynamicTemplates: function() {
                    if (this._displayGetterExpr())
                        this._dynamicTemplates["item"] = new FunctionTempalte($.proxy(function(data) {
                            return this._displayGetter(data)
                        }, this));
                    else
                        delete this._dynamicTemplates["item"]
                },
                _setCollectionWidgetItemTemplate: function() {
                    this._initDynamicTemplates();
                    this._setCollectionWidgetOption("itemTemplate", this._getTemplateByOption("itemTemplate"))
                },
                _dataExpressionOptionChanged: function(args) {
                    switch (args.name) {
                        case"items":
                            this._itemsToDataSource();
                            this._setCollectionWidgetOption("items");
                            break;
                        case"dataSource":
                            this._initDataSource();
                            break;
                        case"itemTemplate":
                            this._setCollectionWidgetItemTemplate();
                            break;
                        case"valueExpr":
                            this._compileValueGetter();
                            break;
                        case"displayExpr":
                            this._compileDisplayGetter();
                            this._setCollectionWidgetItemTemplate();
                            break
                    }
                }
            });
        return DataExpressionMixin
    });
    /*! Module core, file ui.CollectionWidget.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            domUtils = DX.require("/utils/utils.dom"),
            commonUtils = DX.require("/utils/utils.common"),
            Action = DX.require("/action"),
            Widget = DX.require("/ui/ui.widget"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer"),
            DataHelperMixin = DX.require("/ui/ui.dataHelper"),
            selectors = DX.require("/integration/jquery/jquery.selectors");
        var COLLECTION_CLASS = "dx-collection",
            ITEM_CLASS = "dx-item",
            CONTENT_CLASS_POSTFIX = "-content",
            ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder",
            ITEM_DATA_KEY = "dxItemData",
            ITEM_INDEX_KEY = "dxItemIndex",
            ITEM_TEMPLATE_ID_PREFIX = "tmpl-",
            ITEMS_SELECTOR = "[data-options*='dxItem']",
            SELECTED_ITEM_CLASS = "dx-item-selected",
            ITEM_RESPONSE_WAIT_CLASS = "dx-item-response-wait",
            EMPTY_COLLECTION = "dx-empty-collection",
            TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper",
            DISABLED_STATE_CLASS = "dx-state-disabled",
            INVISIBLE_STATE_CLASS = "dx-state-invisible",
            ITEM_PATH_REGEX = /^items[\[\.](\d+)[\.\]].(\w+)/;
        var FOCUS_UP = "up",
            FOCUS_DOWN = "down",
            FOCUS_LEFT = "left",
            FOCUS_RIGHT = "right",
            FOCUS_PAGE_UP = "pageup",
            FOCUS_PAGE_DOWN = "pagedown",
            FOCUS_LAST = "last",
            FOCUS_FIRST = "first";
        var CollectionWidget = Widget.inherit({
                _activeStateUnit: "." + ITEM_CLASS,
                _supportedKeys: function() {
                    var click = function(e) {
                            var $itemElement = this.option("focusedElement");
                            if (!$itemElement)
                                return;
                            e.target = $itemElement;
                            e.currentTarget = $itemElement;
                            this._itemClickHandler(e)
                        },
                        move = function(location, e) {
                            e.preventDefault();
                            e.stopPropagation();
                            this._moveFocus(location, e)
                        };
                    return $.extend(this.callBase(), {
                            space: click,
                            enter: click,
                            leftArrow: $.proxy(move, this, FOCUS_LEFT),
                            rightArrow: $.proxy(move, this, FOCUS_RIGHT),
                            upArrow: $.proxy(move, this, FOCUS_UP),
                            downArrow: $.proxy(move, this, FOCUS_DOWN),
                            pageUp: $.proxy(move, this, FOCUS_UP),
                            pageDown: $.proxy(move, this, FOCUS_DOWN),
                            home: $.proxy(move, this, FOCUS_FIRST),
                            end: $.proxy(move, this, FOCUS_LAST)
                        })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            selectOnFocus: false,
                            loopItemFocus: true,
                            items: [],
                            itemTemplate: "item",
                            onItemRendered: null,
                            onItemClick: null,
                            onItemHold: null,
                            itemHoldTimeout: 750,
                            onItemContextMenu: null,
                            onFocusedItemChanged: null,
                            noDataText: Globalize.localize("dxCollectionWidget-noDataText"),
                            dataSource: null,
                            _itemAttributes: {},
                            itemTemplateProperty: "template",
                            focusOnSelectedItem: true,
                            focusedElement: null
                        })
                },
                _getAnonymousTemplateName: function() {
                    return "item"
                },
                _init: function() {
                    this.callBase();
                    this._cleanRenderedItems();
                    this._refreshDataSource()
                },
                _initTemplates: function() {
                    this._initItemsFromMarkup();
                    this.callBase()
                },
                _initItemsFromMarkup: function() {
                    var $items = this.element().contents().filter(ITEMS_SELECTOR);
                    if (!$items.length || this.option("items").length)
                        return;
                    var items = $.map($items, $.proxy(function(item) {
                            var $item = $(item);
                            var result = domUtils.getElementOptions(item).dxItem;
                            var isTemplateRequired = $.trim($item.html()) && !result.template;
                            if (isTemplateRequired)
                                result.template = this._prepareItemTemplate($item);
                            else
                                $item.remove();
                            return result
                        }, this));
                    this.option("items", items)
                },
                _prepareItemTemplate: function($item) {
                    var templateId = ITEM_TEMPLATE_ID_PREFIX + new DX.data.Guid;
                    var templateOptions = "dxTemplate: { name: \"" + templateId + "\" }";
                    $item.attr("data-options", templateOptions).data("options", templateOptions);
                    return templateId
                },
                _dataSourceOptions: function() {
                    return {paginate: false}
                },
                _cleanRenderedItems: function() {
                    this._renderedItemsCount = 0
                },
                _focusTarget: function() {
                    return this.element()
                },
                _focusInHandler: function(e) {
                    this.callBase.apply(this, arguments);
                    if ($.inArray(e.target, this._focusTarget()) === -1)
                        return;
                    var $focusedElement = this.option("focusedElement");
                    if ($focusedElement && $focusedElement.length)
                        this._setFocusedItem($focusedElement);
                    else {
                        var $activeItem = this._getActiveItem();
                        this.option("focusedElement", $activeItem)
                    }
                },
                _focusOutHandler: function(e) {
                    this.callBase.apply(this, arguments);
                    var $target = this.option("focusedElement");
                    if ($target)
                        this._toggleFocusClass(false, $target)
                },
                _getActiveItem: function(last) {
                    var $focusedElement = this.option("focusedElement");
                    if ($focusedElement && $focusedElement.length)
                        return $focusedElement;
                    var index = this.option("focusOnSelectedItem") ? this.option("selectedIndex") : 0,
                        activeElements = this._getActiveElement(),
                        lastIndex = activeElements.length - 1;
                    if (index < 0)
                        index = last ? lastIndex : 0;
                    return activeElements.eq(index)
                },
                _renderFocusTarget: function() {
                    this.callBase.apply(this, arguments);
                    this._refreshActiveDescendant()
                },
                _moveFocus: function(location) {
                    var $items = this._itemElements().filter(":visible").not(".dx-state-disabled"),
                        $newTarget;
                    switch (location) {
                        case FOCUS_PAGE_UP:
                        case FOCUS_UP:
                            $newTarget = this._prevItem($items);
                            break;
                        case FOCUS_PAGE_DOWN:
                        case FOCUS_DOWN:
                            $newTarget = this._nextItem($items);
                            break;
                        case FOCUS_RIGHT:
                            $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
                            break;
                        case FOCUS_LEFT:
                            $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
                            break;
                        case FOCUS_FIRST:
                            $newTarget = $items.first();
                            break;
                        case FOCUS_LAST:
                            $newTarget = $items.last();
                            break;
                        default:
                            return false
                    }
                    if ($newTarget.length !== 0)
                        this.option("focusedElement", $newTarget)
                },
                _prevItem: function($items) {
                    var $target = this._getActiveItem(),
                        targetIndex = $items.index($target),
                        $last = $items.last(),
                        $item = $($items[targetIndex - 1]),
                        loop = this.option("loopItemFocus");
                    if ($item.length === 0 && loop)
                        $item = $last;
                    return $item
                },
                _nextItem: function($items) {
                    var $target = this._getActiveItem(true),
                        targetIndex = $items.index($target),
                        $first = $items.first(),
                        $item = $($items[targetIndex + 1]),
                        loop = this.option("loopItemFocus");
                    if ($item.length === 0 && loop)
                        $item = $first;
                    return $item
                },
                _selectFocusedItem: function($target) {
                    this.selectItem($target)
                },
                _removeFocusedItem: function($target) {
                    if ($target && $target.length) {
                        this._toggleFocusClass(false, $target);
                        $target.removeAttr("id")
                    }
                },
                _refreshActiveDescendant: function() {
                    this.setAria("activedescendant", "");
                    this.setAria("activedescendant", this.getFocusedItemId())
                },
                _setFocusedItem: function($target) {
                    if (!$target || !$target.length)
                        return;
                    $target.attr("id", this.getFocusedItemId());
                    this._toggleFocusClass(true, $target);
                    this.onFocusedItemChanged(this.getFocusedItemId());
                    this._refreshActiveDescendant();
                    if (this.option("selectOnFocus"))
                        this._selectFocusedItem($target)
                },
                _findItemElementByIndex: function(index) {
                    var result = $();
                    this.itemElements().each(function() {
                        var $item = $(this);
                        if ($item.data(ITEM_INDEX_KEY) === index) {
                            result = $item;
                            return false
                        }
                    });
                    return result
                },
                _itemOptionChanged: function(index, property, value) {
                    var $item = this._findItemElementByIndex(index),
                        itemData = this._getItemData($item);
                    switch (property) {
                        case"visible":
                            this._renderItemVisibleState($item, value);
                            break;
                        case"disabled":
                            this._renderItemDisableState($item, value);
                            break;
                        default:
                            this._renderItem(index, itemData, null, $item);
                            break
                    }
                },
                _renderItemVisibleState: function($item, value) {
                    $item.toggleClass(INVISIBLE_STATE_CLASS, !value)
                },
                _renderItemDisableState: function($item, value) {
                    $item.toggleClass(DISABLED_STATE_CLASS, !!value)
                },
                _optionChanged: function(args) {
                    if (args.name === "items") {
                        var matches = args.fullName.match(ITEM_PATH_REGEX);
                        if (matches && matches.length) {
                            this._itemOptionChanged(parseInt(matches[1], 10), matches[2], args.value);
                            return
                        }
                    }
                    switch (args.name) {
                        case"items":
                        case"_itemAttributes":
                        case"itemTemplateProperty":
                            this._cleanRenderedItems();
                            this._invalidate();
                            break;
                        case"dataSource":
                            this._refreshDataSource();
                            if (!this._dataSource)
                                this.option("items", []);
                            this._renderEmptyMessage();
                            break;
                        case"noDataText":
                            this._renderEmptyMessage();
                            break;
                        case"itemTemplate":
                            this._invalidate();
                            break;
                        case"onItemRendered":
                            this._createItemRenderAction();
                            break;
                        case"onItemClick":
                            break;
                        case"onItemHold":
                        case"itemHoldTimeout":
                            this._attachHoldEvent();
                            break;
                        case"onItemContextMenu":
                            this._attachContextMenuEvent();
                            break;
                        case"onFocusedItemChanged":
                            this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
                            break;
                        case"selectOnFocus":
                        case"loopItemFocus":
                        case"focusOnSelectedItem":
                            break;
                        case"focusedElement":
                            this._removeFocusedItem(args.previousValue);
                            this._setFocusedItem(args.value);
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _loadNextPage: function() {
                    var dataSource = this._dataSource;
                    this._expectNextPageLoading();
                    dataSource.pageIndex(1 + dataSource.pageIndex());
                    return dataSource.load()
                },
                _expectNextPageLoading: function() {
                    this._startIndexForAppendedItems = 0
                },
                _expectLastItemLoading: function() {
                    this._startIndexForAppendedItems = -1
                },
                _forgetNextPageLoading: function() {
                    this._startIndexForAppendedItems = null
                },
                _dataSourceChangedHandler: function(newItems) {
                    var items = this.option("items");
                    if (this._initialized && items && this._shouldAppendItems()) {
                        this._renderedItemsCount = items.length;
                        if (!this._isLastPage() || this._startIndexForAppendedItems !== -1)
                            this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems));
                        this._forgetNextPageLoading();
                        this._renderContent();
                        this._renderFocusTarget()
                    }
                    else
                        this.option("items", newItems)
                },
                _dataSourceLoadErrorHandler: function() {
                    this._forgetNextPageLoading();
                    this.option("items", this.option("items"))
                },
                _shouldAppendItems: function() {
                    return this._startIndexForAppendedItems != null && this._allowDinamicItemsAppend()
                },
                _allowDinamicItemsAppend: function() {
                    return false
                },
                _clean: function() {
                    this._cleanFocusState();
                    this._cleanItemContainer()
                },
                _cleanItemContainer: function() {
                    this._itemContainer().empty()
                },
                _refresh: function() {
                    this._cleanRenderedItems();
                    this.callBase.apply(this, arguments)
                },
                _itemContainer: function() {
                    return this.element()
                },
                _itemClass: function() {
                    return ITEM_CLASS
                },
                _itemContentClass: function() {
                    return this._itemClass() + CONTENT_CLASS_POSTFIX
                },
                _selectedItemClass: function() {
                    return SELECTED_ITEM_CLASS
                },
                _itemResponseWaitClass: function() {
                    return ITEM_RESPONSE_WAIT_CLASS
                },
                _itemSelector: function() {
                    return "." + this._itemClass()
                },
                _itemDataKey: function() {
                    return ITEM_DATA_KEY
                },
                _itemIndexKey: function() {
                    return ITEM_INDEX_KEY
                },
                _itemElements: function() {
                    return this._itemContainer().find(this._itemSelector())
                },
                _render: function() {
                    this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
                    this.callBase();
                    this.element().addClass(COLLECTION_CLASS);
                    this._attachClickEvent();
                    this._attachHoldEvent();
                    this._attachContextMenuEvent()
                },
                _attachClickEvent: function() {
                    var itemSelector = this._itemSelector(),
                        clickEventNamespace = eventUtils.addNamespace("dxclick", this.NAME),
                        pointerDownEventNamespace = eventUtils.addNamespace(pointerEvents.down, this.NAME),
                        that = this;
                    var pointerDownAction = new Action(function(args) {
                            var event = args.event;
                            that._itemPointerDownHandler(event)
                        });
                    this._itemContainer().off(clickEventNamespace, itemSelector).off(pointerDownEventNamespace, itemSelector).on(clickEventNamespace, itemSelector, $.proxy(function(e) {
                        this._itemClickHandler(e)
                    }, this)).on(pointerDownEventNamespace, itemSelector, function(e) {
                        pointerDownAction.execute({
                            element: $(e.target),
                            event: e
                        })
                    })
                },
                _itemClickHandler: function(e, args, config) {
                    this._itemJQueryEventHandler(e, "onItemClick", args, config)
                },
                _itemPointerDownHandler: function(e) {
                    if (!this.option("focusStateEnabled"))
                        return;
                    var $target = $(e.target),
                        $closestItem = $target.closest(this._itemElements()),
                        $closestFocusable = $target.closest(selectors.focusable);
                    if ($closestItem.length && $.inArray($closestFocusable.get(0), this._focusTarget()) !== -1)
                        this.option("focusedElement", $closestItem)
                },
                _attachHoldEvent: function() {
                    var $itemContainer = this._itemContainer(),
                        itemSelector = this._itemSelector(),
                        eventName = eventUtils.addNamespace("dxhold", this.NAME);
                    $itemContainer.off(eventName, itemSelector);
                    if (this._shouldAttachHoldEvent())
                        $itemContainer.on(eventName, itemSelector, {timeout: this._getHoldTimeout()}, $.proxy(this._itemHoldHandler, this))
                },
                _getHoldTimeout: function() {
                    return this.option("itemHoldTimeout")
                },
                _shouldAttachHoldEvent: function() {
                    return this.option("onItemHold")
                },
                _itemHoldHandler: function(e) {
                    this._itemJQueryEventHandler(e, "onItemHold")
                },
                _attachContextMenuEvent: function() {
                    var $itemContainer = this._itemContainer(),
                        itemSelector = this._itemSelector(),
                        eventName = eventUtils.addNamespace("dxcontextmenu", this.NAME);
                    $itemContainer.off(eventName, itemSelector);
                    if (this._shouldAttachContextMenuEvent())
                        $itemContainer.on(eventName, itemSelector, $.proxy(this._itemContextMenuHandler, this))
                },
                _shouldAttachContextMenuEvent: function() {
                    return this.option("onItemContextMenu")
                },
                _itemContextMenuHandler: function(e) {
                    this._itemJQueryEventHandler(e, "onItemContextMenu")
                },
                _renderContentImpl: function() {
                    var items = this.option("items") || [];
                    if (this._renderedItemsCount)
                        this._renderItems(items.slice(this._renderedItemsCount));
                    else
                        this._renderItems(items)
                },
                _renderItems: function(items) {
                    if (items.length)
                        $.each(items, $.proxy(this._renderItem, this));
                    this._renderEmptyMessage()
                },
                _renderItem: function(index, itemData, $container, $itemToReplace) {
                    $container = $container || this._itemContainer();
                    var $itemFrame = this._renderItemFrame(index, itemData, $container, $itemToReplace);
                    this._setElementData($itemFrame, itemData, index);
                    $itemFrame.attr(this.option("_itemAttributes"));
                    this._attachItemClickEvent(itemData, $itemFrame);
                    var $itemContent = $itemFrame.find("." + ITEM_CONTENT_PLACEHOLDER_CLASS);
                    $itemContent.removeClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
                    var renderContentPromise = this._renderItemContent(index, itemData, $itemContent);
                    var that = this;
                    $.when(renderContentPromise).done(function($itemContent) {
                        that._postprocessRenderItem({
                            itemElement: $itemFrame,
                            itemContent: $itemContent,
                            itemData: itemData,
                            itemIndex: index
                        });
                        that._executeItemRenderAction(index, itemData, $itemFrame)
                    });
                    return $itemFrame
                },
                _attachItemClickEvent: function(itemData, $itemElement) {
                    if (!itemData || !itemData.onClick)
                        return;
                    $itemElement.on("dxclick", $.proxy(function(e) {
                        this._itemEventHandlerByHandler($itemElement, itemData.onClick, {jQueryEvent: e})
                    }, this))
                },
                _renderItemContent: function(index, itemData, $container) {
                    var $itemNode = itemData && itemData.node;
                    var itemTemplateName = this._getItemTemplateName(itemData);
                    var itemTemplate = this._getTemplate(itemTemplateName, itemData, index, $container);
                    var renderArgs = {
                            index: index,
                            item: itemData,
                            container: $container
                        };
                    if ($itemNode) {
                        $container.replaceWith($itemNode);
                        $container = $itemNode;
                        this._addItemContentClasses($container, itemData)
                    }
                    else {
                        this._addItemContentClasses($container, itemData);
                        var $result = this._createItemByTemplate(itemTemplate, renderArgs);
                        if ($result.hasClass(TEMPLATE_WRAPPER_CLASS)) {
                            $container.replaceWith($result);
                            $container = $result;
                            this._addItemContentClasses($container, itemData)
                        }
                    }
                    return $container
                },
                _addItemContentClasses: function($container) {
                    $container.addClass([ITEM_CLASS + CONTENT_CLASS_POSTFIX, this._itemContentClass()].join(" "))
                },
                _renderItemFrame: function(index, itemData, $container, $itemToReplace) {
                    var itemFrameTemplate = this.option("templateProvider").getTemplates(this)["itemFrame"],
                        $itemFrame = itemFrameTemplate.render(commonUtils.isDefined(itemData) ? itemData : {}, $container, index);
                    if ($itemToReplace && $itemToReplace.length)
                        $itemToReplace.replaceWith($itemFrame);
                    else
                        $itemFrame.appendTo($container);
                    return $itemFrame
                },
                _postprocessRenderItem: $.noop,
                _executeItemRenderAction: function(index, itemData, itemElement) {
                    this._getItemRenderAction()({
                        itemElement: itemElement,
                        itemIndex: index,
                        itemData: itemData
                    })
                },
                _setElementData: function(element, data, index) {
                    element.addClass([ITEM_CLASS, this._itemClass()].join(" ")).data(this._itemDataKey(), data).data(this._itemIndexKey(), index)
                },
                _createItemRenderAction: function() {
                    return this._itemRenderAction = this._createActionByOption("onItemRendered", {
                            element: this.element(),
                            excludeValidators: ["designMode", "disabled", "readOnly"],
                            category: "rendering"
                        })
                },
                _getItemRenderAction: function() {
                    return this._itemRenderAction || this._createItemRenderAction()
                },
                _getItemTemplateName: function(itemData) {
                    var templateProperty = this.option("itemTemplateProperty");
                    return itemData && itemData[templateProperty] || this.option("itemTemplate")
                },
                _createItemByTemplate: function(itemTemplate, renderArgs) {
                    return itemTemplate.render(renderArgs.item, renderArgs.container, renderArgs.index, "ignoreTarget")
                },
                _renderEmptyMessage: function() {
                    var noDataText = this.option("noDataText"),
                        items = this.option("items"),
                        hideNoData = !noDataText || items && items.length || this._isDataSourceLoading();
                    if (hideNoData && this._$nodata) {
                        this._$nodata.remove();
                        this._$nodata = null;
                        this.setAria("label", undefined)
                    }
                    if (!hideNoData) {
                        this._$nodata = this._$nodata || $("<div>").addClass("dx-empty-message");
                        this._$nodata.appendTo(this._itemContainer()).html(noDataText);
                        this.setAria("label", noDataText)
                    }
                    this.element().toggleClass(EMPTY_COLLECTION, !hideNoData)
                },
                _itemJQueryEventHandler: function(jQueryEvent, handlerOptionName, actionArgs, actionConfig) {
                    this._itemEventHandler(jQueryEvent.target, handlerOptionName, $.extend(actionArgs, {jQueryEvent: jQueryEvent}), actionConfig)
                },
                _itemEventHandler: function(initiator, handlerOptionName, actionArgs, actionConfig) {
                    var action = this._createActionByOption(handlerOptionName, $.extend({validatingTargetName: "itemElement"}, actionConfig));
                    return this._itemEventHandlerImpl(initiator, action, actionArgs)
                },
                _itemEventHandlerByHandler: function(initiator, handler, actionArgs, actionConfig) {
                    var action = this._createAction(handler, $.extend({validatingTargetName: "itemElement"}, actionConfig));
                    return this._itemEventHandlerImpl(initiator, action, actionArgs)
                },
                _itemEventHandlerImpl: function(initiator, action, actionArgs) {
                    var $itemElement = this._closestItemElement($(initiator));
                    return action($.extend(this._extendActionArgs($itemElement), actionArgs))
                },
                _extendActionArgs: function($itemElement) {
                    return {
                            itemElement: $itemElement,
                            itemIndex: this._itemElements().index($itemElement),
                            itemData: this._getItemData($itemElement)
                        }
                },
                _closestItemElement: function($element) {
                    return $($element).closest(this._itemSelector())
                },
                _getItemData: function(itemElement) {
                    return $(itemElement).data(this._itemDataKey())
                },
                getFocusedItemId: function() {
                    if (!this._focusedItemId)
                        this._focusedItemId = new DevExpress.data.Guid;
                    return this._focusedItemId
                },
                itemElements: function() {
                    return this._itemElements()
                },
                itemsContainer: function() {
                    return this._itemContainer()
                }
            }).include(DataHelperMixin);
        CollectionWidget.publicName("CollectionWidget");
        ui.CollectionWidget = CollectionWidget
    })(jQuery, DevExpress);
    /*! Module core, file ui.CollectionWidget.edit.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            errors = DX.require("/ui/ui.errors"),
            arrayUtils = DX.require("/utils/utils.array"),
            commonUtils = DX.require("/utils/utils.common");
        var ITEM_DELETING_DATA_KEY = "dxItemDeleting";
        var CollectionWidget = ui.CollectionWidget.inherit({
                _setOptionsByReference: function() {
                    this.callBase();
                    $.extend(this._optionsByReference, {selectedItem: true})
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            selectionMode: 'none',
                            selectionRequired: false,
                            selectionByClick: true,
                            selectedItems: [],
                            selectedIndex: -1,
                            selectedItem: null,
                            onSelectionChanged: null,
                            onItemReordered: null,
                            onItemDeleting: null,
                            onItemDeleted: null
                        })
                },
                _init: function() {
                    this._initEditStrategy();
                    this.callBase();
                    this._selectedItemIndices = []
                },
                _initEditStrategy: function() {
                    var strategy = ui.CollectionWidget.PlainEditStrategy;
                    this._editStrategy = new strategy(this)
                },
                _forgetNextPageLoading: function() {
                    this.callBase();
                    this._selectedItemIndices = this._editStrategy.selectedItemIndices()
                },
                _render: function() {
                    this._syncSelectionOptions();
                    this._normalizeSelectedItems();
                    this._initSelectedItems();
                    this.callBase();
                    this._renderSelection(this._selectedItemIndices, [])
                },
                _syncSelectionOptions: function(byOption) {
                    byOption = byOption || this._chooseSelectOption();
                    var selectedItem,
                        selectedItems;
                    switch (byOption) {
                        case"selectedIndex":
                            selectedItem = this._editStrategy.getItemDataByIndex(this.option("selectedIndex"));
                            if (commonUtils.isDefined(selectedItem)) {
                                this._setOptionSilent("selectedItems", [selectedItem]);
                                this._setOptionSilent("selectedItem", selectedItem)
                            }
                            else {
                                this._setOptionSilent("selectedItems", []);
                                this._setOptionSilent("selectedItem", null)
                            }
                            break;
                        case"selectedItems":
                            selectedItems = this.option("selectedItems") || [];
                            this._setOptionSilent("selectedItem", selectedItems[0]);
                            this._setOptionSilent("selectedIndex", this._editStrategy.getIndexByItemData(selectedItems[0]));
                            break;
                        case"selectedItem":
                            selectedItem = this.option("selectedItem");
                            if (commonUtils.isDefined(selectedItem)) {
                                this._setOptionSilent("selectedItems", [selectedItem]);
                                this._setOptionSilent("selectedIndex", this._editStrategy.getIndexByItemData(selectedItem))
                            }
                            else {
                                this._setOptionSilent("selectedItems", []);
                                this._setOptionSilent("selectedIndex", -1)
                            }
                            break
                    }
                },
                _chooseSelectOption: function() {
                    var optionName = "selectedIndex";
                    if (this.option("selectedItems").length)
                        optionName = "selectedItems";
                    else if (commonUtils.isDefined(this.option("selectedItem")))
                        optionName = "selectedItem";
                    return optionName
                },
                _normalizeSelectedItems: function() {
                    if (this.option("selectionMode") === "none") {
                        this._setOptionSilent("selectedItems", []);
                        this._syncSelectionOptions("selectedItems")
                    }
                    else if (this.option("selectionMode") === "single") {
                        var newSelection = this._editStrategy.selectedItemIndices(this.option("selectedItems"));
                        if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && this.option("items") && this.option("items").length) {
                            var normalizedSelection = [newSelection[0] || this._selectedItemIndices[0] || 0];
                            this._setOptionSilent("selectedItems", this._editStrategy.fetchSelectedItems(normalizedSelection));
                            this._syncSelectionOptions("selectedItems")
                        }
                    }
                },
                _initSelectedItems: function() {
                    this._selectedItemIndices = this._editStrategy.selectedItemIndices(this.option("selectedItems"))
                },
                _renderSelection: $.noop,
                _itemClickHandler: function(e) {
                    this._createAction($.proxy(function(e) {
                        this._itemSelectHandler(e.jQueryEvent)
                    }, this), {validatingTargetName: "itemElement"})({
                        itemElement: $(e.currentTarget),
                        jQueryEvent: e
                    });
                    this.callBase.apply(this, arguments)
                },
                _itemSelectHandler: function(e) {
                    if (!this.option("selectionByClick"))
                        return;
                    var $itemElement = e.currentTarget;
                    if (this.isItemSelected($itemElement))
                        this.unselectItem(e.currentTarget);
                    else
                        this.selectItem(e.currentTarget)
                },
                _selectedItemElement: function(index) {
                    return this._itemElements().eq(index)
                },
                _postprocessRenderItem: function(args) {
                    var $itemElement = $(args.itemElement);
                    if (this._isItemSelected(this._editStrategy.getNormalizedIndex($itemElement))) {
                        $itemElement.addClass(this._selectedItemClass());
                        this._setAriaSelected($itemElement, "true")
                    }
                    else
                        this._setAriaSelected($itemElement, "false")
                },
                _updateSelectedItems: function() {
                    var that = this,
                        oldSelection = this._selectedItemIndices.slice(),
                        newSelection = this._editStrategy.selectedItemIndices(),
                        addedSelection = arrayUtils.removeDublicates(newSelection, oldSelection),
                        removedSelection = arrayUtils.removeDublicates(oldSelection, newSelection);
                    $.each(removedSelection, function(_, normalizedIndex) {
                        that._removeSelection(normalizedIndex)
                    });
                    $.each(addedSelection, function(_, normalizedIndex) {
                        that._addSelection(normalizedIndex)
                    });
                    if (removedSelection.length || addedSelection.length) {
                        var selectionChangePromise = this._selectionChangePromise;
                        this._updateSelection(addedSelection, removedSelection);
                        $.when(selectionChangePromise).done(function() {
                            that._fireSelectionChangeEvent(addedSelection, removedSelection)
                        })
                    }
                },
                _fireSelectionChangeEvent: function(addedSelection, removedSelection) {
                    this._createActionByOption("onSelectionChanged", {excludeValidators: ["disabled", "readOnly"]})(this._editStrategy.fetchSelectionDifference(addedSelection, removedSelection))
                },
                _updateSelection: function() {
                    this._renderSelection.apply(this, arguments)
                },
                _setAriaSelected: function($target, value) {
                    this.setAria("selected", value, $target)
                },
                _removeSelection: function(normalizedIndex) {
                    var $itemElement = this._editStrategy.getItemElement(normalizedIndex),
                        itemSelectionIndex = $.inArray(normalizedIndex, this._selectedItemIndices);
                    if (itemSelectionIndex > -1) {
                        $itemElement.removeClass(this._selectedItemClass());
                        this._setAriaSelected($itemElement, "false");
                        this._selectedItemIndices.splice(itemSelectionIndex, 1);
                        $itemElement.triggerHandler("stateChanged")
                    }
                },
                _addSelection: function(normalizedIndex) {
                    var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
                    if (normalizedIndex > -1 && !this._isItemSelected(normalizedIndex)) {
                        $itemElement.addClass(this._selectedItemClass());
                        this._setAriaSelected($itemElement, "true");
                        this._selectedItemIndices.push(normalizedIndex);
                        $itemElement.triggerHandler("stateChanged")
                    }
                },
                _isItemSelected: function(index) {
                    return $.inArray(index, this._selectedItemIndices) > -1
                },
                _optionChanged: function(args) {
                    if (this._cancelOptionChange)
                        return;
                    switch (args.name) {
                        case"selectionMode":
                            this._invalidate();
                            break;
                        case"selectedIndex":
                        case"selectedItem":
                        case"selectedItems":
                            this._syncSelectionOptions(args.name);
                            this._normalizeSelectedItems();
                            this._updateSelectedItems();
                            break;
                        case"selectionRequired":
                            this._normalizeSelectedItems();
                            this._updateSelectedItems();
                            break;
                        case"selectionByClick":
                        case"onSelectionChanged":
                        case"onItemDeleting":
                        case"onItemDeleted":
                        case"onItemReordered":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _clearSelectedItems: function() {
                    this._selectedItemIndices = [];
                    this._setOptionSilent("selectedItems", []);
                    this._syncSelectionOptions("selectedItems")
                },
                _setOptionSilent: function(name, value) {
                    this._cancelOptionChange = true;
                    this.option(name, value);
                    this._cancelOptionChange = false
                },
                _waitDeletingPrepare: function($itemElement) {
                    if ($itemElement.data(ITEM_DELETING_DATA_KEY))
                        return $.Deferred().resolve().promise();
                    $itemElement.data(ITEM_DELETING_DATA_KEY, true);
                    var deferred = $.Deferred(),
                        deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", {}, {excludeValidators: ["disabled", "readOnly"]});
                    $.when(deletePromise).always($.proxy(function(value) {
                        var deletePromiseExists = !deletePromise,
                            deletePromiseResolved = !deletePromiseExists && deletePromise.state() === "resolved",
                            argumentsSpecified = !!arguments.length,
                            shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value;
                        $itemElement.data(ITEM_DELETING_DATA_KEY, false);
                        shouldDelete ? deferred.resolve() : deferred.reject()
                    }, this));
                    return deferred.promise()
                },
                _deleteItemFromDS: function($item) {
                    if (!this._dataSource)
                        return $.Deferred().resolve().promise();
                    var deferred = $.Deferred(),
                        disabledState = this.option("disabled"),
                        dataStore = this._dataSource.store();
                    this.option("disabled", true);
                    if (!dataStore.remove)
                        throw errors.Error("E1011");
                    dataStore.remove(dataStore.keyOf(this._getItemData($item))).done(function(key) {
                        if (key !== undefined)
                            deferred.resolve();
                        else
                            deferred.reject()
                    }).fail(function() {
                        deferred.reject()
                    });
                    deferred.always($.proxy(function() {
                        this.option("disabled", disabledState)
                    }, this));
                    return deferred
                },
                _tryRefreshLastPage: function() {
                    var deferred = $.Deferred();
                    if (this._isLastPage() || this.option("grouped"))
                        deferred.resolve();
                    else
                        this._refreshLastPage().done(function() {
                            deferred.resolve()
                        });
                    return deferred.promise()
                },
                _refreshLastPage: function() {
                    this._expectLastItemLoading();
                    return this._dataSource.load()
                },
                _updateSelectionAfterDelete: function(fromIndex) {
                    var itemIndex = $.inArray(fromIndex, this._selectedItemIndices);
                    if (itemIndex > -1)
                        this._selectedItemIndices.splice(itemIndex, 1);
                    this._editStrategy.updateSelectionAfterDelete(fromIndex);
                    this.option("selectedItems", this._editStrategy.fetchSelectedItems())
                },
                _simulateOptionChange: function(optionName) {
                    var optionValue = this.option(optionName);
                    if (optionValue instanceof DX.data.DataSource)
                        return;
                    this.fireEvent("optionChanged", [{
                            name: optionName,
                            fullName: optionName,
                            value: optionValue
                        }])
                },
                isItemSelected: function(itemElement) {
                    return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement))
                },
                selectItem: function(itemElement) {
                    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
                    if (itemIndex === -1)
                        return;
                    var itemSelectionIndex = $.inArray(itemIndex, this._selectedItemIndices);
                    if (itemSelectionIndex !== -1)
                        return;
                    if (this.option("selectionMode") === "single")
                        this.option("selectedItems", this._editStrategy.fetchSelectedItems([itemIndex]));
                    else {
                        var newSelectedIndices = this._selectedItemIndices.slice();
                        newSelectedIndices.push(itemIndex);
                        this.option("selectedItems", this._editStrategy.fetchSelectedItems(newSelectedIndices))
                    }
                },
                unselectItem: function(itemElement) {
                    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
                    if (itemIndex === -1)
                        return;
                    var itemSelectionIndex = $.inArray(itemIndex, this._selectedItemIndices);
                    if (itemSelectionIndex === -1)
                        return;
                    var newSelectedIndices = this._selectedItemIndices.slice();
                    newSelectedIndices.splice(itemSelectionIndex, 1);
                    if (this.option("selectionRequired") && newSelectedIndices.length === 0)
                        return;
                    this.option("selectedItems", this._editStrategy.fetchSelectedItems(newSelectedIndices))
                },
                deleteItem: function(itemElement) {
                    var that = this,
                        deferred = $.Deferred(),
                        $item = this._editStrategy.getItemElement(itemElement),
                        index = this._editStrategy.getNormalizedIndex(itemElement),
                        changingOption = this._dataSource ? "dataSource" : "items",
                        itemResponseWaitClass = this._itemResponseWaitClass();
                    if (index > -1)
                        this._waitDeletingPrepare($item).done(function() {
                            $item.addClass(itemResponseWaitClass);
                            var deletedActionArgs = that._extendActionArgs($item);
                            that._deleteItemFromDS($item).done(function() {
                                that._editStrategy.deleteItemAtIndex(index);
                                that._simulateOptionChange(changingOption);
                                that._updateSelectionAfterDelete(index);
                                that._itemEventHandler($item, "onItemDeleted", deletedActionArgs, {
                                    beforeExecute: function() {
                                        $item.detach()
                                    },
                                    excludeValidators: ["disabled", "readOnly"]
                                });
                                that._renderEmptyMessage();
                                that._tryRefreshLastPage().done(function() {
                                    deferred.resolveWith(that)
                                })
                            }).fail(function() {
                                $item.removeClass(itemResponseWaitClass);
                                deferred.rejectWith(that)
                            })
                        }).fail(function() {
                            deferred.rejectWith(that)
                        });
                    else
                        deferred.rejectWith(that);
                    return deferred.promise()
                },
                reorderItem: function(itemElement, toItemElement) {
                    var deferred = $.Deferred(),
                        that = this,
                        strategy = this._editStrategy,
                        $movingItem = strategy.getItemElement(itemElement),
                        $destinationItem = strategy.getItemElement(toItemElement),
                        movingIndex = strategy.getNormalizedIndex(itemElement),
                        destinationIndex = strategy.getNormalizedIndex(toItemElement),
                        changingOption;
                    var canMoveItems = movingIndex > -1 && destinationIndex > -1 && movingIndex !== destinationIndex;
                    if (canMoveItems)
                        if (this._dataSource) {
                            changingOption = "dataSource";
                            deferred.resolveWith(this)
                        }
                        else {
                            changingOption = "items";
                            deferred.resolveWith(this)
                        }
                    else
                        deferred.rejectWith(this);
                    return deferred.promise().done(function() {
                            $destinationItem[strategy.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
                            var newSelectedItems = strategy.getSelectedItemsAfterReorderItem(movingIndex, destinationIndex);
                            strategy.moveItemAtIndexToIndex(movingIndex, destinationIndex);
                            that._selectedItemIndices = strategy.selectedItemIndices(newSelectedItems);
                            that.option("selectedItems", strategy.fetchSelectedItems());
                            that._simulateOptionChange(changingOption);
                            that._itemEventHandler($movingItem, "onItemReordered", {
                                fromIndex: strategy.getIndex(movingIndex),
                                toIndex: strategy.getIndex(destinationIndex)
                            }, {excludeValidators: ["disabled", "readOnly"]})
                        })
                }
            });
        ui.CollectionWidget = CollectionWidget
    })(jQuery, DevExpress);
    /*! Module core, file ui.collectionWidget.edit.strategy.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            Class = DevExpress.require("/class"),
            abstract = Class.abstract;
        ui.CollectionWidget.EditStrategy = Class.inherit({
            ctor: function(collectionWidget) {
                this._collectionWidget = collectionWidget
            },
            getIndexByItemData: abstract,
            getItemDataByIndex: abstract,
            getNormalizedIndex: function(value) {
                if (this._isNormalisedItemIndex(value))
                    return value;
                if (this._isItemIndex(value))
                    return this._normalizeItemIndex(value);
                if (this._isDOMNode(value))
                    return this._getNormalizedItemIndex(value);
                return this._normalizeItemIndex(this.getIndexByItemData(value))
            },
            getIndex: function(value) {
                if (this._isNormalisedItemIndex(value))
                    return this._denormalizeItemIndex(value);
                if (this._isItemIndex(value))
                    return value;
                if (this._isDOMNode(value))
                    return this._denormalizeItemIndex(this._getNormalizedItemIndex(value));
                return this.getIndexByItemData(value)
            },
            getItemElement: function(value) {
                if (this._isNormalisedItemIndex(value))
                    return this._getItemByNormalizedIndex(value);
                if (this._isItemIndex(value))
                    return this._getItemByNormalizedIndex(this._normalizeItemIndex(value));
                if (this._isDOMNode(value))
                    return $(value);
                return this._getItemByNormalizedIndex(this.getIndexByItemData(value))
            },
            deleteItemAtIndex: abstract,
            updateSelectionAfterDelete: abstract,
            fetchSelectedItems: abstract,
            fetchSelectionDifference: function(addedSelection, removedSelection) {
                return {
                        addedItems: this.fetchSelectedItems(addedSelection),
                        removedItems: this.fetchSelectedItems(removedSelection)
                    }
            },
            selectedItemIndices: abstract,
            itemPlacementFunc: function(movingIndex, destinationIndex) {
                return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before"
            },
            moveItemAtIndexToIndex: abstract,
            getSelectedItemsAfterReorderItem: function() {
                return this._collectionWidget.option("selectedItems")
            },
            _isNormalisedItemIndex: function(index) {
                return $.isNumeric(index)
            },
            _isDOMNode: function(value) {
                var $value = $(value);
                return $value.length && $value.get(0).nodeType
            },
            _isItemIndex: abstract,
            _getNormalizedItemIndex: abstract,
            _normalizeItemIndex: abstract,
            _denormalizeItemIndex: abstract,
            _getItemByNormalizedIndex: abstract,
            _itemsFromSameParent: abstract
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.collectionWidget.edit.strategy.plain.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            errors = DX.require("/ui/ui.errors"),
            arrayUtils = DX.require("/utils/utils.array");
        ui.CollectionWidget.PlainEditStrategy = ui.CollectionWidget.EditStrategy.inherit({
            _getPlainItems: function() {
                return this._collectionWidget.option("items") || []
            },
            getIndexByItemData: function(itemData) {
                return $.inArray(itemData, this._getPlainItems())
            },
            getItemDataByIndex: function(index) {
                return this._getPlainItems()[index]
            },
            deleteItemAtIndex: function(index) {
                this._getPlainItems().splice(index, 1)
            },
            updateSelectionAfterDelete: function(fromIndex) {
                var selectedItemIndices = this._collectionWidget._selectedItemIndices;
                $.each(selectedItemIndices, function(i, index) {
                    if (index > fromIndex)
                        selectedItemIndices[i] -= 1
                })
            },
            fetchSelectedItems: function(indices) {
                indices = indices || this._collectionWidget._selectedItemIndices;
                indices.sort(function(a, b) {
                    return a - b
                });
                var items = this._getPlainItems(),
                    selectedItems = [];
                $.each(indices, function(_, index) {
                    selectedItems.push(items[index])
                });
                if (this._collectionWidget._dataSource) {
                    var allSelectedItems = this._collectionWidget.option("selectedItems"),
                        unavaliableItems = $.grep(allSelectedItems, function(item) {
                            return $.inArray(item, items) === -1
                        });
                    selectedItems = selectedItems.concat(unavaliableItems)
                }
                return selectedItems
            },
            fetchSelectionDifference: function(addedSelection, removedSelection) {
                var difference = this.callBase(addedSelection, removedSelection);
                if (this._collectionWidget._dataSource) {
                    var addedItems = difference.addedItems,
                        removedItems = difference.removedItems,
                        duplicatedItems = arrayUtils.intersection(addedItems, removedItems);
                    $.each(duplicatedItems, function(_, item) {
                        var addedItemIndex = $.inArray(item, addedItems),
                            removedItemIndex = $.inArray(item, removedItems);
                        addedItems.splice(addedItemIndex, 1);
                        removedItems.splice(removedItemIndex, 1)
                    })
                }
                return difference
            },
            selectedItemIndices: function() {
                var selectedIndices = [],
                    items = this._getPlainItems(),
                    selected = this._collectionWidget.option("selectedItems"),
                    dataSource = this._collectionWidget._dataSource;
                $.each(selected, function(_, selectedItem) {
                    var index = $.inArray(selectedItem, items);
                    if (index !== -1)
                        selectedIndices.push(index);
                    else if (!dataSource)
                        errors.log("W1002", selectedItem)
                });
                return selectedIndices
            },
            moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
                var items = this._getPlainItems(),
                    movedItemData = items[movingIndex];
                items.splice(movingIndex, 1);
                items.splice(destinationIndex, 0, movedItemData)
            },
            _isItemIndex: function(index) {
                return $.isNumeric(index)
            },
            _getNormalizedItemIndex: function(itemElement) {
                return this._collectionWidget._itemElements().index(itemElement)
            },
            _normalizeItemIndex: function(index) {
                return index
            },
            _denormalizeItemIndex: function(index) {
                return index
            },
            _getItemByNormalizedIndex: function(index) {
                return index > -1 ? this._collectionWidget._itemElements().eq(index) : null
            },
            _itemsFromSameParent: function() {
                return true
            }
        })
    })(jQuery, DevExpress);
    /*! Module core, file ui.tooltip.js */
    DevExpress.define("/ui/ui.tooltip", ["jquery", "/utils/utils.viewPort"], function($, viewPortUtils) {
        var $tooltip = null;
        var createTooltip = function(options) {
                options = $.extend({position: "top"}, options);
                var content = options.content;
                delete options.content;
                return $("<div />").html(content).appendTo(viewPortUtils.value()).dxTooltip(options)
            };
        var removeTooltip = function() {
                if (!$tooltip)
                    return;
                $tooltip.remove();
                $tooltip = null
            };
        var tooltip = {
                show: function(options) {
                    removeTooltip();
                    $tooltip = createTooltip(options);
                    return $tooltip.dxTooltip("show")
                },
                hide: function() {
                    if (!$tooltip)
                        return $.when();
                    return $tooltip.dxTooltip("hide").done(removeTooltip).promise()
                }
            };
        return tooltip
    });
    DevExpress.MOD_CORE = true
}
if (!window.DevExpress || !DevExpress.MOD_WIDGETS_BASE) {
    if (!window.DevExpress || !DevExpress.MOD_CORE)
        throw Error('Required module is not referenced: core');
    /*! Module widgets-base, file ui.scrollable.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            support = DX.require("/utils/utils.support"),
            browser = DX.require("/utils/utils.browser"),
            commonUtils = DX.require("/utils/utils.common"),
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator"),
            DOMComponent = DX.require("/domComponent"),
            selectors = DX.require("/integration/jquery/jquery.selectors"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var SCROLLABLE = "dxScrollable",
            SCROLLABLE_STRATEGY = "dxScrollableStrategy",
            SCROLLABLE_CLASS = "dx-scrollable",
            SCROLLABLE_DISABLED_CLASS = "dx-scrollable-disabled",
            SCROLLABLE_CONTAINER_CLASS = "dx-scrollable-container",
            SCROLLABLE_CONTENT_CLASS = "dx-scrollable-content",
            VERTICAL = "vertical",
            HORIZONTAL = "horizontal",
            BOTH = "both";
        var deviceDependentOptions = function() {
                return [{
                            device: function(device) {
                                return !support.nativeScrolling
                            },
                            options: {useNative: false}
                        }, {
                            device: function(device) {
                                return !support.nativeScrolling && !devices.isSimulator() && devices.real().platform === "generic" && device.platform === "generic"
                            },
                            options: {
                                bounceEnabled: false,
                                scrollByThumb: true,
                                scrollByContent: support.touch,
                                showScrollbar: "onHover"
                            }
                        }]
            };
        registerComponent(SCROLLABLE, ui, DOMComponent.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        disabled: false,
                        onScroll: null,
                        direction: VERTICAL,
                        showScrollbar: "onScroll",
                        useNative: true,
                        bounceEnabled: true,
                        scrollByContent: true,
                        scrollByThumb: false,
                        onUpdated: null,
                        onStart: null,
                        onEnd: null,
                        onBounce: null,
                        onStop: null,
                        useSimulatedScrollbar: false,
                        useKeyboard: true,
                        inertiaEnabled: true,
                        pushBackValue: 0
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat(deviceDependentOptions(), [{
                            device: function(device) {
                                return support.nativeScrolling && devices.real().platform === "android"
                            },
                            options: {useSimulatedScrollbar: true}
                        }, {
                            device: function(device) {
                                return devices.real().platform === "ios"
                            },
                            options: {pushBackValue: 1}
                        }])
            },
            _initOptions: function(options) {
                this.callBase(options);
                if (!("useSimulatedScrollbar" in options))
                    this._setUseSimulatedScrollbar()
            },
            _setUseSimulatedScrollbar: function() {
                if (!this._initialOptions.useSimulatedScrollbar)
                    this.option("useSimulatedScrollbar", !this.option("useNative"))
            },
            _init: function() {
                this.callBase();
                this._initMarkup();
                this._attachNativeScrollbarsCustomizationCss();
                this._locked = false
            },
            _visibilityChanged: function(visible) {
                if (this.element().is(":hidden"))
                    return;
                if (visible) {
                    this.update();
                    this._toggleRTLDirection(this.option("rtlEnabled"));
                    this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);
                    delete this._savedScrollOffset
                }
                else
                    this._savedScrollOffset = this.scrollOffset()
            },
            _initMarkup: function() {
                var $element = this.element().addClass(SCROLLABLE_CLASS),
                    $container = this._$container = $("<div>").addClass(SCROLLABLE_CONTAINER_CLASS),
                    $content = this._$content = $("<div>").addClass(SCROLLABLE_CONTENT_CLASS);
                $element.on(eventUtils.addNamespace("beforeactivate", SCROLLABLE), function(e) {
                    if (!$(e.target).is(selectors.focusable))
                        e.preventDefault()
                });
                $content.append($element.contents()).appendTo($container);
                $container.appendTo($element)
            },
            _dimensionChanged: function() {
                this.update()
            },
            _attachNativeScrollbarsCustomizationCss: function() {
                if (!(navigator.platform.indexOf('Mac') > -1 && browser['webkit']))
                    this.element().addClass("dx-scrollable-customizable-scrollbars")
            },
            _render: function() {
                this._renderPushBackOffset();
                this._renderDirection();
                this._renderStrategy();
                this._attachEventHandlers();
                this._renderDisabledState();
                this._createActions();
                this.update();
                this.callBase()
            },
            _renderPushBackOffset: function() {
                var pushBackValue = this.option("pushBackValue");
                if (!pushBackValue && !this._lastPushBackValue)
                    return;
                this._$content.css({
                    paddingTop: pushBackValue,
                    paddingBottom: pushBackValue
                });
                this._lastPushBackValue = pushBackValue
            },
            _toggleRTLDirection: function(rtl) {
                this.callBase(rtl);
                if (rtl && this.option("direction") !== VERTICAL)
                    this.scrollTo({left: this.scrollWidth() - this.clientWidth()})
            },
            _attachEventHandlers: function() {
                var strategy = this._strategy;
                var initEventData = {
                        getDirection: $.proxy(strategy.getDirection, strategy),
                        validate: $.proxy(this._validate, this),
                        isNative: this.option("useNative")
                    };
                this._$container.off("." + SCROLLABLE).on(eventUtils.addNamespace("scroll", SCROLLABLE), $.proxy(strategy.handleScroll, strategy)).on(eventUtils.addNamespace("dxscrollinit", SCROLLABLE), initEventData, $.proxy(this._initHandler, this)).on(eventUtils.addNamespace("dxscrollstart", SCROLLABLE), $.proxy(strategy.handleStart, strategy)).on(eventUtils.addNamespace("dxscroll", SCROLLABLE), $.proxy(strategy.handleMove, strategy)).on(eventUtils.addNamespace("dxscrollend", SCROLLABLE), $.proxy(strategy.handleEnd, strategy)).on(eventUtils.addNamespace("dxscrollcancel", SCROLLABLE), $.proxy(strategy.handleCancel, strategy)).on(eventUtils.addNamespace("dxscrollstop", SCROLLABLE), $.proxy(strategy.handleStop, strategy))
            },
            _validate: function(e) {
                if (this._isLocked())
                    return false;
                this.update();
                return this._strategy.validate(e)
            },
            _initHandler: function() {
                var strategy = this._strategy;
                strategy.handleInit.apply(strategy, arguments)
            },
            _renderDisabledState: function() {
                this.element().toggleClass(SCROLLABLE_DISABLED_CLASS, this.option("disabled"));
                if (this.option("disabled"))
                    this._lock();
                else
                    this._unlock()
            },
            _renderDirection: function() {
                this.element().removeClass("dx-scrollable-" + HORIZONTAL).removeClass("dx-scrollable-" + VERTICAL).removeClass("dx-scrollable-" + BOTH).addClass("dx-scrollable-" + this.option("direction"))
            },
            _renderStrategy: function() {
                this._createStrategy();
                this._strategy.render();
                this.element().data(SCROLLABLE_STRATEGY, this._strategy)
            },
            _createStrategy: function() {
                this._strategy = this.option("useNative") ? new ui.dxScrollable.NativeStrategy(this) : new ui.dxScrollable.SimulatedStrategy(this)
            },
            _createActions: function() {
                this._strategy.createActions()
            },
            _clean: function() {
                this._strategy.dispose()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"onStart":
                    case"onEnd":
                    case"onStop":
                    case"onUpdated":
                    case"onScroll":
                    case"onBounce":
                        this._createActions();
                        break;
                    case"direction":
                        this._resetInactiveDirection();
                        this._invalidate();
                        break;
                    case"useNative":
                        this._setUseSimulatedScrollbar();
                        this._invalidate();
                        break;
                    case"inertiaEnabled":
                    case"bounceEnabled":
                    case"scrollByContent":
                    case"scrollByThumb":
                    case"bounceEnabled":
                    case"useKeyboard":
                    case"showScrollbar":
                    case"useSimulatedScrollbar":
                    case"pushBackValue":
                        this._invalidate();
                        break;
                    case"disabled":
                        this._renderDisabledState();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _resetInactiveDirection: function() {
                var inactiveProp = this._getInactiveProp();
                if (!inactiveProp)
                    return;
                var scrollOffset = this.scrollOffset();
                scrollOffset[inactiveProp] = 0;
                this.scrollTo(scrollOffset)
            },
            _getInactiveProp: function() {
                var direction = this.option("direction");
                if (direction === VERTICAL)
                    return "left";
                if (direction === HORIZONTAL)
                    return "top"
            },
            _location: function() {
                return this._strategy.location()
            },
            _normalizeLocation: function(location) {
                if ($.isPlainObject(location)) {
                    var left = commonUtils.ensureDefined(location.left, location.x);
                    var top = commonUtils.ensureDefined(location.top, location.y);
                    return {
                            left: commonUtils.isDefined(left) ? -left : undefined,
                            top: commonUtils.isDefined(top) ? -top : undefined
                        }
                }
                else {
                    var direction = this.option("direction");
                    return {
                            left: direction !== VERTICAL ? -location : 0,
                            top: direction !== HORIZONTAL ? -location : 0
                        }
                }
            },
            _isLocked: function() {
                return this._locked
            },
            _lock: function() {
                this._locked = true
            },
            _unlock: function() {
                this._locked = false
            },
            _isDirection: function(direction) {
                var current = this.option("direction");
                if (direction === VERTICAL)
                    return current !== HORIZONTAL;
                if (direction === HORIZONTAL)
                    return current !== VERTICAL;
                return current === direction
            },
            _updateAllowedDirection: function() {
                var allowedDirections = this._strategy._allowedDirections();
                if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal)
                    this._allowedDirectionValue = BOTH;
                else if (this._isDirection(HORIZONTAL) && allowedDirections.horizontal)
                    this._allowedDirectionValue = HORIZONTAL;
                else if (this._isDirection(VERTICAL) && allowedDirections.vertical)
                    this._allowedDirectionValue = VERTICAL;
                else
                    this._allowedDirectionValue = null
            },
            _allowedDirection: function() {
                return this._allowedDirectionValue
            },
            _container: function() {
                return this._$container
            },
            content: function() {
                return this._$content
            },
            scrollOffset: function() {
                var location = this._location();
                return {
                        top: -location.top,
                        left: -location.left
                    }
            },
            scrollTop: function() {
                return this.scrollOffset().top
            },
            scrollLeft: function() {
                return this.scrollOffset().left
            },
            clientHeight: function() {
                return this._$container.height()
            },
            scrollHeight: function() {
                return this.content().outerHeight() - 2 * this.option("pushBackValue")
            },
            clientWidth: function() {
                return this._$container.width()
            },
            scrollWidth: function() {
                return this.content().outerWidth()
            },
            update: function() {
                this._strategy.update();
                this._updateAllowedDirection();
                return $.when().promise()
            },
            scrollBy: function(distance) {
                distance = $.extend({
                    top: 0,
                    left: 0
                }, this._normalizeLocation(distance));
                if (!distance.top && !distance.left)
                    return;
                this.update();
                this._strategy.scrollBy(distance)
            },
            scrollTo: function(targetLocation) {
                var location = this._location();
                targetLocation = this._normalizeLocation(targetLocation);
                this.scrollBy({
                    left: location.left - commonUtils.ensureDefined(targetLocation.left, location.left),
                    top: location.top - commonUtils.ensureDefined(targetLocation.top, location.top)
                })
            },
            scrollToElement: function(element, offset) {
                offset = offset || {};
                var $element = $(element);
                var elementInsideContent = this.content().find(element).length;
                var elementIsInsideContent = $element.parents("." + SCROLLABLE_CLASS).length - $element.parents("." + SCROLLABLE_CONTENT_CLASS).length === 0;
                if (!elementInsideContent || !elementIsInsideContent)
                    return;
                var scrollPosition = {
                        top: 0,
                        left: 0
                    };
                var direction = this.option("direction");
                if (direction !== VERTICAL)
                    scrollPosition.left = this._scrollToElementPosition($element, HORIZONTAL, offset);
                if (direction !== HORIZONTAL)
                    scrollPosition.top = this._scrollToElementPosition($element, VERTICAL, offset);
                this.scrollTo(scrollPosition)
            },
            _scrollToElementPosition: function($element, direction, offset) {
                var isVertical = direction === VERTICAL;
                var startOffset = (isVertical ? offset.top : offset.left) || 0;
                var endOffset = (isVertical ? offset.bottom : offset.right) || 0;
                var pushBackOffset = isVertical ? this.option("pushBackValue") : 0;
                var elementPositionRelativeToContent = this._elementPositionRelativeToContent($element, isVertical ? 'top' : 'left');
                var elementPosition = elementPositionRelativeToContent - pushBackOffset;
                var elementSize = $element[isVertical ? 'outerHeight' : 'outerWidth']();
                var scrollLocation = isVertical ? this.scrollTop() : this.scrollLeft();
                var clientSize = isVertical ? this.clientHeight() : this.clientWidth();
                var startDistance = scrollLocation - elementPosition + startOffset;
                var endDistance = scrollLocation - elementPosition - elementSize + clientSize - endOffset;
                if (startDistance <= 0 && endDistance >= 0)
                    return scrollLocation;
                return scrollLocation - (Math.abs(startDistance) > Math.abs(endDistance) ? endDistance : startDistance)
            },
            _elementPositionRelativeToContent: function($element, prop) {
                var result = 0;
                while (this._hasScrollContent($element)) {
                    result += $element.position()[prop];
                    $element = $element.offsetParent()
                }
                return result
            },
            _hasScrollContent: function($element) {
                var $content = this.content();
                return $element.closest($content).length && !$element.is($content)
            }
        }));
        ui.dxScrollable.deviceDependentOptions = deviceDependentOptions
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollbar.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.require("/utils/utils.translator"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer");
        var SCROLLBAR = "dxScrollbar",
            SCROLLABLE_SCROLLBAR_CLASS = "dx-scrollable-scrollbar",
            SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = SCROLLABLE_SCROLLBAR_CLASS + "-active",
            SCROLLABLE_SCROLL_CLASS = "dx-scrollable-scroll",
            SCROLLABLE_SCROLL_CONTENT_CLASS = "dx-scrollable-scroll-content",
            HOVER_ENABLED_STATE = "dx-scrollbar-hoverable",
            HORIZONTAL = "horizontal",
            THUMB_MIN_SIZE = 15;
        var SCROLLBAR_VISIBLE = {
                onScroll: "onScroll",
                onHover: "onHover",
                always: "always",
                never: "never"
            };
        registerComponent(SCROLLBAR, ui.dxScrollable, Widget.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        direction: null,
                        visible: false,
                        activeStateEnabled: false,
                        visibilityMode: SCROLLBAR_VISIBLE.onScroll,
                        containerSize: 0,
                        contentSize: 0,
                        expandable: true
                    })
            },
            _init: function() {
                this.callBase();
                this._isHovered = false
            },
            _render: function() {
                this._renderThumb();
                this.callBase();
                this._renderDirection();
                this._update();
                this._attachPointerDownHandler();
                this.option("hoverStateEnabled", this._isHoverMode());
                this.element().toggleClass(HOVER_ENABLED_STATE, this.option("hoverStateEnabled"))
            },
            _renderThumb: function() {
                this._$thumb = $("<div>").addClass(SCROLLABLE_SCROLL_CLASS);
                $("<div>").addClass(SCROLLABLE_SCROLL_CONTENT_CLASS).appendTo(this._$thumb);
                this.element().addClass(SCROLLABLE_SCROLLBAR_CLASS).append(this._$thumb)
            },
            isThumb: function($element) {
                return !!this.element().find($element).length
            },
            _isHoverMode: function() {
                var visibilityMode = this.option("visibilityMode");
                return (visibilityMode === SCROLLBAR_VISIBLE.onHover || visibilityMode === SCROLLBAR_VISIBLE.always) && this.option("expandable")
            },
            _renderDirection: function() {
                var direction = this.option("direction");
                this.element().addClass("dx-scrollbar-" + direction);
                this._dimension = direction === HORIZONTAL ? "width" : "height";
                this._prop = direction === HORIZONTAL ? "left" : "top"
            },
            _attachPointerDownHandler: function() {
                this._$thumb.on(eventUtils.addNamespace(pointerEvents.down, SCROLLBAR), $.proxy(this.feedbackOn, this))
            },
            feedbackOn: function() {
                this.element().addClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
                activeScrollbar = this
            },
            feedbackOff: function() {
                this.element().removeClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
                activeScrollbar = null
            },
            cursorEnter: function() {
                this._isHovered = true;
                this.option("visible", true)
            },
            cursorLeave: function() {
                this._isHovered = false;
                this.option("visible", false)
            },
            _renderDimensions: function() {
                this._$thumb.outerHeight(this.option("height"));
                this._$thumb.outerWidth(this.option("width"))
            },
            _toggleVisibility: function(visible) {
                if (this.option("visibilityMode") === SCROLLBAR_VISIBLE.onScroll)
                    this._$thumb.css("opacity");
                visible = this._adjustVisibility(visible);
                this.option().visible = visible;
                this._$thumb.toggleClass("dx-state-invisible", !visible)
            },
            _adjustVisibility: function(visible) {
                if (this.containerToContentRatio() && !this._needScrollbar())
                    return false;
                switch (this.option("visibilityMode")) {
                    case SCROLLBAR_VISIBLE.onScroll:
                        break;
                    case SCROLLBAR_VISIBLE.onHover:
                        visible = visible || !!this._isHovered;
                        break;
                    case SCROLLBAR_VISIBLE.never:
                        visible = false;
                        break;
                    case SCROLLBAR_VISIBLE.always:
                        visible = true;
                        break
                }
                return visible
            },
            moveTo: function(location) {
                if (this._isHidden())
                    return;
                if ($.isPlainObject(location))
                    location = location[this._prop] || 0;
                var scrollBarLocation = {};
                scrollBarLocation[this._prop] = this._calculateScrollBarPosition(location);
                translator.move(this._$thumb, scrollBarLocation)
            },
            _calculateScrollBarPosition: function(location) {
                return -location * this._thumbRatio
            },
            _update: function() {
                var containerSize = this.option("containerSize"),
                    contentSize = this.option("contentSize");
                this._containerToContentRatio = containerSize / contentSize;
                var thumbSize = Math.round(Math.max(Math.round(containerSize * this._containerToContentRatio), THUMB_MIN_SIZE));
                this._thumbRatio = (containerSize - thumbSize) / (contentSize - containerSize);
                this.option(this._dimension, thumbSize);
                this.element().toggle(this._needScrollbar())
            },
            _isHidden: function() {
                return this.option("visibilityMode") === SCROLLBAR_VISIBLE.never
            },
            _needScrollbar: function() {
                return !this._isHidden() && this._containerToContentRatio < 1
            },
            containerToContentRatio: function() {
                return this._containerToContentRatio
            },
            _normalizeSize: function(size) {
                return $.isPlainObject(size) ? size[this._dimension] || 0 : size
            },
            _clean: function() {
                this.callBase();
                if (this === activeScrollbar)
                    activeScrollbar = null;
                this._$thumb.off("." + SCROLLBAR)
            },
            _optionChanged: function(args) {
                if (this._isHidden())
                    return;
                switch (args.name) {
                    case"containerSize":
                    case"contentSize":
                        this.option()[args.name] = this._normalizeSize(args.value);
                        this._update();
                        break;
                    case"visibilityMode":
                    case"direction":
                        this._invalidate();
                        break;
                    default:
                        this.callBase.apply(this, arguments)
                }
            },
            update: function() {
                this._adjustVisibility() && this.option("visible", true)
            }
        }));
        var activeScrollbar = null;
        $(document).on(eventUtils.addNamespace(pointerEvents.up, SCROLLBAR), function() {
            if (activeScrollbar)
                activeScrollbar.feedbackOff()
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollable.native.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            devices = DX.require("/devices"),
            Class = DevExpress.require("/class");
        var SCROLLABLE_NATIVE = "dxNativeScrollable",
            SCROLLABLE_NATIVE_CLASS = "dx-scrollable-native",
            SCROLLABLE_SCROLLBAR_SIMULATED = "dx-scrollable-scrollbar-simulated",
            SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden",
            VERTICAL = "vertical",
            HORIZONTAL = "horizontal",
            HIDE_SCROLLBAR_TIMOUT = 500;
        ui.dxScrollable.NativeStrategy = Class.inherit({
            ctor: function(scrollable) {
                this._init(scrollable)
            },
            _init: function(scrollable) {
                this._component = scrollable;
                this._$element = scrollable.element();
                this._$container = scrollable._$container;
                this._$content = scrollable._$content;
                this._direction = scrollable.option("direction");
                this._useSimulatedScrollbar = scrollable.option("useSimulatedScrollbar");
                this._showScrollbar = scrollable.option("showScrollbar");
                this.option = $.proxy(scrollable.option, scrollable);
                this._createActionByOption = $.proxy(scrollable._createActionByOption, scrollable);
                this._isLocked = $.proxy(scrollable._isLocked, scrollable);
                this._isDirection = $.proxy(scrollable._isDirection, scrollable);
                this._allowedDirection = $.proxy(scrollable._allowedDirection, scrollable)
            },
            render: function() {
                var device = devices.real(),
                    deviceType = device.platform;
                this._$element.addClass(SCROLLABLE_NATIVE_CLASS).addClass(SCROLLABLE_NATIVE_CLASS + "-" + deviceType).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._showScrollbar);
                if (this._showScrollbar && this._useSimulatedScrollbar)
                    this._renderScrollbars()
            },
            _renderScrollbars: function() {
                this._scrollbars = {};
                this._hideScrollbarTimeout = 0;
                this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);
                this._renderScrollbar(VERTICAL);
                this._renderScrollbar(HORIZONTAL)
            },
            _renderScrollbar: function(direction) {
                if (!this._isDirection(direction))
                    return;
                var $scrollbar = $("<div>").dxScrollbar({
                        direction: direction,
                        expandable: this._component.option("scrollByThumb")
                    }).appendTo(this._$element);
                this._scrollbars[direction] = $scrollbar.dxScrollbar("instance")
            },
            handleInit: $.noop,
            handleStart: function() {
                this._disablePushBack = true
            },
            handleMove: function(e) {
                if (this._isLocked()) {
                    e.cancel = true;
                    return
                }
                if (this._allowedDirection())
                    e.originalEvent.isScrollingEvent = true
            },
            handleEnd: function() {
                this._disablePushBack = false
            },
            handleStop: $.noop,
            _eachScrollbar: function(callback) {
                callback = $.proxy(callback, this);
                $.each(this._scrollbars || {}, function(direction, scrollbar) {
                    callback(scrollbar, direction)
                })
            },
            createActions: function() {
                this._scrollAction = this._createActionByOption("onScroll");
                this._updateAction = this._createActionByOption("onUpdated")
            },
            _createActionArgs: function() {
                var location = this.location();
                return {
                        jQueryEvent: this._eventForUserAction,
                        scrollOffset: {
                            top: -location.top,
                            left: -location.left
                        },
                        reachedLeft: this._isDirection(HORIZONTAL) ? location.left >= 0 : undefined,
                        reachedRight: this._isDirection(HORIZONTAL) ? location.left <= this._containerSize.width - this._componentContentSize.width : undefined,
                        reachedTop: this._isDirection(VERTICAL) ? location.top >= 0 : undefined,
                        reachedBottom: this._isDirection(VERTICAL) ? location.top <= this._containerSize.height - this._componentContentSize.height : undefined
                    }
            },
            handleScroll: function(e) {
                if (!this._isScrollLocationChanged()) {
                    e.stopImmediatePropagation();
                    return
                }
                this._eventForUserAction = e;
                this._moveScrollbars();
                this._scrollAction(this._createActionArgs());
                this._lastLocation = this.location();
                this._pushBackFromBoundary()
            },
            _pushBackFromBoundary: function() {
                var pushBackValue = this.option("pushBackValue");
                if (!pushBackValue || this._disablePushBack)
                    return;
                var scrollOffset = this._containerSize.height - this._contentSize.height,
                    scrollTopPos = this._$container.scrollTop(),
                    scrollBottomPos = scrollOffset + scrollTopPos - pushBackValue * 2;
                if (!scrollTopPos)
                    this._$container.scrollTop(pushBackValue);
                else if (!scrollBottomPos)
                    this._$container.scrollTop(pushBackValue - scrollOffset)
            },
            _isScrollLocationChanged: function() {
                var currentLocation = this.location(),
                    lastLocation = this._lastLocation || {},
                    isTopChanged = lastLocation.top !== currentLocation.top,
                    isLeftChanged = lastLocation.left !== currentLocation.left;
                return isTopChanged || isLeftChanged
            },
            _moveScrollbars: function() {
                this._eachScrollbar(function(scrollbar) {
                    scrollbar.moveTo(this.location());
                    scrollbar.option("visible", true)
                });
                this._hideScrollbars()
            },
            _hideScrollbars: function() {
                clearTimeout(this._hideScrollbarTimeout);
                this._hideScrollbarTimeout = setTimeout($.proxy(function() {
                    this._eachScrollbar(function(scrollbar) {
                        scrollbar.option("visible", false)
                    })
                }, this), HIDE_SCROLLBAR_TIMOUT)
            },
            location: function() {
                return {
                        left: -this._$container.scrollLeft(),
                        top: this.option("pushBackValue") - this._$container.scrollTop()
                    }
            },
            disabledChanged: $.noop,
            update: function() {
                this._update();
                this._updateAction(this._createActionArgs())
            },
            _update: function() {
                this._updateDimensions();
                this._updateScrollbars()
            },
            _updateDimensions: function() {
                this._containerSize = {
                    height: this._$container.height(),
                    width: this._$container.width()
                };
                this._componentContentSize = {
                    height: this._component.content().height(),
                    width: this._component.content().width()
                };
                this._contentSize = {
                    height: this._$content.height(),
                    width: this._$content.width()
                };
                this._pushBackFromBoundary()
            },
            _updateScrollbars: function() {
                this._eachScrollbar(function(scrollbar, direction) {
                    var dimension = direction === VERTICAL ? "height" : "width";
                    scrollbar.option({
                        containerSize: this._containerSize[dimension],
                        contentSize: this._componentContentSize[dimension]
                    });
                    scrollbar.update()
                })
            },
            _allowedDirections: function() {
                return {
                        vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,
                        horizontal: this._isDirection(HORIZONTAL) && this._contentSize.width > this._containerSize.width
                    }
            },
            dispose: function() {
                this._$element.removeClass(function(index, className) {
                    var scrollableNativeRegexp = new RegExp(SCROLLABLE_NATIVE_CLASS + "\\S*", "g");
                    if (scrollableNativeRegexp.test(className))
                        return className.match(scrollableNativeRegexp).join(" ")
                });
                this._$element.off("." + SCROLLABLE_NATIVE);
                this._$container.off("." + SCROLLABLE_NATIVE);
                this._removeScrollbars();
                clearTimeout(this._gestureEndTimer);
                clearTimeout(this._hideScrollbarTimeout)
            },
            _removeScrollbars: function() {
                this._eachScrollbar(function(scrollbar) {
                    scrollbar.element().remove()
                })
            },
            scrollBy: function(distance) {
                var location = this.location();
                this._$container.scrollTop(-location.top - distance.top + this.option("pushBackValue"));
                this._$container.scrollLeft(-location.left - distance.left)
            },
            validate: function() {
                return !this.option("disabled") && this._allowedDirection()
            },
            getDirection: function() {
                return this._allowedDirection()
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollable.simulated.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            math = Math,
            titleize = DX.require("/utils/utils.inflector").titleize,
            translator = DX.require("/utils/utils.translator"),
            Class = DX.require("/class"),
            Animator = DX.require("/animator"),
            devices = DX.require("/devices"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer");
        var realDevice = devices.real;
        var isSluggishPlatform = realDevice.platform === "win" || realDevice.platform === "android";
        var SCROLLABLE_SIMULATED = "dxSimulatedScrollable",
            SCROLLABLE_STRATEGY = "dxScrollableStrategy",
            SCROLLABLE_SIMULATED_CURSOR = SCROLLABLE_SIMULATED + "Cursor",
            SCROLLABLE_SIMULATED_KEYBOARD = SCROLLABLE_SIMULATED + "Keyboard",
            SCROLLABLE_SIMULATED_CLASS = "dx-scrollable-simulated",
            SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden",
            SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = "dx-scrollable-scrollbars-alwaysvisible",
            SCROLLABLE_SCROLLBAR_CLASS = "dx-scrollable-scrollbar",
            VERTICAL = "vertical",
            HORIZONTAL = "horizontal",
            ACCELERATION = isSluggishPlatform ? 0.95 : 0.92,
            OUT_BOUNDS_ACCELERATION = 0.5,
            MIN_VELOCITY_LIMIT = 1,
            FRAME_DURATION = math.round(1000 / 60),
            SCROLL_LINE_HEIGHT = 20,
            BOUNCE_MIN_VELOCITY_LIMIT = MIN_VELOCITY_LIMIT / 5,
            BOUNCE_DURATION = isSluggishPlatform ? 300 : 400,
            BOUNCE_FRAMES = BOUNCE_DURATION / FRAME_DURATION,
            BOUNCE_ACCELERATION_SUM = (1 - math.pow(ACCELERATION, BOUNCE_FRAMES)) / (1 - ACCELERATION);
        var KEY_CODES = {
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                END: 35,
                HOME: 36,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40
            };
        var scrollIntoViewIfNeededCallbacks = function() {
                var callbacks = $.Callbacks();
                var FOCUS_TIMEOUT = 50,
                    cancelChangeTimestamp = null;
                $(window).on(eventUtils.addNamespace("focus", SCROLLABLE_STRATEGY), function() {
                    cancelChangeTimestamp = $.now()
                });
                $(document).on(eventUtils.addNamespace(pointerEvents.down, SCROLLABLE_STRATEGY), function() {
                    cancelChangeTimestamp = $.now()
                });
                var focusChange = function(e) {
                        var keyboardElementChange = $.now() - cancelChangeTimestamp > FOCUS_TIMEOUT,
                            focusedCorrectElement = e.target === document.activeElement;
                        if (keyboardElementChange && focusedCorrectElement)
                            callbacks.fire(e.target)
                    };
                if (window.addEventListener) {
                    var asyncFocus = "onactivate" in document;
                    if (asyncFocus)
                        window.addEventListener("activate", focusChange, true);
                    else
                        window.addEventListener("focus", focusChange, true)
                }
                else
                    window.attachEvent("onfocusin", focusChange);
                return callbacks
            }();
        var InertiaAnimator = Animator.inherit({
                ctor: function(scroller) {
                    this.callBase();
                    this.scroller = scroller
                },
                VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,
                _isFinished: function() {
                    return math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT
                },
                _step: function() {
                    this.scroller._scrollStep(this.scroller._velocity);
                    this.scroller._velocity *= this._acceleration()
                },
                _acceleration: function() {
                    return this.scroller._inBounds() ? ACCELERATION : OUT_BOUNDS_ACCELERATION
                },
                _complete: function() {
                    this.scroller._scrollComplete()
                },
                _stop: function() {
                    this.scroller._stopComplete()
                }
            });
        var BounceAnimator = InertiaAnimator.inherit({
                VELOCITY_LIMIT: BOUNCE_MIN_VELOCITY_LIMIT,
                _isFinished: function() {
                    return this.scroller._crossBoundOnNextStep() || this.callBase()
                },
                _acceleration: function() {
                    return ACCELERATION
                },
                _complete: function() {
                    this.scroller._move(this.scroller._bounceLocation);
                    this.callBase()
                }
            });
        var isWheelEvent = function(e) {
                return e.type === "dxmousewheel"
            };
        var Scroller = ui.dxScrollable.Scroller = Class.inherit({
                ctor: function(options) {
                    this._initOptions(options);
                    this._initAnimators();
                    this._initScrollbar()
                },
                _initOptions: function(options) {
                    this._location = 0;
                    this._topReached = false;
                    this._bottomReached = false;
                    this._axis = options.direction === HORIZONTAL ? "x" : "y";
                    this._prop = options.direction === HORIZONTAL ? "left" : "top";
                    this._dimension = options.direction === HORIZONTAL ? "width" : "height";
                    this._scrollProp = options.direction === HORIZONTAL ? "scrollLeft" : "scrollTop";
                    this._pushBackCorrection = options.direction === VERTICAL ? options.pushBackValue * 2 : 0;
                    $.each(options, $.proxy(function(optionName, optionValue) {
                        this["_" + optionName] = optionValue
                    }, this))
                },
                _initAnimators: function() {
                    this._inertiaAnimator = new InertiaAnimator(this);
                    this._bounceAnimator = new BounceAnimator(this)
                },
                _initScrollbar: function() {
                    this._$scrollbar = $("<div>").dxScrollbar({
                        direction: this._direction,
                        visible: this._scrollByThumb,
                        visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
                        containerSize: this._containerSize(),
                        contentSize: this._contentSize(),
                        expandable: this._scrollByThumb
                    }).appendTo(this._$container);
                    this._scrollbar = this._$scrollbar.dxScrollbar("instance")
                },
                _visibilityModeNormalize: function(mode) {
                    return mode === true ? "onScroll" : mode === false ? "never" : mode
                },
                _scrollStep: function(delta) {
                    var prevLocation = this._location;
                    this._location += delta;
                    this._suppressBounce();
                    this._move();
                    if (Math.abs(prevLocation - this._location) < 1)
                        return;
                    this._scrollAction();
                    this._$container.triggerHandler({
                        type: "scroll",
                        simulated: true
                    })
                },
                _suppressBounce: function() {
                    if (this._bounceEnabled || this._inBounds(this._location))
                        return;
                    this._velocity = 0;
                    this._location = this._boundLocation()
                },
                _boundLocation: function(location) {
                    location = location !== undefined ? location : this._location;
                    return math.max(math.min(location, this._maxOffset), this._minOffset)
                },
                _move: function(location) {
                    this._location = location !== undefined ? location : this._location;
                    this._moveContent();
                    this._moveScrollbar()
                },
                _moveContent: function() {
                    var targetLocation = {};
                    targetLocation[this._prop] = this._location;
                    translator.move(this._$content, targetLocation)
                },
                _moveScrollbar: function() {
                    this._scrollbar.moveTo(this._location)
                },
                _scrollComplete: function() {
                    if (this._inBounds()) {
                        this._hideScrollbar();
                        this._correctLocation();
                        if (this._completeDeferred)
                            this._completeDeferred.resolve()
                    }
                    this._scrollToBounds()
                },
                _correctLocation: function() {
                    this._location = math.round(this._location);
                    this._move()
                },
                _scrollToBounds: function() {
                    if (this._inBounds())
                        return;
                    this._bounceAction();
                    this._setupBounce();
                    this._bounceAnimator.start()
                },
                _setupBounce: function() {
                    var boundLocation = this._bounceLocation = this._boundLocation(),
                        bounceDistance = boundLocation - this._location;
                    this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM
                },
                _inBounds: function(location) {
                    location = location !== undefined ? location : this._location;
                    return this._boundLocation(location) === location
                },
                _crossBoundOnNextStep: function() {
                    var location = this._location,
                        nextLocation = location + this._velocity;
                    return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset
                },
                _initHandler: function(e) {
                    this._stopDeferred = $.Deferred();
                    this._stopScrolling();
                    this._prepareThumbScrolling(e);
                    return this._stopDeferred.promise()
                },
                _stopScrolling: function() {
                    this._hideScrollbar();
                    this._inertiaAnimator.stop();
                    this._bounceAnimator.stop()
                },
                _prepareThumbScrolling: function(e) {
                    if (isWheelEvent(e.originalEvent))
                        return;
                    var $target = $(e.originalEvent.target);
                    var scrollbarClicked = this._isScrollbar($target);
                    if (scrollbarClicked)
                        this._moveToMouseLocation(e);
                    this._thumbScrolling = scrollbarClicked || this._isThumb($target);
                    this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);
                    if (this._thumbScrolling)
                        this._scrollbar.feedbackOn()
                },
                _isThumbScrollingHandler: function($target) {
                    return this._isThumb($target)
                },
                _moveToMouseLocation: function(e) {
                    var mouseLocation = e["page" + this._axis.toUpperCase()] - this._$element.offset()[this._prop];
                    var location = this._location + mouseLocation / this._containerToContentRatio() - this._$container.height() / 2;
                    this._scrollStep(-location)
                },
                _stopComplete: function() {
                    if (this._stopDeferred)
                        this._stopDeferred.resolve()
                },
                _startHandler: function() {
                    this._showScrollbar()
                },
                _moveHandler: function(delta) {
                    if (this._crossThumbScrolling)
                        return;
                    if (this._thumbScrolling)
                        delta[this._axis] = -delta[this._axis] / this._containerToContentRatio();
                    this._scrollBy(delta)
                },
                _scrollBy: function(delta) {
                    delta = delta[this._axis];
                    if (!this._inBounds())
                        delta *= OUT_BOUNDS_ACCELERATION;
                    this._scrollStep(delta)
                },
                _scrollByHandler: function(delta) {
                    this._scrollBy(delta);
                    this._scrollComplete()
                },
                _containerToContentRatio: function() {
                    return this._scrollbar.containerToContentRatio()
                },
                _endHandler: function(velocity) {
                    this._completeDeferred = $.Deferred();
                    this._velocity = velocity[this._axis];
                    this._inertiaHandler();
                    this._resetThumbScrolling();
                    return this._completeDeferred.promise()
                },
                _inertiaHandler: function() {
                    this._suppressIntertia();
                    this._inertiaAnimator.start()
                },
                _suppressIntertia: function() {
                    if (!this._inertiaEnabled || this._thumbScrolling)
                        this._velocity = 0
                },
                _resetThumbScrolling: function() {
                    this._thumbScrolling = false;
                    this._crossThumbScrolling = false
                },
                _stopHandler: function() {
                    this._resetThumbScrolling();
                    this._scrollToBounds()
                },
                _disposeHandler: function() {
                    this._stopScrolling();
                    this._$scrollbar.remove()
                },
                _updateHandler: function() {
                    this._update();
                    this._moveToBounds()
                },
                _update: function() {
                    this._stopScrolling();
                    this._updateLocation();
                    this._updateBounds();
                    this._updateScrollbar();
                    this._moveScrollbar();
                    this._scrollbar.update()
                },
                _updateLocation: function() {
                    this._location = translator.locate(this._$content)[this._prop]
                },
                _updateBounds: function() {
                    this._maxOffset = this._getMaxOffset();
                    this._minOffset = this._getMinOffset()
                },
                _getMaxOffset: function() {
                    return 0
                },
                _getMinOffset: function() {
                    return math.min(this._containerSize() - this._contentSize(), 0)
                },
                _updateScrollbar: function() {
                    this._scrollbar.option({
                        containerSize: this._containerSize(),
                        contentSize: this._contentSize()
                    })
                },
                _moveToBounds: function() {
                    var location = this._boundLocation();
                    var locationChanged = location !== this._location;
                    this._location = location;
                    this._move();
                    if (locationChanged)
                        this._scrollAction()
                },
                _createActionsHandler: function(actions) {
                    this._scrollAction = actions.scroll;
                    this._bounceAction = actions.bounce
                },
                _showScrollbar: function() {
                    this._scrollbar.option("visible", true)
                },
                _hideScrollbar: function() {
                    this._scrollbar.option("visible", false)
                },
                _containerSize: function() {
                    return this._$container[this._dimension]()
                },
                _contentSize: function() {
                    var isOverflowHidden = this._$content.css("overflow-" + this._axis) === "hidden",
                        contentSize = this._$content[this._dimension]();
                    if (!isOverflowHidden) {
                        var containerScrollSize = this._$content[0]["scroll" + titleize(this._dimension)];
                        contentSize = math.max(containerScrollSize - this._pushBackCorrection, contentSize)
                    }
                    return contentSize
                },
                _validateEvent: function(e) {
                    var $target = $(e.originalEvent.target);
                    if (this._isThumb($target) || this._isScrollbar($target)) {
                        e.preventDefault();
                        return true
                    }
                    return this._isContent($target)
                },
                _isThumb: function($element) {
                    return this._scrollByThumb && this._scrollbar.isThumb($element)
                },
                _isScrollbar: function($element) {
                    return this._scrollByThumb && $element && $element.is(this._$scrollbar)
                },
                _isContent: function($element) {
                    return this._scrollByContent && !!$element.closest(this._$element).length
                },
                _reachedMin: function() {
                    return this._location <= this._minOffset
                },
                _reachedMax: function() {
                    return this._location >= this._maxOffset
                },
                _cursorEnterHandler: function() {
                    this._scrollbar.cursorEnter()
                },
                _cursorLeaveHandler: function() {
                    this._scrollbar.cursorLeave()
                },
                dispose: $.noop
            });
        var hoveredScrollable,
            activeScrollable;
        ui.dxScrollable.SimulatedStrategy = Class.inherit({
            ctor: function(scrollable) {
                this._init(scrollable)
            },
            _init: function(scrollable) {
                this._component = scrollable;
                this._$element = scrollable.element();
                this._$container = scrollable._$container;
                this._$content = scrollable._$content;
                this.option = $.proxy(scrollable.option, scrollable);
                this._createActionByOption = $.proxy(scrollable._createActionByOption, scrollable);
                this._isLocked = $.proxy(scrollable._isLocked, scrollable);
                this._isDirection = $.proxy(scrollable._isDirection, scrollable);
                this._allowedDirection = $.proxy(scrollable._allowedDirection, scrollable);
                this._proxiedActiveElementChangeHandler = $.proxy(this._activeElementChangeHandler, this);
                scrollIntoViewIfNeededCallbacks.add(this._proxiedActiveElementChangeHandler)
            },
            _activeElementChangeHandler: function(activeElement) {
                this._component.scrollToElement(activeElement)
            },
            render: function() {
                this._$element.addClass(SCROLLABLE_SIMULATED_CLASS);
                this._createScrollers();
                if (this.option("useKeyboard"))
                    this._$container.prop("tabindex", 0);
                this._attachKeyboardHandler();
                this._attachCursorHandlers()
            },
            _createScrollers: function() {
                this._scrollers = {};
                if (this._isDirection(HORIZONTAL))
                    this._createScroller(HORIZONTAL);
                if (this._isDirection(VERTICAL))
                    this._createScroller(VERTICAL);
                this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, this.option("showScrollbar") === "always");
                this._$element.toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this.option("showScrollbar"))
            },
            _createScroller: function(direction) {
                this._scrollers[direction] = new Scroller(this._scrollerOptions(direction))
            },
            _scrollerOptions: function(direction) {
                return {
                        direction: direction,
                        $content: this._$content,
                        $container: this._$container,
                        $element: this._$element,
                        scrollByContent: this.option("scrollByContent"),
                        scrollByThumb: this.option("scrollByThumb"),
                        scrollbarVisible: this.option("showScrollbar"),
                        bounceEnabled: this.option("bounceEnabled"),
                        inertiaEnabled: this.option("inertiaEnabled"),
                        isAnyThumbScrolling: $.proxy(this._isAnyThumbScrolling, this),
                        pushBackValue: this.option("pushBackValue")
                    }
            },
            _isAnyThumbScrolling: function($target) {
                var result = false;
                this._eventHandler("isThumbScrolling", $target).done(function(isThumbScrollingVertical, isThumbScrollingHorizontal) {
                    result = isThumbScrollingVertical || isThumbScrollingHorizontal
                });
                return result
            },
            handleInit: function(e) {
                this._supressDirections(e);
                this._eventForUserAction = e;
                this._eventHandler("init", e).done(this._stopAction)
            },
            _supressDirections: function(e) {
                if (isWheelEvent(e.originalEvent)) {
                    this._prepareDirections(true);
                    return
                }
                this._prepareDirections();
                this._eachScroller(function(scroller, direction) {
                    var isValid = scroller._validateEvent(e);
                    this._validDirections[direction] = isValid
                })
            },
            _prepareDirections: function(value) {
                value = value || false;
                this._validDirections = {};
                this._validDirections[HORIZONTAL] = value;
                this._validDirections[VERTICAL] = value
            },
            _eachScroller: function(callback) {
                callback = $.proxy(callback, this);
                $.each(this._scrollers, function(direction, scroller) {
                    callback(scroller, direction)
                })
            },
            handleStart: function(e) {
                this._eventForUserAction = e;
                this._eventHandler("start").done(this._startAction)
            },
            _saveActive: function() {
                activeScrollable = this
            },
            _resetActive: function() {
                if (activeScrollable === this)
                    activeScrollable = null
            },
            handleMove: function(e) {
                if (this._isLocked()) {
                    e.cancel = true;
                    this._resetActive();
                    return
                }
                this._saveActive();
                e.preventDefault && e.preventDefault();
                this._adjustDistance(e.delta);
                this._eventForUserAction = e;
                this._eventHandler("move", e.delta)
            },
            _adjustDistance: function(distance) {
                distance.x *= this._validDirections[HORIZONTAL];
                distance.y *= this._validDirections[VERTICAL]
            },
            handleEnd: function(e) {
                this._resetActive();
                this._refreshCursorState(e.originalEvent && e.originalEvent.target);
                this._adjustDistance(e.velocity);
                this._eventForUserAction = e;
                return this._eventHandler("end", e.velocity).done(this._endAction)
            },
            handleCancel: function(e) {
                this._resetActive();
                this._eventForUserAction = e;
                return this._eventHandler("end", {
                        x: 0,
                        y: 0
                    })
            },
            handleStop: function() {
                this._resetActive();
                this._eventHandler("stop")
            },
            handleScroll: function(e) {
                if (e.simulated)
                    return;
                var distance = {
                        left: this.option("direction") !== VERTICAL ? -this._$container.scrollLeft() : 0,
                        top: this.option("direction") !== HORIZONTAL ? -this._$container.scrollTop() : 0
                    };
                if (!distance.left && !distance.top)
                    return;
                this._$container.scrollLeft(0);
                this._$container.scrollTop(0);
                this.scrollBy(distance)
            },
            _attachKeyboardHandler: function() {
                this._$element.off("." + SCROLLABLE_SIMULATED_KEYBOARD);
                if (!this.option("disabled") && this.option("useKeyboard"))
                    this._$element.on(eventUtils.addNamespace("keydown", SCROLLABLE_SIMULATED_KEYBOARD), $.proxy(this._keyDownHandler, this))
            },
            _keyDownHandler: function(e) {
                if (!this._$container.is(document.activeElement))
                    return;
                var handled = true;
                switch (e.keyCode) {
                    case KEY_CODES.DOWN:
                        this._scrollByLine({y: 1});
                        break;
                    case KEY_CODES.UP:
                        this._scrollByLine({y: -1});
                        break;
                    case KEY_CODES.RIGHT:
                        this._scrollByLine({x: 1});
                        break;
                    case KEY_CODES.LEFT:
                        this._scrollByLine({x: -1});
                        break;
                    case KEY_CODES.PAGE_DOWN:
                        this._scrollByPage(1);
                        break;
                    case KEY_CODES.PAGE_UP:
                        this._scrollByPage(-1);
                        break;
                    case KEY_CODES.HOME:
                        this._scrollToHome();
                        break;
                    case KEY_CODES.END:
                        this._scrollToEnd();
                        break;
                    default:
                        handled = false;
                        break
                }
                if (handled) {
                    e.stopPropagation();
                    e.preventDefault()
                }
            },
            _scrollByLine: function(lines) {
                this.scrollBy({
                    top: (lines.y || 0) * -SCROLL_LINE_HEIGHT,
                    left: (lines.x || 0) * -SCROLL_LINE_HEIGHT
                })
            },
            _scrollByPage: function(page) {
                var prop = this._wheelProp(),
                    dimension = this._dimensionByProp(prop);
                var distance = {};
                distance[prop] = page * -this._$container[dimension]();
                this.scrollBy(distance)
            },
            _dimensionByProp: function(prop) {
                return prop === "left" ? "width" : "height"
            },
            _scrollToHome: function() {
                var prop = this._wheelProp();
                var distance = {};
                distance[prop] = 0;
                this._component.scrollTo(distance)
            },
            _scrollToEnd: function() {
                var prop = this._wheelProp(),
                    dimension = this._dimensionByProp(prop);
                var distance = {};
                distance[prop] = this._$content[dimension]() - this._$container[dimension]();
                this._component.scrollTo(distance)
            },
            createActions: function() {
                this._startAction = this._createActionHandler("onStart");
                this._stopAction = this._createActionHandler("onStop");
                this._endAction = this._createActionHandler("onEnd");
                this._updateAction = this._createActionHandler("onUpdated");
                this._createScrollerActions()
            },
            _createScrollerActions: function() {
                this._eventHandler("createActions", {
                    scroll: this._createActionHandler("onScroll"),
                    bounce: this._createActionHandler("onBounce")
                })
            },
            _createActionHandler: function(optionName) {
                var that = this,
                    actionHandler = that._createActionByOption(optionName);
                return function() {
                        actionHandler($.extend(that._createActionArgs(), arguments))
                    }
            },
            _createActionArgs: function() {
                var scrollerX = this._scrollers[HORIZONTAL],
                    scrollerY = this._scrollers[VERTICAL];
                return {
                        jQueryEvent: this._eventForUserAction,
                        scrollOffset: {
                            top: scrollerY && -scrollerY._location,
                            left: scrollerX && -scrollerX._location
                        },
                        reachedLeft: scrollerX && scrollerX._reachedMax(),
                        reachedRight: scrollerX && scrollerX._reachedMin(),
                        reachedTop: scrollerY && scrollerY._reachedMax(),
                        reachedBottom: scrollerY && scrollerY._reachedMin()
                    }
            },
            _eventHandler: function(eventName) {
                var args = $.makeArray(arguments).slice(1),
                    deferreds = $.map(this._scrollers, function(scroller) {
                        return scroller["_" + eventName + "Handler"].apply(scroller, args)
                    });
                return $.when.apply($, deferreds).promise()
            },
            location: function() {
                return translator.locate(this._$content)
            },
            disabledChanged: function() {
                this._attachCursorHandlers()
            },
            _attachCursorHandlers: function() {
                this._$element.off("." + SCROLLABLE_SIMULATED_CURSOR);
                if (!this.option("disabled") && this._isHoverMode())
                    this._$element.on(eventUtils.addNamespace("mouseenter", SCROLLABLE_SIMULATED_CURSOR), $.proxy(this._cursorEnterHandler, this)).on(eventUtils.addNamespace("mouseleave", SCROLLABLE_SIMULATED_CURSOR), $.proxy(this._cursorLeaveHandler, this))
            },
            _isHoverMode: function() {
                return this.option("showScrollbar") === "onHover"
            },
            _cursorEnterHandler: function(e) {
                e = e || {};
                e.originalEvent = e.originalEvent || {};
                if (activeScrollable || e.originalEvent._hoverHandled)
                    return;
                if (hoveredScrollable)
                    hoveredScrollable._cursorLeaveHandler();
                hoveredScrollable = this;
                this._eventHandler("cursorEnter");
                e.originalEvent._hoverHandled = true
            },
            _cursorLeaveHandler: function(e) {
                if (hoveredScrollable !== this || activeScrollable === hoveredScrollable)
                    return;
                this._eventHandler("cursorLeave");
                hoveredScrollable = null;
                this._refreshCursorState(e && e.relatedTarget)
            },
            _refreshCursorState: function(target) {
                if (!this._isHoverMode() && (!target || activeScrollable))
                    return;
                var $target = $(target);
                var $scrollable = $target.closest("." + SCROLLABLE_SIMULATED_CLASS + ":not(.dx-state-disabled)");
                var targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);
                if (hoveredScrollable && hoveredScrollable !== targetScrollable)
                    hoveredScrollable._cursorLeaveHandler();
                if (targetScrollable)
                    targetScrollable._cursorEnterHandler()
            },
            update: function() {
                return this._eventHandler("update").done(this._updateAction)
            },
            _allowedDirections: function() {
                var bounceEnabled = this.option("bounceEnabled"),
                    verticalScroller = this._scrollers[VERTICAL],
                    horizontalScroller = this._scrollers[HORIZONTAL];
                return {
                        vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),
                        horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)
                    }
            },
            scrollBy: function(distance) {
                var verticalScroller = this._scrollers[VERTICAL],
                    horizontalScroller = this._scrollers[HORIZONTAL];
                if (verticalScroller)
                    distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location;
                if (horizontalScroller)
                    distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location;
                this._prepareDirections(true);
                this._startAction();
                this._eventHandler("scrollBy", {
                    x: distance.left,
                    y: distance.top
                });
                this._endAction()
            },
            validate: function(e) {
                if (this.option("disabled"))
                    return false;
                if (this.option("bounceEnabled"))
                    return true;
                return isWheelEvent(e) ? this._validateWheel(e) : this._validateMove(e)
            },
            _validateWheel: function(e) {
                var scroller = this._scrollers[this._wheelDirection(e)];
                var reachedMin = scroller._reachedMin();
                var reachedMax = scroller._reachedMax();
                var contentGreaterThanContainer = !reachedMin || !reachedMax;
                var locatedNotAtBound = !reachedMin && !reachedMax;
                var scrollFromMin = reachedMin && e.delta > 0;
                var scrollFromMax = reachedMax && e.delta < 0;
                return contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax)
            },
            _validateMove: function(e) {
                if (!this.option("scrollByContent") && !$(e.target).closest("." + SCROLLABLE_SCROLLBAR_CLASS).length)
                    return false;
                return this._allowedDirection()
            },
            getDirection: function(e) {
                return isWheelEvent(e) ? this._wheelDirection(e) : this._allowedDirection()
            },
            _wheelProp: function() {
                return this._wheelDirection() === HORIZONTAL ? "left" : "top"
            },
            _wheelDirection: function(e) {
                switch (this.option("direction")) {
                    case HORIZONTAL:
                        return HORIZONTAL;
                    case VERTICAL:
                        return VERTICAL;
                    default:
                        return e && e.shiftKey ? HORIZONTAL : VERTICAL
                }
            },
            dispose: function() {
                scrollIntoViewIfNeededCallbacks.remove(this._proxiedActiveElementChangeHandler);
                this._resetActive();
                if (hoveredScrollable === this)
                    hoveredScrollable = null;
                this._eventHandler("dispose");
                this._detachEventHandlers();
                this._$element.removeClass(SCROLLABLE_SIMULATED_CLASS);
                this._eventForUserAction = null;
                clearTimeout(this._gestureEndTimer)
            },
            _detachEventHandlers: function() {
                this._$element.off("." + SCROLLABLE_SIMULATED_CURSOR);
                this._$container.off("." + SCROLLABLE_SIMULATED_KEYBOARD)
            }
        });
        ui.dxScrollable.__internals = $.extend(ui.dxScrollable.__internals || {}, {
            ACCELERATION: ACCELERATION,
            MIN_VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,
            FRAME_DURATION: FRAME_DURATION,
            SCROLL_LINE_HEIGHT: SCROLL_LINE_HEIGHT,
            scrollIntoViewIfNeededCallbacks: scrollIntoViewIfNeededCallbacks
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator");
        var SCROLLVIEW_CLASS = "dx-scrollview",
            SCROLLVIEW_CONTENT_CLASS = SCROLLVIEW_CLASS + "-content",
            SCROLLVIEW_TOP_POCKET_CLASS = SCROLLVIEW_CLASS + "-top-pocket",
            SCROLLVIEW_BOTTOM_POCKET_CLASS = SCROLLVIEW_CLASS + "-bottom-pocket",
            SCROLLVIEW_PULLDOWN_CLASS = SCROLLVIEW_CLASS + "-pull-down",
            SCROLLVIEW_REACHBOTTOM_CLASS = SCROLLVIEW_CLASS + "-scrollbottom",
            SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-indicator",
            SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-text",
            SCROLLVIEW_LOADPANEL = SCROLLVIEW_CLASS + "-loadpanel";
        registerComponent("dxScrollView", ui, ui.dxScrollable.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        pullingDownText: Globalize.localize("dxScrollView-pullingDownText"),
                        pulledDownText: Globalize.localize("dxScrollView-pulledDownText"),
                        refreshingText: Globalize.localize("dxScrollView-refreshingText"),
                        reachBottomText: Globalize.localize("dxScrollView-reachBottomText"),
                        onPullDown: null,
                        onReachBottom: null,
                        refreshStrategy: "pullDown"
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                var realDevice = devices.real();
                                return realDevice.platform === "android"
                            },
                            options: {refreshStrategy: "swipeDown"}
                        }, {
                            device: function(device) {
                                return devices.real().platform === "win"
                            },
                            options: {refreshStrategy: "slideDown"}
                        }])
            },
            _init: function() {
                this.callBase();
                this._loadingIndicatorEnabled = true
            },
            _initMarkup: function() {
                this.callBase();
                this.element().addClass(SCROLLVIEW_CLASS);
                this._initContent();
                this._initTopPocket();
                this._initBottomPocket();
                this._initLoadPanel()
            },
            _initContent: function() {
                var $content = $("<div>").addClass(SCROLLVIEW_CONTENT_CLASS);
                this._$content.wrapInner($content)
            },
            _initTopPocket: function() {
                var $topPocket = this._$topPocket = $("<div>").addClass(SCROLLVIEW_TOP_POCKET_CLASS),
                    $pullDown = this._$pullDown = $("<div>").addClass(SCROLLVIEW_PULLDOWN_CLASS);
                $topPocket.append($pullDown);
                this._$content.prepend($topPocket)
            },
            _initBottomPocket: function() {
                var $bottomPocket = this._$bottomPocket = $("<div>").addClass(SCROLLVIEW_BOTTOM_POCKET_CLASS),
                    $reachBottom = this._$reachBottom = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_CLASS),
                    $loadContainer = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS),
                    $loadIndicator = $("<div>").dxLoadIndicator(),
                    $text = this._$reachBottomText = $("<div>").addClass(SCROLLVIEW_REACHBOTTOM_TEXT_CLASS);
                this._updateReachBottomText();
                $reachBottom.append($loadContainer.append($loadIndicator)).append($text);
                $bottomPocket.append($reachBottom);
                this._$content.append($bottomPocket)
            },
            _initLoadPanel: function() {
                this._loadPanel = this._createComponent($("<div>").addClass(SCROLLVIEW_LOADPANEL).appendTo(this.element()), "dxLoadPanel", {
                    shading: false,
                    delay: 400,
                    message: this.option("refreshingText"),
                    position: {of: this.element()}
                })
            },
            _updateReachBottomText: function() {
                this._$reachBottomText.text(this.option("reachBottomText"))
            },
            _createStrategy: function() {
                var strategyName = this.option("useNative") ? this.option("refreshStrategy") : "simulated";
                var strategyClass = ui.dxScrollView.refreshStrategies[strategyName];
                if (!strategyClass)
                    throw Error("E1030", this.option("refreshStrategy"));
                this._strategy = new strategyClass(this);
                this._strategy.pullDownCallbacks.add($.proxy(this._pullDownHandler, this));
                this._strategy.releaseCallbacks.add($.proxy(this._releaseHandler, this));
                this._strategy.reachBottomCallbacks.add($.proxy(this._reachBottomHandler, this))
            },
            _createActions: function() {
                this.callBase();
                this._pullDownAction = this._createActionByOption("onPullDown");
                this._reachBottomAction = this._createActionByOption("onReachBottom");
                this._pullDownEnable(!!this.option("onPullDown") && !DX.designMode);
                this._reachBottomEnable(!!this.option("onReachBottom") && !DX.designMode)
            },
            _pullDownEnable: function(enabled) {
                if (arguments.length === 0)
                    return this._pullDownEnabled;
                this._$pullDown.toggle(enabled);
                this._strategy.pullDownEnable(enabled);
                this._pullDownEnabled = enabled
            },
            _reachBottomEnable: function(enabled) {
                if (arguments.length === 0)
                    return this._reachBottomEnabled;
                this._$reachBottom.toggle(enabled);
                this._strategy.reachBottomEnable(enabled);
                this._reachBottomEnabled = enabled
            },
            _pullDownHandler: function() {
                this._loadingIndicator(false);
                this._pullDownLoading()
            },
            _loadingIndicator: function(value) {
                if (arguments.length < 1)
                    return this._loadingIndicatorEnabled;
                this._loadingIndicatorEnabled = value
            },
            _pullDownLoading: function() {
                this.startLoading();
                this._pullDownAction()
            },
            _reachBottomHandler: function() {
                this._loadingIndicator(false);
                this._reachBottomLoading()
            },
            _reachBottomLoading: function() {
                this.startLoading();
                this._reachBottomAction()
            },
            _releaseHandler: function() {
                this.finishLoading();
                this._loadingIndicator(true)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"onPullDown":
                    case"onReachBottom":
                        this._createActions();
                        break;
                    case"pullingDownText":
                    case"pulledDownText":
                    case"refreshingText":
                    case"refreshStrategy":
                        this._invalidate();
                        break;
                    case"reachBottomText":
                        this._updateReachBottomText();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            isEmpty: function() {
                return !this.content().children().length
            },
            content: function() {
                return this._$content.children().eq(1)
            },
            release: function(preventReachBottom) {
                if (preventReachBottom !== undefined)
                    this.toggleLoading(!preventReachBottom);
                return this._strategy.release()
            },
            toggleLoading: function(showOrHide) {
                this._reachBottomEnable(showOrHide)
            },
            isFull: function() {
                return this.content().height() > this._$container.height()
            },
            refresh: function() {
                if (!this.option("onPullDown"))
                    return;
                this._strategy.pendingRelease();
                this._pullDownLoading()
            },
            startLoading: function() {
                if (this._loadingIndicator() && this.element().is(":visible"))
                    this._loadPanel.show();
                this._lock()
            },
            finishLoading: function() {
                this._loadPanel.hide();
                this._unlock()
            },
            _dispose: function() {
                this._strategy.dispose();
                this.callBase();
                if (this._loadPanel)
                    this._loadPanel.element().remove()
            }
        }));
        ui.dxScrollView.refreshStrategies = {}
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollView.native.pullDown.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.require("/utils/utils.translator");
        var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-loading",
            SCROLLVIEW_PULLDOWN_READY_CLASS = "dx-scrollview-pull-down-ready",
            SCROLLVIEW_PULLDOWN_IMAGE_CLASS = "dx-scrollview-pull-down-image",
            SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator",
            SCROLLVIEW_PULLDOWN_TEXT_CLASS = "dx-scrollview-pull-down-text",
            STATE_RELEASED = 0,
            STATE_READY = 1,
            STATE_REFRESHING = 2,
            STATE_LOADING = 3;
        var PullDownNativeScrollViewStrategy = ui.dxScrollable.NativeStrategy.inherit({
                _init: function(scrollView) {
                    this.callBase(scrollView);
                    this._$topPocket = scrollView._$topPocket;
                    this._$pullDown = scrollView._$pullDown;
                    this._$bottomPocket = scrollView._$bottomPocket;
                    this._$refreshingText = scrollView._$refreshingText;
                    this._$scrollViewContent = scrollView.content();
                    this._initCallbacks()
                },
                _initCallbacks: function() {
                    this.pullDownCallbacks = $.Callbacks();
                    this.releaseCallbacks = $.Callbacks();
                    this.reachBottomCallbacks = $.Callbacks()
                },
                render: function() {
                    this.callBase();
                    this._renderPullDown();
                    this._releaseState()
                },
                _renderPullDown: function() {
                    var $image = $("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS),
                        $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS),
                        $loadIndicator = $("<div>").dxLoadIndicator(),
                        $text = this._$pullDownText = $("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
                    this._$pullingDownText = $("<div>").text(this.option("pullingDownText")).appendTo($text);
                    this._$pulledDownText = $("<div>").text(this.option("pulledDownText")).appendTo($text);
                    this._$refreshingText = $("<div>").text(this.option("refreshingText")).appendTo($text);
                    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text)
                },
                _releaseState: function() {
                    this._state = STATE_RELEASED;
                    this._refreshPullDownText()
                },
                _pushBackFromBoundary: function() {
                    if (!this._isLocked() && !this._component.isEmpty())
                        this.callBase()
                },
                _refreshPullDownText: function() {
                    this._$pullingDownText.css("opacity", this._state === STATE_RELEASED ? 1 : 0);
                    this._$pulledDownText.css("opacity", this._state === STATE_READY ? 1 : 0);
                    this._$refreshingText.css("opacity", this._state === STATE_REFRESHING ? 1 : 0)
                },
                update: function() {
                    this.callBase();
                    this._setTopPocketOffset()
                },
                _updateDimensions: function() {
                    this.callBase();
                    this._topPocketSize = this._$topPocket.height();
                    this._bottomPocketSize = this._$bottomPocket.height();
                    this._scrollOffset = this._$container.height() - this._$content.height()
                },
                _allowedDirections: function() {
                    var allowedDirections = this.callBase();
                    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
                    return allowedDirections
                },
                _setTopPocketOffset: function() {
                    this._$topPocket.css({top: -this._topPocketSize})
                },
                handleEnd: function() {
                    this.callBase();
                    this._complete()
                },
                handleStop: function() {
                    this.callBase();
                    this._complete()
                },
                _complete: function() {
                    if (this._state === STATE_READY) {
                        this._setPullDownOffset(this._topPocketSize);
                        clearTimeout(this._pullDownRefreshTimeout);
                        this._pullDownRefreshTimeout = setTimeout($.proxy(function() {
                            this._pullDownRefreshing()
                        }, this), 400)
                    }
                },
                _setPullDownOffset: function(offset) {
                    translator.move(this._$topPocket, {top: offset});
                    translator.move(this._$scrollViewContent, {top: offset})
                },
                handleScroll: function(e) {
                    this.callBase(e);
                    if (this._state === STATE_REFRESHING)
                        return;
                    this._location = this.location().top;
                    if (this._isPullDown())
                        this._pullDownReady();
                    else if (this._isReachBottom())
                        this._reachBottom();
                    else
                        this._stateReleased()
                },
                _isPullDown: function() {
                    return this._pullDownEnabled && this._location >= this._topPocketSize
                },
                _isReachBottom: function() {
                    return this._reachBottomEnabled && this._location <= this._scrollOffset + this._bottomPocketSize
                },
                _reachBottom: function() {
                    if (this._state === STATE_LOADING)
                        return;
                    this._state = STATE_LOADING;
                    this.reachBottomCallbacks.fire()
                },
                _pullDownReady: function() {
                    if (this._state === STATE_READY)
                        return;
                    this._state = STATE_READY;
                    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
                    this._refreshPullDownText()
                },
                _stateReleased: function() {
                    if (this._state === STATE_RELEASED)
                        return;
                    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
                    this._releaseState()
                },
                _pullDownRefreshing: function() {
                    if (this._state === STATE_REFRESHING)
                        return;
                    this._state = STATE_REFRESHING;
                    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
                    this._refreshPullDownText();
                    this.pullDownCallbacks.fire()
                },
                pullDownEnable: function(enabled) {
                    this._pullDownEnabled = enabled
                },
                reachBottomEnable: function(enabled) {
                    this._reachBottomEnabled = enabled
                },
                pendingRelease: function() {
                    this._state = STATE_READY
                },
                release: function() {
                    var deferred = $.Deferred();
                    this._updateDimensions();
                    clearTimeout(this._releaseTimeout);
                    this._releaseTimeout = setTimeout($.proxy(function() {
                        this._setPullDownOffset(0);
                        this._stateReleased();
                        this.releaseCallbacks.fire();
                        this._updateAction();
                        deferred.resolve()
                    }, this), 400);
                    return deferred.promise()
                },
                dispose: function() {
                    clearTimeout(this._pullDownRefreshTimeout);
                    clearTimeout(this._releaseTimeout);
                    this.callBase()
                }
            });
        ui.dxScrollView.refreshStrategies.pullDown = PullDownNativeScrollViewStrategy
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollView.native.swipeDown.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.require("/utils/utils.translator"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS = "dx-scrollview-pull-down-loading",
            SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator",
            SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-refreshing",
            PULLDOWN_ICON_CLASS = "dx-icon-pulldown",
            STATE_RELEASED = 0,
            STATE_READY = 1,
            STATE_REFRESHING = 2,
            STATE_TOUCHED = 4,
            STATE_PULLED = 5;
        var SwipeDownNativeScrollViewStrategy = ui.dxScrollable.NativeStrategy.inherit({
                _init: function(scrollView) {
                    this.callBase(scrollView);
                    this._$topPocket = scrollView._$topPocket;
                    this._$bottomPocket = scrollView._$bottomPocket;
                    this._$pullDown = scrollView._$pullDown;
                    this._$scrollViewContent = scrollView.content();
                    this._initCallbacks();
                    this._location = 0
                },
                _initCallbacks: function() {
                    this.pullDownCallbacks = $.Callbacks();
                    this.releaseCallbacks = $.Callbacks();
                    this.reachBottomCallbacks = $.Callbacks()
                },
                render: function() {
                    this.callBase();
                    this._renderPullDown();
                    this._releaseState()
                },
                _renderPullDown: function() {
                    var $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS),
                        $loadIndicator = $("<div>").dxLoadIndicator({});
                    this._$icon = $("<div>").addClass(PULLDOWN_ICON_CLASS);
                    this._$pullDown.empty().append(this._$icon).append($loadContainer.append($loadIndicator))
                },
                _releaseState: function() {
                    this._state = STATE_RELEASED;
                    this._releasePullDown();
                    this._updateDimensions()
                },
                _releasePullDown: function() {
                    this._$pullDown.css({opacity: 0})
                },
                _updateDimensions: function() {
                    this.callBase();
                    this._topPocketSize = this._$topPocket.height();
                    this._bottomPocketSize = this._$bottomPocket.height();
                    this._scrollOffset = this._$container.height() - this._$content.height()
                },
                _allowedDirections: function() {
                    var allowedDirections = this.callBase();
                    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
                    return allowedDirections
                },
                handleInit: function(e) {
                    this.callBase(e);
                    if (this._state === STATE_RELEASED && this._location === 0) {
                        this._startClientY = eventUtils.eventData(e.originalEvent).y;
                        this._state = STATE_TOUCHED
                    }
                },
                handleMove: function(e) {
                    this.callBase(e);
                    this._deltaY = eventUtils.eventData(e.originalEvent).y - this._startClientY;
                    if (this._state === STATE_TOUCHED)
                        if (this._pullDownEnabled && this._deltaY > 0)
                            this._state = STATE_PULLED;
                        else
                            this._complete();
                    if (this._state === STATE_PULLED) {
                        e.preventDefault();
                        this._movePullDown()
                    }
                },
                _movePullDown: function() {
                    var pullDownHeight = this._getPullDownHeight(),
                        top = Math.min(pullDownHeight * 3, this._deltaY + this._getPullDownStartPosition()),
                        angle = 180 * top / pullDownHeight / 3;
                    this._$pullDown.css({opacity: 1}).toggleClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS, top < pullDownHeight);
                    translator.move(this._$pullDown, {top: top});
                    this._$icon.css({transform: "rotate(" + angle + "deg)"})
                },
                _isPullDown: function() {
                    return this._pullDownEnabled && this._state === STATE_PULLED && this._deltaY >= this._getPullDownHeight() - this._getPullDownStartPosition()
                },
                _getPullDownHeight: function() {
                    return Math.round(this._$element.outerHeight() * 0.05)
                },
                _getPullDownStartPosition: function() {
                    return -Math.round(this._$pullDown.outerHeight() * 1.5)
                },
                handleEnd: function() {
                    if (this._isPullDown())
                        this._pullDownRefreshing();
                    this._complete()
                },
                handleStop: function() {
                    this._complete()
                },
                _complete: function() {
                    if (this._state === STATE_TOUCHED || this._state === STATE_PULLED)
                        this._releaseState()
                },
                handleScroll: function(e) {
                    this.callBase(e);
                    if (this._state === STATE_REFRESHING)
                        return;
                    var currentLocation = this.location().top,
                        scrollDelta = this._location - currentLocation;
                    this._location = currentLocation;
                    if (scrollDelta > 0 && this._isReachBottom())
                        this._reachBottom();
                    else
                        this._stateReleased()
                },
                _isReachBottom: function() {
                    return this._reachBottomEnabled && this._location <= this._scrollOffset + this._bottomPocketSize
                },
                _reachBottom: function() {
                    this.reachBottomCallbacks.fire()
                },
                _stateReleased: function() {
                    if (this._state === STATE_RELEASED)
                        return;
                    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
                    this._releaseState()
                },
                _pullDownRefreshing: function() {
                    this._state = STATE_REFRESHING;
                    this._pullDownRefreshHandler()
                },
                _pullDownRefreshHandler: function() {
                    this._refreshPullDown();
                    this.pullDownCallbacks.fire()
                },
                _refreshPullDown: function() {
                    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
                    translator.move(this._$pullDown, {top: this._getPullDownHeight()})
                },
                pullDownEnable: function(enabled) {
                    this._$topPocket.toggle(enabled);
                    this._pullDownEnabled = enabled
                },
                reachBottomEnable: function(enabled) {
                    this._reachBottomEnabled = enabled
                },
                pendingRelease: function() {
                    this._state = STATE_READY
                },
                release: function() {
                    var deferred = $.Deferred();
                    this._updateDimensions();
                    clearTimeout(this._releaseTimeout);
                    this._releaseTimeout = setTimeout($.proxy(function() {
                        this._stateReleased();
                        this.releaseCallbacks.fire();
                        this._updateAction();
                        deferred.resolve()
                    }, this), 800);
                    return deferred.promise()
                },
                dispose: function() {
                    clearTimeout(this._pullDownRefreshTimeout);
                    clearTimeout(this._releaseTimeout);
                    this.callBase()
                }
            });
        ui.dxScrollView.refreshStrategies.swipeDown = SwipeDownNativeScrollViewStrategy
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollView.native.slideDown.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var STATE_RELEASED = 0,
            STATE_READY = 1,
            STATE_LOADING = 2,
            LOADING_HEIGHT = 80;
        var SlideDownNativeScrollViewStrategy = ui.dxScrollable.NativeStrategy.inherit({
                _init: function(scrollView) {
                    this.callBase(scrollView);
                    this._$topPocket = scrollView._$topPocket;
                    this._$bottomPocket = scrollView._$bottomPocket;
                    this._initCallbacks()
                },
                _initCallbacks: function() {
                    this.pullDownCallbacks = $.Callbacks();
                    this.releaseCallbacks = $.Callbacks();
                    this.reachBottomCallbacks = $.Callbacks()
                },
                render: function() {
                    this.callBase();
                    this._renderPullDown();
                    this._renderBottom();
                    this._releaseState();
                    this._updateDimensions()
                },
                _renderPullDown: function() {
                    this._$topPocket.empty()
                },
                _renderBottom: function() {
                    this._$bottomPocket.empty().append("<progress>")
                },
                _releaseState: function() {
                    if (this._state === STATE_RELEASED)
                        return;
                    this._state = STATE_RELEASED
                },
                _updateDimensions: function() {
                    this._scrollOffset = this._$container.prop("scrollHeight") - this._$container.prop("clientHeight");
                    this._containerSize = {
                        height: this._$container.prop("clientHeight"),
                        width: this._$container.prop("clientWidth")
                    };
                    this._contentSize = this._componentContentSize = {
                        height: this._$container.prop("scrollHeight"),
                        width: this._$container.prop("scrollWidth")
                    }
                },
                handleScroll: function(e) {
                    this.callBase(e);
                    if (this._isReachBottom(this._lastLocation.top))
                        this._reachBottom()
                },
                _isReachBottom: function(location) {
                    this._scrollContent = this._$container.prop("scrollHeight") - this._$container.prop("clientHeight");
                    return this._reachBottomEnabled && location < -this._scrollContent + LOADING_HEIGHT
                },
                _reachBottom: function() {
                    if (this._state === STATE_LOADING)
                        return;
                    this._state = STATE_LOADING;
                    this.reachBottomCallbacks.fire()
                },
                pullDownEnable: function(enabled) {
                    this._pullDownEnabled = enabled
                },
                reachBottomEnable: function(enabled) {
                    this._reachBottomEnabled = enabled;
                    this._$bottomPocket.toggle(enabled)
                },
                pendingRelease: function() {
                    this._state = STATE_READY
                },
                release: function() {
                    var deferred = $.Deferred();
                    this._state = STATE_RELEASED;
                    this.releaseCallbacks.fire();
                    this.update();
                    return deferred.resolve().promise()
                }
            });
        ui.dxScrollView.refreshStrategies.slideDown = SlideDownNativeScrollViewStrategy
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.scrollView.simulated.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            commonUtils = DX.require("/utils/utils.common"),
            math = Math;
        var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-loading",
            SCROLLVIEW_PULLDOWN_READY_CLASS = "dx-scrollview-pull-down-ready",
            SCROLLVIEW_PULLDOWN_IMAGE_CLASS = "dx-scrollview-pull-down-image",
            SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator",
            SCROLLVIEW_PULLDOWN_TEXT_CLASS = "dx-scrollview-pull-down-text",
            STATE_RELEASED = 0,
            STATE_READY = 1,
            STATE_REFRESHING = 2,
            STATE_LOADING = 3;
        var ScrollViewScroller = ui.dxScrollView.Scroller = ui.dxScrollable.Scroller.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    this._initCallbacks();
                    this._releaseState()
                },
                _releaseState: function() {
                    this._state = STATE_RELEASED;
                    this._refreshPullDownText()
                },
                _refreshPullDownText: function() {
                    this._$pullingDownText.css("opacity", this._state === STATE_RELEASED ? 1 : 0);
                    this._$pulledDownText.css("opacity", this._state === STATE_READY ? 1 : 0);
                    this._$refreshingText.css("opacity", this._state === STATE_REFRESHING ? 1 : 0)
                },
                _initCallbacks: function() {
                    this.pullDownCallbacks = $.Callbacks();
                    this.releaseCallbacks = $.Callbacks();
                    this.reachBottomCallbacks = $.Callbacks()
                },
                _updateBounds: function() {
                    var considerPockets = this._direction !== "horizontal";
                    this._topPocketSize = considerPockets ? this._$topPocket[this._dimension]() : 0;
                    this._bottomPocketSize = considerPockets ? this._$bottomPocket[this._dimension]() : 0;
                    this.callBase();
                    this._bottomBound = this._minOffset + this._bottomPocketSize
                },
                _updateScrollbar: function() {
                    this._scrollbar.option({
                        containerSize: this._containerSize(),
                        contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize
                    })
                },
                _moveContent: function() {
                    this.callBase();
                    if (this._isPullDown())
                        this._pullDownReady();
                    else if (this._isReachBottom())
                        this._reachBottomReady();
                    else if (this._state !== STATE_RELEASED)
                        this._stateReleased()
                },
                _moveScrollbar: function() {
                    this._scrollbar.moveTo(this._topPocketSize + this._location)
                },
                _isPullDown: function() {
                    return this._pullDownEnabled && this._location >= 0
                },
                _isReachBottom: function() {
                    return this._reachBottomEnabled && this._location <= this._bottomBound
                },
                _scrollComplete: function() {
                    if (this._inBounds() && this._state === STATE_READY)
                        this._pullDownRefreshing();
                    else if (this._inBounds() && this._state === STATE_LOADING)
                        this._reachBottomLoading();
                    else
                        this.callBase()
                },
                _reachBottomReady: function() {
                    if (this._state === STATE_LOADING)
                        return;
                    this._state = STATE_LOADING;
                    this._minOffset = this._getMinOffset()
                },
                _getMaxOffset: function() {
                    return -this._topPocketSize
                },
                _getMinOffset: function() {
                    return math.min(this.callBase(), -this._topPocketSize)
                },
                _reachBottomLoading: function() {
                    this.reachBottomCallbacks.fire()
                },
                _pullDownReady: function() {
                    if (this._state === STATE_READY)
                        return;
                    this._state = STATE_READY;
                    this._maxOffset = 0;
                    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
                    this._refreshPullDownText()
                },
                _stateReleased: function() {
                    if (this._state === STATE_RELEASED)
                        return;
                    this._releaseState();
                    this._updateBounds();
                    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
                    this.releaseCallbacks.fire()
                },
                _pullDownRefreshing: function() {
                    if (this._state === STATE_REFRESHING)
                        return;
                    this._state = STATE_REFRESHING;
                    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
                    this._refreshPullDownText();
                    this.pullDownCallbacks.fire()
                },
                _releaseHandler: function() {
                    if (this._state === STATE_RELEASED)
                        this._moveToBounds();
                    this._update();
                    if (this._releaseTask)
                        this._releaseTask.abort();
                    this._releaseTask = commonUtils.executeAsync($.proxy(this._release, this));
                    return this._releaseTask.promise
                },
                _release: function() {
                    this._stateReleased();
                    this._scrollComplete()
                },
                _reachBottomEnablingHandler: function(enabled) {
                    if (this._reachBottomEnabled === enabled)
                        return;
                    this._reachBottomEnabled = enabled;
                    this._updateBounds()
                },
                _pullDownEnablingHandler: function(enabled) {
                    if (this._pullDownEnabled === enabled)
                        return;
                    this._pullDownEnabled = enabled;
                    this._considerTopPocketChange();
                    this._updateHandler()
                },
                _considerTopPocketChange: function() {
                    this._location -= this._$topPocket.height() || -this._topPocketSize;
                    this._move()
                },
                _pendingReleaseHandler: function() {
                    this._state = STATE_READY
                },
                dispose: function() {
                    if (this._releaseTask)
                        this._releaseTask.abort();
                    this.callBase()
                }
            });
        var SimulatedScrollViewStrategy = ui.dxScrollable.SimulatedStrategy.inherit({
                _init: function(scrollView) {
                    this.callBase(scrollView);
                    this._$pullDown = scrollView._$pullDown;
                    this._$topPocket = scrollView._$topPocket;
                    this._$bottomPocket = scrollView._$bottomPocket;
                    this._initCallbacks()
                },
                _initCallbacks: function() {
                    this.pullDownCallbacks = $.Callbacks();
                    this.releaseCallbacks = $.Callbacks();
                    this.reachBottomCallbacks = $.Callbacks()
                },
                render: function() {
                    this._renderPullDown();
                    this.callBase()
                },
                _renderPullDown: function() {
                    var $image = $("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS),
                        $loadContainer = $("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS),
                        $loadIndicator = $("<div>").dxLoadIndicator(),
                        $text = this._$pullDownText = $("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
                    this._$pullingDownText = $("<div>").text(this.option("pullingDownText")).appendTo($text);
                    this._$pulledDownText = $("<div>").text(this.option("pulledDownText")).appendTo($text);
                    this._$refreshingText = $("<div>").text(this.option("refreshingText")).appendTo($text);
                    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text)
                },
                pullDownEnable: function(enabled) {
                    this._eventHandler("pullDownEnabling", enabled)
                },
                reachBottomEnable: function(enabled) {
                    this._eventHandler("reachBottomEnabling", enabled)
                },
                _createScroller: function(direction) {
                    var that = this;
                    var scroller = that._scrollers[direction] = new ScrollViewScroller(that._scrollerOptions(direction));
                    scroller.pullDownCallbacks.add(function() {
                        that.pullDownCallbacks.fire()
                    });
                    scroller.releaseCallbacks.add(function() {
                        that.releaseCallbacks.fire()
                    });
                    scroller.reachBottomCallbacks.add(function() {
                        that.reachBottomCallbacks.fire()
                    })
                },
                _scrollerOptions: function(direction) {
                    return $.extend(this.callBase(direction), {
                            $topPocket: this._$topPocket,
                            $bottomPocket: this._$bottomPocket,
                            $pullDown: this._$pullDown,
                            $pullDownText: this._$pullDownText,
                            $pullingDownText: this._$pullingDownText,
                            $pulledDownText: this._$pulledDownText,
                            $refreshingText: this._$refreshingText
                        })
                },
                pendingRelease: function() {
                    this._eventHandler("pendingRelease")
                },
                release: function() {
                    return this._eventHandler("release").done(this._updateAction)
                },
                location: function() {
                    var location = this.callBase();
                    location.top += this._$topPocket.height();
                    return location
                },
                dispose: function() {
                    $.each(this._scrollers, function() {
                        this.dispose()
                    });
                    this.callBase()
                }
            });
        ui.dxScrollView.refreshStrategies.simulated = SimulatedScrollViewStrategy
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.map.provider.js */
    DevExpress.define("/ui/widgets/map/ui.map.provider", ["jquery", "/class", "/ui/events/ui.events.utils"], function($, Class, eventUtils) {
        var abstract = Class.abstract;
        var Provider = Class.inherit({
                _defaultRouteWeight: function() {
                    return 5
                },
                _defaultRouteOpacity: function() {
                    return 0.5
                },
                _defaultRouteColor: function() {
                    return "#0000FF"
                },
                cancelEvents: false,
                ctor: function(map, $container) {
                    this._mapWidget = map;
                    this._$container = $container
                },
                render: function(markerOptions, routeOptions) {
                    var deferred = $.Deferred();
                    this._renderImpl().done($.proxy(function() {
                        var markersPromise = this.addMarkers(markerOptions);
                        var routesPromise = this.addRoutes(routeOptions);
                        $.when(markersPromise, routesPromise).done(function() {
                            deferred.resolve(true)
                        })
                    }, this));
                    return deferred.promise()
                },
                _renderImpl: abstract,
                updateDimensions: abstract,
                updateMapType: abstract,
                updateBounds: abstract,
                updateCenter: abstract,
                updateZoom: abstract,
                updateControls: abstract,
                updateMarkers: function(markerOptionsToRemove, markerOptionsToAdd) {
                    var deferred = $.Deferred(),
                        that = this;
                    this.removeMarkers(markerOptionsToRemove).done(function() {
                        that.addMarkers(markerOptionsToAdd).done(function() {
                            deferred.resolve.apply(deferred, arguments)
                        })
                    });
                    return deferred.promise()
                },
                addMarkers: abstract,
                removeMarkers: abstract,
                adjustViewport: abstract,
                updateRoutes: function(routeOptionsToRemove, routeOptionsToAdd) {
                    var deferred = $.Deferred(),
                        that = this;
                    this.removeRoutes(routeOptionsToRemove).done(function() {
                        that.addRoutes(routeOptionsToAdd).done(function() {
                            deferred.resolve.apply(deferred, arguments)
                        })
                    });
                    return deferred.promise()
                },
                addRoutes: abstract,
                removeRoutes: abstract,
                clean: abstract,
                map: function() {
                    return this._map
                },
                _option: function(name, value) {
                    if (value === undefined)
                        return this._mapWidget.option(name);
                    this._mapWidget.setOptionSilent(name, value)
                },
                _keyOption: function(providerName) {
                    var key = this._option("key");
                    return key[providerName] === undefined ? key : key[providerName]
                },
                _parseTooltipOptions: function(option) {
                    return {
                            text: option.text || option,
                            visible: option.isShown || false
                        }
                },
                _getLatLng: function(location) {
                    if (typeof location === "string") {
                        var coords = $.map(location.split(","), $.trim),
                            numericRegex = /[-+]?[0-9]*\.?[0-9]*/;
                        if (coords.length === 2 && coords[0].match(numericRegex) && coords[1].match(numericRegex))
                            return {
                                    lat: parseFloat(coords[0]),
                                    lng: parseFloat(coords[1])
                                }
                    }
                    else if ($.isArray(location) && location.length === 2)
                        return {
                                lat: location[0],
                                lng: location[1]
                            };
                    else if ($.isPlainObject(location) && $.isNumeric(location.lat) && $.isNumeric(location.lng))
                        return location;
                    return null
                },
                _isBoundsSetted: function() {
                    return this._option("bounds.northEast") && this._option("bounds.southWest")
                },
                _addEventNamespace: function(name) {
                    return eventUtils.addNamespace(name, this._mapWidget.NAME)
                },
                _createAction: function() {
                    var mapWidget = this._mapWidget;
                    return mapWidget._createAction.apply(mapWidget, arguments)
                },
                _fireAction: function(name, actionArguments) {
                    var option = this._option(name);
                    if (option)
                        this._createAction(option)(actionArguments)
                },
                _fireClickAction: function(actionArguments) {
                    this._fireAction("onClick", actionArguments)
                },
                _fireMarkerAddedAction: function(actionArguments) {
                    this._fireAction("onMarkerAdded", actionArguments)
                },
                _fireMarkerRemovedAction: function(actionArguments) {
                    this._fireAction("onMarkerRemoved", actionArguments)
                },
                _fireRouteAddedAction: function(actionArguments) {
                    this._fireAction("onRouteAdded", actionArguments)
                },
                _fireRouteRemovedAction: function(actionArguments) {
                    this._fireAction("onRouteRemoved", actionArguments)
                }
            });
        return Provider
    });
    /*! Module widgets-base, file ui.map.provider.googleStatic.js */
    DevExpress.define("/ui/widgets/map/ui.map.provider.googleStatic", ["jquery", "/ui/widgets/map/ui.map.provider", "/color"], function($, Provider, Color) {
        var GOOGLE_STATIC_URL = "https://maps.google.com/maps/api/staticmap?";
        var GoogleStaticPrivider = Provider.inherit({
                _locationToString: function(location) {
                    var latlng = this._getLatLng(location);
                    return latlng ? latlng.lat + "," + latlng.lng : location.toString().replace(/ /g, "+")
                },
                _renderImpl: function() {
                    return this._updateMap()
                },
                updateDimensions: function() {
                    return this._updateMap()
                },
                updateMapType: function() {
                    return this._updateMap()
                },
                updateBounds: function() {
                    return $.Deferred().resolve().promise()
                },
                updateCenter: function() {
                    return this._updateMap()
                },
                updateZoom: function() {
                    return this._updateMap()
                },
                updateControls: function() {
                    return $.Deferred().resolve().promise()
                },
                addMarkers: function(options) {
                    var that = this;
                    return this._updateMap().done(function() {
                            $.each(options, function(_, options) {
                                that._fireMarkerAddedAction({options: options})
                            })
                        })
                },
                removeMarkers: function(options) {
                    var that = this;
                    return this._updateMap().done(function() {
                            $.each(options, function(_, options) {
                                that._fireMarkerRemovedAction({options: options})
                            })
                        })
                },
                adjustViewport: function() {
                    return $.Deferred().resolve().promise()
                },
                addRoutes: function(options) {
                    var that = this;
                    return this._updateMap().done(function() {
                            $.each(options, function(_, options) {
                                that._fireRouteAddedAction({options: options})
                            })
                        })
                },
                removeRoutes: function(options) {
                    var that = this;
                    return this._updateMap().done(function() {
                            $.each(options, function(_, options) {
                                that._fireRouteRemovedAction({options: options})
                            })
                        })
                },
                clean: function() {
                    this._$container.css("background-image", "none");
                    this._$container.off(this._addEventNamespace("dxclick"));
                    return $.Deferred().resolve().promise()
                },
                mapRendered: function() {
                    return true
                },
                _updateMap: function() {
                    var key = this._keyOption("googleStatic"),
                        $container = this._$container;
                    var requestOptions = ["sensor=false", "size=" + $container.width() + "x" + $container.height(), "maptype=" + this._option("type"), "center=" + this._locationToString(this._option("center")), "zoom=" + this._option("zoom"), this._markersSubstring()];
                    requestOptions.push.apply(requestOptions, this._routeSubstrings());
                    if (key)
                        requestOptions.push("key=" + key);
                    var request = GOOGLE_STATIC_URL + requestOptions.join("&");
                    this._$container.css("background", "url(\"" + request + "\") no-repeat 0 0");
                    this._attachClickEvent();
                    return $.Deferred().resolve(true).promise()
                },
                _markersSubstring: function() {
                    var that = this,
                        markers = [],
                        markerIcon = this._option("markerIconSrc");
                    if (markerIcon)
                        markers.push("icon:" + markerIcon);
                    $.each(this._option("markers"), function(_, marker) {
                        markers.push(that._locationToString(marker.location))
                    });
                    return "markers=" + markers.join("|")
                },
                _routeSubstrings: function() {
                    var that = this,
                        routes = [];
                    $.each(this._option("routes"), function(_, route) {
                        var color = new Color(route.color || that._defaultRouteColor()).toHex().replace('#', '0x'),
                            opacity = Math.round((route.opacity || that._defaultRouteOpacity()) * 255).toString(16),
                            width = route.weight || that._defaultRouteWeight(),
                            locations = [];
                        $.each(route.locations, function(_, routePoint) {
                            locations.push(that._locationToString(routePoint))
                        });
                        routes.push("path=color:" + color + opacity + "|weight:" + width + "|" + locations.join("|"))
                    });
                    return routes
                },
                _attachClickEvent: function() {
                    var that = this,
                        eventName = this._addEventNamespace("dxclick");
                    this._$container.off(eventName).on(eventName, function(e) {
                        that._fireClickAction({jQueryEvent: e})
                    })
                }
            });
        GoogleStaticPrivider.remapConstant = function(newValue) {
            GOOGLE_STATIC_URL = newValue
        };
        return GoogleStaticPrivider
    });
    /*! Module widgets-base, file ui.map.provider.dynamic.js */
    DevExpress.define("/ui/widgets/map/ui.map.provider.dynamic", ["jquery", "/ui/widgets/map/ui.map.provider"], function($, Provider) {
        var abstract = Provider.abstract;
        var DynamicProvider = Provider.inherit({
                cancelEvents: true,
                _renderImpl: function(markerOptions, routeOptions) {
                    var deferred = $.Deferred();
                    this._load().done($.proxy(function() {
                        this._init().done($.proxy(function() {
                            var mapTypePromise = this.updateMapType(),
                                boundsPromise = this._isBoundsSetted() ? this.updateBounds() : this.updateCenter();
                            $.when(mapTypePromise, boundsPromise).done($.proxy(function() {
                                this._attachHandlers();
                                setTimeout(function() {
                                    deferred.resolve()
                                })
                            }, this))
                        }, this))
                    }, this));
                    return deferred.promise()
                },
                _load: function() {
                    if (!this._mapsLoader) {
                        this._mapsLoader = $.Deferred();
                        this._loadImpl().done($.proxy(function() {
                            this._mapsLoader.resolve()
                        }, this))
                    }
                    this._markers = [];
                    this._routes = [];
                    return this._mapsLoader.promise()
                },
                _loadImpl: abstract,
                _init: abstract,
                _attachHandlers: abstract,
                addMarkers: function(options) {
                    var deferred = $.Deferred(),
                        that = this;
                    var markerPromises = $.map(options, function(options) {
                            return that._addMarker(options)
                        });
                    $.when.apply($, markerPromises).done(function() {
                        var instances = $.map($.makeArray(arguments), function(markerObject) {
                                return markerObject.marker
                            });
                        deferred.resolve(false, instances)
                    });
                    return deferred.promise()
                },
                _addMarker: function(options) {
                    var that = this;
                    return this._renderMarker(options).done(function(markerObject) {
                            that._markers.push($.extend({options: options}, markerObject));
                            that._fitBounds();
                            that._fireMarkerAddedAction({
                                options: options,
                                originalMarker: markerObject.marker
                            })
                        })
                },
                _renderMarker: abstract,
                removeMarkers: function(markersOptionsToRemove) {
                    var that = this;
                    $.each(markersOptionsToRemove, function(_, markerOptionToRemove) {
                        that._removeMarker(markerOptionToRemove)
                    });
                    return $.Deferred().resolve().promise()
                },
                _removeMarker: function(markersOptionToRemove) {
                    var that = this;
                    $.each(this._markers, function(markerIndex, markerObject) {
                        if (markerObject.options !== markersOptionToRemove)
                            return true;
                        that._destroyMarker(markerObject);
                        that._markers.splice(markerIndex, 1);
                        that._fireMarkerRemovedAction({options: markerObject.options});
                        return false
                    })
                },
                _destroyMarker: abstract,
                _clearMarkers: function() {
                    while (this._markers.length > 0)
                        this._removeMarker(this._markers[0].options)
                },
                addRoutes: function(options) {
                    var deferred = $.Deferred(),
                        that = this;
                    var routePromises = $.map(options, function(options) {
                            return that._addRoute(options)
                        });
                    $.when.apply($, routePromises).done(function() {
                        var instances = $.map($.makeArray(arguments), function(routeObject) {
                                return routeObject.instance
                            });
                        deferred.resolve(false, instances)
                    });
                    return deferred.promise()
                },
                _addRoute: function(options) {
                    var that = this;
                    return this._renderRoute(options).done(function(routeObject) {
                            that._routes.push($.extend({options: options}, routeObject));
                            that._fitBounds();
                            that._fireRouteAddedAction({
                                options: options,
                                originalRoute: routeObject.instance
                            })
                        })
                },
                _renderRoute: abstract,
                removeRoutes: function(options) {
                    var that = this;
                    $.each(options, function(routeIndex, options) {
                        that._removeRoute(options)
                    });
                    return $.Deferred().resolve().promise()
                },
                _removeRoute: function(options) {
                    var that = this;
                    $.each(this._routes, function(routeIndex, routeObject) {
                        if (routeObject.options !== options)
                            return true;
                        that._destroyRoute(routeObject);
                        that._routes.splice(routeIndex, 1);
                        that._fireRouteRemovedAction({options: options});
                        return false
                    })
                },
                _destroyRoute: abstract,
                _clearRoutes: function() {
                    while (this._routes.length > 0)
                        this._removeRoute(this._routes[0].options)
                },
                adjustViewport: function() {
                    return this._fitBounds()
                },
                _fitBounds: abstract,
                _updateBounds: function() {
                    var that = this;
                    this._clearBounds();
                    $.each(this._markers, function(_, markerObject) {
                        that._extendBounds(markerObject.location)
                    });
                    $.each(this._routes, function(_, routeObject) {
                        that._extendBounds(routeObject.northEast);
                        that._extendBounds(routeObject.southWest)
                    })
                },
                _clearBounds: function() {
                    this._bounds = null
                },
                _extendBounds: abstract
            });
        return DynamicProvider
    });
    /*! Module widgets-base, file ui.map.provider.dynamic.bing.js */
    DevExpress.define("/ui/widgets/map/ui.map.provider.dynamic.bing", ["jquery", "/ui/widgets/map/ui.map.provider.dynamic", "/color", "/utils/utils.support"], function($, DynamicProvider, Color, support) {
        var BING_MAP_READY = "_bingScriptReady",
            BING_URL = "https://ecn.dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=7.0&s=1&onScriptLoad=" + BING_MAP_READY,
            BING_LOCAL_FILES1 = "ms-appx:///Bing.Maps.JavaScript/js/veapicore.js",
            BING_LOCAL_FILES2 = "ms-appx:///Bing.Maps.JavaScript/js/veapiModules.js",
            BING_CREDENTIALS = "AhuxC0dQ1DBTNo8L-H9ToVMQStmizZzBJdraTSgCzDSWPsA1Qd8uIvFSflzxdaLH",
            MIN_LOCATION_RECT_LENGTH = 0.0000000000000001;
        var msMapsLoaded = function() {
                return window.Microsoft && window.Microsoft.Maps
            };
        var msMapsLoader;
        var BingProvider = DynamicProvider.inherit({
                _mapType: function(type) {
                    var mapTypes = {
                            roadmap: Microsoft.Maps.MapTypeId.road,
                            hybrid: Microsoft.Maps.MapTypeId.aerial,
                            satellite: Microsoft.Maps.MapTypeId.aerial
                        };
                    return mapTypes[type] || mapTypes.road
                },
                _movementMode: function(type) {
                    var movementTypes = {
                            driving: Microsoft.Maps.Directions.RouteMode.driving,
                            walking: Microsoft.Maps.Directions.RouteMode.walking
                        };
                    return movementTypes[type] || movementTypes.driving
                },
                _resolveLocation: function(location) {
                    var d = $.Deferred();
                    var latLng = this._getLatLng(location);
                    if (latLng)
                        d.resolve(new Microsoft.Maps.Location(latLng.lat, latLng.lng));
                    else {
                        var searchManager = new Microsoft.Maps.Search.SearchManager(this._map);
                        var searchRequest = {
                                where: location,
                                count: 1,
                                callback: function(searchResponse) {
                                    var boundsBox = searchResponse.results[0].location;
                                    d.resolve(new Microsoft.Maps.Location(boundsBox.latitude, boundsBox.longitude))
                                }
                            };
                        searchManager.geocode(searchRequest)
                    }
                    return d.promise()
                },
                _normalizeLocation: function(location) {
                    return {
                            lat: location.latitude,
                            lng: location.longitude
                        }
                },
                _normalizeLocationRect: function(locationRect) {
                    var northWest = this._normalizeLocation(locationRect.getNorthwest()),
                        southEast = this._normalizeLocation(locationRect.getSoutheast());
                    return {
                            northEast: {
                                lat: northWest.lat,
                                lng: southEast.lng
                            },
                            southWest: {
                                lat: southEast.lat,
                                lng: northWest.lng
                            }
                        }
                },
                _loadImpl: function() {
                    this._msMapsLoader = $.Deferred();
                    if (msMapsLoaded())
                        this._mapReady();
                    else {
                        if (!msMapsLoader || msMapsLoader.state() === "resolved" && !msMapsLoaded()) {
                            msMapsLoader = $.Deferred();
                            window[BING_MAP_READY] = $.proxy(msMapsLoader.resolve, msMapsLoader);
                            if (support.winJS)
                                $.when($.getScript(BING_LOCAL_FILES1), $.getScript(BING_LOCAL_FILES2)).done(function() {
                                    Microsoft.Maps.loadModule("Microsoft.Maps.Map", {callback: window[BING_MAP_READY]})
                                });
                            else
                                $.getScript(BING_URL)
                        }
                        msMapsLoader.done($.proxy(this._mapReady, this))
                    }
                    return this._msMapsLoader.promise()
                },
                _mapReady: function() {
                    try {
                        delete window[BING_MAP_READY]
                    }
                    catch(e) {
                        window[BING_MAP_READY] = undefined
                    }
                    var searchModulePromise = $.Deferred();
                    var directionsModulePromise = $.Deferred();
                    Microsoft.Maps.loadModule('Microsoft.Maps.Search', {callback: $.proxy(searchModulePromise.resolve, searchModulePromise)});
                    Microsoft.Maps.loadModule('Microsoft.Maps.Directions', {callback: $.proxy(directionsModulePromise.resolve, directionsModulePromise)});
                    $.when(searchModulePromise, directionsModulePromise).done($.proxy(function() {
                        this._msMapsLoader.resolve()
                    }, this))
                },
                _init: function() {
                    var deferred = $.Deferred(),
                        initPromise = $.Deferred(),
                        controls = this._option("controls");
                    this._map = new Microsoft.Maps.Map(this._$container[0], {
                        credentials: this._keyOption("bing") || BING_CREDENTIALS,
                        zoom: this._option("zoom"),
                        showDashboard: controls,
                        showMapTypeSelector: controls,
                        showScalebar: controls
                    });
                    var handler = Microsoft.Maps.Events.addHandler(this._map, 'tiledownloadcomplete', $.proxy(initPromise.resolve, initPromise));
                    $.when(initPromise).done($.proxy(function() {
                        Microsoft.Maps.Events.removeHandler(handler);
                        deferred.resolve()
                    }, this));
                    return deferred.promise()
                },
                _attachHandlers: function() {
                    this._providerViewChangeHandler = Microsoft.Maps.Events.addHandler(this._map, 'viewchange', $.proxy(this._viewChangeHandler, this));
                    this._providerClickHandler = Microsoft.Maps.Events.addHandler(this._map, 'click', $.proxy(this._clickActionHandler, this))
                },
                _viewChangeHandler: function() {
                    var bounds = this._map.getBounds();
                    this._option("bounds", this._normalizeLocationRect(bounds));
                    var center = this._map.getCenter();
                    this._option("center", this._normalizeLocation(center));
                    if (!this._preventZoomChangeEvent)
                        this._option("zoom", this._map.getZoom())
                },
                _clickActionHandler: function(e) {
                    if (e.targetType === "map") {
                        var point = new Microsoft.Maps.Point(e.getX(), e.getY()),
                            location = e.target.tryPixelToLocation(point);
                        this._fireClickAction({location: this._normalizeLocation(location)})
                    }
                },
                updateDimensions: function() {
                    var $container = this._$container;
                    this._map.setOptions({
                        width: $container.width(),
                        height: $container.height()
                    });
                    return $.Deferred().resolve().promise()
                },
                updateMapType: function() {
                    var type = this._option("type"),
                        labelOverlay = Microsoft.Maps.LabelOverlay;
                    this._map.setView({
                        animate: false,
                        mapTypeId: this._mapType(type),
                        labelOverlay: type === "satellite" ? labelOverlay.hidden : labelOverlay.visible
                    });
                    return $.Deferred().resolve().promise()
                },
                updateBounds: function() {
                    var deferred = $.Deferred(),
                        that = this;
                    var northEastPromise = this._resolveLocation(this._option("bounds.northEast")),
                        southWestPromise = this._resolveLocation(this._option("bounds.southWest"));
                    $.when(northEastPromise, southWestPromise).done(function(northEast, southWest) {
                        var bounds = new Microsoft.Maps.LocationRect.fromLocations(northEast, southWest);
                        that._map.setView({
                            animate: false,
                            bounds: bounds
                        });
                        deferred.resolve()
                    });
                    return deferred.promise()
                },
                updateCenter: function() {
                    var deferred = $.Deferred(),
                        that = this;
                    this._resolveLocation(this._option("center")).done(function(location) {
                        that._map.setView({
                            animate: false,
                            center: location
                        });
                        deferred.resolve()
                    });
                    return deferred.promise()
                },
                updateZoom: function() {
                    this._map.setView({
                        animate: false,
                        zoom: this._option("zoom")
                    });
                    return $.Deferred().resolve().promise()
                },
                updateControls: function() {
                    this.clean();
                    return this.render.apply(this, arguments)
                },
                _renderMarker: function(options) {
                    var d = $.Deferred(),
                        that = this;
                    this._resolveLocation(options.location).done(function(location) {
                        var pushpinOptions = {icon: options.iconSrc || that._option("markerIconSrc")};
                        if (options.html) {
                            $.extend(pushpinOptions, {
                                htmlContent: options.html,
                                width: null,
                                height: null
                            });
                            var htmlOffset = options.htmlOffset;
                            if (htmlOffset)
                                pushpinOptions.anchor = new Microsoft.Maps.Point(-htmlOffset.left, -htmlOffset.top)
                        }
                        var pushpin = new Microsoft.Maps.Pushpin(location, pushpinOptions);
                        that._map.entities.push(pushpin);
                        var infobox = that._renderTooltip(location, options.tooltip);
                        var handler;
                        if (options.onClick || options.tooltip) {
                            var markerClickAction = that._createAction(options.onClick || $.noop),
                                markerNormalizedLocation = that._normalizeLocation(location);
                            handler = Microsoft.Maps.Events.addHandler(pushpin, "click", function() {
                                markerClickAction({location: markerNormalizedLocation});
                                if (infobox)
                                    infobox.setOptions({visible: true})
                            })
                        }
                        d.resolve({
                            location: location,
                            marker: pushpin,
                            infobox: infobox,
                            handler: handler
                        })
                    });
                    return d.promise()
                },
                _renderTooltip: function(location, options) {
                    if (!options)
                        return;
                    options = this._parseTooltipOptions(options);
                    var infobox = new Microsoft.Maps.Infobox(location, {
                            description: options.text,
                            offset: new Microsoft.Maps.Point(0, 33),
                            visible: options.visible
                        });
                    this._map.entities.push(infobox, null);
                    return infobox
                },
                _destroyMarker: function(marker) {
                    this._map.entities.remove(marker.marker);
                    if (marker.infobox)
                        this._map.entities.remove(marker.infobox);
                    if (marker.handler)
                        Microsoft.Maps.Events.removeHandler(marker.handler)
                },
                _renderRoute: function(options) {
                    var d = $.Deferred(),
                        that = this;
                    var points = $.map(options.locations, function(point) {
                            return that._resolveLocation(point)
                        });
                    $.when.apply($, points).done(function() {
                        var locations = $.makeArray(arguments),
                            direction = new Microsoft.Maps.Directions.DirectionsManager(that._map),
                            color = new Color(options.color || that._defaultRouteColor()).toHex(),
                            routeColor = new Microsoft.Maps.Color.fromHex(color);
                        routeColor.a = (options.opacity || that._defaultRouteOpacity()) * 255;
                        direction.setRenderOptions({
                            autoUpdateMapView: false,
                            displayRouteSelector: false,
                            waypointPushpinOptions: {visible: false},
                            drivingPolylineOptions: {
                                strokeColor: routeColor,
                                strokeThickness: options.weight || that._defaultRouteWeight()
                            },
                            walkingPolylineOptions: {
                                strokeColor: routeColor,
                                strokeThickness: options.weight || that._defaultRouteWeight()
                            }
                        });
                        direction.setRequestOptions({
                            routeMode: that._movementMode(options.mode),
                            routeDraggable: false
                        });
                        $.each(locations, function(_, location) {
                            var waypoint = new Microsoft.Maps.Directions.Waypoint({location: location});
                            direction.addWaypoint(waypoint)
                        });
                        var handler = Microsoft.Maps.Events.addHandler(direction, 'directionsUpdated', function(args) {
                                Microsoft.Maps.Events.removeHandler(handler);
                                var routeSummary = args.routeSummary[0];
                                d.resolve({
                                    instance: direction,
                                    northEast: routeSummary.northEast,
                                    southWest: routeSummary.southWest
                                })
                            });
                        direction.calculateDirections()
                    });
                    return d.promise()
                },
                _destroyRoute: function(routeObject) {
                    routeObject.instance.dispose()
                },
                _fitBounds: function() {
                    this._updateBounds();
                    if (this._bounds && this._option("autoAdjust")) {
                        var zoomBeforeFitting = this._map.getZoom();
                        this._preventZoomChangeEvent = true;
                        var bounds = this._bounds.clone();
                        bounds.height = bounds.height * 1.1;
                        bounds.width = bounds.width * 1.1;
                        this._map.setView({
                            animate: false,
                            bounds: bounds,
                            zoom: zoomBeforeFitting
                        });
                        var zoomAfterFitting = this._map.getZoom();
                        if (zoomBeforeFitting < zoomAfterFitting)
                            this._map.setView({
                                animate: false,
                                zoom: zoomBeforeFitting
                            });
                        else
                            this._option("zoom", zoomAfterFitting);
                        delete this._preventZoomChangeEvent
                    }
                    return $.Deferred().resolve().promise()
                },
                _extendBounds: function(location) {
                    if (this._bounds)
                        this._bounds = new Microsoft.Maps.LocationRect.fromLocations(this._bounds.getNorthwest(), this._bounds.getSoutheast(), location);
                    else
                        this._bounds = new Microsoft.Maps.LocationRect(location, MIN_LOCATION_RECT_LENGTH, MIN_LOCATION_RECT_LENGTH)
                },
                clean: function() {
                    if (this._map) {
                        Microsoft.Maps.Events.removeHandler(this._providerViewChangeHandler);
                        Microsoft.Maps.Events.removeHandler(this._providerClickHandler);
                        this._clearMarkers();
                        this._clearRoutes();
                        this._map.dispose()
                    }
                    return $.Deferred().resolve().promise()
                }
            });
        BingProvider.remapConstant = function(newValue) {
            BING_URL = newValue
        };
        return BingProvider
    });
    /*! Module widgets-base, file ui.map.provider.dynamic.google.js */
    DevExpress.define("/ui/widgets/map/ui.map.provider.dynamic.google", ["jquery", "/ui/widgets/map/ui.map.provider.dynamic", "/color"], function($, DynamicProvider, Color) {
        var GOOGLE_MAP_READY = "_googleScriptReady",
            GOOGLE_URL = "https://maps.google.com/maps/api/js?sensor=false&callback=" + GOOGLE_MAP_READY;
        var CustomMarker;
        var initCustomMarkerClass = function() {
                CustomMarker = function(options) {
                    this._position = options.position;
                    this._offset = options.offset;
                    this._$overlayContainer = $("<div>").css({
                        position: "absolute",
                        display: "none",
                        cursor: "pointer"
                    }).append(options.html);
                    this.setMap(options.map)
                };
                CustomMarker.prototype = new google.maps.OverlayView;
                CustomMarker.prototype.onAdd = function() {
                    var $pane = $(this.getPanes().overlayMouseTarget);
                    $pane.append(this._$overlayContainer);
                    this._clickListner = google.maps.event.addDomListener(this._$overlayContainer.get(0), 'click', $.proxy(function(e) {
                        google.maps.event.trigger(this, 'click');
                        e.preventDefault()
                    }, this));
                    this.draw()
                };
                CustomMarker.prototype.onRemove = function() {
                    google.maps.event.removeListener(this._clickListner);
                    this._$overlayContainer.remove()
                };
                CustomMarker.prototype.draw = function() {
                    var position = this.getProjection().fromLatLngToDivPixel(this._position);
                    this._$overlayContainer.css({
                        left: position.x + this._offset.left,
                        top: position.y + this._offset.top,
                        display: 'block'
                    })
                }
            };
        var googleMapsLoaded = function() {
                return window.google && window.google.maps
            };
        var googleMapsLoader;
        var GoogleProvider = DynamicProvider.inherit({
                _mapType: function(type) {
                    var mapTypes = {
                            hybrid: google.maps.MapTypeId.HYBRID,
                            roadmap: google.maps.MapTypeId.ROADMAP,
                            satellite: google.maps.MapTypeId.SATELLITE
                        };
                    return mapTypes[type] || mapTypes.hybrid
                },
                _movementMode: function(type) {
                    var movementTypes = {
                            driving: google.maps.TravelMode.DRIVING,
                            walking: google.maps.TravelMode.WALKING
                        };
                    return movementTypes[type] || movementTypes.driving
                },
                _resolveLocation: function(location) {
                    var d = $.Deferred();
                    var latLng = this._getLatLng(location);
                    if (latLng)
                        d.resolve(new google.maps.LatLng(latLng.lat, latLng.lng));
                    else {
                        var geocoder = new google.maps.Geocoder;
                        geocoder.geocode({address: location}, function(results, status) {
                            if (status === google.maps.GeocoderStatus.OK)
                                d.resolve(results[0].geometry.location)
                        })
                    }
                    return d.promise()
                },
                _normalizeLocation: function(location) {
                    return {
                            lat: location.lat(),
                            lng: location.lng()
                        }
                },
                _normalizeLocationRect: function(locationRect) {
                    return {
                            northEast: this._normalizeLocation(locationRect.getNorthEast()),
                            southWest: this._normalizeLocation(locationRect.getSouthWest())
                        }
                },
                _loadImpl: function() {
                    this._googleMapsLoader = $.Deferred();
                    if (googleMapsLoaded())
                        this._mapReady();
                    else {
                        if (!googleMapsLoader || googleMapsLoader.state() === "resolved" && !googleMapsLoaded()) {
                            googleMapsLoader = $.Deferred();
                            var key = this._keyOption("google");
                            window[GOOGLE_MAP_READY] = $.proxy(googleMapsLoader.resolve, googleMapsLoader);
                            $.getScript(GOOGLE_URL + (key ? "&key=" + key : ""))
                        }
                        googleMapsLoader.done($.proxy(this._mapReady, this))
                    }
                    return this._googleMapsLoader.promise()
                },
                _mapReady: function() {
                    try {
                        delete window[GOOGLE_MAP_READY]
                    }
                    catch(e) {
                        window[GOOGLE_MAP_READY] = undefined
                    }
                    initCustomMarkerClass();
                    this._googleMapsLoader.resolve()
                },
                _init: function() {
                    var deferred = $.Deferred(),
                        initPromise = $.Deferred(),
                        controls = this._option("controls");
                    this._map = new google.maps.Map(this._$container[0], {
                        zoom: this._option("zoom"),
                        panControl: controls,
                        zoomControl: controls,
                        mapTypeControl: controls,
                        streetViewControl: controls
                    });
                    var listner = google.maps.event.addListener(this._map, 'idle', $.proxy(initPromise.resolve, initPromise));
                    $.when(initPromise).done($.proxy(function() {
                        google.maps.event.removeListener(listner);
                        deferred.resolve()
                    }, this));
                    return deferred.promise()
                },
                _attachHandlers: function() {
                    this._boundsChangeListener = google.maps.event.addListener(this._map, 'bounds_changed', $.proxy(this._boundsChangeHandler, this));
                    this._clickListener = google.maps.event.addListener(this._map, 'click', $.proxy(this._clickActionHandler, this))
                },
                _boundsChangeHandler: function() {
                    var bounds = this._map.getBounds();
                    this._option("bounds", this._normalizeLocationRect(bounds));
                    var center = this._map.getCenter();
                    this._option("center", this._normalizeLocation(center));
                    if (!this._preventZoomChangeEvent)
                        this._option("zoom", this._map.getZoom())
                },
                _clickActionHandler: function(e) {
                    this._fireClickAction({location: this._normalizeLocation(e.latLng)})
                },
                updateDimensions: function() {
                    var center = this._option("center");
                    google.maps.event.trigger(this._map, 'resize');
                    this._option("center", center);
                    return this.updateCenter()
                },
                updateMapType: function() {
                    this._map.setMapTypeId(this._mapType(this._option("type")));
                    return $.Deferred().resolve().promise()
                },
                updateBounds: function() {
                    var deferred = $.Deferred(),
                        that = this;
                    var northEastPromise = this._resolveLocation(this._option("bounds.northEast")),
                        southWestPromise = this._resolveLocation(this._option("bounds.southWest"));
                    $.when(northEastPromise, southWestPromise).done(function(northEast, southWest) {
                        var bounds = new google.maps.LatLngBounds;
                        bounds.extend(northEast);
                        bounds.extend(southWest);
                        that._map.fitBounds(bounds);
                        deferred.resolve()
                    });
                    return deferred.promise()
                },
                updateCenter: function() {
                    var deferred = $.Deferred(),
                        that = this;
                    this._resolveLocation(this._option("center")).done(function(center) {
                        that._map.setCenter(center);
                        that._option("center", that._normalizeLocation(center));
                        deferred.resolve()
                    });
                    return deferred.promise()
                },
                updateZoom: function() {
                    this._map.setZoom(this._option("zoom"));
                    return $.Deferred().resolve().promise()
                },
                updateControls: function() {
                    var controls = this._option("controls");
                    this._map.setOptions({
                        panControl: controls,
                        zoomControl: controls,
                        mapTypeControl: controls,
                        streetViewControl: controls
                    });
                    return $.Deferred().resolve().promise()
                },
                _renderMarker: function(options) {
                    var d = $.Deferred(),
                        that = this;
                    this._resolveLocation(options.location).done(function(location) {
                        var marker;
                        if (options.html)
                            marker = new CustomMarker({
                                map: that._map,
                                position: location,
                                html: options.html,
                                offset: $.extend({
                                    top: 0,
                                    left: 0
                                }, options.htmlOffset)
                            });
                        else
                            marker = new google.maps.Marker({
                                position: location,
                                map: that._map,
                                icon: options.iconSrc || that._option("markerIconSrc")
                            });
                        var infoWindow = that._renderTooltip(marker, options.tooltip);
                        var listner;
                        if (options.onClick || options.tooltip) {
                            var markerClickAction = that._createAction(options.onClick || $.noop),
                                markerNormalizedLocation = that._normalizeLocation(location);
                            listner = google.maps.event.addListener(marker, "click", function() {
                                markerClickAction({location: markerNormalizedLocation});
                                if (infoWindow)
                                    infoWindow.open(that._map, marker)
                            })
                        }
                        d.resolve({
                            location: location,
                            marker: marker,
                            listner: listner
                        })
                    });
                    return d.promise()
                },
                _renderTooltip: function(marker, options) {
                    if (!options)
                        return;
                    options = this._parseTooltipOptions(options);
                    var infoWindow = new google.maps.InfoWindow({content: options.text});
                    if (options.visible)
                        infoWindow.open(this._map, marker);
                    return infoWindow
                },
                _destroyMarker: function(marker) {
                    marker.marker.setMap(null);
                    if (marker.listner)
                        google.maps.event.removeListener(marker.listner)
                },
                _renderRoute: function(options) {
                    var d = $.Deferred(),
                        that = this,
                        directionsService = new google.maps.DirectionsService;
                    var points = $.map(options.locations, function(point) {
                            return that._resolveLocation(point)
                        });
                    $.when.apply($, points).done(function() {
                        var locations = $.makeArray(arguments),
                            origin = locations.shift(),
                            destination = locations.pop(),
                            waypoints = $.map(locations, function(location) {
                                return {
                                        location: location,
                                        stopover: true
                                    }
                            });
                        var request = {
                                origin: origin,
                                destination: destination,
                                waypoints: waypoints,
                                optimizeWaypoints: true,
                                travelMode: that._movementMode(options.mode)
                            };
                        directionsService.route(request, function(response, status) {
                            if (status === google.maps.DirectionsStatus.OK) {
                                var color = new Color(options.color || that._defaultRouteColor()).toHex(),
                                    directionOptions = {
                                        directions: response,
                                        map: that._map,
                                        suppressMarkers: true,
                                        preserveViewport: true,
                                        polylineOptions: {
                                            strokeWeight: options.weight || that._defaultRouteWeight(),
                                            strokeOpacity: options.opacity || that._defaultRouteOpacity(),
                                            strokeColor: color
                                        }
                                    };
                                var route = new google.maps.DirectionsRenderer(directionOptions),
                                    bounds = response.routes[0].bounds;
                                d.resolve({
                                    instance: route,
                                    northEast: bounds.getNorthEast(),
                                    southWest: bounds.getSouthWest()
                                })
                            }
                        })
                    });
                    return d.promise()
                },
                _destroyRoute: function(routeObject) {
                    routeObject.instance.setMap(null)
                },
                _fitBounds: function() {
                    this._updateBounds();
                    if (this._bounds && this._option("autoAdjust")) {
                        var zoomBeforeFitting = this._map.getZoom();
                        this._preventZoomChangeEvent = true;
                        this._map.fitBounds(this._bounds);
                        var zoomAfterFitting = this._map.getZoom();
                        if (zoomBeforeFitting < zoomAfterFitting)
                            this._map.setZoom(zoomBeforeFitting);
                        else
                            this._option("zoom", zoomAfterFitting);
                        delete this._preventZoomChangeEvent
                    }
                    return $.Deferred().resolve().promise()
                },
                _extendBounds: function(location) {
                    if (this._bounds)
                        this._bounds.extend(location);
                    else {
                        this._bounds = new google.maps.LatLngBounds;
                        this._bounds.extend(location)
                    }
                },
                clean: function() {
                    if (this._map) {
                        google.maps.event.removeListener(this._boundsChangeListener);
                        google.maps.event.removeListener(this._clickListener);
                        this._clearMarkers();
                        this._clearRoutes();
                        delete this._map;
                        this._$container.empty()
                    }
                    return $.Deferred().resolve().promise()
                }
            });
        GoogleProvider.remapConstant = function(newValue) {
            GOOGLE_URL = newValue
        };
        return GoogleProvider
    });
    /*! Module widgets-base, file ui.map.js */
    DevExpress.define("/ui/widgets/map/ui.map", ["jquery", "/ui/uiNamespace", "/ui/ui.errors", "/devices", "/componentRegistrator", "/ui/ui.widget", "/utils/utils.support", "/utils/utils.array", "/utils/utils.inflector", "/ui/widgets/map/ui.map.provider.googleStatic", "/ui/widgets/map/ui.map.provider.dynamic.google", "/ui/widgets/map/ui.map.provider.dynamic.bing", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer"], function($, uiNamespace, errors, devices, registerComponent, Widget, support, arrayUtils, inflector, GoogleStaticProvider, GoogleProvider, BingProvider, eventUtils, pointerEvents) {
        var wrapToArray = arrayUtils.wrapToArray,
            removeDublicates = arrayUtils.removeDublicates;
        var PROVIDERS = {
                googleStatic: GoogleStaticProvider,
                google: GoogleProvider,
                bing: BingProvider
            };
        var MAP_CLASS = "dx-map",
            MAP_CONTAINER_CLASS = "dx-map-container",
            MAP_SHIELD_CLASS = "dx-map-shield";
        var Map = Widget.inherit({
                ctor: function() {
                    this.callBase.apply(this, arguments);
                    this.addMarker = $.proxy(this._addFunction, this, "markers");
                    this.removeMarker = $.proxy(this._removeFunction, this, "markers");
                    this.addRoute = $.proxy(this._addFunction, this, "routes");
                    this.removeRoute = $.proxy(this._removeFunction, this, "routes")
                },
                _addFunction: function(optionName, addingValue) {
                    var deferred = $.Deferred(),
                        that = this,
                        providerDeffered = $.Deferred(),
                        optionValue = this.option(optionName),
                        addingValues = wrapToArray(addingValue);
                    optionValue.push.apply(optionValue, addingValues);
                    this._notificationDeffered = providerDeffered;
                    this.option(optionName, optionValue);
                    providerDeffered.done(function(instance) {
                        deferred.resolveWith(that, instance && instance.length > 1 ? [instance] : instance)
                    });
                    return deferred.promise()
                },
                _removeFunction: function(optionName, removingValue) {
                    var deferred = $.Deferred(),
                        that = this,
                        providerDeffered = $.Deferred(),
                        optionValue = this.option(optionName),
                        removingValues = wrapToArray(removingValue);
                    $.each(removingValues, function(_, removingValue) {
                        var index = $.isNumeric(removingValue) ? removingValue : $.inArray(removingValue, optionValue);
                        if (index !== -1)
                            optionValue.splice(index, 1);
                        else
                            throw errors.log("E1021", inflector.titleize(optionName.substring(0, optionName.length - 1)), removingValue);
                    });
                    this._notificationDeffered = providerDeffered;
                    this.option(optionName, optionValue);
                    providerDeffered.done(function() {
                        deferred.resolveWith(that)
                    });
                    return deferred.promise()
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            bounds: {
                                northEast: null,
                                southWest: null
                            },
                            center: {
                                lat: 0,
                                lng: 0
                            },
                            zoom: 1,
                            width: 300,
                            height: 300,
                            type: "roadmap",
                            provider: "google",
                            autoAdjust: true,
                            markers: [],
                            markerIconSrc: null,
                            onMarkerAdded: null,
                            onMarkerRemoved: null,
                            routes: [],
                            onRouteAdded: null,
                            onRouteRemoved: null,
                            key: {
                                bing: "",
                                google: "",
                                googleStatic: ""
                            },
                            controls: false,
                            onReady: null,
                            onUpdated: null,
                            onClick: null
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }])
                },
                _init: function() {
                    this.callBase();
                    this._asyncQueue = [];
                    this._checkProvider();
                    this._checkMarkersOption(this.option("markers"));
                    this._checkRoutesOption(this.option("routes"));
                    this._initContainer();
                    this._grabEvents();
                    this._cleanRenderedMarkers();
                    this._cleanRenderedRoutes()
                },
                _checkProvider: function() {
                    if (support.winJS && this.option("provider") === "google")
                        throw errors.Error("E1024");
                },
                _checkMarkersOption: function(markers) {
                    if (!$.isArray(markers))
                        throw errors.Error("E1022");
                },
                _checkRoutesOption: function(routes) {
                    if (!$.isArray(routes))
                        throw errors.Error("E1023");
                },
                _initContainer: function() {
                    this._$container = $("<div />").addClass(MAP_CONTAINER_CLASS);
                    this.element().append(this._$container)
                },
                _grabEvents: function() {
                    var eventName = eventUtils.addNamespace(pointerEvents.down, this.NAME);
                    this.element().on(eventName, $.proxy(this._cancelEvent, this))
                },
                _cancelEvent: function(e) {
                    var cancelByProvider = this._provider.cancelEvents && !this.option("disabled");
                    if (!DevExpress.designMode && cancelByProvider)
                        e.stopPropagation()
                },
                _cleanRenderedMarkers: function() {
                    this._renderedMarkers = []
                },
                _cleanRenderedRoutes: function(routes) {
                    this._renderedRoutes = []
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(MAP_CLASS);
                    this._renderShield();
                    this._queueAsyncAction("render", this.option("markers"), this.option("routes"));
                    this._saveRenderedMarkers();
                    this._saveRenderedRoutes()
                },
                _saveRenderedMarkers: function(markers) {
                    markers = markers || this.option("markers");
                    this._renderedMarkers = markers.slice()
                },
                _saveRenderedRoutes: function(routes) {
                    routes = routes || this.option("routes");
                    this._renderedRoutes = routes.slice()
                },
                _renderShield: function() {
                    var $shield;
                    if (DevExpress.designMode || this.option("disabled")) {
                        $shield = $("<div/>").addClass(MAP_SHIELD_CLASS);
                        this.element().append($shield)
                    }
                    else {
                        $shield = this.element().find("." + MAP_SHIELD_CLASS);
                        $shield.remove()
                    }
                },
                _clean: function() {
                    this._cleanFocusState();
                    if (!this._provider)
                        return;
                    this._queueAsyncAction("clean");
                    this._cleanRenderedMarkers();
                    this._cleanRenderedRoutes()
                },
                _optionChanged: function(args) {
                    var value = args.value;
                    if (this._cancelOptionChange)
                        return;
                    var notificationDeffered = this._notificationDeffered;
                    delete this._notificationDeffered;
                    switch (args.name) {
                        case"disabled":
                            this._renderShield();
                            this.callBase(args);
                            break;
                        case"width":
                        case"height":
                            this.callBase(args);
                            this._dimensionChanged();
                            break;
                        case"provider":
                            this._invalidate();
                            break;
                        case"key":
                            errors.log("W1001");
                            break;
                        case"bounds":
                            this._queueAsyncAction("updateBounds");
                            break;
                        case"center":
                            this._queueAsyncAction("updateCenter");
                            break;
                        case"zoom":
                            this._queueAsyncAction("updateZoom");
                            break;
                        case"type":
                            this._queueAsyncAction("updateMapType");
                            break;
                        case"controls":
                            this._queueAsyncAction("updateControls", this.option("markers"), this.option("routes"));
                            break;
                        case"autoAdjust":
                            this._queueAsyncAction("adjustViewport");
                            break;
                        case"markers":
                            this._checkMarkersOption(value);
                            this._queueAsyncAction("updateMarkers", notificationDeffered ? removeDublicates(this._renderedMarkers, value) : this._renderedMarkers, notificationDeffered ? removeDublicates(value, this._renderedMarkers) : value).done($.proxy(function() {
                                if (notificationDeffered)
                                    notificationDeffered.resolve.apply(notificationDeffered, arguments)
                            }, this));
                            this._saveRenderedMarkers(value);
                            break;
                        case"markerIconSrc":
                            this._queueAsyncAction("updateMarkers", this._renderedMarkers, this._renderedMarkers);
                            break;
                        case"routes":
                            this._checkRoutesOption(value);
                            this._queueAsyncAction("updateRoutes", notificationDeffered ? removeDublicates(this._renderedRoutes, value) : this._renderedRoutes, notificationDeffered ? removeDublicates(value, this._renderedRoutes) : value).done($.proxy(function() {
                                if (notificationDeffered)
                                    notificationDeffered.resolve.apply(notificationDeffered, arguments)
                            }, this));
                            this._saveRenderedRoutes(value);
                            break;
                        case"onReady":
                        case"onUpdated":
                        case"onMarkerAdded":
                        case"onMarkerRemoved":
                        case"onRouteAdded":
                        case"onRouteRemoved":
                        case"onClick":
                            break;
                        default:
                            this.callBase.apply(this, arguments)
                    }
                },
                _visibilityChanged: function(visible) {
                    if (visible)
                        this._dimensionChanged()
                },
                _dimensionChanged: function() {
                    this._queueAsyncAction("updateDimensions")
                },
                _queueAsyncAction: function(name) {
                    var deferred = $.Deferred(),
                        emptyQueue = !this._asyncQueue.length;
                    this._asyncQueue.push({
                        name: name,
                        options: $.makeArray(arguments).slice(1),
                        deferred: deferred
                    });
                    if (emptyQueue)
                        this._enqueueAsyncAction();
                    return deferred.promise()
                },
                _enqueueAsyncAction: function() {
                    var emptyQueue = !this._asyncQueue.length;
                    if (emptyQueue)
                        return;
                    this._execAsyncAction(this._asyncQueue[0]).done($.proxy(function() {
                        this._asyncQueue.shift();
                        this._enqueueAsyncAction()
                    }, this))
                },
                _execAsyncAction: function(action) {
                    var deferred = $.Deferred(),
                        actionName = action.name,
                        actionOptions = action.options,
                        actionDeferred = action.deferred,
                        provider = this._getProvider(actionName);
                    provider[actionName].apply(provider, actionOptions).done($.proxy(function(mapRefreshed) {
                        actionDeferred.resolve.apply(actionDeferred, $.makeArray(arguments).slice(1));
                        if (mapRefreshed)
                            this._triggerReadyAction();
                        else if (actionName !== "clean")
                            this._triggerUpdateAction();
                        deferred.resolve()
                    }, this));
                    return deferred.promise()
                },
                _getProvider: function(actionName) {
                    var currentProvider = this.option("provider");
                    if (actionName !== "clean" && this._usedProvider !== currentProvider) {
                        this._provider = new PROVIDERS[currentProvider](this, this._$container);
                        this._usedProvider = currentProvider
                    }
                    return this._provider
                },
                _triggerReadyAction: function() {
                    this._createActionByOption("onReady")({originalMap: this._provider.map()})
                },
                _triggerUpdateAction: function() {
                    this._createActionByOption("onUpdated")()
                },
                setOptionSilent: function(name, value) {
                    this._cancelOptionChange = true;
                    this.option(name, value);
                    this._cancelOptionChange = false
                }
            });
        registerComponent("dxMap", uiNamespace, Map);
        return Map
    });
    DevExpress.require(["/ui/widgets/map/ui.map"]);
    /*! Module widgets-base, file ui.swipeable.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            registerComponent = DX.require("/componentRegistrator"),
            DOMComponent = DX.require("/domComponent"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            DX_SWIPEABLE = "dxSwipeable",
            SWIPEABLE_CLASS = "dx-swipeable",
            ACTION_TO_EVENT_MAP = {
                onStart: "dxswipestart",
                onUpdated: "dxswipe",
                onEnd: "dxswipeend",
                onCancel: "dxswipecancel"
            };
        registerComponent(DX_SWIPEABLE, ui, DOMComponent.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        elastic: true,
                        immediate: false,
                        direction: "horizontal",
                        itemSizeFunc: null,
                        onStart: null,
                        onUpdated: null,
                        onEnd: null,
                        onCancel: null
                    })
            },
            _render: function() {
                this.callBase();
                this.element().addClass(SWIPEABLE_CLASS);
                this._attachEventHandlers()
            },
            _attachEventHandlers: function() {
                this._detachEventHanlers();
                if (this.option("disabled"))
                    return;
                var NAME = this.NAME;
                this._createEventData();
                $.each(ACTION_TO_EVENT_MAP, $.proxy(function(actionName, eventName) {
                    var action = this._createActionByOption(actionName, {context: this});
                    eventName = eventUtils.addNamespace(eventName, NAME);
                    this.element().on(eventName, this._eventData, function(e) {
                        return action({jQueryEvent: e})
                    })
                }, this))
            },
            _createEventData: function() {
                this._eventData = {
                    elastic: this.option("elastic"),
                    itemSizeFunc: this.option("itemSizeFunc"),
                    direction: this.option("direction"),
                    immediate: this.option("immediate")
                }
            },
            _detachEventHanlers: function() {
                this.element().off("." + DX_SWIPEABLE)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"disabled":
                    case"onStart":
                    case"onUpdated":
                    case"onEnd":
                    case"onCancel":
                    case"elastic":
                    case"immediate":
                    case"itemSizeFunc":
                    case"direction":
                        this._detachEventHanlers();
                        this._attachEventHandlers();
                        break;
                    case"rtlEnabled":
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.draggable.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.require("/utils/utils.translator"),
            dasherize = DX.require("/utils/utils.inflector").dasherize,
            stringUtils = DX.require("/utils/utils.string"),
            registerComponent = DX.require("/componentRegistrator"),
            DOMComponent = DX.require("/domComponent"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer"),
            DRAGGABLE = "dxDraggable",
            DRAGSTART_EVENT_NAME = eventUtils.addNamespace("dxdragstart", DRAGGABLE),
            DRAG_EVENT_NAME = eventUtils.addNamespace("dxdrag", DRAGGABLE),
            DRAGEND_EVENT_NAME = eventUtils.addNamespace("dxdragend", DRAGGABLE),
            POINTERDOWN_EVENT_NAME = eventUtils.addNamespace(pointerEvents.down, DRAGGABLE),
            DRAGGABLE_CLASS = dasherize(DRAGGABLE),
            DRAGGABLE_DRAGGING_CLASS = DRAGGABLE_CLASS + "-dragging";
        registerComponent(DRAGGABLE, ui, DOMComponent.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        onDragStart: $.noop,
                        onDrag: $.noop,
                        onDragEnd: $.noop,
                        direction: "both",
                        area: window,
                        boundOffset: 0,
                        allowMoveByClick: false
                    })
            },
            _init: function() {
                this.callBase();
                this._attachEventHandlers()
            },
            _attachEventHandlers: function() {
                if (this.option("disabled"))
                    return;
                var $element = this.element().css("position", "absolute"),
                    eventHandlers = {},
                    allowMoveByClick = this.option("allowMoveByClick");
                eventHandlers[DRAGSTART_EVENT_NAME] = $.proxy(this._dragStartHandler, this);
                eventHandlers[DRAG_EVENT_NAME] = $.proxy(this._dragHandler, this);
                eventHandlers[DRAGEND_EVENT_NAME] = $.proxy(this._dragEndHandler, this);
                if (allowMoveByClick) {
                    eventHandlers[POINTERDOWN_EVENT_NAME] = $.proxy(this._pointerDownHandler, this);
                    $element = this._getArea()
                }
                $element.on(eventHandlers, {
                    direction: this.option("direction"),
                    immediate: true
                })
            },
            _detachEventHandlers: function() {
                this.element().off("." + DRAGGABLE);
                this._getArea().off("." + DRAGGABLE)
            },
            _move: function(position) {
                translator.move(this.element(), position)
            },
            _pointerDownHandler: function(e) {
                if (eventUtils.needSkipEvent(e))
                    return;
                var areaOffset = this._getAreaOffset($(e.currentTarget)),
                    direction = this.option("direction"),
                    position = {};
                if (direction === "horizontal" || direction === "both")
                    position.left = e.pageX - this.element().width() / 2 - areaOffset.left;
                if (direction === "vertical" || direction === "both")
                    position.top = e.pageY - this.element().height() / 2 - areaOffset.top;
                this._move(position);
                this._getAction("onDrag")({jQueryEvent: e})
            },
            _dragStartHandler: function(e) {
                var $element = this.element();
                if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
                    e.cancel = true;
                    return
                }
                var $area = this._getArea(),
                    areaOffset = this._getAreaOffset($area),
                    boundOffset = this._getBoundOffset(),
                    areaWidth = $area.outerWidth(),
                    areaHeight = $area.outerHeight(),
                    elementWidth = $element.width(),
                    elementHeight = $element.height();
                this._toggleDraggingClass(true);
                var startOffset = {
                        left: $element.offset().left - areaOffset.left,
                        top: $element.offset().top - areaOffset.top
                    };
                this._startPosition = translator.locate($element);
                e.maxLeftOffset = startOffset.left - boundOffset.left;
                e.maxRightOffset = areaWidth - startOffset.left - elementWidth - boundOffset.right;
                e.maxTopOffset = startOffset.top - boundOffset.top;
                e.maxBottomOffset = areaHeight - startOffset.top - elementHeight - boundOffset.bottom;
                this._getAction("onDragStart")({jQueryEvent: e})
            },
            _getAreaOffset: function($area) {
                var offset = $area && $area.offset();
                return offset ? offset : {
                        left: 0,
                        top: 0
                    }
            },
            _toggleDraggingClass: function(value) {
                this.element().toggleClass(DRAGGABLE_DRAGGING_CLASS, value)
            },
            _getBoundOffset: function() {
                var boundOffset = this.option("boundOffset");
                if ($.isFunction(boundOffset))
                    boundOffset = boundOffset.call(this);
                return stringUtils.quadToObject(boundOffset)
            },
            _getArea: function() {
                var area = this.option("area");
                if ($.isFunction(area))
                    area = area.call(this);
                return $(area)
            },
            _dragHandler: function(e) {
                var offset = e.offset,
                    startPosition = this._startPosition;
                this._move({
                    left: startPosition.left + offset.x,
                    top: startPosition.top + offset.y
                });
                this._getAction("onDrag")({jQueryEvent: e})
            },
            _dragEndHandler: function(e) {
                this._toggleDraggingClass(false);
                this._getAction("onDragEnd")({jQueryEvent: e})
            },
            _getAction: function(name) {
                return this["_" + name + "Action"] || this._createActionByOption(name)
            },
            _render: function() {
                this.callBase();
                this.element().addClass(DRAGGABLE_CLASS)
            },
            _optionChanged: function(args) {
                var name = args.name;
                switch (name) {
                    case"onDragStart":
                    case"onDrag":
                    case"onDragEnd":
                        this["_" + name + "Action"] = this._createActionByOption(name);
                        break;
                    case"allowMoveByClick":
                    case"direction":
                    case"disabled":
                        this._detachEventHandlers();
                        this._attachEventHandlers();
                        break;
                    case"boundOffset":
                    case"area":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _dispose: function() {
                this.callBase();
                this._detachEventHandlers()
            }
        }));
        ui.dxDraggable.__internals = {DRAGGABLE_CLASS: DRAGGABLE_CLASS}
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.deferRendering.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget");
        var WIDGET_CLASS = "dx-widget",
            DEFER_RENDERING_CLASS = "dx-deferrendering",
            PENDING_RENDERING_CLASS = "dx-pending-rendering",
            PENDING_RENDERING_MANUAL_CLASS = "dx-pending-rendering-manual",
            PENDING_RENDERING_ACTIVE_CLASS = "dx-pending-rendering-active",
            INVISIBLE_WHILE_PENDING_RENDERING_CLASS = "dx-invisible-while-pending-rendering",
            LOADINDICATOR_CONTAINER_CLASS = "dx-loadindicator-container",
            DEFER_DEFER_RENDERING_LOAD_INDICATOR = "dx-deferrendering-load-indicator",
            ANONYMOUS_TEMPLATE_NAME = "content",
            ACTIONS = ["onRendered", "onShown"];
        registerComponent("dxDeferRendering", ui, Widget.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        showLoadIndicator: false,
                        renderWhen: undefined,
                        animation: undefined,
                        staggerItemSelector: undefined,
                        onRendered: null,
                        onShown: null
                    })
            },
            _getAnonymousTemplateName: function() {
                return ANONYMOUS_TEMPLATE_NAME
            },
            _init: function() {
                this.transitionExecutor = new DX.TransitionExecutor;
                this._initElement();
                this._initRender();
                this._$initialContent = this.element().clone().contents();
                this._initActions();
                this.callBase()
            },
            _initElement: function() {
                this.element().addClass(DEFER_RENDERING_CLASS).addClass(LOADINDICATOR_CONTAINER_CLASS)
            },
            _initRender: function() {
                var that = this,
                    $element = this.element(),
                    renderWhen = this.option("renderWhen");
                var doRender = function() {
                        return that._renderDeferredContent()
                    };
                if (renderWhen && renderWhen.done)
                    renderWhen.done(doRender);
                else {
                    $element.data("dx-render-delegate", doRender);
                    if (renderWhen === undefined)
                        $element.addClass(PENDING_RENDERING_MANUAL_CLASS)
                }
            },
            _initActions: function() {
                this._actions = {};
                $.each(ACTIONS, $.proxy(function(_, action) {
                    this._actions[action] = this._createActionByOption(action) || $.noop
                }, this))
            },
            _renderContentImpl: function() {
                this.element().removeClass(WIDGET_CLASS);
                this.element().append(this._$initialContent);
                this._setLoadingState()
            },
            _renderDeferredContent: function() {
                var that = this,
                    $element = this.element(),
                    result = $.Deferred();
                $element.removeClass(PENDING_RENDERING_MANUAL_CLASS);
                $element.addClass(PENDING_RENDERING_ACTIVE_CLASS);
                this._renderTask = commonUtils.executeAsync(function() {
                    that._renderImpl().done(function() {
                        var shownArgs = {element: $element};
                        that._actions.onShown([shownArgs]);
                        result.resolve(shownArgs)
                    }).fail(function() {
                        result.rejectWith(result, arguments)
                    })
                });
                return result.promise()
            },
            _isElementInViewport: function(element) {
                var rect = element.getBoundingClientRect();
                return rect.bottom >= 0 && rect.right >= 0 && rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.left <= (window.innerWidth || document.documentElement.clientWidth)
            },
            _animate: function() {
                var that = this,
                    $element = this.element(),
                    animation = this.option("animation"),
                    staggerItemSelector = this.option("staggerItemSelector"),
                    animatePromise;
                that.transitionExecutor.stop();
                if (animation) {
                    if (staggerItemSelector)
                        $element.find(staggerItemSelector).each(function() {
                            if (that._isElementInViewport(this))
                                that.transitionExecutor.enter($(this), animation)
                        });
                    else
                        that.transitionExecutor.enter($element, animation);
                    animatePromise = that.transitionExecutor.start()
                }
                else
                    animatePromise = $.Deferred().resolve().promise();
                return animatePromise
            },
            _renderImpl: function() {
                var $element = this.element(),
                    renderedArgs = {element: $element};
                var contentTemplate = this._getTemplate(this._getAnonymousTemplateName());
                if (contentTemplate)
                    contentTemplate.render($element.empty());
                this._setRenderedState($element);
                $element.trigger("dxcontentrendered");
                this._actions.onRendered([renderedArgs]);
                this._isRendered = true;
                return this._animate()
            },
            _setLoadingState: function() {
                var $element = this.element();
                $element.addClass(PENDING_RENDERING_CLASS);
                $element.children().addClass(INVISIBLE_WHILE_PENDING_RENDERING_CLASS);
                if (this.option("showLoadIndicator"))
                    this._showLoadIndicator($element)
            },
            _showLoadIndicator: function($container) {
                this._$loadIndicator = $('<div/>').dxLoadIndicator({visible: true}).addClass(DEFER_DEFER_RENDERING_LOAD_INDICATOR);
                $container.append(this._$loadIndicator)
            },
            _setRenderedState: function() {
                var $element = this.element();
                if (this._$loadIndicator)
                    this._$loadIndicator.remove();
                $element.removeClass(PENDING_RENDERING_CLASS);
                $element.removeClass(PENDING_RENDERING_ACTIVE_CLASS);
                $element.children().removeClass(INVISIBLE_WHILE_PENDING_RENDERING_CLASS);
                utils.triggerShownEvent($element.children())
            },
            _optionChanged: function(args) {
                var value = args.value,
                    previousValue = args.previousValue;
                switch (args.name) {
                    case"renderWhen":
                        if (previousValue === false && value === true)
                            this._renderOrAnimate();
                        else if (previousValue === true && value === false)
                            this._setLoadingState();
                        break;
                    case"showLoadIndicator":
                    case"onRendered":
                    case"onShown":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _renderOrAnimate: function() {
                var result;
                if (this._isRendered) {
                    this._setRenderedState();
                    result = this._animate()
                }
                else
                    result = this._renderDeferredContent();
                return result
            },
            renderContent: function() {
                return this._renderOrAnimate()
            },
            _dispose: function() {
                this.transitionExecutor.stop();
                if (this._renderTask)
                    this._renderTask.abort();
                this._actions = null;
                this._$initialContent = null;
                this.callBase()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.resizable.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.require("/utils/utils.translator"),
            stringUtils = DX.require("/utils/utils.string"),
            fitIntoRange = DX.require("/utils/utils.math").fitIntoRange,
            registerComponent = DX.require("/componentRegistrator"),
            DOMComponent = DX.require("/domComponent"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            RESIZABLE = "dxResizable",
            RESIZABLE_CLASS = "dx-resizable",
            RESIZABLE_RESIZING_CLASS = "dx-resizable-resizing",
            RESIZABLE_HANDLE_CLASS = "dx-resizable-handle",
            RESIZABLE_HANDLE_TOP_CLASS = "dx-resizable-handle-top",
            RESIZABLE_HANDLE_BOTTOM_CLASS = "dx-resizable-handle-bottom",
            RESIZABLE_HANDLE_LEFT_CLASS = "dx-resizable-handle-left",
            RESIZABLE_HANDLE_RIGHT_CLASS = "dx-resizable-handle-right",
            RESIZABLE_HANDLE_CORNER_CLASS = "dx-resizable-handle-corner",
            DRAGSTART_START_EVENT_NAME = eventUtils.addNamespace("dxdragstart", RESIZABLE),
            DRAGSTART_EVENT_NAME = eventUtils.addNamespace("dxdrag", RESIZABLE),
            DRAGSTART_END_EVENT_NAME = eventUtils.addNamespace("dxdragend", RESIZABLE);
        registerComponent(RESIZABLE, ui, DOMComponent.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        handles: "all",
                        step: "1",
                        area: undefined,
                        minWidth: 30,
                        maxWidth: Infinity,
                        minHeight: 30,
                        maxHeight: Infinity,
                        onResizeStart: null,
                        onResize: null,
                        onResizeEnd: null
                    })
            },
            _init: function() {
                this.callBase();
                this.element().addClass(RESIZABLE_CLASS)
            },
            _render: function() {
                this.callBase();
                this._renderActions();
                this._renderHandles()
            },
            _renderActions: function() {
                this._resizeStartAction = this._createActionByOption("onResizeStart");
                this._resizeEndAction = this._createActionByOption("onResizeEnd");
                this._resizeAction = this._createActionByOption("onResize")
            },
            _renderHandles: function() {
                var handles = this.option("handles");
                if (handles === "none")
                    return;
                var directions = handles === "all" ? ['top', 'bottom', 'left', 'right'] : handles.split(" ");
                $.each(directions, $.proxy(function(index, handleName) {
                    this._renderHandle(handleName)
                }, this));
                $.inArray('bottom', directions) + 1 && $.inArray('right', directions) + 1 && this._renderHandle("corner-bottom-right");
                $.inArray('bottom', directions) + 1 && $.inArray('left', directions) + 1 && this._renderHandle("corner-bottom-left");
                $.inArray('top', directions) + 1 && $.inArray('right', directions) + 1 && this._renderHandle("corner-top-right");
                $.inArray('top', directions) + 1 && $.inArray('left', directions) + 1 && this._renderHandle("corner-top-left")
            },
            _renderHandle: function(handleName) {
                var $element = this.element(),
                    $handle = $("<div>");
                $handle.addClass(RESIZABLE_HANDLE_CLASS).addClass(RESIZABLE_HANDLE_CLASS + "-" + handleName).appendTo($element);
                this._attachEventHandlers($handle)
            },
            _attachEventHandlers: function($handle) {
                if (this.option("disabled"))
                    return;
                var handlers = {};
                handlers[DRAGSTART_START_EVENT_NAME] = $.proxy(this._dragStartHandler, this);
                handlers[DRAGSTART_EVENT_NAME] = $.proxy(this._dragHandler, this);
                handlers[DRAGSTART_END_EVENT_NAME] = $.proxy(this._dragEndHandler, this);
                $handle.on(handlers, {
                    direction: "both",
                    immediate: true
                })
            },
            _dragStartHandler: function(e) {
                var $element = this.element();
                if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
                    e.cancel = true;
                    return
                }
                this._toggleResizingClass(true);
                this._movingSides = this._getMovingSides(e);
                this._elementLocation = translator.locate($element);
                this._elementSize = {
                    width: $element.outerWidth(),
                    height: $element.outerHeight()
                };
                this._renderDragOffsets(e);
                this._resizeStartAction({
                    jQueryEvent: e,
                    width: this._elementSize.width,
                    height: this._elementSize.height,
                    handles: this._movingSides
                });
                e.targetElements = null
            },
            _toggleResizingClass: function(value) {
                this.element().toggleClass(RESIZABLE_RESIZING_CLASS, value)
            },
            _renderDragOffsets: function(e) {
                var area = this._getArea();
                if (!area)
                    return;
                var $handle = $(e.target).closest("." + RESIZABLE_HANDLE_CLASS),
                    handleWidth = $handle.outerWidth(),
                    handleHeight = $handle.outerHeight(),
                    handleOffset = $handle.offset(),
                    areaOffset = area.offset;
                e.maxLeftOffset = handleOffset.left - areaOffset.left;
                e.maxRightOffset = areaOffset.left + area.width - handleOffset.left - handleWidth;
                e.maxTopOffset = handleOffset.top - areaOffset.top;
                e.maxBottomOffset = areaOffset.top + area.height - handleOffset.top - handleHeight
            },
            _getBorderWidth: function($element, direction) {
                var borderWidth = $element.css("border-" + direction + "-width");
                return parseInt(borderWidth) || 0
            },
            _dragHandler: function(e) {
                var $element = this.element(),
                    offset = this._getOffset(e),
                    sides = this._movingSides;
                var location = this._elementLocation,
                    size = this._elementSize;
                var width = size.width + offset.x * (sides.left ? -1 : 1),
                    height = size.height + offset.y * (sides.top ? -1 : 1);
                this._renderSize(width, height);
                var offsetTop = offset.y - (this.option("height") - height),
                    offsetLeft = offset.x - (this.option("width") - width);
                translator.move($element, {
                    top: location.top + (sides.top ? offsetTop : 0),
                    left: location.left + (sides.left ? offsetLeft : 0)
                });
                this._resizeAction({
                    jQueryEvent: e,
                    width: width,
                    height: height,
                    handles: this._movingSides
                })
            },
            _getOffset: function(e) {
                var offset = e.offset,
                    steps = stringUtils.pairToObject(this.option("step")),
                    sides = this._getMovingSides(e);
                if (!sides.left && !sides.right)
                    offset.x = 0;
                if (!sides.top && !sides.bottom)
                    offset.y = 0;
                return {
                        x: offset.x - offset.x % steps.h,
                        y: offset.y - offset.y % steps.v
                    }
            },
            _getMovingSides: function(e) {
                var $target = $(e.target);
                return {
                        top: $target.hasClass(RESIZABLE_HANDLE_TOP_CLASS) || $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-left") || $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-right"),
                        left: $target.hasClass(RESIZABLE_HANDLE_LEFT_CLASS) || $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-left") || $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-left"),
                        bottom: $target.hasClass(RESIZABLE_HANDLE_BOTTOM_CLASS) || $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-left") || $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-right"),
                        right: $target.hasClass(RESIZABLE_HANDLE_RIGHT_CLASS) || $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-right") || $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-right")
                    }
            },
            _getArea: function() {
                var area = this.option("area");
                if ($.isFunction(area))
                    area = area.call(this);
                if ($.isPlainObject(area))
                    return this._getAreaFromObject(area);
                return this._getAreaFromElement(area)
            },
            _getAreaFromObject: function(area) {
                var result = {
                        width: area.right - area.left,
                        height: area.bottom - area.top,
                        offset: {
                            left: area.left,
                            top: area.top
                        }
                    };
                this._correctAreaGeometry(result);
                return result
            },
            _getAreaFromElement: function(area) {
                var $area = $(area),
                    result;
                if ($area.length) {
                    result = {};
                    result.width = $area.innerWidth();
                    result.height = $area.innerHeight();
                    result.offset = $area.offset();
                    this._correctAreaGeometry(result, $area)
                }
                return result
            },
            _correctAreaGeometry: function(result, $area) {
                var areaBorderLeft = $area ? this._getBorderWidth($area, "left") : 0,
                    areaBorderTop = $area ? this._getBorderWidth($area, "top") : 0;
                result.offset.left += areaBorderLeft + this._getBorderWidth(this.element(), "left");
                result.offset.top += areaBorderTop + this._getBorderWidth(this.element(), "top");
                result.width -= this.element().outerWidth() - this.element().innerWidth();
                result.height -= this.element().outerHeight() - this.element().innerHeight()
            },
            _dragEndHandler: function(e) {
                var $element = this.element();
                this._resizeEndAction({
                    jQueryEvent: e,
                    width: $element.outerWidth(),
                    height: $element.outerHeight(),
                    handles: this._movingSides
                });
                this._toggleResizingClass(false)
            },
            _renderSize: function(width, height) {
                this.option("width", fitIntoRange(width, this.option("minWidth"), this.option("maxWidth")));
                this.option("height", fitIntoRange(height, this.option("minHeight"), this.option("maxHeight")))
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"disabled":
                    case"handles":
                        this._invalidate();
                        break;
                    case"minWidth":
                    case"maxWidth":
                    case"minHeight":
                    case"maxHeight":
                        this._renderSize(this.element().outerWidth(), this.element().outerHeight());
                        break;
                    case"onResize":
                    case"onResizeStart":
                    case"onResizeEnd":
                        this._renderActions();
                        break;
                    case"gridStepHorizontal":
                    case"gridStepVertical":
                    case"area":
                    case"step":
                        break;
                    default:
                        this.callBase(args);
                        break
                }
            },
            _clean: function() {
                this.element().find("." + RESIZABLE_HANDLE_CLASS).remove()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.box.js */
    (function($, DX, undefined) {
        var ui = DevExpress.ui,
            Class = DevExpress.require("/class"),
            support = DX.require("/utils/utils.support"),
            browser = DX.require("/utils/utils.browser"),
            commonUtils = DX.require("/utils/utils.common"),
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator");
        var BOX_CLASS = "dx-box",
            BOX_SELECTOR = ".dx-box",
            BOX_ITEM_CLASS = "dx-box-item",
            BOX_ITEM_DATA_KEY = "dxBoxItemData";
        var flexGrowProp = support.styleProp("flexGrow");
        var flexShrinkProp = support.styleProp("flexShrink");
        var flexPropPrefix = support.stylePropPrefix("flexDirection");
        var MINSIZE_MAP = {
                row: "minWidth",
                col: "minHeight"
            };
        var MAXSIZE_MAP = {
                row: "maxWidth",
                col: "maxHeight"
            };
        var SHRINK = 1;
        var FLEX_JUSTIFY_CONTENT_MAP = {
                start: "flex-start",
                end: "flex-end",
                center: "center",
                "space-between": "space-between",
                "space-around": "space-around"
            };
        var FLEX_ALIGN_ITEMS_MAP = {
                start: "flex-start",
                end: "flex-end",
                center: "center",
                stretch: "stretch"
            };
        var FLEX_DIRECTION_MAP = {
                row: "row",
                col: "column"
            };
        var FlexLayoutStrategy = Class.inherit({
                ctor: function($element, option) {
                    this._$element = $element;
                    this._option = option
                },
                renderBox: function() {
                    this._$element.css({
                        display: support.stylePropPrefix("flexDirection") + "flex",
                        flexDirection: FLEX_DIRECTION_MAP[this._option("direction")]
                    })
                },
                renderAlign: function() {
                    this._$element.css({justifyContent: this._normalizedAlign()})
                },
                _normalizedAlign: function() {
                    var align = this._option("align");
                    return align in FLEX_JUSTIFY_CONTENT_MAP ? FLEX_JUSTIFY_CONTENT_MAP[align] : align
                },
                renderCrossAlign: function() {
                    this._$element.css({alignItems: this._normalizedCrossAlign()})
                },
                _normalizedCrossAlign: function() {
                    var crossAlign = this._option("crossAlign");
                    return crossAlign in FLEX_ALIGN_ITEMS_MAP ? FLEX_ALIGN_ITEMS_MAP[crossAlign] : crossAlign
                },
                renderItems: function($items) {
                    var direction = this._option("direction");
                    $.each($items, function() {
                        var $item = $(this);
                        var item = $item.data(BOX_ITEM_DATA_KEY);
                        $item.css({
                            display: flexPropPrefix + "flex",
                            flexBasis: item.baseSize || 0
                        }).css(MAXSIZE_MAP[direction], item.maxSize || "none").css(MINSIZE_MAP[direction], item.minSize || "0");
                        var itemStyle = $item.get(0).style;
                        itemStyle[flexGrowProp] = item.ratio;
                        itemStyle[flexShrinkProp] = commonUtils.isDefined(item.shrink) ? item.shrink : SHRINK;
                        $item.children().each(function(_, itemContent) {
                            $(itemContent).css({
                                width: "auto",
                                height: "auto",
                                display: support.stylePropPrefix("flexDirection") + "flex",
                                flexDirection: $item.children().css("flexDirection") || "column"
                            });
                            itemContent.style[flexGrowProp] = 1
                        })
                    })
                },
                initSize: $.noop,
                update: $.noop
            });
        var BOX_EVENTNAMESPACE = "dxBox",
            UPDATE_EVENT = "dxupdate." + BOX_EVENTNAMESPACE,
            FALLBACK_BOX_ITEM = "dx-box-fallback-item";
        var FALLBACK_WRAP_MAP = {
                row: "nowrap",
                col: "normal"
            };
        var FALLBACK_MAIN_SIZE_MAP = {
                row: "width",
                col: "height"
            };
        var FALLBACK_CROSS_SIZE_MAP = {
                row: "height",
                col: "width"
            };
        var FALLBACK_PRE_MARGIN_MAP = {
                row: "marginLeft",
                col: "marginTop"
            };
        var FALLBACK_POST_MARGIN_MAP = {
                row: "marginRight",
                col: "marginBottom"
            };
        var FALLBACK_CROSS_PRE_MARGIN_MAP = {
                row: "marginTop",
                col: "marginLeft"
            };
        var FALLBACK_CROSS_POST_MARGIN_MAP = {
                row: "marginBottom",
                col: "marginRight"
            };
        var MARGINS_RTL_FLIP_MAP = {
                marginLeft: "marginRight",
                marginRight: "marginLeft"
            };
        var FallbackLayoutStrategy = Class.inherit({
                ctor: function($element, option) {
                    this._$element = $element;
                    this._option = option
                },
                renderBox: function() {
                    this._$element.css({
                        fontSize: 0,
                        whiteSpace: FALLBACK_WRAP_MAP[this._option("direction")],
                        verticalAlign: "top"
                    });
                    this._$element.off(UPDATE_EVENT).on(UPDATE_EVENT, $.proxy(this.update, this))
                },
                renderAlign: function() {
                    var $items = this._$items;
                    if (!$items)
                        return;
                    var align = this._option("align"),
                        shift = 0,
                        totalItemSize = this.totalItemSize,
                        direction = this._option("direction"),
                        boxSize = this._$element[FALLBACK_MAIN_SIZE_MAP[direction]](),
                        freeSpace = boxSize - totalItemSize;
                    this._setItemsMargins($items, direction, 0);
                    switch (align) {
                        case"start":
                            break;
                        case"end":
                            shift = freeSpace;
                            $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift);
                            break;
                        case"center":
                            shift = 0.5 * freeSpace;
                            $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift);
                            $items.last().css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), shift);
                            break;
                        case"space-between":
                            shift = 0.5 * freeSpace / ($items.length - 1);
                            this._setItemsMargins($items, direction, shift);
                            $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), 0);
                            $items.last().css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), 0);
                            break;
                        case"space-around":
                            shift = 0.5 * freeSpace / $items.length;
                            this._setItemsMargins($items, direction, shift);
                            break
                    }
                },
                _setItemsMargins: function($items, direction, shift) {
                    $items.css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift).css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), shift)
                },
                renderCrossAlign: function() {
                    var $items = this._$items;
                    if (!$items)
                        return;
                    var crossAlign = this._option("crossAlign"),
                        direction = this._option("direction"),
                        size = this._$element[FALLBACK_CROSS_SIZE_MAP[direction]]();
                    var that = this;
                    switch (crossAlign) {
                        case"start":
                            break;
                        case"end":
                            $.each($items, function() {
                                var $item = $(this),
                                    itemSize = $item[FALLBACK_CROSS_SIZE_MAP[direction]](),
                                    shift = size - itemSize;
                                $item.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), shift)
                            });
                            break;
                        case"center":
                            $.each($items, function() {
                                var $item = $(this),
                                    itemSize = $item[FALLBACK_CROSS_SIZE_MAP[direction]](),
                                    shift = 0.5 * (size - itemSize);
                                $item.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), shift).css(that._chooseMarginSide(FALLBACK_CROSS_POST_MARGIN_MAP[direction]), shift)
                            });
                            break;
                        case"stretch":
                            $items.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), 0).css(that._chooseMarginSide(FALLBACK_CROSS_POST_MARGIN_MAP[direction]), 0).css(FALLBACK_CROSS_SIZE_MAP[direction], "100%");
                            break
                    }
                },
                _chooseMarginSide: function(value) {
                    if (!this._option("rtlEnabled"))
                        return value;
                    return MARGINS_RTL_FLIP_MAP[value] || value
                },
                renderItems: function($items) {
                    this._$items = $items;
                    var direction = this._option("direction"),
                        totalRatio = 0,
                        totalWeightedShrink = 0,
                        totalBaseSize = 0;
                    $.each($items, $.proxy(function(_, item) {
                        var $item = $(item);
                        $item.css({
                            display: "inline-block",
                            verticalAlign: "top"
                        });
                        $item[FALLBACK_MAIN_SIZE_MAP[direction]]("auto");
                        $item.removeClass(FALLBACK_BOX_ITEM);
                        var itemData = $item.data(BOX_ITEM_DATA_KEY),
                            ratio = itemData.ratio || 0,
                            size = this._baseSize($item),
                            shrink = commonUtils.isDefined(itemData.shrink) ? itemData.shrink : SHRINK;
                        totalRatio += ratio;
                        totalWeightedShrink += shrink * size;
                        totalBaseSize += size
                    }, this));
                    var freeSpaceSize = this._boxSize() - totalBaseSize;
                    var itemSize = $.proxy(function($item) {
                            var itemData = $item.data(BOX_ITEM_DATA_KEY),
                                size = this._baseSize($item),
                                factor = freeSpaceSize >= 0 ? itemData.ratio || 0 : (commonUtils.isDefined(itemData.shrink) ? itemData.shrink : SHRINK) * size,
                                totalFactor = freeSpaceSize >= 0 ? totalRatio : totalWeightedShrink,
                                shift = totalFactor ? Math.round(freeSpaceSize * factor / totalFactor) : 0;
                            return size + shift
                        }, this);
                    var totalItemSize = 0;
                    $.each($items, function(_, item) {
                        var $item = $(item),
                            itemData = $(item).data(BOX_ITEM_DATA_KEY),
                            size = itemSize($item);
                        totalItemSize += size;
                        $item.css(MAXSIZE_MAP[direction], itemData.maxSize || "none").css(MINSIZE_MAP[direction], itemData.minSize || "0").css(FALLBACK_MAIN_SIZE_MAP[direction], size);
                        $item.addClass(FALLBACK_BOX_ITEM)
                    });
                    this.totalItemSize = totalItemSize
                },
                _baseSize: function(item) {
                    var itemData = $(item).data(BOX_ITEM_DATA_KEY);
                    return itemData.baseSize == null ? 0 : itemData.baseSize === "auto" ? this._contentSize(item) : this._parseSize(itemData.baseSize)
                },
                _contentSize: function(item) {
                    return $(item)[FALLBACK_MAIN_SIZE_MAP[this._option("direction")]]()
                },
                _parseSize: function(size) {
                    return String(size).match(/.+%$/) ? 0.01 * parseFloat(size) * this._boxSizeValue : size
                },
                _boxSize: function(value) {
                    if (!arguments.length) {
                        this._boxSizeValue = this._boxSizeValue || this._totalBaseSize();
                        return this._boxSizeValue
                    }
                    this._boxSizeValue = value
                },
                _totalBaseSize: function() {
                    var result = 0;
                    $.each(this._$items, $.proxy(function(_, item) {
                        result += this._baseSize(item)
                    }, this));
                    return result
                },
                initSize: function() {
                    this._boxSize(this._$element[FALLBACK_MAIN_SIZE_MAP[this._option("direction")]]())
                },
                update: function() {
                    if (!this._$items || this._$element.is(":hidden"))
                        return;
                    this._$items.detach();
                    this.initSize();
                    this._$element.append(this._$items);
                    this.renderItems(this._$items);
                    this.renderAlign();
                    this.renderCrossAlign();
                    var element = this._$element.get(0);
                    this._$items.find(BOX_SELECTOR).each(function() {
                        if (element === $(this).parent().closest(BOX_SELECTOR).get(0))
                            $(this).triggerHandler(UPDATE_EVENT)
                    })
                }
            });
        registerComponent("dxBox", ui, ui.CollectionWidget.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        direction: "row",
                        align: "start",
                        crossAlign: "stretch",
                        activeStateEnabled: false,
                        focusStateEnabled: false,
                        _layoutStrategy: "flex",
                        _queue: undefined
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function() {
                                var device = devices.real();
                                var isOldAndroid = device.platform === "android" && (device.version[0] < 4 || device.version[0] === 4 && device.version[1] < 4),
                                    isOldIos = device.platform === "ios" && device.version[0] < 7;
                                return device.platform === "win" || browser["msie"] || isOldAndroid || isOldIos
                            },
                            options: {_layoutStrategy: "fallback"}
                        }])
            },
            _itemClass: function() {
                return BOX_ITEM_CLASS
            },
            _itemDataKey: function() {
                return BOX_ITEM_DATA_KEY
            },
            _itemElements: function() {
                return this._itemContainer().children(this._itemSelector())
            },
            _init: function() {
                this.callBase();
                this.element().addClass(BOX_CLASS + "-" + this.option("_layoutStrategy"));
                this._initLayout();
                this._initBoxQueue()
            },
            _initLayout: function() {
                this._layout = this.option("_layoutStrategy") === "fallback" ? new FallbackLayoutStrategy(this.element(), $.proxy(this.option, this)) : new FlexLayoutStrategy(this.element(), $.proxy(this.option, this))
            },
            _initBoxQueue: function() {
                this._queue = this.option("_queue") || []
            },
            _queueIsNotEmpty: function() {
                return this.option("_queue") ? false : !!this._queue.length
            },
            _pushItemToQueue: function($item, config) {
                this._queue.push({
                    $item: $item,
                    config: config
                })
            },
            _shiftItemFromQueue: function() {
                return this._queue.shift()
            },
            _render: function() {
                this.callBase();
                this.element().addClass(BOX_CLASS);
                this._renderBox()
            },
            _renderBox: function() {
                this._layout.renderBox();
                this._layout.renderAlign();
                this._layout.renderCrossAlign()
            },
            _renderItems: function(items) {
                this._layout.initSize();
                this.callBase(items);
                while (this._queueIsNotEmpty()) {
                    var item = this._shiftItemFromQueue();
                    this._createComponent(item.$item, "dxBox", $.extend({
                        _layoutStrategy: this.option("_layoutStrategy"),
                        itemTemplate: this.option("itemTemplate"),
                        itemHoldTimeout: this.option("itemHoldTimeout"),
                        onItemHold: this.option("onItemHold"),
                        onItemClick: this.option("onItemClick"),
                        onItemContextMenu: this.option("onItemContextMenu"),
                        onItemRendered: this.option("onItemRendered"),
                        _queue: this._queue
                    }, item.config))
                }
                this._layout.renderItems(this._itemElements());
                clearTimeout(this._updateTimer);
                this._updateTimer = setTimeout($.proxy(function() {
                    if (!this._isUpdated)
                        this._layout.update();
                    this._isUpdated = false;
                    this._updateTimer = null
                }, this))
            },
            _postprocessRenderItem: function(args) {
                var boxConfig = args.itemData.box;
                if (!boxConfig)
                    return;
                this._pushItemToQueue(args.itemContent, boxConfig)
            },
            _createItemByTemplate: function(itemTemplate, args) {
                return args.item.box ? itemTemplate.source() : this.callBase(itemTemplate, args)
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._dimensionChanged()
            },
            _dimensionChanged: function() {
                if (this._updateTimer)
                    return;
                this._isUpdated = true;
                this._layout.update()
            },
            _dispose: function() {
                clearTimeout(this._updateTimer);
                this.callBase.apply(this, arguments)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"_layoutStrategy":
                    case"_queue":
                    case"direction":
                        this._invalidate();
                        break;
                    case"align":
                        this._layout.renderAlign();
                        break;
                    case"crossAlign":
                        this._layout.renderCrossAlign();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            repaint: function() {
                this._dimensionChanged()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.responsiveBox.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            errors = DevExpress.require("/ui/ui.errors"),
            registerComponent = DX.require("/componentRegistrator");
        var RESPONSIVE_BOX_CLASS = "dx-responsivebox",
            BOX_ITEM_CLASS = "dx-box-item",
            BOX_ITEM_DATA_KEY = "dxBoxItemData";
        var DEFAULT_SCREEN_FACTOR_FUNC = function(width) {
                if (width < 768)
                    return "xs";
                else if (width < 992)
                    return "sm";
                else if (width < 1200)
                    return "md";
                else
                    return "lg"
            };
        registerComponent("dxResponsiveBox", ui, ui.CollectionWidget.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        rows: [],
                        cols: [],
                        screenByWidth: DEFAULT_SCREEN_FACTOR_FUNC,
                        singleColumnScreen: "xs",
                        height: "100%",
                        width: "100%",
                        activeStateEnabled: false,
                        focusStateEnabled: false,
                        onLayoutChanged: null,
                        currentScreenFactor: undefined,
                        _layoutStrategy: undefined
                    })
            },
            _initOptions: function(options) {
                if (options.screenByWidth)
                    this.option("singleColumnScreen", options.screenByWidth(0));
                this.callBase(options)
            },
            _init: function() {
                this.callBase();
                this._initLayoutChangedAction()
            },
            _initLayoutChangedAction: function() {
                this._layoutChangedAction = this._createActionByOption("onLayoutChanged", {excludeValidators: ["disabled", "readonly"]})
            },
            _itemClass: function() {
                return BOX_ITEM_CLASS
            },
            _itemDataKey: function() {
                return BOX_ITEM_DATA_KEY
            },
            _render: function() {
                this.callBase();
                this.element().addClass(RESPONSIVE_BOX_CLASS);
                this._updateRootBox()
            },
            _updateRootBox: function() {
                clearTimeout(this._updateTimer);
                this._updateTimer = setTimeout($.proxy(function() {
                    if (this._$root)
                        this._$root.trigger("dxupdate")
                }, this))
            },
            _renderItems: function() {
                this.option("currentScreenFactor", this._getCurrentScreen());
                this._screenItems = this._itemsByScreen();
                this._prepareGrid();
                this._spreadItems();
                this._layoutItems();
                this._linkNodeToItem()
            },
            _prepareGrid: function() {
                var grid = this._grid = [];
                this._prepareRowsAndCols();
                $.each(this._rows, $.proxy(function() {
                    var row = [];
                    grid.push(row);
                    $.each(this._cols, $.proxy(function() {
                        row.push(this._createEmptyCell())
                    }, this))
                }, this))
            },
            _prepareRowsAndCols: function() {
                if (this._isSingleColumnScreen()) {
                    this._prepareSingleColumnScreenItems();
                    this._rows = this._defaultSizeConfig(this._screenItems.length);
                    this._cols = this._defaultSizeConfig(1)
                }
                else {
                    this._rows = this._sizesByScreen(this.option("rows"));
                    this._cols = this._sizesByScreen(this.option("cols"))
                }
            },
            _isSingleColumnScreen: function() {
                return this._screenRegExp().test(this.option("singleColumnScreen")) || !this.option("rows").length || !this.option("cols").length
            },
            _prepareSingleColumnScreenItems: function() {
                this._screenItems.sort(function(item1, item2) {
                    return item1.location.row - item2.location.row || item1.location.col - item2.location.col
                });
                $.each(this._screenItems, function(index, item) {
                    $.extend(item.location, {
                        row: index,
                        col: 0,
                        rowspan: 1,
                        colspan: 1
                    })
                })
            },
            _sizesByScreen: function(sizeConfigs) {
                return $.map(this._filterByScreen(sizeConfigs), $.proxy(function(sizeConfig) {
                        return $.extend(this._defaultSizeConfig(), sizeConfig)
                    }, this))
            },
            _defaultSizeConfig: function(size) {
                var defaultSizeConfig = {
                        ratio: 1,
                        baseSize: 0,
                        minSize: 0,
                        maxSize: 0
                    };
                if (!arguments.length)
                    return defaultSizeConfig;
                var result = [];
                for (var i = 0; i < size; i++)
                    result.push(defaultSizeConfig);
                return result
            },
            _filterByScreen: function(items) {
                var screenRegExp = this._screenRegExp();
                return $.grep(items, function(item) {
                        return !item.screen || screenRegExp.test(item.screen)
                    })
            },
            _screenRegExp: function() {
                var screen = this._getCurrentScreen();
                return new RegExp("(^|\\s)" + screen + "($|\\s)", "i")
            },
            _getCurrentScreen: function() {
                var width = this._screenWidth();
                return this.option("screenByWidth")(width)
            },
            _screenWidth: function() {
                return $(window).width()
            },
            _createEmptyCell: function() {
                return {
                        item: {},
                        location: {
                            colspan: 1,
                            rowspan: 1
                        }
                    }
            },
            _spreadItems: function() {
                $.each(this._screenItems, $.proxy(function(_, itemInfo) {
                    var location = itemInfo.location || {};
                    var itemCol = location.col;
                    var itemRow = location.row;
                    var row = this._grid[itemRow];
                    var itemCell = row && row[itemCol];
                    this._occupyCells(itemCell, itemInfo)
                }, this))
            },
            _itemsByScreen: function() {
                return $.map(this.option("items"), $.proxy(function(item) {
                        var locations = item.location || {};
                        locations = $.isPlainObject(locations) ? [locations] : locations;
                        return $.map(this._filterByScreen(locations), function(location) {
                                return {
                                        item: item,
                                        location: $.extend({
                                            rowspan: 1,
                                            colspan: 1
                                        }, location)
                                    }
                            })
                    }, this))
            },
            _occupyCells: function(itemCell, itemInfo) {
                if (!itemCell || this._isItemCellOccupied(itemCell, itemInfo))
                    return;
                $.extend(itemCell, itemInfo);
                this._markSpanningCell(itemCell)
            },
            _isItemCellOccupied: function(itemCell, itemInfo) {
                if (!$.isEmptyObject(itemCell.item))
                    return true;
                var result = false;
                this._loopOverSpanning(itemInfo.location, function(cell) {
                    result = result || !$.isEmptyObject(cell.item)
                });
                return result
            },
            _loopOverSpanning: function(location, callback) {
                var rowEnd = location.row + location.rowspan - 1;
                var colEnd = location.col + location.colspan - 1;
                var boundRowEnd = Math.min(rowEnd, this._rows.length - 1);
                var boundColEnd = Math.min(colEnd, this._cols.length - 1);
                location.rowspan -= rowEnd - boundRowEnd;
                location.colspan -= colEnd - boundColEnd;
                for (var rowIndex = location.row; rowIndex <= boundRowEnd; rowIndex++)
                    for (var colIndex = location.col; colIndex <= boundColEnd; colIndex++)
                        if (rowIndex !== location.row || colIndex !== location.col)
                            callback(this._grid[rowIndex][colIndex])
            },
            _markSpanningCell: function(itemCell) {
                this._loopOverSpanning(itemCell.location, function(cell) {
                    $.extend(cell, {
                        item: itemCell.item,
                        spanningCell: itemCell
                    })
                })
            },
            _linkNodeToItem: function() {
                $.each(this._itemElements(), function(_, itemNode) {
                    var $item = $(itemNode),
                        item = $item.data(BOX_ITEM_DATA_KEY);
                    if (!item.box)
                        item.node = $item.children()
                })
            },
            _layoutItems: function() {
                var rowsCount = this._grid.length;
                var colsCount = rowsCount && this._grid[0].length;
                if (!rowsCount && !colsCount)
                    return;
                var result = this._layoutBlock({
                        direction: "col",
                        row: {
                            start: 0,
                            end: rowsCount - 1
                        },
                        col: {
                            start: 0,
                            end: colsCount - 1
                        }
                    });
                var rootBox = this._prepareBoxConfig(result.box || {
                        direction: "row",
                        items: [$.extend(result, {ratio: 1})]
                    });
                $.extend(rootBox, this._rootBoxConfig());
                this._$root = $("<div>").appendTo(this._itemContainer());
                this._createComponent(this._$root, "dxBox", rootBox)
            },
            _rootBoxConfig: function(config) {
                return $.extend({
                        width: "100%",
                        height: "100%",
                        itemTemplate: this.option("itemTemplate"),
                        itemHoldTimeout: this.option("itemHoldTimeout"),
                        onItemHold: this.option("onItemHold"),
                        onItemClick: this.option("onItemClick"),
                        onItemContextMenu: this.option("onItemContextMenu"),
                        onItemRendered: this.option("onItemRendered")
                    }, {_layoutStrategy: this.option("_layoutStrategy")})
            },
            _prepareBoxConfig: function(config) {
                return $.extend(config || {}, {crossAlign: "stretch"})
            },
            _layoutBlock: function(options) {
                if (this._isSingleItem(options))
                    return this._itemByCell(options.row.start, options.col.start);
                return this._layoutDirection(options)
            },
            _isSingleItem: function(options) {
                var firstCellLocation = this._grid[options.row.start][options.col.start].location;
                var isItemRowSpanned = options.row.end - options.row.start === firstCellLocation.rowspan - 1;
                var isItemColSpanned = options.col.end - options.col.start === firstCellLocation.colspan - 1;
                return isItemRowSpanned && isItemColSpanned
            },
            _itemByCell: function(rowIndex, colIndex) {
                var itemCell = this._grid[rowIndex][colIndex];
                return itemCell.spanningCell ? null : itemCell.item
            },
            _layoutDirection: function(options) {
                var items = [];
                var direction = options.direction;
                var crossDirection = this._crossDirection(direction);
                var block;
                while (block = this._nextBlock(options)) {
                    if (this._isBlockIndivisible(options.prevBlockOptions, block))
                        throw errors.Error("E1025");
                    var item = this._layoutBlock({
                            direction: crossDirection,
                            row: block.row,
                            col: block.col,
                            prevBlockOptions: options
                        });
                    if (item) {
                        $.extend(item, this._blockSize(block, crossDirection));
                        items.push(item)
                    }
                    options[crossDirection].start = block[crossDirection].end + 1
                }
                return {box: this._prepareBoxConfig({
                            direction: direction,
                            items: items
                        })}
            },
            _isBlockIndivisible: function(options, block) {
                return options && options.col.start === block.col.start && options.col.end === block.col.end && options.row.start === block.row.start && options.row.end === block.row.end
            },
            _crossDirection: function(direction) {
                return direction === "col" ? "row" : "col"
            },
            _nextBlock: function(options) {
                var direction = options.direction;
                var crossDirection = this._crossDirection(direction);
                var startIndex = options[direction].start;
                var endIndex = options[direction].end;
                var crossStartIndex = options[crossDirection].start;
                if (crossStartIndex > options[crossDirection].end)
                    return null;
                var crossSpan = 1;
                for (var crossIndex = crossStartIndex; crossIndex < crossStartIndex + crossSpan; crossIndex++) {
                    var lineCrossSpan = 1;
                    for (var index = startIndex; index <= endIndex; index++) {
                        var cell = this._cellByDirection(direction, index, crossIndex);
                        lineCrossSpan = Math.max(lineCrossSpan, cell.location[crossDirection + "span"])
                    }
                    var lineCrossEndIndex = crossIndex + lineCrossSpan;
                    var crossEndIndex = crossStartIndex + crossSpan;
                    if (lineCrossEndIndex > crossEndIndex)
                        crossSpan += lineCrossEndIndex - crossEndIndex
                }
                var result = {};
                result[direction] = {
                    start: startIndex,
                    end: endIndex
                };
                result[crossDirection] = {
                    start: crossStartIndex,
                    end: crossStartIndex + crossSpan - 1
                };
                return result
            },
            _cellByDirection: function(direction, index, crossIndex) {
                return direction === "col" ? this._grid[crossIndex][index] : this._grid[index][crossIndex]
            },
            _blockSize: function(block, direction) {
                var sizeConfigs = direction === "row" ? this._rows : this._cols;
                var result = {
                        ratio: 0,
                        baseSize: 0,
                        minSize: 0,
                        maxSize: 0
                    };
                for (var index = block[direction].start; index <= block[direction].end; index++) {
                    var sizeConfig = sizeConfigs[index];
                    result.ratio += sizeConfig.ratio;
                    result.baseSize += sizeConfig.baseSize;
                    result.minSize += sizeConfig.minSize;
                    result.maxSize += sizeConfig.maxSize
                }
                result.minSize = result.minSize ? result.minSize : "auto";
                result.maxSize = result.maxSize ? result.maxSize : "auto";
                this._isSingleColumnScreen() && (result.baseSize = 'auto');
                return result
            },
            _update: function() {
                if (this._getCurrentScreen() === this.option("currentScreenFactor"))
                    return;
                var $existingRoot = this._$root;
                this._renderItems();
                $existingRoot && $existingRoot.detach();
                this._saveAssistantRoot($existingRoot);
                this._layoutChangedAction();
                this._updateRootBox()
            },
            _saveAssistantRoot: function($root) {
                this._assistantRoots = this._assistantRoots || [];
                this._assistantRoots.push($root)
            },
            _dispose: function() {
                clearTimeout(this._updateTimer);
                this._cleanUnusedRoots();
                this.callBase.apply(this, arguments)
            },
            _cleanUnusedRoots: function() {
                if (!this._assistantRoots)
                    return;
                $.each(this._assistantRoots, function() {
                    $(this).remove()
                })
            },
            _clearItemNodeTemplates: function() {
                $.each(this.option("items"), function() {
                    delete this.node
                })
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"rows":
                    case"cols":
                    case"screenByWidth":
                    case"_layoutStrategy":
                    case"singleColumnScreen":
                        this._invalidate();
                        break;
                    case"width":
                    case"height":
                        this.callBase(args);
                        this._update();
                        break;
                    case"onLayoutChanged":
                        this._initLayoutChangedAction();
                        break;
                    case"itemTemplate":
                        this._clearItemNodeTemplates();
                        this.callBase(args);
                        break;
                    case"currentScreenFactor":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _dimensionChanged: function() {
                this._update()
            },
            repaint: function() {
                this._update()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.button.js */
    DevExpress.define("/ui/widgets/ui.button", ["jquery", "/ui/uiNamespace", "/utils/utils.icon", "/devices", "/componentRegistrator", "/ui/ui.validationMixin", "/ui/ui.widget", "/utils/utils.inkRipple", "/ui/events/ui.events.utils"], function($, uiNamespace, iconUtils, devices, registerComponent, ValidationMixin, Widget, inkRipple, eventUtils) {
        var BUTTON_CLASS = "dx-button",
            BUTTON_CONTENT_CLASS = "dx-button-content",
            BUTTON_HAS_TEXT_CLASS = "dx-button-has-text",
            BUTTON_HAS_ICON_CLASS = "dx-button-has-icon",
            TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper",
            ANONYMOUS_TEMPLATE_NAME = "content",
            BUTTON_FEEDBACK_HIDE_TIMEOUT = 100;
        var Button = Widget.inherit({
                _supportedKeys: function() {
                    var that = this,
                        click = function(e) {
                            e.preventDefault();
                            that._executeClickAction(e)
                        };
                    return $.extend(this.callBase(), {
                            space: click,
                            enter: click
                        })
                },
                _setDeprecatedOptions: function() {
                    this.callBase();
                    $.extend(this._deprecatedOptions, {iconSrc: {
                            since: "15.1",
                            alias: "icon"
                        }})
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            hoverStateEnabled: true,
                            onClick: null,
                            type: "normal",
                            text: "",
                            icon: "",
                            validationGroup: undefined,
                            activeStateEnabled: true,
                            template: "content",
                            useInkRipple: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }, {
                                device: {platform: "android"},
                                options: {useInkRipple: true}
                            }])
                },
                _getAnonymousTemplateName: function() {
                    return ANONYMOUS_TEMPLATE_NAME
                },
                _init: function() {
                    this.callBase();
                    this._feedbackHideTimeout = BUTTON_FEEDBACK_HIDE_TIMEOUT
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(BUTTON_CLASS);
                    this._renderType();
                    this.option("useInkRipple") && this._renderInkRipple();
                    this._renderClick();
                    this.setAria("role", "button");
                    this._updateAriaLabel()
                },
                _renderInkRipple: function() {
                    var isOnlyIconButton = !this.option("text") && this.option("icon") || this.option("type") === "back",
                        config = {};
                    if (isOnlyIconButton)
                        $.extend(config, {
                            waveSizeCoefficient: 1,
                            isCentered: true
                        });
                    this._inkRipple = inkRipple.render(config)
                },
                _toggleActiveState: function($element, value, e) {
                    this.callBase.apply(this, arguments);
                    if (!this._inkRipple)
                        return;
                    var config = {
                            element: $element,
                            jQueryEvent: e
                        };
                    if (value)
                        this._inkRipple.renderWave(config);
                    else
                        this._inkRipple.removeWave(config)
                },
                _renderContentImpl: function() {
                    var $content = $("<div>").addClass(BUTTON_CONTENT_CLASS),
                        data = this._getContentData();
                    this.element().empty();
                    this.element().append($content);
                    this.element().toggleClass(BUTTON_HAS_ICON_CLASS, !!data.icon);
                    this.element().toggleClass(BUTTON_HAS_TEXT_CLASS, !!data.text);
                    var template = this._getTemplateByOption("template");
                    var $result = template.render(data, $content);
                    if ($result.hasClass(TEMPLATE_WRAPPER_CLASS)) {
                        $content.replaceWith($result);
                        $content = $result;
                        $content.addClass(BUTTON_CONTENT_CLASS)
                    }
                },
                _getContentData: function() {
                    var icon = this.option("icon"),
                        text = this.option("text"),
                        back = this.option("type") === "back";
                    if (back && !icon)
                        icon = "back";
                    return {
                            icon: icon,
                            text: text
                        }
                },
                _renderClick: function() {
                    var that = this,
                        eventName = eventUtils.addNamespace("dxclick", this.NAME);
                    this._clickAction = this._createActionByOption("onClick");
                    this.element().off(eventName).on(eventName, function(e) {
                        that._executeClickAction(e)
                    })
                },
                _executeClickAction: function(e) {
                    this._clickAction({
                        jQueryEvent: e,
                        validationGroup: DevExpress.validationEngine.getGroupConfig(this._findGroup())
                    })
                },
                _updateAriaLabel: function() {
                    var icon = this.option("icon"),
                        text = this.option("text");
                    if (iconUtils.getImageSourceType(icon) === "image")
                        if (icon.indexOf("base64") === -1)
                            icon = icon.replace(/.+\/([^\.]+)\..+$/, "$1");
                        else
                            icon = "Base64";
                    var ariaLabel = text || icon;
                    this.setAria("label", $.trim(ariaLabel))
                },
                _renderType: function() {
                    var type = this.option("type");
                    if (type)
                        this.element().addClass("dx-button-" + type)
                },
                _refreshType: function(prevType) {
                    var type = this.option("type");
                    prevType && this.element().removeClass("dx-button-" + prevType).addClass("dx-button-" + type);
                    if (!this.element().hasClass("dx-button-has-icon") && type === "back")
                        this._renderContentImpl()
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"onClick":
                            this._renderClick();
                            break;
                        case"icon":
                        case"text":
                            this._renderContentImpl();
                            this._updateAriaLabel();
                            break;
                        case"type":
                            this._refreshType(args.previousValue);
                            this._updateAriaLabel();
                            break;
                        case"template":
                            this._renderContentImpl();
                            break;
                        case"useInkRipple":
                            this._invalidate();
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            }).include(ValidationMixin);
        registerComponent("dxButton", uiNamespace, Button);
        return Button
    });
    DevExpress.require(["/ui/widgets/ui.button"]);
    /*! Module widgets-base, file ui.checkBox.js */
    DevExpress.define("/ui/widgets/ui.checkBox", ["jquery", "/ui/uiNamespace", "/devices", "/utils/utils.inkRipple", "/ui/ui.editor", "/componentRegistrator", "/ui/events/ui.events.utils"], function($, uiNamespace, devices, inkRipple, Editor, registerComponent, eventUtils) {
        var CHECKBOX_CLASS = "dx-checkbox",
            CHECKBOX_ICON_CLASS = "dx-checkbox-icon",
            CHECKBOX_CHECKED_CLASS = "dx-checkbox-checked",
            CHECKBOX_CONTAINER_CLASS = "dx-checkbox-container",
            CHECKBOX_TEXT_CLASS = "dx-checkbox-text",
            CHECKBOX_TEXT_SELECTOR = ".dx-checkbox-text",
            CHECKBOX_HAS_TEXT_CLASS = "dx-checkbox-has-text",
            CHECKBOX_INDETERMINATE_CLASS = "dx-checkbox-indeterminate",
            CHECKBOX_FEEDBACK_HIDE_TIMEOUT = 100;
        var CheckBox = Editor.inherit({
                _supportedKeys: function() {
                    var click = function(e) {
                            e.preventDefault();
                            this._clickAction({jQueryEvent: e})
                        };
                    return $.extend(this.callBase(), {space: click})
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            hoverStateEnabled: true,
                            activeStateEnabled: true,
                            value: false,
                            text: "",
                            useInkRipple: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }, {
                                device: {platform: "android"},
                                options: {useInkRipple: true}
                            }])
                },
                _init: function() {
                    this.callBase();
                    this._feedbackHideTimeout = CHECKBOX_FEEDBACK_HIDE_TIMEOUT
                },
                _render: function() {
                    this.callBase();
                    this._$container = $("<div>").addClass(CHECKBOX_CONTAINER_CLASS);
                    this.element().addClass(CHECKBOX_CLASS).append(this._$container);
                    this.setAria("role", "checkbox");
                    this._renderClick();
                    this._renderValue();
                    this._renderIcon();
                    this._renderText();
                    this.option("useInkRipple") && this._renderInkRipple()
                },
                _renderInkRipple: function() {
                    this._inkRipple = inkRipple.render({
                        waveSizeCoefficient: 3.43,
                        isCentered: true
                    })
                },
                _renderInkWave: function(element, jQueryEvent, doRender) {
                    if (!this._inkRipple)
                        return;
                    var config = {
                            element: element,
                            jQueryEvent: jQueryEvent
                        };
                    if (doRender)
                        this._inkRipple.renderWave(config);
                    else
                        this._inkRipple.removeWave(config)
                },
                _updateFocusState: function(e, value) {
                    this.callBase.apply(this, arguments);
                    this._renderInkWave(this._$icon, e, value)
                },
                _toggleActiveState: function($element, value, e) {
                    this.callBase.apply(this, arguments);
                    this._renderInkWave(this._$icon, e, value)
                },
                _renderDimensions: function() {
                    this.callBase()
                },
                _renderIcon: function() {
                    this._$icon = $("<span>").addClass(CHECKBOX_ICON_CLASS).prependTo(this._$container)
                },
                _renderText: function() {
                    this._$text = this._$container.find(CHECKBOX_TEXT_SELECTOR);
                    if (!this.option("text")) {
                        if (this._$text) {
                            this._$text.remove();
                            this.element().removeClass(CHECKBOX_HAS_TEXT_CLASS)
                        }
                        return
                    }
                    if (!this._$text.length)
                        this._$text = $("<span>").addClass(CHECKBOX_TEXT_CLASS);
                    this._$text.text(this.option("text"));
                    this._$container.append(this._$text);
                    this.element().addClass(CHECKBOX_HAS_TEXT_CLASS)
                },
                _renderClick: function() {
                    var eventName = eventUtils.addNamespace("dxclick", this.NAME);
                    this._clickAction = this._createAction(this._clickHandler);
                    this.element().off(eventName).on(eventName, $.proxy(function(e) {
                        this._clickAction({jQueryEvent: e})
                    }, this))
                },
                _clickHandler: function(args) {
                    var that = args.component;
                    that._saveValueChangeEvent(args.jQueryEvent);
                    that.option("value", !that.option("value"))
                },
                _renderValue: function() {
                    var $element = this.element(),
                        checked = this.option("value"),
                        indeterminate = checked === undefined;
                    $element.toggleClass(CHECKBOX_CHECKED_CLASS, Boolean(checked));
                    $element.toggleClass(CHECKBOX_INDETERMINATE_CLASS, indeterminate);
                    this.setAria("checked", indeterminate ? "mixed" : checked || "false")
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"useInkRipple":
                            this._invalidate();
                            break;
                        case"value":
                            this._renderValue();
                            this.callBase(args);
                            break;
                        case"text":
                            this._renderText();
                            this._renderDimensions();
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        registerComponent("dxCheckBox", uiNamespace, CheckBox);
        return CheckBox
    });
    DevExpress.require(["/ui/widgets/ui.checkBox"]);
    /*! Module widgets-base, file ui.switch.js */
    DevExpress.define("/ui/widgets/ui.switch", ["jquery", "/devices", "/utils/utils.inkRipple", "/componentRegistrator", "/ui/ui.editor", "/ui/uiNamespace", "/ui/events/ui.events.utils", "/ui/events/ui.events.emitter.feedback"], function($, devices, inkRipple, registerComponent, Editor, uiNamespace, eventUtils, feedbackEvents) {
        var fx = DevExpress.fx;
        var SWITCH_CLASS = "dx-switch",
            SWITCH_WRAPPER_CLASS = SWITCH_CLASS + "-wrapper",
            SWITCH_CONTAINER_CLASS = SWITCH_CLASS + "-container",
            SWITCH_INNER_CLASS = SWITCH_CLASS + "-inner",
            SWITCH_HANDLE_CLASS = SWITCH_CLASS + "-handle",
            SWITCH_ON_VALUE_CLASS = SWITCH_CLASS + "-on-value",
            SWITCH_ON_CLASS = SWITCH_CLASS + "-on",
            SWITCH_OFF_CLASS = SWITCH_CLASS + "-off",
            SWITCH_ANIMATION_DURATION = 100;
        var Switch = Editor.inherit({
                _supportedKeys: function() {
                    var isRTL = this.option("rtlEnabled");
                    var click = function(e) {
                            e.preventDefault();
                            this._clickAction({jQueryEvent: e})
                        },
                        move = function(value, e) {
                            e.preventDefault();
                            e.stopPropagation();
                            this._animateValue(value)
                        };
                    return $.extend(this.callBase(), {
                            space: click,
                            enter: click,
                            leftArrow: $.proxy(move, this, isRTL ? true : false),
                            rightArrow: $.proxy(move, this, isRTL ? false : true)
                        })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            hoverStateEnabled: true,
                            activeStateEnabled: true,
                            onText: Globalize.localize("dxSwitch-onText"),
                            offText: Globalize.localize("dxSwitch-offText"),
                            value: false,
                            useInkRipple: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }, {
                                device: {platform: "android"},
                                options: {useInkRipple: true}
                            }])
                },
                _init: function() {
                    this.callBase();
                    this._animating = false
                },
                _render: function() {
                    var element = this.element();
                    this._$switchInner = $("<div>").addClass(SWITCH_INNER_CLASS);
                    this._$handle = $("<div>").addClass(SWITCH_HANDLE_CLASS).appendTo(this._$switchInner);
                    this.option("useInkRipple") && this._renderInkRipple();
                    this._$labelOn = $("<div>").addClass(SWITCH_ON_CLASS).prependTo(this._$switchInner);
                    this._$labelOff = $("<div>").addClass(SWITCH_OFF_CLASS).appendTo(this._$switchInner);
                    this._$switchContainer = $("<div>").addClass(SWITCH_CONTAINER_CLASS).append(this._$switchInner);
                    this._$switchWrapper = $("<div>").addClass(SWITCH_WRAPPER_CLASS).append(this._$switchContainer);
                    element.addClass(SWITCH_CLASS).append(this._$switchWrapper);
                    this.setAria("role", "button");
                    this._createComponent(element, "dxSwipeable", {
                        elastic: false,
                        immediate: true,
                        onStart: $.proxy(this._swipeStartHandler, this),
                        onUpdated: $.proxy(this._swipeUpdateHandler, this),
                        onEnd: $.proxy(this._swipeEndHandler, this),
                        itemSizeFunc: $.proxy(this._getMarginBound, this)
                    });
                    this._renderLabels();
                    this.callBase();
                    this._updateMarginBound();
                    this._renderValue();
                    this._renderClick()
                },
                _renderInkRipple: function() {
                    this._inkRipple = inkRipple.render({
                        waveSizeCoefficient: 2.4,
                        isCentered: true
                    })
                },
                _renderInkWave: function(element, jQueryEvent, doRender) {
                    if (!this._inkRipple)
                        return;
                    var config = {
                            element: element,
                            jQueryEvent: jQueryEvent
                        };
                    if (doRender)
                        this._inkRipple.renderWave(config);
                    else
                        this._inkRipple.removeWave(config)
                },
                _updateFocusState: function(e, value) {
                    this.callBase.apply(this, arguments);
                    this._renderInkWave(this._$handle, e, value)
                },
                _toggleActiveState: function($element, value, e) {
                    this.callBase.apply(this, arguments);
                    this._renderInkWave(this._$handle, e, value)
                },
                _updateMarginBound: function() {
                    this._marginBound = this._$switchContainer.outerWidth(true) - this._$handle.outerWidth()
                },
                _getMarginBound: function() {
                    return this._marginBound
                },
                _marginDirection: function() {
                    return this.option("rtlEnabled") ? "Right" : "Left"
                },
                _offsetDirection: function() {
                    return this.option("rtlEnabled") ? -1 : 1
                },
                _renderPosition: function(state, swipeOffset) {
                    var stateInt = state ? 1 : 0,
                        marginDirection = this._marginDirection(),
                        resetMarginDirection = marginDirection === "Left" ? "Right" : "Left";
                    this._$switchInner.css("margin" + marginDirection, this._getMarginBound() * (stateInt + swipeOffset - 1));
                    this._$switchInner.css("margin" + resetMarginDirection, 0)
                },
                _validateValue: function() {
                    var check = this.option("value");
                    if (typeof check !== "boolean")
                        this._options["value"] = !!check
                },
                _renderClick: function() {
                    var eventName = eventUtils.addNamespace("dxclick", this.NAME);
                    this._clickAction = this._createAction($.proxy(this._clickHandler, this));
                    this.element().off(eventName).on(eventName, $.proxy(function(e) {
                        this._clickAction({jQueryEvent: e})
                    }, this))
                },
                _clickHandler: function(args) {
                    this.time = new Date;
                    var e = args.jQueryEvent;
                    this._saveValueChangeEvent(e);
                    if (this._animating || this._swiping)
                        return;
                    this._animateValue(!this.option("value"))
                },
                _animateValue: function(value) {
                    var startValue = this.option("value"),
                        endValue = value;
                    if (startValue === endValue)
                        return;
                    this._animating = true;
                    var that = this,
                        marginDirection = this._marginDirection(),
                        resetMarginDirection = marginDirection === "Left" ? "Right" : "Left",
                        fromConfig = {},
                        toConfig = {};
                    this._$switchInner.css("margin" + resetMarginDirection, 0);
                    fromConfig["margin" + marginDirection] = (Number(startValue) - 1) * this._getMarginBound();
                    toConfig["margin" + marginDirection] = (Number(endValue) - 1) * this._getMarginBound();
                    fx.animate(this._$switchInner, {
                        from: fromConfig,
                        to: toConfig,
                        duration: SWITCH_ANIMATION_DURATION,
                        complete: function() {
                            that._animating = false;
                            that.option("value", endValue)
                        }
                    })
                },
                _swipeStartHandler: function(e) {
                    var state = this.option("value"),
                        rtlEnabled = this.option("rtlEnabled"),
                        maxOffOffset = rtlEnabled ? 0 : 1,
                        maxOnOffset = rtlEnabled ? 1 : 0;
                    e.jQueryEvent.maxLeftOffset = state ? maxOffOffset : maxOnOffset;
                    e.jQueryEvent.maxRightOffset = state ? maxOnOffset : maxOffOffset;
                    this._swiping = true;
                    this._feedbackDeferred = $.Deferred();
                    feedbackEvents.lock(this._feedbackDeferred);
                    this._toggleActiveState(this.element(), this.option("activeStateEnabled"))
                },
                _swipeUpdateHandler: function(e) {
                    this._renderPosition(this.option("value"), this._offsetDirection() * e.jQueryEvent.offset)
                },
                _swipeEndHandler: function(e) {
                    var that = this,
                        offsetDirection = this._offsetDirection(),
                        toConfig = {};
                    toConfig["margin" + this._marginDirection()] = this._getMarginBound() * (that.option("value") + offsetDirection * e.jQueryEvent.targetOffset - 1);
                    fx.animate(this._$switchInner, {
                        to: toConfig,
                        duration: SWITCH_ANIMATION_DURATION,
                        complete: function() {
                            that._swiping = false;
                            var pos = that.option("value") + offsetDirection * e.jQueryEvent.targetOffset;
                            that.option("value", Boolean(pos));
                            that._feedbackDeferred.resolve();
                            that._toggleActiveState(that.element(), false)
                        }
                    })
                },
                _renderValue: function() {
                    this._validateValue();
                    var val = this.option("value");
                    this._renderPosition(val, 0);
                    this.element().toggleClass(SWITCH_ON_VALUE_CLASS, val);
                    this.setAria({
                        pressed: val,
                        label: val ? this.option("onText") : this.option("offText")
                    })
                },
                _renderLabels: function() {
                    this._$labelOn.text(this.option("onText"));
                    this._$labelOff.text(this.option("offText"))
                },
                _visibilityChanged: function(visible) {
                    if (visible)
                        this.repaint()
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"useInkRipple":
                            this._invalidate();
                            break;
                        case"visible":
                        case"width":
                            this._refresh();
                            break;
                        case"onText":
                        case"offText":
                            this._renderLabels();
                            break;
                        case"value":
                            this._renderValue();
                            this.callBase(args);
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        registerComponent("dxSwitch", uiNamespace, Switch);
        return Switch
    });
    DevExpress.require(["/ui/widgets/ui.switch"]);
    /*! Module widgets-base, file ui.textEditor.base.js */
    DevExpress.define("/ui/widgets/textEditor/ui.textEditor.base", ["jquery", "/utils/utils.inflector", "/utils/utils.dom", "/utils/utils.common", "/componentRegistrator", "/ui/uiNamespace", "/ui/ui.editor", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer"], function($, inflector, domUtils, commonUtils, registerComponent, uiNamespace, Editor, eventUtils, pointerEvents) {
        var TEXTEDITOR_CLASS = "dx-texteditor",
            TEXTEDITOR_INPUT_CLASS = "dx-texteditor-input",
            TEXTEDITOR_INPUT_SELECTOR = "." + TEXTEDITOR_INPUT_CLASS,
            TEXTEDITOR_CONTAINER_CLASS = "dx-texteditor-container",
            TEXTEDITOR_BUTTONS_CONTAINER_CLASS = "dx-texteditor-buttons-container",
            TEXTEDITOR_PLACEHOLDER_CLASS = "dx-placeholder",
            TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS = "dx-show-clear-button",
            TEXTEDITOR_ICON_CLASS = "dx-icon",
            TEXTEDITOR_CLEAR_ICON_CLASS = "dx-icon-clear",
            TEXTEDITOR_CLEAR_BUTTON_CLASS = "dx-clear-button-area",
            TEXTEDITOR_EMPTY_INPUT_CLASS = "dx-texteditor-empty",
            EVENTS_LIST = ["KeyDown", "KeyPress", "KeyUp", "Change", "Cut", "Copy", "Paste", "Input"];
        var TextEditorBase = Editor.inherit({
                _supportedKeys: function() {
                    var stop = function(e) {
                            e.stopPropagation()
                        };
                    return {
                            space: stop,
                            enter: stop,
                            leftArrow: stop,
                            rightArrow: stop
                        }
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            value: "",
                            spellcheck: false,
                            showClearButton: false,
                            valueChangeEvent: "change",
                            placeholder: "",
                            attr: {},
                            onFocusIn: null,
                            onFocusOut: null,
                            onKeyDown: null,
                            onKeyPress: null,
                            onKeyUp: null,
                            onChange: null,
                            onInput: null,
                            onCut: null,
                            onCopy: null,
                            onPaste: null,
                            onEnterKey: null,
                            mode: "text",
                            hoverStateEnabled: true,
                            focusStateEnabled: true,
                            text: undefined,
                            valueFormat: function(value) {
                                return value
                            }
                        })
                },
                _input: function() {
                    return this.element().find(TEXTEDITOR_INPUT_SELECTOR).first()
                },
                _inputWrapper: function() {
                    return this.element()
                },
                _buttonsContainer: function() {
                    return this._inputWrapper().find("." + TEXTEDITOR_BUTTONS_CONTAINER_CLASS)
                },
                _render: function() {
                    this.element().addClass(TEXTEDITOR_CLASS);
                    this._renderInput();
                    this._renderInputType();
                    this._renderValue();
                    this._renderProps();
                    this._renderPlaceholder();
                    this.callBase();
                    this._renderValueChangeEvent();
                    this._renderEvents();
                    this._renderEnterKeyAction();
                    this._renderEmptinessEvent()
                },
                _renderInput: function() {
                    $("<div>").addClass(TEXTEDITOR_CONTAINER_CLASS).append(this._createInput()).append($("<div>").addClass(TEXTEDITOR_BUTTONS_CONTAINER_CLASS)).appendTo(this.element())
                },
                _createInput: function() {
                    return $("<input>").addClass(TEXTEDITOR_INPUT_CLASS).attr("autocomplete", "off").attr(this.option("attr"))
                },
                _renderValue: function() {
                    this._renderInputValue();
                    this._renderInputAddons()
                },
                _renderInputValue: function() {
                    var text = this.option("text"),
                        value = this.option("value"),
                        displayValue = this.option("displayValue"),
                        valueFormat = this.option("valueFormat");
                    if (displayValue !== undefined)
                        text = valueFormat(displayValue);
                    else if (!commonUtils.isDefined(text))
                        text = valueFormat(value);
                    if (this._input().val() !== (commonUtils.isDefined(text) ? text : ""))
                        this._renderDisplayText(text);
                    else
                        this._toggleEmptinessEventHandler()
                },
                _renderDisplayText: function(text) {
                    this._input().val(text);
                    this._toggleEmptinessEventHandler()
                },
                _isValueValid: function() {
                    var validity = this._input().get(0).validity;
                    if (validity)
                        return validity.valid;
                    return true
                },
                _toggleEmptiness: function(isEmpty) {
                    this.element().toggleClass(TEXTEDITOR_EMPTY_INPUT_CLASS, isEmpty);
                    this._togglePlaceholder(isEmpty)
                },
                _togglePlaceholder: function(isEmpty) {
                    if (!this._$placeholder)
                        return;
                    this._$placeholder.toggleClass("dx-state-invisible", !isEmpty)
                },
                _renderProps: function() {
                    this._toggleDisabledState(this.option("disabled"));
                    this._toggleReadOnlyState();
                    this._toggleSpellcheckState()
                },
                _toggleDisabledState: function(value) {
                    this.callBase.apply(this, arguments);
                    var $input = this._input();
                    if (value)
                        $input.attr("disabled", true).attr("tabindex", -1);
                    else
                        $input.removeAttr("disabled").removeAttr("tabindex")
                },
                _toggleReadOnlyState: function() {
                    this._input().prop("readOnly", this._readOnlyPropValue());
                    this.callBase()
                },
                _readOnlyPropValue: function() {
                    return this.option("readOnly")
                },
                _toggleSpellcheckState: function() {
                    this._input().prop("spellcheck", this.option("spellcheck"))
                },
                _renderPlaceholder: function() {
                    if (this._$placeholder) {
                        this._$placeholder.remove();
                        this._$placeholder = null
                    }
                    var that = this,
                        $input = that._input(),
                        placeholderText = that.option("placeholder"),
                        $placeholder = this._$placeholder = $('<div>').attr("data-dx_placeholder", placeholderText),
                        startEvent = eventUtils.addNamespace(pointerEvents.up, this.NAME);
                    $placeholder.on(startEvent, function() {
                        $input.focus()
                    });
                    $placeholder.insertAfter($input);
                    $placeholder.addClass(TEXTEDITOR_PLACEHOLDER_CLASS)
                },
                _placeholder: function() {
                    return this._$placeholder || $()
                },
                _renderInputAddons: function() {
                    this._renderClearButton()
                },
                _renderClearButton: function() {
                    var clearButtonVisibility = this._clearButtonVisibility();
                    this.element().toggleClass(TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS, clearButtonVisibility);
                    if (clearButtonVisibility) {
                        if (!this._$clearButton || this._$clearButton && !this._$clearButton.closest(this.element()).length)
                            this._$clearButton = this._createClearButton();
                        this._$clearButton.prependTo(this._buttonsContainer())
                    }
                    if (this._$clearButton)
                        this._$clearButton.toggleClass("dx-state-invisible", !clearButtonVisibility)
                },
                _clearButtonVisibility: function() {
                    return this.option("showClearButton") && !this.option("readOnly")
                },
                _createClearButton: function() {
                    return $("<span>").addClass(TEXTEDITOR_CLEAR_BUTTON_CLASS).append($("<span>").addClass(TEXTEDITOR_ICON_CLASS).addClass(TEXTEDITOR_CLEAR_ICON_CLASS)).on(eventUtils.addNamespace(pointerEvents.down, this.NAME), function(e) {
                            if (e.pointerType === "mouse")
                                e.preventDefault();
                            e.dxPreventBlur = true
                        }).on(eventUtils.addNamespace("dxclick", this.NAME), $.proxy(this._clearValueHandler, this))
                },
                _clearValueHandler: function(e) {
                    var $input = this._input();
                    e.stopPropagation();
                    this._valueChangeEventHandler(e);
                    this.reset();
                    !$input.is(":focus") && $input.focus()
                },
                _renderEvents: function() {
                    var that = this,
                        $input = that._input();
                    $.each(EVENTS_LIST, function(_, event) {
                        if (that.option("on" + event)) {
                            var action = that._createActionByOption("on" + event, {excludeValidators: ["readOnly"]});
                            $input.on(eventUtils.addNamespace(event.toLowerCase(), that.NAME), function(e) {
                                action({jQueryEvent: e})
                            })
                        }
                    })
                },
                _refreshEvents: function() {
                    var that = this,
                        $input = this._input();
                    $.each(EVENTS_LIST, function(_, event) {
                        $input.off(eventUtils.addNamespace(event.toLowerCase(), that.NAME))
                    });
                    this._renderEvents()
                },
                _keyPressHandler: function(e) {
                    this.option("text", this._input().val())
                },
                _renderValueChangeEvent: function() {
                    var keyPressEvent = eventUtils.addNamespace(this._renderValueEventName(), this.NAME + "TextChange"),
                        valueChangeEvent = eventUtils.addNamespace(this.option("valueChangeEvent"), this.NAME + "ValueChange");
                    this._input().on(keyPressEvent, $.proxy(this._keyPressHandler, this)).on(valueChangeEvent, $.proxy(this._valueChangeEventHandler, this))
                },
                _cleanValueChangeEvent: function() {
                    var eventNamespace = this.NAME + "ValueChange",
                        keyPressEvent = eventUtils.addNamespace(this._renderValueEventName(), this.NAME + "TextChange");
                    this._input().off("." + eventNamespace).off(keyPressEvent)
                },
                _refreshValueChangeEvent: function() {
                    this._cleanValueChangeEvent();
                    this._renderValueChangeEvent()
                },
                _renderValueEventName: function() {
                    return "input change keypress"
                },
                _focusTarget: function() {
                    return this._input()
                },
                _toggleFocusClass: function(isFocused) {
                    this.callBase(isFocused, this.element())
                },
                _hasFocusClass: function(element) {
                    return this.callBase($(element || this.element()))
                },
                _renderEmptinessEvent: function() {
                    var $input = this._input();
                    $input.on("input blur", $.proxy(this._toggleEmptinessEventHandler, this));
                    this._toggleEmptinessEventHandler()
                },
                _toggleEmptinessEventHandler: function(value) {
                    var text = this._input().val(),
                        isEmpty = (text === "" || text === null) && this._isValueValid();
                    this._toggleEmptiness(isEmpty)
                },
                _valueChangeEventHandler: function(e, formattedValue) {
                    this._saveValueChangeEvent(e);
                    this.option("value", arguments.length > 1 ? formattedValue : this._input().val())
                },
                _renderEnterKeyAction: function() {
                    this._enterKeyAction = this._createActionByOption("onEnterKey", {excludeValidators: ["readOnly"]});
                    this._input().off("keydown.onEnterKey.dxTextEditor").on("keydown.onEnterKey.dxTextEditor", $.proxy(this._enterKeyHandlerUp, this))
                },
                _enterKeyHandlerUp: function(e) {
                    if (e.which === 13)
                        this._enterKeyAction({jQueryEvent: e})
                },
                _updateValue: function() {
                    this.option("text", undefined);
                    this._renderValue()
                },
                _dispose: function() {
                    this._enterKeyAction = undefined;
                    this.callBase()
                },
                _optionChanged: function(args) {
                    var name = args.name;
                    if ($.inArray(name.replace("on", ""), EVENTS_LIST) > -1) {
                        this._refreshEvents();
                        return
                    }
                    switch (name) {
                        case"valueChangeEvent":
                            this._refreshValueChangeEvent();
                            this._refreshFocusEvent();
                            this._refreshEvents();
                            break;
                        case"onValueChanged":
                            this._createValueChangeAction();
                            break;
                        case"readOnly":
                            this.callBase(args);
                            this._renderInputAddons();
                            break;
                        case"spellcheck":
                            this._toggleSpellcheckState();
                            break;
                        case"mode":
                            this._renderInputType();
                            break;
                        case"onEnterKey":
                            this._renderEnterKeyAction();
                            break;
                        case"placeholder":
                            this._renderPlaceholder();
                            break;
                        case"showClearButton":
                            this._renderInputAddons();
                            break;
                        case"text":
                            break;
                        case"value":
                            this._updateValue();
                            this.callBase(args);
                            break;
                        case"attr":
                            this._input().attr(args.value);
                            break;
                        case"valueFormat":
                            this._invalidate();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _renderInputType: function() {
                    this._setInputType(this.option("mode"))
                },
                _setInputType: function(type) {
                    var input = this._input();
                    if (type === "search")
                        type = "text";
                    try {
                        input.prop("type", type)
                    }
                    catch(e) {
                        input.prop("type", "text")
                    }
                },
                focus: function() {
                    this._input().focus()
                },
                blur: function() {
                    if (this._input().is(document.activeElement))
                        domUtils.resetActiveElement()
                },
                reset: function() {
                    this.option("value", "")
                }
            });
        return TextEditorBase
    });
    /*! Module widgets-base, file ui.textEditor.mask.rule.js */
    DevExpress.define("/ui/widgets/textEditor/ui.textEditor.mask.rule", ["jquery", "/class", "/utils/utils.common"], function($, Class, commonUtils) {
        var EMPTY_CHAR = " ";
        var BaseMaskRule = Class.inherit({
                ctor: function(config) {
                    this._value = EMPTY_CHAR;
                    $.extend(this, config)
                },
                next: function(rule) {
                    if (!arguments.length)
                        return this._next;
                    this._next = rule
                },
                text: $.noop,
                value: $.noop,
                rawValue: $.noop,
                handle: $.noop,
                _prepareHandlingArgs: function(args, config) {
                    var handlingProperty = args.hasOwnProperty("value") ? "value" : "text";
                    args[handlingProperty] = commonUtils.isDefined(config.str) ? config.str : args[handlingProperty];
                    args.start = commonUtils.isDefined(config.start) ? config.start : args.start;
                    args.length = commonUtils.isDefined(config.length) ? config.length : args.length;
                    return args
                },
                reset: $.noop,
                clear: $.noop,
                isAccepted: function() {
                    return false
                },
                adjustedCaret: function(caret, isForwardDirection, char) {
                    return isForwardDirection ? this._adjustedForward(caret, 0, char) : this._adjustedBackward(caret, 0, char)
                },
                _adjustedForward: $.noop,
                _adjustedBackward: $.noop,
                isValid: $.noop
            });
        var EmptyMaskRule = BaseMaskRule.inherit({
                next: $.noop,
                handle: function() {
                    return 0
                },
                text: function() {
                    return ""
                },
                value: function() {
                    return ""
                },
                rawValue: function() {
                    return ""
                },
                adjustedCaret: function() {
                    return 0
                },
                isValid: function() {
                    return true
                }
            });
        var MaskRule = BaseMaskRule.inherit({
                text: function() {
                    return (this._value !== EMPTY_CHAR ? this._value : this.maskChar) + this.next().text()
                },
                value: function() {
                    return this._value + this.next().value()
                },
                rawValue: function() {
                    return this._value + this.next().rawValue()
                },
                handle: function(args) {
                    var str = args.hasOwnProperty("value") ? args.value : args.text;
                    if (!str || !str.length || !args.length)
                        return 0;
                    if (args.start)
                        return this.next().handle(this._prepareHandlingArgs(args, {start: args.start - 1}));
                    var char = str[0];
                    var rest = str.substring(1);
                    this._tryAcceptChar(char);
                    return this._accepted() ? this.next().handle(this._prepareHandlingArgs(args, {
                            str: rest,
                            length: args.length - 1
                        })) + 1 : this.handle(this._prepareHandlingArgs(args, {
                            str: rest,
                            length: args.length - 1
                        }))
                },
                clear: function() {
                    this._tryAcceptChar(EMPTY_CHAR);
                    this.next().clear()
                },
                reset: function() {
                    this._accepted(false);
                    this.next().reset()
                },
                _tryAcceptChar: function(char) {
                    this._accepted(false);
                    if (!this._isAllowed(char))
                        return;
                    this._accepted(true);
                    this._value = char
                },
                _accepted: function(value) {
                    if (!arguments.length)
                        return !!this._isAccepted;
                    this._isAccepted = !!value
                },
                _isAllowed: function(char) {
                    if (char === EMPTY_CHAR)
                        return true;
                    return this._isValid(char)
                },
                _isValid: function(char) {
                    var allowedChars = this.allowedChars;
                    if (allowedChars instanceof RegExp)
                        return allowedChars.test(char);
                    if ($.isFunction(allowedChars))
                        return allowedChars(char);
                    if ($.isArray(allowedChars))
                        return $.inArray(char, allowedChars) > -1;
                    return allowedChars === char
                },
                isAccepted: function(caret) {
                    return caret === 0 ? this._accepted() : this.next().isAccepted(caret - 1)
                },
                _adjustedForward: function(caret, index, char) {
                    if (index >= caret)
                        return index;
                    return this.next()._adjustedForward(caret, index + 1, char) || index + 1
                },
                _adjustedBackward: function(caret, index) {
                    if (index >= caret - 1)
                        return caret;
                    return this.next()._adjustedBackward(caret, index + 1) || index + 1
                },
                isValid: function() {
                    return this._isValid(this._value) && this.next().isValid()
                }
            });
        var StubMaskRule = MaskRule.inherit({
                value: function() {
                    return this.next().value()
                },
                handle: function(args) {
                    var hasValueProperty = args.hasOwnProperty("value");
                    var str = hasValueProperty ? args.value : args.text;
                    if (!str.length || !args.length)
                        return 0;
                    if (args.start || hasValueProperty)
                        return this.next().handle(this._prepareHandlingArgs(args, {start: args.start && args.start - 1}));
                    var char = str[0];
                    var rest = str.substring(1);
                    this._tryAcceptChar(char);
                    var nextArgs = this._isAllowed(char) ? this._prepareHandlingArgs(args, {
                            str: rest,
                            length: args.length - 1
                        }) : args;
                    return this.next().handle(nextArgs) + 1
                },
                clear: function() {
                    this._accepted(false);
                    this.next().clear()
                },
                _tryAcceptChar: function(char) {
                    this._accepted(this._isValid(char))
                },
                _isValid: function(char) {
                    return char === this.maskChar
                },
                _adjustedForward: function(caret, index, char) {
                    if (index >= caret && char === this.maskChar)
                        return index;
                    if (caret === index + 1 && this._accepted())
                        return caret;
                    return this.next()._adjustedForward(caret, index + 1, char)
                },
                _adjustedBackward: function(caret, index) {
                    if (index >= caret - 1)
                        return 0;
                    return this.next()._adjustedBackward(caret, index + 1)
                },
                isValid: function() {
                    return this.next().isValid()
                }
            });
        return {
                MaskRule: MaskRule,
                StubMaskRule: StubMaskRule,
                EmptyMaskRule: EmptyMaskRule
            }
    });
    /*! Module widgets-base, file ui.textEditor.mask.js */
    DevExpress.define("/ui/widgets/textEditor/ui.textEditor.mask", ["jquery", "/utils/utils.caret", "/utils/utils.dom", "/utils/utils.common", "/ui/widgets/textEditor/ui.textEditor.base", "/ui/widgets/textEditor/ui.textEditor.mask.rule", "/ui/events/ui.events.utils"], function($, caret, domUtils, commonUtils, TextEditorBase, MaskRules, eventUtils) {
        var stubCaret = function() {
                return {}
            };
        var EMPTY_CHAR = " ";
        var EMPTY_CHAR_CODE = 32;
        var ESCAPED_CHAR = "\\";
        var TEXTEDITOR_MASKED_CLASS = "dx-texteditor-masked";
        var MASK_EVENT_NAMESPACE = "dxMask";
        var FORWARD_DIRECTION = "forward";
        var BACKWARD_DIRECTION = "backward";
        var buildInMaskRules = {
                "0": /[0-9]/,
                "9": /[0-9\s]/,
                "#": /[-+0-9\s]/,
                L: function(char) {
                    return isLiteralChar(char)
                },
                l: function(char) {
                    return isLiteralChar(char) || isSpaceChar(char)
                },
                C: /\S/,
                c: /./,
                A: function(char) {
                    return isLiteralChar(char) || isNumericChar(char)
                },
                a: function(char) {
                    return isLiteralChar(char) || isNumericChar(char) || isSpaceChar(char)
                }
            };
        var isNumericChar = function(char) {
                return /[0-9]/.test(char)
            };
        var isLiteralChar = function(char) {
                var code = char.charCodeAt();
                return 64 < code && code < 91 || 96 < code && code < 123 || code > 127
            };
        var isSpaceChar = function(char) {
                return char === " "
            };
        var CONTROL_KEYS = {
                9: "tab",
                35: "end",
                36: "home",
                37: "leftArrow",
                38: "upArrow",
                39: "rightArrow",
                40: "downArrow"
            };
        var TextEditorMask = TextEditorBase.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            mask: "",
                            maskChar: "_",
                            maskRules: {},
                            maskInvalidMessage: Globalize.localize("validation-mask"),
                            useMaskedValue: false
                        })
                },
                _supportedKeys: function() {
                    var that = this;
                    var keyHandlerMap = {
                            backspace: that._maskBackspaceHandler,
                            del: that._maskDelHandler,
                            enter: that._changeHandler
                        };
                    var result = that.callBase();
                    $.each(keyHandlerMap, function(key, callback) {
                        var parentHandler = result[key];
                        result[key] = function(e) {
                            that.option("mask") && callback.call(that, e);
                            parentHandler && parentHandler(e)
                        }
                    });
                    return result
                },
                _render: function() {
                    this.callBase();
                    this._renderMask()
                },
                _renderMask: function() {
                    this.element().removeClass(TEXTEDITOR_MASKED_CLASS);
                    this._maskRulesChain = null;
                    if (!this.option("mask"))
                        return;
                    this.element().addClass(TEXTEDITOR_MASKED_CLASS);
                    this._attachMaskEventHandlers();
                    this._parseMask();
                    this._renderMaskedValue()
                },
                _attachMaskEventHandlers: function() {
                    this._input().off("." + MASK_EVENT_NAMESPACE).on(eventUtils.addNamespace("focus", MASK_EVENT_NAMESPACE), $.proxy(this._maskFocusHandler, this)).on(eventUtils.addNamespace("keypress", MASK_EVENT_NAMESPACE), $.proxy(this._maskKeyPressHandler, this)).on(eventUtils.addNamespace("input", MASK_EVENT_NAMESPACE), $.proxy(this._maskInputHandler, this)).on(eventUtils.addNamespace("paste", MASK_EVENT_NAMESPACE), $.proxy(this._maskPasteHandler, this)).on(eventUtils.addNamespace("cut", MASK_EVENT_NAMESPACE), $.proxy(this._maskCutHandler, this)).on(eventUtils.addNamespace("drop", MASK_EVENT_NAMESPACE), $.proxy(this._maskDragHandler, this));
                    this._attachChangeEventHandlers()
                },
                _attachChangeEventHandlers: function() {
                    if ($.inArray("change", this.option("valueChangeEvent").split(" ")) === -1)
                        return;
                    this._input().on(eventUtils.addNamespace("blur", MASK_EVENT_NAMESPACE), $.proxy(function(e) {
                        this._suppressCaretChanging(this._changeHandler, [e])
                    }, this))
                },
                _suppressCaretChanging: function(callback, args) {
                    var originalCaret = caret;
                    caret = stubCaret;
                    try {
                        callback.apply(this, args)
                    }
                    finally {
                        caret = originalCaret
                    }
                },
                _changeHandler: function(e) {
                    this._valueChangeEventHandler(eventUtils.createEvent(e, {type: "change"}))
                },
                _parseMask: function() {
                    this._maskRules = $.extend({}, buildInMaskRules, this.option("maskRules"));
                    this._maskRulesChain = this._parseMaskRule(0)
                },
                _parseMaskRule: function(index) {
                    var mask = this.option("mask");
                    if (index >= mask.length)
                        return new MaskRules.EmptyMaskRule;
                    var currentMaskChar = mask[index];
                    var isEscapedChar = currentMaskChar === ESCAPED_CHAR;
                    var result = isEscapedChar ? new MaskRules.StubMaskRule({maskChar: mask[index + 1]}) : this._getMaskRule(currentMaskChar);
                    result.next(this._parseMaskRule(index + 1 + isEscapedChar));
                    return result
                },
                _getMaskRule: function(pattern) {
                    var ruleConfig;
                    $.each(this._maskRules, function(rulePattern, allowedChars) {
                        if (rulePattern === pattern) {
                            ruleConfig = {
                                pattern: rulePattern,
                                allowedChars: allowedChars
                            };
                            return false
                        }
                    });
                    return commonUtils.isDefined(ruleConfig) ? new MaskRules.MaskRule($.extend({maskChar: this.option("maskChar")}, ruleConfig)) : new MaskRules.StubMaskRule({maskChar: pattern})
                },
                _renderMaskedValue: function() {
                    if (!this._maskRulesChain)
                        return;
                    var value = this.option("value") || "";
                    this._maskRulesChain.clear();
                    var chainArgs = {length: value.length};
                    chainArgs[this._isMaskedValueMode() ? "text" : "value"] = value;
                    this._handleChain(chainArgs);
                    this._displayMask()
                },
                _isMaskedValueMode: function() {
                    return this.option("useMaskedValue")
                },
                _displayMask: function() {
                    var caret = this._caret();
                    this._renderValue();
                    this._caret(caret)
                },
                _renderValue: function() {
                    if (this._maskRulesChain)
                        this.option("text", this._maskRulesChain.text());
                    this.callBase()
                },
                _valueChangeEventHandler: function(e) {
                    if (!this._maskRulesChain) {
                        this.callBase.apply(this, arguments);
                        return
                    }
                    this._saveValueChangeEvent(e);
                    var value = this._isMaskedValueMode() ? (this._textValue || "").replace(new RegExp("[" + this.option("maskChar") + "]", "g"), " ").replace(/\s+$/, "") : (this._value || "").replace(/\s+$/, "");
                    this.option("value", value)
                },
                _maskFocusHandler: function() {
                    this._direction(FORWARD_DIRECTION);
                    this._adjustCaret()
                },
                _maskKeyPressHandler: function(e) {
                    this._keyPressHandled = true;
                    if (this._isControlKeyFired(e))
                        return;
                    this._maskKeyHandler(e, function() {
                        this._handleKey(e.which);
                        return true
                    })
                },
                _maskInputHandler: function(e) {
                    if (this._keyPressHandled) {
                        this._keyPressHandled = false;
                        return
                    }
                    var inputValue = this._input().val();
                    var caret = this._caret();
                    caret.start = caret.end - 1;
                    var oldValue = inputValue.substring(0, caret.start) + inputValue.substring(caret.end);
                    var char = inputValue[caret.start];
                    this._input().val(oldValue);
                    this._inputHandlerTimer = setTimeout($.proxy(function() {
                        this._caret({
                            start: caret.start,
                            end: caret.start
                        });
                        this._maskKeyHandler(e, function() {
                            this._handleKey(char.charCodeAt());
                            return true
                        });
                        this._keyPressHandled = false
                    }, this))
                },
                _isControlKeyFired: function(e) {
                    return CONTROL_KEYS[e.keyCode] && !e.which || e.metaKey
                },
                _maskBackspaceHandler: function(e) {
                    this._maskKeyHandler(e, function() {
                        if (this._hasSelection())
                            return true;
                        if (this._tryMoveCaretBackward())
                            return false;
                        this._handleKey(EMPTY_CHAR_CODE, BACKWARD_DIRECTION);
                        return true
                    })
                },
                _maskDelHandler: function(e) {
                    this._maskKeyHandler(e, function() {
                        !this._hasSelection() && this._handleKey(EMPTY_CHAR_CODE);
                        return true
                    })
                },
                _maskPasteHandler: function(e) {
                    var caret = this._caret();
                    this._maskKeyHandler(e, function() {
                        var pastingText = domUtils.clipboardText(e);
                        var restText = this._maskRulesChain.text().substring(caret.end);
                        var accepted = this._handleChain({
                                text: pastingText,
                                start: caret.start,
                                length: pastingText.length
                            });
                        var newCaret = caret.start + accepted;
                        this._handleChain({
                            text: restText,
                            start: newCaret,
                            length: restText.length
                        });
                        this._caret({
                            start: newCaret,
                            end: newCaret
                        });
                        return true
                    })
                },
                _handleChain: function(args) {
                    var handledCount = this._maskRulesChain.handle(args);
                    this._value = this._maskRulesChain.value();
                    this._textValue = this._maskRulesChain.text();
                    return handledCount
                },
                _maskCutHandler: function(e) {
                    var caret = this._caret();
                    var selectedText = this._input().val().substring(caret.start, caret.end);
                    this._maskKeyHandler(e, function() {
                        domUtils.clipboardText(e, selectedText);
                        return true
                    })
                },
                _maskDragHandler: function() {
                    this._clearDragTimer();
                    this._dragTimer = setTimeout($.proxy(function() {
                        this.option("value", this._convertToValue(this._input().val()))
                    }, this))
                },
                _convertToValue: function(text) {
                    return text.replace(new RegExp(this.option("maskChar"), "g"), EMPTY_CHAR)
                },
                _maskKeyHandler: function(e, tryHandleKeyCallback) {
                    if (this.option("readOnly"))
                        return;
                    this._direction(FORWARD_DIRECTION);
                    e.preventDefault();
                    this._handleSelection();
                    if (!tryHandleKeyCallback.call(this))
                        return;
                    this._direction(FORWARD_DIRECTION);
                    this._adjustCaret();
                    this._displayMask();
                    this._maskRulesChain.reset()
                },
                _handleKey: function(keyCode, direction) {
                    var char = String.fromCharCode(keyCode);
                    this._direction(direction || FORWARD_DIRECTION);
                    this._adjustCaret(char);
                    this._handleKeyChain(char);
                    this._moveCaret()
                },
                _handleSelection: function() {
                    if (!this._hasSelection())
                        return;
                    var caret = this._caret();
                    var emptyChars = new Array(caret.end - caret.start + 1).join(EMPTY_CHAR);
                    this._handleKeyChain(emptyChars)
                },
                _handleKeyChain: function(chars) {
                    var caret = this._caret();
                    var start = this._isForwardDirection() ? caret.start : caret.start - 1;
                    var end = this._isForwardDirection() ? caret.end : caret.end - 1;
                    var length = start === end ? 1 : end - start;
                    this._handleChain({
                        text: chars,
                        start: start,
                        length: length
                    })
                },
                _tryMoveCaretBackward: function() {
                    this._direction(BACKWARD_DIRECTION);
                    var currentCaret = this._caret().start;
                    this._adjustCaret();
                    return !currentCaret || currentCaret !== this._caret().start
                },
                _adjustCaret: function(char) {
                    var caret = this._maskRulesChain.adjustedCaret(this._caret().start, this._isForwardDirection(), char);
                    this._caret({
                        start: caret,
                        end: caret
                    })
                },
                _moveCaret: function() {
                    var currentCaret = this._caret().start;
                    var maskRuleIndex = currentCaret + (this._isForwardDirection() ? 0 : -1);
                    var caret = this._maskRulesChain.isAccepted(maskRuleIndex) ? currentCaret + (this._isForwardDirection() ? 1 : -1) : currentCaret;
                    this._caret({
                        start: caret,
                        end: caret
                    })
                },
                _caret: function(position) {
                    if (!arguments.length)
                        return caret(this._input());
                    caret(this._input(), position)
                },
                _hasSelection: function() {
                    var caret = this._caret();
                    return caret.start !== caret.end
                },
                _direction: function(direction) {
                    if (!arguments.length)
                        return this._typingDirection;
                    this._typingDirection = direction
                },
                _isForwardDirection: function() {
                    return this._direction() === FORWARD_DIRECTION
                },
                _clearDragTimer: function() {
                    clearTimeout(this._dragTimer)
                },
                _clean: function() {
                    this._clearDragTimer();
                    this.callBase()
                },
                _validateMask: function() {
                    if (!this._maskRulesChain)
                        return;
                    var isValid = this._maskRulesChain.isValid();
                    this.option({
                        isValid: isValid,
                        validationError: isValid ? null : {
                            editorSpecific: true,
                            message: this.option("maskInvalidMessage")
                        }
                    })
                },
                _dispose: function() {
                    clearTimeout(this._inputHandlerTimer);
                    this.callBase()
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"mask":
                        case"maskChar":
                        case"maskRules":
                        case"useMaskedValue":
                            this._renderMask();
                            this._validateMask();
                            break;
                        case"value":
                            this._renderMaskedValue();
                            this._validateMask();
                            this.callBase(args);
                            break;
                        case"maskInvalidMessage":
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        return TextEditorMask
    });
    /*! Module widgets-base, file ui.textEditor.js */
    DevExpress.define("/ui/widgets/ui.textEditor", ["jquery", "/componentRegistrator", "/ui/uiNamespace", "/ui/widgets/textEditor/ui.textEditor.mask"], function($, registerComponent, uiNamespace, TextEditorMask) {
        registerComponent("dxTextEditor", uiNamespace, TextEditorMask);
        return TextEditorMask
    });
    /*! Module widgets-base, file ui.textBox.js */
    DevExpress.define("/ui/widgets/ui.textBox", ["jquery", "/devices", "/componentRegistrator", "/ui/widgets/ui.textEditor", "/ui/events/ui.events.utils", "/ui/uiNamespace"], function($, devices, registerComponent, TextEditor, eventUtils, uiNamespace) {
        var ua = window.navigator.userAgent,
            ignoreCode = [8, 9, 13, 33, 34, 35, 36, 37, 38, 39, 40, 46],
            TEXTBOX_CLASS = "dx-textbox",
            SEARCHBOX_CLASS = "dx-searchbox",
            ICON_CLASS = "dx-icon",
            SEARCH_ICON_CLASS = "dx-icon-search";
        var TextBox = TextEditor.inherit({
                ctor: function(element, options) {
                    if (options)
                        this._showClearButton = options.showClearButton;
                    this.callBase.apply(this, arguments)
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            mode: "text",
                            maxLength: null
                        })
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(TEXTBOX_CLASS);
                    this.setAria("role", "textbox");
                    this._renderMaxLengthHandlers()
                },
                _renderInputType: function() {
                    this.callBase();
                    this._renderSearchMode()
                },
                _renderMaxLengthHandlers: function() {
                    if (this._isAndroid())
                        this._input().on(eventUtils.addNamespace("keydown", this.NAME), $.proxy(this._onKeyDownAndroidHandler, this)).on(eventUtils.addNamespace("change", this.NAME), $.proxy(this._onChangeAndroidHandler, this))
                },
                _renderProps: function() {
                    this.callBase();
                    this._toggleMaxLengthProp()
                },
                _toggleMaxLengthProp: function() {
                    if (this._isAndroid())
                        return;
                    var maxLength = this.option("maxLength");
                    if (maxLength > 0)
                        this._input().attr("maxLength", maxLength);
                    else
                        this._input().removeAttr("maxLength")
                },
                _renderSearchMode: function() {
                    var $element = this._$element;
                    if (this.option("mode") === "search") {
                        $element.addClass(SEARCHBOX_CLASS);
                        this._renderSearchIcon();
                        if (this._showClearButton === undefined) {
                            this._showClearButton = this.option("showClearButton");
                            this.option("showClearButton", true)
                        }
                    }
                    else {
                        $element.removeClass(SEARCHBOX_CLASS);
                        this._$searchIcon && this._$searchIcon.remove();
                        this.option("showClearButton", this._showClearButton === undefined ? this.option("showClearButton") : this._showClearButton);
                        delete this._showClearButton
                    }
                },
                _renderSearchIcon: function() {
                    var $searchIcon = $("<div>").addClass(ICON_CLASS).addClass(SEARCH_ICON_CLASS);
                    $searchIcon.prependTo(this._input().parent());
                    this._$searchIcon = $searchIcon
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"maxLength":
                            this._toggleMaxLengthProp();
                            this._renderMaxLengthHandlers();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _onKeyDownAndroidHandler: function(e) {
                    var maxLength = this.option("maxLength");
                    if (maxLength) {
                        var $input = $(e.target),
                            code = e.keyCode;
                        this._cutOffExtraChar($input);
                        return $input.val().length < maxLength || $.inArray(code, ignoreCode) !== -1 || window.getSelection().toString() !== ""
                    }
                    else
                        return true
                },
                _onChangeAndroidHandler: function(e) {
                    var $input = $(e.target);
                    if (this.option("maxLength"))
                        this._cutOffExtraChar($input)
                },
                _cutOffExtraChar: function($input) {
                    var maxLength = this.option("maxLength"),
                        textInput = $input.val();
                    if (textInput.length > maxLength)
                        $input.val(textInput.substr(0, maxLength))
                },
                _isAndroid: function() {
                    var realDevice = devices.real();
                    var version = realDevice.version.join(".");
                    return realDevice.platform === "android" && version && /^(2\.|4\.1)/.test(version) && !/chrome/i.test(ua)
                }
            });
        TextBox.__internals = {
            uaAccessor: function(value) {
                if (!arguments.length)
                    return DevExpress.ui;
                ua = value
            },
            SEARCHBOX_CLASS: SEARCHBOX_CLASS,
            SEARCH_ICON_CLASS: SEARCH_ICON_CLASS
        };
        registerComponent("dxTextBox", uiNamespace, TextBox);
        return TextBox
    });
    DevExpress.require(["/ui/widgets/ui.textBox"]);
    /*! Module widgets-base, file ui.dropDownEditor.js */
    DevExpress.define("/ui/widgets/ui.dropDownEditor", ["jquery", "/ui/ui.errors", "/utils/utils.position", "/utils/utils.common", "/devices", "/componentRegistrator", "/ui/widgets/ui.button", "/ui/events/ui.events.utils", "/ui/widgets/ui.textBox", "/ui/uiNamespace"], function($, errors, positionUtils, commonUtils, devices, registerComponent, Button, eventUtils, TextBox, uiNamespace) {
        var DROP_DOWN_EDITOR_CLASS = "dx-dropdowneditor",
            DROP_DOWN_EDITOR_READONLY_CLASS = "dx-dropdowneditor-readonly",
            DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS = "dx-dropdowneditor-input-wrapper",
            DROP_DOWN_EDITOR_BUTTON_CLASS = "dx-dropdowneditor-button",
            DROP_DOWN_EDITOR_BUTTON_ICON = "dx-dropdowneditor-icon",
            DROP_DOWN_EDITOR_OVERLAY = "dx-dropdowneditor-overlay",
            DROP_DOWN_EDITOR_OVERLAY_FLIPPED = "dx-dropdowneditor-overlay-flipped",
            DROP_DOWN_EDITOR_ACTIVE = "dx-dropdowneditor-active",
            DROP_DOWN_EDITOR_BUTTON_VISIBLE = "dx-dropdowneditor-button-visible",
            DROP_DOWN_EDITOR_FIELD_CLICKABLE = "dx-dropdowneditor-field-clickable",
            DropDownEditor = TextBox.inherit({
                _supportedKeys: function() {
                    return $.extend(this.callBase(), {
                            escape: function(e) {
                                if (this.option("opened"))
                                    e.preventDefault();
                                this.close()
                            },
                            upArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                if (e.altKey) {
                                    this.close();
                                    return false
                                }
                                return true
                            },
                            downArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                if (e.altKey) {
                                    this._validatedOpening();
                                    return false
                                }
                                return true
                            },
                            enter: function(e) {
                                if (this.option("opened")) {
                                    e.preventDefault();
                                    this._valueChangeEventHandler(e)
                                }
                                return true
                            }
                        })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            value: null,
                            onOpened: null,
                            onClosed: null,
                            opened: false,
                            fieldEditEnabled: true,
                            applyValueMode: "instantly",
                            deferRendering: true,
                            activeStateEnabled: true,
                            fieldTemplate: null,
                            contentTemplate: null,
                            openOnFieldClick: false,
                            showDropButton: true,
                            popupPosition: this._getDefaultPopupPosition(),
                            onPopupInitialized: null,
                            applyButtonText: Globalize.localize("OK"),
                            cancelButtonText: Globalize.localize("Cancel"),
                            buttonsLocation: "default",
                            showPopupTitle: false
                        })
                },
                _getDefaultPopupPosition: function() {
                    var position = commonUtils.getDefaultAlignment(this.option("rtlEnabled"));
                    return {
                            offset: {
                                h: 0,
                                v: -1
                            },
                            my: position + " top",
                            at: position + " bottom",
                            collision: "flip flip"
                        }
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    var isGeneric = device.platform === "generic",
                                        isWin10 = device.platform === "win" && device.version && device.version[0] === 10;
                                    return isGeneric || isWin10
                                },
                                options: {popupPosition: {offset: {v: 0}}}
                            }])
                },
                _inputWrapper: function() {
                    return this.element().find("." + DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS)
                },
                _init: function() {
                    this.callBase();
                    this._initVisibilityActions();
                    this._initPopupInitializedAction()
                },
                _initVisibilityActions: function() {
                    this._openAction = this._createActionByOption("onOpened", {excludeValidators: ["disabled", "readOnly"]});
                    this._closeAction = this._createActionByOption("onClosed", {excludeValidators: ["disabled", "readOnly"]})
                },
                _initPopupInitializedAction: function() {
                    this._popupInitizliedAction = this._createActionByOption("onPopupInitialized", {excludeValidators: ["disabled", "readOnly", "designMode"]})
                },
                _render: function() {
                    this.callBase();
                    this._renderOpenHandler();
                    this.element().addClass(DROP_DOWN_EDITOR_CLASS);
                    this._renderOpenedState();
                    this.setAria("role", "combobox")
                },
                _renderContentImpl: function() {
                    if (!this.option("deferRendering"))
                        this._createPopup()
                },
                _renderInput: function() {
                    this.callBase();
                    this.element().wrapInner($("<div>").addClass(DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS));
                    this._$container = this.element().children().eq(0);
                    this.setAria({
                        haspopup: "true",
                        autocomplete: "list"
                    })
                },
                _readOnlyPropValue: function() {
                    return !this.option("fieldEditEnabled") || this.callBase()
                },
                _renderField: function() {
                    var fieldTemplate = this._getTemplateByOption("fieldTemplate");
                    if (!(fieldTemplate && this.option("fieldTemplate")))
                        return;
                    var isFocused = this._input().is(":focus");
                    isFocused && this._input().focusout();
                    this._cleanFocusState();
                    var $container = this._$container;
                    var data = this._fieldRenderData();
                    $container.empty();
                    this._$dropButton = null;
                    this._$clearButton = null;
                    fieldTemplate.render(data, $container);
                    if (!this._input().length)
                        throw errors.Error("E1010");
                    this._renderFocusState();
                    isFocused && this._input().focus()
                },
                _fieldRenderData: function() {
                    return this.option("value")
                },
                _renderInputAddons: function() {
                    this._renderField();
                    this.callBase();
                    this._renderDropButton()
                },
                _renderDropButton: function() {
                    var dropButtonVisible = this.option("showDropButton");
                    this.element().toggleClass(DROP_DOWN_EDITOR_BUTTON_VISIBLE, dropButtonVisible);
                    if (!dropButtonVisible) {
                        this._$dropButton && this._$dropButton.remove();
                        this._$dropButton = null;
                        return
                    }
                    if (!this._$dropButton)
                        this._$dropButton = this._createDropButton().addClass(DROP_DOWN_EDITOR_BUTTON_CLASS);
                    this._$dropButton.prependTo(this._buttonsContainer())
                },
                _createDropButton: function() {
                    var $button = $("<div>");
                    this._createComponent($button, Button, {
                        focusStateEnabled: false,
                        disabled: this.option("readOnly"),
                        _templates: {}
                    });
                    var $buttonIcon = $("<div>").addClass(DROP_DOWN_EDITOR_BUTTON_ICON);
                    $button.append($buttonIcon).removeClass("dx-button").on("mousedown", function(e) {
                        e.preventDefault()
                    });
                    $button.find(".dx-button-content").remove();
                    return $button
                },
                _renderOpenHandler: function() {
                    var $inputWrapper = this.element().find(".dx-dropdowneditor-input-wrapper");
                    var eventName = eventUtils.addNamespace("dxclick", this.NAME);
                    $inputWrapper.off(eventName);
                    var openOnFieldClick = this.option("openOnFieldClick");
                    this.element().toggleClass(DROP_DOWN_EDITOR_FIELD_CLICKABLE, openOnFieldClick);
                    if (openOnFieldClick) {
                        $inputWrapper.on(eventUtils.addNamespace("mousedown", this.NAME), function(e) {
                            devices.real().platform !== "generic" && e.preventDefault()
                        });
                        $inputWrapper.on(eventName, $.proxy(this._openHandler, this));
                        return
                    }
                    if (this.option("showDropButton"))
                        this._$dropButton.dxButton("option", "onClick", $.proxy(this._openHandler, this))
                },
                _openHandler: function() {
                    this._toggleOpenState()
                },
                _keyboardEventBindingTarget: function() {
                    return this._input()
                },
                _toggleOpenState: function(isVisible) {
                    if (this.option("disabled"))
                        return;
                    if (this._needFocusOnButtonClick())
                        this._input().focus();
                    if (!this.option("readOnly")) {
                        isVisible = arguments.length ? isVisible : !this.option("opened");
                        this.option("opened", isVisible)
                    }
                },
                _needFocusOnButtonClick: function() {
                    return devices.real().deviceType === "desktop"
                },
                _renderOpenedState: function() {
                    var opened = this.option("opened");
                    if (opened)
                        this._createPopup();
                    this.element().toggleClass(DROP_DOWN_EDITOR_ACTIVE, opened);
                    this._setPopupOption("visible", opened);
                    this.setAria({
                        expanded: opened,
                        owns: (opened || undefined) && this._popupContentId
                    })
                },
                _createPopup: function() {
                    if (this._$popup)
                        return;
                    this._$popup = $("<div>").addClass(DROP_DOWN_EDITOR_OVERLAY).addClass(this.option("customOverlayCssClass")).appendTo(this.element());
                    this._renderPopup();
                    this._renderPopupContent()
                },
                _renderPopup: function() {
                    this._popup = this._createComponent(this._$popup, "dxPopup", this._popupConfig());
                    this._popup.on({
                        showing: $.proxy(this._popupShowingHandler, this),
                        shown: $.proxy(this._popupShownHandler, this),
                        hiding: $.proxy(this._popupHidingHandler, this),
                        hidden: $.proxy(this._popupHiddenHandler, this)
                    });
                    this._popup.option("onContentReady", $.proxy(this._contentReadyHandler, this));
                    this._contentReadyHandler();
                    this._popupContentId = new DevExpress.data.Guid;
                    this.setAria("id", this._popupContentId, this._popup.content())
                },
                _contentReadyHandler: $.noop,
                _popupConfig: function() {
                    return {
                            onInitialized: this._popupInitializedHandler(),
                            position: $.extend(this.option("popupPosition"), {of: this.element()}),
                            showTitle: this.option("showPopupTitle"),
                            width: "auto",
                            height: "auto",
                            shading: false,
                            closeOnTargetScroll: true,
                            closeOnOutsideClick: $.proxy(this._closeOutsideDropDownHandler, this),
                            animation: {
                                show: {
                                    type: "fade",
                                    duration: 0,
                                    from: 0,
                                    to: 1
                                },
                                hide: {
                                    type: "fade",
                                    duration: 400,
                                    from: 1,
                                    to: 0
                                }
                            },
                            deferRendering: false,
                            focusStateEnabled: false,
                            showCloseButton: false,
                            buttons: this._getPopupButtons(),
                            onPositioned: $.proxy(this._popupPositionedHandler, this),
                            fullScreen: false
                        }
                },
                _popupInitializedHandler: function() {
                    if (!this.option("onPopupInitialized"))
                        return;
                    return $.proxy(function(e) {
                            this._popupInitizliedAction({popup: e.component})
                        }, this)
                },
                _popupPositionedHandler: function(e) {
                    this._popup.overlayContent().toggleClass(DROP_DOWN_EDITOR_OVERLAY_FLIPPED, e.position.v.flip)
                },
                _popupShowingHandler: $.noop,
                _popupHidingHandler: function() {
                    this.option("opened", false)
                },
                _popupShownHandler: function() {
                    this._openAction();
                    if (this._$validationMessage)
                        this._$validationMessage.dxTooltip("option", "position", this._getValidationTooltipPosition())
                },
                _popupHiddenHandler: function() {
                    this._closeAction();
                    if (this._$validationMessage)
                        this._$validationMessage.dxTooltip("option", "position", this._getValidationTooltipPosition())
                },
                _getValidationTooltipPosition: function() {
                    var positionRequest = "below";
                    if (this._popup && this._popup.option("visible")) {
                        var myTop = positionUtils.setup(this.element()).top,
                            popupTop = positionUtils.setup(this._popup.content()).top;
                        positionRequest = myTop + this.option("popupPosition").offset.v > popupTop ? "below" : "above"
                    }
                    return this.callBase(positionRequest)
                },
                _renderPopupContent: function() {
                    var contentTemplate = this._getTemplateByOption("contentTemplate");
                    if (!(contentTemplate && this.option("contentTemplate")))
                        return;
                    var $popupContent = this._popup.content();
                    $popupContent.empty();
                    contentTemplate.render($popupContent)
                },
                _closeOutsideDropDownHandler: function(e) {
                    var $target = $(e.target);
                    var isInputClicked = !!$target.closest(this.element()).length;
                    var isDropButtonClicked = !!$target.closest(this._$dropButton).length;
                    var isOutsideClick = !isInputClicked && !isDropButtonClicked;
                    return isOutsideClick
                },
                _clean: function() {
                    delete this._$dropButton;
                    if (this._$popup) {
                        this._$popup.remove();
                        delete this._$popup;
                        delete this._popup
                    }
                    this.callBase()
                },
                _setPopupOption: function(optionName, value) {
                    this._setWidgetOption("_popup", arguments)
                },
                _validatedOpening: function() {
                    if (!this.option("readOnly"))
                        this._toggleOpenState(true)
                },
                _getPopupButtons: function() {
                    return this.option("applyValueMode") === "useButtons" ? this._popupButtonsConfig() : []
                },
                _popupButtonsConfig: function() {
                    var buttonsConfig = [{
                                shortcut: "done",
                                options: {
                                    onClick: $.proxy(this._applyButtonHandler, this),
                                    text: this.option("applyButtonText")
                                }
                            }, {
                                shortcut: "cancel",
                                options: {
                                    onClick: $.proxy(this._cancelButtonHandler, this),
                                    text: this.option("cancelButtonText")
                                }
                            }];
                    return this._applyButtonsLocation(buttonsConfig)
                },
                _applyButtonsLocation: function(buttonsConfig) {
                    var buttonsLocation = this.option("buttonsLocation"),
                        resultConfig = buttonsConfig;
                    if (buttonsLocation !== "default") {
                        var position = commonUtils.splitPair(buttonsLocation);
                        $.each(resultConfig, function(_, element) {
                            $.extend(element, {
                                toolbar: position[0],
                                location: position[1]
                            })
                        })
                    }
                    return resultConfig
                },
                _applyButtonHandler: function() {
                    this.close();
                    this.option("focusStateEnabled") && this.focus()
                },
                _cancelButtonHandler: function() {
                    this.close();
                    this.option("focusStateEnabled") && this.focus()
                },
                _toggleReadOnlyState: function() {
                    this.callBase();
                    this._$dropButton && this._$dropButton.dxButton("option", "disabled", this.option("readOnly"))
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"opened":
                            this._renderOpenedState();
                            break;
                        case"onOpened":
                        case"onClosed":
                            this._initVisibilityActions();
                            break;
                        case"onPopupInitialized":
                            this._initPopupInitializedAction();
                            break;
                        case"fieldTemplate":
                        case"fieldRender":
                            this._renderInputAddons();
                            break;
                        case"showDropButton":
                        case"contentTemplate":
                        case"contentRender":
                        case"fieldEditEnabled":
                        case"openOnFieldClick":
                            this._invalidate();
                            break;
                        case"popupPosition":
                        case"deferRendering":
                            break;
                        case"applyValueMode":
                        case"applyButtonText":
                        case"cancelButtonText":
                        case"buttonsLocation":
                            this._setPopupOption("buttons", this._getPopupButtons());
                            break;
                        case"showPopupTitle":
                            this._setPopupOption("showTitle", args.value);
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                open: function() {
                    this.option("opened", true)
                },
                close: function() {
                    this.option("opened", false)
                },
                reset: function() {
                    this.option("value", null)
                },
                field: function() {
                    return this._input()
                },
                content: function() {
                    return this._popup ? this._popup.content() : null
                }
            });
        DropDownEditor.__internals = {
            DROP_DOWN_EDITOR_CLASS: DROP_DOWN_EDITOR_CLASS,
            DROP_DOWN_EDITOR_READONLY_CLASS: DROP_DOWN_EDITOR_READONLY_CLASS,
            DROP_DOWN_EDITOR_BUTTON_ICON: DROP_DOWN_EDITOR_BUTTON_ICON,
            DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS: DROP_DOWN_EDITOR_INPUT_WRAPPER_CLASS,
            DROP_DOWN_EDITOR_BUTTON_CLASS: DROP_DOWN_EDITOR_BUTTON_CLASS,
            DROP_DOWN_EDITOR_OVERLAY: DROP_DOWN_EDITOR_OVERLAY,
            DROP_DOWN_EDITOR_ACTIVE: DROP_DOWN_EDITOR_ACTIVE,
            DROP_DOWN_EDITOR_BUTTON_VISIBLE: DROP_DOWN_EDITOR_BUTTON_VISIBLE
        };
        registerComponent("dxDropDownEditor", uiNamespace, DropDownEditor);
        return DropDownEditor
    });
    /*! Module widgets-base, file ui.dropDownList.js */
    DevExpress.define("/ui/widgets/ui.dropDownList", ["jquery", "/ui/ui.errors", "/utils/utils.common", "/componentRegistrator", "/ui/widgets/ui.dropDownEditor", "/ui/uiNamespace", "/ui/ui.dataExpression"], function($, errors, commonUtils, registerComponent, DropDownEditor, uiNamespace, DataExpressionMixin) {
        var LIST_ITEM_SELECTOR = ".dx-list-item",
            LIST_ITEM_DATA_KEY = "dxListItemData",
            DROPDOWNLIST_SELECTED_CLASS = "dx-dropdownlist-selected",
            DROPDOWNLIST_POPUP_WRAPPER_CLASS = "dx-dropdownlist-popup-wrapper",
            SKIP_GESTURE_EVENT_CLASS = "dx-skip-gesture-event",
            SEARCH_MODES = ["startswith", "contains", "endwith", "notcontains"];
        var DropDownList = DropDownEditor.inherit({
                _supportedKeys: function() {
                    return $.extend(this.callBase(), {
                            tab: function(e) {
                                if (this.option("opened") === true) {
                                    var $focusedItem = this._list.option("focusedElement");
                                    if ($focusedItem)
                                        this._setSelectedElement($focusedItem);
                                    else
                                        this._selectFirstItem();
                                    this.close()
                                }
                                else
                                    this._focusTarget().focusout()
                            },
                            space: $.noop,
                            home: $.noop,
                            end: $.noop
                        })
                },
                _selectFirstItem: function() {
                    this._setSelectedElement(this._listItemElements().first())
                },
                _setSelectedElement: function($element) {
                    var $selectedItem = this._listSelectedItemElements();
                    this._changeSelectedItem($selectedItem, $element);
                    this.option("value", this._selectedItemValue())
                },
                _setDeprecatedOptions: function() {
                    this.callBase();
                    $.extend(this._deprecatedOptions, {pagingEnabled: {
                            since: "15.1",
                            message: "Use the 'dataSource.paginate' option instead"
                        }})
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), $.extend(DataExpressionMixin._dataExpressionDefaultOptions(), {
                            displayValue: undefined,
                            searchEnabled: false,
                            searchMode: "contains",
                            searchTimeout: 500,
                            minSearchLength: 0,
                            searchExpr: null,
                            valueChangeEvent: "input change keyup",
                            selectedItem: null,
                            pagingEnabled: undefined,
                            noDataText: Globalize.localize("dxCollectionWidget-noDataText"),
                            onSelectionChanged: null,
                            onItemClick: $.noop,
                            showDataBeforeSearch: false,
                            popupPosition: {
                                my: "left top",
                                at: "left bottom",
                                offset: {
                                    h: 0,
                                    v: 0
                                },
                                collision: "flip"
                            },
                            popupWidthExtension: 0
                        }))
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return device.platform === "win" && device.version && device.version[0] === 8
                                },
                                options: {popupPosition: {offset: {v: -6}}}
                            }, {
                                device: {platform: "android"},
                                options: {popupWidthExtension: 32}
                            }, {
                                device: {platform: "ios"},
                                options: {popupPosition: {offset: {v: -1}}}
                            }])
                },
                _setOptionsByReference: function() {
                    this.callBase();
                    $.extend(this._optionsByReference, {
                        value: true,
                        selectedItem: true,
                        displayValue: true
                    })
                },
                _init: function() {
                    this.callBase();
                    this._initDataExpressions();
                    this._initActions();
                    this._setListDataSource();
                    this._validateSearchMode();
                    this._clearSelectedItem()
                },
                _initActions: function() {
                    this._initContentReadyAction();
                    this._initSelectionChangedAction();
                    this._initItemClickAction()
                },
                _initContentReadyAction: function() {
                    this._contentReadyAction = this._createActionByOption("onContentReady", {excludeValidators: ["disabled", "readOnly"]})
                },
                _initSelectionChangedAction: function() {
                    this._selectionChangedAction = this._createActionByOption("onSelectionChanged", {excludeValidators: ["disabled", "readOnly"]})
                },
                _initItemClickAction: function() {
                    this._itemClickAction = this._createActionByOption("onItemClick")
                },
                _renderField: function() {
                    this.callBase();
                    this._input().on("input", $.proxy(this._setFocusPolicy, this))
                },
                _preventFocusOnPopup: function(e) {
                    if (this._list && this._list.initialOption("focusStateEnabled"))
                        e.preventDefault()
                },
                _createPopup: function() {
                    this.callBase();
                    this._popup._wrapper().addClass(this._popupWrapperClass());
                    this._popup.content().off("mousedown").on("mousedown", $.proxy(this._preventFocusOnPopup, this))
                },
                _popupWrapperClass: function() {
                    return DROPDOWNLIST_POPUP_WRAPPER_CLASS
                },
                _renderInputValue: function() {
                    var callBase = $.proxy(this.callBase, this);
                    return this._loadItem(this.option("value")).always($.proxy(function(item) {
                            this._setSelectedItem(item);
                            this._refreshSelected();
                            callBase()
                        }, this))
                },
                _loadItem: function(value) {
                    var selectedItem = $.grep(this.option("items") || [], $.proxy(function(item) {
                            return this._isValueEquals(this._valueGetter(item), value)
                        }, this))[0];
                    return selectedItem !== undefined ? $.Deferred().resolve(selectedItem).promise() : this._loadValue(value)
                },
                _setSelectedItem: function(item) {
                    var displayValue = this._displayValue(item);
                    this.option("selectedItem", commonUtils.ensureDefined(item, null));
                    this.option("displayValue", displayValue)
                },
                _displayValue: function(item) {
                    return this._displayGetter(item)
                },
                _refreshSelected: function() {
                    this._listItemElements().each($.proxy(function(_, itemElement) {
                        var $itemElement = $(itemElement);
                        var itemValue = this._valueGetter($itemElement.data(LIST_ITEM_DATA_KEY));
                        var isItemSelected = this._isSelectedValue(itemValue);
                        $itemElement.toggleClass(this._selectedItemClass(), isItemSelected);
                        if (isItemSelected)
                            this._list.selectItem($itemElement);
                        else
                            this._list.unselectItem($itemElement)
                    }, this))
                },
                _popupShownHandler: function() {
                    this.callBase();
                    this._setFocusPolicy()
                },
                _setFocusPolicy: function() {
                    if (!this.option("focusStateEnabled") || !this._list)
                        return;
                    this._list.option("focusedElement", null)
                },
                _isSelectedValue: function(value) {
                    return this._isValueEquals(value, this.option("value"))
                },
                _validateSearchMode: function() {
                    var searchMode = this.option("searchMode"),
                        normalizedSearchMode = searchMode.toLowerCase();
                    if ($.inArray(normalizedSearchMode, SEARCH_MODES) < 0)
                        throw errors.Error("E1019", searchMode);
                },
                _clearSelectedItem: function() {
                    this.option("selectedItem", null)
                },
                _processDataSourceChanging: function() {
                    this._setListDataSource();
                    this._renderInputValue().fail($.proxy(function() {
                        if (this._isCustomValueAllowed())
                            return;
                        this.reset()
                    }, this))
                },
                _isCustomValueAllowed: function() {
                    return this.option("displayCustomValue")
                },
                reset: function() {
                    this.option("value", null);
                    this._clearFilter();
                    this._clearSelectedItem()
                },
                _selectedItemClass: function() {
                    return DROPDOWNLIST_SELECTED_CLASS
                },
                _listItemElements: function() {
                    return this._$list ? this._$list.find(LIST_ITEM_SELECTOR) : $()
                },
                _listSelectedItemElements: function() {
                    return this._$list ? this._$list.find("." + this._selectedItemClass()) : $()
                },
                _popupConfig: function() {
                    var that = this;
                    return $.extend(this.callBase(), {
                            width: this.option("width"),
                            onShowing: function() {
                                that.element().addClass(SKIP_GESTURE_EVENT_CLASS)
                            },
                            onHidden: function() {
                                that.element().removeClass(SKIP_GESTURE_EVENT_CLASS)
                            }
                        })
                },
                _renderPopupContent: function() {
                    this._renderList()
                },
                _attachChildKeyboardEvents: function() {
                    this._childKeyboardProcessor = this._keyboardProcessor.attachChildProcessor();
                    this._setListOption("_keyboardProcessor", this._childKeyboardProcessor)
                },
                _fireContentReadyAction: $.noop,
                _setAriaTargetForList: function() {
                    this._list._getAriaTarget = $.proxy(this._getAriaTarget, this);
                    this._list.setAria("role", "combobox")
                },
                _renderList: function() {
                    this._listId = (new DevExpress.data.Guid)._value;
                    var $list = this._$list = $("<div>", {id: this._listId}).appendTo(this._popup.content());
                    this._list = this._createComponent($list, "dxList", this._listConfig());
                    this._refreshList();
                    this._setAriaTargetForList()
                },
                _renderOpenedState: function() {
                    this.callBase();
                    var opened = this.option("opened") || undefined;
                    this.setAria({
                        activedescendant: opened && this._list.getFocusedItemId(),
                        owns: opened && this._listId
                    })
                },
                _refreshList: function() {
                    if (this._list && this._shouldRefreshDataSource())
                        this._setListDataSource()
                },
                _shouldRefreshDataSource: function() {
                    var dataSourceProvided = !!this._list.option("dataSource");
                    return dataSourceProvided !== this._needPassDataSourceToList()
                },
                _listConfig: function() {
                    return {
                            _templates: this.option("_templates"),
                            templateProvider: this.option("templateProvider"),
                            noDataText: this.option("noDataText"),
                            onContentReady: $.proxy(this._listContentReadyHandler, this),
                            itemTemplate: this._getTemplateByOption("itemTemplate"),
                            indicateLoading: false,
                            tabIndex: -1,
                            onItemClick: $.proxy(this._listItemClickAction, this),
                            dataSource: this._getDataSource(),
                            _keyboardProcessor: this._childKeyboardProcessor
                        }
                },
                _getDataSource: function() {
                    return this._needPassDataSourceToList() ? this._dataSource : null
                },
                _dataSourceOptions: function() {
                    this._suppressDeprecatedWarnings();
                    var pagingEnabled = this.option("pagingEnabled");
                    this._resumeDeprecatedWarnings();
                    return {paginate: commonUtils.ensureDefined(pagingEnabled, false)}
                },
                _listContentReadyHandler: function() {
                    this._list = this._list || this._$list.dxList("instance");
                    this.option().items = this._list.option("items");
                    this._refreshSelected();
                    this._dimensionChanged();
                    this._contentReadyAction()
                },
                _setListOption: function(optionName, value) {
                    this._setWidgetOption("_list", arguments)
                },
                _listItemClickAction: function(e) {
                    this._listItemClickHandler(e);
                    this._itemClickAction(e)
                },
                _listItemClickHandler: $.noop,
                _setListDataSource: function() {
                    if (!this._list)
                        return;
                    this._setListOption("dataSource", this._getDataSource());
                    if (!this._needPassDataSourceToList())
                        this._setListOption("items", [])
                },
                _needPassDataSourceToList: function() {
                    return this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded()
                },
                _isMinSearchLengthExceeded: function() {
                    return this._searchValue().toString().length >= this.option("minSearchLength")
                },
                _searchValue: function() {
                    return this._input().val() || ""
                },
                _search: function() {
                    if (!this._isMinSearchLengthExceeded()) {
                        this._searchCanceled();
                        return
                    }
                    var searchTimeout = this.option("searchTimeout");
                    if (searchTimeout) {
                        if (!this._searchTimer)
                            this._searchTimer = setTimeout($.proxy(this._searchDataSource, this), searchTimeout)
                    }
                    else
                        this._searchDataSource()
                },
                _searchCanceled: function() {
                    this._clearSearchTimer();
                    if (this._needPassDataSourceToList())
                        this._filterDataSource(null);
                    this._refreshList()
                },
                _searchDataSource: function() {
                    this._filterDataSource(this._searchValue())
                },
                _filterDataSource: function(searchValue) {
                    var dataSource = this._dataSource;
                    dataSource.searchExpr(this.option("searchExpr") || this._displayGetterExpr());
                    dataSource.searchOperation(this.option("searchMode"));
                    dataSource.searchValue(searchValue);
                    dataSource.pageIndex(0);
                    return dataSource.load().done($.proxy(this._dataSourceFiltered, this))
                },
                _clearFilter: function() {
                    this._dataSource.searchValue(null)
                },
                _dataSourceFiltered: function() {
                    this._clearSearchTimer();
                    this._refreshList();
                    this._refreshPopupVisibility()
                },
                _refreshPopupVisibility: function() {
                    if (this.option("readOnly"))
                        return;
                    this.option("opened", this._hasItemsToShow());
                    if (this.option("opened"))
                        this._dimensionChanged()
                },
                _hasItemsToShow: function() {
                    var resultItems = this._dataSource && this._dataSource.items() || [];
                    var resultAmount = resultItems.length;
                    var isMinSearchLengthExceeded = this._needPassDataSourceToList();
                    return isMinSearchLengthExceeded && resultAmount && this._hasFocusClass()
                },
                _clearSearchTimer: function() {
                    clearTimeout(this._searchTimer);
                    delete this._searchTimer
                },
                _popupShowingHandler: function() {
                    this._dimensionChanged()
                },
                _dimensionChanged: function() {
                    this._popup && this._updatePopupDimensions()
                },
                _updatePopupDimensions: function() {
                    this._updatePopupWidth();
                    this._updatePopupHeight()
                },
                _updatePopupWidth: function() {
                    this._setPopupOption("width", this.element().outerWidth() + this.option("popupWidthExtension"))
                },
                _updatePopupHeight: function() {
                    var popupPadding = this._popup.overlayContent().outerHeight() - this._popup.content().height();
                    var listMargin = this._list ? this._list.element().outerHeight() - this._list.clientHeight() : 0;
                    var listHeight = this._list ? this._list.scrollHeight() + listMargin : 0;
                    var popupHeight = Math.min(listHeight + popupPadding, this._getMaxHeight());
                    this._setPopupOption("height", popupHeight);
                    this._list && this._list.updateDimensions()
                },
                _getMaxHeight: function() {
                    var $element = this.element(),
                        offset = $element.offset(),
                        windowHeight = $(window).height(),
                        maxHeight = Math.max(offset.top, windowHeight - offset.top - $element.outerHeight());
                    return Math.min(windowHeight * 0.5, maxHeight)
                },
                _changeSelectedItem: function($selectedItem, $newItem) {
                    var selectedItemClass = this._selectedItemClass();
                    $selectedItem.removeClass(selectedItemClass);
                    $newItem.addClass(selectedItemClass)
                },
                _selectedItemValue: function() {
                    var $selectedItem = this._listSelectedItemElements();
                    return this._valueGetter($selectedItem.data(LIST_ITEM_DATA_KEY))
                },
                _valueChangeArgs: function() {
                    return $.extend(this.callBase.apply(this, arguments), {
                            selectedItem: this.option("selectedItem"),
                            itemData: this.option("selectedItem")
                        })
                },
                _clean: function() {
                    if (this._list)
                        delete this._list;
                    this.callBase()
                },
                _dispose: function() {
                    this._clearSearchTimer();
                    this.callBase()
                },
                _setCollectionWidgetOption: function() {
                    this._setListOption.apply(this, arguments)
                },
                _needFocusOnButtonClick: function() {
                    return true
                },
                _optionChanged: function(args) {
                    this._dataExpressionOptionChanged(args);
                    switch (args.name) {
                        case"items":
                            if (!this.option("dataSource"))
                                this._processDataSourceChanging();
                            break;
                        case"dataSource":
                            this._processDataSourceChanging();
                            break;
                        case"valueExpr":
                        case"displayExpr":
                            this._renderValue();
                            break;
                        case"searchMode":
                            this._validateSearchMode();
                            break;
                        case"minSearchLength":
                            this._refreshList();
                            break;
                        case"searchEnabled":
                        case"showDataBeforeSearch":
                        case"searchExpr":
                        case"pagingEnabled":
                            this._invalidate();
                            break;
                        case"onContentReady":
                            this._initContentReadyAction();
                            break;
                        case"onSelectionChanged":
                            this._initSelectionChangedAction();
                            break;
                        case"onItemClick":
                            this._initItemClickAction();
                            break;
                        case"noDataText":
                            this._setListOption("noDataText");
                            break;
                        case"displayValue":
                            this.option("text", args.value);
                            break;
                        case"itemTemplate":
                        case"searchTimeout":
                        case"popupWidthExtension":
                            break;
                        case"selectedItem":
                            this._selectionChangedAction({selectedItem: args.value});
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            }).include(DataExpressionMixin);
        registerComponent("dxDropDownList", uiNamespace, DropDownList);
        return DropDownList
    });
    /*! Module widgets-base, file ui.textArea.js */
    DevExpress.define("/ui/widgets/ui.textArea", ["jquery", "/componentRegistrator", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer", "/ui/widgets/ui.textBox", "/ui/uiNamespace"], function($, registerComponent, eventUtils, pointerEvents, TextBox, uiNamespace) {
        var TEXTAREA_CLASS = "dx-textarea",
            TEXTEDITOR_INPUT_CLASS = "dx-texteditor-input";
        var TextArea = TextBox.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {spellcheck: true})
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(TEXTAREA_CLASS);
                    this.setAria("multiline", "true")
                },
                _renderInput: function() {
                    this.callBase();
                    this._renderScrollHandler()
                },
                _createInput: function() {
                    return $("<textarea>").addClass(TEXTEDITOR_INPUT_CLASS).attr(this.option("attr"))
                },
                _renderScrollHandler: function() {
                    var $input = this._input(),
                        eventY = 0;
                    $input.on(eventUtils.addNamespace(pointerEvents.down, this.NAME), function(e) {
                        eventY = eventUtils.eventData(e).y
                    });
                    $input.on(eventUtils.addNamespace(pointerEvents.move, this.NAME), function(e) {
                        var scrollTopPos = $input.scrollTop(),
                            scrollBottomPos = $input.prop("scrollHeight") - $input.prop("clientHeight") - scrollTopPos;
                        if (scrollTopPos === 0 && scrollBottomPos === 0)
                            return;
                        var currentEventY = eventUtils.eventData(e).y;
                        var isScrollFromTop = scrollTopPos === 0 && eventY >= currentEventY,
                            isScrollFromBottom = scrollBottomPos === 0 && eventY <= currentEventY,
                            isScrollFromMiddle = scrollTopPos > 0 && scrollBottomPos > 0;
                        if (isScrollFromTop || isScrollFromBottom || isScrollFromMiddle) {
                            e.isScrollingEvent = true;
                            e.stopPropagation()
                        }
                        eventY = currentEventY
                    })
                },
                _renderInputType: $.noop
            });
        registerComponent("dxTextArea", uiNamespace, TextArea);
        return TextArea
    });
    DevExpress.require(["/ui/widgets/ui.textArea"]);
    /*! Module widgets-base, file ui.numberBox.spin.js */
    DevExpress.define("/ui/widgets/numberBox/ui.numberBox.spin", ["jquery", "/ui/ui.widget", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer", "/ui/events/ui.events.emitter.feedback"], function($, Widget, eventUtils, pointerEvents, feedbackEvents) {
        var SPIN_CLASS = "dx-numberbox-spin",
            SPIN_BUTTON_CLASS = "dx-numberbox-spin-button",
            SPIN_HOLD_DELAY = 100,
            NUMBER_BOX = 'dxNumberBox',
            POINTERUP_EVENT_NAME = eventUtils.addNamespace(pointerEvents.up, NUMBER_BOX),
            POINTERCANCEL_EVENT_NAME = eventUtils.addNamespace(pointerEvents.cancel, NUMBER_BOX);
        var SpinButton = Widget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            direction: "up",
                            onChange: null,
                            activeStateEnabled: true,
                            hoverStateEnabled: true
                        })
                },
                _render: function() {
                    this.callBase();
                    var $element = this.element(),
                        direction = SPIN_CLASS + "-" + this.option("direction");
                    var eventName = eventUtils.addNamespace(pointerEvents.down, this.NAME);
                    $element.addClass(SPIN_BUTTON_CLASS).addClass(direction).off(eventName).on(eventName, $.proxy(this._spinDownHandler, this));
                    this._spinIcon = $("<div>").addClass(direction + "-icon").appendTo(this.element());
                    this._spinChangeHandler = this._createActionByOption("onChange")
                },
                _spinDownHandler: function(e) {
                    e.preventDefault();
                    this._clearTimer();
                    $(document).on("dxhold", $.proxy(function() {
                        this._feedBackDeferred = $.Deferred();
                        feedbackEvents.lock(this._feedBackDeferred);
                        this._spinChangeHandler({jQueryEvent: e});
                        this._holdTimer = setInterval(this._spinChangeHandler, SPIN_HOLD_DELAY, {jQueryEvent: e})
                    }, this)).on(POINTERUP_EVENT_NAME, $.proxy(this._clearTimer, this)).on(POINTERCANCEL_EVENT_NAME, $.proxy(this._clearTimer, this));
                    this._spinChangeHandler({jQueryEvent: e})
                },
                _dispose: function() {
                    this._clearTimer();
                    this.callBase()
                },
                _clearTimer: function(e) {
                    $(document).off(POINTERUP_EVENT_NAME).off(POINTERCANCEL_EVENT_NAME).off("dxhold");
                    if (this._feedBackDeferred)
                        this._feedBackDeferred.resolve();
                    if (this._holdTimer)
                        clearInterval(this._holdTimer)
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"onChange":
                        case"direction":
                            this._invalidate();
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        return SpinButton
    });
    /*! Module widgets-base, file ui.numberBox.js */
    DevExpress.define("/ui/widgets/ui.numberBox", ["jquery", "/utils/utils.common", "/devices", "/componentRegistrator", "/ui/uiNamespace", "/ui/widgets/ui.textEditor", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer", "/ui/events/ui.events.wheel", "/ui/widgets/numberBox/ui.numberBox.spin", "/ui/events/ui.events.emitter.feedback"], function($, commonUtils, devices, registerComponent, uiNamespace, TextEditor, eventUtils, pointerEvents, wheelEvent, SpinButton, feedbackEvents) {
        var math = Math;
        var WIDGET_CLASS = "dx-numberbox",
            SPIN_CLASS = "dx-numberbox-spin",
            SPIN_CONTAINER_CLASS = "dx-numberbox-spin-container",
            SPIN_UP_CLASS = "dx-numberbox-spin-up",
            SPIN_DOWN_CLASS = "dx-numberbox-spin-down",
            SPIN_TOUCH_FRIENDLY_CLASS = "dx-numberbox-spin-touch-friendly",
            CONTROL_KEYS = ["Tab", "Del", "Delete", "Backspace", "Left", "ArrowLeft", "Right", "ArrowRight", "Home", "End"];
        var androidNativeBrowser = devices.real().android && navigator.userAgent.indexOf("Chrome") === -1;
        var NumberBox = TextEditor.inherit({
                _supportedKeys: function() {
                    return $.extend(this.callBase(), {
                            upArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                this._spinUpChangeHandler()
                            },
                            downArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                this._spinDownChangeHandler()
                            },
                            enter: function(e) {
                                this._input().trigger(this.option("valueChangeEvent"))
                            }
                        })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            value: 0,
                            min: undefined,
                            max: undefined,
                            step: 1,
                            showSpinButtons: false,
                            useTouchSpinButtons: true,
                            mode: "number"
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {useTouchSpinButtons: false}
                            }])
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(WIDGET_CLASS);
                    this.setAria("role", "spinbutton");
                    this._renderMouseWheelHandler()
                },
                _keyPressHandler: function(e) {
                    this.callBase(e);
                    var ch = String.fromCharCode(e.which),
                        validCharRegExp = /[\d.,eE\-+]/,
                        isInputCharValid = validCharRegExp.test(ch);
                    if (!isInputCharValid) {
                        if (e.metaKey || e.ctrlKey || e.key && $.inArray(e.key, CONTROL_KEYS) >= 0)
                            return;
                        e.preventDefault();
                        return false
                    }
                    this._isIncompleteValue = false;
                    if (this._isValueIncomplete(this._input().val()))
                        this._isIncompleteValue = true
                },
                _isValueIncomplete: function(value) {
                    var expRegex = /\d+[eE]$/,
                        dotRegex = /^[\.,]$/,
                        negRegex = /^-$/;
                    return expRegex.test(value) || dotRegex.test(value) || negRegex.test(value)
                },
                _renderMouseWheelHandler: function(e) {
                    var eventName = eventUtils.addNamespace(wheelEvent.name, this.NAME);
                    var mouseWheelAction = this._createAction($.proxy(function(e) {
                            this._mouseWheelHandler(e.jQueryEvent)
                        }, this));
                    this._input().off(eventName).on(eventName, function(e) {
                        mouseWheelAction({jQueryEvent: e})
                    })
                },
                _mouseWheelHandler: function(e) {
                    if (!this._input().is(":focus"))
                        return;
                    e.delta > 0 ? this._spinValueChange(1) : this._spinValueChange(-1);
                    e.preventDefault();
                    e.stopPropagation()
                },
                _renderValue: function() {
                    if (!this._input().val().length || Number(this._input().val()) !== this.option("value")) {
                        this._forceValueRender();
                        this._toggleEmptinessEventHandler()
                    }
                    this._renderInputAddons();
                    this.setAria("valuenow", this.option("value"))
                },
                _renderValueEventName: function() {
                    return this.callBase() + " keypress"
                },
                _toggleDisabledState: function(value) {
                    if (this._$spinUp)
                        SpinButton.getInstance(this._$spinUp).option("disabled", value);
                    if (this._$spinDown)
                        SpinButton.getInstance(this._$spinDown).option("disabled", value);
                    this.callBase.apply(this, arguments)
                },
                _forceValueRender: function() {
                    var $input = this._input(),
                        value = this.option("value"),
                        valueFormat = this.option("valueFormat");
                    if (androidNativeBrowser) {
                        var inputType = $input.attr("type");
                        this._setInputType("text");
                        $input.val(valueFormat(value));
                        this._setInputType(inputType)
                    }
                    else
                        $input.val(valueFormat(value))
                },
                _renderProps: function() {
                    this.callBase();
                    this._input().prop({
                        min: this.option("min"),
                        max: this.option("max"),
                        step: this.option("step")
                    });
                    this.setAria({
                        valuemin: this.option("min") || "undefined",
                        valuemax: this.option("max") || "undefined"
                    })
                },
                _renderInputAddons: function() {
                    this.callBase();
                    this._renderSpinButtons()
                },
                _renderSpinButtons: function() {
                    var spinButtonsVisible = this.option("showSpinButtons");
                    this.element().toggleClass(SPIN_CLASS, spinButtonsVisible);
                    this._toggleTouchFriendlyClass();
                    if (!spinButtonsVisible) {
                        this._$spinContainer && this._$spinContainer.remove();
                        this._$spinContainer = null;
                        return
                    }
                    if (!this._$spinContainer)
                        this._$spinContainer = this._createSpinButtons();
                    this._$spinContainer.prependTo(this._buttonsContainer())
                },
                _toggleTouchFriendlyClass: function() {
                    this.element().toggleClass(SPIN_TOUCH_FRIENDLY_CLASS, this.option("showSpinButtons") && this.option("useTouchSpinButtons"))
                },
                _createSpinButtons: function() {
                    var eventName = eventUtils.addNamespace(pointerEvents.down, this.NAME);
                    var pointerDownAction = this._createAction($.proxy(this._spinButtonsPointerDownHandler, this));
                    var $spinContainer = $("<div>").addClass(SPIN_CONTAINER_CLASS).off(eventName).on(eventName, function(e) {
                            pointerDownAction({jQueryEvent: e})
                        });
                    this._$spinUp = $("<div>").appendTo($spinContainer);
                    this._createComponent(this._$spinUp, SpinButton, {
                        direction: "up",
                        onChange: $.proxy(this._spinUpChangeHandler, this)
                    });
                    this._$spinDown = $("<div>").appendTo($spinContainer);
                    this._createComponent(this._$spinDown, SpinButton, {
                        direction: "down",
                        onChange: $.proxy(this._spinDownChangeHandler, this)
                    });
                    return $spinContainer
                },
                _spinButtonsPointerDownHandler: function(e) {
                    e.dxPreventBlur = true;
                    var $input = this._input();
                    if (!this.option("useTouchSpinButtons") && document.activeElement !== $input[0])
                        $input.trigger("focus")
                },
                _spinUpChangeHandler: function() {
                    if (!this.option("readOnly"))
                        this._spinValueChange(1)
                },
                _spinDownChangeHandler: function() {
                    if (!this.option("readOnly"))
                        this._spinValueChange(-1)
                },
                _spinValueChange: function(sign) {
                    var value = parseFloat(this._validationRequired() ? this._oldValue : this._normalizeInputValue()) || 0,
                        step = parseFloat(this.option("step"));
                    value = this._correctRounding(value, step * sign);
                    this.option("value", value)
                },
                _correctRounding: function(value, step) {
                    var regex = /[,|.](.*)/;
                    var isFloatValue = regex.test(value),
                        isFloatStep = regex.test(step);
                    if (isFloatValue || isFloatStep) {
                        var valueAccuracy = isFloatValue ? regex.exec(value)[0].length : 0,
                            stepAccuracy = isFloatStep ? regex.exec(step)[0].length : 0,
                            accuracy = math.max(valueAccuracy, stepAccuracy);
                        value = this._round(value + step, accuracy);
                        return value
                    }
                    return value + step
                },
                _round: function(value, precision) {
                    precision = precision || 0;
                    var multiplier = Math.pow(10, precision);
                    value *= multiplier;
                    value = Math.round(value) / multiplier;
                    return value
                },
                _renderValueChangeEvent: function() {
                    this.callBase();
                    this._input().focusout($.proxy(this._forceRefreshInputValue, this))
                },
                _forceRefreshInputValue: function() {
                    var $input = this._input(),
                        valueFormat = this.option("valueFormat");
                    $input.val(null);
                    $input.val(valueFormat(this.option("value")))
                },
                _valueChangeEventHandler: function(e) {
                    if (this._validationRequired()) {
                        this._inputInvalidHandler();
                        return
                    }
                    var $input = this._input(),
                        value = this._normalizeInputValue(),
                        valueFormat = this.option("valueFormat");
                    if (this._isIncompleteValue)
                        return;
                    if (Number($input.val()) !== value)
                        $input.val(valueFormat(this.option("value")), valueFormat(value));
                    this.callBase(e, value)
                },
                _validationRequired: function() {
                    return !this._isIncompleteValue && !this._validateValue(this._normalizeText())
                },
                _validateValue: function(value) {
                    var isValueValid = this._isValueValid();
                    if (!value && isValueValid) {
                        this.option("value", null);
                        return true
                    }
                    var isNumber = /^[-+]?(0|[1-9]\d*)?([.,]\d+)?([eE][-+]?\d+)?/.test(value);
                    this._oldValue = this.option("value");
                    if (!isNumber && !isValueValid)
                        return false;
                    return true
                },
                _inputInvalidHandler: function() {
                    var $input = this._input(),
                        isValueDefined = commonUtils.isDefined(this._oldValue);
                    this.option("value", isValueDefined ? this._oldValue : null);
                    isValueDefined && $input.val(this._oldValue);
                    this._oldValue = null
                },
                _normalizeInputValue: function() {
                    var value = this._normalizeValue();
                    return commonUtils.isDefined(value) ? value : this.option("value")
                },
                _normalizeValue: function(value) {
                    return this._parseValue(this._normalizeText(value))
                },
                _normalizeText: function(value) {
                    value = $.trim(commonUtils.isDefined(value) ? value : this._input().val());
                    return value.replace(",", ".")
                },
                _parseValue: function(value) {
                    var number = parseFloat(value);
                    if (this.option("min") !== undefined)
                        number = math.max(number, this.option("min"));
                    if (this.option("max") !== undefined)
                        number = math.min(number, this.option("max"));
                    return number
                },
                _setValue: function(value, prevValue) {
                    if (value == null || value === "") {
                        this.option("value", null);
                        if (value !== null)
                            this._suppressValueChangeAction();
                        return
                    }
                    var newValue = this._normalizeValue(value);
                    if (!newValue && newValue !== 0) {
                        this.option("value", prevValue);
                        this._suppressValueChangeAction();
                        return
                    }
                    if (value !== newValue) {
                        this.option("value", newValue);
                        this._suppressValueChangeAction()
                    }
                },
                _clean: function() {
                    delete this._$spinContainer;
                    delete this._$spinUp;
                    delete this._$spinDown;
                    this.callBase()
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"value":
                            this._setValue(args.value, args.previousValue);
                            this.callBase(args);
                            this._resumeValueChangeAction();
                            break;
                        case"step":
                        case"min":
                        case"max":
                            this._renderProps();
                            break;
                        case"showSpinButtons":
                            this._renderInputAddons();
                            break;
                        case"useTouchSpinButtons":
                            this._toggleTouchFriendlyClass();
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        registerComponent("dxNumberBox", uiNamespace, NumberBox);
        NumberBox.__internals = {
            WIDGET_CLASS: WIDGET_CLASS,
            SPIN_CLASS: SPIN_CLASS,
            SPIN_CONTAINER_CLASS: SPIN_CONTAINER_CLASS,
            SPIN_UP_CLASS: SPIN_UP_CLASS,
            SPIN_DOWN_CLASS: SPIN_DOWN_CLASS
        };
        return NumberBox
    });
    DevExpress.require(["/ui/widgets/ui.numberBox"]);
    /*! Module widgets-base, file ui.radioButton.js */
    DevExpress.define("/ui/widgets/ui.radioButton", ["jquery", "/devices", "/utils/utils.inkRipple", "/componentRegistrator", "/ui/ui.editor", "/ui/uiNamespace", "/ui/events/ui.events.utils"], function($, devices, inkRipple, registerComponent, Editor, uiNamespace, eventUtils) {
        var RADIO_BUTTON_CLASS = "dx-radiobutton",
            RADIO_BUTTON_ICON_CLASS = "dx-radiobutton-icon",
            RADIO_BUTTON_ICON_DOT_CLASS = "dx-radiobutton-icon-dot",
            RADIO_BUTTON_CHECKED_CLASS = "dx-radiobutton-checked";
        var RadioButton = Editor.inherit({
                _supportedKeys: function() {
                    var click = function(e) {
                            e.preventDefault();
                            this._clickAction({jQueryEvent: e})
                        };
                    return $.extend(this.callBase(), {space: click})
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            hoverStateEnabled: true,
                            activeStateEnabled: true,
                            value: false,
                            useInkRipple: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }, {
                                device: {platform: "android"},
                                options: {useInkRipple: true}
                            }])
                },
                _init: function() {
                    this.callBase();
                    this.element().addClass(RADIO_BUTTON_CLASS)
                },
                _render: function() {
                    this.callBase();
                    this._renderIcon();
                    this.option("useInkRipple") && this._renderInkRipple();
                    this._renderCheckedState(this.option("value"));
                    this._renderClick();
                    this.setAria("role", "radio")
                },
                _renderInkRipple: function() {
                    this._inkRipple = inkRipple.render({
                        waveSizeCoeffient: 3.3,
                        isCentered: true
                    })
                },
                _renderInkWave: function(element, jQueryEvent, doRender) {
                    if (!this._inkRipple)
                        return;
                    var config = {
                            element: element,
                            jQueryEvent: jQueryEvent
                        };
                    if (doRender)
                        this._inkRipple.renderWave(config);
                    else
                        this._inkRipple.removeWave(config)
                },
                _updateFocusState: function(e, value) {
                    this.callBase.apply(this, arguments);
                    this._renderInkWave(this._$icon, e, value)
                },
                _toggleActiveState: function($element, value, e) {
                    this.callBase.apply(this, arguments);
                    this._renderInkWave(this._$icon, e, value)
                },
                _renderIcon: function() {
                    this._$icon = $("<div>").addClass(RADIO_BUTTON_ICON_CLASS);
                    $("<div>").addClass(RADIO_BUTTON_ICON_DOT_CLASS).appendTo(this._$icon);
                    this.element().append(this._$icon)
                },
                _renderCheckedState: function(checked) {
                    this.element().toggleClass(RADIO_BUTTON_CHECKED_CLASS, checked);
                    this.setAria("checked", checked)
                },
                _renderClick: function() {
                    var eventName = eventUtils.addNamespace("dxclick", this.NAME);
                    this._clickAction = this._createAction($.proxy(function(args) {
                        this._clickHandler(args.jQueryEvent)
                    }, this));
                    this.element().off(eventName).on(eventName, $.proxy(function(e) {
                        this._clickAction({jQueryEvent: e})
                    }, this))
                },
                _clickHandler: function(e) {
                    this._saveValueChangeEvent(e);
                    this.option("value", true)
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"useInkRipple":
                            this._invalidate();
                            break;
                        case"value":
                            this._renderCheckedState(args.value);
                            this.callBase(args);
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        registerComponent("dxRadioButton", uiNamespace, RadioButton);
        return RadioButton
    });
    /*! Module widgets-base, file ui.radioGroup.js */
    DevExpress.define("/ui/widgets/ui.radioGroup", ["jquery", "/devices", "/componentRegistrator", "/ui/ui.editor", "/ui/uiNamespace", "/utils/utils.inkRipple", "/ui/ui.dataExpression"], function($, devices, registerComponent, Editor, uiNamespace, inkRipple, DataExpressionMixin) {
        var RADIO_GROUP_CLASS = "dx-radiogroup",
            RADIO_GROUP_VERTICAL_CLASS = "dx-radiogroup-vertical",
            RADIO_GROUP_HORIZONTAL_CLASS = "dx-radiogroup-horizontal",
            RADIO_BUTTON_CLASS = "dx-radiobutton",
            RADIO_BUTTON_ICON_CLASS = "dx-radiobutton-icon",
            RADIO_BUTTON_ICON_DOT_CLASS = "dx-radiobutton-icon-dot",
            RADIO_VALUE_CONTAINER_CLASS = "dx-radio-value-container",
            RADIO_BUTTON_CHECKED_CLASS = "dx-radiobutton-checked",
            ITEM_DATA_KEY = "dxItemData",
            RADIO_FEEDBACK_HIDE_TIMEOUT = 100;
        var RadioCollection = DevExpress.ui.CollectionWidget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), DataExpressionMixin._dataExpressionDefaultOptions(), {_itemAttributes: {role: "radio"}})
                },
                _supportedKeys: function(e) {
                    var parent = this.callBase();
                    return $.extend({}, parent, {
                            enter: function(e) {
                                e.preventDefault();
                                return parent.enter.apply(this, arguments)
                            },
                            space: function(e) {
                                e.preventDefault();
                                return parent.space.apply(this, arguments)
                            }
                        })
                },
                _focusTarget: function() {
                    return this.element().parent()
                },
                _keyboardEventBindingTarget: function() {
                    return this._focusTarget()
                }
            });
        RadioCollection.publicName("dxRadioCollection");
        var RadioGroup = Editor.inherit({
                _activeStateUnit: "." + RADIO_BUTTON_CLASS,
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), $.extend(DataExpressionMixin._dataExpressionDefaultOptions(), {
                            hoverStateEnabled: true,
                            activeStateEnabled: true,
                            layout: "vertical",
                            useInkRipple: false
                        }))
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: {tablet: true},
                                options: {layout: "horizontal"}
                            }, {
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }, {
                                device: {platform: "android"},
                                options: {useInkRipple: true}
                            }])
                },
                _setOptionsByReference: function() {
                    this.callBase();
                    $.extend(this._optionsByReference, {value: true})
                },
                _dataSourceOptions: function() {
                    return {paginate: false}
                },
                _init: function() {
                    this.callBase();
                    this._initDataExpressions();
                    this._feedbackHideTimeout = RADIO_FEEDBACK_HIDE_TIMEOUT
                },
                _render: function() {
                    this.element().addClass(RADIO_GROUP_CLASS);
                    this._renderRadios();
                    this.setAria("role", "radiogroup");
                    this.callBase();
                    this._renderLayout();
                    this._updateItemsSize();
                    this.option("useInkRipple") && this._renderInkRipple()
                },
                _renderInkRipple: function() {
                    this._inkRipple = inkRipple.render({
                        waveSizeCoeffient: 3.3,
                        isCentered: true
                    })
                },
                _toggleActiveState: function($element, value, e) {
                    this.callBase.apply(this, arguments);
                    if (!this._inkRipple)
                        return;
                    if (value)
                        this._inkRipple.renderWave({
                            element: $element.find("." + RADIO_BUTTON_ICON_CLASS),
                            jQueryEvent: e
                        });
                    else
                        this._inkRipple.removeWave({
                            element: $element.find("." + RADIO_BUTTON_ICON_CLASS),
                            jQueryEvent: e
                        })
                },
                _renderFocusState: $.noop,
                _renderRadios: function() {
                    var $radios = $("<div>").appendTo(this.element());
                    this._radios = this._createComponent($radios, RadioCollection, {
                        dataSource: this._dataSource,
                        onItemRendered: $.proxy(this._itemRenderedHandler, this),
                        onItemClick: $.proxy(this._itemClickHandler, this),
                        itemTemplate: this._getTemplateByOption("itemTemplate"),
                        scrollingEnabled: false,
                        focusStateEnabled: this.option("focusStateEnabled"),
                        accessKey: this.option("accessKey"),
                        tabIndex: this.option("tabIndex"),
                        noDataText: ""
                    });
                    this._setCollectionWidgetOption("onContentReady", $.proxy(this._contentReadyHandler, this));
                    this._contentReadyHandler()
                },
                _contentReadyHandler: function() {
                    this.itemElements().addClass(RADIO_BUTTON_CLASS);
                    this._refreshSelected()
                },
                _itemRenderedHandler: function(e) {
                    if (e.itemData.html)
                        return;
                    var $radio,
                        $radioContainer;
                    $radio = $("<div>").addClass(RADIO_BUTTON_ICON_CLASS);
                    $("<div>").addClass(RADIO_BUTTON_ICON_DOT_CLASS).appendTo($radio);
                    $radioContainer = $("<div>").append($radio).addClass(RADIO_VALUE_CONTAINER_CLASS);
                    e.itemElement.prepend($radioContainer)
                },
                _itemClickHandler: function(e) {
                    this.option("value", this._getItemValue(e.itemData))
                },
                _getItemValue: function(item) {
                    return !!this._valueGetter ? this._valueGetter(item) : item.text
                },
                itemElements: function() {
                    return this._radios.itemElements()
                },
                _renderDimensions: function() {
                    this.callBase();
                    this._updateItemsSize()
                },
                _renderLayout: function() {
                    var layout = this.option("layout");
                    this.element().toggleClass(RADIO_GROUP_VERTICAL_CLASS, layout === "vertical");
                    this.element().toggleClass(RADIO_GROUP_HORIZONTAL_CLASS, layout === "horizontal")
                },
                _refreshSelected: function() {
                    var selectedValue = this.option("value");
                    this.itemElements().each($.proxy(function(_, item) {
                        var $item = $(item);
                        var itemValue = this._valueGetter($item.data(ITEM_DATA_KEY));
                        $item.toggleClass(RADIO_BUTTON_CHECKED_CLASS, this._isValueEquals(itemValue, selectedValue));
                        this.setAria("checked", this._isValueEquals(itemValue, selectedValue), $item)
                    }, this))
                },
                _updateItemsSize: function() {
                    if (this.option("layout") === "horizontal")
                        this.itemElements().css("height", "auto");
                    else {
                        var itemsCount = this.option("items").length;
                        this.itemElements().css("height", 100 / itemsCount + "%")
                    }
                },
                _getAriaTarget: function() {
                    return this.element()
                },
                _setCollectionWidgetOption: function() {
                    this._setWidgetOption("_radios", arguments)
                },
                _optionChanged: function(args) {
                    this._dataExpressionOptionChanged(args);
                    switch (args.name) {
                        case"useInkRipple":
                            this._invalidate();
                            break;
                        case"focusStateEnabled":
                        case"accessKey":
                        case"tabIndex":
                            this._setCollectionWidgetOption(args.name, args.value);
                            break;
                        case"disabled":
                            this.callBase(args);
                            this._setCollectionWidgetOption(args.name, args.value);
                            break;
                        case"dataSource":
                            this._setCollectionWidgetOption("dataSource");
                            break;
                        case"valueExpr":
                            this._refreshSelected();
                            break;
                        case"value":
                            this._refreshSelected();
                            this.callBase(args);
                            break;
                        case"items":
                        case"itemTemplate":
                        case"displayExpr":
                            break;
                        case"layout":
                            this._renderLayout();
                            this._updateItemsSize();
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            }).include(DataExpressionMixin);
        registerComponent("dxRadioGroup", uiNamespace, RadioGroup);
        return RadioGroup
    });
    DevExpress.require(["/ui/widgets/ui.radioGroup"]);
    /*! Module widgets-base, file ui.tabs.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator"),
            Button = DX.require("/ui/widgets/ui.button"),
            inkRipple = DX.require("/utils/utils.inkRipple"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer"),
            TABS_CLASS = "dx-tabs",
            TABS_WRAPPER_CLASS = "dx-indent-wrapper",
            TABS_EXPANDED_CLASS = "dx-tabs-expanded",
            TABS_SCROLLABLE_CLASS = "dx-scrollable-wrapper",
            TABS_NAV_BUTTONS_CLASS = "dx-tabs-nav-buttons",
            TABS_ITEM_CLASS = "dx-tab",
            TABS_ITEM_SELECTOR = ".dx-tab",
            TABS_ITEM_SELECTED_CLASS = "dx-tab-selected",
            TABS_NAV_BUTTON_CLASS = "dx-tabs-nav-button",
            TABS_LEFT_NAV_BUTTON_CLASS = "dx-tabs-nav-button-left",
            TABS_RIGHT_NAV_BUTTON_CLASS = "dx-tabs-nav-button-right",
            TABS_ITEM_DATA_KEY = "dxTabData",
            FEEDBACK_HIDE_TIMEOUT = 100,
            FEEDBACK_DURATION_INTERVAL = 5,
            FEEDBACK_SCROLL_TIMEOUT = 300,
            ACTIVE_STATE_CLASS = "dx-state-active",
            TAB_OFFSET = 30;
        registerComponent("dxTabs", ui, ui.CollectionWidget.inherit({
            _activeStateUnit: TABS_ITEM_SELECTOR,
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        hoverStateEnabled: true,
                        showNavButtons: false,
                        scrollByContent: true,
                        scrollingEnabled: true,
                        selectionMode: "single",
                        activeStateEnabled: true,
                        selectionRequired: false,
                        selectOnFocus: true,
                        loopItemFocus: false,
                        useInkRipple: false
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "generic"},
                            options: {
                                showNavButtons: true,
                                scrollByContent: false
                            }
                        }, {
                            device: function(device) {
                                return devices.real().generic && !devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }, {
                            device: {platform: "android"},
                            options: {useInkRipple: true}
                        }])
            },
            _init: function() {
                this.callBase();
                this._renderMultiple();
                this.element().addClass(TABS_CLASS);
                this._feedbackHideTimeout = FEEDBACK_HIDE_TIMEOUT
            },
            _itemClass: function() {
                return TABS_ITEM_CLASS
            },
            _selectedItemClass: function() {
                return TABS_ITEM_SELECTED_CLASS
            },
            _itemDataKey: function() {
                return TABS_ITEM_DATA_KEY
            },
            _render: function() {
                this.element().removeClass(TABS_EXPANDED_CLASS);
                this.callBase();
                this._renderWrapper();
                if (this._allowScrolling()) {
                    this._renderScrollable();
                    this._renderNavButtons()
                }
                else {
                    this.element().removeClass(TABS_NAV_BUTTONS_CLASS);
                    this.element().addClass(TABS_EXPANDED_CLASS)
                }
                this.setAria("role", "tablist");
                var that = this;
                this.itemElements().each(function(_, item) {
                    that.setAria("role", "tab", $(item))
                });
                this.element().addClass(ACTIVE_STATE_CLASS).removeClass(ACTIVE_STATE_CLASS);
                this.option("useInkRipple") && this._renderInkRipple()
            },
            _renderInkRipple: function() {
                this._inkRipple = inkRipple.render()
            },
            _toggleActiveState: function($element, value, e) {
                this.callBase.apply(this, arguments);
                if (!this._inkRipple)
                    return;
                var config = {
                        element: $element,
                        jQueryEvent: e
                    };
                if (value)
                    this._inkRipple.renderWave(config);
                else
                    this._inkRipple.removeWave(config)
            },
            _renderMultiple: function() {
                if (this.option("selectionMode") === "multi")
                    this.option("selectOnFocus", false)
            },
            _renderWrapper: function() {
                this.element().wrapInner($("<div>").addClass(TABS_WRAPPER_CLASS))
            },
            _renderScrollable: function() {
                var $itemContainer = this.element().wrapInner($("<div>").addClass(TABS_SCROLLABLE_CLASS)).children();
                this._scrollable = this._createComponent($itemContainer, "dxScrollable", {
                    direction: "horizontal",
                    showScrollbar: false,
                    useKeyboard: false,
                    useNative: false,
                    scrollByContent: this.option("scrollByContent"),
                    onScroll: $.proxy(this._updateNavButtonsVisibility, this)
                });
                this.element().append(this._scrollable.element())
            },
            _allowScrolling: function() {
                if (!this.option("scrollingEnabled"))
                    return false;
                var tabItemsWidth = 0;
                this.itemElements().each(function(_, tabItem) {
                    tabItemsWidth += $(tabItem).outerWidth(true)
                });
                return tabItemsWidth - 1 > this.element().width()
            },
            _renderNavButtons: function() {
                this.element().toggleClass(TABS_NAV_BUTTONS_CLASS, this.option("showNavButtons"));
                if (this.option("showNavButtons")) {
                    this._leftButton = this._createNavButton(-TAB_OFFSET, "chevronprev");
                    var $leftButton = this._leftButton.element();
                    $leftButton.addClass(TABS_LEFT_NAV_BUTTON_CLASS);
                    this.element().prepend($leftButton);
                    this._rightButton = this._createNavButton(TAB_OFFSET, "chevronnext");
                    var $rightButton = this._rightButton.element();
                    $rightButton.addClass(TABS_RIGHT_NAV_BUTTON_CLASS);
                    this.element().append($rightButton);
                    this._updateNavButtonsVisibility();
                    this._scrollable.update();
                    if (this.option("rtlEnabled"))
                        this._scrollable.scrollTo({left: this._scrollable.scrollWidth() - this._scrollable.clientWidth()})
                }
            },
            _updateNavButtonsVisibility: function() {
                this._leftButton && this._leftButton.option("disabled", this._scrollable.scrollLeft() <= 0);
                this._rightButton && this._rightButton.option("disabled", this._scrollable.scrollLeft() >= this._scrollable.scrollWidth() - this._scrollable.clientWidth())
            },
            _updateScrollPosition: function(offset, duration) {
                this._scrollable.update();
                this._scrollable.scrollBy(offset / duration)
            },
            _createNavButton: function(offset, icon) {
                var that = this;
                var holdAction = that._createAction(function() {
                        that._holdInterval = setInterval(function() {
                            that._updateScrollPosition(offset, FEEDBACK_DURATION_INTERVAL)
                        }, FEEDBACK_DURATION_INTERVAL)
                    }),
                    holdEventName = eventUtils.addNamespace('dxhold', "dxNavButton"),
                    pointerUpEventName = eventUtils.addNamespace(pointerEvents.up, "dxNavButton"),
                    pointerOutEventName = eventUtils.addNamespace(pointerEvents.out, "dxNavButton");
                var navButton = this._createComponent($("<div>").addClass(TABS_NAV_BUTTON_CLASS), Button, {
                        focusStateEnabled: false,
                        icon: icon,
                        type: "back",
                        onClick: function() {
                            that._updateScrollPosition(offset, 1)
                        },
                        _templates: {}
                    });
                navButton.element().on(holdEventName, {timeout: FEEDBACK_SCROLL_TIMEOUT}, $.proxy(function(e) {
                    holdAction({jQueryEvent: e})
                }, this)).on(pointerUpEventName, function() {
                    that._clearInterval()
                }).on(pointerOutEventName, function() {
                    that._clearInterval()
                });
                return navButton
            },
            _clearInterval: function() {
                if (this._holdInterval)
                    clearInterval(this._holdInterval)
            },
            _renderSelection: function(addedSelection) {
                this._scrollable && this._scrollable.scrollToElement(this.itemElements().eq(addedSelection[0]), {
                    left: 1,
                    right: 1
                })
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._dimensionChanged()
            },
            _dimensionChanged: function() {
                this._refresh()
            },
            _itemSelectHandler: function(e) {
                if (this.option("selectionMode") === "single" && this.isItemSelected(e.currentTarget))
                    return;
                this.callBase(e)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"useInkRipple":
                    case"scrollingEnabled":
                    case"showNavButtons":
                        this._invalidate();
                        break;
                    case"scrollByContent":
                        this._scrollable && this._scrollable.option(args.name, args.value);
                        break;
                    case"selectionMode":
                        this._renderMultiple();
                        this.callBase(args);
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.navBar.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            registerComponent = DX.require("/componentRegistrator"),
            NAVBAR_CLASS = "dx-navbar",
            ITEM_CLASS = "dx-item-content",
            NAVBAR_ITEM_CLASS = "dx-nav-item",
            NAVBAR_ITEM_CONTENT_CLASS = "dx-nav-item-content";
        registerComponent("dxNavBar", ui, ui.dxTabs.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {scrollingEnabled: false})
            },
            _render: function() {
                this.callBase();
                this.element().addClass(NAVBAR_CLASS)
            },
            _postprocessRenderItem: function(args) {
                this.callBase(args);
                var $itemElement = args.itemElement,
                    itemData = args.itemData;
                $itemElement.addClass(NAVBAR_ITEM_CLASS);
                $itemElement.find("." + ITEM_CLASS).addClass(NAVBAR_ITEM_CONTENT_CLASS);
                if (!itemData.icon && !itemData.iconSrc)
                    $itemElement.addClass("dx-navbar-text-item")
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.toolbar.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx,
            translator = DX.require("/utils/utils.translator"),
            hideTopOverlayCallback = DX.require("/utils/utils.topOverlay").hideCallback,
            registerComponent = DX.require("/componentRegistrator"),
            Button = DX.require("/ui/widgets/ui.button");
        var TOOLBAR_CLASS = "dx-toolbar",
            TOOLBAR_BOTTOM_CLASS = "dx-toolbar-bottom",
            TOOLBAR_MINI_CLASS = "dx-toolbar-mini",
            TOOLBAR_ITEM_CLASS = "dx-toolbar-item",
            TOOLBAR_LABEL_CLASS = "dx-toolbar-label",
            TOOLBAR_BUTTON_CLASS = "dx-toolbar-button",
            TOOLBAR_MENU_CONTAINER_CLASS = "dx-toolbar-menu-container",
            TOOLBAR_MENU_BUTTON_CLASS = "dx-toolbar-menu-button",
            TOOLBAR_ITEMS_CONTAINER_CLASS = "dx-toolbar-items-container",
            TOOLBAR_LABEL_SELECTOR = "." + TOOLBAR_LABEL_CLASS,
            TOOLBAR_ITEM_DATA_KEY = "dxToolbarItemDataKey",
            SUBMENU_SWIPE_EASING = "easeOutCubic",
            SUBMENU_HIDE_DURATION = 200,
            SUBMENU_SHOW_DURATION = 400;
        var slideSubmenu = function($element, position, isShowAnimation) {
                var duration = isShowAnimation ? SUBMENU_SHOW_DURATION : SUBMENU_HIDE_DURATION;
                fx.animate($element, {
                    type: "slide",
                    to: {top: position},
                    easing: SUBMENU_SWIPE_EASING,
                    duration: duration
                })
            };
        registerComponent("dxToolbar", ui, ui.CollectionWidget.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        menuItemTemplate: "menuItem",
                        submenuType: "dxDropDownMenu",
                        renderAs: "topToolbar"
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "ios"},
                            options: {submenuType: "dxActionSheet"}
                        }, {
                            device: {platform: "android"},
                            options: {submenuType: "dxDropDownMenu"}
                        }, {
                            device: function() {
                                var currentTheme = (ui.themes.current() || "").split(".")[0];
                                return currentTheme === "win8"
                            },
                            options: {submenuType: "dxList"}
                        }])
            },
            _itemContainer: function() {
                return this._$toolbarItemsContainer.find([".dx-toolbar-before", ".dx-toolbar-center", ".dx-toolbar-after"].join(","))
            },
            _itemClass: function() {
                return TOOLBAR_ITEM_CLASS
            },
            _itemDataKey: function() {
                return TOOLBAR_ITEM_DATA_KEY
            },
            _dimensionChanged: function() {
                if (this._menu)
                    this._toggleMenuVisibility(false, true);
                this._arrangeTitle()
            },
            _render: function() {
                this._renderToolbar();
                this._renderSections();
                this.callBase();
                this._renderMenu();
                this._arrangeTitle();
                this.setAria("role", "toolbar")
            },
            _renderToolbar: function() {
                this.element().addClass(TOOLBAR_CLASS).toggleClass(TOOLBAR_BOTTOM_CLASS, this.option("renderAs") === "bottomToolbar");
                this._$toolbarItemsContainer = $("<div>").appendTo(this.element());
                this._$toolbarItemsContainer.addClass(TOOLBAR_ITEMS_CONTAINER_CLASS)
            },
            _renderSections: function() {
                var $container = this._$toolbarItemsContainer,
                    that = this;
                $.each(["before", "center", "after"], function() {
                    var sectionClass = "dx-toolbar-" + this,
                        $section = $container.find("." + sectionClass);
                    if (!$section.length)
                        that["_$" + this + "Section"] = $section = $("<div>").addClass(sectionClass).appendTo($container)
                })
            },
            _arrangeTitle: function() {
                var $label = this._$toolbarItemsContainer.find(TOOLBAR_LABEL_SELECTOR).eq(0),
                    $section = $label.parent();
                if (!$label.length)
                    return;
                if (this.element().is(":hidden"))
                    return;
                var containerWidth = this._$toolbarItemsContainer.width(),
                    labelOffset = this._$beforeSection.outerWidth() ? this._$beforeSection.outerWidth() : $label.position().left,
                    widthBeforeSection = $section.hasClass("dx-toolbar-before") ? 0 : labelOffset,
                    widthAfterSection = $section.hasClass("dx-toolbar-after") ? 0 : this._$afterSection.outerWidth(),
                    elemsAtSectionWidth = 0;
                $section.children().not(TOOLBAR_LABEL_SELECTOR).each(function() {
                    elemsAtSectionWidth += $(this).outerWidth()
                });
                var freeSpace = containerWidth - elemsAtSectionWidth,
                    centeredLabelWidth = freeSpace - Math.max(widthBeforeSection, widthAfterSection) * 2,
                    labelLongerThanCenteredWidth = Math.round($label.outerWidth()) > Math.round(centeredLabelWidth);
                $section.css({
                    marginLeft: labelLongerThanCenteredWidth ? widthBeforeSection : "",
                    marginRight: labelLongerThanCenteredWidth ? widthAfterSection : "",
                    float: labelLongerThanCenteredWidth && widthAfterSection > widthBeforeSection ? "right" : "none"
                });
                var labelPaddings = $label.outerWidth() - $label.width();
                $label.css("max-width", freeSpace - widthBeforeSection - widthAfterSection - labelPaddings)
            },
            _renderItem: function(index, item, _, $after) {
                var location = item.location || "center",
                    container = this._$toolbarItemsContainer.find(".dx-toolbar-" + location),
                    itemHasText = Boolean(item.text),
                    itemElement = this.callBase(index, item, container, $after);
                itemElement.toggleClass(TOOLBAR_BUTTON_CLASS, !itemHasText).toggleClass(TOOLBAR_LABEL_CLASS, itemHasText);
                return itemElement
            },
            _hasVisibleMenuItems: function() {
                var menuItems = this._getMenuItems(),
                    result = false;
                var optionGetter = DevExpress.data.utils.compileGetter("visible");
                $.each(menuItems, function(index, item) {
                    var itemVisible = optionGetter(item, {functionsAsIs: true});
                    if (itemVisible !== false)
                        result = true
                });
                return result
            },
            _getToolbarItems: function() {
                return $.grep(this.option("items") || [], function(item) {
                        return item.location !== "menu"
                    })
            },
            _getMenuItems: function() {
                return $.grep(this.option("items") || [], function(item) {
                        return item.location === "menu"
                    })
            },
            _renderContentImpl: function() {
                var items = this._getToolbarItems();
                this.element().toggleClass(TOOLBAR_MINI_CLASS, items.length === 0);
                if (this._renderedItemsCount)
                    this._renderItems(items.slice(this._renderedItemsCount));
                else
                    this._renderItems(items)
            },
            _renderMenu: function() {
                var that = this,
                    itemClickAction = this._createActionByOption("onItemClick");
                var options = {
                        itemTemplate: function() {
                            if (that._menuType === "dxActionSheet")
                                return that._getTemplate("actionSheetItem");
                            return that._getTemplateByOption("menuItemTemplate")
                        },
                        onItemClick: function(e) {
                            that._toggleMenuVisibility(false, true);
                            itemClickAction(e)
                        }
                    };
                this._menuType = this.option("submenuType");
                if (this._menuType === "dxList" && this.option("renderAs") === "topToolbar")
                    this._menuType = "dxDropDownMenu";
                switch (this._menuType) {
                    case"dxActionSheet":
                        this._renderActionSheet(options);
                        break;
                    case"dxDropDownMenu":
                        this._renderDropDown(options);
                        break;
                    case"dxList":
                        this._renderList(options);
                        break
                }
            },
            _renderMenuButton: function(options) {
                var buttonOptions = $.extend({onClick: $.proxy(this._menuButtonClickHandler, this)}, options);
                this._renderMenuButtonContainer();
                this._$button = $("<div>").appendTo(this._$menuButtonContainer).addClass(TOOLBAR_MENU_BUTTON_CLASS);
                this._createComponent(this._$button, Button, buttonOptions)
            },
            _renderMenuButtonContainer: function() {
                var $afterSection = this._$afterSection;
                this._$menuButtonContainer = $("<div>").appendTo($afterSection).addClass(TOOLBAR_BUTTON_CLASS).addClass(TOOLBAR_MENU_CONTAINER_CLASS)
            },
            _renderDropDown: function(options) {
                if (!this._hasVisibleMenuItems())
                    return;
                this._renderMenuButtonContainer();
                var $menu = $("<div>").appendTo(this._$menuButtonContainer);
                this._menu = this._createComponent($menu, "dxDropDownMenu", options);
                this._renderMenuItems()
            },
            _renderActionSheet: function(options) {
                if (!this._hasVisibleMenuItems())
                    return;
                this._renderMenuButton({icon: "overflow"});
                var actionSheetOptions = $.extend({
                        target: this._$button,
                        showTitle: false
                    }, options);
                var $menu = $("<div>").appendTo(this.element());
                this._menu = this._createComponent($menu, "dxActionSheet", actionSheetOptions);
                this._renderMenuItems()
            },
            _renderList: function(options) {
                this._renderMenuButton({
                    activeStateEnabled: false,
                    text: "..."
                });
                var listOptions = $.extend({
                        width: "100%",
                        indicateLoading: false
                    }, options);
                this._renderListOverlay();
                this._renderContainerSwipe();
                if (this._hasVisibleMenuItems()) {
                    var $menu = $("<div>").appendTo(this._listOverlay.content());
                    this._menu = this._createComponent($menu, "dxList", listOptions);
                    this._renderMenuItems()
                }
                this._changeListVisible(this.option("visible"))
            },
            _renderMenuItems: function() {
                this._menu.option("items", this._getMenuItems())
            },
            _getListHeight: function() {
                var listHeight = this._listOverlay.content().find(".dx-list").height(),
                    semiHiddenHeight = this._$toolbarItemsContainer.height() - this.element().height();
                return listHeight + semiHiddenHeight
            },
            _renderListOverlay: function() {
                var $listOverlay = $("<div>").appendTo(this.element());
                this._listOverlay = this._createComponent($listOverlay, "dxOverlay", {
                    container: false,
                    deferRendering: false,
                    shading: false,
                    height: "auto",
                    width: "100%",
                    showTitle: false,
                    closeOnOutsideClick: $.proxy(this._listOutsideClickHandler, this),
                    position: null,
                    animation: null,
                    closeOnBackButton: false
                })
            },
            _hideTopOverlayHandler: function() {
                this._toggleMenuVisibility(false, true)
            },
            _toggleHideTopOverlayCallback: function() {
                if (this._closeCallback)
                    hideTopOverlayCallback.remove(this._closeCallback);
                if (this._menuShown) {
                    this._closeCallback = $.proxy(this._hideTopOverlayHandler, this);
                    hideTopOverlayCallback.add(this._closeCallback)
                }
            },
            _renderContainerSwipe: function() {
                this._createComponent(this._$toolbarItemsContainer.appendTo(this._listOverlay.content()), "dxSwipeable", {
                    elastic: false,
                    onStart: $.proxy(this._swipeStartHandler, this),
                    onUpdated: $.proxy(this._swipeUpdateHandler, this),
                    onEnd: $.proxy(this._swipeEndHandler, this),
                    itemSizeFunc: $.proxy(this._getListHeight, this),
                    direction: "vertical"
                })
            },
            _listOutsideClickHandler: function(e) {
                if (!$(e.target).closest(this._listOverlay.content()).length)
                    this._toggleMenuVisibility(false, true)
            },
            _calculatePixelOffset: function(offset) {
                offset = (offset || 0) - 1;
                var maxOffset = this._getListHeight();
                return offset * maxOffset
            },
            _swipeStartHandler: function(e) {
                e.jQueryEvent.maxTopOffset = this._menuShown ? 0 : 1;
                e.jQueryEvent.maxBottomOffset = this._menuShown ? 1 : 0
            },
            _swipeUpdateHandler: function(e) {
                var offset = this._menuShown ? e.jQueryEvent.offset : 1 + e.jQueryEvent.offset;
                this._renderMenuPosition(offset, false)
            },
            _swipeEndHandler: function(e) {
                var targetOffset = e.jQueryEvent.targetOffset;
                targetOffset -= this._menuShown - 1;
                this._toggleMenuVisibility(targetOffset === 0, true)
            },
            _renderMenuPosition: function(offset, animate) {
                var pos = this._calculatePixelOffset(offset),
                    element = this._listOverlay.content();
                if (animate)
                    slideSubmenu(element, pos, this._menuShown);
                else
                    translator.move(element, {top: pos})
            },
            _menuButtonClickHandler: function() {
                this._toggleMenuVisibility(!this._menuShown, true)
            },
            _toggleMenuVisibility: function(visible, animate) {
                this._menuShown = visible;
                switch (this._menuType) {
                    case"dxList":
                        this._toggleHideTopOverlayCallback();
                        this._renderMenuPosition(this._menuShown ? 0 : 1, animate);
                        break;
                    case"dxActionSheet":
                        this._menu.toggle(this._menuShown);
                        this._menuShown = false;
                        break
                }
            },
            _renderEmptyMessage: $.noop,
            _clean: function() {
                this._$toolbarItemsContainer.children().empty();
                this.element().empty()
            },
            _changeMenuOption: function(name, value) {
                if (this._menu)
                    this._menu.option(name, value)
            },
            _changeListVisible: function(value) {
                if (this._listOverlay) {
                    this._listOverlay.option("visible", value);
                    this._toggleMenuVisibility(false, false)
                }
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._arrangeTitle()
            },
            _isVisible: function() {
                return this.element().width() > 0 && this.element().height() > 0
            },
            _renderDimensions: function() {
                this.callBase();
                this._arrangeTitle()
            },
            _itemOptionChanged: function(index, property, value) {
                var itemData = this.option("items")[index];
                if (itemData.location === "menu")
                    this._renderMenuItems();
                else {
                    var itemIndex = $.inArray(itemData, this._getToolbarItems());
                    this.callBase.apply(this, [itemIndex, property, value])
                }
            },
            _optionChanged: function(args) {
                var name = args.name;
                var value = args.value;
                switch (name) {
                    case"renderAs":
                    case"submenuType":
                        this._invalidate();
                        break;
                    case"visible":
                        this.callBase.apply(this, arguments);
                        this._changeListVisible(value);
                        break;
                    case"menuItemTemplate":
                        this._changeMenuOption("itemTemplate", this._getTemplate(value));
                        break;
                    case"onItemClick":
                        this._changeMenuOption(name, value);
                        this.callBase.apply(this, arguments);
                        break;
                    default:
                        this.callBase.apply(this, arguments)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            support = DX.require("/utils/utils.support"),
            commonUtils = DX.require("/utils/utils.common"),
            inkRipple = DX.require("/utils/utils.inkRipple"),
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator"),
            Button = DX.require("/ui/widgets/ui.button"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var LIST_CLASS = "dx-list",
            LIST_ITEM_CLASS = "dx-list-item",
            LIST_ITEM_SELECTOR = "." + LIST_ITEM_CLASS,
            LIST_GROUP_CLASS = "dx-list-group",
            LIST_GROUP_HEADER_CLASS = "dx-list-group-header",
            LIST_GROUP_BODY_CLASS = "dx-list-group-body",
            LIST_COLLAPSIBLE_GROUPS_CLASS = "dx-list-collapsible-groups",
            LIST_GROUP_COLLAPSED_CLASS = "dx-list-group-collapsed",
            LIST_HAS_NEXT_CLASS = "dx-has-next",
            LIST_NEXT_BUTTON_CLASS = "dx-list-next-button",
            LIST_ITEM_DATA_KEY = "dxListItemData",
            LIST_FEEDBACK_SHOW_TIMEOUT = 70;
        var groupItemsGetter = DX.data.utils.compileGetter("items");
        registerComponent("dxList", ui, ui.CollectionWidget.inherit({
            _activeStateUnit: LIST_ITEM_SELECTOR,
            _supportedKeys: function() {
                var that = this;
                var moveFocusPerPage = function(direction) {
                        var $item = getEdgeVisibleItem(direction),
                            isFocusedItem = $item.is(that.option("focusedElement"));
                        if (isFocusedItem) {
                            scrollListTo($item, direction);
                            $item = getEdgeVisibleItem(direction)
                        }
                        that.option("focusedElement", $item);
                        that.scrollToItem($item)
                    };
                var getEdgeVisibleItem = function(direction) {
                        var scrollTop = that.scrollTop(),
                            containerHeight = that.element().height();
                        var $item = that.option("focusedElement"),
                            isItemVisible = true;
                        if (!$item)
                            return;
                        while (isItemVisible) {
                            var $nextItem = $item[direction]();
                            if (!$nextItem.length)
                                break;
                            var nextItemLocation = $nextItem.position().top + $nextItem.outerHeight() / 2;
                            isItemVisible = nextItemLocation < containerHeight + scrollTop && nextItemLocation > scrollTop;
                            if (isItemVisible)
                                $item = $nextItem
                        }
                        return $item
                    };
                var scrollListTo = function($item, direction) {
                        var resultPosition = $item.position().top;
                        if (direction === "prev")
                            resultPosition = $item.position().top - that.element().height() + $item.outerHeight();
                        that.scrollTo(resultPosition)
                    };
                return $.extend(this.callBase(), {
                        leftArrow: $.noop,
                        rightArrow: $.noop,
                        pageUp: function() {
                            moveFocusPerPage("prev");
                            return false
                        },
                        pageDown: function() {
                            moveFocusPerPage("next");
                            return false
                        }
                    })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    autoPagingEnabled: {
                        since: "15.1",
                        message: "Use the 'pageLoadMode' option instead"
                    },
                    showNextButton: {
                        since: "15.1",
                        message: "Use the 'pageLoadMode' option instead"
                    }
                })
            },
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        hoverStateEnabled: true,
                        pullRefreshEnabled: false,
                        scrollingEnabled: true,
                        showScrollbar: "onScroll",
                        useNativeScrolling: true,
                        bounceEnabled: true,
                        scrollByContent: true,
                        scrollByThumb: false,
                        pullingDownText: Globalize.localize("dxList-pullingDownText"),
                        pulledDownText: Globalize.localize("dxList-pulledDownText"),
                        refreshingText: Globalize.localize("dxList-refreshingText"),
                        pageLoadingText: Globalize.localize("dxList-pageLoadingText"),
                        onScroll: null,
                        onPullRefresh: null,
                        onPageLoading: null,
                        pageLoadMode: "scrollBottom",
                        nextButtonText: Globalize.localize("dxList-nextButtonText"),
                        onItemSwipe: null,
                        grouped: false,
                        onGroupRendered: null,
                        collapsibleGroups: false,
                        groupTemplate: "group",
                        indicateLoading: true,
                        activeStateEnabled: true,
                        _itemAttributes: {role: "option"},
                        useInkRipple: false
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat(ui.dxScrollable.deviceDependentOptions(), [{
                            device: function(device) {
                                return !support.nativeScrolling && !devices.isSimulator() && devices.real().platform === "generic" && device.platform === "generic"
                            },
                            options: {
                                showScrollbar: "onHover",
                                pageLoadMode: "nextButton"
                            }
                        }, {
                            device: function(device) {
                                return devices.real().generic && !devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }, {
                            device: {platform: "android"},
                            options: {useInkRipple: true}
                        }])
            },
            _getOptionAliases: function() {
                return $.extend(this.callBase(), {useNative: "useNativeScrolling"})
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._updateLoadingState(true)
            },
            _itemClass: function() {
                return LIST_ITEM_CLASS
            },
            _itemDataKey: function() {
                return LIST_ITEM_DATA_KEY
            },
            _itemContainer: function() {
                return this._$container
            },
            _allowDinamicItemsAppend: function() {
                return true
            },
            _init: function() {
                this.callBase();
                this._$container = this.element();
                this._initScrollView();
                this._feedbackShowTimeout = LIST_FEEDBACK_SHOW_TIMEOUT;
                this._createGroupRenderAction();
                this.setAria("role", "listbox")
            },
            _dataSourceOptions: function() {
                this._suppressDeprecatedWarnings();
                var pagingEnabled = this.option("autoPagingEnabled");
                pagingEnabled = commonUtils.isDefined(this.option("showNextButton")) ? pagingEnabled || this.option("showNextButton") : pagingEnabled;
                this._resumeDeprecatedWarnings();
                return $.extend(this.callBase(), {paginate: commonUtils.isDefined(pagingEnabled) ? pagingEnabled : true})
            },
            _initScrollView: function() {
                this._suppressDeprecatedWarnings();
                var scrollingEnabled = this.option("scrollingEnabled"),
                    pullRefreshEnabled = scrollingEnabled && this.option("pullRefreshEnabled"),
                    autoPagingEnabled = scrollingEnabled && commonUtils.ensureDefined(this.option("autoPagingEnabled"), this.option("pageLoadMode") === "scrollBottom") && !!this._dataSource;
                this._resumeDeprecatedWarnings();
                this._scrollView = this._createComponent(this.element(), "dxScrollView", {
                    disabled: this.option("disabled") || !scrollingEnabled,
                    onScroll: $.proxy(this._scrollHandler, this),
                    onPullDown: pullRefreshEnabled ? $.proxy(this._pullDownHandler, this) : null,
                    onReachBottom: autoPagingEnabled ? $.proxy(this._scrollBottomHandler, this) : null,
                    showScrollbar: this.option("showScrollbar"),
                    useNative: this.option("useNativeScrolling"),
                    bounceEnabled: this.option("bounceEnabled"),
                    scrollByContent: this.option("scrollByContent"),
                    scrollByThumb: this.option("scrollByThumb"),
                    pullingDownText: this.option("pullingDownText"),
                    pulledDownText: this.option("pulledDownText"),
                    refreshingText: this.option("refreshingText"),
                    reachBottomText: this.option("pageLoadingText"),
                    useKeyboard: false
                });
                this._$container = this._scrollView.content();
                this._createScrollViewActions()
            },
            _createScrollViewActions: function() {
                this._scrollAction = this._createActionByOption("onScroll");
                this._pullRefreshAction = this._createActionByOption("onPullRefresh");
                this._pageLoadingAction = this._createActionByOption("onPageLoading")
            },
            _scrollHandler: function(e) {
                this._scrollAction(e)
            },
            _updateLoadingState: function(tryLoadMore) {
                this._suppressDeprecatedWarnings();
                var isDataLoaded = !tryLoadMore || this._isLastPage(),
                    autoPagingEnabled = commonUtils.ensureDefined(this.option("autoPagingEnabled"), this.option("pageLoadMode") === "scrollBottom"),
                    stopLoading = isDataLoaded || !autoPagingEnabled,
                    hideLoadIndicator = stopLoading && !this._isDataSourceLoading();
                this._resumeDeprecatedWarnings();
                if (stopLoading || this._scrollViewIsFull()) {
                    this._scrollView.release(hideLoadIndicator);
                    this._toggleNextButton(this._shouldRenderNextButton() && !isDataLoaded);
                    this._loadIndicationSuppressed(false)
                }
                else
                    this._infiniteDataLoading()
            },
            _shouldRenderNextButton: function() {
                this._suppressDeprecatedWarnings();
                var result = commonUtils.ensureDefined(this.option("showNextButton"), this.option("pageLoadMode") === "nextButton") && this._dataSource && this._dataSource.isLoaded();
                this._resumeDeprecatedWarnings();
                return result
            },
            _dataSourceLoadingChangedHandler: function(isLoading) {
                if (this._loadIndicationSuppressed())
                    return;
                if (isLoading && this.option("indicateLoading"))
                    this._showLoadingIndicatorTimer = setTimeout($.proxy(function() {
                        var isEmpty = !this._itemElements().length;
                        if (this._scrollView && !isEmpty)
                            this._scrollView.startLoading()
                    }, this));
                else {
                    clearTimeout(this._showLoadingIndicatorTimer);
                    this._scrollView && this._scrollView.finishLoading()
                }
            },
            _dataSourceChangedHandler: function(newItems) {
                if (!this._shouldAppendItems())
                    this._scrollView && this._scrollView.scrollTo(0);
                this.callBase(newItems)
            },
            _hideLoadingIfLoadIndicationOff: function() {
                if (!this.option("indicateLoading"))
                    this._dataSourceLoadingChangedHandler(false)
            },
            _loadIndicationSuppressed: function(value) {
                if (!arguments.length)
                    return this._isLoadIndicationSuppressed;
                this._isLoadIndicationSuppressed = value
            },
            _scrollViewIsFull: function() {
                return !this._scrollView || this._scrollView.isFull()
            },
            _pullDownHandler: function(e) {
                this._pullRefreshAction(e);
                if (this._dataSource && !this._isDataSourceLoading()) {
                    this._dataSource.pageIndex(0);
                    this._dataSource.load()
                }
                else
                    this._updateLoadingState()
            },
            _infiniteDataLoading: function() {
                var isElementVisible = this.element().is(":visible");
                if (isElementVisible && !this._scrollViewIsFull() && !this._isDataSourceLoading() && !this._isLastPage()) {
                    clearTimeout(this._loadNextPageTimer);
                    this._loadNextPageTimer = setTimeout($.proxy(this._loadNextPage, this))
                }
            },
            _scrollBottomHandler: function(e) {
                this._pageLoadingAction(e);
                if (!this._isDataSourceLoading())
                    this._loadNextPage();
                else
                    this._updateLoadingState()
            },
            _renderItems: function(items) {
                if (this.option("grouped")) {
                    $.each(items, $.proxy(this._renderGroup, this));
                    this._attachGroupCollapseEvent();
                    this._renderEmptyMessage()
                }
                else
                    this.callBase.apply(this, arguments);
                this._updateLoadingState(true)
            },
            _attachGroupCollapseEvent: function() {
                var eventName = eventUtils.addNamespace("dxclick", this.NAME),
                    selector = "." + LIST_GROUP_HEADER_CLASS,
                    $element = this.element(),
                    collapsibleGroups = this.option("collapsibleGroups");
                $element.toggleClass(LIST_COLLAPSIBLE_GROUPS_CLASS, collapsibleGroups);
                $element.off(eventName, selector);
                if (collapsibleGroups)
                    $element.on(eventName, selector, $.proxy(function(e) {
                        this._createAction($.proxy(function(e) {
                            this._collapseGroupHandler($(e.jQueryEvent.currentTarget).parent())
                        }, this), {validatingTargetName: "element"})({jQueryEvent: e})
                    }, this))
            },
            _collapseGroupHandler: function($group, toggle) {
                var deferred = $.Deferred(),
                    $groupBody = $group.children("." + LIST_GROUP_BODY_CLASS);
                $group.toggleClass(LIST_GROUP_COLLAPSED_CLASS, toggle);
                var slideMethod = "slideToggle";
                if (toggle === true)
                    slideMethod = "slideUp";
                if (toggle === false)
                    slideMethod = "slideDown";
                $groupBody[slideMethod]({
                    duration: 200,
                    complete: $.proxy(function() {
                        this.updateDimensions();
                        deferred.resolve()
                    }, this)
                });
                return deferred.promise()
            },
            _dataSourceLoadErrorHandler: function() {
                this._forgetNextPageLoading();
                if (this._initialized) {
                    this._renderEmptyMessage();
                    this._updateLoadingState()
                }
            },
            _render: function() {
                this.element().addClass(LIST_CLASS);
                this.callBase();
                this.option("useInkRipple") && this._renderInkRipple()
            },
            _renderInkRipple: function() {
                this._inkRipple = inkRipple.render()
            },
            _toggleActiveState: function($element, value, e) {
                this.callBase.apply(this, arguments);
                if (!this._inkRipple)
                    return;
                var config = {
                        element: $element,
                        jQueryEvent: e
                    };
                if (value)
                    this._inkRipple.renderWave(config);
                else
                    this._inkRipple.removeWave(config)
            },
            _postprocessRenderItem: function(args) {
                this.callBase.apply(this, arguments);
                if (this.option("onItemSwipe"))
                    this._attachSwipeEvent($(args.itemElement))
            },
            _attachSwipeEvent: function($itemElement) {
                var endEventName = eventUtils.addNamespace("dxswipeend", this.NAME);
                $itemElement.on(endEventName, $.proxy(this._itemSwipeEndHandler, this))
            },
            _itemSwipeEndHandler: function(e) {
                this._itemJQueryEventHandler(e, "onItemSwipe", {direction: e.offset < 0 ? "left" : "right"})
            },
            _nextButtonHandler: function() {
                var source = this._dataSource;
                if (source && !source.isLoading()) {
                    this._scrollView.toggleLoading(true);
                    this._$nextButton.detach();
                    this._loadIndicationSuppressed(true);
                    this._loadNextPage()
                }
            },
            _renderGroup: function(index, group) {
                var $groupElement = $("<div>").addClass(LIST_GROUP_CLASS).appendTo(this._itemContainer());
                var $groupHeaderElement = $("<div>").addClass(LIST_GROUP_HEADER_CLASS).appendTo($groupElement);
                var groupTemplateName = this.option("groupTemplate"),
                    groupTemplate = this._getTemplate(group.template || groupTemplateName, group, index, $groupHeaderElement),
                    renderArgs = {
                        index: index,
                        item: group,
                        container: $groupHeaderElement
                    };
                this._createItemByTemplate(groupTemplate, renderArgs);
                this._renderingGroupIndex = index;
                var $groupBody = $("<div>").addClass(LIST_GROUP_BODY_CLASS).appendTo($groupElement);
                $.each(groupItemsGetter(group) || [], $.proxy(function(index, item) {
                    this._renderItem(index, item, $groupBody)
                }, this));
                this._groupRenderAction({
                    groupElement: $groupElement,
                    groupIndex: index,
                    groupData: group
                })
            },
            _createGroupRenderAction: function() {
                this._groupRenderAction = this._createActionByOption("onGroupRendered")
            },
            _clean: function() {
                if (this._$nextButton) {
                    this._$nextButton.remove();
                    this._$nextButton = null
                }
                this.callBase.apply(this, arguments)
            },
            _dispose: function() {
                clearTimeout(this._holdTimer);
                clearTimeout(this._loadNextPageTimer);
                clearTimeout(this._showLoadingIndicatorTimer);
                this.callBase()
            },
            _toggleDisabledState: function(value) {
                this.callBase(value);
                this._scrollView.option("disabled", value || !this.option("scrollingEnabled"))
            },
            _toggleNextButton: function(value) {
                var dataSource = this._dataSource,
                    $nextButton = this._getNextButton();
                this.element().toggleClass(LIST_HAS_NEXT_CLASS, value);
                if (value && dataSource && dataSource.isLoaded())
                    $nextButton.appendTo(this._itemContainer());
                if (!value)
                    $nextButton.detach()
            },
            _getNextButton: function() {
                if (!this._$nextButton)
                    this._$nextButton = this._createNextButton();
                return this._$nextButton
            },
            _createNextButton: function() {
                var $result = $("<div>").addClass(LIST_NEXT_BUTTON_CLASS);
                var $button = $("<div>").appendTo($result);
                this._createComponent($button, Button, {
                    text: this.option("nextButtonText"),
                    onClick: $.proxy(this._nextButtonHandler, this),
                    _templates: {}
                });
                return $result
            },
            _moveFocus: function(location) {
                this.callBase.apply(this, arguments);
                this.scrollToItem(this.option("focusedElement"))
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"pageLoadMode":
                        this._toggleNextButton(args.value);
                        this._initScrollView();
                        break;
                    case"showNextButton":
                        this._toggleNextButton(args.value);
                        break;
                    case"dataSource":
                        this.callBase(args);
                        this._initScrollView();
                        break;
                    case"pullingDownText":
                    case"pulledDownText":
                    case"refreshingText":
                    case"pageLoadingText":
                    case"useNative":
                    case"showScrollbar":
                    case"bounceEnabled":
                    case"scrollByContent":
                    case"scrollByThumb":
                    case"scrollingEnabled":
                    case"pullRefreshEnabled":
                    case"autoPagingEnabled":
                        this._initScrollView();
                        break;
                    case"nextButtonText":
                    case"onItemSwipe":
                    case"useInkRipple":
                        this._invalidate();
                        break;
                    case"onScroll":
                    case"onPullRefresh":
                    case"onPageLoading":
                        this._createScrollViewActions();
                        this._invalidate();
                        break;
                    case"grouped":
                    case"collapsibleGroups":
                    case"groupTemplate":
                        this._invalidate();
                        break;
                    case"onGroupRendered":
                        this._createGroupRenderAction();
                        break;
                    case"items":
                        this._invalidate();
                        break;
                    case"width":
                    case"height":
                        this.callBase(args);
                        this._scrollView.update();
                        break;
                    case"indicateLoading":
                        this._hideLoadingIfLoadIndicationOff();
                        break;
                    case"visible":
                        this.callBase(args);
                        this._scrollView.update();
                        break;
                    case"rtlEnabled":
                        this._initScrollView();
                        this.callBase(args);
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _extendActionArgs: function($itemElement) {
                if (!this.option("grouped"))
                    return this.callBase($itemElement);
                var $group = $itemElement.closest("." + LIST_GROUP_CLASS);
                var $item = $group.find("." + LIST_ITEM_CLASS);
                return $.extend(this.callBase($itemElement), {itemIndex: {
                            group: $group.index(),
                            item: $item.index($itemElement)
                        }})
            },
            expandGroup: function(groupIndex) {
                var deferred = $.Deferred(),
                    $group = this._itemContainer().find("." + LIST_GROUP_CLASS).eq(groupIndex);
                this._collapseGroupHandler($group, false).done($.proxy(function() {
                    deferred.resolveWith(this)
                }, this));
                return deferred.promise()
            },
            collapseGroup: function(groupIndex) {
                var deferred = $.Deferred(),
                    $group = this._itemContainer().find("." + LIST_GROUP_CLASS).eq(groupIndex);
                this._collapseGroupHandler($group, true).done($.proxy(function() {
                    deferred.resolveWith(this)
                }, this));
                return deferred
            },
            updateDimensions: function() {
                var that = this,
                    deferred = $.Deferred();
                if (that._scrollView)
                    that._scrollView.update().done(function() {
                        deferred.resolveWith(that)
                    });
                else
                    deferred.resolveWith(that);
                return deferred.promise()
            },
            reload: function() {
                this.scrollTo(0);
                this._pullDownHandler()
            },
            scrollTop: function() {
                return this._scrollView.scrollOffset().top
            },
            clientHeight: function() {
                return this._scrollView.clientHeight()
            },
            scrollHeight: function() {
                return this._scrollView.scrollHeight()
            },
            scrollBy: function(distance) {
                this._scrollView.scrollBy(distance)
            },
            scrollTo: function(location) {
                this._scrollView.scrollTo(location)
            },
            scrollToItem: function(itemElement) {
                var $item = this._editStrategy.getItemElement(itemElement);
                this._scrollView.scrollToElement($item)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            registerComponent = DX.require("/componentRegistrator"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var LIST_ITEM_SELECTED_CLASS = "dx-list-item-selected",
            LIST_ITEM_RESPONSE_WAIT_CLASS = "dx-list-item-response-wait";
        registerComponent("dxList", ui, ui.dxList.inherit({
            _supportedKeys: function() {
                var that = this,
                    parent = this.callBase();
                var deleteFocusedItem = function(e) {
                        if (that.option("allowItemDeleting")) {
                            e.preventDefault();
                            that.deleteItem(that.option("focusedElement"))
                        }
                    };
                var moveFocusedItemUp = function(e) {
                        if (e.shiftKey && that.option("allowItemReordering")) {
                            e.preventDefault();
                            var focusedItemIndex = that._editStrategy.getNormalizedIndex(that.option("focusedElement")),
                                $prevItem = that._editStrategy.getItemElement(focusedItemIndex - 1);
                            that.reorderItem(that.option("focusedElement"), $prevItem);
                            that.scrollToItem(that.option("focusedElement"))
                        }
                        else
                            parent.upArrow(e)
                    };
                var moveFocusedItemDown = function(e) {
                        if (e.shiftKey && that.option("allowItemReordering")) {
                            e.preventDefault();
                            var focusedItemIndex = that._editStrategy.getNormalizedIndex(that.option("focusedElement")),
                                $nextItem = that._editStrategy.getItemElement(focusedItemIndex + 1);
                            that.reorderItem(that.option("focusedElement"), $nextItem);
                            that.scrollToItem(that.option("focusedElement"))
                        }
                        else
                            parent.downArrow(e)
                    };
                return $.extend({}, parent, {
                        del: deleteFocusedItem,
                        upArrow: moveFocusedItemUp,
                        downArrow: moveFocusedItemDown
                    })
            },
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        showSelectionControls: false,
                        selectionMode: 'none',
                        onSelectAllChanged: null,
                        selectAllText: Globalize.localize("dxList-selectAll"),
                        menuItems: [],
                        menuMode: "context",
                        allowItemDeleting: false,
                        itemDeleteMode: "toggle",
                        allowItemReordering: false
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return device.platform === "ios"
                            },
                            options: {
                                menuMode: "slide",
                                itemDeleteMode: "slideItem"
                            }
                        }, {
                            device: {platform: "android"},
                            options: {itemDeleteMode: "swipe"}
                        }, {
                            device: {platform: "win"},
                            options: {itemDeleteMode: "context"}
                        }, {
                            device: {platform: "generic"},
                            options: {itemDeleteMode: "static"}
                        }])
            },
            _init: function() {
                this.callBase();
                this._initEditProvider()
            },
            _initEditProvider: function() {
                this._editProvider = new ui.dxList.EditProvider(this)
            },
            _disposeEditProvider: function() {
                if (this._editProvider)
                    this._editProvider.dispose()
            },
            _refreshEditProvider: function() {
                this._disposeEditProvider();
                this._initEditProvider()
            },
            _initEditStrategy: function(grouped) {
                if (this.option("grouped"))
                    this._editStrategy = new ui.dxList.GroupedEditStrategy(this);
                else
                    this.callBase()
            },
            _render: function() {
                this._refreshEditProvider();
                this.callBase()
            },
            _renderItems: function() {
                this.callBase.apply(this, arguments);
                this._editProvider.afterItemsRendered()
            },
            _selectedItemClass: function() {
                return LIST_ITEM_SELECTED_CLASS
            },
            _itemResponseWaitClass: function() {
                return LIST_ITEM_RESPONSE_WAIT_CLASS
            },
            _itemClickHandler: function(e) {
                var $itemElement = $(e.currentTarget);
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *"))
                    return;
                var handledByEditProvider = this._editProvider.handleClick($itemElement, e);
                if (handledByEditProvider)
                    return;
                this.callBase.apply(this, arguments)
            },
            _shouldAttachContextMenuEvent: function() {
                return this.callBase.apply(this, arguments) || this._editProvider.contextMenuHandlerExists()
            },
            _itemHoldHandler: function(e) {
                var $itemElement = $(e.currentTarget);
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *"))
                    return;
                var isTouchEvent = eventUtils.isTouchEvent(e),
                    handledByEditProvider = isTouchEvent && this._editProvider.handleContextMenu($itemElement, e);
                if (handledByEditProvider) {
                    e.handledByEditProvider = true;
                    return
                }
                this.callBase.apply(this, arguments)
            },
            _itemContextMenuHandler: function(e) {
                var $itemElement = $(e.currentTarget);
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *"))
                    return;
                var handledByEditProvider = !e.handledByEditProvider && this._editProvider.handleContextMenu($itemElement, e);
                if (handledByEditProvider)
                    return;
                this.callBase.apply(this, arguments)
            },
            _postprocessRenderItem: function(args) {
                this.callBase.apply(this, arguments);
                this._editProvider.modifyItemElement(args)
            },
            _clean: function() {
                this._disposeEditProvider();
                this.callBase()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"grouped":
                        this._clearSelectedItems();
                        delete this._renderingGroupIndex;
                        this._initEditStrategy(args.value);
                        this.callBase(args);
                        break;
                    case"showSelectionControls":
                    case"menuItems":
                    case"menuMode":
                    case"allowItemDeleting":
                    case"itemDeleteMode":
                    case"allowItemReordering":
                    case"selectAllText":
                        this._invalidate();
                        break;
                    case"onSelectAllChanged":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            getFlatIndexByItemElement: function(itemElement) {
                return this._itemElements().index(itemElement)
            },
            getItemElementByFlatIndex: function(flatIndex) {
                var $itemElements = this._itemElements();
                if (flatIndex < 0 || flatIndex >= $itemElements.length)
                    return $();
                return $itemElements.eq(flatIndex)
            },
            getItemByIndex: function(index) {
                return this._getItemData(this._itemElements().eq(index))
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.strategy.grouped.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            errors = DevExpress.require("/ui/ui.errors");
        var LIST_ITEM_CLASS = "dx-list-item",
            LIST_GROUP_CLASS = "dx-list-group";
        var SELECTION_SHIFT = 20,
            SELECTION_MASK = 0x8FF;
        var combineIndex = function(indices) {
                return (indices.group << SELECTION_SHIFT) + indices.item
            };
        var splitIndex = function(combinedIndex) {
                return {
                        group: combinedIndex >> SELECTION_SHIFT,
                        item: combinedIndex & SELECTION_MASK
                    }
            };
        var createGroupSelection = function(group, selectedItems) {
                var groupItems = group.items,
                    groupSelection = {
                        key: group.key,
                        items: []
                    };
                $.each(selectedItems, function(_, itemIndex) {
                    groupSelection.items.push(groupItems[itemIndex])
                });
                return groupSelection
            };
        var groupByKey = function(groups, key) {
                var length = groups.length;
                for (var i = 0; i < length; i++)
                    if (groups[i].key === key)
                        return groups[i]
            };
        ui.dxList.GroupedEditStrategy = ui.CollectionWidget.EditStrategy.inherit({
            _groupElements: function() {
                return this._collectionWidget._itemContainer().find("." + LIST_GROUP_CLASS)
            },
            _groupItemElements: function($group) {
                return $group.find("." + LIST_ITEM_CLASS)
            },
            getIndexByItemData: function(itemData) {
                var groups = this._collectionWidget.option("items"),
                    index = false;
                $.each(groups, function(groupIndex, group) {
                    $.each(group.items, function(itemIndex, item) {
                        if (item !== itemData)
                            return true;
                        index = {
                            group: groupIndex,
                            item: itemIndex
                        };
                        return false
                    });
                    if (index)
                        return false
                });
                return index
            },
            getItemDataByIndex: function(index) {
                if (!index || !index.group || !index.item)
                    return null;
                var items = this._collectionWidget.option("items");
                return items.length && items[index.group].items[index.item] || null
            },
            deleteItemAtIndex: function(index) {
                var indices = splitIndex(index),
                    itemGroup = this._collectionWidget.option("items")[indices.group].items;
                itemGroup.splice(indices.item, 1)
            },
            updateSelectionAfterDelete: function(fromIndex) {
                var deletedIndices = splitIndex(fromIndex),
                    selectedItemIndices = this._collectionWidget._selectedItemIndices;
                $.each(selectedItemIndices, function(i, index) {
                    var indices = splitIndex(index);
                    if (indices.group === deletedIndices.group && indices.item > deletedIndices.item)
                        selectedItemIndices[i] -= 1
                })
            },
            fetchSelectedItems: function(indices) {
                indices = indices || this._collectionWidget._selectedItemIndices;
                indices.sort(function(a, b) {
                    return a - b
                });
                var items = this._collectionWidget.option("items"),
                    selectedItems = [];
                var currentGroupIndex = 0,
                    groupSelectedIndices = [];
                $.each(indices, function(_, combinedIndex) {
                    var index = splitIndex(combinedIndex);
                    if (index.group !== currentGroupIndex && groupSelectedIndices.length) {
                        selectedItems.push(createGroupSelection(items[currentGroupIndex], groupSelectedIndices));
                        groupSelectedIndices.length = 0
                    }
                    currentGroupIndex = index.group;
                    groupSelectedIndices.push(index.item)
                });
                if (groupSelectedIndices.length)
                    selectedItems.push(createGroupSelection(items[currentGroupIndex], groupSelectedIndices));
                return selectedItems
            },
            selectedItemIndices: function() {
                var selectedIndices = [],
                    items = this._collectionWidget.option("items"),
                    selected = this._collectionWidget.option("selectedItems");
                $.each(selected, function(_, selectionInGroup) {
                    var group = groupByKey(items, selectionInGroup.key),
                        groupIndex = $.inArray(group, items);
                    if (!group) {
                        errors.log("W1003", selectionInGroup.key);
                        return
                    }
                    $.each(selectionInGroup.items, function(_, selectedGroupItem) {
                        var itemIndex = $.inArray(selectedGroupItem, group.items);
                        if (itemIndex !== -1)
                            selectedIndices.push(combineIndex({
                                group: groupIndex,
                                item: itemIndex
                            }));
                        else
                            errors.log("W1004", selectedGroupItem, selectionInGroup.key)
                    })
                });
                return selectedIndices
            },
            moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
                var items = this._collectionWidget.option("items"),
                    movingIndices = splitIndex(movingIndex),
                    destinationIndices = splitIndex(destinationIndex),
                    movingItemGroup = items[movingIndices.group].items,
                    destinationItemGroup = items[destinationIndices.group].items,
                    movedItemData = movingItemGroup[movingIndices.item];
                movingItemGroup.splice(movingIndices.item, 1);
                destinationItemGroup.splice(destinationIndices.item, 0, movedItemData)
            },
            getSelectedItemsAfterReorderItem: function(movingIndex, destinationIndex) {
                if (this._itemsFromSameParent(movingIndex, destinationIndex) || $.inArray(movingIndex, this._collectionWidget._selectedItemIndices))
                    return this.callBase();
                var items = this._collectionWidget.option("items"),
                    selectedItems = this._collectionWidget.option("selectedItems"),
                    movingIndices = splitIndex(movingIndex),
                    destinationIndices = splitIndex(destinationIndex),
                    movingSelectedItemGroup = selectedItems[movingIndices.group].items,
                    destinationSelectedItemGroup = selectedItems[destinationIndices.group].items,
                    movedItemData = items[movingIndices.group].items[movingIndices.item],
                    movedItemSelectedIndex = $.inArray(movedItemData, movingSelectedItemGroup);
                movingSelectedItemGroup.splice(movedItemSelectedIndex, 1);
                destinationSelectedItemGroup.push(movedItemData);
                return selectedItems
            },
            _isItemIndex: function(index) {
                return $.isNumeric(index.group) && $.isNumeric(index.item)
            },
            _getNormalizedItemIndex: function(itemElement) {
                var $item = $(itemElement),
                    $group = $item.closest("." + LIST_GROUP_CLASS);
                return combineIndex({
                        group: this._groupElements().index($group),
                        item: this._groupItemElements($group).index($item)
                    })
            },
            _normalizeItemIndex: function(index) {
                return combineIndex(index)
            },
            _denormalizeItemIndex: function(index) {
                return splitIndex(index)
            },
            _getItemByNormalizedIndex: function(index) {
                var indices = splitIndex(index),
                    $group = this._groupElements().eq(indices.group);
                return this._groupItemElements($group).eq(indices.item)
            },
            _itemsFromSameParent: function(firstIndex, secondIndex) {
                return splitIndex(firstIndex).group === splitIndex(secondIndex).group
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            Class = DevExpress.require("/class"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        ui.dxList.EditDecoratorsRegistry = {};
        ui.dxList.registerEditDecorator = function(option, type, decoratorClass) {
            var decoratorsRegistry = ui.dxList.EditDecoratorsRegistry;
            var decoratorConfig = {};
            decoratorConfig[option] = decoratorsRegistry[option] ? decoratorsRegistry[option] : {};
            decoratorConfig[option][type] = decoratorClass;
            decoratorsRegistry = $.extend(decoratorsRegistry, decoratorConfig)
        };
        var LIST_EDIT_DECORATOR = "dxListEditDecorator",
            SWIPE_START_EVENT_NAME = eventUtils.addNamespace("dxswipestart", LIST_EDIT_DECORATOR),
            SWIPE_UPDATE_EVENT_NAME = eventUtils.addNamespace("dxswipe", LIST_EDIT_DECORATOR),
            SWIPE_END_EVENT_NAME = eventUtils.addNamespace("dxswipeend", LIST_EDIT_DECORATOR);
        ui.dxList.EditDecorator = Class.inherit({
            ctor: function(list) {
                this._list = list;
                this._init()
            },
            _init: $.noop,
            _shouldHandleSwipe: false,
            _attachSwipeEvent: function(config) {
                var swipeConfig = {itemSizeFunc: $.proxy(function() {
                            if (this._clearSwipeCache) {
                                this._itemWidthCache = this._list.element().width();
                                this._clearSwipeCache = false
                            }
                            return this._itemWidthCache
                        }, this)};
                config.$itemElement.on(SWIPE_START_EVENT_NAME, swipeConfig, $.proxy(this._itemSwipeStartHandler, this)).on(SWIPE_UPDATE_EVENT_NAME, $.proxy(this._itemSwipeUpdateHandler, this)).on(SWIPE_END_EVENT_NAME, $.proxy(this._itemSwipeEndHandler, this))
            },
            _itemSwipeStartHandler: function(e) {
                var $itemElement = $(e.currentTarget);
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
                    e.cancel = true;
                    return
                }
                this._swipeStartHandler($itemElement, e)
            },
            _itemSwipeUpdateHandler: function(e) {
                var $itemElement = $(e.currentTarget);
                this._swipeUpdateHandler($itemElement, e)
            },
            _itemSwipeEndHandler: function(e) {
                var $itemElement = $(e.currentTarget);
                this._swipeEndHandler($itemElement, e);
                this._clearSwipeCache = true
            },
            beforeBag: $.noop,
            afterBag: $.noop,
            _commonOptions: function() {
                return {
                        activeStateEnabled: this._list.option("activeStateEnabled"),
                        hoverStateEnabled: this._list.option("hoverStateEnabled"),
                        focusStateEnabled: this._list.option("focusStateEnabled")
                    }
            },
            modifyElement: function(config) {
                if (this._shouldHandleSwipe) {
                    this._attachSwipeEvent(config);
                    this._clearSwipeCache = true
                }
            },
            afterRender: $.noop,
            handleClick: $.noop,
            handleContextMenu: $.noop,
            _swipeStartHandler: $.noop,
            _swipeUpdateHandler: $.noop,
            _swipeEndHandler: $.noop,
            visibilityChange: $.noop,
            dispose: $.noop
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decoratorMenuHelper.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        ui.dxList.EditDecoratorMenuHelperMixin = {
            _menuEnabled: function() {
                return !!this._menuItems().length
            },
            _menuItems: function() {
                return this._list.option("menuItems")
            },
            _deleteEnabled: function() {
                return this._list.option("allowItemDeleting")
            },
            _fireMenuAction: function($itemElement, action) {
                this._list._itemEventHandlerByHandler($itemElement, action, {}, {excludeValidators: ["disabled", "readOnly"]})
            }
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.static.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            Button = DX.require("/ui/widgets/ui.button");
        var STATIC_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-static-delete-button-container",
            STATIC_DELETE_BUTTON_CLASS = "dx-list-static-delete-button";
        ui.dxList.registerEditDecorator("delete", "static", ui.dxList.EditDecorator.inherit({
            afterBag: function(config) {
                var $itemElement = config.$itemElement,
                    $container = config.$container;
                var $button = $("<div>").addClass(STATIC_DELETE_BUTTON_CLASS);
                this._list._createComponent($button, Button, {
                    icon: "remove",
                    type: "danger",
                    onClick: $.proxy(function(args) {
                        args.jQueryEvent.stopPropagation();
                        this._deleteItem($itemElement)
                    }, this),
                    _templates: {}
                });
                $container.addClass(STATIC_DELETE_BUTTON_CONTAINER_CLASS).append($button)
            },
            _deleteItem: function($itemElement) {
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *"))
                    return;
                this._list.deleteItem($itemElement)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.switchable.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            EditDecorator = ui.dxList.EditDecorator,
            abstract = EditDecorator.abstract,
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer"),
            feedbackEvents = DX.require("/ui/events/ui.events.emitter.feedback");
        var LIST_EDIT_DECORATOR = "dxListEditDecorator",
            POINTER_DOWN_EVENT_NAME = eventUtils.addNamespace(pointerEvents.down, LIST_EDIT_DECORATOR),
            ACTIVE_EVENT_NAME = eventUtils.addNamespace(feedbackEvents.active, LIST_EDIT_DECORATOR),
            LIST_ITEM_CONTENT_CLASS = "dx-list-item-content",
            SWITCHABLE_DELETE_READY_CLASS = "dx-list-switchable-delete-ready",
            SWITCHABLE_MENU_SHIELD_POSITIONING_CLASS = "dx-list-switchable-menu-shield-positioning",
            SWITCHABLE_DELETE_TOP_SHIELD_CLASS = "dx-list-switchable-delete-top-shield",
            SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS = "dx-list-switchable-delete-bottom-shield",
            SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS = "dx-list-switchable-menu-item-shield-positioning",
            SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS = "dx-list-switchable-delete-item-content-shield";
        ui.dxList.SwitchableEditDecorator = EditDecorator.inherit({
            _init: function() {
                this._$topShield = $("<div />").addClass(SWITCHABLE_DELETE_TOP_SHIELD_CLASS);
                this._$bottomShield = $("<div />").addClass(SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS);
                this._$itemContentShield = $("<div />").addClass(SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS);
                this._$topShield.on(POINTER_DOWN_EVENT_NAME, $.proxy(this._cancelDeleteReadyItem, this));
                this._$bottomShield.on(POINTER_DOWN_EVENT_NAME, $.proxy(this._cancelDeleteReadyItem, this));
                this._list.element().append(this._$topShield.toggle(false)).append(this._$bottomShield.toggle(false))
            },
            handleClick: function($itemElement) {
                return this._cancelDeleteReadyItem()
            },
            _cancelDeleteReadyItem: function() {
                if (!this._$readyToDeleteItem)
                    return false;
                this._cancelDelete(this._$readyToDeleteItem);
                return true
            },
            _cancelDelete: function($itemElement) {
                this._toggleDeleteReady($itemElement, false)
            },
            _toggleDeleteReady: function($itemElement, readyToDelete) {
                if (readyToDelete === undefined)
                    readyToDelete = !this._isReadyToDelete($itemElement);
                this._toggleShields($itemElement, readyToDelete);
                this._toggleScrolling(readyToDelete);
                this._cacheReadyToDeleteItem($itemElement, readyToDelete);
                this._animateToggleDelete($itemElement, readyToDelete)
            },
            _isReadyToDelete: function($itemElement) {
                return $itemElement.hasClass(SWITCHABLE_DELETE_READY_CLASS)
            },
            _toggleShields: function($itemElement, enabled) {
                this._list.element().toggleClass(SWITCHABLE_MENU_SHIELD_POSITIONING_CLASS, enabled);
                this._$topShield.toggle(enabled);
                this._$bottomShield.toggle(enabled);
                if (enabled)
                    this._updateShieldsHeight($itemElement);
                this._toggleContentShield($itemElement, enabled)
            },
            _updateShieldsHeight: function($itemElement) {
                var $list = this._list.element(),
                    listTopOffset = $list.offset().top,
                    listHeight = $list.outerHeight(),
                    itemTopOffset = $itemElement.offset().top,
                    itemHeight = $itemElement.outerHeight(),
                    dirtyTopShieldHeight = itemTopOffset - listTopOffset,
                    dirtyBottomShieldHeight = listHeight - itemHeight - dirtyTopShieldHeight;
                this._$topShield.height(Math.max(dirtyTopShieldHeight, 0));
                this._$bottomShield.height(Math.max(dirtyBottomShieldHeight, 0))
            },
            _toggleContentShield: function($itemElement, enabled) {
                if (enabled)
                    $itemElement.find("." + LIST_ITEM_CONTENT_CLASS).append(this._$itemContentShield);
                else
                    this._$itemContentShield.detach()
            },
            _toggleScrolling: function(readyToDelete) {
                var scrollView = this._list.element().dxScrollView("instance");
                if (readyToDelete)
                    scrollView.on("start", this._cancelScrolling);
                else
                    scrollView.off("start", this._cancelScrolling)
            },
            _cancelScrolling: function(args) {
                args.jQueryEvent.cancel = true
            },
            _cacheReadyToDeleteItem: function($itemElement, cache) {
                if (cache)
                    this._$readyToDeleteItem = $itemElement;
                else
                    delete this._$readyToDeleteItem
            },
            _animateToggleDelete: function($itemElement, readyToDelete) {
                if (readyToDelete) {
                    this._enablePositioning($itemElement);
                    this._prepareDeleteReady($itemElement);
                    this._animatePrepareDeleteReady($itemElement)
                }
                else {
                    this._forgetDeleteReady($itemElement);
                    this._animateForgetDeleteReady($itemElement).done($.proxy(this._disablePositioning, this, $itemElement))
                }
            },
            _enablePositioning: function($itemElement) {
                $itemElement.addClass(SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS);
                $itemElement.on(ACTIVE_EVENT_NAME, $.noop)
            },
            _disablePositioning: function($itemElement) {
                $itemElement.removeClass(SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS);
                $itemElement.off(ACTIVE_EVENT_NAME)
            },
            _prepareDeleteReady: function($itemElement) {
                $itemElement.addClass(SWITCHABLE_DELETE_READY_CLASS)
            },
            _forgetDeleteReady: function($itemElement) {
                $itemElement.removeClass(SWITCHABLE_DELETE_READY_CLASS)
            },
            _animatePrepareDeleteReady: abstract,
            _animateForgetDeleteReady: abstract,
            _deleteItem: function($itemElement) {
                $itemElement = $itemElement || this._$readyToDeleteItem;
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *"))
                    return;
                this._list.deleteItem($itemElement).always($.proxy(this._cancelDelete, this, $itemElement))
            },
            _isRtlEnabled: function() {
                return this._list.option("rtlEnabled")
            },
            dispose: function() {
                if (this._$topShield)
                    this._$topShield.remove();
                if (this._$bottomShield)
                    this._$bottomShield.remove();
                this.callBase.apply(this, arguments)
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.switchable.button.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx,
            Button = DX.require("/ui/widgets/ui.button");
        var SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-switchable-delete-button-container",
            SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS = "dx-list-switchable-delete-button-wrapper",
            SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS = "dx-list-switchable-delete-button-inner-wrapper",
            SWITCHABLE_DELETE_BUTTON_CLASS = "dx-list-switchable-delete-button",
            SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION = 200;
        ui.dxList.SwitchableButtonEditDecorator = ui.dxList.SwitchableEditDecorator.inherit({
            _init: function() {
                this.callBase.apply(this, arguments);
                var $buttonContainer = $("<div >").addClass(SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS),
                    $buttonWrapper = $("<div />").addClass(SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS),
                    $buttonInnerWrapper = $("<div />").addClass(SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS),
                    $button = $("<div />").addClass(SWITCHABLE_DELETE_BUTTON_CLASS);
                this._list._createComponent($button, Button, {
                    text: Globalize.localize("dxListEditDecorator-delete"),
                    type: "danger",
                    onClick: $.proxy(function(e) {
                        this._deleteItem();
                        e.jQueryEvent.stopPropagation()
                    }, this),
                    _templates: {}
                });
                $buttonContainer.append($buttonWrapper);
                $buttonWrapper.append($buttonInnerWrapper);
                $buttonInnerWrapper.append($button);
                this._$buttonContainer = $buttonContainer
            },
            _enablePositioning: function($itemElement) {
                this.callBase.apply(this, arguments);
                fx.stop(this._$buttonContainer, true);
                this._$buttonContainer.appendTo($itemElement)
            },
            _disablePositioning: function() {
                this.callBase.apply(this, arguments);
                this._$buttonContainer.detach()
            },
            _animatePrepareDeleteReady: function() {
                var rtl = this._isRtlEnabled(),
                    listWidth = this._list.element().width(),
                    buttonWidth = this._buttonWidth(),
                    fromValue = rtl ? listWidth : -buttonWidth,
                    toValue = rtl ? listWidth - buttonWidth : 0;
                return fx.animate(this._$buttonContainer, {
                        type: "custom",
                        duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
                        from: {right: fromValue},
                        to: {right: toValue}
                    })
            },
            _animateForgetDeleteReady: function() {
                var rtl = this._isRtlEnabled(),
                    listWidth = this._list.element().width(),
                    buttonWidth = this._buttonWidth(),
                    fromValue = rtl ? listWidth - buttonWidth : 0,
                    toValue = rtl ? listWidth : -buttonWidth;
                return fx.animate(this._$buttonContainer, {
                        type: "custom",
                        duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
                        from: {right: fromValue},
                        to: {right: toValue}
                    })
            },
            _buttonWidth: function() {
                if (!this._buttonContainerWidth)
                    this._buttonContainerWidth = this._$buttonContainer.outerWidth();
                return this._buttonContainerWidth
            },
            dispose: function() {
                if (this._$buttonContainer)
                    this._$buttonContainer.remove();
                this.callBase.apply(this, arguments)
            }
        });
        var TOGGLE_DELETE_SWITCH_CONTAINER_CLASS = "dx-list-toggle-delete-switch-container",
            TOGGLE_DELETE_SWITCH_CLASS = "dx-list-toggle-delete-switch";
        ui.dxList.registerEditDecorator("delete", "toggle", ui.dxList.SwitchableButtonEditDecorator.inherit({beforeBag: function(config) {
                var $itemElement = config.$itemElement,
                    $container = config.$container;
                var $toggle = $("<div />").addClass(TOGGLE_DELETE_SWITCH_CLASS);
                this._list._createComponent($toggle, Button, {
                    icon: "toggle-delete",
                    onClick: $.proxy(function(e) {
                        this._toggleDeleteReady($itemElement);
                        e.jQueryEvent.stopPropagation()
                    }, this),
                    _templates: {}
                });
                $container.addClass(TOGGLE_DELETE_SWITCH_CONTAINER_CLASS);
                $container.append($toggle)
            }}));
        ui.dxList.registerEditDecorator("delete", "slideButton", ui.dxList.SwitchableButtonEditDecorator.inherit({
            _shouldHandleSwipe: true,
            _swipeEndHandler: function($itemElement, args) {
                if (args.targetOffset !== 0)
                    this._toggleDeleteReady($itemElement);
                return true
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.switchable.slide.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.require("/utils/utils.translator"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            feedbackEvents = DX.require("/ui/events/ui.events.emitter.feedback"),
            fx = DX.fx;
        var LIST_EDIT_DECORATOR = "dxListEditDecorator",
            CLICK_EVENT_NAME = eventUtils.addNamespace("dxclick", LIST_EDIT_DECORATOR),
            ACTIVE_EVENT_NAME = eventUtils.addNamespace(feedbackEvents.active, LIST_EDIT_DECORATOR),
            SLIDE_MENU_CLASS = "dx-list-slide-menu",
            SLIDE_MENU_WRAPPER_CLASS = "dx-list-slide-menu-wrapper",
            SLIDE_MENU_CONTENT_CLASS = "dx-list-slide-menu-content",
            SLIDE_MENU_BUTTONS_CONTAINER_CLASS = "dx-list-slide-menu-buttons-container",
            SLIDE_MENU_BUTTONS_CLASS = "dx-list-slide-menu-buttons",
            SLIDE_MENU_BUTTON_CLASS = "dx-list-slide-menu-button",
            SLIDE_MENU_BUTTON_MENU_CLASS = "dx-list-slide-menu-button-menu",
            SLIDE_MENU_BUTTON_DELETE_CLASS = "dx-list-slide-menu-button-delete",
            SLIDE_MENU_ANIMATION_DURATION = 400,
            SLIDE_MENU_ANIMATION_EASING = "cubic-bezier(0.075, 0.82, 0.165, 1)";
        ui.dxList.registerEditDecorator("menu", "slide", ui.dxList.SwitchableEditDecorator.inherit({
            _shouldHandleSwipe: true,
            _init: function() {
                this.callBase.apply(this, arguments);
                this._$buttonsContainer = $("<div/>").addClass(SLIDE_MENU_BUTTONS_CONTAINER_CLASS).on(ACTIVE_EVENT_NAME, $.noop);
                this._$buttons = $("<div/>").addClass(SLIDE_MENU_BUTTONS_CLASS).appendTo(this._$buttonsContainer);
                this._renderMenu();
                this._renderDeleteButton()
            },
            _renderMenu: function() {
                if (!this._menuEnabled())
                    return;
                var menuItems = this._menuItems();
                if (menuItems.length === 1) {
                    var menuItem = menuItems[0];
                    this._renderMenuButton(menuItem.text, $.proxy(function(e) {
                        e.stopPropagation();
                        this._fireAction(menuItem)
                    }, this))
                }
                else {
                    var $menu = $("<div />").addClass(SLIDE_MENU_CLASS);
                    this._menu = this._list._createComponent($menu, "dxActionSheet", {
                        showTitle: false,
                        items: menuItems,
                        onItemClick: $.proxy(function(args) {
                            this._fireAction(args.itemData)
                        }, this),
                        _templates: {}
                    });
                    $menu.appendTo(this._list.element());
                    var $menuButton = this._renderMenuButton(Globalize.localize("dxListEditDecorator-more"), $.proxy(function(e) {
                            e.stopPropagation();
                            this._menu.show()
                        }, this));
                    this._menu.option("target", $menuButton)
                }
            },
            _renderMenuButton: function(text, action) {
                var $menuButton = $("<div/>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_MENU_CLASS).text(text);
                this._$buttons.append($menuButton);
                $menuButton.on(CLICK_EVENT_NAME, action);
                return $menuButton
            },
            _renderDeleteButton: function() {
                if (!this._deleteEnabled())
                    return;
                var $deleteButton = $("<div/>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_DELETE_CLASS).text(Globalize.localize("dxListEditDecorator-delete"));
                $deleteButton.on(CLICK_EVENT_NAME, $.proxy(function(e) {
                    e.stopPropagation();
                    this._deleteItem()
                }, this));
                this._$buttons.append($deleteButton)
            },
            _fireAction: function(menuItem) {
                this._fireMenuAction($(this._cachedNode), menuItem.action);
                this._cancelDeleteReadyItem()
            },
            modifyElement: function(config) {
                this.callBase.apply(this, arguments);
                var $itemElement = config.$itemElement;
                $itemElement.addClass(SLIDE_MENU_WRAPPER_CLASS);
                var $slideMenuContent = $("<div/>").addClass(SLIDE_MENU_CONTENT_CLASS);
                $itemElement.wrapInner($slideMenuContent)
            },
            handleClick: function(_, e) {
                if ($(e.target).closest("." + SLIDE_MENU_CONTENT_CLASS).length)
                    return this.callBase.apply(this, arguments);
                return false
            },
            _swipeStartHandler: function($itemElement) {
                this._enablePositioning($itemElement);
                this._cacheItemData($itemElement);
                this._setPositions(this._getPostions(0))
            },
            _swipeUpdateHandler: function($itemElement, args) {
                var rtl = this._isRtlEnabled(),
                    signCorrection = rtl ? -1 : 1,
                    isItemReadyToDelete = this._isReadyToDelete($itemElement);
                if (!isItemReadyToDelete && args.offset * signCorrection > 0) {
                    args.cancel = true;
                    return
                }
                var offset = this._cachedItemWidth * args.offset,
                    startOffset = isItemReadyToDelete ? -this._cachedButtonWidth * signCorrection : 0,
                    correctedOffset = (offset + startOffset) * signCorrection,
                    percent = correctedOffset < 0 ? Math.abs((offset + startOffset) / this._cachedButtonWidth) : 0;
                this._setPositions(this._getPostions(percent));
                return true
            },
            _getStartPositions: function() {
                var rtl = this._isRtlEnabled(),
                    signCorrection = rtl ? -1 : 1;
                return {
                        content: 0,
                        buttonsContainer: rtl ? -this._cachedButtonWidth : this._cachedItemWidth,
                        buttons: -this._cachedButtonWidth * signCorrection
                    }
            },
            _getPostions: function(percent) {
                var rtl = this._isRtlEnabled(),
                    signCorrection = rtl ? -1 : 1,
                    startPositions = this._getStartPositions();
                return {
                        content: startPositions.content - percent * this._cachedButtonWidth * signCorrection,
                        buttonsContainer: startPositions.buttonsContainer - Math.min(percent, 1) * this._cachedButtonWidth * signCorrection,
                        buttons: startPositions.buttons + Math.min(percent, 1) * this._cachedButtonWidth * signCorrection
                    }
            },
            _getCurrentPositions: function() {
                return {
                        content: translator.locate(this._$cachedContent).left,
                        buttonsContainer: translator.locate(this._$buttonsContainer).left,
                        buttons: translator.locate(this._$buttons).left
                    }
            },
            _setPositions: function(positions) {
                translator.move(this._$cachedContent, {left: positions.content});
                translator.move(this._$buttonsContainer, {left: positions.buttonsContainer});
                translator.move(this._$buttons, {left: positions.buttons})
            },
            _cacheItemData: function($itemElement) {
                if ($itemElement[0] === this._cachedNode)
                    return;
                this._$cachedContent = $itemElement.find("." + SLIDE_MENU_CONTENT_CLASS);
                this._cachedItemWidth = $itemElement.outerWidth();
                this._cachedButtonWidth = this._cachedButtonWidth || this._$buttons.outerWidth();
                this._$buttonsContainer.width(this._cachedButtonWidth);
                if (this._$cachedContent.length)
                    this._cachedNode = $itemElement[0]
            },
            _minButtonContainerLeftOffset: function() {
                return this._cachedItemWidth - this._cachedButtonWidth
            },
            _swipeEndHandler: function($itemElement, args) {
                this._cacheItemData($itemElement);
                var signCorrection = this._isRtlEnabled() ? 1 : -1,
                    offset = this._cachedItemWidth * args.offset,
                    endedAtReadyToDelete = !this._isReadyToDelete($itemElement) && offset * signCorrection > this._cachedButtonWidth * 0.2,
                    readyToDelete = args.targetOffset === signCorrection || endedAtReadyToDelete;
                this._toggleDeleteReady($itemElement, readyToDelete);
                return true
            },
            _enablePositioning: function($itemElement) {
                fx.stop(this._$cachedContent, true);
                this.callBase.apply(this, arguments);
                this._$buttonsContainer.appendTo($itemElement)
            },
            _disablePositioning: function($itemElement) {
                this.callBase.apply(this, arguments);
                this._$buttonsContainer.detach()
            },
            _animatePrepareDeleteReady: function() {
                return this._animateToPositions(this._getPostions(1))
            },
            _animateForgetDeleteReady: function($itemElement) {
                this._cacheItemData($itemElement);
                return this._animateToPositions(this._getPostions(0))
            },
            _animateToPositions: function(positions) {
                var that = this,
                    currentPosition = this._getCurrentPositions(),
                    durationTimePart = Math.min(Math.abs(currentPosition.content - positions.content) / this._cachedButtonWidth, 1);
                return fx.animate(this._$cachedContent, {
                        from: this._getCurrentPositions(),
                        to: positions,
                        easing: SLIDE_MENU_ANIMATION_EASING,
                        duration: SLIDE_MENU_ANIMATION_DURATION * durationTimePart,
                        strategy: "frame",
                        draw: function(positions) {
                            that._setPositions(positions)
                        }
                    })
            },
            dispose: function() {
                if (this._menu)
                    this._menu.element().remove();
                if (this._$buttonsContainer)
                    this._$buttonsContainer.remove();
                this.callBase.apply(this, arguments)
            }
        }).include(ui.dxList.EditDecoratorMenuHelperMixin))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.swipe.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.require("/utils/utils.translator"),
            fx = DX.fx;
        ui.dxList.registerEditDecorator("delete", "swipe", ui.dxList.EditDecorator.inherit({
            _shouldHandleSwipe: true,
            _renderItemPosition: function($itemElement, offset, animate) {
                var deferred = $.Deferred(),
                    itemOffset = offset * this._itemElementWidth;
                if (animate)
                    fx.animate($itemElement, {
                        to: {left: itemOffset},
                        type: "slide",
                        complete: function() {
                            deferred.resolve($itemElement, offset)
                        }
                    });
                else {
                    translator.move($itemElement, {left: itemOffset});
                    deferred.resolve()
                }
                return deferred.promise()
            },
            _swipeStartHandler: function($itemElement) {
                this._itemElementWidth = $itemElement.width();
                return true
            },
            _swipeUpdateHandler: function($itemElement, args) {
                this._renderItemPosition($itemElement, args.offset);
                return true
            },
            _swipeEndHandler: function($itemElement, args) {
                var offset = args.targetOffset;
                this._renderItemPosition($itemElement, offset, true).done($.proxy(function($itemElement, offset) {
                    if (Math.abs(offset))
                        this._list.deleteItem($itemElement).fail($.proxy(function() {
                            this._renderItemPosition($itemElement, 0, true)
                        }, this))
                }, this));
                return true
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.context.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var CONTEXTMENU_CLASS = "dx-list-context-menu",
            CONTEXTMENU_MENUCONTENT_CLASS = "dx-list-context-menucontent";
        ui.dxList.registerEditDecorator("menu", "context", ui.dxList.EditDecorator.inherit({
            _init: function() {
                var $menu = $("<div/>").addClass(CONTEXTMENU_CLASS);
                this._list.element().append($menu);
                this._menu = this._renderOverlay($menu)
            },
            _renderOverlay: function($element) {
                return this._list._createComponent($element, "dxOverlay", {
                        shading: false,
                        deferRendering: true,
                        closeOnTargetScroll: true,
                        closeOnOutsideClick: function(e) {
                            return !$(e.target).closest("." + CONTEXTMENU_CLASS).length
                        },
                        animation: {
                            show: {
                                type: "slide",
                                duration: 300,
                                from: {
                                    height: 0,
                                    opacity: 1
                                },
                                to: {
                                    height: $.proxy(function() {
                                        return this._$menuList.outerHeight()
                                    }, this),
                                    opacity: 1
                                }
                            },
                            hide: {
                                type: "slide",
                                duration: 0,
                                from: {opacity: 1},
                                to: {opacity: 0}
                            }
                        },
                        height: $.proxy(function() {
                            return this._$menuList ? this._$menuList.outerHeight() : 0
                        }, this),
                        width: $.proxy(function() {
                            return this._list.element().outerWidth()
                        }, this),
                        onContentReady: $.proxy(this._renderMenuContent, this)
                    })
            },
            _renderMenuContent: function(e) {
                var $overlayContent = e.component.content();
                var items = this._menuItems().slice();
                if (this._deleteEnabled())
                    items.push({
                        text: Globalize.localize("dxListEditDecorator-delete"),
                        action: $.proxy(this._deleteItem, this)
                    });
                this._$menuList = $("<div>");
                this._list._createComponent(this._$menuList, "dxList", {
                    items: items,
                    onItemClick: $.proxy(this._menuItemClickHandler, this),
                    height: "auto",
                    _templates: {}
                });
                $overlayContent.addClass(CONTEXTMENU_MENUCONTENT_CLASS);
                $overlayContent.append(this._$menuList)
            },
            _menuItemClickHandler: function(args) {
                this._menu.hide();
                this._fireMenuAction(this._$itemWithMenu, args.itemData.action)
            },
            _deleteItem: function() {
                this._list.deleteItem(this._$itemWithMenu)
            },
            handleContextMenu: function($itemElement) {
                this._$itemWithMenu = $itemElement;
                this._menu.option({position: {
                        my: "top",
                        at: "bottom",
                        of: $itemElement,
                        collision: "flip"
                    }});
                this._menu.show();
                return true
            },
            dispose: function() {
                if (this._menu)
                    this._menu.element().remove();
                this.callBase.apply(this, arguments)
            }
        }).include(ui.dxList.EditDecoratorMenuHelperMixin))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.selection.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            CheckBox = DX.require("/ui/widgets/ui.checkBox"),
            RadioButton = DX.require("/ui/widgets/ui.radioButton"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var SELECT_DECORATOR_ENABLED_CLASS = "dx-list-select-decorator-enabled",
            SELECT_DECORATOR_SELECT_ALL_CLASS = "dx-list-select-all",
            SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS = "dx-list-select-all-checkbox",
            SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS = "dx-list-select-all-label",
            SELECT_CHECKBOX_CONTAINER_CLASS = "dx-list-select-checkbox-container",
            SELECT_CHECKBOX_CLASS = "dx-list-select-checkbox",
            SELECT_RADIO_BUTTON_CONTAINER_CLASS = "dx-list-select-radiobutton-container",
            SELECT_RADIO_BUTTON_CLASS = "dx-list-select-radiobutton";
        var CLICK_EVENT_NAME = eventUtils.addNamespace("dxclick", "dxListEditDecorator");
        ui.dxList.registerEditDecorator("selection", "default", ui.dxList.EditDecorator.inherit({
            _init: function() {
                this.callBase.apply(this, arguments);
                var selectionMode = this._list.option("selectionMode");
                this._singleStrategy = selectionMode === "single";
                this._containerClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CONTAINER_CLASS : SELECT_CHECKBOX_CONTAINER_CLASS;
                this._controlClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CLASS : SELECT_CHECKBOX_CLASS;
                this._controlWidget = this._singleStrategy ? RadioButton.publicName() : CheckBox.publicName();
                this._list.element().addClass(SELECT_DECORATOR_ENABLED_CLASS)
            },
            beforeBag: function(config) {
                var $itemElement = config.$itemElement,
                    $container = config.$container;
                var $control = $("<div />").addClass(this._controlClass);
                $control[this._controlWidget]($.extend(this._commonOptions(), {
                    value: this._isSelected($itemElement),
                    focusStateEnabled: false,
                    hoverStateEnabled: false,
                    onValueChanged: $.proxy(function(e) {
                        this._processCheckedState($itemElement, e.value);
                        e.jQueryEvent && e.jQueryEvent.stopPropagation()
                    }, this)
                }));
                $container.addClass(this._containerClass);
                $container.append($control)
            },
            modifyElement: function(config) {
                this.callBase.apply(this, arguments);
                var $itemElement = config.$itemElement,
                    control = $itemElement.find("." + this._controlClass)[this._controlWidget]("instance");
                $itemElement.on("stateChanged", $.proxy(function() {
                    control.option("value", this._isSelected($itemElement));
                    this._updateSelectAllState()
                }, this))
            },
            _updateSelectAllState: function() {
                if (!this._$selectAll)
                    return;
                var items = this._list.option("items");
                var selectedItems = this._list.option("selectedItems");
                var dataSource = this._list._dataSource;
                var itemsCount = dataSource && dataSource.totalCount() >= 0 ? dataSource.totalCount() : items.length;
                var isSelectedAll = itemsCount > 0 && itemsCount === selectedItems.length ? true : selectedItems.length === 0 ? false : undefined;
                this._selectAllCheckBox.option("value", isSelectedAll)
            },
            afterRender: function() {
                if (this._list.option("selectionMode") !== "all")
                    return;
                if (!this._$selectAll)
                    this._renderSelectAll()
            },
            _renderSelectAll: function() {
                var $selectAll = this._$selectAll = $("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CLASS);
                this._selectAllCheckBox = this._list._createComponent($("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS).appendTo($selectAll), CheckBox);
                $("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS).text(this._list.option("selectAllText")).appendTo($selectAll);
                this._list.itemsContainer().prepend($selectAll);
                this._updateSelectAllState();
                this._attachSelectAllHandler()
            },
            _attachSelectAllHandler: function() {
                this._selectAllCheckBox.option("onValueChanged", $.proxy(this._selectAllHandler, this));
                this._$selectAll.off(CLICK_EVENT_NAME).on(CLICK_EVENT_NAME, $.proxy(this._selectAllClickHandler, this))
            },
            _selectAllHandler: function(e) {
                e.jQueryEvent && e.jQueryEvent.stopPropagation();
                var isSelectedAll = this._selectAllCheckBox.option("value");
                var result = this._list._createActionByOption("onSelectAllChanged")({value: isSelectedAll});
                if (result === false)
                    return;
                if (isSelectedAll === true)
                    this._selectAllItems();
                else if (isSelectedAll === false)
                    this._unselectAllItems()
            },
            _selectAllItems: function() {
                this._list.option("selectedItems", this._list.option("items").slice())
            },
            _unselectAllItems: function() {
                this._list.option("selectedItems", [])
            },
            _selectAllClickHandler: function() {
                this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"))
            },
            _isSelected: function($itemElement) {
                return this._list.isItemSelected($itemElement)
            },
            _processCheckedState: function($itemElement, checked) {
                if (checked)
                    this._list.selectItem($itemElement);
                else
                    this._list.unselectItem($itemElement)
            },
            dispose: function() {
                this._disposeSelectAll();
                this._list.element().removeClass(SELECT_DECORATOR_ENABLED_CLASS);
                this.callBase.apply(this, arguments)
            },
            _disposeSelectAll: function() {
                if (this._$selectAll) {
                    this._$selectAll.remove();
                    this._$selectAll = null
                }
            },
            handleClick: function($itemElement) {
                var newState = !this._isSelected($itemElement) || this._singleStrategy;
                this._processCheckedState($itemElement, newState);
                return true
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.decorator.reorder.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.require("/utils/utils.translator"),
            fx = DX.fx,
            support = DX.require("/utils/utils.support"),
            mathUtils = DX.require("/utils/utils.math"),
            Animator = DX.require("/animator"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var ReorderScrollAnimator = Animator.inherit({
                ctor: function(strategy) {
                    this.callBase();
                    this._strategy = strategy
                },
                _isFinished: function() {
                    return this._strategy.scrollFinished()
                },
                _step: function() {
                    this._strategy.scrollByStep()
                }
            });
        var LIST_EDIT_DECORATOR = "dxListEditDecorator",
            DRAG_START_EVENT_NAME = eventUtils.addNamespace("dxdragstart", LIST_EDIT_DECORATOR),
            DRAG_UPDATE_EVENT_NAME = eventUtils.addNamespace("dxdrag", LIST_EDIT_DECORATOR),
            DRAG_END_EVENT_NAME = eventUtils.addNamespace("dxdragend", LIST_EDIT_DECORATOR),
            REORDER_HANDLE_CONTAINER_CLASS = "dx-list-reorder-handle-container",
            REORDER_HANDLE_CLASS = "dx-list-reorder-handle",
            REOREDERING_ITEM_CLASS = "dx-list-item-reordering",
            REOREDERING_ITEM_GHOST_CLASS = "dx-list-item-ghost-reordering",
            LIST_REORDER_COMPATIBILITY_MODE_CLASS = "dx-list-reorder-compatibility-mode";
        ui.dxList.registerEditDecorator("reorder", "default", ui.dxList.EditDecorator.inherit({
            _init: function() {
                this._groupedEnabled = this._list.option("grouped");
                this._initAnimator()
            },
            _initAnimator: function() {
                this._scrollAnimator = new ReorderScrollAnimator(this)
            },
            _startAnimator: function() {
                if (!this._scrollAnimator.inProgress())
                    this._scrollAnimator.start()
            },
            _stopAnimator: function() {
                this._scrollAnimator.stop()
            },
            afterBag: function(config) {
                var $itemElement = config.$itemElement,
                    $container = config.$container;
                var $handle = $("<div>").addClass(REORDER_HANDLE_CLASS);
                $handle.on(DRAG_START_EVENT_NAME, {
                    direction: "both",
                    immediate: true
                }, $.proxy(this._dragStartHandler, this, $itemElement));
                $handle.on(DRAG_UPDATE_EVENT_NAME, $.proxy(this._dragHandler, this, $itemElement));
                $handle.on(DRAG_END_EVENT_NAME, $.proxy(this._dragEndHandler, this, $itemElement));
                $container.addClass(REORDER_HANDLE_CONTAINER_CLASS);
                $container.append($handle)
            },
            _dragStartHandler: function($itemElement, e) {
                if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
                    e.cancel = true;
                    return
                }
                this._stopPreviousAnimation();
                e.targetElements = [];
                this._cacheItemsPositions();
                this._startPointerOffset = e.pageY - $itemElement.offset().top;
                this._elementHeight = $itemElement.outerHeight();
                var itemIndex = this._list.getFlatIndexByItemElement($itemElement);
                this._startIndex = itemIndex;
                this._lastIndex = itemIndex;
                this._cacheScrollData();
                this._createGhost($itemElement);
                $itemElement.addClass(REOREDERING_ITEM_CLASS);
                this._toggleCompatibilityMode(true)
            },
            _stopPreviousAnimation: function() {
                fx.stop(this._$ghostItem, true)
            },
            _toggleCompatibilityMode: function(enabled) {
                this._list.element().toggleClass(LIST_REORDER_COMPATIBILITY_MODE_CLASS, !support.transform && enabled)
            },
            _cacheItemsPositions: function() {
                this._itemPositions = [];
                $.each(this._list.itemElements(), $.proxy(function(index, item) {
                    this._itemPositions.push($(item).position().top)
                }, this))
            },
            _getDraggingElementPosition: function() {
                return this._itemPositions[this._startIndex]
            },
            _getLastElementPosition: function() {
                return this._itemPositions[this._lastIndex]
            },
            _cacheScrollData: function() {
                this._list.updateDimensions();
                this._startScrollTop = this._list.scrollTop();
                this._scrollOffset = 0;
                this._scrollHeight = this._list.scrollHeight();
                this._clientHeight = this._list.clientHeight()
            },
            _scrollTop: function() {
                return this._startScrollTop + this._scrollOffset
            },
            _createGhost: function($itemElement) {
                this._$ghostItem = $itemElement.clone();
                this._$ghostItem.addClass(REOREDERING_ITEM_GHOST_CLASS).appendTo(this._list.itemsContainer());
                this._startGhostPosition = this._getDraggingElementPosition() - this._$ghostItem.position().top;
                translator.move(this._$ghostItem, {top: this._startGhostPosition})
            },
            _dragHandler: function($itemElement, e) {
                this._topOffset = e.offset.y;
                this._updateItemPositions();
                var pointerPosition = this._getPonterPosition();
                this._toggleScroll(pointerPosition)
            },
            _getPonterPosition: function() {
                return this._getDraggingElementPosition() + this._startPointerOffset + this._scrollOffset + this._topOffset
            },
            _toggleScroll: function(pointerPosition) {
                if (this._scrollHeight <= this._clientHeight)
                    return;
                var minOffset = this._elementHeight * 0.7,
                    topOffset = this._clientHeight - (pointerPosition - this._scrollTop()),
                    topOffsetRatio = topOffset / minOffset,
                    bottomOffset = pointerPosition - this._scrollTop(),
                    bottomOffsetRatio = bottomOffset / minOffset;
                if (topOffsetRatio < 1) {
                    this._stepSize = this._adjustRationIntoRange(topOffsetRatio);
                    this._startAnimator()
                }
                else if (bottomOffsetRatio < 1) {
                    this._stepSize = -this._adjustRationIntoRange(bottomOffsetRatio);
                    this._startAnimator()
                }
                else
                    this._stopAnimator()
            },
            _adjustRationIntoRange: function(ratio) {
                return mathUtils.fitIntoRange(Math.round(Math.abs(ratio - 1) * 7), 1, 7)
            },
            _updateItemPositions: function() {
                this._updateGhostPosition();
                this._updateOthersPositions()
            },
            _updateGhostPosition: function() {
                translator.move(this._$ghostItem, {top: this._startGhostPosition + this._scrollOffset + this._topOffset})
            },
            _updateOthersPositions: function() {
                var currentIndex = this._findItemIndexByPosition(this._getPonterPosition());
                if (this._lastIndex === currentIndex || this._groupedEnabled && !this._sameParent(currentIndex))
                    return;
                var currentIndexOffset = currentIndex - this._startIndex,
                    currentDirection = mathUtils.sign(currentIndexOffset),
                    minIndex = Math.min(currentIndex, this._lastIndex),
                    maxIndex = Math.max(currentIndex, this._lastIndex);
                for (var itemIndex = minIndex; itemIndex <= maxIndex; itemIndex++) {
                    if (itemIndex === this._startIndex)
                        continue;
                    var $item = this._list.getItemElementByFlatIndex(itemIndex),
                        itemIndexOffset = itemIndex - this._startIndex,
                        itemDirection = mathUtils.sign(itemIndexOffset),
                        offsetsDifference = Math.abs(itemIndexOffset) <= Math.abs(currentIndexOffset),
                        sameDirections = currentDirection === itemDirection,
                        setupPosition = offsetsDifference && sameDirections,
                        resetPosition = !offsetsDifference || !sameDirections;
                    fx.stop($item);
                    if (setupPosition)
                        fx.animate($item, {
                            type: "slide",
                            to: {top: this._elementHeight * -currentDirection},
                            duration: 300
                        });
                    if (resetPosition)
                        fx.animate($item, {
                            type: "slide",
                            to: {top: 0},
                            duration: 300
                        })
                }
                this._lastIndex = currentIndex
            },
            _sameParent: function(index) {
                var $dragging = this._list.getItemElementByFlatIndex(this._startIndex),
                    $over = this._list.getItemElementByFlatIndex(index);
                return $over.parent().get(0) === $dragging.parent().get(0)
            },
            scrollByStep: function() {
                this._scrollOffset += this._stepSize;
                this._list.scrollBy(this._stepSize);
                this._updateItemPositions()
            },
            scrollFinished: function() {
                var scrollTop = this._scrollTop(),
                    rejectScrollTop = scrollTop <= 0 && this._stepSize < 0,
                    rejectScrollBottom = scrollTop >= this._scrollHeight - this._clientHeight && this._stepSize > 0;
                return rejectScrollTop || rejectScrollBottom
            },
            _dragEndHandler: function($itemElement) {
                this._scrollAnimator.stop();
                fx.animate(this._$ghostItem, {
                    type: "slide",
                    to: {top: this._startGhostPosition + this._getLastElementPosition() - this._getDraggingElementPosition()},
                    duration: 300
                }).done($.proxy(function() {
                    $itemElement.removeClass(REOREDERING_ITEM_CLASS);
                    this._resetPositions();
                    this._list.reorderItem($itemElement, this._list.getItemElementByFlatIndex(this._lastIndex));
                    this._deleteGhost();
                    this._toggleCompatibilityMode(false)
                }, this))
            },
            _deleteGhost: function() {
                this._$ghostItem.remove()
            },
            _resetPositions: function() {
                var minIndex = Math.min(this._startIndex, this._lastIndex),
                    maxIndex = Math.max(this._startIndex, this._lastIndex);
                for (var itemIndex = minIndex; itemIndex <= maxIndex; itemIndex++) {
                    var $item = this._list.getItemElementByFlatIndex(itemIndex);
                    translator.resetPosition($item)
                }
            },
            _findItemIndexByPosition: function(position) {
                var minIndex = 0;
                var maxIndex = this._itemPositions.length - 1;
                var currentIndex;
                var currentPosition;
                while (minIndex <= maxIndex) {
                    currentIndex = (minIndex + maxIndex) / 2 | 0;
                    currentPosition = this._itemPositions[currentIndex];
                    if (currentPosition < position)
                        minIndex = currentIndex + 1;
                    else if (currentPosition > position)
                        maxIndex = currentIndex - 1;
                    else
                        return currentIndex
                }
                return mathUtils.fitIntoRange(minIndex, 0, Math.max(maxIndex, 0))
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.list.edit.provider.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            Class = DevExpress.require("/class"),
            errors = DevExpress.require("/ui/ui.errors");
        var editOptionsRegistry = [];
        var registerOption = function(enabledFunc, decoratorTypeFunc, decoratorSubTypeFunc) {
                editOptionsRegistry.push({
                    enabled: enabledFunc,
                    decoratorType: decoratorTypeFunc,
                    decoratorSubType: decoratorSubTypeFunc
                })
            };
        registerOption(function() {
            return this.option("menuItems").length
        }, function() {
            return "menu"
        }, function() {
            return this.option("menuMode")
        });
        registerOption(function() {
            return !this.option("menuItems").length && this.option("allowItemDeleting")
        }, function() {
            var mode = this.option("itemDeleteMode");
            return mode === "toggle" || mode === "slideButton" || mode === "swipe" || mode === "static" ? "delete" : "menu"
        }, function() {
            var mode = this.option("itemDeleteMode");
            if (mode === "slideItem")
                mode = "slide";
            if (mode === "hold")
                mode = "context";
            return mode
        });
        registerOption(function() {
            return this.option("selectionMode") !== "none" && this.option("showSelectionControls")
        }, function() {
            return "selection"
        }, function() {
            return "default"
        });
        registerOption(function() {
            return this.option("allowItemReordering")
        }, function() {
            return "reorder"
        }, function() {
            return "default"
        });
        var LIST_ITEM_BEFORE_BAG_CLASS = "dx-list-item-before-bag",
            LIST_ITEM_AFTER_BAG_CLASS = "dx-list-item-after-bag",
            DECORATOR_BEFORE_BAG_CREATE_METHOD = "beforeBag",
            DECORATOR_AFTER_BAG_CREATE_METHOD = "afterBag",
            DECORATOR_MODIFY_ELEMENT_METHOD = "modifyElement",
            DECORATOR_AFTER_RENDER_METHOD = "afterRender";
        ui.dxList.EditProvider = Class.inherit({
            ctor: function(list) {
                this._list = list;
                this._fetchRequiredDecorators()
            },
            dispose: function() {
                if (this._decorators && this._decorators.length)
                    $.each(this._decorators, function(_, decorator) {
                        decorator.dispose()
                    })
            },
            _fetchRequiredDecorators: function() {
                this._decorators = [];
                $.each(editOptionsRegistry, $.proxy(function(_, option) {
                    var optionEnabled = option.enabled.call(this._list);
                    if (optionEnabled) {
                        var decoratorType = option.decoratorType.call(this._list),
                            decoratorSubType = option.decoratorSubType.call(this._list),
                            decorator = this._createDecorator(decoratorType, decoratorSubType);
                        this._decorators.push(decorator)
                    }
                }, this))
            },
            _createDecorator: function(type, subType) {
                var decoratorClass = this._findDecorator(type, subType);
                return new decoratorClass(this._list)
            },
            _findDecorator: function(type, subType) {
                var foundDecorator = ui.dxList.EditDecoratorsRegistry[type][subType];
                if (!foundDecorator)
                    throw errors.Error("E1012", type, subType);
                return foundDecorator
            },
            modifyItemElement: function(args) {
                var $itemElement = $(args.itemElement);
                var config = {$itemElement: $itemElement};
                this._prependBeforeBags($itemElement, config);
                this._appendAfterBags($itemElement, config);
                this._applyDecorators(DECORATOR_MODIFY_ELEMENT_METHOD, config)
            },
            afterItemsRendered: function() {
                this._applyDecorators(DECORATOR_AFTER_RENDER_METHOD)
            },
            _prependBeforeBags: function($itemElement, config) {
                var $beforeBags = this._collectDecoratorsMarkup(DECORATOR_BEFORE_BAG_CREATE_METHOD, config, LIST_ITEM_BEFORE_BAG_CLASS);
                $itemElement.prepend($beforeBags)
            },
            _appendAfterBags: function($itemElement, config) {
                var $afterBags = this._collectDecoratorsMarkup(DECORATOR_AFTER_BAG_CREATE_METHOD, config, LIST_ITEM_AFTER_BAG_CLASS);
                $itemElement.append($afterBags)
            },
            _collectDecoratorsMarkup: function(method, config, containerClass) {
                var $collector = $("<div />");
                $.each(this._decorators, function() {
                    var $container = $("<div />").addClass(containerClass);
                    this[method]($.extend({$container: $container}, config));
                    if ($container.children().length)
                        $collector.append($container)
                });
                return $collector.children()
            },
            _applyDecorators: function(method, config) {
                $.each(this._decorators, function() {
                    this[method](config)
                })
            },
            _handlerExists: function(name) {
                if (!this._decorators)
                    return false;
                var decorators = this._decorators,
                    length = decorators.length;
                for (var i = 0; i < length; i++)
                    if (decorators[i][name] !== $.noop)
                        return true;
                return false
            },
            _eventHandler: function(name, $itemElement, e) {
                if (!this._decorators)
                    return false;
                var response = false,
                    decorators = this._decorators,
                    length = decorators.length;
                for (var i = 0; i < length; i++) {
                    response = decorators[i][name]($itemElement, e);
                    if (response)
                        break
                }
                return response
            },
            handleClick: function($itemElement, e) {
                return this._eventHandler("handleClick", $itemElement, e)
            },
            contextMenuHandlerExists: function() {
                return this._handlerExists("handleContextMenu")
            },
            handleContextMenu: function($itemElement, e) {
                return this._eventHandler("handleContextMenu", $itemElement, e)
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.tileView.js */
    DevExpress.define("/ui/widgets/ui.tileView", ["jquery", "/devices", "/componentRegistrator", "/ui/uiNamespace", "/utils/utils.inflector", "/utils/utils.common"], function($, devices, registerComponent, uiNamespace, inflector, commonUtils) {
        var TILEVIEW_CLASS = "dx-tileview",
            TILEVIEW_CONTAINER_CLASS = "dx-tileview-wrapper",
            TILEVIEW_ITEM_CLASS = "dx-tile",
            TILEVIEW_ITEM_SELECTOR = "." + TILEVIEW_ITEM_CLASS,
            TILEVIEW_ITEM_DATA_KEY = "dxTileData";
        var CONFIGS = {
                horizontal: {
                    itemMainRatio: "widthRatio",
                    itemCrossRatio: "heightRatio",
                    baseItemMainDimension: "baseItemWidth",
                    baseItemCrossDimension: "baseItemHeight",
                    mainDimension: "width",
                    crossDimension: "height",
                    mainPosition: "left",
                    crossPosition: "top"
                },
                vertical: {
                    itemMainRatio: "heightRatio",
                    itemCrossRatio: "widthRatio",
                    baseItemMainDimension: "baseItemHeight",
                    baseItemCrossDimension: "baseItemWidth",
                    mainDimension: "height",
                    crossDimension: "width",
                    mainPosition: "top",
                    crossPosition: "left"
                }
            };
        var TileView = DevExpress.ui.CollectionWidget.inherit({
                _activeStateUnit: TILEVIEW_ITEM_SELECTOR,
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            items: null,
                            direction: "horizontal",
                            hoverStateEnabled: true,
                            showScrollbar: false,
                            height: 500,
                            baseItemWidth: 100,
                            baseItemHeight: 100,
                            itemMargin: 20,
                            activeStateEnabled: true,
                            indicateLoading: true
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }])
                },
                _itemClass: function() {
                    return TILEVIEW_ITEM_CLASS
                },
                _itemDataKey: function() {
                    return TILEVIEW_ITEM_DATA_KEY
                },
                _itemContainer: function() {
                    return this._$container
                },
                _init: function() {
                    this.callBase();
                    this.element().addClass(TILEVIEW_CLASS);
                    this._initScrollView()
                },
                _dataSourceLoadingChangedHandler: function(isLoading) {
                    var scrollView = this._scrollView;
                    if (!scrollView)
                        return;
                    if (isLoading && this.option("indicateLoading"))
                        scrollView.startLoading();
                    else
                        scrollView.finishLoading()
                },
                _hideLoadingIfLoadIndicationOff: function() {
                    if (!this.option("indicateLoading"))
                        this._dataSourceLoadingChangedHandler(false)
                },
                _initScrollView: function() {
                    this._scrollView = this._createComponent(this.element(), "dxScrollView", {
                        direction: this.option("direction"),
                        scrollByContent: true,
                        useKeyboard: false,
                        showScrollbar: this.option("showScrollbar")
                    });
                    this._$container = this._scrollView.content();
                    this._$container.addClass(TILEVIEW_CONTAINER_CLASS);
                    this._scrollView.option("onUpdated", $.proxy(this._renderGeometry, this))
                },
                _render: function() {
                    this.callBase();
                    this._cellsPerDimension = 1;
                    this._renderGeometry();
                    this._updateScrollView();
                    this._fireContentReadyAction()
                },
                _renderContent: function() {
                    this._renderContentImpl()
                },
                _updateScrollView: function() {
                    this._scrollView.option("direction", this.option("direction"));
                    this._scrollView.update();
                    this._indicateLoadingIfAlreadyStarted()
                },
                _indicateLoadingIfAlreadyStarted: function() {
                    if (this._isDataSourceLoading())
                        this._dataSourceLoadingChangedHandler(true)
                },
                _renderGeometry: function() {
                    this._config = CONFIGS[this.option("direction")];
                    var items = this.option("items") || [],
                        config = this._config,
                        itemMargin = this.option("itemMargin"),
                        maxItemCrossRatio = Math.max.apply(Math, $.map(items || [], function(item) {
                            return Math.round(item[config.itemCrossRatio] || 1)
                        }));
                    this._cellsPerDimension = Math.floor(this.element()[config.crossDimension]() / (this.option(config.baseItemCrossDimension) + itemMargin));
                    this._cellsPerDimension = Math.max(this._cellsPerDimension, maxItemCrossRatio);
                    this._cells = [];
                    this._cells.push(new Array(this._cellsPerDimension));
                    this._arrangeItems(items);
                    this._$container[config.mainDimension](this._cells.length * this.option(config.baseItemMainDimension) + (this._cells.length + 1) * itemMargin)
                },
                _arrangeItems: function(items) {
                    var config = this._config,
                        itemMainRatio = config.itemMainRatio,
                        itemCrossRatio = config.itemCrossRatio,
                        mainPosition = config.mainPosition;
                    this._itemsPositions = [];
                    $.each(items, $.proxy(function(index, item) {
                        var currentItem = {};
                        currentItem[itemMainRatio] = item[itemMainRatio] || 1;
                        currentItem[itemCrossRatio] = item[itemCrossRatio] || 1;
                        currentItem.index = index;
                        currentItem[itemMainRatio] = currentItem[itemMainRatio] <= 0 ? 0 : Math.round(currentItem[config.itemMainRatio]);
                        currentItem[itemCrossRatio] = currentItem[itemCrossRatio] <= 0 ? 0 : Math.round(currentItem[config.itemCrossRatio]);
                        var itemPosition = this._getItemPosition(currentItem);
                        if (itemPosition[mainPosition] === -1)
                            itemPosition[mainPosition] = this._cells.push(new Array(this._cellsPerDimension)) - 1;
                        this._occupyCells(currentItem, itemPosition);
                        this._arrangeItem(currentItem, itemPosition);
                        this._itemsPositions.push(itemPosition)
                    }, this))
                },
                _getItemPosition: function(item) {
                    var config = this._config,
                        mainPosition = config.mainPosition,
                        crossPosition = config.crossPosition;
                    var position = {};
                    position[mainPosition] = -1;
                    position[crossPosition] = 0;
                    for (var main = 0; main < this._cells.length; main++) {
                        for (var cross = 0; cross < this._cellsPerDimension; cross++)
                            if (this._itemFit(main, cross, item)) {
                                position[mainPosition] = main;
                                position[crossPosition] = cross;
                                break
                            }
                        if (position[mainPosition] > -1)
                            break
                    }
                    return position
                },
                _itemFit: function(mainPosition, crossPosition, item) {
                    var result = true,
                        config = this._config,
                        itemRatioMain = item[config.itemMainRatio],
                        itemRatioCross = item[config.itemCrossRatio];
                    if (crossPosition + itemRatioCross > this._cellsPerDimension)
                        return false;
                    for (var main = mainPosition; main < mainPosition + itemRatioMain; main++)
                        for (var cross = crossPosition; cross < crossPosition + itemRatioCross; cross++)
                            if (this._cells.length - 1 < main)
                                this._cells.push(new Array(this._cellsPerDimension));
                            else if (this._cells[main][cross] !== undefined) {
                                result = false;
                                break
                            }
                    return result
                },
                _occupyCells: function(item, itemPosition) {
                    var config = this._config,
                        itemPositionMain = itemPosition[config.mainPosition],
                        itemPositionCross = itemPosition[config.crossPosition],
                        itemRatioMain = item[config.itemMainRatio],
                        itemRatioCross = item[config.itemCrossRatio];
                    for (var main = itemPositionMain; main < itemPositionMain + itemRatioMain; main++)
                        for (var cross = itemPositionCross; cross < itemPositionCross + itemRatioCross; cross++)
                            this._cells[main][cross] = item.index
                },
                _arrangeItem: function(item, itemPosition) {
                    var config = this._config,
                        itemPositionMain = itemPosition[config.mainPosition],
                        itemPositionCross = itemPosition[config.crossPosition],
                        itemRatioMain = item[config.itemMainRatio],
                        itemRatioCross = item[config.itemCrossRatio],
                        baseItemCross = this.option(config.baseItemCrossDimension),
                        baseItemMain = this.option(config.baseItemMainDimension),
                        itemMargin = this.option("itemMargin");
                    var cssProps = {display: itemRatioMain <= 0 || itemRatioCross <= 0 ? "none" : ""};
                    cssProps[config.mainDimension] = itemRatioMain * baseItemMain + (itemRatioMain - 1) * itemMargin;
                    cssProps[config.crossDimension] = itemRatioCross * baseItemCross + (itemRatioCross - 1) * itemMargin;
                    cssProps[config.mainPosition] = itemPositionMain * baseItemMain + (itemPositionMain + 1) * itemMargin;
                    cssProps[config.crossPosition] = itemPositionCross * baseItemCross + (itemPositionCross + 1) * itemMargin;
                    if (this.option("rtlEnabled")) {
                        var offsetCorrection = this._$container.width(),
                            baseItemWidth = this.option("baseItemWidth"),
                            itemPositionX = itemPosition.left,
                            offsetPosition = itemPositionX * baseItemWidth,
                            itemBaseOffset = baseItemWidth + itemMargin,
                            itemWidth = itemBaseOffset * item.widthRatio,
                            subitemMargins = itemPositionX * itemMargin;
                        cssProps.left = offsetCorrection - (offsetPosition + itemWidth + subitemMargins)
                    }
                    this._itemElements().eq(item.index).css(cssProps)
                },
                _moveFocus: function(location) {
                    var FOCUS_UP = "up",
                        FOCUS_DOWN = "down",
                        FOCUS_LEFT = this.option("rtlEnabled") ? "right" : "left",
                        FOCUS_RIGHT = this.option("rtlEnabled") ? "left" : "right",
                        FOCUS_PAGE_UP = "pageup",
                        FOCUS_PAGE_DOWN = "pagedown";
                    var horizontalDirection = this.option("direction") === "horizontal",
                        cells = this._cells,
                        index = this.option("focusedElement").index(),
                        targetCol = this._itemsPositions[index].left,
                        targetRow = this._itemsPositions[index].top;
                    var colCount = (horizontalDirection ? cells : cells[0]).length;
                    var rowCount = (horizontalDirection ? cells[0] : cells).length;
                    var getCell = function(col, row) {
                            if (horizontalDirection)
                                return cells[col][row];
                            return cells[row][col]
                        };
                    switch (location) {
                        case FOCUS_PAGE_UP:
                        case FOCUS_UP:
                            while (targetRow > 0 && index === getCell(targetCol, targetRow))
                                targetRow--;
                            if (targetRow < 0)
                                targetRow = 0;
                            break;
                        case FOCUS_PAGE_DOWN:
                        case FOCUS_DOWN:
                            while (targetRow < rowCount && index === getCell(targetCol, targetRow))
                                targetRow++;
                            if (targetRow === rowCount)
                                targetRow = rowCount - 1;
                            break;
                        case FOCUS_RIGHT:
                            while (targetCol < colCount && index === getCell(targetCol, targetRow))
                                targetCol++;
                            if (targetCol === colCount)
                                targetCol = colCount - 1;
                            break;
                        case FOCUS_LEFT:
                            while (targetCol >= 0 && index === getCell(targetCol, targetRow))
                                targetCol--;
                            if (targetCol < 0)
                                targetCol = 0;
                            break;
                        default:
                            this.callBase.apply(this, arguments);
                            return
                    }
                    var newTargetIndex = getCell(targetCol, targetRow);
                    if (!commonUtils.isDefined(newTargetIndex))
                        return;
                    var $newTarget = this._itemElements().eq(newTargetIndex);
                    this.option("focusedElement", $newTarget);
                    this._scrollToItem($newTarget)
                },
                _scrollToItem: function($itemElement) {
                    if (!$itemElement.length)
                        return;
                    var config = this._config,
                        outerMainProp = "outer" + inflector.captionize(config.mainDimension),
                        itemMargin = this.option("itemMargin"),
                        itemPosition = $itemElement.position()[config.mainPosition],
                        itemDimension = $itemElement[outerMainProp](),
                        itemTail = itemPosition + itemDimension,
                        scrollPosition = this.scrollPosition(),
                        clientWidth = this.element()[outerMainProp]();
                    if (scrollPosition <= itemPosition && itemTail <= scrollPosition + clientWidth)
                        return;
                    if (scrollPosition > itemPosition)
                        this._scrollView.scrollTo(itemPosition - itemMargin);
                    else
                        this._scrollView.scrollTo(itemPosition + itemDimension - clientWidth + itemMargin)
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"showScrollbar":
                            this._initScrollView();
                            break;
                        case"disabled":
                            this._scrollView.option("disabled", args.value);
                            this.callBase(args);
                            break;
                        case"baseItemWidth":
                        case"baseItemHeight":
                        case"itemMargin":
                            this._renderGeometry();
                            break;
                        case"direction":
                        case"width":
                        case"height":
                            this.callBase(args);
                            this._renderGeometry();
                            this._updateScrollView();
                            break;
                        case"indicateLoading":
                            this._hideLoadingIfLoadIndicationOff();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                scrollPosition: function() {
                    return this._scrollView.scrollOffset()[this._config.mainPosition]
                }
            });
        registerComponent("dxTileView", TileView);
        return TileView
    });
    DevExpress.require(["/ui/widgets/ui.tileView"]);
    /*! Module widgets-base, file ui.trackBar.js */
    DevExpress.define("/ui/widgets/track/ui.trackBar", ["jquery", "/ui/ui.editor", "/componentRegistrator", "/ui/uiNamespace"], function($, Editor, registerComponent, uiNamespace) {
        var fx = DevExpress.fx;
        var TRACKBAR_CLASS = "dx-trackbar",
            TRACKBAR_CONTAINER_CLASS = "dx-trackbar-container",
            TRACKBAR_RANGE_CLASS = "dx-trackbar-range",
            TRACKBAR_WRAPPER_CLASS = "dx-trackbar-wrapper";
        var TrackBar = Editor.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            min: 0,
                            max: 100,
                            value: 0
                        })
                },
                _render: function() {
                    this.element().addClass(TRACKBAR_CLASS);
                    this._renderWrapper();
                    this._renderContainer();
                    this._renderRange();
                    this.callBase();
                    this._renderValue()
                },
                _renderWrapper: function() {
                    this._$wrapper = $("<div>").addClass(TRACKBAR_WRAPPER_CLASS).appendTo(this.element())
                },
                _renderContainer: function() {
                    this._$bar = $("<div>").addClass(TRACKBAR_CONTAINER_CLASS).appendTo(this._$wrapper)
                },
                _renderRange: function() {
                    this._$range = $("<div>").addClass(TRACKBAR_RANGE_CLASS).appendTo(this._$bar)
                },
                _renderValue: function() {
                    var val = this.option("value"),
                        min = this.option("min"),
                        max = this.option("max");
                    if (min > max)
                        return;
                    if (val < min) {
                        this.option("value", min);
                        this._currentRatio = 0;
                        return
                    }
                    if (val > max) {
                        this.option("value", max);
                        this._currentRatio = 1;
                        return
                    }
                    var ratio = min === max ? 0 : (val - min) / (max - min);
                    !this._needPreventAnimation && this._setRangeStyles({width: ratio * 100 + "%"});
                    this.setAria({
                        valuemin: this.option("min"),
                        valuemax: max,
                        valuenow: val
                    });
                    this._currentRatio = ratio
                },
                _setRangeStyles: function(options) {
                    fx.stop(this._$range);
                    if (!this._needPreventAnimation)
                        fx.animate(this._$range, {
                            type: "custom",
                            duration: 100,
                            to: options
                        })
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"value":
                            this._renderValue();
                            this.callBase(args);
                            break;
                        case"max":
                        case"min":
                            this._renderValue();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _dispose: function() {
                    fx.stop(this._$range);
                    this.callBase()
                }
            });
        registerComponent("dxTrackBar", uiNamespace, TrackBar);
        return TrackBar
    });
    /*! Module widgets-base, file ui.progressBar.js */
    DevExpress.define("/ui/widgets/track/ui.progressBar", ["jquery", "/ui/widgets/track/ui.trackBar", "/componentRegistrator", "/ui/uiNamespace"], function($, TrackBar, registerComponent, uiNamespace) {
        var PROGRESSBAR_CLASS = "dx-progressbar",
            PROGRESSBAR_CONTAINER_CLASS = "dx-progressbar-container",
            PROGRESSBAR_RANGE_CONTAINER_CLASS = "dx-progressbar-range-container",
            PROGRESSBAR_RANGE_CLASS = "dx-progressbar-range",
            PROGRESSBAR_WRAPPER_CLASS = "dx-progressbar-wrapper",
            PROGRESSBAR_STATUS_CLASS = "dx-progressbar-status",
            PROGRESSBAR_INDETERMINATE_SEGMENT_CONTAINER = "dx-progressbar-animating-container",
            PROGRESSBAR_INDETERMINATE_SEGMENT = "dx-progressbar-animating-segment";
        var ProgressBar = TrackBar.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            statusFormat: function(ratio, value) {
                                return "Progress: " + Math.round(ratio * 100) + "%"
                            },
                            showStatus: true,
                            onComplete: null,
                            activeStateEnabled: false,
                            statusPosition: "bottom left",
                            _animatingSegmentCount: 0
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: {platform: "win"},
                                options: {_animatingSegmentCount: 5}
                            }, {
                                device: function(device) {
                                    return device.platform === "android"
                                },
                                options: {_animatingSegmentCount: 2}
                            }])
                },
                _init: function() {
                    this.callBase()
                },
                _render: function() {
                    this._createCompleteAction();
                    this._renderStatus();
                    this.callBase();
                    this.element().addClass(PROGRESSBAR_CLASS);
                    this.setAria("role", "progressbar");
                    this._$wrapper.addClass(PROGRESSBAR_WRAPPER_CLASS);
                    this._$bar.addClass(PROGRESSBAR_CONTAINER_CLASS);
                    $("<div>").addClass(PROGRESSBAR_RANGE_CONTAINER_CLASS).appendTo(this._$wrapper).append(this._$bar);
                    this._$range.addClass(PROGRESSBAR_RANGE_CLASS);
                    this._toggleStatus(this.option("showStatus"))
                },
                _createCompleteAction: function() {
                    this._completeAction = this._createActionByOption("onComplete")
                },
                _renderStatus: function() {
                    this._$status = $("<div>").addClass(PROGRESSBAR_STATUS_CLASS)
                },
                _renderIndeterminateState: function() {
                    this._$segmentContainer = $("<div>").addClass(PROGRESSBAR_INDETERMINATE_SEGMENT_CONTAINER);
                    var segments = this.option("_animatingSegmentCount");
                    for (var i = 0; i < segments; i++)
                        $("<div>").addClass(PROGRESSBAR_INDETERMINATE_SEGMENT).addClass(PROGRESSBAR_INDETERMINATE_SEGMENT + "-" + (i + 1)).appendTo(this._$segmentContainer);
                    this._$segmentContainer.appendTo(this._$wrapper)
                },
                _toggleStatus: function(value) {
                    var splittedPosition = this.option("statusPosition").split(" ");
                    if (value)
                        if (splittedPosition[0] === "top" || splittedPosition[0] === "left")
                            this._$status.prependTo(this._$wrapper);
                        else
                            this._$status.appendTo(this._$wrapper);
                    else
                        this._$status.detach();
                    this._togglePositionClass()
                },
                _togglePositionClass: function() {
                    var position = this.option("statusPosition"),
                        splittedPosition = position.split(" ");
                    this._$wrapper.removeClass("dx-position-top-left dx-position-top-right dx-position-bottom-left dx-position-bottom-right dx-position-left dx-position-right");
                    var positionClass = "dx-position-" + splittedPosition[0];
                    if (splittedPosition[1])
                        positionClass += "-" + splittedPosition[1];
                    this._$wrapper.addClass(positionClass)
                },
                _toggleIndeterminateState: function(value) {
                    if (value) {
                        this._renderIndeterminateState();
                        this._$bar.toggle(false)
                    }
                    else {
                        this._$bar.toggle(true);
                        this._$segmentContainer.remove();
                        delete this._$segmentContainer
                    }
                },
                _renderValue: function() {
                    var val = this.option("value"),
                        max = this.option("max");
                    if (!val && val !== 0) {
                        this._toggleIndeterminateState(true);
                        return
                    }
                    if (this._$segmentContainer)
                        this._toggleIndeterminateState(false);
                    if (val === max)
                        this._completeAction();
                    this.callBase();
                    this._setStatus()
                },
                _setStatus: function() {
                    var format = this.option("statusFormat");
                    if ($.isFunction(format))
                        format = $.proxy(format, this);
                    else
                        format = function(value) {
                            return value
                        };
                    var statusText = format(this._currentRatio, this.option("value"));
                    this._$status.text(statusText)
                },
                _dispose: function() {
                    this._$status.remove();
                    this.callBase()
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"statusFormat":
                            this._setStatus();
                            break;
                        case"showStatus":
                            this._toggleStatus(args.value);
                            break;
                        case"statusPosition":
                            this._toggleStatus(this.option("showStatus"));
                            break;
                        case"onComplete":
                            this._createCompleteAction();
                            break;
                        case"_animatingSegmentCount":
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        registerComponent("dxProgressBar", uiNamespace, ProgressBar);
        return ProgressBar
    });
    DevExpress.require(["/ui/widgets/track/ui.progressBar"]);
    /*! Module widgets-base, file ui.sliderHandle.js */
    DevExpress.define("/ui/widgets/track/ui.sliderHandle", ["jquery", "/utils/utils.translator", "/utils/utils.position", "/ui/ui.widget"], function($, translator, positionUtils, Widget) {
        var SLIDER_CLASS = "dx-slider",
            SLIDER_HANDLE_CLASS = "dx-slider-handle";
        var POSITION_ALIASES = {
                top: {
                    my: "bottom center",
                    at: "top center",
                    collision: "none"
                },
                bottom: {
                    my: "top center",
                    at: "bottom center",
                    collision: "none"
                },
                right: {
                    my: "left center",
                    at: "right center",
                    collision: "none"
                },
                left: {
                    my: "right center",
                    at: "left center",
                    collision: "none"
                }
            };
        var SliderHandle = Widget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            hoverStateEnabled: false,
                            value: 0,
                            tooltipEnabled: false,
                            tooltipFormat: function(v) {
                                return v
                            },
                            tooltipPosition: "top",
                            tooltipShowMode: "onHover",
                            tooltipFitIn: null
                        })
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(SLIDER_HANDLE_CLASS);
                    this._renderTooltip();
                    this.setAria({
                        role: "slider",
                        valuenow: this.option("value")
                    })
                },
                _renderTooltip: function() {
                    if (this.option("tooltipEnabled")) {
                        if (!this._$tooltip)
                            this._$tooltip = $("<div>").appendTo(this.element());
                        this._$slider = this.element().closest("." + SLIDER_CLASS);
                        this._updateTooltip()
                    }
                    else
                        this._removeTooltip()
                },
                _createTooltip: function() {
                    if (this._tooltip)
                        return false;
                    this._tooltip = this._createComponent(this._$tooltip, "dxTooltip", {
                        visible: true,
                        target: this.element(),
                        closeOnOutsideClick: false,
                        container: this.element(),
                        closeOnBackButton: false,
                        closeOnTargetScroll: false,
                        animation: null,
                        arrowPosition: null
                    });
                    this._detachWindowResizeCallback();
                    this._attachWindowResizeCallback();
                    return true
                },
                _visibilityChanged: function() {
                    this._dimensionChanged()
                },
                _dimensionChanged: function() {
                    this._renderTooltipPosition();
                    this._centeredTooltipPosition()
                },
                _removeTooltip: function() {
                    if (!this._$tooltip)
                        return;
                    this._$tooltip.remove();
                    delete this._$tooltip;
                    delete this._tooltip
                },
                _renderTooltipPosition: function() {
                    if (!this._tooltip)
                        return;
                    var position = this.option("tooltipPosition");
                    this._saveTooltipElements();
                    this._resetTooltipPosition();
                    if ($.type(position) === "string")
                        position = $.extend({
                            boundary: this._$slider,
                            boundaryOffset: {
                                h: 1,
                                v: 1
                            }
                        }, POSITION_ALIASES[position]);
                    this._tooltip.option("position", position);
                    this._saveTooltipLocation()
                },
                _saveTooltipElements: function() {
                    this._$tooltipContent = this._tooltip.content().parent();
                    this._$tooltipArrow = this._$tooltipContent.find(".dx-popover-arrow")
                },
                _resetTooltipPosition: function() {
                    translator.resetPosition(this._$tooltipContent);
                    translator.resetPosition(this._$tooltipArrow)
                },
                _saveTooltipLocation: function() {
                    this._contentLocate = translator.locate(this._$tooltipContent);
                    this._arrowLocate = translator.locate(this._$tooltipArrow)
                },
                _centeredTooltipPosition: function() {
                    if (!this._tooltip)
                        return;
                    this._$tooltipContent.outerWidth("auto");
                    var outerWidthWithoutRounding = this._$tooltipContent.get(0).getBoundingClientRect().width;
                    var tooltipOuterWidth = Math.ceil(outerWidthWithoutRounding);
                    var roundedTooltipOuterWidth = tooltipOuterWidth % 2 + tooltipOuterWidth;
                    this._$tooltipContent.outerWidth(roundedTooltipOuterWidth);
                    var tooltipCenter = (roundedTooltipOuterWidth - this.element().width()) / 2;
                    this._contentLocate.left = -tooltipCenter;
                    this._$tooltipArrow.css({
                        marginLeft: -this._$tooltipArrow.outerWidth() / 2,
                        left: "50%"
                    });
                    this._fitTooltip()
                },
                _fitTooltip: function() {
                    if (!this._tooltip)
                        return;
                    var position = this.option("tooltipPosition");
                    if ($.type(position) === "string")
                        position = $.extend({
                            of: this.element(),
                            boundary: this._$slider,
                            boundaryOffset: {
                                h: 2,
                                v: 1
                            }
                        }, POSITION_ALIASES[position], {collision: 'fit none'});
                    var calculatePosition = positionUtils.calculate(this._$tooltipContent, position);
                    var isLeftSide = calculatePosition.h.collisionSide === "left";
                    translator.move(this._$tooltipContent, {left: this._contentLocate.left + (isLeftSide ? 1 : -1) * calculatePosition.h.oversize});
                    translator.move(this._$tooltipArrow, {left: this._arrowLocate.left + (isLeftSide ? -1 : 1) * calculatePosition.h.oversize})
                },
                _renderValue: function() {
                    if (!this._tooltip)
                        return;
                    var format = this.option("tooltipFormat"),
                        value = format(this.option("value"));
                    this._tooltip.content().html(value);
                    this._fitTooltip()
                },
                _updateTooltip: function() {
                    var hoverMode = /^onhover$/i.test(this.option("tooltipShowMode"));
                    if (!hoverMode)
                        this._createTooltip();
                    this.element().toggleClass("dx-slider-tooltip-on-hover", hoverMode);
                    this._renderTooltipPosition();
                    this._renderValue();
                    this._centeredTooltipPosition()
                },
                _clean: function() {
                    this.callBase();
                    delete this._$tooltip;
                    delete this._tooltip
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"tooltipFormat":
                            this._renderValue();
                            break;
                        case"value":
                            this._renderValue();
                            if (args.value.toString().length !== args.previousValue.toString().length)
                                this._centeredTooltipPosition();
                            this.setAria("valuenow", args.value);
                            break;
                        case"tooltipEnabled":
                            this._renderTooltip();
                            break;
                        case"tooltipPosition":
                            this._renderTooltipPosition();
                            this._centeredTooltipPosition();
                            break;
                        case"tooltipShowMode":
                            this._updateTooltip();
                            break;
                        case"tooltipFitIn":
                            this._fitTooltip();
                            break;
                        case"_templates":
                        case"templateProvider":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                fitTooltipPosition: function() {
                    this._fitTooltip()
                },
                updateTooltip: function() {
                    if (!this._createTooltip())
                        return;
                    this._renderTooltipPosition();
                    this._renderValue();
                    this._centeredTooltipPosition()
                },
                repaint: function() {
                    this._renderTooltipPosition();
                    this._centeredTooltipPosition();
                    if (this._tooltip)
                        this._tooltip._visibilityChanged(true)
                }
            });
        return SliderHandle
    });
    /*! Module widgets-base, file ui.slider.js */
    DevExpress.define("/ui/widgets/track/ui.slider", ["jquery", "/utils/utils.support", "/utils/utils.dom", "/devices", "/componentRegistrator", "/ui/widgets/track/ui.trackBar", "/ui/uiNamespace", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer", "/ui/events/ui.events.emitter.feedback", "/ui/widgets/track/ui.sliderHandle"], function($, support, domUtils, devices, registerComponent, TrackBar, uiNamespace, eventUtils, pointerEvents, feedbackEvents, SliderHandle) {
        var transionEndEventName = support.transitionEndEventName;
        var SLIDER_CLASS = "dx-slider",
            SLIDER_WRAPPER_CLASS = "dx-slider-wrapper",
            SLIDER_HANDLE_SELECTOR = ".dx-slider-handle",
            SLIDER_BAR_CLASS = "dx-slider-bar",
            SLIDER_RANGE_CLASS = "dx-slider-range",
            SLIDER_RANGE_VISIBLE_CLASS = "dx-slider-range-visible",
            SLIDER_LABEL_CLASS = "dx-slider-label",
            SLIDER_LABEL_POSITION_CLASS_PREFIX = "dx-slider-label-position-",
            SLIDER_TOOLTIP_POSITION_CLASS_PREFIX = "dx-slider-tooltip-position-";
        var Slider = TrackBar.inherit({
                _activeStateUnit: SLIDER_HANDLE_SELECTOR,
                _supportedKeys: function() {
                    var isRTL = this.option("rtlEnabled");
                    var that = this;
                    var roundedValue = function(offset, isLeftDirection) {
                            offset = that._valueStep(offset);
                            var step = that.option("step");
                            var value = that.option("value");
                            var division = (value - that.option("min")) % step;
                            return isLeftDirection ? value - offset + (division ? step - division : 0) : value + offset - division
                        };
                    var moveHandleRight = function(offset) {
                            that.option("value", roundedValue(offset, isRTL))
                        };
                    var moveHandleLeft = function(offset) {
                            that.option("value", roundedValue(offset, !isRTL))
                        };
                    return $.extend(this.callBase(), {
                            leftArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                moveHandleLeft(this.option("step"))
                            },
                            rightArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                moveHandleRight(this.option("step"))
                            },
                            pageUp: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                moveHandleRight(this.option("step") * this.option("keyStep"))
                            },
                            pageDown: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                moveHandleLeft(this.option("step") * this.option("keyStep"))
                            },
                            home: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                var min = this.option("min");
                                this.option("value", min)
                            },
                            end: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                var max = this.option("max");
                                this.option("value", max)
                            }
                        })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            hoverStateEnabled: true,
                            activeStateEnabled: true,
                            step: 1,
                            value: 50,
                            showRange: true,
                            tooltip: {
                                enabled: false,
                                format: function(value) {
                                    return value
                                },
                                position: "top",
                                showMode: "onHover"
                            },
                            label: {
                                visible: false,
                                position: "bottom",
                                format: function(value) {
                                    return value
                                }
                            },
                            keyStep: 1
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }])
                },
                _render: function() {
                    this.element().addClass(SLIDER_CLASS);
                    this.callBase();
                    this._renderLabels();
                    this._renderStartHandler();
                    this._renderAriaMinAndMax();
                    this._repaintHandle()
                },
                _visibilityChanged: function() {
                    this.repaint()
                },
                _renderWrapper: function() {
                    this.callBase();
                    this._$wrapper.addClass(SLIDER_WRAPPER_CLASS);
                    this._createComponent(this._$wrapper, "dxSwipeable", {
                        elastic: false,
                        immediate: true,
                        onStart: $.proxy(this._swipeStartHandler, this),
                        onUpdated: $.proxy(this._swipeUpdateHandler, this),
                        onEnd: $.proxy(this._swipeEndHandler, this),
                        itemSizeFunc: $.proxy(this._itemWidthFunc, this)
                    })
                },
                _renderContainer: function() {
                    this.callBase();
                    this._$bar.addClass(SLIDER_BAR_CLASS);
                    this._$bar.off(transionEndEventName + "." + this.NAME).on(transionEndEventName, $.proxy(this._fitHandleTooltipPosition, this))
                },
                _renderRange: function() {
                    this.callBase();
                    this._$range.addClass(SLIDER_RANGE_CLASS);
                    this._renderHandle();
                    this._renderRangeVisibility()
                },
                _renderRangeVisibility: function() {
                    this._$range.toggleClass(SLIDER_RANGE_VISIBLE_CLASS, Boolean(this.option("showRange")))
                },
                _renderHandle: function() {
                    this._$handle = this._renderHandleImpl(this.option("value"), this._$handle)
                },
                _renderHandleImpl: function(value, $element) {
                    var $handle = $element || $("<div>").appendTo(this._$range),
                        format = this._normalizeFormat(this.option("tooltip.format")),
                        tooltipEnabled = this.option("tooltip.enabled"),
                        tooltipPosition = this.option("tooltip.position");
                    this.element().toggleClass(SLIDER_TOOLTIP_POSITION_CLASS_PREFIX + "bottom", tooltipEnabled && tooltipPosition === "bottom").toggleClass(SLIDER_TOOLTIP_POSITION_CLASS_PREFIX + "top", tooltipEnabled && tooltipPosition === "top");
                    this._createComponent($handle, SliderHandle, {
                        value: value,
                        tooltipEnabled: tooltipEnabled,
                        tooltipPosition: tooltipPosition,
                        tooltipFormat: format,
                        tooltipShowMode: this.option("tooltip.showMode"),
                        tooltipFitIn: this.element()
                    });
                    return $handle
                },
                _renderAriaMinAndMax: function() {
                    this.setAria({
                        valuemin: this.option("min"),
                        valuemax: this.option("max")
                    }, this._$handle)
                },
                _hoverStartHandler: function(e) {
                    SliderHandle.getInstance($(e.currentTarget)).updateTooltip()
                },
                _toggleActiveState: function($element, value) {
                    this.callBase($element, value);
                    if (value)
                        SliderHandle.getInstance($element).updateTooltip()
                },
                _renderLabels: function() {
                    this.element().removeClass(SLIDER_LABEL_POSITION_CLASS_PREFIX + "bottom").removeClass(SLIDER_LABEL_POSITION_CLASS_PREFIX + "top");
                    if (this.option("label.visible")) {
                        var min = this.option("min"),
                            max = this.option("max"),
                            position = this.option("label.position"),
                            format = this._normalizeFormat(this.option("label.format"));
                        if (!this._$minLabel)
                            this._$minLabel = $("<div>").addClass(SLIDER_LABEL_CLASS).appendTo(this._$wrapper);
                        this._$minLabel.html(format(min));
                        if (!this._$maxLabel)
                            this._$maxLabel = $("<div>").addClass(SLIDER_LABEL_CLASS).appendTo(this._$wrapper);
                        this._$maxLabel.html(format(max));
                        this.element().addClass(SLIDER_LABEL_POSITION_CLASS_PREFIX + position)
                    }
                    else {
                        if (this._$minLabel) {
                            this._$minLabel.remove();
                            delete this._$minLabel
                        }
                        if (this._$maxLabel) {
                            this._$maxLabel.remove();
                            delete this._$maxLabel
                        }
                    }
                },
                _normalizeFormat: function(formatSource) {
                    var format = formatSource;
                    if (typeof formatSource === "string")
                        format = function(value) {
                            return Globalize.format(value, formatSource)
                        };
                    else if ($.isFunction(formatSource))
                        format = $.proxy(format, this);
                    else
                        format = function(value) {
                            return value
                        };
                    return format
                },
                _renderDimensions: function() {
                    this.callBase();
                    if (this._$bar) {
                        var barMarginWidth = this._$bar.outerWidth(true) - this._$bar.outerWidth();
                        this._$bar.width(this.option("width") - barMarginWidth)
                    }
                },
                _renderStartHandler: function() {
                    var pointerDownEventName = eventUtils.addNamespace(pointerEvents.down, this.NAME),
                        clickEventName = eventUtils.addNamespace("dxclick", this.NAME),
                        startAction = this._createAction($.proxy(this._startHandler, this));
                    this.element().off(pointerDownEventName).on(pointerDownEventName, function(e) {
                        if (eventUtils.isMouseEvent(e))
                            startAction({jQueryEvent: e})
                    }).off(clickEventName).on(clickEventName, $.proxy(function(e) {
                        var handle = this._activeHandle();
                        handle && handle.focusin() && handle.focus();
                        startAction({jQueryEvent: e})
                    }, this))
                },
                _itemWidthFunc: function() {
                    return this._itemWidthRatio
                },
                _swipeStartHandler: function(e) {
                    var rtlEnabled = this.option("rtlEnabled"),
                        startOffset,
                        endOffset;
                    if (eventUtils.isTouchEvent(e.jQueryEvent))
                        this._createAction($.proxy(this._startHandler, this))({jQueryEvent: e.jQueryEvent});
                    this._feedbackDeferred = $.Deferred();
                    feedbackEvents.lock(this._feedbackDeferred);
                    this._toggleActiveState(this._activeHandle(), this.option("activeStateEnabled"));
                    this._startOffset = this._currentRatio;
                    startOffset = this._startOffset * this._swipePixelRatio();
                    endOffset = (1 - this._startOffset) * this._swipePixelRatio();
                    e.jQueryEvent.maxLeftOffset = rtlEnabled ? endOffset : startOffset;
                    e.jQueryEvent.maxRightOffset = rtlEnabled ? startOffset : endOffset;
                    this._itemWidthRatio = this.element().width() / this._swipePixelRatio();
                    this._needPreventAnimation = true
                },
                _swipeEndHandler: function(e) {
                    this._feedbackDeferred.resolve();
                    this._toggleActiveState(this._activeHandle(), false);
                    var offsetDirection = this.option("rtlEnabled") ? -1 : 1;
                    delete this._needPreventAnimation;
                    this._changeValueOnSwipe(this._startOffset + offsetDirection * e.jQueryEvent.targetOffset / this._swipePixelRatio());
                    delete this._startOffset;
                    this._renderValue()
                },
                _activeHandle: function() {
                    return this._$handle
                },
                _swipeUpdateHandler: function(e) {
                    this._saveValueChangeEvent(e);
                    this._updateHandlePosition(e)
                },
                _updateHandlePosition: function(e) {
                    var offsetDirection = this.option("rtlEnabled") ? -1 : 1;
                    var newRatio = this._startOffset + offsetDirection * e.jQueryEvent.offset / this._swipePixelRatio();
                    this._$range.width(newRatio * 100 + "%");
                    SliderHandle.getInstance(this._activeHandle())["fitTooltipPosition"];
                    this._changeValueOnSwipe(newRatio)
                },
                _swipePixelRatio: function() {
                    var min = this.option("min"),
                        max = this.option("max"),
                        step = this._valueStep(this.option("step"));
                    return (max - min) / step
                },
                _valueStep: function(step) {
                    if (!step || isNaN(step))
                        step = 1;
                    step = parseFloat(step.toFixed(5));
                    if (step === 0)
                        step = 0.00001;
                    return step
                },
                _changeValueOnSwipe: function(ratio) {
                    var min = this.option("min"),
                        max = this.option("max"),
                        step = this._valueStep(this.option("step")),
                        newChange = ratio * (max - min),
                        newValue = min + newChange;
                    if (step < 0)
                        return;
                    if (newValue === max || newValue === min)
                        this.option("value", newValue);
                    else {
                        var stepExponent = (step + "").split(".")[1];
                        var minExponent = (min + "").split(".")[1];
                        var exponentLength = Math.max(stepExponent && stepExponent.length || 0, minExponent && minExponent.length || 0);
                        var stepCount = Math.round((newValue - min) / step);
                        newValue = Number((stepCount * step + min).toFixed(exponentLength));
                        this.option("value", Math.max(Math.min(newValue, max), min))
                    }
                },
                _startHandler: function(args) {
                    var e = args.jQueryEvent;
                    this._currentRatio = (eventUtils.eventData(e).x - this._$bar.offset().left) / this._$bar.width();
                    if (this.option("rtlEnabled"))
                        this._currentRatio = 1 - this._currentRatio;
                    this._saveValueChangeEvent(e);
                    this._changeValueOnSwipe(this._currentRatio)
                },
                _renderValue: function() {
                    this.callBase();
                    var value = this.option("value");
                    SliderHandle.getInstance(this._activeHandle()).option("value", value)
                },
                _setRangeStyles: function(options) {
                    this._$range.css(options)
                },
                _callHandlerMethod: function(name, args) {
                    SliderHandle.getInstance(this._$handle)[name](args)
                },
                _repaintHandle: function() {
                    this._callHandlerMethod("repaint")
                },
                _fitTooltip: function() {
                    this._callHandlerMethod("fitTooltipPosition")
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"visible":
                            this.callBase(args);
                            this._renderHandle();
                            this._repaintHandle();
                            domUtils.triggerShownEvent(this.element());
                            break;
                        case"min":
                        case"max":
                            this._renderLabels();
                            this._renderAriaMinAndMax();
                            this.callBase(args);
                            this._fitTooltip();
                            break;
                        case"step":
                            this._renderValue();
                            break;
                        case"keyStep":
                            break;
                        case"showRange":
                            this._renderRangeVisibility();
                            break;
                        case"tooltip":
                            this._renderHandle();
                            break;
                        case"label":
                            this._renderLabels();
                            break;
                        case"rtlEnabled":
                            this._toggleRTLDirection();
                            this._renderValue();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _refresh: function() {
                    this._renderDimensions();
                    this._renderValue();
                    this._renderHandle();
                    this._repaintHandle()
                }
            });
        registerComponent("dxSlider", uiNamespace, Slider);
        return Slider
    });
    DevExpress.require(["/ui/widgets/track/ui.slider"]);
    /*! Module widgets-base, file ui.rangeSlider.js */
    DevExpress.define("/ui/widgets/track/ui.rangeSlider", ["jquery", "/utils/utils.string", "/ui/widgets/track/ui.sliderHandle", "/ui/widgets/track/ui.slider", "/componentRegistrator", "/ui/uiNamespace", "/ui/events/ui.events.utils"], function($, stringUtils, SliderHandle, Slider, registerComponent, uiNamespace, eventUtils) {
        var RANGE_SLIDER_CLASS = "dx-rangeslider",
            RANGE_SLIDER_START_HANDLE_CLASS = RANGE_SLIDER_CLASS + "-start-handle",
            RANGE_SLIDER_END_HANDLE_CLASS = RANGE_SLIDER_CLASS + "-end-handle";
        var RangeSlider = Slider.inherit({
                _supportedKeys: function() {
                    var isRTL = this.option("rtlEnabled");
                    var that = this,
                        _changeHandle = function(e, capturedHandle) {
                            if (that.option("start") === that.option("end")) {
                                that._capturedHandle = capturedHandle;
                                e.target = that._capturedHandle;
                                that._capturedHandle.focus()
                            }
                        },
                        _setHandleValue = function(e, step, sign) {
                            var isStart = $(e.target).hasClass(RANGE_SLIDER_START_HANDLE_CLASS),
                                valueOption = isStart ? "start" : "end",
                                val = that.option(valueOption);
                            step = that._valueStep(step);
                            val += sign * (isRTL ? -step : step);
                            that.option(valueOption, val)
                        },
                        moveHandleRight = function(e, step) {
                            _changeHandle(e, isRTL ? that._$handleStart : that._$handleEnd);
                            _setHandleValue(e, step, 1)
                        },
                        moveHandleLeft = function(e, step) {
                            _changeHandle(e, isRTL ? that._$handleEnd : that._$handleStart);
                            _setHandleValue(e, step, -1)
                        };
                    return $.extend(this.callBase(), {
                            leftArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                moveHandleLeft(e, this.option("step"))
                            },
                            rightArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                moveHandleRight(e, this.option("step"))
                            },
                            pageUp: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                moveHandleRight(e, this.option("step") * this.option("keyStep"))
                            },
                            pageDown: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                moveHandleLeft(e, this.option("step") * this.option("keyStep"))
                            },
                            home: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                var isStart = $(e.target).hasClass(RANGE_SLIDER_START_HANDLE_CLASS),
                                    valueOption = isStart ? "start" : "end",
                                    startOption = isStart ? "min" : "start",
                                    val = this.option(startOption);
                                this.option(valueOption, val)
                            },
                            end: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                var isStart = $(e.target).hasClass(RANGE_SLIDER_START_HANDLE_CLASS),
                                    valueOption = isStart ? "start" : "end",
                                    endOption = isStart ? "end" : "max",
                                    val = this.option(endOption);
                                this.option(valueOption, val)
                            }
                        })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            start: 40,
                            end: 60
                        })
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(RANGE_SLIDER_CLASS);
                    this._callHandlerMethod("repaint")
                },
                _renderHandle: function() {
                    this._$handleStart = this._renderHandleImpl(this.option("start"), this._$handleStart).addClass(RANGE_SLIDER_START_HANDLE_CLASS);
                    this._$handleEnd = this._renderHandleImpl(this.option("end"), this._$handleEnd).addClass(RANGE_SLIDER_END_HANDLE_CLASS);
                    this._updateHandleAriaLabels()
                },
                _startHandler: function(args) {
                    var e = args.jQueryEvent,
                        $range = this._$range,
                        rangeWidth = $range.width(),
                        eventOffsetX = eventUtils.eventData(e).x - this._$bar.offset().left,
                        startHandleX = $range.position().left,
                        endHandleX = $range.position().left + rangeWidth,
                        rtlEnabled = this.option("rtlEnabled"),
                        startHandleIsClosest = (rtlEnabled ? -1 : 1) * ((startHandleX + endHandleX) / 2 - eventOffsetX) > 0;
                    this._capturedHandle = startHandleIsClosest ? this._$handleStart : this._$handleEnd;
                    this.callBase(args)
                },
                _updateHandleAriaLabels: function() {
                    this.setAria("label", stringUtils.format(Globalize.localize("dxRangeSlider-ariaFrom"), this.option("start")), this._$handleStart);
                    this.setAria("label", stringUtils.format(Globalize.localize("dxRangeSlider-ariaTill"), this.option("end")), this._$handleEnd)
                },
                _activeHandle: function() {
                    return this._capturedHandle
                },
                _updateHandlePosition: function(e) {
                    var rtlEnabled = this.option("rtlEnabled"),
                        offsetDirection = rtlEnabled ? -1 : 1,
                        max = this.option("max"),
                        min = this.option("min");
                    var newRatio = this._startOffset + offsetDirection * e.jQueryEvent.offset / this._swipePixelRatio();
                    newRatio = newRatio.toPrecision(12);
                    var newValue = newRatio * (max - min) + min;
                    this._updateSelectedRangePosition(newRatio, newRatio);
                    SliderHandle.getInstance(this._activeHandle())["fitTooltipPosition"];
                    this._changeValueOnSwipe(newRatio);
                    var startValue = this.option("start"),
                        endValue = this.option("end"),
                        $nextHandle;
                    if (startValue === endValue) {
                        if (newValue < startValue)
                            $nextHandle = this._$handleStart;
                        else
                            $nextHandle = this._$handleEnd;
                        $nextHandle.focus();
                        if ($nextHandle && $nextHandle !== this._capturedHandle) {
                            this._updateSelectedRangePosition((startValue - min) / (max - min), (endValue - min) / (max - min));
                            this._toggleActiveState(this._activeHandle(), false);
                            this._toggleActiveState($nextHandle, true);
                            this._capturedHandle = $nextHandle
                        }
                        this._updateSelectedRangePosition(newRatio, newRatio);
                        this._changeValueOnSwipe(newRatio)
                    }
                },
                _updateSelectedRangePosition: function(leftRatio, rightRatio) {
                    var rtlEnabled = this.option("rtlEnabled"),
                        moveRight = this._capturedHandle === this._$handleStart && rtlEnabled || this._capturedHandle === this._$handleEnd && !rtlEnabled;
                    var prop = moveRight ? "right" : "left";
                    if (rtlEnabled ^ moveRight)
                        this._$range.css(prop, 100 - rightRatio * 100 + "%");
                    else
                        this._$range.css(prop, leftRatio * 100 + "%")
                },
                _changeValueOnSwipe: function(ratio) {
                    this._suppressValueChangeAction();
                    this.callBase(ratio);
                    this._resumeValueChangeAction();
                    var option = this._capturedHandle === this._$handleStart ? "start" : "end",
                        start = this.option("start"),
                        end = this.option("end"),
                        newValue = this.option("value"),
                        max = this.option("max"),
                        min = this.option("min");
                    if (start > max) {
                        start = max;
                        this.option("start", max)
                    }
                    if (start < min) {
                        start = min;
                        this.option("start", min)
                    }
                    if (end > max) {
                        end = max;
                        this.option("end", max)
                    }
                    if (newValue > end && option === "start")
                        newValue = end;
                    if (newValue < start && option === "end")
                        newValue = start;
                    this.option(option, newValue)
                },
                _renderValue: function() {
                    var valStart = this.option("start"),
                        valEnd = this.option("end"),
                        min = this.option("min"),
                        max = this.option("max"),
                        rtlEnabled = this.option("rtlEnabled");
                    valStart = Math.max(min, Math.min(valStart, max));
                    valEnd = Math.max(valStart, Math.min(valEnd, max));
                    this.option("start", valStart);
                    this.option("end", valEnd);
                    var ratio1 = max === min ? 0 : (valStart - min) / (max - min),
                        ratio2 = max === min ? 0 : (valEnd - min) / (max - min);
                    var startOffset = parseFloat((ratio1 * 100).toPrecision(12)) + "%",
                        endOffset = parseFloat(((1 - ratio2) * 100).toPrecision(12)) + "%";
                    !this._needPreventAnimation && this._setRangeStyles({
                        right: rtlEnabled ? startOffset : endOffset,
                        left: rtlEnabled ? endOffset : startOffset
                    });
                    SliderHandle.getInstance(this._$handleStart).option("value", valStart);
                    SliderHandle.getInstance(this._$handleEnd).option("value", valEnd)
                },
                _callHandlerMethod: function(name, args) {
                    SliderHandle.getInstance(this._$handleStart)[name](args);
                    SliderHandle.getInstance(this._$handleEnd)[name](args)
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"start":
                        case"end":
                            this._renderValue();
                            this._createActionByOption("onValueChanged", {excludeValidators: ["disabled", "readOnly"]})({
                                start: this.option("start"),
                                end: this.option("end"),
                                jQueryEvent: this._valueChangeEventInstance
                            });
                            this._saveValueChangeEvent(undefined);
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        registerComponent("dxRangeSlider", uiNamespace, RangeSlider);
        return RangeSlider
    });
    DevExpress.require(["/ui/widgets/track/ui.rangeSlider"]);
    /*! Module widgets-base, file ui.gallery.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx,
            translator = DX.require("/utils/utils.translator"),
            commonUtils = DX.require("/utils/utils.common"),
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            GALLERY_CLASS = "dx-gallery",
            GALLERY_WRAPPER_CLASS = GALLERY_CLASS + "-wrapper",
            GALLERY_LOOP_CLASS = "dx-gallery-loop",
            GALLERY_ITEM_CONTAINER_CLASS = GALLERY_CLASS + "-container",
            GALLERY_ACTIVE_CLASS = GALLERY_CLASS + "-active",
            GALLERY_ITEM_CLASS = GALLERY_CLASS + "-item",
            GALLERY_LOOP_ITEM_CLASS = GALLERY_ITEM_CLASS + "-loop",
            GALLERY_ITEM_SELECTOR = "." + GALLERY_ITEM_CLASS,
            GALLERY_ITEM_SELECTED_CLASS = GALLERY_ITEM_CLASS + "-selected",
            GALLERY_INDICATOR_CLASS = GALLERY_CLASS + "-indicator",
            GALLERY_INDICATOR_ITEM_CLASS = GALLERY_INDICATOR_CLASS + "-item",
            GALLERY_INDICATOR_ITEM_SELECTOR = "." + GALLERY_INDICATOR_ITEM_CLASS,
            GALLERY_INDICATOR_ITEM_SELECTED_CLASS = GALLERY_INDICATOR_ITEM_CLASS + "-selected",
            GALLERY_ITEM_DATA_KEY = "dxGalleryItemData";
        var GalleryNavButton = Widget.inherit({
                _supportedKeys: function() {
                    return $.extend(this.callBase(), {
                            pageUp: $.noop,
                            pageDown: $.noop
                        })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            direction: "next",
                            onClick: null,
                            hoverStateEnabled: true,
                            activeStateEnabled: true
                        })
                },
                _render: function() {
                    this.callBase();
                    var that = this,
                        $element = this.element(),
                        eventName = eventUtils.addNamespace("dxclick", this.NAME);
                    $element.addClass(GALLERY_CLASS + "-nav-button-" + this.option("direction")).off(eventName).on(eventName, function(e) {
                        that._createActionByOption("onClick")({jQueryEvent: e})
                    })
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"onClick":
                        case"direction":
                            this._invalidate();
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        GalleryNavButton.publicName("dxGalleryNavButton");
        registerComponent("dxGallery", ui, ui.CollectionWidget.inherit({
            _activeStateUnit: GALLERY_ITEM_SELECTOR,
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        activeStateEnabled: false,
                        animationDuration: 400,
                        animationEnabled: true,
                        loop: false,
                        swipeEnabled: true,
                        indicatorEnabled: true,
                        showIndicator: true,
                        selectedIndex: 0,
                        slideshowDelay: 0,
                        showNavButtons: false,
                        wrapAround: false,
                        initialItemWidth: undefined,
                        stretchImages: false,
                        _itemAttributes: {role: "option"},
                        loopItemFocus: false,
                        selectOnFocus: true,
                        selectionMode: "single",
                        selectionRequired: true,
                        selectionByClick: false
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return devices.real().generic && !devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _init: function() {
                this.callBase();
                this.option("loopItemFocus", this.option("loop"))
            },
            _dataSourceOptions: function() {
                return {paginate: false}
            },
            _itemContainer: function() {
                return this._$container
            },
            _itemClass: function() {
                return GALLERY_ITEM_CLASS
            },
            _itemDataKey: function() {
                return GALLERY_ITEM_DATA_KEY
            },
            _actualItemWidth: function() {
                var itemPerPage = this.option("wrapAround") ? this._itemsPerPage() + 1 : this._itemsPerPage();
                if (this.option("stretchImages"))
                    return 1 / itemPerPage;
                if (this.option("wrapAround"))
                    return this._itemPercentWidth() * this._itemsPerPage() / (this._itemsPerPage() + 1);
                return this._itemPercentWidth()
            },
            _itemPercentWidth: function() {
                var percentWidth;
                if (this.option("initialItemWidth"))
                    percentWidth = this.option("initialItemWidth") / this.element().outerWidth();
                else
                    percentWidth = 1;
                return percentWidth
            },
            _itemsPerPage: function() {
                var itemsPerPage = Math.floor(1 / this._itemPercentWidth());
                return Math.min(itemsPerPage, this._itemsCount())
            },
            _pagesCount: function() {
                return Math.ceil(this._itemsCount() / this._itemsPerPage())
            },
            _itemsCount: function() {
                return (this.option("items") || []).length
            },
            _offsetDirection: function() {
                return this.option("rtlEnabled") ? -1 : 1
            },
            _render: function() {
                this.element().addClass(GALLERY_CLASS);
                this.element().toggleClass(GALLERY_LOOP_CLASS, this.option("loop"));
                this._renderDragHandler();
                this._renderWrapper();
                this._renderItemsContainer();
                this.callBase();
                this._renderContainerPosition();
                this._renderItemSizes();
                this._renderItemPositions();
                this._renderNavButtons();
                this._renderIndicator();
                this._renderSelectedItem();
                this._renderUserInteraction();
                this._setupSlideShow();
                this._reviseDimensions();
                this.setAria({
                    role: "listbox",
                    label: "gallery"
                })
            },
            _dimensionChanged: function() {
                var selectedIndex = this.option("selectedIndex") || 0;
                this._clearCacheWidth();
                this._renderDuplicateItems();
                this._renderItemSizes();
                this._renderItemPositions();
                this._renderIndicator();
                this._renderContainerPosition(this._calculateIndexOffset(selectedIndex))
            },
            _renderDragHandler: function() {
                var eventName = eventUtils.addNamespace("dragstart", this.NAME);
                this.element().off(eventName).on(eventName, "img", function() {
                    return false
                })
            },
            _renderWrapper: function() {
                if (this._$wrapper)
                    return;
                this._$wrapper = $("<div />").addClass(GALLERY_WRAPPER_CLASS).appendTo(this.element())
            },
            _renderItems: function(items) {
                this.callBase(items);
                this._loadNextPageIfNeeded()
            },
            _renderItemsContainer: function() {
                if (this._$container)
                    return;
                this._$container = $("<div>").addClass(GALLERY_ITEM_CONTAINER_CLASS).appendTo(this._$wrapper)
            },
            _renderDuplicateItems: function() {
                if (!this.option("loop"))
                    return;
                var items = this.option("items") || [],
                    itemsCount = items.length,
                    lastItemIndex = itemsCount - 1,
                    i;
                if (!itemsCount)
                    return;
                this.element().find("." + GALLERY_LOOP_ITEM_CLASS).remove();
                var duplicateCount = Math.min(this._itemsPerPage(), itemsCount);
                for (i = 0; i < duplicateCount; i++)
                    this._renderItem(0, items[i]).addClass(GALLERY_LOOP_ITEM_CLASS);
                for (i = 0; i < duplicateCount; i++)
                    this._renderItem(0, items[lastItemIndex - i]).addClass(GALLERY_LOOP_ITEM_CLASS)
            },
            _renderItemSizes: function(startIndex) {
                var $items = this._itemElements(),
                    itemWidth = this._actualItemWidth();
                if (startIndex !== undefined)
                    $items = $items.slice(startIndex);
                $items.each(function(index) {
                    $($items[index]).outerWidth(itemWidth * 100 + "%")
                })
            },
            _renderItemPositions: function() {
                var itemWidth = this._actualItemWidth(),
                    itemsCount = this._itemsCount(),
                    itemsPerPage = this._itemsPerPage(),
                    loopItemsCount = this.element().find("." + GALLERY_LOOP_ITEM_CLASS).length,
                    lastItemDuplicateIndex = itemsCount + loopItemsCount - 1,
                    offsetRatio = this.option("wrapAround") ? 0.5 : 0,
                    freeSpace = this._itemFreeSpace(),
                    rtlEnabled = this.option("rtlEnabled");
                this._itemElements().each(function(index) {
                    var realIndex = index;
                    if (index > itemsCount + itemsPerPage - 1)
                        realIndex = lastItemDuplicateIndex - realIndex - itemsPerPage;
                    var itemPosition = itemWidth * (realIndex + offsetRatio) + freeSpace * (realIndex + 1 - offsetRatio);
                    $(this).css(rtlEnabled ? "right" : "left", itemPosition * 100 + "%")
                });
                this._relocateItems(this.option("selectedIndex"), this.option("selectedIndex"), true)
            },
            _itemFreeSpace: function() {
                var itemsPerPage = this._itemsPerPage();
                if (this.option("wrapAround"))
                    itemsPerPage = itemsPerPage + 1;
                return (1 - this._actualItemWidth() * itemsPerPage) / (itemsPerPage + 1)
            },
            _renderContainerPosition: function(offset, animate) {
                offset = offset || 0;
                var that = this,
                    itemWidth = this._actualItemWidth(),
                    targetIndex = offset,
                    targetPosition = this._offsetDirection() * targetIndex * (itemWidth + this._itemFreeSpace()),
                    positionReady;
                if (commonUtils.isDefined(this._animationOverride)) {
                    animate = this._animationOverride;
                    delete this._animationOverride
                }
                if (animate) {
                    that._startSwipe();
                    positionReady = that._animate(targetPosition).done($.proxy(that._endSwipe, that))
                }
                else {
                    translator.move(this._$container, {left: targetPosition * this._elementWidth()});
                    positionReady = $.Deferred().resolveWith(that)
                }
                if (this._deferredAnimate)
                    positionReady.done(function() {
                        that._deferredAnimate.resolveWith(that)
                    });
                return positionReady.promise()
            },
            _startSwipe: function() {
                this.element().addClass(GALLERY_ACTIVE_CLASS)
            },
            _endSwipe: function() {
                this.element().removeClass(GALLERY_ACTIVE_CLASS)
            },
            _animate: function(targetPosition, extraConfig) {
                var that = this,
                    $container = this._$container,
                    animationComplete = $.Deferred();
                fx.animate(this._$container, $.extend({
                    type: "slide",
                    to: {left: targetPosition * this._elementWidth()},
                    duration: that.option("animationDuration"),
                    complete: function() {
                        if (that._needMoveContainerForward())
                            translator.move($container, {left: 0});
                        if (that._needMoveContainerBack())
                            translator.move($container, {left: that._maxContainerOffset() * that._elementWidth()});
                        animationComplete.resolveWith(that)
                    }
                }, extraConfig || {}));
                return animationComplete
            },
            _needMoveContainerForward: function() {
                return this._$container.position().left * this._offsetDirection() <= -this._maxItemWidth() * this._elementWidth() * this._itemsCount()
            },
            _needMoveContainerBack: function() {
                return this._$container.position().left * this._offsetDirection() >= this._actualItemWidth() * this._elementWidth()
            },
            _maxContainerOffset: function() {
                return -this._maxItemWidth() * (this._itemsCount() - this._itemsPerPage()) * this._offsetDirection()
            },
            _maxItemWidth: function() {
                return this._actualItemWidth() + this._itemFreeSpace()
            },
            _reviseDimensions: function() {
                var that = this,
                    $firstItem = that._itemElements().first().find(".dx-item-content");
                if (!$firstItem || $firstItem.is(":hidden"))
                    return;
                if (!that.option("height"))
                    that.option("height", $firstItem.outerHeight());
                if (!that.option("width"))
                    that.option("width", $firstItem.outerWidth());
                this._dimensionChanged()
            },
            _renderIndicator: function() {
                this._cleanIndicators();
                if (!this.option("showIndicator"))
                    return;
                var indicator = this._$indicator = $("<div>").addClass(GALLERY_INDICATOR_CLASS).appendTo(this._$wrapper);
                for (var i = 0; i < this._pagesCount(); i++)
                    $("<div>").addClass(GALLERY_INDICATOR_ITEM_CLASS).appendTo(indicator);
                this._renderSelectedPageIndicator()
            },
            _cleanIndicators: function() {
                if (this._$indicator)
                    this._$indicator.remove()
            },
            _renderSelectedItem: function() {
                var selectedIndex = this.option("selectedIndex");
                this._itemElements().removeClass(GALLERY_ITEM_SELECTED_CLASS).eq(selectedIndex).addClass(GALLERY_ITEM_SELECTED_CLASS)
            },
            _renderSelectedPageIndicator: function() {
                if (!this._$indicator)
                    return;
                var itemIndex = this.option("selectedIndex"),
                    lastIndex = this._pagesCount() - 1,
                    pageIndex = Math.ceil(itemIndex / this._itemsPerPage());
                pageIndex = Math.min(lastIndex, pageIndex);
                this._$indicator.find(GALLERY_INDICATOR_ITEM_SELECTOR).removeClass(GALLERY_INDICATOR_ITEM_SELECTED_CLASS).eq(pageIndex).addClass(GALLERY_INDICATOR_ITEM_SELECTED_CLASS)
            },
            _renderUserInteraction: function() {
                var rootElement = this.element(),
                    swipeEnabled = this.option("swipeEnabled") && this._itemsCount() > 1;
                this._createComponent(rootElement, "dxSwipeable", {
                    disabled: this.option("disabled") || !swipeEnabled,
                    onStart: $.proxy(this._swipeStartHandler, this),
                    onUpdated: $.proxy(this._swipeUpdateHandler, this),
                    onEnd: $.proxy(this._swipeEndHandler, this),
                    itemSizeFunc: $.proxy(this._elementWidth, this)
                });
                var indicatorSelectAction = this._createAction(this._indicatorSelectHandler);
                rootElement.off(eventUtils.addNamespace("dxclick", this.NAME), GALLERY_INDICATOR_ITEM_SELECTOR).on(eventUtils.addNamespace("dxclick", this.NAME), GALLERY_INDICATOR_ITEM_SELECTOR, function(e) {
                    indicatorSelectAction({jQueryEvent: e})
                })
            },
            _indicatorSelectHandler: function(args) {
                var e = args.jQueryEvent,
                    instance = args.component;
                if (!instance.option("indicatorEnabled"))
                    return;
                var indicatorIndex = $(e.target).index(),
                    itemIndex = instance._fitPaginatedIndex(indicatorIndex * instance._itemsPerPage());
                instance._needLongMove = true;
                instance.option("selectedIndex", itemIndex);
                instance._loadNextPageIfNeeded(itemIndex)
            },
            _renderNavButtons: function() {
                var that = this;
                if (!that.option("showNavButtons")) {
                    that._cleanNavButtons();
                    return
                }
                that._prevNavButton = $("<div>").appendTo(this._$wrapper);
                that._createComponent(that._prevNavButton, GalleryNavButton, {
                    direction: "prev",
                    onClick: function() {
                        that._prevPage()
                    }
                });
                that._nextNavButton = $("<div>").appendTo(this._$wrapper);
                that._createComponent(that._nextNavButton, GalleryNavButton, {
                    direction: "next",
                    onClick: function() {
                        that._nextPage()
                    }
                });
                this._renderNavButtonsVisibility()
            },
            _prevPage: function() {
                var visiblePageSize = this._itemsPerPage(),
                    newSelectedIndex = this.option("selectedIndex") - visiblePageSize;
                if (newSelectedIndex === -visiblePageSize && visiblePageSize === this._itemsCount())
                    return this._relocateItems(newSelectedIndex, 0);
                else
                    return this.goToItem(this._fitPaginatedIndex(newSelectedIndex))
            },
            _nextPage: function() {
                var visiblePageSize = this._itemsPerPage(),
                    newSelectedIndex = this.option("selectedIndex") + visiblePageSize;
                if (newSelectedIndex === visiblePageSize && visiblePageSize === this._itemsCount())
                    return this._relocateItems(newSelectedIndex, 0);
                else
                    return this.goToItem(this._fitPaginatedIndex(newSelectedIndex)).done(this._loadNextPageIfNeeded)
            },
            _loadNextPageIfNeeded: function(selectedIndex) {
                selectedIndex = selectedIndex === undefined ? this.option("selectedIndex") : selectedIndex;
                if (this._dataSource && this._dataSource.paginate() && this._shouldLoadNextPage(selectedIndex) && !this._isDataSourceLoading() && !this._isLastPage())
                    this._loadNextPage().done($.proxy(function() {
                        this._renderIndicator();
                        this._renderItemPositions();
                        this._renderNavButtonsVisibility();
                        this._renderItemSizes(selectedIndex)
                    }, this))
            },
            _shouldLoadNextPage: function(selectedIndex) {
                var visiblePageSize = this._itemsPerPage();
                return selectedIndex + 2 * visiblePageSize > this.option("items").length
            },
            _allowDinamicItemsAppend: function() {
                return true
            },
            _fitPaginatedIndex: function(itemIndex) {
                var itemsPerPage = this._itemsPerPage();
                var restItemsCount = itemIndex < 0 ? itemsPerPage + itemIndex : this._itemsCount() - itemIndex;
                if (itemIndex > this._itemsCount() - 1) {
                    itemIndex = 0;
                    this._goToGhostItem = true
                }
                else if (restItemsCount < itemsPerPage && restItemsCount > 0)
                    if (itemIndex > 0)
                        itemIndex = itemIndex - (itemsPerPage - restItemsCount);
                    else
                        itemIndex = itemIndex + (itemsPerPage - restItemsCount);
                return itemIndex
            },
            _cleanNavButtons: function() {
                if (this._prevNavButton) {
                    this._prevNavButton.remove();
                    delete this._prevNavButton
                }
                if (this._nextNavButton) {
                    this._nextNavButton.remove();
                    delete this._nextNavButton
                }
            },
            _renderNavButtonsVisibility: function() {
                if (!this.option("showNavButtons") || !this._prevNavButton || !this._nextNavButton)
                    return;
                var selectedIndex = this.option("selectedIndex"),
                    loop = this.option("loop"),
                    itemsCount = this._itemsCount();
                this._prevNavButton.show();
                this._nextNavButton.show();
                if (loop)
                    return;
                var nextHidden = selectedIndex === itemsCount - this._itemsPerPage(),
                    prevHidden = itemsCount < 2 || selectedIndex === 0;
                if (this._dataSource && this._dataSource.paginate())
                    nextHidden = nextHidden && this._isLastPage();
                else
                    nextHidden = nextHidden || itemsCount < 2;
                if (prevHidden)
                    this._prevNavButton.hide();
                if (nextHidden)
                    this._nextNavButton.hide()
            },
            _setupSlideShow: function() {
                var that = this,
                    slideshowDelay = that.option("slideshowDelay");
                clearTimeout(that._slideshowTimer);
                if (!slideshowDelay)
                    return;
                that._slideshowTimer = setTimeout(function() {
                    if (that._userInteraction) {
                        that._setupSlideShow();
                        return
                    }
                    that.nextItem(true).done(that._setupSlideShow)
                }, slideshowDelay)
            },
            _elementWidth: function() {
                if (!this._cacheElementWidth)
                    this._cacheElementWidth = this.element().width();
                return this._cacheElementWidth
            },
            _clearCacheWidth: function() {
                delete this._cacheElementWidth
            },
            _swipeStartHandler: function(e) {
                this._clearCacheWidth();
                this._elementWidth();
                var itemsCount = this._itemsCount();
                if (!itemsCount) {
                    e.jQueryEvent.cancel = true;
                    return
                }
                this._stopItemAnimations();
                this._startSwipe();
                this._userInteraction = true;
                if (!this.option("loop")) {
                    var selectedIndex = this.option("selectedIndex"),
                        startOffset = itemsCount - selectedIndex - this._itemsPerPage(),
                        endOffset = selectedIndex,
                        rtlEnabled = this.option("rtlEnabled");
                    e.jQueryEvent.maxLeftOffset = rtlEnabled ? endOffset : startOffset;
                    e.jQueryEvent.maxRightOffset = rtlEnabled ? startOffset : endOffset
                }
            },
            _stopItemAnimations: function() {
                fx.stop(this._$container, true)
            },
            _swipeUpdateHandler: function(e) {
                var wrapAroundRatio = this.option("wrapAround") ? 1 : 0;
                var offset = this._offsetDirection() * e.jQueryEvent.offset * (this._itemsPerPage() + wrapAroundRatio) - this.option("selectedIndex");
                if (offset < 0)
                    this._loadNextPageIfNeeded(Math.ceil(Math.abs(offset)));
                this._renderContainerPosition(offset)
            },
            _swipeEndHandler: function(e) {
                var targetOffset = e.jQueryEvent.targetOffset * this._offsetDirection() * this._itemsPerPage(),
                    selectedIndex = this.option("selectedIndex"),
                    newIndex = this._fitIndex(selectedIndex - targetOffset),
                    paginatedIndex = this._fitPaginatedIndex(newIndex);
                if (Math.abs(targetOffset) < this._itemsPerPage()) {
                    this._relocateItems(selectedIndex);
                    return
                }
                if (this._itemsPerPage() === this._itemsCount()) {
                    if (targetOffset > 0)
                        this._relocateItems(-targetOffset);
                    else
                        this._relocateItems(0);
                    return
                }
                this.option("selectedIndex", paginatedIndex)
            },
            _setFocusOnSelect: function() {
                this._userInteraction = true;
                var selectedItem = this.itemElements().filter("." + GALLERY_ITEM_SELECTED_CLASS);
                this.option("focusedElement", selectedItem);
                this._userInteraction = false
            },
            _flipIndex: function(index) {
                var itemsCount = this._itemsCount();
                index = index % itemsCount;
                if (index > (itemsCount + 1) / 2)
                    index -= itemsCount;
                if (index < -(itemsCount - 1) / 2)
                    index += itemsCount;
                return index
            },
            _fitIndex: function(index) {
                if (!this.option("loop"))
                    return index;
                var itemsCount = this._itemsCount();
                if (index >= itemsCount || index < 0)
                    this._goToGhostItem = true;
                if (index >= itemsCount)
                    index = itemsCount - index;
                index = index % itemsCount;
                if (index < 0)
                    index += itemsCount;
                return index
            },
            _clean: function() {
                this.callBase();
                this._cleanIndicators();
                this._cleanNavButtons()
            },
            _dispose: function() {
                clearTimeout(this._slideshowTimer);
                this.callBase()
            },
            _updateSelection: function(addedSelection, removedSelection) {
                this._stopItemAnimations();
                this._renderNavButtonsVisibility();
                this._renderSelectedItem();
                this._relocateItems(addedSelection[0], removedSelection[0]);
                this._renderSelectedPageIndicator()
            },
            _relocateItems: function(newIndex, prevIndex, withoutAnimation) {
                if (prevIndex === undefined)
                    prevIndex = newIndex;
                var indexOffset = this._calculateIndexOffset(newIndex, prevIndex);
                this._renderContainerPosition(indexOffset, this.option("animationEnabled") && !withoutAnimation).done(function() {
                    this._setFocusOnSelect();
                    this._userInteraction = false;
                    this._setupSlideShow()
                })
            },
            _focusInHandler: function(e) {
                if (fx.isAnimating(this._$container) || this._userInteraction)
                    return;
                this.callBase.apply(this, arguments)
            },
            _focusOutHandler: function(e) {
                if (fx.isAnimating(this._$container) || this._userInteraction)
                    return;
                this.callBase.apply(this, arguments)
            },
            _selectFocusedItem: $.noop,
            _moveFocus: function(location) {
                this._stopItemAnimations();
                this.callBase.apply(this, arguments);
                var index = this.itemElements().index(this.option("focusedElement"));
                this.goToItem(index, this.option("animationEnabled"))
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._reviseDimensions()
            },
            _calculateIndexOffset: function(newIndex, lastIndex) {
                if (lastIndex === undefined)
                    lastIndex = newIndex;
                var indexOffset = lastIndex - newIndex;
                if (this.option("loop") && !this._needLongMove && this._goToGhostItem) {
                    if (this._isItemOnFirstPage(newIndex) && this._isItemOnLastPage(lastIndex))
                        indexOffset = -this._itemsPerPage();
                    else if (this._isItemOnLastPage(newIndex) && this._isItemOnFirstPage(lastIndex))
                        indexOffset = this._itemsPerPage();
                    this._goToGhostItem = false
                }
                this._needLongMove = false;
                indexOffset = indexOffset - lastIndex;
                return indexOffset
            },
            _isItemOnLastPage: function(itemIndex) {
                return itemIndex >= this._itemsCount() - this._itemsPerPage()
            },
            _isItemOnFirstPage: function(itemIndex) {
                return itemIndex <= this._itemsPerPage()
            },
            _optionChanged: function(args) {
                var value = args.value;
                switch (args.name) {
                    case"width":
                    case"initialItemWidth":
                        this.callBase.apply(this, arguments);
                        this._dimensionChanged();
                        break;
                    case"animationDuration":
                        this._renderNavButtonsVisibility();
                        break;
                    case"animationEnabled":
                        break;
                    case"loop":
                        this.option("loopItemFocus", value);
                        this.element().toggleClass(GALLERY_LOOP_CLASS, value);
                        this._renderDuplicateItems();
                        this._renderItemPositions();
                        this._renderNavButtonsVisibility();
                        return;
                    case"showIndicator":
                        this._renderIndicator();
                        return;
                    case"showNavButtons":
                        this._renderNavButtons();
                        return;
                    case"slideshowDelay":
                        this._setupSlideShow();
                        return;
                    case"wrapAround":
                    case"stretchImages":
                        this._renderItemSizes();
                        this._renderItemPositions();
                        break;
                    case"swipeEnabled":
                    case"indicatorEnabled":
                        this._renderUserInteraction();
                        return;
                    default:
                        this.callBase(args)
                }
            },
            goToItem: function(itemIndex, animation) {
                var selectedIndex = this.option("selectedIndex"),
                    itemsCount = this._itemsCount();
                if (animation !== undefined)
                    this._animationOverride = animation;
                itemIndex = this._fitIndex(itemIndex);
                this._deferredAnimate = $.Deferred();
                if (itemIndex > itemsCount - 1 || itemIndex < 0 || selectedIndex === itemIndex)
                    return this._deferredAnimate.resolveWith(this).promise();
                this.option("selectedIndex", itemIndex);
                return this._deferredAnimate.promise()
            },
            prevItem: function(animation) {
                return this.goToItem(this.option("selectedIndex") - 1, animation)
            },
            nextItem: function(animation) {
                return this.goToItem(this.option("selectedIndex") + 1, animation)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.overlay.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx,
            translator = DX.require("/utils/utils.translator"),
            compareVersions = DX.require("/utils/utils.version").compare,
            viewPortUtils = DX.require("/utils/utils.viewPort"),
            viewPort = viewPortUtils.value,
            viewPortChanged = viewPortUtils.changeCallback,
            hideTopOverlayCallback = DX.require("/utils/utils.topOverlay").hideCallback,
            positionUtils = DX.require("/utils/utils.position"),
            fitIntoRange = DX.require("/utils/utils.math").fitIntoRange,
            domUtils = DX.require("/utils/utils.dom"),
            commonUtils = DX.require("/utils/utils.common"),
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget"),
            KeyboardProcessor = DX.require("/ui/ui.keyboardProcessor"),
            selectors = DX.require("/integration/jquery/jquery.selectors"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer");
        var OVERLAY_CLASS = "dx-overlay",
            OVERLAY_WRAPPER_CLASS = "dx-overlay-wrapper",
            OVERLAY_CONTENT_CLASS = "dx-overlay-content",
            OVERLAY_SHADER_CLASS = "dx-overlay-shader",
            OVERLAY_MODAL_CLASS = "dx-overlay-modal",
            INVISIBLE_STATE_CLASS = "dx-state-invisible",
            ANONYMOUS_TEMPLATE_NAME = "content",
            RTL_DIRECTION_CLASS = "dx-rtl",
            ACTIONS = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioning", "onPositioned", "onResizeStart", "onResize", "onResizeEnd"],
            FIRST_Z_INDEX = 1000,
            Z_INDEX_STACK = [],
            DISABLED_STATE_CLASS = "dx-state-disabled",
            TAB_KEY = 9;
        var realDevice = devices.real(),
            realVersion = realDevice.version,
            iOS = realDevice.platform === "ios",
            iOS7_0andBelow = iOS && compareVersions(realVersion, [7, 1]) < 0,
            android4_0nativeBrowser = realDevice.platform === "android" && compareVersions(realVersion, [4, 0], 2) === 0 && navigator.userAgent.indexOf("Chrome") === -1;
        var forceRepaint = function($element) {
                if (iOS7_0andBelow)
                    $element.width();
                if (android4_0nativeBrowser) {
                    var $parents = $element.parents(),
                        inScrollView = $parents.is(".dx-scrollable-native");
                    if (!inScrollView) {
                        $parents.css("backface-visibility", "hidden");
                        $parents.css("backface-visibility");
                        $parents.css("backface-visibility", "visible")
                    }
                }
            };
        var getElement = function(value) {
                return value && $(value instanceof $.Event ? value.target : value)
            };
        registerComponent("dxOverlay", ui, Widget.inherit({
            _supportedKeys: function() {
                var offsetSize = 5,
                    move = function(top, left, e) {
                        if (!this.option("dragEnabled"))
                            return;
                        e.preventDefault();
                        e.stopPropagation();
                        var allowedOffsets = this._allowedOffsets();
                        var offset = {
                                top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),
                                left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)
                            };
                        this._changePosition(offset)
                    };
                return $.extend(this.callBase(), {
                        escape: function(e) {
                            this.hide()
                        },
                        upArrow: $.proxy(move, this, -offsetSize, 0),
                        downArrow: $.proxy(move, this, offsetSize, 0),
                        leftArrow: $.proxy(move, this, 0, -offsetSize),
                        rightArrow: $.proxy(move, this, 0, offsetSize)
                    })
            },
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        activeStateEnabled: false,
                        visible: false,
                        deferRendering: true,
                        shading: true,
                        shadingColor: "",
                        position: {
                            my: "center",
                            at: "center"
                        },
                        width: function() {
                            return $(window).width() * 0.8
                        },
                        minWidth: null,
                        maxWidth: null,
                        height: function() {
                            return $(window).height() * 0.8
                        },
                        minHeight: null,
                        maxHeight: null,
                        animation: {
                            show: {
                                type: "pop",
                                duration: 300,
                                from: {scale: 0.55}
                            },
                            hide: {
                                type: "pop",
                                duration: 300,
                                to: {
                                    opacity: 0,
                                    scale: 0.55
                                },
                                from: {
                                    opacity: 1,
                                    scale: 1
                                }
                            }
                        },
                        closeOnOutsideClick: false,
                        closeOnBackButton: true,
                        onShowing: null,
                        onShown: null,
                        onHiding: null,
                        onHidden: null,
                        contentTemplate: "content",
                        dragEnabled: false,
                        resizeEnabled: false,
                        onResizeStart: null,
                        onResize: null,
                        onResizeEnd: null,
                        target: undefined,
                        container: undefined,
                        hideTopOverlayHandler: undefined,
                        closeOnTargetScroll: false,
                        onPositioning: null,
                        onPositioned: null,
                        boundaryOffset: {
                            h: 0,
                            v: 0
                        }
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                var realDevice = devices.real(),
                                    realPlatform = realDevice.platform,
                                    realVersion = realDevice.version;
                                return realPlatform === "android" && compareVersions(realVersion, [4, 2]) < 0
                            },
                            options: {animation: {
                                    show: {
                                        type: "fade",
                                        duration: 400
                                    },
                                    hide: {
                                        type: "fade",
                                        duration: 400,
                                        to: {opacity: 0},
                                        from: {opacity: 1}
                                    }
                                }}
                        }])
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {animation: true})
            },
            _getAnonymousTemplateName: function() {
                return ANONYMOUS_TEMPLATE_NAME
            },
            _wrapper: function() {
                return this._$wrapper
            },
            _container: function() {
                return this._$content
            },
            _eventBindingTarget: function() {
                return this._$content
            },
            _init: function() {
                this.callBase();
                this._initActions();
                this._initCloseOnOutsideClickHandler();
                this._$wrapper = $("<div>").addClass(OVERLAY_WRAPPER_CLASS);
                this._$content = $("<div>").addClass(OVERLAY_CONTENT_CLASS);
                var $element = this.element();
                this._$wrapper.addClass($element.attr("class"));
                $element.addClass(OVERLAY_CLASS);
                this._$wrapper.attr("data-bind", "dxControlsDescendantBindings: true");
                this._$wrapper.on("MSPointerDown", $.noop);
                this._toggleViewPortSubscriptiion(true)
            },
            _initOptions: function(options) {
                this._initTarget(options.target);
                this._initContainer(options.container);
                this._initHideTopOverlayHandler(options.hideTopOverlayHandler);
                this.callBase(options)
            },
            _initTarget: function(target) {
                if (!commonUtils.isDefined(target))
                    return;
                var options = this.option();
                $.each(["position.of", "animation.show.from.position.of", "animation.show.to.position.of", "animation.hide.from.position.of", "animation.hide.to.position.of"], function(_, path) {
                    var pathParts = path.split(".");
                    var option = options;
                    while (option)
                        if (pathParts.length === 1) {
                            if ($.isPlainObject(option))
                                option[pathParts.shift()] = target;
                            break
                        }
                        else
                            option = option[pathParts.shift()]
                })
            },
            _initContainer: function(container) {
                container = container === undefined ? viewPort() : container;
                var $element = this.element(),
                    $container = $element.closest(container);
                if (!$container.length)
                    $container = $(container).first();
                this._$container = $container.length ? $container : $element.parent()
            },
            _initHideTopOverlayHandler: function(handler) {
                this._hideTopOverlayHandler = handler !== undefined ? handler : $.proxy(this._defaultHideTopOverlayHandler, this)
            },
            _defaultHideTopOverlayHandler: function() {
                this.hide()
            },
            _initActions: function() {
                this._actions = {};
                $.each(ACTIONS, $.proxy(function(_, action) {
                    this._actions[action] = this._createActionByOption(action, {excludeValidators: ["disabled", "readOnly"]}) || $.noop
                }, this))
            },
            _initCloseOnOutsideClickHandler: function() {
                this._proxiedDocumentDownHandler = $.proxy(function() {
                    this._documentDownHandler.apply(this, arguments)
                }, this)
            },
            _documentDownHandler: function(e) {
                if (!this._isTopOverlay())
                    return;
                if (this._showAnimationProcessing) {
                    this._stopAnimation();
                    return
                }
                var closeOnOutsideClick = this.option("closeOnOutsideClick");
                if ($.isFunction(closeOnOutsideClick))
                    closeOnOutsideClick = closeOnOutsideClick(e);
                if (closeOnOutsideClick) {
                    var $container = this._$content,
                        outsideClick = !$container.is(e.target) && !$.contains($container.get(0), e.target);
                    if (outsideClick) {
                        if (this.option("shading"))
                            e.preventDefault();
                        this.hide()
                    }
                }
            },
            _isTopOverlay: function() {
                var zIndexStack = this._zIndexStack();
                return zIndexStack[zIndexStack.length - 1] === this._zIndex
            },
            _zIndexStack: function() {
                return Z_INDEX_STACK
            },
            _zIndexInitValue: function() {
                return FIRST_Z_INDEX
            },
            _toggleViewPortSubscriptiion: function(toggle) {
                viewPortChanged.remove(this._viewPortChangeHandle);
                if (toggle) {
                    this._viewPortChangeHandle = $.proxy(this._viewPortChangeHandler, this);
                    viewPortChanged.add(this._viewPortChangeHandle)
                }
            },
            _viewPortChangeHandler: function() {
                this._initContainer(this.option("container"));
                this._refresh()
            },
            _renderVisibilityAnimate: function(visible) {
                this._stopAnimation();
                return visible ? this._show() : this._hide()
            },
            _normalizePosition: function() {
                this._position = this.option("position")
            },
            _show: function() {
                if (this._isParentHidden())
                    return $.Deferred().resolve();
                if (this._currentVisible)
                    return $.when().promise();
                this._currentVisible = true;
                this._normalizePosition();
                var that = this,
                    deferred = $.Deferred(),
                    animation = that.option("animation") || {},
                    showAnimation = this._normalizeAnimation(animation.show, "to"),
                    startShowAnimation = showAnimation && showAnimation.start || $.noop,
                    completeShowAnimation = showAnimation && showAnimation.complete || $.noop;
                if (this._isHidingActionCancelled) {
                    delete this._isHidingActionCancelled;
                    deferred.resolve()
                }
                else {
                    this._renderVisibility(true);
                    this._animate(showAnimation, function() {
                        if (that.option("focusStateEnabled"))
                            that._focusTarget().focus();
                        completeShowAnimation.apply(this, arguments);
                        that._showAnimationProcessing = false;
                        that._actions.onShown();
                        deferred.resolve()
                    }, function() {
                        startShowAnimation.apply(this, arguments);
                        that._showAnimationProcessing = true
                    })
                }
                return deferred.promise()
            },
            _normalizeAnimation: function(animation, prop) {
                if (animation && animation[prop]) {
                    animation = $.extend({type: "slide"}, animation);
                    $.extend(animation[prop], {position: this._position})
                }
                return animation
            },
            _hide: function() {
                if (!this._currentVisible)
                    return $.when().promise();
                this._currentVisible = false;
                var that = this,
                    deferred = $.Deferred(),
                    animation = this.option("animation") || {},
                    hideAnimation = this._normalizeAnimation(animation.hide, "from"),
                    completeHideAnimation = hideAnimation && hideAnimation.complete || $.noop,
                    hidingArgs = {cancel: false};
                this._actions.onHiding(hidingArgs);
                if (hidingArgs.cancel) {
                    this._isHidingActionCancelled = true;
                    this.option("visible", true);
                    deferred.resolve()
                }
                else {
                    this._toggleShading(false);
                    this._animate(hideAnimation, function() {
                        that._renderVisibility(false);
                        completeHideAnimation.apply(this, arguments);
                        that._actions.onHidden();
                        deferred.resolve()
                    })
                }
                return deferred.promise()
            },
            _animate: function(animation, completeCallback, startCallback) {
                if (animation) {
                    startCallback = startCallback || animation.start || $.noop;
                    var $content = this._$content;
                    fx.animate(this._$content, $.extend({}, animation, {
                        start: function() {
                            $content.css("pointer-events", "none");
                            startCallback.apply(this, arguments)
                        },
                        complete: function() {
                            $content.css("pointer-events", "");
                            completeCallback.apply(this, arguments)
                        }
                    }))
                }
                else
                    completeCallback()
            },
            _stopAnimation: function() {
                fx.stop(this._$content, true)
            },
            _renderVisibility: function(visible) {
                if (visible && this._isParentHidden())
                    return;
                this._currentVisible = visible;
                this._stopAnimation();
                if (!visible)
                    domUtils.triggerHidingEvent(this._$content);
                this._toggleVisibility(visible);
                this._$content.toggleClass(INVISIBLE_STATE_CLASS, !visible);
                this._updateZIndexStackPosition(visible);
                if (visible) {
                    this._renderContent();
                    this._actions.onShowing();
                    this._moveToContainer();
                    this._renderGeometry();
                    domUtils.triggerShownEvent(this._$content);
                    domUtils.triggerResizeEvent(this._$content)
                }
                else
                    this._moveFromContainer();
                this._toggleShading(visible);
                this._toggleSubscriptions(visible)
            },
            _updateZIndexStackPosition: function(pushToStack) {
                var zIndexStack = this._zIndexStack();
                if (pushToStack) {
                    if (!this._zIndex) {
                        var length = zIndexStack.length;
                        this._zIndex = (length ? zIndexStack[length - 1] : this._zIndexInitValue()) + 1;
                        zIndexStack.push(this._zIndex)
                    }
                    this._$wrapper.css("z-index", this._zIndex);
                    this._$content.css("z-index", this._zIndex)
                }
                else if (this._zIndex) {
                    var index = $.inArray(this._zIndex, zIndexStack);
                    zIndexStack.splice(index, 1);
                    delete this._zIndex
                }
            },
            _toggleShading: function(visible) {
                this._$wrapper.toggleClass(OVERLAY_MODAL_CLASS, this.option("shading") && !this.option("container"));
                this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible && this.option("shading"));
                this._$wrapper.css("background-color", this.option("shading") ? this.option("shadingColor") : "");
                this._toggleTabTerminator(visible && this.option("shading"))
            },
            _toggleTabTerminator: function(enabled) {
                var eventName = eventUtils.addNamespace("keydown", this.NAME);
                if (enabled)
                    $(document).on(eventName, $.proxy(this._tabKeyHandler, this));
                else
                    $(document).off(eventName)
            },
            _tabKeyHandler: function(e) {
                if (e.keyCode !== TAB_KEY)
                    return;
                var tabbableElements = this._$wrapper.find(selectors.tabbable),
                    $firstTabbable = tabbableElements.first(),
                    $lastTabbable = tabbableElements.last(),
                    isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0),
                    isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0),
                    isEmptyTabList = tabbableElements.length === 0,
                    isOutsideTarget = $.inArray(e.target, tabbableElements) === -1;
                if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {
                    e.preventDefault();
                    (e.shiftKey ? $lastTabbable : $firstTabbable).focusin().focus()
                }
            },
            _toggleSubscriptions: function(enabled) {
                this._toggleHideTopOverlayCallback(enabled);
                this._toggleDocumentDownHandler(enabled);
                this._toggleParentsScrollSubscription(enabled)
            },
            _toggleHideTopOverlayCallback: function(subscribe) {
                if (!this._hideTopOverlayHandler)
                    return;
                if (subscribe && this.option("closeOnBackButton"))
                    hideTopOverlayCallback.add(this._hideTopOverlayHandler);
                else
                    hideTopOverlayCallback.remove(this._hideTopOverlayHandler)
            },
            _toggleDocumentDownHandler: function(enabled) {
                var eventName = eventUtils.addNamespace(pointerEvents.down, this.NAME);
                if (enabled)
                    $(document).on(eventName, this._proxiedDocumentDownHandler);
                else
                    $(document).off(eventName, this._proxiedDocumentDownHandler)
            },
            _toggleParentsScrollSubscription: function(subscribe) {
                if (!this._position)
                    return;
                var target = this._position.of || $(),
                    closeOnScroll = this.option("closeOnTargetScroll"),
                    $parents = getElement(target).parents(),
                    scrollEvents = eventUtils.addNamespace("scroll", this.NAME);
                if (devices.real().platform === "generic")
                    $parents = $parents.add(window);
                this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || $.proxy(function(e) {
                    this._targetParentsScrollHandler(e)
                }, this);
                $().add(this._$prevTargetParents).off(scrollEvents, this._proxiedTargetParentsScrollHandler);
                if (subscribe && closeOnScroll) {
                    $parents.on(scrollEvents, this._proxiedTargetParentsScrollHandler);
                    this._$prevTargetParents = $parents
                }
            },
            _targetParentsScrollHandler: function(e) {
                var closeHandled = false,
                    closeOnScroll = this.option("closeOnTargetScroll");
                if ($.isFunction(closeOnScroll))
                    closeHandled = closeOnScroll(e);
                if (!closeHandled)
                    this.hide()
            },
            _render: function() {
                this.callBase();
                this._renderVisibility(this.option("visible"))
            },
            _renderContent: function() {
                var shouldDeferRendering = !this.option("visible") && this.option("deferRendering");
                var isParentHidden = this.option("visible") && this._isParentHidden();
                if (this._contentAlreadyRendered || shouldDeferRendering || isParentHidden)
                    return;
                this._contentAlreadyRendered = true;
                this.callBase()
            },
            _isParentHidden: function() {
                var $parent = this.element().parent();
                if ($parent.is(":visible"))
                    return false;
                var isHidden = false;
                $parent.add($parent.parents()).each(function() {
                    var $element = $(this);
                    if ($element.css("display") === "none") {
                        isHidden = true;
                        return false
                    }
                });
                return isHidden || !$.contains(document, $parent.get(0))
            },
            _renderContentImpl: function() {
                var $element = this.element();
                this._$content.appendTo($element);
                var contentTemplate = this._getTemplate(this.option("contentTemplate"));
                contentTemplate && contentTemplate.render(this.content());
                this._renderDrag();
                this._renderResize();
                this._renderScrollTerminator()
            },
            _renderDrag: function() {
                var $dragTarget = this._getDragTarget();
                if (!$dragTarget)
                    return;
                var startEventName = eventUtils.addNamespace("dxdragstart", this.NAME),
                    updateEventName = eventUtils.addNamespace("dxdrag", this.NAME);
                $dragTarget.off(startEventName).off(updateEventName);
                if (!this.option("dragEnabled"))
                    return;
                $dragTarget.on(startEventName, $.proxy(this._dragStartHandler, this)).on(updateEventName, $.proxy(this._dragUpdateHandler, this))
            },
            _renderResize: function() {
                this._createComponent(this._$content, "dxResizable", {
                    handles: this.option("resizeEnabled") ? "all" : "none",
                    onResizeEnd: $.proxy(this._resizeEndHandler, this),
                    onResize: $.proxy(this._actions.onResize, this),
                    onResizeStart: $.proxy(this._actions.onResizeStart, this),
                    minHeight: 100,
                    minWidth: 100,
                    area: this._$container
                })
            },
            _resizeEndHandler: function() {
                this._geometryChangeHandled = true;
                this._actions.onResizeEnd()
            },
            _renderScrollTerminator: function() {
                var $scrollTerminator = this._wrapper();
                var scrollEventName = eventUtils.addNamespace("dxscroll", this.NAME);
                $scrollTerminator.off(scrollEventName).on(scrollEventName, {
                    validate: function() {
                        return true
                    },
                    getDirection: function() {
                        return "both"
                    },
                    _toggleGestureCover: $.noop,
                    _clearSelection: $.noop,
                    isNative: true
                }, function(e) {
                    if (e.originalEvent.originalEvent.type !== "mousemove")
                        e.preventDefault()
                })
            },
            _getDragTarget: function() {
                return this.content()
            },
            _dragStartHandler: function(e) {
                e.targetElements = [];
                this._prevOffset = {
                    x: 0,
                    y: 0
                };
                var allowedOffsets = this._allowedOffsets();
                e.maxTopOffset = allowedOffsets.top;
                e.maxBottomOffset = allowedOffsets.bottom;
                e.maxLeftOffset = allowedOffsets.left;
                e.maxRightOffset = allowedOffsets.right
            },
            _deltaSize: function() {
                var $content = this._$content,
                    $container = this._$container;
                var contentWidth = $content.outerWidth(),
                    contentHeight = $content.outerHeight(),
                    containerWidth = $container.width(),
                    containerHeight = $container.height();
                return {
                        width: containerWidth - contentWidth,
                        height: containerHeight - contentHeight
                    }
            },
            _dragUpdateHandler: function(e) {
                var offset = e.offset,
                    prevOffset = this._prevOffset,
                    targetOffset = {
                        top: offset.y - prevOffset.y,
                        left: offset.x - prevOffset.x
                    };
                this._changePosition(targetOffset);
                this._prevOffset = offset
            },
            _changePosition: function(offset) {
                var position = translator.locate(this._$content);
                translator.move(this._$content, {
                    left: position.left + offset.left,
                    top: position.top + offset.top
                });
                this._geometryChangeHandled = true
            },
            _allowedOffsets: function() {
                var position = translator.locate(this._$content),
                    deltaSize = this._deltaSize(),
                    isAllowedDrag = deltaSize.height >= 0 && deltaSize.width >= 0,
                    boundaryOffset = this.option("boundaryOffset");
                return {
                        top: isAllowedDrag ? position.top + boundaryOffset.v : 0,
                        bottom: isAllowedDrag ? -position.top + deltaSize.height - boundaryOffset.v : 0,
                        left: isAllowedDrag ? position.left + boundaryOffset.h : 0,
                        right: isAllowedDrag ? -position.left + deltaSize.width - boundaryOffset.h : 0
                    }
            },
            _fireContentReadyAction: function() {
                if (this.option("visible"))
                    this._moveToContainer();
                this.callBase.apply(this, arguments)
            },
            _moveFromContainer: function() {
                this._$content.appendTo(this.element());
                this._detachWrapperToContainer()
            },
            _detachWrapperToContainer: function() {
                this._$wrapper.detach()
            },
            _moveToContainer: function() {
                this._attachWrapperToContainer();
                this._$content.appendTo(this._$wrapper)
            },
            _attachWrapperToContainer: function() {
                var $element = this.element();
                if (this._$container && this._$container[0] !== $element.parent()[0])
                    this._$wrapper.appendTo(this._$container);
                else
                    this._$wrapper.appendTo($element)
            },
            _renderGeometry: function() {
                if (this.option("visible"))
                    this._renderGeometryImpl()
            },
            _renderGeometryImpl: function() {
                this._stopAnimation();
                this._normalizePosition();
                this._renderShading();
                this._renderDimensions();
                this._renderPosition()
            },
            _renderShading: function() {
                var $wrapper = this._$wrapper,
                    $container = this._getContainer();
                $wrapper.css("position", this._isWindow($container) && !iOS ? "fixed" : "absolute");
                if (this.option("shading"))
                    $wrapper.show();
                this._renderShadingDimensions();
                this._renderShadingPosition()
            },
            _renderShadingPosition: function() {
                if (this.option("shading")) {
                    var $container = this._getContainer();
                    positionUtils.setup(this._$wrapper, {
                        my: "top left",
                        at: "top left",
                        of: $container
                    })
                }
            },
            _renderShadingDimensions: function() {
                if (this.option("shading")) {
                    var $container = this._getContainer(),
                        wrapperWidth = this._isWindow($container) ? "100%" : $container.outerWidth(),
                        wrapperHeight = this._isWindow($container) ? "100%" : $container.outerHeight();
                    this._$wrapper.css({
                        width: wrapperWidth,
                        height: wrapperHeight
                    })
                }
            },
            _isWindow: function($element) {
                return !!$element && $.isWindow($element.get(0))
            },
            _getContainer: function() {
                var position = this._position,
                    container = this.option("container"),
                    positionOf = position ? position.of || window : null;
                return getElement(container || positionOf)
            },
            _renderDimensions: function() {
                this._$content.css({
                    minWidth: this.option("minWidth"),
                    maxWidth: this.option("maxWidth"),
                    minHeight: this.option("minHeight"),
                    maxHeight: this.option("maxHeight")
                });
                if (this._geometryChangeHandled) {
                    var $content = this._$content,
                        $container = this._$container;
                    $content.outerWidth(Math.min($content.outerWidth(), $container.width())).outerHeight(Math.min($content.outerHeight(), $container.height()))
                }
                else
                    this._$content.outerWidth(this.option("width")).outerHeight(this.option("height"))
            },
            _renderPosition: function() {
                var position,
                    containerPosition,
                    allowedOffsets,
                    $content;
                if (this._geometryChangeHandled) {
                    $content = this._$content;
                    position = translator.locate($content);
                    allowedOffsets = this._allowedOffsets();
                    this._changePosition({
                        top: fitIntoRange(0, -allowedOffsets.top, allowedOffsets.bottom),
                        left: fitIntoRange(0, -allowedOffsets.left, allowedOffsets.right)
                    })
                }
                else {
                    translator.resetPosition(this._$content);
                    this._renderOverlayBoundaryOffset();
                    position = this._position;
                    containerPosition = positionUtils.calculate(this._$content, position);
                    this._actions.onPositioning({position: containerPosition});
                    var resultPosition = positionUtils.setup(this._$content, containerPosition);
                    this._actions.onPositioned({position: resultPosition});
                    forceRepaint(this._$content)
                }
            },
            _renderOverlayBoundaryOffset: function() {
                var boundaryOffset = this.option("boundaryOffset");
                this._$content.css("margin", boundaryOffset.v + "px " + boundaryOffset.h + "px")
            },
            _focusTarget: function() {
                return this._$content
            },
            _attachKeyboardEvents: function() {
                this._keyboardProcessor = new KeyboardProcessor({
                    element: this._$content,
                    handler: this._keyboardHandler,
                    context: this
                })
            },
            _keyboardHandler: function(options) {
                var e = options.originalEvent,
                    $target = $(e.target);
                if ($target.is(this._$content))
                    this.callBase.apply(this, arguments)
            },
            _isVisible: function() {
                if (this.content().parent().length)
                    return this.content().is(":visible") || this.element().is(".dx-state-invisible");
                else
                    return this.callBase()
            },
            _visibilityChanged: function(visible) {
                if (visible) {
                    if (this.option("visible"))
                        this._renderVisibilityAnimate(visible)
                }
                else
                    this._renderVisibilityAnimate(visible)
            },
            _dimensionChanged: function() {
                this._renderGeometry()
            },
            _clean: function() {
                if (!this._contentAlreadyRendered)
                    this.content().empty();
                this._cleanFocusState()
            },
            _dispose: function() {
                DX.fx.stop(this._$content, false);
                this._toggleViewPortSubscriptiion(false);
                this._toggleSubscriptions(false);
                this._updateZIndexStackPosition(false);
                this._actions = null;
                this.callBase();
                this._$wrapper.remove();
                this._$content.remove()
            },
            _toggleDisabledState: function(value) {
                this.callBase.apply(this, arguments);
                this._$content.toggleClass(DISABLED_STATE_CLASS, Boolean(value))
            },
            _toggleRTLDirection: function(rtl) {
                this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl)
            },
            _optionChanged: function(args) {
                var value = args.value;
                if ($.inArray(args.name, ACTIONS) > -1) {
                    this._initActions();
                    return
                }
                switch (args.name) {
                    case"dragEnabled":
                        this._renderDrag();
                        this._renderGeometry();
                        break;
                    case"resizeEnabled":
                        this._renderResize();
                        this._renderGeometry();
                        break;
                    case"shading":
                    case"shadingColor":
                        this._toggleShading(this.option("visible"));
                        break;
                    case"width":
                    case"minWidth":
                    case"maxWidth":
                    case"height":
                    case"minHeight":
                    case"maxHeight":
                    case"position":
                    case"boundaryOffset":
                        this._renderGeometry();
                        break;
                    case"visible":
                        this._renderVisibilityAnimate(value).done($.proxy(function() {
                            if (!this._animateDeferred)
                                return;
                            this._animateDeferred.resolveWith(this)
                        }, this));
                        break;
                    case"target":
                        this._initTarget(value);
                        this._invalidate();
                        break;
                    case"container":
                        this._initContainer(value);
                        this._invalidate();
                        break;
                    case"deferRendering":
                    case"contentTemplate":
                        this._contentAlreadyRendered = false;
                        this._invalidate();
                        break;
                    case"closeOnBackButton":
                        this._toggleHideTopOverlayCallback(this.option("visible"));
                        break;
                    case"closeOnOutsideClick":
                        this._toggleDocumentDownHandler(this.option("visible"));
                        break;
                    case"closeOnTargetScroll":
                        this._toggleParentsScrollSubscription(this.option("visible"));
                        break;
                    case"animation":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            toggle: function(showing) {
                showing = showing === undefined ? !this.option("visible") : showing;
                if (showing === this.option("visible"))
                    return $.Deferred().resolve().promise();
                var animateDeferred = $.Deferred();
                this._animateDeferred = animateDeferred;
                this.option("visible", showing);
                return animateDeferred.promise().done($.proxy(function() {
                        delete this._animateDeferred
                    }, this))
            },
            show: function() {
                return this.toggle(true)
            },
            hide: function() {
                return this.toggle(false)
            },
            content: function() {
                return this._$content
            },
            repaint: function() {
                this._renderGeometry()
            }
        }));
        DevExpress.ui.dxOverlay.baseZIndex = function(zIndex) {
            FIRST_Z_INDEX = zIndex
        };
        ui.dxOverlay.__internals = {
            OVERLAY_CLASS: OVERLAY_CLASS,
            OVERLAY_WRAPPER_CLASS: OVERLAY_WRAPPER_CLASS,
            OVERLAY_CONTENT_CLASS: OVERLAY_CONTENT_CLASS,
            OVERLAY_SHADER_CLASS: OVERLAY_SHADER_CLASS,
            OVERLAY_MODAL_CLASS: OVERLAY_MODAL_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.toast.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator");
        var TOAST_CLASS = "dx-toast",
            TOAST_CLASS_PREFIX = TOAST_CLASS + "-",
            TOAST_WRAPPER_CLASS = TOAST_CLASS_PREFIX + "wrapper",
            TOAST_CONTENT_CLASS = TOAST_CLASS_PREFIX + "content",
            TOAST_MESSAGE_CLASS = TOAST_CLASS_PREFIX + "message",
            TOAST_ICON_CLASS = TOAST_CLASS_PREFIX + "icon",
            WIDGET_NAME = "dxToast",
            toastTypes = ["info", "warning", "error", "success"],
            Z_INDEX_STACK = [],
            FIRST_Z_INDEX_OFFSET = 8000,
            visibleToastInstance = null,
            POSITION_ALIASES = {
                top: {
                    my: "top",
                    at: "top",
                    of: null,
                    offset: "0 0"
                },
                bottom: {
                    my: "bottom",
                    at: "bottom",
                    of: null,
                    offset: "0 -20"
                },
                center: {
                    my: "center",
                    at: "center",
                    of: null,
                    offset: "0 0"
                },
                right: {
                    my: "center right",
                    at: "center right",
                    of: null,
                    offset: "0 0"
                },
                left: {
                    my: "center left",
                    at: "center left",
                    of: null,
                    offset: "0 0"
                }
            };
        registerComponent(WIDGET_NAME, ui, ui.dxOverlay.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        message: "",
                        type: "info",
                        displayTime: 2000,
                        position: "bottom center",
                        animation: {
                            show: {
                                type: "fade",
                                duration: 400,
                                from: 0,
                                to: 1
                            },
                            hide: {
                                type: "fade",
                                duration: 400,
                                to: 0
                            }
                        },
                        shading: false,
                        height: "auto",
                        closeOnBackButton: false,
                        closeOnSwipe: true,
                        closeOnClick: false,
                        resizeEnabled: false
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return device.platform === "win" && device.version && device.version[0] === 8
                            },
                            options: {
                                position: "top center",
                                width: function() {
                                    return $(window).width()
                                }
                            }
                        }, {
                            device: function(device) {
                                return device.platform === "win" && device.version && device.version[0] === 10
                            },
                            options: {
                                position: "bottom right",
                                width: "auto"
                            }
                        }, {
                            device: {platform: "android"},
                            options: {
                                closeOnOutsideClick: true,
                                width: "auto",
                                position: {
                                    at: "bottom left",
                                    my: "bottom left",
                                    offset: "20 -20"
                                },
                                animation: {
                                    show: {
                                        type: "slide",
                                        duration: 200,
                                        from: {top: $(window).height()}
                                    },
                                    hide: {
                                        type: "slide",
                                        duration: 200,
                                        to: {top: $(window).height()}
                                    }
                                }
                            }
                        }, {
                            device: function(device) {
                                var isPhone = device.deviceType === "phone",
                                    isAndroid = device.platform === "android",
                                    isWin10 = device.platform === "win" && device.version && device.version[0] === 10;
                                return isPhone && (isAndroid || isWin10)
                            },
                            options: {
                                width: function() {
                                    return $(window).width()
                                },
                                position: {
                                    at: "bottom center",
                                    my: "bottom center",
                                    offset: "0 0"
                                }
                            }
                        }])
            },
            _init: function() {
                this.callBase();
                this._posStringToObject()
            },
            _renderContentImpl: function() {
                if (this.option("message"))
                    this._message = $("<div>").addClass(TOAST_MESSAGE_CLASS).text(this.option("message")).appendTo(this.content());
                this.setAria("role", "alert", this._message);
                if ($.inArray(this.option("type").toLowerCase(), toastTypes) > -1)
                    this.content().prepend($("<div>").addClass(TOAST_ICON_CLASS));
                this.callBase()
            },
            _render: function() {
                this.callBase();
                this.element().addClass(TOAST_CLASS);
                this._wrapper().addClass(TOAST_WRAPPER_CLASS);
                this._$content.addClass(TOAST_CLASS_PREFIX + String(this.option("type")).toLowerCase());
                this.content().addClass(TOAST_CONTENT_CLASS);
                this._toggleCloseEvents("Swipe");
                this._toggleCloseEvents("Click")
            },
            _toggleCloseEvents: function(event) {
                var dxEvent = "dx" + event.toLowerCase();
                this._$content.off(dxEvent);
                this.option("closeOn" + event) && this._$content.on(dxEvent, $.proxy(this.hide, this))
            },
            _posStringToObject: function() {
                if (!commonUtils.isString(this.option("position")))
                    return;
                var verticalPosition = this.option("position").split(" ")[0],
                    horizontalPosition = this.option("position").split(" ")[1];
                this.option("position", $.extend({}, POSITION_ALIASES[verticalPosition]));
                switch (horizontalPosition) {
                    case"center":
                    case"left":
                    case"right":
                        this.option("position").at += " " + horizontalPosition;
                        this.option("position").my += " " + horizontalPosition;
                        break
                }
            },
            _show: function() {
                if (visibleToastInstance) {
                    clearTimeout(visibleToastInstance._hideTimeout);
                    visibleToastInstance.hide()
                }
                visibleToastInstance = this;
                return this.callBase.apply(this, arguments).done($.proxy(function() {
                        clearTimeout(this._hideTimeout);
                        this._hideTimeout = setTimeout($.proxy(this.hide, this), this.option("displayTime"))
                    }, this))
            },
            _hide: function() {
                visibleToastInstance = null;
                return this.callBase.apply(this, arguments)
            },
            _zIndexStack: function() {
                return Z_INDEX_STACK
            },
            _zIndexInitValue: function() {
                return this.callBase() + FIRST_Z_INDEX_OFFSET
            },
            _dispose: function() {
                clearTimeout(this._hideTimeout);
                visibleToastInstance = null;
                this.callBase()
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"type":
                        this._$content.removeClass(TOAST_CLASS_PREFIX + args.previousValue);
                        this._$content.addClass(TOAST_CLASS_PREFIX + String(args.value).toLowerCase());
                        break;
                    case"message":
                        if (this._message)
                            this._message.text(args.value);
                        break;
                    case"closeOnSwipe":
                        this._toggleCloseEvents("Swipe");
                        break;
                    case"closeOnClick":
                        this._toggleCloseEvents("Click");
                        break;
                    case"displayTime":
                    case"position":
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }));
        ui.dxToast.__internals = {
            TOAST_CLASS: TOAST_CLASS,
            TOAST_WRAPPER_CLASS: TOAST_WRAPPER_CLASS,
            TOAST_CONTENT_CLASS: TOAST_CONTENT_CLASS,
            TOAST_MESSAGE_CLASS: TOAST_MESSAGE_CLASS,
            TOAST_ICON_CLASS: TOAST_ICON_CLASS,
            TOAST_CLASS_PREFIX: TOAST_CLASS_PREFIX,
            WIDGET_NAME: WIDGET_NAME
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.popup.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.require("/utils/utils.translator"),
            camelize = DX.require("/utils/utils.inflector").camelize,
            commonUtils = DX.require("/utils/utils.common"),
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator"),
            Button = DX.require("/ui/widgets/ui.button"),
            themes = DX.require("/ui/ui.themes"),
            POPUP_CLASS = "dx-popup",
            POPUP_WRAPPER_CLASS = "dx-popup-wrapper",
            POPUP_FULL_SCREEN_CLASS = "dx-popup-fullscreen",
            POPUP_FULL_SCREEN_WIDTH_CLASS = "dx-popup-fullscreen-width",
            POPUP_NORMAL_CLASS = "dx-popup-normal",
            POPUP_CONTENT_CLASS = "dx-popup-content",
            POPUP_DRAGGABLE_CLASS = "dx-popup-draggable",
            POPUP_TITLE_CLASS = "dx-popup-title",
            POPUP_TITLE_CLOSEBUTTON_CLASS = "dx-closebutton",
            POPUP_BOTTOM_CLASS = "dx-popup-bottom",
            TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper",
            ALLOWED_BUTTON_ALIASES = ["cancel", "clear", "done"];
        var getButtonPlace = function(name) {
                var device = devices.current(),
                    platform = device.platform,
                    toolbar = "bottom",
                    location = "before";
                if (platform === "ios")
                    switch (name) {
                        case"cancel":
                            toolbar = "top";
                            break;
                        case"clear":
                            toolbar = "top";
                            location = "after";
                            break;
                        case"done":
                            location = "after";
                            break
                    }
                else if (platform === "win")
                    location = "after";
                else if (platform === "android" && device.version && parseInt(device.version[0]) > 4)
                    switch (name) {
                        case"cancel":
                            location = "after";
                            break;
                        case"done":
                            location = "after";
                            break
                    }
                else if (platform === "android")
                    location = "center";
                return {
                        toolbar: toolbar,
                        location: location
                    }
            };
        registerComponent("dxPopup", ui, ui.dxOverlay.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        fullScreen: false,
                        title: "",
                        showTitle: true,
                        titleTemplate: "title",
                        onTitleRendered: null,
                        dragEnabled: false,
                        buttons: [],
                        showCloseButton: false,
                        bottomTemplate: "bottom"
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function() {
                                var currentTheme = (themes.current() || "").split(".")[0];
                                return currentTheme === "win8"
                            },
                            options: {width: function() {
                                    return $(window).width()
                                }}
                        }, {
                            device: function(device) {
                                var currentTheme = (themes.current() || "").split(".")[0];
                                return device.phone && currentTheme === "win8"
                            },
                            options: {position: {
                                    my: "top center",
                                    at: "top center",
                                    offset: "0 0"
                                }}
                        }, {
                            device: {platform: "ios"},
                            options: {animation: this._iosAnimation}
                        }, {
                            device: {platform: "generic"},
                            options: {showCloseButton: true}
                        }, {
                            device: function(device) {
                                return devices.real().platform === "generic" && device.platform === "generic"
                            },
                            options: {dragEnabled: true}
                        }, {
                            device: function(device) {
                                return devices.real().generic && !devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _iosAnimation: {
                show: {
                    type: "slide",
                    duration: 400,
                    from: {position: {
                            my: "top",
                            at: "bottom"
                        }},
                    to: {position: {
                            my: "center",
                            at: "center"
                        }}
                },
                hide: {
                    type: "slide",
                    duration: 400,
                    from: {
                        opacity: 1,
                        position: {
                            my: "center",
                            at: "center"
                        }
                    },
                    to: {
                        opacity: 1,
                        position: {
                            my: "top",
                            at: "bottom"
                        }
                    }
                }
            },
            _init: function() {
                this.callBase();
                this.element().addClass(POPUP_CLASS);
                this._wrapper().addClass(POPUP_WRAPPER_CLASS);
                this._$popupContent = this._$content.wrapInner($("<div>").addClass(POPUP_CONTENT_CLASS)).children().eq(0)
            },
            _render: function() {
                var isFullscreen = this.option("fullScreen");
                this._$content.toggleClass(POPUP_FULL_SCREEN_CLASS, isFullscreen).toggleClass(POPUP_NORMAL_CLASS, !isFullscreen);
                this.callBase()
            },
            _renderContentImpl: function() {
                this.callBase();
                this._renderTitle();
                this._renderBottom()
            },
            _renderTitle: function() {
                var items = this._getToolbarItems("top"),
                    titleText = this.option("title"),
                    showTitle = this.option("showTitle");
                if (showTitle && !!titleText)
                    items.unshift({
                        location: devices.current().ios ? "center" : "before",
                        text: titleText
                    });
                if (showTitle || items.length > 0) {
                    this._$title && this._$title.remove();
                    var $title = $("<div>").addClass(POPUP_TITLE_CLASS).insertBefore(this.content());
                    this._$title = this._renderTemplateByType("titleTemplate", items, $title).addClass(POPUP_TITLE_CLASS);
                    this._renderDrag();
                    this._executeTitleRenderAction(this._$title)
                }
                else if (this._$title)
                    this._$title.detach()
            },
            _renderTemplateByType: function(optionName, data, $container) {
                var template = this._getTemplateByOption(optionName),
                    toolbarTemplate = template.owner() === this.option("templateProvider"),
                    $result;
                if (toolbarTemplate) {
                    $result = template.render(data, $container);
                    $container.replaceWith($result);
                    return $result
                }
                else {
                    $result = template.render($container);
                    if ($result.hasClass(TEMPLATE_WRAPPER_CLASS)) {
                        $container.replaceWith($result);
                        $container = $result
                    }
                    return $container
                }
            },
            _executeTitleRenderAction: function(titleElement) {
                this._getTitleRenderAction()({titleElement: titleElement})
            },
            _getTitleRenderAction: function() {
                return this._titleRenderAction || this._createTitleRenderAction()
            },
            _createTitleRenderAction: function() {
                return this._titleRenderAction = this._createActionByOption("onTitleRendered", {
                        element: this.element(),
                        excludeValidators: ["designMode", "disabled", "readOnly"]
                    })
            },
            _getCloseButton: function() {
                return {
                        toolbar: "top",
                        location: "after",
                        template: this._getCloseButtonRenderer()
                    }
            },
            _getCloseButtonRenderer: function() {
                return $.proxy(function(_, __, $container) {
                        var $button = $("<div>").addClass(POPUP_TITLE_CLOSEBUTTON_CLASS);
                        this._createComponent($button, Button, {
                            icon: 'close',
                            onClick: this._createButtonAction(undefined),
                            _templates: {}
                        });
                        $container.append($button)
                    }, this)
            },
            _getToolbarItems: function(toolbar) {
                var buttons = this.option("buttons");
                var toolbarsItems = [];
                this._buttonsClasses = [];
                var currentPlatform = devices.current().platform,
                    index = 0;
                $.each(buttons, $.proxy(function(_, data) {
                    var isShortcut = commonUtils.isDefined(data.shortcut),
                        item = isShortcut ? getButtonPlace(data.shortcut) : data;
                    if (isShortcut && currentPlatform === "ios" && index < 2) {
                        item.toolbar = "top";
                        index++
                    }
                    $.extend(item, commonUtils.isDefined(data.toolbar) ? {toolbar: data.toolbar} : {});
                    if (item && item.toolbar === toolbar) {
                        if (isShortcut)
                            $.extend(item, {location: data.location}, this._getButtonByAlias(data));
                        var isLTROrder = currentPlatform === "win" || currentPlatform === "generic";
                        if (data.shortcut === "done" && isLTROrder || data.shortcut === "cancel" && !isLTROrder)
                            toolbarsItems.unshift(item);
                        else
                            toolbarsItems.push(item)
                    }
                }, this));
                if (toolbar === "top" && this.option("showCloseButton") && this.option("showTitle"))
                    toolbarsItems.push(this._getCloseButton());
                return toolbarsItems
            },
            _getButtonByAlias: function(data) {
                var that = this,
                    buttonType = data.shortcut;
                if ($.inArray(buttonType, ALLOWED_BUTTON_ALIASES) < 0)
                    return false;
                var buttonConfig = $.extend({
                        text: Globalize.localize(camelize(buttonType, true)),
                        onClick: this._createButtonAction(data.onClick),
                        _templates: {}
                    }, data.options || {});
                var buttonClass = POPUP_CLASS + "-" + buttonType;
                this._buttonsClasses.push(buttonClass);
                return {template: function(_, __, $container) {
                            var $button = $("<div>").addClass(buttonClass).appendTo($container);
                            that._createComponent($button, Button, buttonConfig)
                        }}
            },
            _createButtonAction: function(clickAction) {
                return this._createAction(clickAction, {afterExecute: function(e) {
                            e.component.hide()
                        }})
            },
            _renderBottom: function() {
                var items = this._getToolbarItems("bottom");
                if (items.length) {
                    this._$bottom && this._$bottom.remove();
                    var $bottom = $("<div>").addClass(POPUP_BOTTOM_CLASS).insertAfter(this.content());
                    this._$bottom = this._renderTemplateByType("bottomTemplate", items, $bottom).addClass(POPUP_BOTTOM_CLASS);
                    this._toggleClasses()
                }
                else
                    this._$bottom && this._$bottom.detach()
            },
            _toggleClasses: function() {
                var aliases = ALLOWED_BUTTON_ALIASES;
                $.each(aliases, $.proxy(function(_, alias) {
                    var className = POPUP_CLASS + "-" + alias;
                    if ($.inArray(className, this._buttonsClasses) >= 0) {
                        this._wrapper().addClass(className + "-visible");
                        this._$bottom.addClass(className)
                    }
                    else {
                        this._wrapper().removeClass(className + "-visible");
                        this._$bottom.removeClass(className)
                    }
                }, this))
            },
            _getDragTarget: function() {
                return this._$title
            },
            _renderGeometryImpl: function() {
                this._resetContentHeight();
                this.callBase.apply(this, arguments);
                this._setContentHeight()
            },
            _resetContentHeight: function() {
                this._$popupContent.css({height: "auto"})
            },
            _renderDrag: function() {
                this.callBase();
                this._$content.toggleClass(POPUP_DRAGGABLE_CLASS, this.option("dragEnabled"))
            },
            _renderResize: function() {
                this.callBase();
                this._$content.dxResizable("option", "onResize", $.proxy(this._setContentHeight, this))
            },
            _setContentHeight: function() {
                if (this._disallowUpdateContentHeight())
                    return;
                var contentHeight = this._$content.height();
                if (this._$title && this._$title.is(":visible"))
                    contentHeight -= this._$title.outerHeight(true) || 0;
                if (this._$bottom && this._$bottom.is(":visible"))
                    contentHeight -= this._$bottom.outerHeight(true) || 0;
                this._$popupContent.css({height: contentHeight})
            },
            _disallowUpdateContentHeight: function() {
                var isHeightAuto = this.option("height") === "auto",
                    maxHeightSpecified = this._$content.css("maxHeight") !== "none",
                    minHeightSpecified = parseInt(this._$content.css("minHeight")) > 0;
                return isHeightAuto && !(maxHeightSpecified || minHeightSpecified)
            },
            _renderDimensions: function() {
                if (this.option("fullScreen"))
                    this._$content.css({
                        width: "100%",
                        height: "100%"
                    });
                else
                    this.callBase.apply(this, arguments);
                this._renderFullscreenWidthClass()
            },
            _renderFullscreenWidthClass: function() {
                this.overlayContent().toggleClass(POPUP_FULL_SCREEN_WIDTH_CLASS, this.overlayContent().outerWidth() === $(window).width())
            },
            _renderShadingDimensions: function() {
                if (this.option("fullScreen"))
                    this._wrapper().css({
                        width: "100%",
                        height: "100%"
                    });
                else
                    this.callBase.apply(this, arguments)
            },
            _renderPosition: function() {
                if (this.option("fullScreen"))
                    translator.move(this._$content, {
                        top: 0,
                        left: 0
                    });
                else
                    this.callBase.apply(this, arguments)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"showTitle":
                    case"title":
                    case"titleTemplate":
                        this._renderTitle();
                        this._renderGeometry();
                        break;
                    case"bottomTemplate":
                        this._renderBottom();
                        this._renderGeometry();
                        break;
                    case"onTitleRendered":
                        this._createTitleRenderAction(args.value);
                        break;
                    case"buttons":
                        this._renderTitle();
                        this._renderBottom();
                        this._renderGeometry();
                        break;
                    case"dragEnabled":
                        this._renderDrag();
                        break;
                    case"fullScreen":
                        this._$content.toggleClass(POPUP_FULL_SCREEN_CLASS, args.value);
                        this._refresh();
                        break;
                    case"showCloseButton":
                        this._renderTitle();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            bottomToolbar: function() {
                return this._$bottom
            },
            content: function() {
                return this._$popupContent
            },
            overlayContent: function() {
                return this._$content
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.popover.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.require("/utils/utils.translator"),
            stringUtils = DX.require("/utils/utils.string"),
            positionUtils = DX.require("/utils/utils.position"),
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator");
        var POPOVER_CLASS = "dx-popover",
            POPOVER_WRAPPER_CLASS = "dx-popover-wrapper",
            POPOVER_ARROW_CLASS = "dx-popover-arrow",
            POPOVER_WITHOUT_TITLE_CLASS = "dx-popover-without-title",
            POSITION_FLIP_MAP = {
                left: "right",
                top: "bottom",
                right: "left",
                bottom: "top",
                center: "center"
            },
            WEIGHT_OF_SIDES = {
                left: -1,
                top: -1,
                center: 0,
                right: 1,
                bottom: 1
            },
            POSITION_ALIASES = {
                top: {
                    my: "bottom center",
                    at: "top center",
                    collision: "fit flip"
                },
                bottom: {
                    my: "top center",
                    at: "bottom center",
                    collision: "fit flip"
                },
                right: {
                    my: "left center",
                    at: "right center",
                    collision: "flip fit"
                },
                left: {
                    my: "right center",
                    at: "left center",
                    collision: "flip fit"
                }
            };
        registerComponent("dxPopover", ui, ui.dxPopup.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        target: window,
                        shading: false,
                        position: 'bottom',
                        closeOnOutsideClick: true,
                        animation: {
                            show: {
                                type: "fade",
                                from: 0,
                                to: 1
                            },
                            hide: {
                                type: "fade",
                                to: 0
                            }
                        },
                        showTitle: false,
                        width: "auto",
                        height: "auto",
                        dragEnabled: false,
                        resizeEnabled: false,
                        fullScreen: false,
                        closeOnTargetScroll: true,
                        arrowPosition: "",
                        arrowOffset: 0,
                        boundaryOffset: {
                            h: 10,
                            v: 10
                        }
                    })
            },
            _defaultOptionsRules: function() {
                return [{
                            device: {platform: "ios"},
                            options: {arrowPosition: {
                                    boundaryOffset: {
                                        h: 20,
                                        v: -10
                                    },
                                    collision: "fit"
                                }}
                        }]
            },
            _init: function() {
                this.callBase();
                this._renderArrow();
                this.element().addClass(POPOVER_CLASS);
                this._wrapper().addClass(POPOVER_WRAPPER_CLASS)
            },
            _renderArrow: function() {
                this._$arrow = $("<div>").addClass(POPOVER_ARROW_CLASS).prependTo(this.overlayContent())
            },
            _documentDownHandler: function(e) {
                if (this._isOutsideClick(e))
                    this.callBase(e)
            },
            _isOutsideClick: function(e) {
                return !$(e.target).closest(this.option("target")).length
            },
            _animate: function(animation) {
                if (animation && animation.to)
                    $.extend(animation.to, {position: this._contentPosition});
                this.callBase.apply(this, arguments)
            },
            _stopAnimation: function() {
                this.callBase.apply(this, arguments)
            },
            _renderTitle: function() {
                this._wrapper().toggleClass(POPOVER_WITHOUT_TITLE_CLASS, !this.option("showTitle"));
                this.callBase()
            },
            _renderPosition: function() {
                this.callBase();
                this._renderOverlayPosition()
            },
            _renderOverlayBoundaryOffset: $.noop,
            _renderOverlayPosition: function() {
                this._resetOverlayPosition();
                this._updateContentSize();
                var contentPosition = this._getContainerPosition();
                var resultLocation = positionUtils.setup(this._$content, contentPosition);
                var positionSide = this._getSideByLocation(resultLocation);
                this._togglePositionClass("dx-position-" + positionSide);
                this._toggleFlippedClass(resultLocation.h.flip, resultLocation.v.flip);
                this._renderArrowPosition(positionSide)
            },
            _resetOverlayPosition: function() {
                this._setContentHeight(true);
                this._togglePositionClass("dx-position-" + this._positionSide);
                translator.move(this._$content, {
                    left: 0,
                    top: 0
                });
                this._$arrow.css({
                    top: 'auto',
                    right: 'auto',
                    bottom: 'auto',
                    left: 'auto'
                })
            },
            _updateContentSize: function() {
                if (!this._$popupContent)
                    return;
                var containerLocation = positionUtils.calculate(this._$content, this._getContainerPosition());
                if (containerLocation.h.oversize > 0 && this._isHorizontalSide() && !containerLocation.h.fit) {
                    var newContainerWidth = this._$content.width() - containerLocation.h.oversize;
                    this._$content.width(newContainerWidth)
                }
                if (containerLocation.v.oversize > 0 && this._isVerticalSide() && !containerLocation.v.fit) {
                    var newOverlayContentHeight = this._$content.height() - containerLocation.v.oversize,
                        newPopupContentHeight = this._$popupContent.height() - containerLocation.v.oversize;
                    this._$content.height(newOverlayContentHeight);
                    this._$popupContent.height(newPopupContentHeight)
                }
            },
            _getContainerPosition: function() {
                var offset = stringUtils.pairToObject(this._position.offset || "");
                var hOffset = offset.h;
                var vOffset = offset.v;
                var isPopoverInside = this._isPopoverInside();
                var sign = (isPopoverInside ? -1 : 1) * WEIGHT_OF_SIDES[this._positionSide];
                var arrowSizeCorrection = this._getContentBorderWidth(this._positionSide);
                if (this._isVerticalSide())
                    vOffset += sign * (this._$arrow.height() - arrowSizeCorrection);
                else if (this._isHorizontalSide())
                    hOffset += sign * (this._$arrow.width() - arrowSizeCorrection);
                return $.extend({}, this._position, {offset: hOffset + " " + vOffset})
            },
            _getContentBorderWidth: function(side) {
                var borderWidth = this._$content.css("border-" + side + "-width");
                return parseInt(borderWidth) || 0
            },
            _getSideByLocation: function(location) {
                var isFlippedByVertical = location.v.flip;
                var isFlippedByHorizontal = location.h.flip;
                return this._isVerticalSide() && isFlippedByVertical || this._isHorizontalSide() && isFlippedByHorizontal || this._isPopoverInside() ? POSITION_FLIP_MAP[this._positionSide] : this._positionSide
            },
            _togglePositionClass: function(positionClass) {
                this._$wrapper.removeClass("dx-position-left dx-position-right dx-position-top dx-position-bottom").addClass(positionClass)
            },
            _toggleFlippedClass: function(isFlippedHorizontal, isFlippedVertical) {
                this._$wrapper.toggleClass("dx-popover-flipped-horizontal", isFlippedHorizontal).toggleClass("dx-popover-flipped-vertical", isFlippedVertical)
            },
            _renderArrowPosition: function(side) {
                this._$arrow.css(POSITION_FLIP_MAP[side], -(this._isVerticalSide(side) ? this._$arrow.height() : this._$arrow.width()));
                var axis = this._isVerticalSide(side) ? "left" : "top";
                var sizeProperty = this._isVerticalSide(side) ? "outerWidth" : "outerHeight";
                var $target = $(this._position.of);
                var targetOffset = $target.offset() || {
                        top: 0,
                        left: 0
                    };
                var contentOffset = this._$content.offset();
                var arrowSize = this._$arrow[sizeProperty]();
                var contentLocation = contentOffset[axis];
                var contentSize = this._$content[sizeProperty]();
                var targetLocation = targetOffset[axis];
                var targetSize = $target.get(0).preventDefault ? 0 : $target[sizeProperty]();
                var min = Math.max(contentLocation, targetLocation);
                var max = Math.min(contentLocation + contentSize, targetLocation + targetSize);
                var arrowLocation;
                if (this.option("arrowPosition") === "start")
                    arrowLocation = min - contentLocation;
                else if (this.option("arrowPosition") === "end")
                    arrowLocation = max - contentLocation - arrowSize;
                else
                    arrowLocation = (min + max) / 2 - contentLocation - arrowSize / 2;
                this._$arrow.css(axis, arrowLocation - this._getContentBorderWidth(side) + this.option("arrowOffset"))
            },
            _isPopoverInside: function() {
                var position = this._getPosition();
                var my = positionUtils.setup.normalizeAlign(position.my);
                var at = positionUtils.setup.normalizeAlign(position.at);
                return my.h === at.h && my.v === at.v
            },
            _getPosition: function() {
                var position = this.option("position");
                if (commonUtils.isString(position))
                    position = $.extend({}, POSITION_ALIASES[position]);
                return position
            },
            _setContentHeight: function(fullUpdate) {
                if (fullUpdate)
                    this.callBase()
            },
            _renderShadingPosition: function() {
                if (this.option("shading"))
                    this._$wrapper.css({
                        top: 0,
                        left: 0
                    })
            },
            _renderShadingDimensions: function() {
                if (this.option("shading"))
                    this._$wrapper.css({
                        width: "100%",
                        height: "100%"
                    })
            },
            _normalizePosition: function() {
                var position = this._getPosition();
                if (!position.of)
                    position.of = this.option("target");
                if (!position.collision)
                    position.collision = "flip";
                if (!position.boundaryOffset)
                    position.boundaryOffset = this.option("boundaryOffset");
                this._positionSide = this._getDisplaySide(position);
                this._position = position
            },
            _getDisplaySide: function(position) {
                var my = positionUtils.setup.normalizeAlign(position.my),
                    at = positionUtils.setup.normalizeAlign(position.at);
                var weightSign = WEIGHT_OF_SIDES[my.h] === WEIGHT_OF_SIDES[at.h] && WEIGHT_OF_SIDES[my.v] === WEIGHT_OF_SIDES[at.v] ? -1 : 1,
                    horizontalWeight = Math.abs(WEIGHT_OF_SIDES[my.h] - weightSign * WEIGHT_OF_SIDES[at.h]),
                    verticalWeight = Math.abs(WEIGHT_OF_SIDES[my.v] - weightSign * WEIGHT_OF_SIDES[at.v]);
                return horizontalWeight > verticalWeight ? at.h : at.v
            },
            _isVerticalSide: function(side) {
                side = side || this._positionSide;
                return side === "top" || side === "bottom"
            },
            _isHorizontalSide: function(side) {
                side = side || this._positionSide;
                return side === "left" || side === "right"
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"showTitle":
                    case"title":
                    case"titleTemplate":
                        this.callBase(args);
                        this._renderGeometry();
                        break;
                    case"target":
                    case"boundaryOffset":
                    case"arrowPosition":
                    case"arrowOffset":
                        this._renderGeometry();
                        break;
                    case"fullScreen":
                        if (args.value)
                            this.option("fullScreen", false);
                        break;
                    default:
                        this.callBase(args)
                }
            },
            show: function(target) {
                if (target)
                    this.option("target", target);
                return this.callBase()
            }
        }));
        ui.dxPopover.__internals = {
            POPOVER_CLASS: POPOVER_CLASS,
            POPOVER_WRAPPER_CLASS: POPOVER_WRAPPER_CLASS,
            POPOVER_ARROW_CLASS: POPOVER_ARROW_CLASS,
            POPOVER_WITHOUT_TITLE_CLASS: POPOVER_WITHOUT_TITLE_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.tooltip.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            registerComponent = DX.require("/componentRegistrator"),
            TOOLTIP_CLASS = "dx-tooltip",
            TOOLTIP_WRAPPER_CLASS = "dx-tooltip-wrapper",
            Z_INDEX_STACK = [],
            FIRST_Z_INDEX_OFFSET = -500;
        registerComponent("dxTooltip", ui, ui.dxPopover.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        buttons: [],
                        showCloseButton: false,
                        showTitle: false,
                        title: null,
                        titleTemplate: null,
                        onTitleRendered: null,
                        bottomTemplate: null
                    })
            },
            _render: function() {
                this.element().addClass(TOOLTIP_CLASS);
                this._wrapper().addClass(TOOLTIP_WRAPPER_CLASS);
                this.callBase()
            },
            _renderContent: function() {
                this.callBase();
                this._contentId = new DevExpress.data.Guid;
                this._$content.attr({
                    id: this._contentId,
                    role: "tooltip"
                });
                this._toggleAriaDescription(true)
            },
            _toggleAriaDescription: function(showing) {
                var $target = $(this.option("target")),
                    label = showing ? this._contentId : undefined;
                this.setAria("describedby", label, $target)
            },
            _zIndexStack: function() {
                return Z_INDEX_STACK
            },
            _zIndexInitValue: function() {
                return this.callBase() + FIRST_Z_INDEX_OFFSET
            }
        }));
        ui.dxTooltip.__internals = {
            TOOLTIP_CLASS: TOOLTIP_CLASS,
            TOOLTIP_WRAPPER_CLASS: TOOLTIP_WRAPPER_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.dropDownMenu.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget"),
            Button = DX.require("/ui/widgets/ui.button"),
            DataHelperMixin = DX.require("/ui/ui.dataHelper");
        var DROP_DOWN_MENU_CLASS = "dx-dropdownmenu",
            DROP_DOWN_MENU_POPUP_CLASS = "dx-dropdownmenu-popup",
            DROP_DOWN_MENU_POPUP_WRAPPER_CLASS = DROP_DOWN_MENU_POPUP_CLASS + "-wrapper",
            DROP_DOWN_MENU_LIST_CLASS = "dx-dropdownmenu-list",
            DROP_DOWN_MENU_BUTTON_CLASS = "dx-dropdownmenu-button";
        var POPUP_OPTION_MAP = {
                popupWidth: "width",
                popupHeight: "height"
            };
        var BUTTON_OPTION_MAP = {
                buttonIcon: "icon",
                buttonText: "text",
                buttonWidth: "width",
                buttonHeight: "height",
                buttonTemplate: "template"
            };
        registerComponent("dxDropDownMenu", ui, Widget.inherit({
            _supportedKeys: function() {
                return $.extend(this.callBase(), {tab: function(e) {
                            this._popup.hide()
                        }})
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {buttonIconSrc: {
                        since: "15.1",
                        alias: "buttonIcon"
                    }})
            },
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        items: [],
                        onItemClick: null,
                        dataSource: null,
                        itemTemplate: "item",
                        buttonText: "",
                        buttonIcon: "overflow",
                        buttonWidth: undefined,
                        buttonHeight: undefined,
                        buttonTemplate: "content",
                        onButtonClick: null,
                        usePopover: false,
                        popupWidth: "auto",
                        popupHeight: "auto",
                        activeStateEnabled: true,
                        hoverStateEnabled: true,
                        opened: false,
                        popupPosition: "bottom",
                        popupAnimation: undefined,
                        onItemRendered: null
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: [{platform: "ios"}],
                            options: {usePopover: true}
                        }, {
                            device: function(device) {
                                return devices.real().generic && !devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }, {
                            device: [{platform: "android"}],
                            options: {
                                popupPosition: {
                                    my: "top " + (this.option("rtlEnabled") ? "left" : "right"),
                                    at: "top " + (this.option("rtlEnabled") ? "left" : "right"),
                                    collision: "flipfit"
                                },
                                popupAnimation: {
                                    show: {
                                        type: "pop",
                                        duration: 200,
                                        from: {scale: 0},
                                        to: {scale: 1}
                                    },
                                    hide: {
                                        type: "pop",
                                        duration: 200,
                                        from: {scale: 1},
                                        to: {scale: 0}
                                    }
                                }
                            }
                        }])
            },
            _initOptions: function(options) {
                if (devices.current().platform === "android")
                    if (!options.popupPosition)
                        options.popupPosition = {at: (options.usePopover ? "bottom " : "top ") + (options.rtlEnabled ? "left" : "right")};
                this.callBase(options)
            },
            _dataSourceOptions: function() {
                return {paginate: false}
            },
            _init: function() {
                this.callBase();
                this.element().addClass(DROP_DOWN_MENU_CLASS);
                this._initDataSource();
                this._initItemClickAction();
                this._initButtonClickAction()
            },
            _initItemClickAction: function() {
                this._itemClickAction = this._createActionByOption("onItemClick")
            },
            _initButtonClickAction: function() {
                this._buttonClickAction = this._createActionByOption("onButtonClick")
            },
            _render: function() {
                this._renderButton();
                this.callBase();
                this.setAria({
                    role: "menubar",
                    haspopup: true,
                    expanded: this.option("opened")
                })
            },
            _clean: function() {
                this._cleanFocusState();
                this._popup.element().remove()
            },
            _renderContentImpl: function() {
                this._renderPopup()
            },
            _renderButton: function() {
                var $button = this.element().addClass(DROP_DOWN_MENU_BUTTON_CLASS),
                    config = this._buttonOptions();
                this._button = this._createComponent($button, Button, config);
                var keys = this._supportedKeys(),
                    buttonKeys = this._button._supportedKeys();
                this._supportedKeys = function() {
                    return $.extend(keys, buttonKeys)
                }
            },
            _buttonOptions: function() {
                return {
                        text: this.option("buttonText"),
                        icon: this.option("buttonIcon"),
                        width: this.option("buttonWidth"),
                        height: this.option("buttonHeight"),
                        template: this.option("buttonTemplate"),
                        focusStateEnabled: false,
                        onClick: $.proxy(function(e) {
                            this.option("opened", !this.option("opened"));
                            this._buttonClickAction(e)
                        }, this)
                    }
            },
            _toggleMenuVisibility: function(opened) {
                var state = opened === undefined ? !this._popup.option("visible") : opened;
                this._popup.toggle(state);
                this.setAria("expanded", state)
            },
            _renderPopup: function() {
                var $popup = this._$popup = $("<div>").appendTo(this.element()),
                    config = this._popupOptions(),
                    usePopup = !this.option("usePopover");
                this._popup = this._createComponent($popup, "dxPopover", config);
                this._popup._wrapper().addClass(DROP_DOWN_MENU_POPUP_WRAPPER_CLASS);
                this._popup._wrapper().toggleClass(DROP_DOWN_MENU_POPUP_CLASS, usePopup)
            },
            _popupOptions: function() {
                return {
                        onContentReady: $.proxy(this._popupContentReadyHandler, this),
                        deferRendering: false,
                        position: this.option("popupPosition"),
                        animation: this.option("popupAnimation"),
                        onOptionChanged: $.proxy(function(args) {
                            if (args.name === "visible")
                                this.option("opened", args.value)
                        }, this),
                        target: this.element(),
                        height: this.option("popupHeight"),
                        width: this.option("popupWidth")
                    }
            },
            _popupContentReadyHandler: function() {
                var popup = this._$popup.dxPopover("instance");
                this._renderList(popup)
            },
            _renderList: function(instance) {
                var $content = instance.content(),
                    listConfig = this._listOptions();
                $content.addClass(DROP_DOWN_MENU_LIST_CLASS);
                this._list = this._createComponent($content, "dxList", listConfig);
                this._list._getAriaTarget = $.proxy(function() {
                    return this.element()
                }, this);
                this._setListDataSource();
                var listMaxHeight = $(window).height() * 0.5;
                if ($content.height() > listMaxHeight)
                    $content.height(listMaxHeight)
            },
            _listOptions: function() {
                return {
                        _keyboardProcessor: this._listProcessor,
                        pageLoadMode: "scrollBottom",
                        indicateLoading: false,
                        noDataText: "",
                        itemTemplate: this._getTemplateByOption("itemTemplate"),
                        onItemClick: $.proxy(function(e) {
                            this.option("opened", false);
                            this._itemClickAction(e)
                        }, this),
                        tabIndex: -1,
                        focusStateEnabled: this.option("focusStateEnabled"),
                        activeStateEnabled: this.option("activeStateEnabled"),
                        onItemRendered: this.option("onItemRendered"),
                        _itemAttributes: {role: "menuitem"}
                    }
            },
            _setListDataSource: function() {
                if (this._list)
                    this._list.option("dataSource", this._dataSource || this.option("items"))
            },
            _attachKeyboardEvents: function() {
                this.callBase.apply(this, arguments);
                this._listProcessor = this._keyboardProcessor.attachChildProcessor();
                if (this._list)
                    this._list.option("_keyboardProcessor", this._listProcessor)
            },
            _cleanFocusState: function() {
                this.callBase.apply(this, arguments);
                delete this._listProcessor
            },
            _toggleVisibility: function(visible) {
                this.callBase(visible);
                this._button.option("visible", visible)
            },
            _optionChanged: function(args) {
                var name = args.name;
                var value = args.value;
                switch (name) {
                    case"items":
                    case"dataSource":
                        this._refreshDataSource();
                        this._setListDataSource();
                        break;
                    case"itemTemplate":
                        if (this._list)
                            this._list.option(name, this._getTemplate(value));
                        break;
                    case"onItemClick":
                        this._initItemClickAction();
                        break;
                    case"onButtonClick":
                        this._buttonClickAction();
                        break;
                    case"buttonIcon":
                    case"buttonText":
                    case"buttonWidth":
                    case"buttonHeight":
                    case"buttonTemplate":
                        this._button.option(BUTTON_OPTION_MAP[name], value);
                        this._renderPopup();
                        break;
                    case"popupWidth":
                    case"popupHeight":
                        this._popup.option(POPUP_OPTION_MAP[name], value);
                        break;
                    case"usePopover":
                        this._invalidate();
                        break;
                    case"focusStateEnabled":
                    case"activeStateEnabled":
                        if (this._list)
                            this._list.option(name, value);
                        this.callBase(args);
                        break;
                    case"onItemRendered":
                        if (this._list)
                            this._list.option(name, value);
                        break;
                    case"opened":
                        this._toggleMenuVisibility(value);
                        break;
                    case"popupPosition":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            open: function() {
                this.option("opened", true)
            },
            close: function() {
                this.option("opened", false)
            }
        }).include(DataHelperMixin))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.dateUtils.js */
    DevExpress.define("/ui/widgets/date/ui.dateUtils", ["jquery"], function($) {
        var dateCopmotents = function() {
                return ["year", "day", "month", "day"]
            };
        var ONE_MINUTE = 1000 * 60;
        var ONE_DAY = ONE_MINUTE * 60 * 24;
        var ONE_YEAR = ONE_DAY * 365;
        var dateUtils = DevExpress.ui.dateUtils = {
                SUPPORTED_FORMATS: ["date", "time", "datetime"],
                DEFAULT_FORMATTER: function(value) {
                    return value
                },
                DATE_COMPONENT_TEXT_FORMATTER: function(value, name) {
                    var $container = $("<div>").addClass("dx-dateview-formatter-container");
                    $("<span>").text(value).addClass("dx-dateview-value-formatter").appendTo($container);
                    $("<span>").text(name).addClass("dx-dateview-name-formatter").appendTo($container);
                    return $container
                },
                ONE_MINUTE: ONE_MINUTE,
                ONE_DAY: ONE_DAY,
                ONE_YEAR: ONE_YEAR,
                MIN_DATEVIEW_DEFAULT_DATE: new Date(1900, 1, 1),
                MAX_DATEVIEW_DEFAULT_DATE: new Date((new Date).setHours(23, 59, 59) + 50 * ONE_YEAR),
                FORMATS_INFO: {
                    date: {
                        standardPattern: "yyyy-MM-dd",
                        components: dateCopmotents()
                    },
                    time: {
                        standardPattern: "HH:mm",
                        components: ["hours", "minutes"]
                    },
                    datetime: {
                        standardPattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'",
                        components: dateCopmotents().concat(["hours", "minutes", "seconds", "milliseconds"])
                    },
                    "datetime-local": {
                        standardPattern: "yyyy'-'MM'-'dd'T'HH':'mm",
                        components: dateCopmotents().concat(["hours", "minutes", "seconds"])
                    }
                },
                FORMATS_MAP: {
                    date: "d",
                    time: "t",
                    datetime: "S",
                    "datetime-local": "f"
                },
                toStandardDateFormat: function(date, mode, pattern) {
                    pattern = pattern || dateUtils.FORMATS_INFO[mode].standardPattern;
                    return Globalize.format(date, pattern)
                },
                fromStandardDateFormat: function(date) {
                    return Globalize.parseDate(date, dateUtils.FORMATS_INFO["datetime"].standardPattern) || Globalize.parseDate(date, dateUtils.FORMATS_INFO["datetime-local"].standardPattern) || Globalize.parseDate(date, dateUtils.FORMATS_INFO["time"].standardPattern) || Globalize.parseDate(date, dateUtils.FORMATS_INFO["date"].standardPattern) || Date.parse && Date.parse(date) && new Date(Date.parse(date))
                },
                getMaxMonthDay: function(year, month) {
                    return new Date(year, month + 1, 0).getDate()
                },
                mergeDates: function(target, source, format) {
                    if (!source)
                        return undefined;
                    if (isNaN(target.getTime()))
                        target = new Date(0, 0, 0, 0, 0, 0);
                    var formatInfo = dateUtils.FORMATS_INFO[format];
                    $.each(formatInfo.components, function() {
                        var componentInfo = dateUtils.DATE_COMPONENTS_INFO[this];
                        target[componentInfo.setter](source[componentInfo.getter]())
                    });
                    return target
                },
                getLongestCaptionIndex: function(captionArray) {
                    var longestIndex = 0,
                        longestCaptionLength = 0,
                        i;
                    for (i = 0; i < captionArray.length; ++i)
                        if (captionArray[i].length > longestCaptionLength) {
                            longestIndex = i;
                            longestCaptionLength = captionArray[i].length
                        }
                    return longestIndex
                },
                expandPattern: function(pattern) {
                    return pattern.length === 1 ? Globalize.culture().calendar.patterns[pattern] : pattern
                },
                formatUsesMonthName: function(format) {
                    return dateUtils.expandPattern(format).indexOf("MMMM") !== -1
                },
                formatUsesDayName: function(format) {
                    return dateUtils.expandPattern(format).indexOf("dddd") !== -1
                },
                getLongestDate: function(format, monthNames, dayNames) {
                    var longestDate = new Date(1888, dateUtils.formatUsesMonthName(format) ? dateUtils.getLongestCaptionIndex(monthNames) : 9, 28 - 7, 23, 59, 59, 999);
                    if (dateUtils.formatUsesDayName(format))
                        longestDate.setDate(longestDate.getDate() - longestDate.getDay() + dateUtils.getLongestCaptionIndex(dayNames));
                    return longestDate
                },
                calculateMaximumDateFormatWidth: function(format, customFontStyles, rootElement) {
                    if (!rootElement || $(rootElement).is(":visible")) {
                        var width,
                            ieRoundingError = 2,
                            longestTextDiv = $("<div>" + Globalize.format(dateUtils.getLongestDate(format, Globalize.culture().calendar.months.names, Globalize.culture().calendar.days.names), format) + "</div>").css({
                                visibility: "hidden",
                                "white-space": "nowrap",
                                position: "absolute",
                                float: "left"
                            });
                        if (customFontStyles)
                            longestTextDiv.css(customFontStyles);
                        longestTextDiv.appendTo(rootElement ? $(rootElement) : $("body"));
                        width = longestTextDiv.width() + ieRoundingError;
                        longestTextDiv.remove();
                        return width
                    }
                }
            };
        dateUtils.DATE_COMPONENTS_INFO = {
            year: {
                getter: "getFullYear",
                setter: "setFullYear",
                possibleFormats: ["yy", "yyyy"],
                formatter: dateUtils.DEFAULT_FORMATTER,
                startValue: undefined,
                endValue: undefined
            },
            day: {
                getter: "getDate",
                setter: "setDate",
                possibleFormats: ["d", "dd"],
                formatter: function(value, showNames, date) {
                    if (!showNames)
                        return value;
                    var formatDate = new Date(date.getTime());
                    formatDate.setDate(value);
                    return dateUtils.DATE_COMPONENT_TEXT_FORMATTER(value, Globalize.culture().calendar.days.names[formatDate.getDay()])
                },
                startValue: 1,
                endValue: undefined
            },
            month: {
                getter: "getMonth",
                setter: "setMonth",
                possibleFormats: ["M", "MM", "MMM", "MMMM"],
                formatter: function(value, showNames) {
                    var monthName = Globalize.culture().calendar.months.names[value];
                    return showNames ? dateUtils.DATE_COMPONENT_TEXT_FORMATTER(value + 1, monthName) : monthName
                },
                startValue: 0,
                endValue: 11
            },
            hours: {
                getter: "getHours",
                setter: "setHours",
                possibleFormats: ["H", "HH", "h", "hh"],
                formatter: function(value) {
                    return Globalize.format(new Date(0, 0, 0, value), "HH")
                },
                startValue: 0,
                endValue: 23
            },
            minutes: {
                getter: "getMinutes",
                setter: "setMinutes",
                possibleFormats: ["m", "mm"],
                formatter: function(value) {
                    return Globalize.format(new Date(0, 0, 0, 0, value), "mm")
                },
                startValue: 0,
                endValue: 59
            },
            seconds: {
                getter: "getSeconds",
                setter: "setSeconds",
                possibleFormats: ["s", "ss"],
                formatter: function(value) {
                    return Globalize.format(new Date(0, 0, 0, 0, 0, value), "ss")
                },
                startValue: 0,
                endValue: 59
            },
            milliseconds: {
                getter: "getMilliseconds",
                setter: "setMilliseconds",
                possibleFormats: ["f", "ff", "fff"],
                formatter: function(value) {
                    return Globalize.format(new Date(0, 0, 0, 0, 0, 0, value), "fff")
                },
                startValue: 0,
                endValue: 999
            }
        };
        (function androidFormatDetection() {
            var androidFormatPattern = "yyyy'-'MM'-'dd'T'HH':'mm'Z'";
            var $input = $("<input>").attr("type", "datetime");
            $input.val(dateUtils.toStandardDateFormat(new Date, "datetime", androidFormatPattern));
            if ($input.val())
                dateUtils.FORMATS_INFO.datetime.standardPattern = androidFormatPattern
        })();
        return dateUtils
    });
    /*! Module widgets-base, file ui.calendar.navigator.js */
    DevExpress.define("/ui/widgets/date/ui.calendar.navigator", ["jquery", "/ui/ui.widget", "/ui/widgets/ui.button", "/componentRegistrator"], function($, Widget, Button, registerComponent) {
        var CALENDAR_NAVIGATOR_CLASS = "dx-calendar-navigator",
            CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS = "dx-calendar-navigator-previous-month",
            CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS = "dx-calendar-navigator-next-month",
            CALENDAR_NAVIGATOR_PREVIOUS_VIEW_CLASS = "dx-calendar-navigator-previous-view",
            CALENDAR_NAVIGATOR_NEXT_VIEW_CLASS = "dx-calendar-navigator-next-view",
            CALENDAR_NAVIGATOR_DISABLED_LINK_CLASS = "dx-calendar-disabled-navigator-link",
            CALENDAR_NAVIGATOR_CAPTION_BUTTON_CLASS = "dx-calendar-caption-button";
        var Navigator = Widget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            onClick: null,
                            onCaptionClick: null,
                            text: ""
                        })
                },
                _init: function() {
                    this.callBase();
                    this._initActions()
                },
                _initActions: function() {
                    this._clickAction = this._createActionByOption("onClick");
                    this._captionClickAction = this._createActionByOption("onCaptionClick")
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(CALENDAR_NAVIGATOR_CLASS);
                    this._renderButtons();
                    this._renderCaption()
                },
                _renderButtons: function() {
                    var that = this,
                        direction = this.option("rtlEnabled") ? -1 : 1;
                    this._prevButton = this._createComponent($("<a>"), Button, {
                        focusStateEnabled: false,
                        icon: "chevronleft",
                        onClick: function(e) {
                            that._clickAction({
                                direction: -direction,
                                jQueryEvent: e
                            })
                        },
                        _templates: {}
                    });
                    var $prevButton = this._prevButton.element().addClass(CALENDAR_NAVIGATOR_PREVIOUS_VIEW_CLASS).addClass(CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS);
                    this._nextButton = this._createComponent($("<a>"), Button, {
                        focusStateEnabled: false,
                        icon: "chevronright",
                        onClick: function(e) {
                            that._clickAction({
                                direction: direction,
                                jQueryEvent: e
                            })
                        },
                        _templates: {}
                    });
                    var $nextButton = this._nextButton.element().addClass(CALENDAR_NAVIGATOR_NEXT_VIEW_CLASS).addClass(CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS);
                    this._caption = this._createComponent($("<a>").addClass(CALENDAR_NAVIGATOR_CAPTION_BUTTON_CLASS), Button, {
                        focusStateEnabled: false,
                        onClick: function(e) {
                            that._captionClickAction({jQueryEvent: e})
                        },
                        _templates: {}
                    });
                    var $caption = this._caption.element();
                    this.element().append($prevButton, $caption, $nextButton)
                },
                _renderCaption: function(caption) {
                    this._caption.option("text", this.option("text"))
                },
                toggleButton: function(buttonPrefix, value) {
                    var buttonName = "_" + buttonPrefix + "Button",
                        button = this[buttonName];
                    if (button) {
                        button.option("disabled", value);
                        button.element().toggleClass(CALENDAR_NAVIGATOR_DISABLED_LINK_CLASS, value)
                    }
                },
                _optionChanged: function(args) {
                    var value = args.value;
                    switch (args.name) {
                        case"text":
                            this._renderCaption(value);
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        return Navigator
    });
    /*! Module widgets-base, file ui.calendar.baseView.js */
    DevExpress.define("/ui/widgets/date/ui.calendar.baseView", ["jquery", "/utils/utils.inflector", "/utils/utils.date", "/ui/ui.widget", "/ui/events/ui.events.utils"], function($, inflector, dateUtils, Widget, eventUtils) {
        var abstract = Widget.abstract,
            CALENDAR_OTHER_VIEW_CLASS = "dx-calendar-other-view",
            CALENDAR_CELL_CLASS = "dx-calendar-cell",
            CALENDAR_EMPTY_CELL_CLASS = "dx-calendar-empty-cell",
            CALENDAR_TODAY_CLASS = "dx-calendar-today",
            CALENDAR_SELECTED_DATE_CLASS = "dx-calendar-selected-date",
            CALENDAR_CONTOURED_DATE_CLASS = "dx-calendar-contoured-date",
            CALENDAR_DXCLICK_EVENT_NAME = eventUtils.addNamespace("dxclick", "dxCalendar"),
            CALENDAR_DATE_VALUE_KEY = "dxDateValueKey";
        var BaseView = Widget.inherit({
                _getViewName: function() {
                    return "base"
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            date: new Date,
                            focusStateEnabled: false,
                            cellTemplate: null,
                            onCellClick: null,
                            rowCount: 3,
                            colCount: 4,
                            allowValueSelection: true
                        })
                },
                _init: function() {
                    this.callBase();
                    var value = this.option("value");
                    this.option("value", new Date(value));
                    if (!this.option("value").valueOf())
                        this.option("value", new Date(0, 0, 0, 0, 0, 0))
                },
                _render: function() {
                    this.callBase();
                    this._renderImpl()
                },
                _renderImpl: function() {
                    this._$table = $("<table>");
                    this._renderBody();
                    this._renderContouredDate();
                    this._renderValue();
                    this._renderEvents();
                    this.element().append(this._$table)
                },
                _renderBody: function() {
                    this.$body = $("<tbody>").appendTo(this._$table);
                    var that = this,
                        cellTemplate = this.option("cellTemplate");
                    function renderCell(cellIndex) {
                        var cellDate = that._getCellData(indexRow, cellIndex);
                        var $cell = $("<td>").appendTo($row).addClass(CALENDAR_CELL_CLASS).toggleClass(CALENDAR_TODAY_CLASS, that._isTodayCell(cellDate)).toggleClass(CALENDAR_EMPTY_CELL_CLASS, that._isDateOutOfRange(cellDate)).toggleClass(CALENDAR_OTHER_VIEW_CLASS, that._isOtherView(cellDate)).attr("data-value", dateUtils.getShortDate(cellDate)).data(CALENDAR_DATE_VALUE_KEY, cellDate);
                        that.setAria({
                            role: "option",
                            label: that.getCellAriaLabel(cellDate)
                        }, $cell);
                        if (cellTemplate)
                            cellTemplate.render({
                                text: that._getCellText(cellDate),
                                date: cellDate,
                                view: that._getViewName()
                            }, $cell, cellIndex);
                        else
                            $cell.text(that._getCellText(cellDate))
                    }
                    for (var indexRow = 0, len = this.option("rowCount"); indexRow < len; indexRow++) {
                        var $row = $("<tr>").appendTo(this.$body);
                        this._iterateCells(renderCell)
                    }
                },
                _iterateCells: function(delegate) {
                    var rtl = this.option("rtl"),
                        colCount = this.option("colCount"),
                        i = rtl ? colCount - 1 : 0;
                    while (rtl ? i >= 0 : i < colCount) {
                        delegate(i);
                        rtl ? --i : ++i
                    }
                },
                _renderEvents: function() {
                    this._createCellClickAction();
                    this._$table.off(CALENDAR_DXCLICK_EVENT_NAME).on(CALENDAR_DXCLICK_EVENT_NAME, "td", $.proxy(function(e) {
                        if (!$(e.currentTarget).hasClass(CALENDAR_EMPTY_CELL_CLASS))
                            this._cellClickAction({
                                jQueryEvent: e,
                                value: $(e.currentTarget).data(CALENDAR_DATE_VALUE_KEY)
                            })
                    }, this));
                    this.element().off("beforeactivate").on("beforeactivate", function(e) {
                        e.preventDefault()
                    })
                },
                _createCellClickAction: function(e) {
                    this._cellClickAction = this._createActionByOption("onCellClick")
                },
                _isTodayCell: abstract,
                _isDateOutOfRange: abstract,
                _isOtherView: abstract,
                _getCellText: abstract,
                _getCellData: abstract,
                _renderContouredDate: function(contouredDate) {
                    if (!this.option("focusStateEnabled"))
                        return;
                    contouredDate = contouredDate || this.option("contouredDate");
                    var $oldContouredCell = this._$table.find("." + CALENDAR_CONTOURED_DATE_CLASS);
                    var $newContouredCell = this._getCellByDate(contouredDate);
                    $oldContouredCell.removeClass(CALENDAR_CONTOURED_DATE_CLASS);
                    $newContouredCell.addClass(CALENDAR_CONTOURED_DATE_CLASS)
                },
                _dispose: function() {
                    this._keyboardProcessor = undefined;
                    this.callBase()
                },
                _changeValue: function(cellDate) {
                    if (cellDate) {
                        var value = this.option("value"),
                            newValue = value ? new Date(value) : new Date;
                        newValue.setDate(cellDate.getDate());
                        newValue.setMonth(cellDate.getMonth());
                        newValue.setFullYear(cellDate.getFullYear());
                        newValue.setDate(cellDate.getDate());
                        this.option("value", newValue)
                    }
                    else
                        this.option("value", null)
                },
                _renderValue: function() {
                    if (!this.option("allowValueSelection"))
                        return;
                    var value = this.option("value"),
                        selectedCell = this._getCellByDate(value);
                    if (this._selectedCell)
                        this._selectedCell.removeClass(CALENDAR_SELECTED_DATE_CLASS);
                    selectedCell.addClass(CALENDAR_SELECTED_DATE_CLASS);
                    this._selectedCell = selectedCell
                },
                getCellAriaLabel: function(date) {
                    return this._getCellText(date)
                },
                _getFirstAvailableDate: function() {
                    var date = this.option("date"),
                        min = this.option("min");
                    date = dateUtils.getFirstDateView(this._getViewName(), date);
                    return new Date(min && date < min ? min : date)
                },
                _getCellByDate: abstract,
                isBoundary: abstract,
                _optionChanged: function(args) {
                    var name = args.name;
                    switch (name) {
                        case"value":
                            this._renderValue();
                            break;
                        case"contouredDate":
                            this._renderContouredDate(args.value);
                            break;
                        case"onCellClick":
                            this._createCellClickAction();
                            break;
                        case"cellTemplate":
                            this._invalidate();
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        return BaseView
    });
    /*! Module widgets-base, file ui.calendar.views.js */
    DevExpress.define("/ui/widgets/date/ui.calendar.views", ["jquery", "/utils/utils.date", "/utils/utils.common", "/ui/widgets/date/ui.calendar.baseView"], function($, dateUtils, commonUtils, BaseView) {
        var CALENDAR_OTHER_MONTH_CLASS = "dx-calendar-other-month",
            CALENDAR_OTHER_VIEW_CLASS = "dx-calendar-other-view";
        var Views = {
                month: BaseView.inherit({
                    _getViewName: function() {
                        return "month"
                    },
                    _getDefaultOptions: function() {
                        return $.extend(this.callBase(), {
                                firstDayOfWeek: undefined,
                                rowCount: 6,
                                colCount: 7
                            })
                    },
                    _renderImpl: function() {
                        this.callBase();
                        this._renderHeader()
                    },
                    _renderBody: function() {
                        this.callBase();
                        this._$table.find("." + CALENDAR_OTHER_VIEW_CLASS).addClass(CALENDAR_OTHER_MONTH_CLASS)
                    },
                    _renderFocusTarget: $.noop,
                    getCellAriaLabel: function(date) {
                        return Globalize.format(date, "D")
                    },
                    _renderHeader: function() {
                        var that = this,
                            $header = $("<thead>").prependTo(this._$table),
                            $headerRow = $("<tr>").appendTo($header);
                        this._iterateCells(function(i) {
                            $("<th>").text(that._getDayCaption(that._getFirstDayOfWeek() + i)).appendTo($headerRow)
                        })
                    },
                    getNavigatorCaption: function() {
                        var navigatorMonth = Globalize.culture().calendar.months.names[this.option("date").getMonth()],
                            navigatorYear = this.option("date").getFullYear();
                        return this.option("rtl") ? navigatorYear + " " + navigatorMonth : navigatorMonth + " " + navigatorYear
                    },
                    _isTodayCell: function(cellDate) {
                        var today = new Date;
                        return dateUtils.sameMonthAndYear(cellDate, today) && cellDate.getDate() === today.getDate()
                    },
                    _isDateOutOfRange: function(cellDate) {
                        var minDate = this.option("min"),
                            maxDate = this.option("max");
                        return !dateUtils.dateInRange(cellDate, minDate, maxDate, "date")
                    },
                    _isOtherView: function(cellDate) {
                        return cellDate.getMonth() !== this.option("date").getMonth()
                    },
                    _getCellText: function(cellDate) {
                        return cellDate.getDate()
                    },
                    _getDayCaption: function(day) {
                        var daysInWeek = this.option("colCount");
                        return Globalize.culture().calendar.days.namesAbbr[day % daysInWeek]
                    },
                    _getCellData: function(week, day) {
                        var firstDay = dateUtils.getFirstMonthDate(this.option("date")),
                            firstMonthDayPosition = firstDay.getDay() - this._getFirstDayOfWeek(),
                            daysInWeek = this.option("colCount"),
                            firstWeekDay = daysInWeek * week - firstMonthDayPosition;
                        firstWeekDay = firstMonthDayPosition < 0 ? firstWeekDay - daysInWeek : firstWeekDay;
                        firstDay.setDate(firstDay.getDate() + firstWeekDay + day);
                        return firstDay
                    },
                    _getFirstDayOfWeek: function() {
                        return this.option("firstDayOfWeek") || Globalize.culture().calendar.firstDay
                    },
                    _getCellByDate: function(date) {
                        return this._$table.find("td[data-value='" + dateUtils.getShortDate(date) + "']")
                    },
                    isBoundary: function(date) {
                        return dateUtils.sameMonthAndYear(date, this.option("min")) || dateUtils.sameMonthAndYear(date, this.option("max"))
                    }
                }),
                year: BaseView.inherit({
                    _getViewName: function() {
                        return "year"
                    },
                    _isTodayCell: function(cellDate) {
                        return dateUtils.sameMonthAndYear(cellDate, new Date)
                    },
                    _isDateOutOfRange: function(cellDate) {
                        return !dateUtils.dateInRange(cellDate, dateUtils.getFirstMonthDate(this.option("min")), dateUtils.getLastMonthDate(this.option("max")))
                    },
                    _isOtherView: function(cellDate) {
                        return false
                    },
                    _getCellText: function(cellDate) {
                        return Globalize.culture().calendar.months.names[cellDate.getMonth()].slice(0, 3)
                    },
                    _getCellData: function(indexRow, cellIndex) {
                        var data = new Date(this.option("date")),
                            colCount = this.option("colCount");
                        data.setDate(1);
                        data.setMonth(indexRow * colCount + cellIndex);
                        return data
                    },
                    _getCellByDate: function(date) {
                        var foundDate = new Date(date);
                        foundDate.setDate(1);
                        return this._$table.find("td[data-value='" + dateUtils.getShortDate(foundDate) + "']")
                    },
                    getCellAriaLabel: function(date) {
                        return Globalize.format(date, "Y")
                    },
                    getNavigatorCaption: function() {
                        return this.option("date").getFullYear()
                    },
                    isBoundary: function(date) {
                        return dateUtils.sameYear(date, this.option("min")) || dateUtils.sameYear(date, this.option("max"))
                    }
                }),
                decade: BaseView.inherit({
                    _getViewName: function() {
                        return "decade"
                    },
                    _isTodayCell: function(cellDate) {
                        return dateUtils.sameYear(cellDate, new Date)
                    },
                    _isDateOutOfRange: function(cellDate) {
                        var min = this.option("min"),
                            max = this.option("max");
                        return !dateUtils.dateInRange(cellDate.getFullYear(), min && min.getFullYear(), max && max.getFullYear())
                    },
                    _isOtherView: function(cellDate) {
                        var date = new Date(cellDate);
                        date.setMonth(1);
                        return !dateUtils.sameDecade(date, this.option("date"))
                    },
                    _getCellText: function(cellDate) {
                        return cellDate.getFullYear()
                    },
                    _getCellData: function(indexRow, cellIndex) {
                        var colCount = this.option("colCount"),
                            year = dateUtils.getFirstYearInDecade(this.option("date")) - 1 + indexRow * colCount + cellIndex;
                        return new Date(year, 0, 1)
                    },
                    getNavigatorCaption: function() {
                        var year = dateUtils.getFirstYearInDecade(this.option("date"));
                        return year + "-" + (year + 9)
                    },
                    _isValueOnCurrentView: function(currentDate, value) {
                        return dateUtils.sameDecade(currentDate, value)
                    },
                    _getCellByDate: function(date) {
                        var foundDate = new Date(date);
                        foundDate.setDate(1);
                        foundDate.setMonth(0);
                        return this._$table.find("td[data-value='" + dateUtils.getShortDate(foundDate) + "']")
                    },
                    isBoundary: function(date) {
                        return dateUtils.sameDecade(date, this.option("min")) || dateUtils.sameDecade(date, this.option("max"))
                    }
                }),
                century: BaseView.inherit({
                    _getViewName: function() {
                        return "century"
                    },
                    _isTodayCell: function(cellDate) {
                        return dateUtils.sameDecade(cellDate, new Date)
                    },
                    _isDateOutOfRange: function(cellDate) {
                        var decade = dateUtils.getFirstYearInDecade(cellDate),
                            minDecade = dateUtils.getFirstYearInDecade(this.option("min")),
                            maxDecade = dateUtils.getFirstYearInDecade(this.option("max"));
                        return !dateUtils.dateInRange(decade, minDecade, maxDecade)
                    },
                    _isOtherView: function(cellDate) {
                        var date = new Date(cellDate);
                        date.setMonth(1);
                        return !dateUtils.sameCentury(date, this.option("date"))
                    },
                    _getCellText: function(cellDate) {
                        var decade = cellDate.getFullYear();
                        return decade + " - " + (decade + 9)
                    },
                    _getCellData: function(indexRow, cellIndex) {
                        var colCount = this.option("colCount"),
                            decade = dateUtils.getFirstDecadeInCentury(this.option("date")) + (-1 + indexRow * colCount + cellIndex) * 10;
                        return new Date(decade, 0, 1)
                    },
                    _getCellByDate: function(date) {
                        var foundDate = new Date(date);
                        foundDate.setDate(1);
                        foundDate.setMonth(0);
                        foundDate.setFullYear(dateUtils.getFirstYearInDecade(foundDate));
                        return this._$table.find("td[data-value='" + dateUtils.getShortDate(foundDate) + "']")
                    },
                    getNavigatorCaption: function() {
                        var decade = dateUtils.getFirstDecadeInCentury(this.option("date"));
                        return decade + "-" + (decade + 99)
                    },
                    isBoundary: function(date) {
                        return dateUtils.sameCentury(date, this.option("min")) || dateUtils.sameCentury(date, this.option("max"))
                    }
                })
            };
        return Views
    });
    /*! Module widgets-base, file ui.calendar.js */
    DevExpress.define("/ui/widgets/date/ui.calendar", ["jquery", "/ui/uiNamespace", "/utils/utils.translator", "/utils/utils.browser", "/utils/utils.date", "/utils/utils.common", "/devices", "/ui/widgets/ui.button", "/ui/ui.editor", "/componentRegistrator", "/ui/ui.keyboardProcessor", "/ui/widgets/date/ui.calendar.navigator", "/ui/widgets/date/ui.calendar.views"], function($, uiNamespace, translator, browser, dateUtils, commonUtils, devices, Button, Editor, registerComponent, KeyboardProcessor, Navigator, Views) {
        var fx = DevExpress.fx;
        var CALENDAR_CLASS = "dx-calendar",
            CALENDAR_BODY_CLASS = "dx-calendar-body",
            CALENDAR_CELL_CLASS = "dx-calendar-cell",
            CALENDAR_FOOTER_CLASS = "dx-calendar-footer",
            CALENDAR_TODAY_BUTTON_CLASS = "dx-calendar-today-button",
            CALENDAR_HAS_FOOTER_CLASS = "dx-calendar-with-footer",
            CALENDAR_VIEWS_WRAPPER_CLASS = "dx-calendar-views-wrapper",
            CALENDAR_VIEW_CLASS = "dx-calendar-view",
            FOCUSED_STATE_CLASS = "dx-state-focused",
            ANIMATION_DURATION_SHOW_VIEW = 250,
            POP_ANIMATION_FROM = 0.6,
            POP_ANIMATION_TO = 1,
            CALENDAR_DATE_VALUE_KEY = "dxDateValueKey",
            LEVEL_COMPARE_MAP = {
                month: 3,
                year: 2,
                decade: 1,
                century: 0
            };
        var Calendar = Editor.inherit({
                _activeStateUnit: "." + CALENDAR_CELL_CLASS,
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            hoverStateEnabled: true,
                            activeStateEnabled: true,
                            currentDate: new Date,
                            min: new Date(1000, 0),
                            max: new Date(3000, 0),
                            firstDayOfWeek: undefined,
                            zoomLevel: "month",
                            maxZoomLevel: "month",
                            minZoomLevel: "century",
                            showTodayButton: false,
                            cellTemplate: "cell",
                            onCellClick: null,
                            onContouredChanged: null,
                            hasFocus: function(element) {
                                return element.hasClass(FOCUSED_STATE_CLASS)
                            }
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function() {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }])
                },
                _supportedKeys: function() {
                    return $.extend(this.callBase(), {
                            rightArrow: function(e) {
                                e.preventDefault();
                                if (e.ctrlKey)
                                    this._waitRenderView(1);
                                else
                                    this._moveCurrentDate(1 * this._getRtlCorrection())
                            },
                            leftArrow: function(e) {
                                e.preventDefault();
                                if (e.ctrlKey)
                                    this._waitRenderView(-1);
                                else
                                    this._moveCurrentDate(-1 * this._getRtlCorrection())
                            },
                            upArrow: function(e) {
                                e.preventDefault();
                                if (e.ctrlKey)
                                    this._navigateUp();
                                else {
                                    if (fx.isAnimating(this._view.element()))
                                        return;
                                    this._moveCurrentDate(-1 * this._view.option("colCount"))
                                }
                            },
                            downArrow: function(e) {
                                e.preventDefault();
                                if (e.ctrlKey)
                                    this._navigateDown();
                                else {
                                    if (fx.isAnimating(this._view.element()))
                                        return;
                                    this._moveCurrentDate(1 * this._view.option("colCount"))
                                }
                            },
                            home: function(e) {
                                e.preventDefault();
                                var zoomLevel = this.option("zoomLevel");
                                var currentDate = this.option("currentDate");
                                var min = this.option("min");
                                var date = dateUtils.sameView(zoomLevel, currentDate, min) ? min : dateUtils.getViewFirstCellDate(zoomLevel, currentDate);
                                this.option("currentDate", date)
                            },
                            end: function(e) {
                                e.preventDefault();
                                var zoomLevel = this.option("zoomLevel");
                                var currentDate = this.option("currentDate");
                                var max = this.option("max");
                                var date = dateUtils.sameView(zoomLevel, currentDate, max) ? max : dateUtils.getViewLastCellDate(zoomLevel, currentDate);
                                this.option("currentDate", date)
                            },
                            pageUp: function(e) {
                                e.preventDefault();
                                this._waitRenderView(-1)
                            },
                            pageDown: function(e) {
                                e.preventDefault();
                                this._waitRenderView(1)
                            },
                            tab: $.noop,
                            enter: function(e) {
                                if (!this._isMaxZoomLevel())
                                    this._navigateDown();
                                else {
                                    var value = this._updateTimeComponent(this.option("currentDate"));
                                    this.option("value", value)
                                }
                            }
                        })
                },
                _moveCurrentDate: function(offset) {
                    var currentDate = new Date(this.option("currentDate"));
                    var newDate = new Date(currentDate);
                    var zoomLevel = this.option("zoomLevel");
                    switch (zoomLevel) {
                        case"month":
                            newDate.setDate(currentDate.getDate() + offset);
                            break;
                        case"year":
                            newDate.setMonth(currentDate.getMonth() + offset);
                            break;
                        case"decade":
                            newDate.setFullYear(currentDate.getFullYear() + offset);
                            break;
                        case"century":
                            newDate.setFullYear(currentDate.getFullYear() + 10 * offset);
                            break
                    }
                    var offsetCorrection = 2 * offset / Math.abs(offset);
                    if (Math.abs(offset) > 1 && !dateUtils.sameView(zoomLevel, currentDate, newDate)) {
                        if (zoomLevel === "decade")
                            newDate.setFullYear(currentDate.getFullYear() + offset - offsetCorrection);
                        if (zoomLevel === "century")
                            newDate.setFullYear(currentDate.getFullYear() + 10 * (offset - offsetCorrection))
                    }
                    this.option("currentDate", newDate)
                },
                _init: function() {
                    this.callBase();
                    this._correctZoomLevel();
                    this._initCurrentDate();
                    this._initActions()
                },
                _correctZoomLevel: function() {
                    var minZoomLevel = this.option("minZoomLevel"),
                        maxZoomLevel = this.option("maxZoomLevel"),
                        zoomLevel = this.option("zoomLevel");
                    if (LEVEL_COMPARE_MAP[maxZoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel])
                        return;
                    if (LEVEL_COMPARE_MAP[zoomLevel] > LEVEL_COMPARE_MAP[maxZoomLevel])
                        this.option("zoomLevel", maxZoomLevel);
                    else if (LEVEL_COMPARE_MAP[zoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel])
                        this.option("zoomLevel", minZoomLevel)
                },
                _initCurrentDate: function() {
                    this.option("currentDate", this._getNormalizedDate(this.option("value")) || this._getNormalizedDate(this.option("currentDate")))
                },
                _getNormalizedDate: function(date) {
                    date = dateUtils.normalizeDate(date, this._getMinDate(), this._getMaxDate());
                    return commonUtils.isDefined(date) ? new Date(date) : date
                },
                _initActions: function() {
                    this._cellClickAction = this._createActionByOption("onCellClick");
                    this._onContouredChanged = this._createActionByOption("onContouredChanged")
                },
                _updateCurrentDate: function(date) {
                    var min = this._getMinDate(),
                        max = this._getMaxDate();
                    if (min > max) {
                        this.option("currentDate", new Date);
                        return
                    }
                    var normalizedDate = this._getNormalizedDate(date);
                    if (date.getTime() !== normalizedDate.getTime()) {
                        this.option("currentDate", new Date(normalizedDate));
                        return
                    }
                    var offset = this._getViewsOffset(this._view.option("date"), normalizedDate);
                    if (this._view && offset !== 0)
                        this._navigate(offset, normalizedDate);
                    else {
                        this._renderNavigator();
                        this._setViewContoured(normalizedDate)
                    }
                },
                _setViewContoured: function(date) {
                    if (this.option("hasFocus")(this._focusTarget()))
                        this._view.option("contouredDate", date)
                },
                _getMinDate: function() {
                    return this.option("min") || new Date(1000, 0)
                },
                _getMaxDate: function() {
                    return this.option("max") || new Date(3000, 0)
                },
                _getViewsOffset: function(startDate, endDate) {
                    var zoomLevel = this.option("zoomLevel");
                    if (zoomLevel === "month")
                        return this._getMonthsOffset(startDate, endDate);
                    var zoomCorrection;
                    switch (zoomLevel) {
                        case"century":
                            zoomCorrection = 100;
                            break;
                        case"decade":
                            zoomCorrection = 10;
                            break;
                        default:
                            zoomCorrection = 1;
                            break
                    }
                    return parseInt(endDate.getFullYear() / zoomCorrection) - parseInt(startDate.getFullYear() / zoomCorrection)
                },
                _getMonthsOffset: function(startDate, endDate) {
                    var yearOffset = endDate.getFullYear() - startDate.getFullYear(),
                        monthOffset = endDate.getMonth() - startDate.getMonth();
                    return yearOffset * 12 + monthOffset
                },
                _waitRenderView: function(offset) {
                    if (this._alreadyViewRender)
                        return;
                    this._alreadyViewRender = true;
                    var date = this._getDateByOffset(offset * this._getRtlCorrection());
                    this.option("currentDate", date);
                    setTimeout($.proxy(function() {
                        this._alreadyViewRender = false
                    }, this))
                },
                _getRtlCorrection: function() {
                    return this.option("rtlEnabled") ? -1 : 1
                },
                _getDateByOffset: function(offset, date) {
                    date = new Date(date || this.option("currentDate"));
                    var currentDay = date.getDate();
                    var difference = dateUtils.getDifferenceInMonth(this.option("zoomLevel")) * offset;
                    date.setDate(1);
                    date.setMonth(date.getMonth() + difference);
                    var lastDay = dateUtils.getLastMonthDate(date).getDate();
                    date.setDate(currentDay > lastDay ? lastDay : currentDay);
                    return date
                },
                _focusTarget: function() {
                    return this.element()
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(CALENDAR_CLASS);
                    this._renderBody();
                    this._renderViews();
                    this._renderNavigator();
                    this._renderSwipeable();
                    this._renderFooter();
                    this.setAria({
                        role: "listbox",
                        label: Globalize.localize("dxCalendar-ariaWidgetName")
                    });
                    this._updateAriaSelected();
                    this._updateAriaId();
                    this._setViewContoured(this.option("currentDate"))
                },
                _renderBody: function() {
                    if (!this._$viewsWrapper) {
                        var $body = $("<div>").addClass(CALENDAR_BODY_CLASS);
                        this._$viewsWrapper = $("<div>").addClass(CALENDAR_VIEWS_WRAPPER_CLASS);
                        $body.append(this._$viewsWrapper);
                        this.element().append($body)
                    }
                },
                _renderViews: function() {
                    this.element().addClass(CALENDAR_VIEW_CLASS + "-" + this.option("zoomLevel"));
                    var currentDate = this.option("currentDate");
                    this._view = this._renderSpecificView(currentDate);
                    this._view.option("_keyboardProcessor", this._viewKeyboardProcessor);
                    var beforeDate = this._getDateByOffset(-1, currentDate);
                    this._beforeView = this._isViewAvailable(beforeDate) ? this._renderSpecificView(beforeDate) : null;
                    var afterDate = this._getDateByOffset(1, currentDate);
                    this._afterView = this._isViewAvailable(afterDate) ? this._renderSpecificView(afterDate) : null;
                    this._translateViews()
                },
                _renderSpecificView: function(date) {
                    var specificView = Views[this.option("zoomLevel")],
                        $view = $("<div>").appendTo(this._$viewsWrapper),
                        config = this._viewConfig(date);
                    return new specificView($view, config)
                },
                _viewConfig: function(date) {
                    return {
                            date: date,
                            min: this._getMinDate(),
                            max: this._getMaxDate(),
                            firstDayOfWeek: this.option("firstDayOfWeek"),
                            value: this.option("value"),
                            rtl: this.option("rtlEnabled"),
                            disabled: this.option("disabled") || DevExpress.designMode,
                            tabIndex: undefined,
                            focusStateEnabled: this.option("focusStateEnabled"),
                            hoverStateEnabled: this.option("hoverStateEnabled"),
                            onCellClick: $.proxy(this._cellClickHandler, this),
                            cellTemplate: this._getTemplateByOption("cellTemplate"),
                            allowValueSelection: this._isMaxZoomLevel()
                        }
                },
                _isViewAvailable: function(date) {
                    var zoomLevel = this.option("zoomLevel");
                    var min = dateUtils.getViewMinBoundaryDate(zoomLevel, this._getMinDate());
                    var max = dateUtils.getViewMaxBoundaryDate(zoomLevel, this._getMaxDate());
                    return dateUtils.dateInRange(date, min, max)
                },
                _translateViews: function() {
                    translator.move(this._view.element(), {left: 0});
                    this._beforeView && translator.move(this._beforeView.element(), {left: this._getViewPosition(-1)});
                    this._afterView && translator.move(this._afterView.element(), {left: this._getViewPosition(1)})
                },
                _getViewPosition: function(coefficient) {
                    var rtlCorrection = this.option("rtlEnabled") && !(browser.msie && browser.version[0] !== "8") ? -1 : 1;
                    return coefficient * 100 * rtlCorrection + "%"
                },
                _cellClickHandler: function(e) {
                    var zoomLevel = this.option("zoomLevel"),
                        nextView = dateUtils.getViewDown(zoomLevel);
                    var isMaxZoomLevel = this._isMaxZoomLevel();
                    if (nextView && !isMaxZoomLevel) {
                        var target = e.jQueryEvent.currentTarget;
                        this._navigateDown(target)
                    }
                    else {
                        var newValue = this._updateTimeComponent(e.value);
                        this.option("value", newValue);
                        this._cellClickAction(e)
                    }
                },
                _updateTimeComponent: function(date) {
                    var result = new Date(date);
                    var currentValue = this.option("value");
                    if (currentValue) {
                        result.setHours(currentValue.getHours());
                        result.setMinutes(currentValue.getMinutes());
                        result.setSeconds(currentValue.getSeconds());
                        result.setMilliseconds(currentValue.getMilliseconds())
                    }
                    return result
                },
                _isMaxZoomLevel: function() {
                    return this.option("zoomLevel") === this.option("maxZoomLevel")
                },
                _navigateDown: function(cell) {
                    var zoomLevel = this.option("zoomLevel");
                    if (this._isMaxZoomLevel())
                        return;
                    var nextView = dateUtils.getViewDown(zoomLevel);
                    if (!nextView)
                        return;
                    var newCurrentDate = this._view.option("contouredDate") || this._view.option("date");
                    if (cell)
                        newCurrentDate = $(cell).data(CALENDAR_DATE_VALUE_KEY);
                    this.option("currentDate", newCurrentDate);
                    this.option("zoomLevel", nextView);
                    this._renderNavigator();
                    this._animateShowView();
                    this._setViewContoured(this._getNormalizedDate(newCurrentDate))
                },
                _renderNavigator: function() {
                    if (!this._navigator) {
                        var $navigator = $("<div>").prependTo(this.element());
                        this._navigator = new Navigator($navigator, this._navigatorConfig())
                    }
                    this._navigator.option("text", this._view.getNavigatorCaption());
                    this._updateButtonsVisibility()
                },
                _navigatorConfig: function() {
                    return {
                            text: this._view.getNavigatorCaption(),
                            onClick: $.proxy(this._navigatorClickHandler, this),
                            onCaptionClick: $.proxy(this._navigateUp, this),
                            rtlEnabled: this.option("rtlEnabled")
                        }
                },
                _navigatorClickHandler: function(e) {
                    var currentDate = this._getDateByOffset(e.direction, this.option("currentDate"));
                    this.option("currentDate", currentDate)
                },
                _navigateUp: function() {
                    var zoomLevel = this.option("zoomLevel"),
                        nextView = dateUtils.getViewUp(zoomLevel);
                    if (!nextView || this._isMinZoomLevel(zoomLevel))
                        return;
                    var contouredDate = this._view.option("contouredDate");
                    this.option("zoomLevel", nextView);
                    this.option("currentDate", contouredDate || this._view.option("date"));
                    this._renderNavigator();
                    this._animateShowView().done($.proxy(function() {
                        this._setViewContoured(contouredDate)
                    }, this))
                },
                _isMinZoomLevel: function(zoomLevel) {
                    var min = this._getMinDate(),
                        max = this._getMaxDate();
                    return dateUtils.sameView(zoomLevel, min, max) || this.option("minZoomLevel") === zoomLevel
                },
                _updateButtonsVisibility: function() {
                    this._navigator.toggleButton("next", !commonUtils.isDefined(this._afterView));
                    this._navigator.toggleButton("prev", !commonUtils.isDefined(this._beforeView))
                },
                _renderSwipeable: function() {
                    if (!this._swipeable)
                        this._swipeable = this._createComponent(this.element(), "dxSwipeable", {
                            onStart: $.proxy(this._swipeStartHandler, this),
                            onUpdated: $.proxy(this._swipeUpdateHandler, this),
                            onEnd: $.proxy(this._swipeEndHandler, this),
                            itemSizeFunc: $.proxy(this._viewWidth, this)
                        })
                },
                _swipeStartHandler: function(e) {
                    fx.stop(this._$viewsWrapper, true);
                    e.jQueryEvent.maxLeftOffset = this._afterView ? 1 : 0;
                    e.jQueryEvent.maxRightOffset = this._beforeView ? 1 : 0
                },
                _swipeUpdateHandler: function(e) {
                    var offset = e.jQueryEvent.offset;
                    translator.move(this._$viewsWrapper, {left: offset * this._viewWidth()});
                    this._updateNavigatorCaption(offset)
                },
                _swipeEndHandler: function(e) {
                    var targetOffset = e.jQueryEvent.targetOffset,
                        moveOffset = !targetOffset ? 0 : targetOffset / Math.abs(targetOffset);
                    if (moveOffset === 0) {
                        this._animateWrapper(0, ANIMATION_DURATION_SHOW_VIEW);
                        return
                    }
                    var date = this._getDateByOffset(-moveOffset * this._getRtlCorrection());
                    if (this._isDateInInvalidRange(date))
                        if (moveOffset >= 0)
                            date = new Date(this._getMinDate());
                        else
                            date = new Date(this._getMaxDate());
                    this.option("currentDate", date)
                },
                _viewWidth: function() {
                    if (!this._viewWidthValue)
                        this._viewWidthValue = this.element().width();
                    return this._viewWidthValue
                },
                _updateNavigatorCaption: function(offset) {
                    offset *= this._getRtlCorrection();
                    var view = this._view;
                    if (offset > 0.5 && this._beforeView)
                        view = this._beforeView;
                    else if (offset < -0.5 && this._afterView)
                        view = this._afterView;
                    this._navigator.option("text", view.getNavigatorCaption())
                },
                _isDateInInvalidRange: function(date) {
                    if (this._view.isBoundary(date))
                        return;
                    var min = this._getMinDate(),
                        max = this._getMaxDate(),
                        normalizedDate = dateUtils.normalizeDate(date, min, max);
                    return normalizedDate === min || normalizedDate === max
                },
                _renderFooter: function() {
                    var showTodayButton = this.option("showTodayButton");
                    if (showTodayButton) {
                        var $todayButton = this._createComponent($("<a>"), Button, {
                                focusStateEnabled: false,
                                text: Globalize.localize("dxCalendar-todayButtonText"),
                                onClick: $.proxy(function() {
                                    this._toTodayView()
                                }, this),
                                _templates: {}
                            }).element().addClass(CALENDAR_TODAY_BUTTON_CLASS);
                        this._$footer = $("<div>").addClass(CALENDAR_FOOTER_CLASS).append($todayButton);
                        this.element().append(this._$footer)
                    }
                    this.element().toggleClass(CALENDAR_HAS_FOOTER_CLASS, showTodayButton)
                },
                _animateShowView: function() {
                    fx.stop(this._view.element(), true);
                    return this._popAnimationView(this._view, POP_ANIMATION_FROM, POP_ANIMATION_TO, ANIMATION_DURATION_SHOW_VIEW).promise()
                },
                _popAnimationView: function(view, from, to, duration) {
                    return fx.animate(view.element(), {
                            type: "pop",
                            from: {
                                scale: from,
                                opacity: from
                            },
                            to: {
                                scale: to,
                                opacity: to
                            },
                            duration: duration
                        })
                },
                _navigate: function(offset, value) {
                    if (fx.isAnimating(this._$viewsWrapper))
                        fx.stop(this._$viewsWrapper, true);
                    if (offset !== 0 && Math.abs(offset) !== 1 && this._isViewAvailable(value)) {
                        var newView = this._renderSpecificView(value);
                        if (offset > 0) {
                            this._afterView && this._afterView.element().remove();
                            this._afterView = newView
                        }
                        else {
                            this._beforeView && this._beforeView.element().remove();
                            this._beforeView = newView
                        }
                        this._translateViews()
                    }
                    var rtlCorrection = this._getRtlCorrection(),
                        offsetSign = offset > 0 ? 1 : offset < 0 ? -1 : 0,
                        endPosition = -rtlCorrection * offsetSign * this._viewWidth();
                    var viewsWrapperPosition = this._$viewsWrapper.position().left;
                    if (viewsWrapperPosition !== endPosition)
                        if (this._preventViewChangeAnimation)
                            this._wrapperAnimationEndHandler(offset, value);
                        else
                            this._animateWrapper(endPosition, ANIMATION_DURATION_SHOW_VIEW).done($.proxy(this._wrapperAnimationEndHandler, this, offset, value))
                },
                _animateWrapper: function(to, duration) {
                    return fx.animate(this._$viewsWrapper, {
                            type: "slide",
                            from: {left: this._$viewsWrapper.position().left},
                            to: {left: to},
                            duration: duration
                        })
                },
                _toTodayView: function() {
                    var today = new Date;
                    if (this._isMaxZoomLevel()) {
                        this.option("value", today);
                        return
                    }
                    this._preventViewChangeAnimation = true;
                    this.option("zoomLevel", this.option("maxZoomLevel"));
                    this.option("value", today);
                    this._animateShowView();
                    this._preventViewChangeAnimation = false
                },
                _wrapperAnimationEndHandler: function(offset, newDate) {
                    this._rearrangeViews(offset);
                    this._translateViews();
                    this._resetLocation();
                    this._renderNavigator();
                    this._setViewContoured(newDate)
                },
                _rearrangeViews: function(offset) {
                    if (offset === 0)
                        return;
                    var viewOffset,
                        viewToCreateKey,
                        viewToRemoveKey;
                    if (offset < 0) {
                        viewOffset = 1;
                        viewToCreateKey = "_beforeView";
                        viewToRemoveKey = "_afterView"
                    }
                    else {
                        viewOffset = -1;
                        viewToCreateKey = "_afterView";
                        viewToRemoveKey = "_beforeView"
                    }
                    if (!this[viewToCreateKey])
                        return;
                    var destinationDate = this[viewToCreateKey].option("date");
                    if (this[viewToRemoveKey])
                        this[viewToRemoveKey].element().remove();
                    if (offset === viewOffset)
                        this[viewToRemoveKey] = this._view;
                    else {
                        this[viewToRemoveKey] = this._renderSpecificView(this._getDateByOffset(viewOffset, destinationDate));
                        this._view.element().remove()
                    }
                    this._view = this[viewToCreateKey];
                    var dateByOffset = this._getDateByOffset(-viewOffset, destinationDate);
                    this[viewToCreateKey] = this._isViewAvailable(dateByOffset) ? this._renderSpecificView(dateByOffset) : null
                },
                _resetLocation: function() {
                    translator.move(this._$viewsWrapper, {left: 0})
                },
                _clean: function() {
                    this.callBase();
                    this._clearViewWidthCache();
                    delete this._$viewsWrapper;
                    delete this._navigator;
                    delete this._$footer
                },
                _clearViewWidthCache: function() {
                    delete this._viewWidthValue
                },
                _disposeViews: function() {
                    this._view.element().remove();
                    this._beforeView && this._beforeView.element().remove();
                    this._afterView && this._afterView.element().remove();
                    delete this._view;
                    delete this._beforeView;
                    delete this._afterView
                },
                _refreshViews: function() {
                    this._disposeViews();
                    this._renderViews()
                },
                _visibilityChanged: function() {
                    this._translateViews()
                },
                _focusInHandler: function() {
                    this.callBase.apply(this, arguments);
                    this._view.option("contouredDate", this.option("currentDate"))
                },
                _focusOutHandler: function() {
                    this.callBase.apply(this, arguments);
                    this._view.option("contouredDate", null)
                },
                _updateViewsValue: function(value) {
                    var newValue = value ? new Date(value) : null;
                    this._view.option("value", newValue);
                    this._beforeView && this._beforeView.option("value", newValue);
                    this._afterView && this._afterView.option("value", newValue)
                },
                _updateAriaSelected: function(value, previousValue) {
                    value = value || this.option("value");
                    var $prevSelectedCell = this._view._getCellByDate(previousValue);
                    var $selectedCell = this._view._getCellByDate(value);
                    this.setAria("selected", undefined, $prevSelectedCell);
                    this.setAria("selected", true, $selectedCell);
                    if (value && this.option("currentDate").getTime() === value.getTime())
                        this._updateAriaId(value, previousValue)
                },
                _updateAriaId: function(value, previousValue) {
                    value = value || this.option("currentDate");
                    var ariaId = new DevExpress.data.Guid;
                    var $oldCell = this._view._getCellByDate(previousValue);
                    var $newCell = this._view._getCellByDate(value);
                    this.setAria("id", undefined, $oldCell);
                    this.setAria("id", ariaId, $newCell);
                    this.setAria("activedescendant", ariaId);
                    this._onContouredChanged(ariaId)
                },
                _optionChanged: function(args) {
                    var value = args.value;
                    var previousValue = args.previousValue;
                    switch (args.name) {
                        case"width":
                            this.callBase(args);
                            this._clearViewWidthCache();
                            break;
                        case"min":
                        case"max":
                            this.option("currentDate", this._getNormalizedDate(this.option("value")) || this._getNormalizedDate(this.option("currentDate")));
                            this._refreshViews();
                            this._updateButtonsVisibility();
                            break;
                        case"firstDayOfWeek":
                            this._refreshViews();
                            this._updateButtonsVisibility();
                            break;
                        case"currentDate":
                            this._updateCurrentDate(value);
                            this._updateAriaId(value, previousValue);
                            break;
                        case"zoomLevel":
                            this.element().removeClass(CALENDAR_VIEW_CLASS + "-" + previousValue);
                            this._correctZoomLevel();
                            this._refreshViews();
                            this._renderNavigator();
                            break;
                        case"minZoomLevel":
                        case"maxZoomLevel":
                            this._correctZoomLevel();
                            this._updateButtonsVisibility();
                            break;
                        case"value":
                            this._updateAriaSelected(value, previousValue);
                            this.option("currentDate", commonUtils.isDefined(value) ? new Date(value) : new Date);
                            this._updateViewsValue(value);
                            this.callBase(args);
                            break;
                        case"disabled":
                            this._view.option("disabled", value);
                            this.callBase(args);
                            break;
                        case"showTodayButton":
                            this._invalidate();
                            break;
                        case"onCellClick":
                            this._view.option("onCellClick", value);
                            break;
                        case"onContouredChanged":
                            this._onContouredChanged = this._createActionByOption("onContouredChanged");
                            break;
                        case"cellTemplate":
                            this._invalidate();
                            break;
                        case"hasFocus":
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        registerComponent("dxCalendar", uiNamespace, Calendar);
        return Calendar
    });
    DevExpress.require(["/ui/widgets/date/ui.calendar"]);
    /*! Module widgets-base, file ui.timeView.js */
    DevExpress.define("/ui/widgets/date/ui.timeView", ["jquery", "/ui/uiNamespace", "/utils/utils.support", "/componentRegistrator", "/ui/ui.editor", "/ui/widgets/ui.numberBox"], function($, uiNamespace, support, registerComponent, Editor, NumberBox) {
        var TIMEVIEW_CLASS = "dx-timeview",
            TIMEVIEW_CLOCK_CLASS = "dx-timeview-clock",
            TIMEVIEW_FIELD_CLASS = "dx-timeview-field",
            TIMEVIEW_HOURARROW_CLASS = "dx-timeview-hourarrow",
            TIMEVIEW_MINUTEARROW_CLASS = "dx-timeview-minutearrow";
        var rotateArrow = function($arrow, angle, offset) {
                if (!support.transform)
                    filterRotate($arrow, angle, offset);
                else
                    cssRotate($arrow, angle, offset)
            };
        var filterRotate = function($arrow, angle, offset) {
                angle = angle / 180 * Math.PI;
                var sin = Math.sin(angle),
                    cos = Math.cos(angle);
                $arrow.css("filter", "none");
                var originalWidth = $arrow.width(),
                    originalHeight = $arrow.height();
                $arrow.css("filter", 'progid:DXImageTransform.Microsoft.Matrix' + '(sizingMethod="auto expand", M11 = ' + cos + ', M12 = ' + -sin + ', M21 = ' + sin + ', M22 = ' + cos + ')');
                var width = $arrow.width(),
                    height = $arrow.height();
                var sx = (width - originalWidth) / 2,
                    sy = (height - originalHeight) / 2;
                $arrow.css("margin-left", -originalWidth / 2 + (originalHeight / 2 - offset) * sin - sx);
                $arrow.css("margin-top", originalHeight / 2 - (originalHeight / 2 - offset) * cos - sy)
            };
        var cssRotate = function($arrow, angle, offset) {
                $arrow.css("transform", "rotate(" + angle + "deg)" + " translate(0," + offset + "px)")
            };
        var TimeView = Editor.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            value: new Date($.now()),
                            _arrowOffset: 0
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: {platform: "android"},
                                options: {_arrowOffset: 15}
                            }, {
                                device: {platform: "generic"},
                                options: {_arrowOffset: 5}
                            }])
                },
                _getValue: function() {
                    return this.option("value") || new Date
                },
                _init: function() {
                    this.callBase();
                    this.element().addClass(TIMEVIEW_CLASS)
                },
                _render: function() {
                    this.callBase();
                    this._renderBox();
                    this._updateTime()
                },
                _renderBox: function() {
                    var $box = $("<div>").appendTo(this.element());
                    this._createComponent($box, "dxBox", {
                        height: "100%",
                        width: "100%",
                        direction: "col",
                        items: [{
                                ratio: 1,
                                shrink: 0,
                                baseSize: "auto",
                                template: $.proxy(this._renderClock, this)
                            }, {
                                ratio: 0,
                                shrink: 0,
                                baseSize: 50,
                                template: $.proxy(this._renderField, this)
                            }]
                    })
                },
                _renderClock: function(_, __, $container) {
                    this._$hourArrow = $("<div>").addClass(TIMEVIEW_HOURARROW_CLASS);
                    this._$minuteArrow = $("<div>").addClass(TIMEVIEW_MINUTEARROW_CLASS);
                    $container.addClass(TIMEVIEW_CLOCK_CLASS).append(this._$hourArrow).append(this._$minuteArrow);
                    this.setAria("role", "presentation", $container)
                },
                _updateClock: function() {
                    var time = this._getValue(),
                        hourArrowAngle = time.getHours() / 12 * 360 + time.getMinutes() / 60 * 30,
                        minuteArrowAngle = time.getMinutes() / 60 * 360;
                    rotateArrow(this._$hourArrow, hourArrowAngle, this.option("_arrowOffset"));
                    rotateArrow(this._$minuteArrow, minuteArrowAngle, this.option("_arrowOffset"))
                },
                _renderField: function() {
                    this._createHourBox();
                    this._createMinuteBox();
                    return this._createComponent($("<div>").addClass(TIMEVIEW_FIELD_CLASS), "dxBox", {
                            direction: "row",
                            align: "center",
                            crossAlign: "center",
                            items: [{
                                    ratio: 0,
                                    shrink: 0,
                                    baseSize: "auto",
                                    template: $.proxy(function() {
                                        return this._hourBox.element()
                                    }, this)
                                }, {
                                    ratio: 0,
                                    shrink: 0,
                                    baseSize: "auto",
                                    template: Globalize.culture().calendar[":"]
                                }, {
                                    ratio: 0,
                                    shrink: 0,
                                    baseSize: "auto",
                                    template: $.proxy(function() {
                                        return this._minuteBox.element()
                                    }, this)
                                }]
                        }).element()
                },
                _createHourBox: function() {
                    this._hourBox = this._createComponent($("<div>"), NumberBox, $.extend({
                        min: -1,
                        max: 24,
                        value: this._getValue().getHours(),
                        onValueChanged: $.proxy(function(args) {
                            var newHours = (24 + args.value) % 24;
                            this._hourBox.option("value", newHours);
                            var time = new Date(this._getValue());
                            time.setHours(newHours);
                            this.option("value", time)
                        }, this)
                    }, this._getNumberBoxConfig()));
                    this._hourBox.setAria("label", "hours")
                },
                _createMinuteBox: function() {
                    this._minuteBox = this._createComponent($("<div>"), NumberBox, $.extend({
                        min: -1,
                        max: 60,
                        value: this._getValue().getMinutes(),
                        onValueChanged: $.proxy(function(args) {
                            var newMinutes = (60 + args.value) % 60;
                            this._minuteBox.option("value", newMinutes);
                            var time = new Date(this._getValue());
                            time.setMinutes(newMinutes);
                            this.option("value", time)
                        }, this)
                    }, this._getNumberBoxConfig()));
                    this._minuteBox.setAria("label", "minutes")
                },
                _getNumberBoxConfig: function() {
                    return {
                            showSpinButtons: true,
                            disabled: this.option("disabled"),
                            valueFormat: function(value) {
                                return (value < 10 ? "0" : "") + value
                            }
                        }
                },
                _updateField: function() {
                    this._hourBox && this._hourBox.option("value", this._getValue().getHours());
                    this._minuteBox && this._minuteBox.option("value", this._getValue().getMinutes())
                },
                _updateTime: function() {
                    this._updateClock();
                    this._updateField()
                },
                _visibilityChanged: function(visible) {
                    if (visible)
                        this._updateTime()
                },
                _toggleDisabledState: function(value) {
                    this._hourBox && this._hourBox.option("disabled", value);
                    this._minuteBox && this._minuteBox.option("disabled", value)
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"value":
                            this._updateTime();
                            this.callBase(args);
                            break;
                        case"_arrowOffset":
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        registerComponent("dxTimeView", uiNamespace, TimeView);
        return TimeView
    });
    /*! Module widgets-base, file ui.dateViewRoller.js */
    DevExpress.define("/ui/widgets/date/ui.dateViewRoller", ["jquery", "/ui/uiNamespace", "/ui/widgets/date/ui.dateUtils", "/utils/utils.date", "/ui/ui.editor", "/componentRegistrator", "/ui/events/ui.events.utils"], function($, uiNamespace, uiDateUtils, dateUtils, Editor, registerComponent, eventUtils) {
        var DATEVIEW_ROLLER_CLASS = "dx-dateviewroller",
            DATEVIEW_ROLLER_ACTIVE_CLASS = "dx-state-active",
            DATEVIEW_ROLLER_CURRENT_CLASS = "dx-dateviewroller-current",
            DATEVIEW_ROLLER_ITEM_CLASS = "dx-dateview-item",
            DATEVIEW_ROLLER_ITEM_SELECTED_CLASS = "dx-dateview-item-selected",
            DATEVIEW_ROLLER_ITEM_SELECTED_FRAME_CLASS = "dx-dateview-item-selected-frame",
            DATEVIEW_ROLLER_ITEM_SELECTED_BORDER_CLASS = "dx-dateview-item-selected-border";
        var DateViewRoller = DevExpress.ui.dxScrollable.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            showScrollbar: false,
                            useNative: false,
                            selectedIndex: 0,
                            bounceEnabled: false,
                            items: [],
                            showOnClick: false,
                            onClick: null,
                            onSelectedIndexChanged: null
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return device.platform === "win" && device.version && device.version[0] === 8
                                },
                                options: {showOnClick: true}
                            }, {
                                device: {platform: "generic"},
                                options: {scrollByContent: true}
                            }])
                },
                _init: function() {
                    this.callBase();
                    this._renderSelectedItemFrame()
                },
                _render: function() {
                    this.callBase();
                    $.each(this._strategy._scrollers, function(index, scroller) {
                        scroller._correctLocation = $.noop
                    });
                    this.element().addClass(DATEVIEW_ROLLER_CLASS);
                    this._renderContainerClick();
                    this._renderItems();
                    this._renderSelectedValue();
                    this._renderItemsClick();
                    this._wrapAction("_endAction", $.proxy(this._endActionHandler, this));
                    this._renderSelectedIndexChanged()
                },
                _renderSelectedIndexChanged: function() {
                    this._selectedIndexChanged = this._createActionByOption("onSelectedIndexChanged")
                },
                _renderContainerClick: function() {
                    if (!this.option("showOnClick"))
                        return;
                    var eventName = eventUtils.addNamespace("dxclick", this.NAME);
                    var clickAction = this._createActionByOption("onClick");
                    this._$container.off(eventName).on(eventName, function(e) {
                        clickAction({jQueryEvent: e})
                    })
                },
                _wrapAction: function(actionName, callback) {
                    var strategy = this._strategy,
                        originalAction = strategy[actionName];
                    strategy[actionName] = function() {
                        callback.apply(this, arguments);
                        return originalAction.apply(this, arguments)
                    }
                },
                _renderItems: function() {
                    var items = this.option("items") || [],
                        $items = $();
                    this._$content.empty();
                    $.each(items, function() {
                        $items = $items.add($("<div>").addClass(DATEVIEW_ROLLER_ITEM_CLASS).append(this))
                    });
                    this._$content.append($items);
                    this._$items = $items;
                    this.update()
                },
                _renderSelectedItemFrame: function() {
                    $("<div>").addClass(DATEVIEW_ROLLER_ITEM_SELECTED_FRAME_CLASS).append($("<div>").addClass(DATEVIEW_ROLLER_ITEM_SELECTED_BORDER_CLASS)).appendTo(this._$container)
                },
                _renderSelectedValue: function(selectedIndex) {
                    var index = this._fitIndex(selectedIndex || this.option("selectedIndex"));
                    this._moveTo({top: this._getItemPosition(index)});
                    this._renderActiveStateItem()
                },
                _fitIndex: function(index) {
                    var items = this.option("items") || [],
                        itemCount = items.length;
                    if (index >= itemCount)
                        return itemCount - 1;
                    if (index < 0)
                        return 0;
                    return index
                },
                _getItemPosition: function(index) {
                    return Math.round(this._itemHeight() * index)
                },
                _renderItemsClick: function() {
                    var itemSelector = this._getItemSelector(),
                        eventName = eventUtils.addNamespace("dxclick", this.NAME);
                    this.element().off(eventName, itemSelector);
                    this.element().on(eventName, itemSelector, $.proxy(this._itemClickHandler, this))
                },
                _getItemSelector: function() {
                    return "." + DATEVIEW_ROLLER_ITEM_CLASS
                },
                _itemClickHandler: function(e) {
                    this.option("selectedIndex", this._itemElementIndex(e.currentTarget))
                },
                _itemElementIndex: function(itemElement) {
                    return this._itemElements().index(itemElement)
                },
                _itemElements: function() {
                    return this.element().find(this._getItemSelector())
                },
                _renderActiveStateItem: function() {
                    var selectedIndex = this.option("selectedIndex");
                    $.each(this._$items, function(index) {
                        $(this).toggleClass(DATEVIEW_ROLLER_ITEM_SELECTED_CLASS, selectedIndex === index)
                    })
                },
                _moveTo: function(targetLocation) {
                    targetLocation = this._normalizeLocation(targetLocation);
                    var location = this._location(),
                        delta = {
                            x: -(location.left - targetLocation.left),
                            y: -(location.top - targetLocation.top)
                        };
                    if (this._isVisible() && (delta.x || delta.y)) {
                        this._strategy._prepareDirections(true);
                        if (this._animation) {
                            DevExpress.fx.stop(this._$content);
                            DevExpress.fx.animate(this._$content, {
                                duration: 200,
                                type: "slide",
                                to: {top: targetLocation.top}
                            });
                            delete this._animation
                        }
                        else
                            this._strategy.handleMove({delta: delta})
                    }
                },
                _validate: function(e) {
                    return this._strategy.validate(e)
                },
                _endActionHandler: function() {
                    var currentSelectedIndex = this.option("selectedIndex"),
                        ratio = -this._location().top / this._itemHeight(),
                        newSelectedIndex = Math.round(ratio);
                    this._animation = true;
                    if (newSelectedIndex === currentSelectedIndex)
                        this._renderSelectedValue(newSelectedIndex);
                    else
                        this.option("selectedIndex", newSelectedIndex)
                },
                _itemHeight: function() {
                    var $item = this._$items.first(),
                        height = $item.outerHeight() + parseFloat($item.css("margin-top") || 0);
                    return height
                },
                _toggleActive: function(state) {
                    this.element().toggleClass(DATEVIEW_ROLLER_ACTIVE_CLASS, state)
                },
                _isVisible: function() {
                    return this._$container.is(":visible")
                },
                _fireSelectedIndexChanged: function(value, previousValue) {
                    this._selectedIndexChanged({
                        value: value,
                        previousValue: previousValue,
                        jQueryEvent: undefined
                    })
                },
                _visibilityChanged: function(visible) {
                    this.callBase(visible);
                    if (visible)
                        this._renderSelectedValue(this.option("selectedIndex"));
                    else
                        this.toggleActiveState(false)
                },
                toggleActiveState: function(state) {
                    this.element().toggleClass(DATEVIEW_ROLLER_CURRENT_CLASS, state)
                },
                _refreshSelectedIndex: function() {
                    var selectedIndex = this.option("selectedIndex");
                    var fitIndex = this._fitIndex(selectedIndex);
                    fitIndex === selectedIndex ? this._renderActiveStateItem() : this.option("selectedIndex", fitIndex)
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"selectedIndex":
                            this._fireSelectedIndexChanged(args.value, args.previousValue);
                            this._renderSelectedValue(args.value);
                            break;
                        case"items":
                            this._renderItems();
                            this._refreshSelectedIndex();
                            break;
                        case"onClick":
                        case"showOnClick":
                            this._renderContainerClick();
                            break;
                        case"onSelectedIndexChanged":
                            this._renderSelectedIndexChanged();
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        registerComponent("dxDateViewRoller", uiNamespace, DateViewRoller);
        return DateViewRoller
    });
    /*! Module widgets-base, file ui.dateView.js */
    DevExpress.define("/ui/widgets/date/ui.dateView", ["jquery", "/ui/uiNamespace", "/ui/widgets/date/ui.dateUtils", "/utils/utils.date", "/ui/ui.editor", "/componentRegistrator", "/ui/widgets/date/ui.dateViewRoller"], function($, uiNamespace, uiDateUtils, dateUtils, Editor, registerComponent, DateViewRoller) {
        var DATEVIEW_CLASS = "dx-dateview",
            DATEVIEW_WRAPPER_CLASS = "dx-dateview-wrapper",
            DATEVIEW_ROLLER_CONTAINER_CLASS = "dx-dateview-rollers",
            DATEVIEW_ROLLER_CLASS = "dx-dateviewroller";
        var FORMAT = {
                date: 'date',
                datetime: 'datetime',
                time: 'time'
            };
        var ROLLER_TYPE = {
                year: 'year',
                month: 'month',
                day: 'day'
            };
        var DateView = Editor.inherit({
                _valueOption: function() {
                    return new Date(this.option("value")) === "Invalid Date" ? new Date : new Date(this.option("value"))
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            minDate: uiDateUtils.MIN_DATEVIEW_DEFAULT_DATE,
                            maxDate: uiDateUtils.MAX_DATEVIEW_DEFAULT_DATE,
                            format: FORMAT.date,
                            value: new Date,
                            culture: Globalize.culture().name,
                            showNames: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return device.platform === "win" && device.version && device.version[0] === 8
                                },
                                options: {showNames: true}
                            }])
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(DATEVIEW_CLASS);
                    this._toggleFormatClasses(this.option("format"))
                },
                _toggleFormatClasses: function(currentFormat, previousFormat) {
                    this.element().addClass(DATEVIEW_CLASS + "-" + currentFormat);
                    previousFormat && this.element().removeClass(DATEVIEW_CLASS + "-" + previousFormat)
                },
                _wrapper: function() {
                    return this._$wrapper
                },
                _renderContentImpl: function() {
                    this._$wrapper = $("<div>").addClass(DATEVIEW_WRAPPER_CLASS);
                    this._renderRollers();
                    this._$wrapper.appendTo(this.element())
                },
                _renderRollers: function() {
                    if (!this._$rollersContainer)
                        this._$rollersContainer = $("<div>").addClass(DATEVIEW_ROLLER_CONTAINER_CLASS);
                    this._$rollersContainer.empty();
                    this._createRollerConfigs();
                    this._rollers = {};
                    var that = this;
                    $.each(that._rollerConfigs, function(name) {
                        var $roller = $("<div>").appendTo(that._$rollersContainer).addClass(DATEVIEW_ROLLER_CLASS + "-" + that._rollerConfigs[name].type);
                        that._rollers[that._rollerConfigs[name].type] = that._createComponent($roller, DateViewRoller, {
                            items: that._rollerConfigs[name].displayItems,
                            selectedIndex: that._rollerConfigs[name].selectedIndex,
                            showScrollbar: false,
                            onStart: function(e) {
                                var roller = e.component;
                                roller._toggleActive(true);
                                that._setActiveRoller(that._rollerConfigs[name], roller.option("selectedIndex"))
                            },
                            onEnd: function(e) {
                                var roller = e.component;
                                roller._toggleActive(false)
                            },
                            onClick: function(e) {
                                var roller = e.component;
                                roller._toggleActive(true);
                                that._setActiveRoller(that._rollerConfigs[name], roller.option("selectedIndex"));
                                that._setRollerState(that._rollerConfigs[name], roller.option("selectedIndex"));
                                roller._toggleActive(false)
                            },
                            onSelectedIndexChanged: function(e) {
                                var roller = e.component;
                                that._setRollerState(that._rollerConfigs[name], roller.option("selectedIndex"))
                            }
                        })
                    });
                    that._$rollersContainer.appendTo(that._wrapper())
                },
                _createRollerConfigs: function(format) {
                    var that = this;
                    format = format || that.option("format");
                    that._rollerConfigs = {};
                    $.each(that._getFormatPattern(format).split(/\W+/), function(_, formatPart) {
                        $.each(uiDateUtils.DATE_COMPONENTS_INFO, function(componentName, componentInfo) {
                            if ($.inArray(formatPart, componentInfo.possibleFormats) > -1)
                                that._createRollerConfig(componentName)
                        })
                    })
                },
                _createRollerConfig: function(componentName) {
                    var componentInfo = uiDateUtils.DATE_COMPONENTS_INFO[componentName],
                        valueRange = this._calculateRollerConfigValueRange(componentName),
                        startValue = valueRange.startValue,
                        endValue = valueRange.endValue,
                        formatter = componentInfo.formatter,
                        showNames = this.option("showNames"),
                        curDate = this._getCurrentDate();
                    var config = {
                            type: componentName,
                            setValue: componentInfo.setter,
                            valueItems: [],
                            displayItems: [],
                            getIndex: function(value) {
                                return value[componentInfo.getter]() - startValue
                            }
                        };
                    for (var i = startValue; i <= endValue; i++) {
                        config.valueItems.push(i);
                        config.displayItems.push(formatter(i, showNames, curDate))
                    }
                    config.selectedIndex = config.getIndex(curDate);
                    this._rollerConfigs[componentName] = config
                },
                _setActiveRoller: function(currentRoller) {
                    var activeRoller = currentRoller && this._rollers[currentRoller.type];
                    $.each(this._rollers, function() {
                        this.toggleActiveState(this === activeRoller)
                    })
                },
                _updateRollersPosition: function() {
                    var that = this;
                    $.each(this._rollers, function(type) {
                        var correctIndex = that._rollerConfigs[type].getIndex(that._getCurrentDate());
                        this.option("selectedIndex", correctIndex)
                    })
                },
                _setRollerState: function(roller, selectedIndex) {
                    if (selectedIndex !== roller.selectedIndex) {
                        var rollerValue = roller.valueItems[selectedIndex],
                            setValue = roller.setValue,
                            currentValue = new Date(this._getCurrentDate()),
                            currentDate = currentValue.getDate();
                        if (roller.type === ROLLER_TYPE.month)
                            currentDate = Math.min(currentDate, uiDateUtils.getMaxMonthDay(currentValue.getFullYear(), rollerValue));
                        else if (roller.type === ROLLER_TYPE.year)
                            currentDate = Math.min(currentDate, uiDateUtils.getMaxMonthDay(rollerValue, currentValue.getMonth()));
                        currentValue.setDate(currentDate);
                        currentValue[setValue](rollerValue);
                        this.option("value", currentValue);
                        roller.selectedIndex = selectedIndex
                    }
                    if (roller.type === ROLLER_TYPE.year) {
                        this._refreshMonthRoller();
                        this._refreshDayRoller()
                    }
                    if (roller.type === ROLLER_TYPE.month)
                        this._refreshDayRoller()
                },
                _refreshMonthRoller: function() {
                    var monthRoller = this._rollers[ROLLER_TYPE.month];
                    if (monthRoller) {
                        this._createRollerConfig(ROLLER_TYPE.month);
                        var monthRollerConfig = this._rollerConfigs[ROLLER_TYPE.month];
                        if (monthRollerConfig.displayItems.length !== monthRoller.option("items").length)
                            monthRoller.option({
                                items: monthRollerConfig.displayItems,
                                selectedIndex: monthRollerConfig.selectedIndex
                            })
                    }
                },
                _refreshDayRoller: function() {
                    var dayRoller = this._rollers[ROLLER_TYPE.day];
                    if (dayRoller) {
                        this._createRollerConfig(ROLLER_TYPE.day);
                        var dayRollerConfig = this._rollerConfigs[ROLLER_TYPE.day];
                        dayRoller.option({
                            items: dayRollerConfig.displayItems,
                            selectedIndex: dayRollerConfig.selectedIndex
                        })
                    }
                },
                _getFormatPattern: function(format) {
                    var culture = Globalize.culture(this.option("culture"));
                    if (format === FORMAT.date)
                        return culture.calendar.patterns.d;
                    if (format === FORMAT.time)
                        return culture.calendar.patterns.t;
                    if (format === FORMAT.datetime)
                        return [culture.calendar.patterns.d, culture.calendar.patterns.t].join(" ");
                    return ""
                },
                _getCurrentDate: function() {
                    var curDate = this.option("value"),
                        minDate = this.option("minDate"),
                        maxDate = this.option("maxDate");
                    if (minDate && curDate.getTime() <= minDate.getTime())
                        curDate = minDate;
                    else if (maxDate && curDate.getTime() >= maxDate.getTime())
                        curDate = maxDate;
                    return curDate
                },
                _calculateRollerConfigValueRange: function(componentName) {
                    var curDate = this._getCurrentDate(),
                        minDate = this.option("minDate"),
                        maxDate = this.option("maxDate"),
                        minYear = dateUtils.sameYear(curDate, minDate),
                        minMonth = minYear && curDate.getMonth() === minDate.getMonth(),
                        maxYear = dateUtils.sameYear(curDate, maxDate),
                        maxMonth = maxYear && curDate.getMonth() === maxDate.getMonth(),
                        componentInfo = uiDateUtils.DATE_COMPONENTS_INFO[componentName],
                        startValue = componentInfo.startValue,
                        endValue = componentInfo.endValue;
                    if (componentName === ROLLER_TYPE.year) {
                        startValue = minDate.getFullYear();
                        endValue = maxDate.getFullYear()
                    }
                    if (componentName === ROLLER_TYPE.month) {
                        if (minYear)
                            startValue = minDate.getMonth();
                        if (maxYear)
                            endValue = maxDate.getMonth()
                    }
                    if (componentName === ROLLER_TYPE.day) {
                        endValue = uiDateUtils.getMaxMonthDay(curDate.getFullYear(), curDate.getMonth());
                        if (minYear && minMonth)
                            startValue = minDate.getDate();
                        if (maxYear && maxMonth)
                            endValue = maxDate.getDate()
                    }
                    return {
                            startValue: startValue,
                            endValue: endValue
                        }
                },
                _refreshRollers: function() {
                    this._refreshMonthRoller();
                    this._refreshDayRoller()
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"showNames":
                        case"minDate":
                        case"maxDate":
                        case"culture":
                        case"format":
                            this._renderRollers();
                            this._toggleFormatClasses(args.value, args.previousValue);
                            break;
                        case"visible":
                            this.callBase(args);
                            if (args.value)
                                this._renderRollers();
                            break;
                        case"value":
                            this.option("value", this._valueOption());
                            this._refreshRollers();
                            this._updateRollersPosition();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _clean: function() {
                    this.callBase();
                    delete this._$rollersContainer
                },
                _dispose: function() {
                    clearTimeout(this._deferredRenderDayTimeout);
                    clearTimeout(this._deferredRenderMonthTimeout);
                    this.callBase()
                }
            });
        registerComponent("dxDateView", uiNamespace, DateView);
        return DateView
    });
    /*! Module widgets-base, file ui.dateBox.js */
    DevExpress.define("/ui/widgets/date/ui.dateBox", ["jquery", "/utils/utils.support", "/devices", "/ui/ui.errors", "/utils/utils.date", "/ui/widgets/date/ui.dateUtils", "/utils/utils.version", "/utils/utils.common", "/componentRegistrator", "/ui/widgets/ui.dropDownEditor", "/ui/uiNamespace"], function($, support, devices, errors, dateUtils, uiDateUtils, version, commonUtils, registerComponent, DropDownEditor, uiNamespace) {
        var compareVersions = version.compare,
            DATEBOX_CLASS = "dx-datebox",
            DATEBOX_WRAPPER_CLASS = "dx-datebox-wrapper";
        var PICKER_TYPE = {
                calendar: "calendar",
                rollers: "rollers",
                list: "list",
                native: "native"
            };
        var FORMAT = {
                date: "date",
                datetime: "datetime",
                time: "time"
            };
        var STRATEGY_NAME = {
                calendar: 'Calendar',
                dateview: 'DateView',
                native: 'Native',
                calendarWithTime: 'CalendarWithTime',
                list: 'List'
            };
        var realWidthSetted = function($element) {
                var explicitWidth = $element[0].style.width;
                if (explicitWidth && explicitWidth !== "auto" && explicitWidth !== "inherit")
                    return true;
                return false
            };
        var calculateWidth = function(value, $input, $element) {
                var IE_ROUNDING_ERROR = 10;
                var NATIVE_BUTTONS_WIDTH = 48;
                var $longestValueElement = $("<div>").text(value).css({
                        "font-style": $input.css("font-style"),
                        "font-variant": $input.css("font-variant"),
                        "font-weight": $input.css("font-weight"),
                        "font-size": $input.css("font-size"),
                        "font-family": $input.css("font-family"),
                        "letter-spacing": $input.css("letter-spacing"),
                        "padding-left": $input.css("padding-left"),
                        "padding-right": $input.css("padding-right"),
                        border: $input.css("border"),
                        visibility: "hidden",
                        "white-space": "nowrap",
                        position: "absolute",
                        float: "left"
                    });
                $longestValueElement.appendTo($element);
                var width = $longestValueElement.outerWidth() + IE_ROUNDING_ERROR + ($input.prop("type") !== "text" ? NATIVE_BUTTONS_WIDTH : 0);
                $longestValueElement.remove();
                return width
            };
        var DateBox = DropDownEditor.inherit({
                _supportedKeys: function() {
                    return $.extend(this.callBase(), this._strategy.supportedKeys())
                },
                _setDeprecatedOptions: function() {
                    this.callBase();
                    $.extend(this._deprecatedOptions, {
                        useNative: {
                            since: "15.1",
                            message: "'useNative' option is deprecated in 15.1. Use the 'pickerType' option instead"
                        },
                        useCalendar: {
                            since: "15.1",
                            message: "'useCalendar' option is deprecated in 15.1. Use the 'pickerType' option instead"
                        }
                    })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            format: "date",
                            value: new Date,
                            min: undefined,
                            max: undefined,
                            useCalendar: false,
                            formatString: "d",
                            interval: 30,
                            maxZoomLevel: "month",
                            minZoomLevel: "century",
                            useNative: true,
                            pickerType: PICKER_TYPE["native"],
                            invalidDateMessage: Globalize.localize("dxDateBox-validation-datetime"),
                            dateOutOfRangeMessage: Globalize.localize("validation-range")
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: {platform: "ios"},
                                options: {showPopupTitle: true}
                            }, {
                                device: function(device) {
                                    return device.platform === "android"
                                },
                                options: {buttonsLocation: "bottom after"}
                            }, {
                                device: function(device) {
                                    return device.platform === "win" && device.version && device.version[0] === 8
                                },
                                options: {buttonsLocation: "bottom after"}
                            }, {
                                device: function(device) {
                                    return device.platform === "win" && device.version && device.version[0] === 10
                                },
                                options: {buttonsLocation: "bottom center"}
                            }, {
                                device: function() {
                                    var realDevice = devices.real(),
                                        platform = realDevice.platform,
                                        version = realDevice.version;
                                    return platform === "generic" || platform === "win" || platform === "android" && compareVersions(version, [4, 4]) < 0
                                },
                                options: {pickerType: PICKER_TYPE.rollers}
                            }, {
                                device: {
                                    platform: "generic",
                                    deviceType: "desktop"
                                },
                                options: {
                                    pickerType: PICKER_TYPE.calendar,
                                    buttonsLocation: "bottom after"
                                }
                            }, {
                                device: function() {
                                    var realDevice = devices.real(),
                                        platform = realDevice.platform,
                                        isPhone = realDevice.phone;
                                    return platform === "win" && !isPhone
                                },
                                options: {pickerType: PICKER_TYPE.calendar}
                            }])
                },
                _initOptions: function(options) {
                    this._userOptions = $.extend({}, options);
                    this.callBase(options);
                    this._updatePickerOptions(this._userOptions)
                },
                _updatePickerOptions: function(userOptions) {
                    var pickerType = this._getPickerTypeByDepricatedOptions(userOptions);
                    var format = this.option("format");
                    if (pickerType === PICKER_TYPE.list && (format === FORMAT.datetime || format === FORMAT.date))
                        pickerType = PICKER_TYPE.calendar;
                    if (format === FORMAT.time && pickerType === PICKER_TYPE.calendar)
                        pickerType = PICKER_TYPE.list;
                    this.option("showDropButton", devices.real().platform !== "generic" || pickerType !== PICKER_TYPE["native"]);
                    this._pickerType = pickerType
                },
                _getPickerTypeByDepricatedOptions: function(userOptions) {
                    return userOptions.pickerType ? userOptions.pickerType : commonUtils.isDefined(userOptions.useCalendar) || commonUtils.isDefined(userOptions.useNative) ? this._getPickerType() : this._pickerType || this.option("pickerType")
                },
                _getPickerType: function() {
                    if (this.option().useCalendar)
                        return this.option("format") === FORMAT.time ? PICKER_TYPE.list : PICKER_TYPE.calendar;
                    if (this.option().useNative)
                        return PICKER_TYPE["native"];
                    return PICKER_TYPE.rollers
                },
                _init: function() {
                    this._initStrategy();
                    this.option($.extend({}, this._strategy.getDefaultOptions(), this._userOptions));
                    delete this._userOptions;
                    this.callBase()
                },
                _toLowerCaseFirstLetter: function(string) {
                    return string.charAt(0).toLowerCase() + string.substr(1)
                },
                _initStrategy: function() {
                    var strategyName = this._getStrategyName(this._getFormatType()),
                        strategy = DevExpress.require("/ui/widgets/date/ui.dateBox.strategy." + this._toLowerCaseFirstLetter(strategyName));
                    if (!(this._strategy && this._strategy.NAME === strategyName))
                        this._strategy = new strategy(this)
                },
                _getFormatType: function() {
                    var format = this.option("format");
                    var isTime = /h|m|s/g.test(format),
                        isDate = /d|M|Y/g.test(format);
                    var formatType = "";
                    if (isDate)
                        formatType += FORMAT.date;
                    if (isTime)
                        formatType += FORMAT.time;
                    return formatType
                },
                _getStrategyName: function(format) {
                    var pickerType = this._pickerType;
                    if (pickerType === PICKER_TYPE.rollers)
                        return this.option().useCalendar ? STRATEGY_NAME.calendar : STRATEGY_NAME.dateview;
                    if (pickerType === PICKER_TYPE["native"])
                        return STRATEGY_NAME["native"];
                    if (format === FORMAT.date)
                        return STRATEGY_NAME.calendar;
                    if (format === FORMAT.datetime)
                        return STRATEGY_NAME.calendarWithTime;
                    return STRATEGY_NAME.list
                },
                _render: function() {
                    this.element().addClass(DATEBOX_CLASS);
                    this._refreshFormatClass();
                    this._refreshPickerTypeClass();
                    this.callBase();
                    this._updateSize();
                    this._strategy.renderInputMinMax(this._input())
                },
                _refreshFormatClass: function() {
                    var $element = this.element();
                    $.each(FORMAT, $.proxy(function(_, item) {
                        $element.removeClass(DATEBOX_CLASS + "-" + item)
                    }, null));
                    $element.addClass(DATEBOX_CLASS + "-" + this.option("format"))
                },
                _refreshPickerTypeClass: function() {
                    var $element = this.element();
                    $.each(PICKER_TYPE, $.proxy(function(_, item) {
                        $element.removeClass(DATEBOX_CLASS + "-" + item)
                    }, null));
                    $element.addClass(DATEBOX_CLASS + "-" + this._pickerType)
                },
                _updateSize: function() {
                    var $element = this.element(),
                        widthOption = this.option("width"),
                        isWidthSet = commonUtils.isDefined(widthOption) || realWidthSetted($element) && !this._isSizeUpdatable,
                        isElementVisible = $element.is(":visible"),
                        pickerType = this._pickerType,
                        shouldCalculateWidth = pickerType !== PICKER_TYPE.rollers && devices.current().platform === "generic";
                    if (isWidthSet || !(shouldCalculateWidth && isElementVisible))
                        return;
                    var $input = this._input(),
                        calendar = Globalize.culture().calendar,
                        format = this.option("formatString"),
                        longestValue = Globalize.format(uiDateUtils.getLongestDate(format, calendar.months.names, calendar.days.names), format);
                    $element.width(calculateWidth(longestValue, $input, this.element()));
                    this._isSizeUpdatable = true
                },
                _attachChildKeyboardEvents: function() {
                    this._strategy.attachKeyboardEvents(this._keyboardProcessor)
                },
                _renderPopup: function() {
                    this.callBase();
                    this._popup._wrapper().addClass(DATEBOX_WRAPPER_CLASS);
                    this._renderPopupWrapper()
                },
                _popupConfig: function() {
                    var popupConfig = this.callBase();
                    return $.extend(this._strategy.popupConfig(popupConfig), {
                            title: this._getPopupTitle(),
                            dragEnabled: false
                        })
                },
                _renderPopupWrapper: function() {
                    if (!this._popup)
                        return;
                    var $element = this.element();
                    var classPostfixes = $.extend({}, FORMAT, PICKER_TYPE);
                    $.each(classPostfixes, $.proxy(function(_, item) {
                        $element.removeClass(DATEBOX_WRAPPER_CLASS + "-" + item)
                    }, this));
                    this._popup._wrapper().addClass(DATEBOX_WRAPPER_CLASS + "-" + this.option("format")).addClass(DATEBOX_WRAPPER_CLASS + "-" + this._pickerType)
                },
                _renderPopupContent: function() {
                    this.callBase();
                    this._strategy.renderPopupContent()
                },
                _popupShowingHandler: function() {
                    this.callBase();
                    this._strategy.popupShowingHandler()
                },
                _popupHiddenHandler: function() {
                    this.callBase();
                    this._strategy.popupHiddenHandler()
                },
                _visibilityChanged: function(visible) {
                    if (visible)
                        this._updateSize()
                },
                _readOnlyPropValue: function() {
                    return this.callBase() || this._pickerType === PICKER_TYPE.rollers
                },
                _clearButtonVisibility: function() {
                    return this.callBase() && !this._isNativeType()
                },
                _renderValue: function() {
                    var mode = this.option("mode"),
                        value = this.dateOption("value"),
                        patternKey = uiDateUtils.FORMATS_MAP[mode],
                        pattern = this._getPattern(patternKey);
                    this._validateValue(value);
                    if (mode !== "text")
                        this.option("text", uiDateUtils.toStandardDateFormat(value, mode, pattern));
                    else
                        this.option("text", Globalize.format(value, this.option("formatString")));
                    this._strategy.renderValue();
                    this.callBase()
                },
                _getPattern: function(patternKey) {
                    return !support.inputType(this.option("mode")) ? Globalize.culture().calendar.patterns[patternKey] : null
                },
                _valueChangeEventHandler: function(e) {
                    var date = this._strategy.getParsedText(this.option("text"), this.option("formatString")),
                        value = this.dateOption("value"),
                        modelValue = new Date(value && value.valueOf()),
                        mode = this.option("mode"),
                        newValue = (mode !== "text" ? uiDateUtils.mergeDates(modelValue, date, mode) : date) || null;
                    if (this._validateValue(date))
                        this.dateOption("value", newValue);
                    else
                        this.option().value = null;
                    this.validationRequest.fire({
                        value: newValue,
                        editor: this
                    })
                },
                _validateValue: function(value) {
                    var text = this.option("text"),
                        hasText = !!text,
                        isDate = !!value,
                        isDateInRange = isDate && dateUtils.dateInRange(value, this.dateOption("min"), this.dateOption("max"), this.option("format")),
                        isValid = !hasText || !hasText && !value || isDateInRange,
                        validationMessage = "";
                    if (!isDate)
                        validationMessage = this.option("invalidDateMessage");
                    else if (!isDateInRange)
                        validationMessage = this.option("dateOutOfRangeMessage");
                    this.option({
                        isValid: isValid,
                        validationError: isValid ? null : {
                            editorSpecific: true,
                            message: validationMessage
                        }
                    });
                    return isValid
                },
                _renderProps: function() {
                    this.callBase();
                    this._input().attr("autocomplete", "off")
                },
                _renderOpenedState: function() {
                    if (!this._isNativeType())
                        this.callBase();
                    this._strategy.renderOpenedState()
                },
                _getPopupTitle: function() {
                    var placeholder = this.option("placeholder");
                    if (placeholder)
                        return placeholder;
                    var format = this.option("format");
                    if (format === FORMAT.time)
                        return Globalize.localize("dxDateBox-simulatedDataPickerTitleTime");
                    if (format === FORMAT.date || format === FORMAT.datetime)
                        return Globalize.localize("dxDateBox-simulatedDataPickerTitleDate");
                    return ""
                },
                _renderPlaceholder: function() {
                    this._popup && this._popup.option("title", this._getPopupTitle());
                    this.callBase()
                },
                _refreshStrategy: function() {
                    this._strategy.dispose();
                    this._initStrategy();
                    this.option(this._strategy.getDefaultOptions());
                    this._refresh()
                },
                _applyButtonHandler: function() {
                    this.dateOption("value", this._strategy.getValue());
                    this.callBase()
                },
                _dispose: function() {
                    this._strategy && this._strategy.dispose();
                    this.callBase()
                },
                _isNativeType: function() {
                    return this._pickerType === PICKER_TYPE["native"]
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"useCalendar":
                            this._updatePickerOptions({useCalendar: args.value});
                            this._refreshStrategy();
                            break;
                        case"useNative":
                            this._updatePickerOptions({useNative: args.value});
                            this._refreshStrategy();
                            break;
                        case"showClearButton":
                            this.callBase.apply(this, arguments);
                            this._updateSize();
                            break;
                        case"pickerType":
                            this._updatePickerOptions({pickerType: args.value});
                            this._refreshStrategy();
                            this._refreshPickerTypeClass();
                            this._invalidate();
                            break;
                        case"format":
                            this._updatePickerOptions({format: args.value});
                            this._refreshStrategy();
                            this._refreshFormatClass();
                            this._renderPopupWrapper();
                            this._updateSize();
                            break;
                        case"placeholder":
                            this._renderPlaceholder();
                            break;
                        case"readOnly":
                        case"min":
                        case"max":
                        case"interval":
                        case"minZoomLevel":
                        case"maxZoomLevel":
                            this._invalidate();
                            break;
                        case"type":
                            throw errors.Error("E1020");
                        case"formatString":
                            this._updateValue();
                            break;
                        case"formatWidthCalculator":
                            break;
                        case"closeOnValueChange":
                            var applyValueMode = args.value ? "instantly" : "useButtons";
                            this.option("applyValueMode", applyValueMode);
                            break;
                        case"applyValueMode":
                            this._suppressDeprecatedWarnings();
                            this.option("closeOnValueChange", args.value === "instantly");
                            this._resumeDeprecatedWarnings();
                            this.callBase.apply(this, arguments);
                            break;
                        case"text":
                            this._strategy.textChangedHandler(args.value);
                            this.callBase.apply(this, arguments);
                            break;
                        case"isValid":
                            this.callBase.apply(this, arguments);
                            this._updateSize();
                            break;
                        case"showDropButton":
                        case"invalidDateMessage":
                        case"dateOutOfRangeMessage":
                            break;
                        default:
                            this.callBase.apply(this, arguments)
                    }
                },
                _getSerializtionFormat: function() {
                    var value = this.option("value");
                    if (commonUtils.isNumber(value))
                        return "number";
                    if (!commonUtils.isString(value))
                        return;
                    return this.option("format") === "date" ? "yyyy/MM/dd" : "yyyy/MM/dd HH:mm:ss"
                },
                dateOption: function(optionName, value) {
                    var serializationFormat = this._getSerializtionFormat();
                    if (arguments.length === 1)
                        return dateUtils.deserializeDate(this.option(optionName), serializationFormat);
                    this.option(optionName, dateUtils.serializeDate(value, serializationFormat))
                },
                reset: function() {
                    this.callBase();
                    this._updateValue()
                }
            });
        registerComponent("dxDateBox", uiNamespace, DateBox);
        return DateBox
    });
    DevExpress.require(["/ui/widgets/date/ui.dateBox"]);
    /*! Module widgets-base, file ui.dateBox.strategy.js */
    DevExpress.define("/ui/widgets/date/ui.dateBox.strategy", ["jquery", "/class"], function($, Class) {
        var abstract = Class.abstract;
        var DateBoxStrategy = Class.inherit({
                ctor: function(dateBox) {
                    this.dateBox = dateBox
                },
                widgetOption: function() {
                    return this._widget && this._widget.option.apply(this._widget, arguments)
                },
                _renderWidget: function(element) {
                    element = element || $("<div>");
                    this._widget = this._createWidget(element);
                    this._widget.element().appendTo(this._getWidgetContainer())
                },
                _createWidget: function(element) {
                    var widgetName = this._getWidgetName();
                    var widgetOptions = this._getWidgetOptions();
                    return this.dateBox._createComponent(element, widgetName, widgetOptions)
                },
                _getWidgetOptions: abstract,
                _getWidgetName: abstract,
                getDefaultOptions: function() {
                    return {mode: "text"}
                },
                _getDateTimeFormatString: function() {
                    return Globalize.culture().calendar.patterns["d"] + " " + Globalize.culture().calendar.patterns["t"]
                },
                supportedKeys: $.noop,
                attachKeyboardEvents: function(keyboardProcessor) {
                    this._widgetKeyboardProcessor = keyboardProcessor.attachChildProcessor()
                },
                getParsedText: function(text, format) {
                    return Globalize.parseDate(text, format)
                },
                renderInputMinMax: $.noop,
                renderOpenedState: function() {
                    if (this.dateBox.option("opened"))
                        this._updateValue()
                },
                popupConfig: abstract,
                renderPopupContent: function() {
                    var popup = this._getPopup();
                    this._renderWidget();
                    popup.content().parent().off("mousedown").on("mousedown", $.proxy(this._preventFocusOnPopup, this))
                },
                _preventFocusOnPopup: function(e) {
                    e.preventDefault()
                },
                _getWidgetContainer: function() {
                    return this._getPopup().content()
                },
                _getPopup: function() {
                    return this.dateBox._popup
                },
                popupShowingHandler: $.noop,
                popupHiddenHandler: $.noop,
                _updateValue: function() {
                    this._widget && this._widget.option("value", this.dateBoxValue())
                },
                _valueChangedHandler: function(args) {
                    if (this.dateBox.option("opened") && this.dateBox.option("applyValueMode") === "instantly")
                        this.dateBoxValue(args.value)
                },
                textChangedHandler: $.noop,
                renderValue: function() {
                    if (this.dateBox.option("opened"))
                        this._updateValue()
                },
                getValue: function() {
                    return this._widget.option("value")
                },
                dispose: function() {
                    var popup = this._getPopup();
                    if (popup)
                        popup.content().empty()
                },
                dateBoxValue: function() {
                    var args = ["value"];
                    arguments.length && args.push(arguments[0]);
                    return this.dateBox.dateOption.apply(this.dateBox, args)
                }
            });
        return DateBoxStrategy
    });
    /*! Module widgets-base, file ui.dateBox.strategy.calendar.js */
    DevExpress.define("/ui/widgets/date/ui.dateBox.strategy.calendar", ["jquery", "/utils/utils.date", "/utils/utils.common", "/ui/widgets/date/ui.calendar", "/ui/widgets/date/ui.dateBox.strategy"], function($, dateUtils, commonUtils, Calendar, DateBoxStrategy) {
        var CalendarStrategy = DateBoxStrategy.inherit({
                NAME: "Calendar",
                supportedKeys: function() {
                    return {
                            tab: function() {
                                this.close()
                            },
                            rightArrow: function() {
                                if (this.option("opened"))
                                    return true
                            },
                            leftArrow: function() {
                                if (this.option("opened"))
                                    return true
                            },
                            enter: $.proxy(function(e) {
                                if (this.dateBox.option("opened")) {
                                    e.preventDefault();
                                    if (this._widget.option("zoomLevel") === this._widget.option("maxZoomLevel")) {
                                        var contouredDate = this._widget._view.option("contouredDate");
                                        contouredDate && this.dateBoxValue(contouredDate);
                                        this.dateBox.close();
                                        this.dateBox._valueChangeEventHandler(e)
                                    }
                                    else
                                        return true
                                }
                            }, this)
                        }
                },
                getDefaultOptions: function() {
                    return $.extend(this.callBase(), {formatString: Globalize.culture().calendar.patterns["d"]})
                },
                _getWidgetName: function() {
                    return Calendar.publicName()
                },
                _getWidgetOptions: function() {
                    return $.extend(this.dateBox.option("calendarOptions"), {
                            value: this.dateBoxValue(),
                            _keyboardProcessor: this._widgetKeyboardProcessor,
                            min: this.dateBox.dateOption("min"),
                            max: this.dateBox.dateOption("max"),
                            onValueChanged: $.proxy(this._valueChangedHandler, this),
                            onCellClick: $.proxy(this._cellClickHandler, this),
                            tabIndex: null,
                            maxZoomLevel: this.dateBox.option("maxZoomLevel"),
                            minZoomLevel: this.dateBox.option("minZoomLevel"),
                            onContouredChanged: $.proxy(this._refreshActiveDescendant, this),
                            hasFocus: function() {
                                return true
                            }
                        })
                },
                _refreshActiveDescendant: function(e) {
                    this.dateBox.setAria("activedescendant", e.actionValue)
                },
                popupConfig: function(popupConfig) {
                    var buttons = popupConfig.buttons,
                        buttonsLocation = this.dateBox.option("buttonsLocation");
                    var position = [];
                    if (buttonsLocation !== "default")
                        position = commonUtils.splitPair(buttonsLocation);
                    else
                        position = ["bottom", "center"];
                    if (this.dateBox.option("applyValueMode") === "useButtons")
                        buttons.unshift({
                            widget: "button",
                            toolbar: position[0],
                            location: position[1] === "after" ? "before" : position[1],
                            options: {
                                onClick: $.proxy(function() {
                                    this._widget._toTodayView()
                                }, this),
                                text: Globalize.localize("dxCalendar-todayButtonText"),
                                type: "today"
                            }
                        });
                    return $.extend(true, popupConfig, {
                            buttons: buttons,
                            position: {collision: "flipfit flip"}
                        })
                },
                _valueChangedHandler: function(e) {
                    var dateBox = this.dateBox,
                        value = e.value,
                        prevValue = e.previousValue;
                    var isSameDate = dateUtils.sameMonthAndYear(value, prevValue) && value.getDate() === prevValue.getDate();
                    if (isSameDate)
                        return;
                    if (dateBox.option("applyValueMode") === "instantly")
                        this.dateBoxValue(this.getValue())
                },
                _getParsedValue: function() {
                    return this.getParsedText(this.dateBox.option("text"), this.dateBox.option("formatString"))
                },
                _updateValue: function(preventDefaultValue) {
                    var parsedValue = this._getParsedValue();
                    if (this._widget) {
                        var value = this.dateBoxValue();
                        if (parsedValue)
                            this._widget.option("value", value)
                    }
                },
                textChangedHandler: function() {
                    if (this.dateBox.option("opened") && this._widget)
                        this._updateValue(true)
                },
                _cellClickHandler: function() {
                    var dateBox = this.dateBox;
                    if (dateBox.option("applyValueMode") === "instantly") {
                        dateBox.option("opened", false);
                        this.dateBoxValue(this.getValue())
                    }
                },
                dispose: function() {
                    this.dateBox.off("optionChanged");
                    this.callBase()
                }
            });
        return CalendarStrategy
    });
    /*! Module widgets-base, file ui.dateBox.strategy.calendarWithTime.js */
    DevExpress.define("/ui/widgets/date/ui.dateBox.strategy.calendarWithTime", ["jquery", "/ui/widgets/date/ui.dateBox.strategy.calendar", "/ui/widgets/date/ui.timeView"], function($, CalendarStrategy, TimeView) {
        var CalendarWithTimeStrategy = CalendarStrategy.inherit({
                NAME: "CalendarWithTime",
                supportedKeys: function() {
                    return $.extend(this.callBase(), {tab: function(e) {
                                if (this.option("opened") === true) {
                                    e.preventDefault();
                                    this._strategy._timeView._hourBox.focus()
                                }
                            }})
                },
                getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            formatString: this._getDateTimeFormatString(),
                            applyValueMode: "useButtons",
                            buttonsLocation: "bottom after",
                            showPopupTitle: false
                        })
                },
                _renderWidget: function() {
                    this.callBase();
                    this._timeView = this.dateBox._createComponent($("<div>"), TimeView, {
                        value: this.dateBoxValue(),
                        onValueChanged: $.proxy(this._valueChangedHandler, this)
                    })
                },
                _updateValue: function(preventDefaultValue) {
                    var date = this._getParsedValue();
                    if (!date && !preventDefaultValue)
                        date = new Date;
                    this.callBase.apply(this, arguments);
                    if (this._timeView && date)
                        this._timeView.option("value", date)
                },
                renderPopupContent: function() {
                    this.callBase();
                    var $popupContent = this._getPopup().content();
                    var box = this.dateBox._createComponent($("<div>").appendTo($popupContent), "dxBox", {
                            direction: "row",
                            crossAlign: "start",
                            items: [{
                                    ratio: 0,
                                    shrink: 0,
                                    baseSize: "auto",
                                    name: "calendar"
                                }, {
                                    ratio: 0,
                                    shrink: 0,
                                    baseSize: "auto",
                                    name: "time"
                                }],
                            itemTemplate: $.proxy(function(data) {
                                switch (data.name) {
                                    case"calendar":
                                        return $("<div>").append(this._widget.element());
                                    case"time":
                                        return $("<div>").append(this._timeView.element())
                                }
                            }, this)
                        });
                    this._removeMinWidthTimer = setTimeout(function() {
                        if (box.option("_layoutStrategy") === "fallback")
                            $popupContent.find(".dx-timeview-clock").css("minWidth", 0)
                    }, 0);
                    this._attachTabHandler()
                },
                _attachTabHandler: function() {
                    var dateBox = this.dateBox,
                        handler = function(e) {
                            if (e.shiftKey) {
                                e.preventDefault();
                                dateBox.focus()
                            }
                        };
                    this._timeView._hourBox.registerKeyHandler("tab", handler)
                },
                _preventFocusOnPopup: function(e) {
                    if (!$(e.target).hasClass("dx-texteditor-input")) {
                        this.callBase.apply(this, arguments);
                        if (!this.dateBox._hasFocusClass())
                            this.dateBox.focus()
                    }
                },
                getValue: function() {
                    var date = this._widget.option("value"),
                        time = this._timeView.option("value");
                    date = date ? new Date(date) : new Date;
                    date.setHours(time.getHours(), time.getMinutes(), time.getSeconds());
                    return date
                },
                dispose: function() {
                    clearTimeout(this._removeMinWidthTimer);
                    this.callBase()
                }
            });
        return CalendarWithTimeStrategy
    });
    /*! Module widgets-base, file ui.dateBox.strategy.dateView.js */
    DevExpress.define("/ui/widgets/date/ui.dateBox.strategy.dateView", ["jquery", "/ui/widgets/date/ui.dateUtils", "/utils/utils.support", "/ui/ui.themes", "/ui/widgets/date/ui.dateView", "/ui/widgets/date/ui.dateBox.strategy"], function($, dateUtils, support, themes, DateView, DateBoxStrategy) {
        var DateViewStrategy = DateBoxStrategy.inherit({
                NAME: "DateView",
                getDefaultOptions: function() {
                    var format = this.dateBox.option("format"),
                        formatString = "d";
                    if (format === "datetime")
                        formatString = this._getDateTimeFormatString();
                    else if (format === "time")
                        formatString = "t";
                    return $.extend(this.callBase(), {
                            openOnFieldClick: true,
                            applyButtonText: Globalize.localize("Done"),
                            formatString: formatString
                        })
                },
                popupConfig: function() {
                    return {
                            showTitle: true,
                            buttons: this.dateBox._popupButtonsConfig(),
                            defaultOptionsRules: [{
                                    device: function(device) {
                                        return device.platform === "win" && device.version && device.version[0] === 8
                                    },
                                    options: {showNames: true}
                                }, {
                                    device: function(device) {
                                        return device.platform === "win" && device.phone && device.version && device.version[0] === 8
                                    },
                                    options: {animation: null}
                                }, {
                                    device: function() {
                                        var currentTheme = (themes.current() || "").split(".")[0];
                                        return currentTheme === "win8"
                                    },
                                    options: {fullScreen: true}
                                }, {
                                    device: {platform: "android"},
                                    options: {
                                        width: 333,
                                        height: 331
                                    }
                                }, {
                                    device: function(device) {
                                        var platform = device.platform,
                                            version = device.version;
                                        return platform === "generic" || platform === "ios" || platform === "win" && version && version[0] === 10
                                    },
                                    options: {
                                        width: "auto",
                                        height: "auto"
                                    }
                                }, {
                                    device: function(device) {
                                        var currentTheme = (themes.current() || "").split(".")[0];
                                        return device.phone && currentTheme === "win10"
                                    },
                                    options: {
                                        width: 333,
                                        height: "auto"
                                    }
                                }, {
                                    device: {
                                        platform: "ios",
                                        phone: true
                                    },
                                    options: {
                                        width: "100%",
                                        position: {
                                            my: "bottom",
                                            at: "bottom",
                                            of: window
                                        }
                                    }
                                }]
                        }
                },
                _renderWidget: function() {
                    if (support.inputType(this.dateBox.option("mode")) && this.dateBox._isNativeType() || this.dateBox.option("readOnly")) {
                        if (this._widget) {
                            this._widget.element().remove();
                            this._widget = null
                        }
                        return
                    }
                    var popup = this._getPopup();
                    if (this._widget)
                        this._widget.option(this._getWidgetOptions());
                    else {
                        var element = $("<div>").appendTo(popup.content());
                        this._widget = this._createWidget(element)
                    }
                    this._widget.element().appendTo(this._getWidgetContainer())
                },
                _getWidgetName: function() {
                    return DateView.publicName()
                },
                _getWidgetOptions: function() {
                    return {
                            value: this.dateBoxValue() || new Date,
                            format: this.dateBox.option("format"),
                            minDate: this.dateBox.dateOption("min") || new Date(1900, 1, 1),
                            maxDate: this.dateBox.dateOption("max") || new Date($.now() + 50 * dateUtils.ONE_YEAR),
                            onDisposing: $.proxy(function() {
                                this._widget = null
                            }, this)
                        }
                },
                _updateValue: function() {
                    this._widget && this._widget.option("value", this.dateBoxValue() || new Date)
                }
            });
        return DateViewStrategy
    });
    /*! Module widgets-base, file ui.dateBox.strategy.native.js */
    DevExpress.define("/ui/widgets/date/ui.dateBox.strategy.native", ["jquery", "/utils/utils.support", "/ui/widgets/date/ui.dateUtils", "/ui/widgets/date/ui.dateBox.strategy"], function($, support, dateUtils, DateBoxStrategy) {
        var NativeStrategy = DateBoxStrategy.inherit({
                NAME: "Native",
                popupConfig: $.noop,
                getParsedText: function(text) {
                    return dateUtils.fromStandardDateFormat(text)
                },
                renderPopupContent: $.noop,
                _getWidgetName: $.noop,
                _getWidgetOptions: $.noop,
                getDefaultOptions: function() {
                    var format = this.dateBox.option("format");
                    if ($.inArray(format, dateUtils.SUPPORTED_FORMATS) === -1)
                        format = "date";
                    else if (format === "datetime" && !support.inputType(format))
                        format = "datetime-local";
                    this.dateBox.option({
                        mode: format,
                        formatString: dateUtils.FORMATS_MAP[format]
                    })
                },
                renderInputMinMax: function($input) {
                    $input.attr({
                        min: Globalize.format(this.dateBox.dateOption("min"), "yyyy-MM-dd"),
                        max: Globalize.format(this.dateBox.dateOption("max"), "yyyy-MM-dd")
                    })
                }
            });
        return NativeStrategy
    });
    /*! Module widgets-base, file ui.dateBox.strategy.list.js */
    DevExpress.define("/ui/widgets/date/ui.dateBox.strategy.list", ["jquery", "/utils/utils.common", "/devices", "/ui/widgets/date/ui.dateUtils", "/ui/widgets/date/ui.dateBox.strategy"], function($, commonUtils, devices, dateUtils, DateBoxStrategy) {
        var ListStrategy = DateBoxStrategy.inherit({
                NAME: "List",
                supportedKeys: function() {
                    return {
                            tab: function(e) {
                                if (this.option("opened"))
                                    this.close()
                            },
                            space: $.noop,
                            home: $.noop,
                            end: $.noop
                        }
                },
                getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            formatString: Globalize.culture().calendar.patterns["t"],
                            applyValueMode: "instantly"
                        })
                },
                popupConfig: function(popupConfig) {
                    var device = devices.current(),
                        result = $.extend(popupConfig, {width: this._getPopupWidth()});
                    if (device.platform === "android")
                        $.extend(result, {position: {offset: {
                                    h: -16,
                                    v: -10
                                }}});
                    return result
                },
                _getPopupWidth: function() {
                    var device = devices.current(),
                        result = this.dateBox.element().outerWidth();
                    if (device.platform === "android")
                        result += 32;
                    return result
                },
                popupShowingHandler: function() {
                    this._dimensionChanged()
                },
                _renderWidget: function() {
                    this.callBase();
                    this._refreshItems()
                },
                _getWidgetName: function() {
                    return "dxList"
                },
                _getWidgetOptions: function() {
                    var keyboardProcessor = this.dateBox._keyboardProcessor;
                    return {
                            _keyboardProcessor: keyboardProcessor ? keyboardProcessor.attachChildProcessor() : null,
                            itemTemplate: $.proxy(this._timeListItemTemplate, this),
                            onItemClick: $.proxy(this._listItemClickHandler, this),
                            tabIndex: -1,
                            onFocusedItemChanged: $.proxy(this._refreshActiveDescendant, this),
                            selectionMode: "single"
                        }
                },
                _refreshActiveDescendant: function(e) {
                    this.dateBox.setAria("activedescendant", "");
                    this.dateBox.setAria("activedescendant", e.actionValue)
                },
                _refreshItems: function() {
                    this._widgetItems = this._getTimeListItems();
                    this._widget.option("items", this._widgetItems)
                },
                renderOpenedState: function() {
                    this.callBase();
                    this._widget && this._widget.option("focusedElement", null)
                },
                _updateValue: function() {
                    if (!this._widget)
                        return;
                    var value = this.dateBoxValue();
                    var dateIndex = this._getDateIndex(value);
                    this._widget.option("selectedIndex", dateIndex)
                },
                _getDateIndex: function(date) {
                    var result = -1;
                    for (var i = 0, n = this._widgetItems.length; i < n; i++)
                        if (this._areDatesEqual(date, this._widgetItems[i])) {
                            result = i;
                            break
                        }
                    return result
                },
                _areDatesEqual: function(first, second) {
                    return commonUtils.isDate(first) && commonUtils.isDate(second) && first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes()
                },
                _getTimeListItems: function() {
                    var min = this.dateBox.dateOption("min") || new Date(0, 0, 0, 0, 0),
                        max = this.dateBox.dateOption("max") || new Date(0, 0, 0, 23, 59),
                        interval = this.dateBox.option("interval"),
                        result = [],
                        current = new Date(min),
                        delta = max - min;
                    if (delta < 0)
                        return [];
                    if (delta > dateUtils.ONE_DAY)
                        delta = dateUtils.ONE_DAY;
                    while (current - min < delta) {
                        result.push(new Date(current));
                        current.setMinutes(current.getMinutes() + interval)
                    }
                    return result
                },
                _timeListItemTemplate: function(itemData) {
                    return Globalize.format(itemData, this.dateBox.option("formatString"))
                },
                _listItemClickHandler: function(e) {
                    this.dateBox.option("opened", false);
                    this.dateBoxValue(e.itemData)
                },
                attachKeyboardEvents: function(keyboardProcessor) {
                    var child = keyboardProcessor.attachChildProcessor();
                    if (this._widget)
                        this._widget.option("_keyboardProcessor", child)
                },
                _dimensionChanged: function() {
                    this._getPopup() && this._updatePopupDimensions()
                },
                _updatePopupDimensions: function() {
                    this._updatePopupWidth();
                    this._updatePopupHeight()
                },
                _updatePopupWidth: function() {
                    this.dateBox._setPopupOption("width", this._getPopupWidth())
                },
                _updatePopupHeight: function() {
                    this.dateBox._setPopupOption("height", "auto");
                    var popupHeight = this._widget.element().outerHeight();
                    var maxHeight = $(window).height() * 0.45;
                    this.dateBox._setPopupOption("height", Math.min(popupHeight, maxHeight));
                    this.dateBox._timeList && this.dateBox._timeList.updateDimensions()
                }
            });
        return ListStrategy
    });
    /*! Module widgets-base, file ui.loadIndicator.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            support = DX.require("/utils/utils.support"),
            browser = DX.require("/utils/utils.browser"),
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget");
        var LOADINDICATOR_CLASS = "dx-loadindicator",
            LOADINDICATOR_WRAPPER_CLASS = "dx-loadindicator-wrapper",
            LOADINDICATOR_CONTENT_CLASS = "dx-loadindicator-content",
            LOADINDICATOR_ICON_CLASS = "dx-loadindicator-icon",
            LOADINDICATOR_SEGMENT_CLASS = "dx-loadindicator-segment",
            LOADINDICATOR_SEGMENT_INNER_CLASS = "dx-loadindicator-segment-inner",
            LOADINDICATOR_IMAGE_CLASS = "dx-loadindicator-image";
        registerComponent("dxLoadIndicator", ui, Widget.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        indicatorSrc: "",
                        activeStateEnabled: false,
                        hoverStateEnabled: false,
                        _animatingSegmentCount: 0
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function() {
                                var realDevice = devices.real(),
                                    obsoleteAndroid = realDevice.platform === "android" && !/chrome/i.test(navigator.userAgent);
                                return browser.msie && browser.version < 10 || obsoleteAndroid
                            },
                            options: {viaImage: true}
                        }, {
                            device: {platform: "win"},
                            options: {_animatingSegmentCount: 5}
                        }, {
                            device: function(device) {
                                return device.platform === "ios"
                            },
                            options: {_animatingSegmentCount: 11}
                        }, {
                            device: [{platform: "android"}],
                            options: {_animatingSegmentCount: 2}
                        }, {
                            device: [{platform: "generic"}],
                            options: {_animatingSegmentCount: 7}
                        }])
            },
            _init: function() {
                this.callBase();
                this.element().addClass(LOADINDICATOR_CLASS)
            },
            _render: function() {
                this._renderWrapper();
                this._renderContent();
                this._renderMarkup();
                this.callBase()
            },
            _renderWrapper: function() {
                this._$wrapper = $("<div>").addClass(LOADINDICATOR_WRAPPER_CLASS);
                this.element().append(this._$wrapper)
            },
            _renderContent: function() {
                this._$content = $("<div>").addClass(LOADINDICATOR_CONTENT_CLASS);
                this._$wrapper.append(this._$content)
            },
            _renderMarkup: function() {
                if (support.animation && !this.option("viaImage") && !this.option("indicatorSrc"))
                    this._renderMarkupForAnimation();
                else
                    this._renderMarkupForImage()
            },
            _renderMarkupForAnimation: function() {
                var currentDevice = devices.current();
                this._$indicator = $("<div>").addClass(LOADINDICATOR_ICON_CLASS);
                this._$content.append(this._$indicator);
                for (var i = this.option("_animatingSegmentCount"); i >= 0; --i) {
                    var $segment = $("<div>").addClass(LOADINDICATOR_SEGMENT_CLASS).addClass(LOADINDICATOR_SEGMENT_CLASS + i);
                    if (currentDevice.platform === "android")
                        $segment.append($("<div>").addClass(LOADINDICATOR_SEGMENT_INNER_CLASS));
                    this._$indicator.append($segment)
                }
            },
            _renderMarkupForImage: function() {
                var indicatorSrc = this.option("indicatorSrc");
                this._$wrapper.addClass(LOADINDICATOR_IMAGE_CLASS);
                if (indicatorSrc)
                    this._$wrapper.css("background-image", "url(" + indicatorSrc + ")")
            },
            _renderDimensions: function() {
                this.callBase();
                this._updateContentSizeForAnimation()
            },
            _updateContentSizeForAnimation: function() {
                if (!this._$indicator)
                    return;
                var width = this.option("width"),
                    height = this.option("height");
                if (width || height) {
                    width = this.element().width();
                    height = this.element().height();
                    var minDimention = Math.min(height, width);
                    this._$wrapper.css({
                        height: minDimention,
                        width: minDimention,
                        "font-size": minDimention
                    })
                }
            },
            _clean: function() {
                this.callBase();
                this._removeMarkupForAnimation();
                this._removeMarkupForImage()
            },
            _removeMarkupForAnimation: function() {
                if (!this._$indicator)
                    return;
                this._$indicator.remove();
                delete this._$indicator
            },
            _removeMarkupForImage: function() {
                this._$wrapper.css("background-image", "none")
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"_animatingSegmentCount":
                    case"indicatorSrc":
                        this._invalidate();
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.loadPanel.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            registerComponent = DX.require("/componentRegistrator");
        var LOADPANEL_CLASS = "dx-loadpanel",
            LOADPANEL_WRAPPER_CLASS = "dx-loadpanel-wrapper",
            LOADPANEL_INDICATOR_CLASS = "dx-loadpanel-indicator",
            LOADPANEL_MESSAGE_CLASS = "dx-loadpanel-message",
            LOADPANEL_CONTENT_CLASS = "dx-loadpanel-content",
            LOADPANEL_CONTENT_WRAPPER_CLASS = "dx-loadpanel-content-wrapper",
            LOADPANEL_PANE_HIDDEN_CLASS = "dx-loadpanel-pane-hidden";
        registerComponent("dxLoadPanel", ui, ui.dxOverlay.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        message: Globalize.localize("Loading"),
                        width: 222,
                        height: 90,
                        animation: null,
                        showIndicator: true,
                        indicatorSrc: "",
                        showPane: true,
                        delay: 0,
                        closeOnBackButton: false,
                        resizeEnabled: false
                    })
            },
            _init: function() {
                this.callBase.apply(this, arguments)
            },
            _render: function() {
                this.callBase();
                this.element().addClass(LOADPANEL_CLASS);
                this._wrapper().addClass(LOADPANEL_WRAPPER_CLASS)
            },
            _renderContentImpl: function() {
                this.callBase();
                this.content().addClass(LOADPANEL_CONTENT_CLASS);
                this._$contentWrapper = $("<div>").addClass(LOADPANEL_CONTENT_WRAPPER_CLASS);
                this._$contentWrapper.appendTo(this._$content);
                this._togglePaneVisible();
                this._cleanPreviousContent();
                this._renderLoadIndicator();
                this._renderMessage()
            },
            _show: function() {
                var delay = this.option("delay");
                if (!delay)
                    return this.callBase();
                var deferred = $.Deferred();
                var callBase = $.proxy(this.callBase, this);
                this._clearShowTimeout();
                this._showTimeout = setTimeout(function() {
                    callBase().done(function() {
                        deferred.resolve()
                    })
                }, delay);
                return deferred.promise()
            },
            _hide: function() {
                this._clearShowTimeout();
                return this.callBase()
            },
            _clearShowTimeout: function() {
                clearTimeout(this._showTimeout)
            },
            _renderMessage: function() {
                if (!this._$contentWrapper)
                    return;
                var message = this.option("message");
                if (!message)
                    return;
                var $message = $("<div>").addClass(LOADPANEL_MESSAGE_CLASS).text(message);
                this._$contentWrapper.append($message)
            },
            _renderLoadIndicator: function() {
                if (!this._$contentWrapper || !this.option("showIndicator"))
                    return;
                this._$indicator = $("<div>").addClass(LOADPANEL_INDICATOR_CLASS).appendTo(this._$contentWrapper);
                this._createComponent(this._$indicator, "dxLoadIndicator", {indicatorSrc: this.option("indicatorSrc")})
            },
            _cleanPreviousContent: function() {
                this.content().find("." + LOADPANEL_MESSAGE_CLASS).remove();
                this.content().find("." + LOADPANEL_INDICATOR_CLASS).remove()
            },
            _togglePaneVisible: function() {
                this.content().toggleClass(LOADPANEL_PANE_HIDDEN_CLASS, !this.option("showPane"))
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"delay":
                        break;
                    case"message":
                    case"showIndicator":
                        this._cleanPreviousContent();
                        this._renderLoadIndicator();
                        this._renderMessage();
                        break;
                    case"showPane":
                        this._togglePaneVisible();
                        break;
                    case"indicatorSrc":
                        if (this._$indicator)
                            this._createComponent(this._$indicator, "dxLoadIndicator", {indicatorSrc: this.option("indicatorSrc")});
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _dispose: function() {
                this._clearShowTimeout();
                this.callBase()
            }
        }));
        ui.dxLoadPanel.__internals = {
            LOADPANEL_CLASS: LOADPANEL_CLASS,
            LOADPANEL_WRAPPER_CLASS: LOADPANEL_WRAPPER_CLASS,
            LOADPANEL_MESSAGE_CLASS: LOADPANEL_MESSAGE_CLASS,
            LOADPANEL_CONTENT_CLASS: LOADPANEL_CONTENT_CLASS,
            LOADPANEL_PANE_HIDDEN_CLASS: LOADPANEL_PANE_HIDDEN_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.lookup.js */
    DevExpress.define("/ui/widgets/ui.lookup", ["jquery", "/utils/utils.string", "/utils/utils.version", "/utils/utils.support", "/utils/utils.browser", "/utils/utils.common", "/utils/utils.inkRipple", "/devices", "/componentRegistrator", "/ui/events/ui.events.utils", "/ui/widgets/ui.dropDownList", "/ui/uiNamespace"], function($, stringUtils, versionUtils, support, browser, commonUtils, inkRipple, devices, registerComponent, eventUtils, DropDownList, uiNamespace) {
        var compareVersions = versionUtils.compare;
        var LOOKUP_CLASS = "dx-lookup",
            LOOKUP_SELECTED_CLASS = "dx-lookup-selected",
            LOOKUP_SEARCH_CLASS = "dx-lookup-search",
            LOOKUP_SEARCH_WRAPPER_CLASS = "dx-lookup-search-wrapper",
            LOOKUP_FIELD_CLASS = "dx-lookup-field",
            LOOKUP_ARROW_CLASS = "dx-lookup-arrow",
            LOOKUP_FIELD_WRAPPER_CLASS = "dx-lookup-field-wrapper",
            LOOKUP_POPUP_CLASS = "dx-lookup-popup",
            LOOKUP_POPUP_WRAPPER_CLASS = "dx-lookup-popup-wrapper",
            LOOKUP_POPUP_SEARCH_CLASS = "dx-lookup-popup-search",
            LOOKUP_POPOVER_MODE = "dx-lookup-popover-mode",
            LOOKUP_EMPTY_CLASS = "dx-lookup-empty",
            LOOKUP_POPUP_VALIDATION_MESSAGE = "dx-lookup-validation-message",
            LOOKUP_POPUP_INVALID_CLASS = "dx-lookup-invalid",
            LIST_ITEM_SELECTOR = ".dx-list-item",
            LIST_ITEM_DATA_KEY = "dxListItemData";
        var POPUP_OPTION_MAP = {
                popupWidth: "width",
                popupHeight: "height"
            };
        var Lookup = DropDownList.inherit({
                _supportedKeys: function() {
                    return $.extend(this.callBase(), {
                            space: function(e) {
                                this._validatedOpening()
                            },
                            enter: function(e) {
                                this._validatedOpening()
                            }
                        })
                },
                _setDeprecatedOptions: function() {
                    this.callBase();
                    $.extend(this._deprecatedOptions, {
                        showNextButton: {
                            since: "15.1",
                            message: "Use the 'pageLoadMode' option instead"
                        },
                        pagingEnabled: {
                            since: "15.1",
                            message: "Use the 'dataSource.paginate' option instead"
                        }
                    })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            title: "",
                            titleTemplate: "title",
                            onTitleRendered: null,
                            placeholder: Globalize.localize("Select"),
                            searchPlaceholder: Globalize.localize("Search"),
                            searchEnabled: true,
                            cleanSearchOnOpening: true,
                            fullScreen: false,
                            showCancelButton: true,
                            cancelButtonText: Globalize.localize("Cancel"),
                            showClearButton: false,
                            clearButtonText: Globalize.localize("Clear"),
                            applyButtonText: Globalize.localize("Done"),
                            popupWidth: function() {
                                return $(window).width() * 0.8
                            },
                            popupHeight: function() {
                                return $(window).height() * 0.8
                            },
                            shading: true,
                            closeOnOutsideClick: false,
                            position: undefined,
                            animation: undefined,
                            pullRefreshEnabled: false,
                            useNativeScrolling: true,
                            pullingDownText: Globalize.localize("dxList-pullingDownText"),
                            pulledDownText: Globalize.localize("dxList-pulledDownText"),
                            refreshingText: Globalize.localize("dxList-refreshingText"),
                            pageLoadingText: Globalize.localize("dxList-pageLoadingText"),
                            onScroll: null,
                            onPullRefresh: null,
                            onPageLoading: null,
                            pageLoadMode: "scrollBottom",
                            showNextButton: undefined,
                            nextButtonText: Globalize.localize("dxList-nextButtonText"),
                            grouped: false,
                            groupTemplate: "group",
                            usePopover: false,
                            showDropButton: false,
                            showPopupTitle: true,
                            focusStateEnabled: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return !support.nativeScrolling
                                },
                                options: {useNativeScrolling: false}
                            }, {
                                device: function(device) {
                                    return !support.nativeScrolling && !devices.isSimulator() && devices.real().platform === "generic" && device.platform === "generic"
                                },
                                options: {
                                    pageLoadMode: "nextButton",
                                    usePopover: true
                                }
                            }, {
                                device: function(device) {
                                    return browser.msie && compareVersions(browser.version, 9) < 0
                                },
                                options: {usePopover: false}
                            }, {
                                device: function(device) {
                                    return device.platform === "win" && device.phone && device.version && device.version[0] === 8
                                },
                                options: {
                                    showCancelButton: false,
                                    fullScreen: true
                                }
                            }, {
                                device: function(device) {
                                    return device.platform === "win" && !device.phone && device.version && device.version[0] === 8
                                },
                                options: {popupWidth: function() {
                                        return $(window).width()
                                    }}
                            }, {
                                device: {
                                    platform: "ios",
                                    phone: true
                                },
                                options: {fullScreen: true}
                            }, {
                                device: {
                                    platform: "ios",
                                    tablet: true
                                },
                                options: {
                                    popupWidth: function() {
                                        return Math.min($(window).width(), $(window).height()) * 0.4
                                    },
                                    popupHeight: function() {
                                        return Math.min($(window).width(), $(window).height()) * 0.4
                                    },
                                    usePopover: true,
                                    useInkRipple: false
                                }
                            }, {
                                device: {platform: "generic"},
                                options: {buttonsLocation: "bottom center"}
                            }, {
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }, {
                                device: {platform: "android"},
                                options: {useInkRipple: true}
                            }])
                },
                _dataSourceOptions: function() {
                    this._suppressDeprecatedWarnings();
                    var pagingEnabled = commonUtils.ensureDefined(this.option("pagingEnabled"), true);
                    pagingEnabled = commonUtils.isDefined(this.option("showNextButton")) ? pagingEnabled || this.option("showNextButton") : pagingEnabled;
                    this._resumeDeprecatedWarnings();
                    return $.extend(this.callBase(), {paginate: pagingEnabled})
                },
                _inputWrapper: function() {
                    return this.element().find("." + LOOKUP_FIELD_WRAPPER_CLASS)
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(LOOKUP_CLASS).toggleClass(LOOKUP_POPOVER_MODE, this.option("usePopover"))
                },
                _fireContentReadyAction: $.noop,
                _popupWrapperClass: function() {
                    return ""
                },
                _renderInput: function() {
                    var fieldClickAction = this._createAction($.proxy(function() {
                            this._validatedOpening()
                        }, this));
                    this._$field = $("<div>").addClass(LOOKUP_FIELD_CLASS).on(eventUtils.addNamespace("dxclick", this.NAME), function(e) {
                        fieldClickAction({jQueryEvent: e})
                    });
                    var $arrow = $("<div>").addClass(LOOKUP_ARROW_CLASS);
                    this._$fieldWrapper = $("<div>").addClass(LOOKUP_FIELD_WRAPPER_CLASS).append(this._$field).append($arrow).appendTo(this.element());
                    this.option("useInkRipple") && this._renderInkRipple()
                },
                _renderInkRipple: function() {
                    this._inkRipple = inkRipple.render()
                },
                _toggleActiveState: function($element, value, e) {
                    this.callBase.apply(this, arguments);
                    if (!this._inkRipple)
                        return;
                    var config = {
                            element: this._inputWrapper(),
                            jQueryEvent: e
                        };
                    if (value)
                        this._inkRipple.renderWave(config);
                    else
                        this._inkRipple.removeWave(config)
                },
                _renderField: function() {
                    var fieldTemplate = this._getTemplateByOption("fieldTemplate");
                    if (!(fieldTemplate && this.option("fieldTemplate")))
                        return;
                    this._$field.empty();
                    var data = this._fieldRenderData();
                    fieldTemplate.render(data, this._$field)
                },
                _popupShowingHandler: function() {
                    var validationError;
                    if (this._$popupValidationMessage) {
                        validationError = this.option("validationError");
                        if (validationError && validationError.message) {
                            this._$popupValidationMessage.text(validationError.message);
                            this._popup.content().addClass(LOOKUP_POPUP_INVALID_CLASS)
                        }
                        else
                            this._popup.content().removeClass(LOOKUP_POPUP_INVALID_CLASS)
                    }
                    this.callBase.apply(this, arguments);
                    if (this.option("cleanSearchOnOpening")) {
                        if (this.option("searchEnabled") && this._searchBox.option("value")) {
                            this._searchBox.option("value", "");
                            this._searchCanceled();
                            this._searchDataSource()
                        }
                        this._list && this._list.option("focusedElement", null)
                    }
                    this._attachSearchChildProcessor()
                },
                _popupPositionedHandler: function() {
                    if (this.option("usePopover"))
                        this._updatePopoverHeight()
                },
                _updatePopoverHeight: function() {
                    if (!this._isInitialOptionValue("popupHeight"))
                        return;
                    var listHeight = 0,
                        topSpace = this._popup.content().position().top,
                        bottomSpace = this._popup.bottomToolbar() ? this._popup.bottomToolbar().outerHeight(true) : 0,
                        contentPaddings = topSpace + bottomSpace;
                    if (this._list) {
                        listHeight += this._list.element().position().top;
                        listHeight += this._list.element().outerHeight() - this._list.clientHeight();
                        listHeight += this._list.scrollHeight()
                    }
                    this._popup.overlayContent().css("maxHeight", "none");
                    var popupHeight = Math.min(listHeight + contentPaddings, this._popup.overlayContent().outerHeight());
                    this._popup.overlayContent().css("maxHeight", popupHeight);
                    this._list && this._list.updateDimensions()
                },
                _renderPopup: function() {
                    if (this.option("usePopover") && !this.option("fullScreen"))
                        this._renderPopover();
                    else
                        this.callBase();
                    this._$popup.addClass(LOOKUP_POPUP_CLASS);
                    this._popup._wrapper().addClass(LOOKUP_POPUP_WRAPPER_CLASS)
                },
                _popupOptionMap: function(optionName) {
                    return POPUP_OPTION_MAP[optionName] || optionName
                },
                _renderPopover: function() {
                    this._popup = this._createComponent(this._$popup, "dxPopover", $.extend(this._popupConfig(), {
                        target: this.element(),
                        fullScreen: false,
                        shading: false,
                        closeOnTargetScroll: true,
                        closeOnOutsideClick: true,
                        width: this._isInitialOptionValue("popupWidth") ? $.proxy(function() {
                            return this.element().outerWidth()
                        }, this) : this._popupConfig().width
                    }));
                    this._popup.on({
                        showing: $.proxy(this._popupShowingHandler, this),
                        shown: $.proxy(this._popupShownHandler, this),
                        hiding: $.proxy(this._popupHidingHandler, this),
                        hidden: $.proxy(this._popupHiddenHandler, this),
                        positioned: $.proxy(this._popupPositionedHandler, this)
                    });
                    this._popup.option("onContentReady", $.proxy(this._contentReadyHandler, this));
                    this._contentReadyHandler()
                },
                _popupHidingHandler: function() {
                    this.callBase();
                    this.option("focusStateEnabled") && this.focus()
                },
                _preventFocusOnPopup: $.noop,
                _popupConfig: function() {
                    var result = $.extend(this.callBase(), {
                            onShowing: null,
                            showTitle: this.option("showPopupTitle"),
                            title: this.option("title"),
                            titleTemplate: this._getTemplateByOption("titleTemplate"),
                            onTitleRendered: this.option("onTitleRendered"),
                            buttons: this._getPopupButtons(),
                            fullScreen: this.option("fullScreen"),
                            shading: this.option("shading"),
                            closeOnTargetScroll: false,
                            closeOnOutsideClick: this.option("closeOnOutsideClick")
                        });
                    delete result.animation;
                    delete result.position;
                    $.each(["position", "animation", "popupWidth", "popupHeight"], $.proxy(function(_, optionName) {
                        if (this.option(optionName) !== undefined)
                            result[this._popupOptionMap(optionName)] = this.option(optionName)
                    }, this));
                    return result
                },
                _getPopupButtons: function() {
                    var buttonsConfig = this.option("applyValueMode") === "useButtons" ? this._popupButtonsConfig() : [];
                    var cancelButton = this._getCancelButtonConfig();
                    if (cancelButton)
                        buttonsConfig.push(cancelButton);
                    var clearButton = this._getClearButtonConfig();
                    if (clearButton)
                        buttonsConfig.push(clearButton);
                    return this._applyButtonsLocation(buttonsConfig)
                },
                _popupButtonsConfig: function() {
                    return [{
                                shortcut: "done",
                                options: {
                                    onClick: $.proxy(this._applyButtonHandler, this),
                                    text: this.option("applyButtonText")
                                }
                            }]
                },
                _getCancelButtonConfig: function() {
                    return this.option("showCancelButton") ? {
                            shortcut: "cancel",
                            onClick: $.proxy(this._cancelButtonHandler, this),
                            options: {text: this.option("cancelButtonText")}
                        } : null
                },
                _getClearButtonConfig: function() {
                    return this.option("showClearButton") ? {
                            shortcut: "clear",
                            onClick: $.proxy(this._resetValue, this),
                            options: {text: this.option("clearButtonText")}
                        } : null
                },
                _applyButtonHandler: function() {
                    this.option("value", this._valueGetter(this._currentSelectedItem()));
                    this.callBase()
                },
                _cancelButtonHandler: function() {
                    this._refreshSelected();
                    this.callBase()
                },
                _refreshPopupVisibility: $.noop,
                _dimensionChanged: function() {
                    if (this.option("usePopover") && !this.option("popupWidth"))
                        this.option("popupWidth", this.element().width())
                },
                _input: function() {
                    return this._$searchBox || this.callBase()
                },
                _renderPopupContent: function() {
                    if (this._popup.NAME === "dxPopup")
                        this._$popupValidationMessage = $("<div>").addClass(LOOKUP_POPUP_VALIDATION_MESSAGE).appendTo(this._popup.content());
                    this._renderSearch();
                    this.callBase();
                    this._attachSearchChildProcessor()
                },
                _attachSearchChildProcessor: function() {
                    if (this.option("searchEnabled") && this._searchBox) {
                        this._listKeyboardProcessor = this._searchBox._keyboardProcessor.attachChildProcessor();
                        this._setListOption("_keyboardProcessor", this._listKeyboardProcessor)
                    }
                    else
                        this._setListOption("_keyboardProcessor", undefined)
                },
                _renderSearch: function() {
                    var $searchWrapper = this._$searchWrapper = $("<div>").addClass(LOOKUP_SEARCH_WRAPPER_CLASS);
                    var $searchBox = this._$searchBox = $("<div>").addClass(LOOKUP_SEARCH_CLASS).appendTo($searchWrapper);
                    var currentDevice = devices.current(),
                        searchMode = currentDevice.android && currentDevice.version[0] >= 5 ? "text" : "search";
                    this._searchBox = this._createComponent($searchBox, "dxTextBox", {
                        mode: searchMode,
                        showClearButton: true,
                        valueChangeEvent: this.option("valueChangeEvent"),
                        onValueChanged: $.proxy(this._search, this)
                    });
                    this._registerSearchKeyHandlers();
                    $searchWrapper.appendTo(this._popup.content());
                    this._renderSearchVisibility();
                    this._setSearchPlaceholder()
                },
                _registerSearchKeyHandlers: function() {
                    var that = this;
                    var selectListItem = function(e) {
                            var $itemElement = that._list.option("focusedElement");
                            if (!$itemElement)
                                return;
                            that._selectListItem(e.itemData, $itemElement)
                        };
                    this._searchBox.registerKeyHandler("escape", $.proxy(function(e) {
                        this.close()
                    }, this));
                    this._searchBox.registerKeyHandler("enter", $.proxy(function(e) {
                        selectListItem(e)
                    }, this));
                    this._searchBox.registerKeyHandler("space", $.proxy(function(e) {
                        selectListItem(e)
                    }, this))
                },
                _renderSearchVisibility: function() {
                    if (this._popup) {
                        var searchEnabled = this.option("searchEnabled");
                        this._popup._wrapper().toggleClass(LOOKUP_POPUP_SEARCH_CLASS, searchEnabled);
                        this._$searchWrapper.toggle(searchEnabled)
                    }
                },
                _setSearchPlaceholder: function() {
                    if (!this._$searchBox)
                        return;
                    var minSearchLength = this.option("minSearchLength");
                    var placeholder = this.option("searchPlaceholder");
                    if (minSearchLength && placeholder === Globalize.localize("Search"))
                        placeholder = stringUtils.format(Globalize.localize("dxLookup-searchPlaceholder"), minSearchLength);
                    this._searchBox.option("placeholder", placeholder)
                },
                _setAriaTargetForList: $.noop,
                _renderList: function() {
                    this.callBase();
                    this._list.registerKeyHandler("escape", $.proxy(function(e) {
                        this.close()
                    }, this))
                },
                _listConfig: function() {
                    return $.extend(this.callBase(), {
                            tabIndex: 0,
                            grouped: this.option("grouped"),
                            groupTemplate: this._getTemplateByOption("groupTemplate"),
                            pullRefreshEnabled: this.option("pullRefreshEnabled"),
                            useNativeScrolling: this.option("useNativeScrolling"),
                            pullingDownText: this.option("pullingDownText"),
                            pulledDownText: this.option("pulledDownText"),
                            refreshingText: this.option("refreshingText"),
                            pageLoadingText: this.option("pageLoadingText"),
                            onScroll: this.option("onScroll"),
                            onPullRefresh: this.option("onPullRefresh"),
                            onPageLoading: this.option("onPageLoading"),
                            pageLoadMode: this._getPageLoadMode(),
                            nextButtonText: this.option("nextButtonText"),
                            _keyboardProcessor: this._listKeyboardProcessor,
                            onFocusIn: $.proxy(this._onFocusInHandler, this)
                        })
                },
                _onFocusInHandler: function() {
                    this._setListOption("_keyboardProcessor", undefined)
                },
                _listContentReadyHandler: function() {
                    if (this.option("usePopover"))
                        this._popup.repaint();
                    this.callBase.apply(this, arguments)
                },
                _getPageLoadMode: function() {
                    this._suppressDeprecatedWarnings();
                    var result = commonUtils.isDefined(this.option("showNextButton")) ? "nextButton" : this.option("pageLoadMode");
                    this._resumeDeprecatedWarnings();
                    return result
                },
                _setFocusPolicy: function() {
                    if (!this.option("focusStateEnabled"))
                        return;
                    if (this.option("searchEnabled"))
                        this._searchBox.focus();
                    else
                        this._$list.focus()
                },
                _attachChildKeyboardEvents: $.noop,
                _focusTarget: function() {
                    return this._$field
                },
                _keyboardEventBindingTarget: function() {
                    return this._$field
                },
                _selectedItemClass: function() {
                    return LOOKUP_SELECTED_CLASS
                },
                _listItemClickHandler: function(e) {
                    this._selectListItem(e.itemData, e.jQueryEvent.target)
                },
                _selectListItem: function(itemData, target) {
                    if (this._currentSelectedItem() === itemData)
                        this._applyButtonHandler();
                    this._setCurrentSelectedClass(target);
                    if (this.option("applyValueMode") === "instantly")
                        this._applyButtonHandler()
                },
                _currentSelectedItem: function() {
                    return this._listSelectedItemElements().data(LIST_ITEM_DATA_KEY)
                },
                _setCurrentSelectedClass: function(target) {
                    this._listSelectedItemElements().removeClass(LOOKUP_SELECTED_CLASS);
                    $(target).closest(LIST_ITEM_SELECTOR).addClass(LOOKUP_SELECTED_CLASS)
                },
                _resetValue: function() {
                    this.option("value", null);
                    this.option("opened", false)
                },
                _searchValue: function() {
                    return this.option("searchEnabled") ? this._searchBox.option("value") : ""
                },
                _renderInputValue: function() {
                    return this.callBase().always($.proxy(function() {
                            this._refreshField()
                        }, this))
                },
                _refreshField: function() {
                    this._$field.text(this.option("displayValue") || this.option("placeholder"));
                    this.element().toggleClass(LOOKUP_EMPTY_CLASS, !this.option("selectedItem"))
                },
                _renderPlaceholder: function(){},
                _clean: function() {
                    this._$fieldWrapper.remove();
                    this._$searchBox = null;
                    this.callBase()
                },
                _optionChanged: function(args) {
                    var name = args.name;
                    var value = args.value;
                    switch (name) {
                        case"searchEnabled":
                            this._renderSearchVisibility();
                            this._attachSearchChildProcessor();
                            break;
                        case"searchPlaceholder":
                            this._setSearchPlaceholder();
                            break;
                        case"minSearchLength":
                            this._setSearchPlaceholder();
                            this.callBase.apply(this, arguments);
                            break;
                        case"title":
                        case"titleTemplate":
                        case"onTitleRendered":
                        case"shading":
                        case"animation":
                        case"position":
                        case"closeOnOutsideClick":
                            this._setPopupOption(name);
                            break;
                        case"fullScreen":
                        case"usePopover":
                        case"placeholder":
                            this._invalidate();
                            break;
                        case"clearButtonText":
                        case"showClearButton":
                        case"showCancelButton":
                            this._setPopupOption("buttons", this._getPopupButtons());
                            break;
                        case"applyValueMode":
                            this.callBase.apply(this, arguments);
                            break;
                        case"popupWidth":
                            this._setPopupOption("popupWidth", value === "auto" ? this.initialOption("popupWidth") : value);
                            break;
                        case"popupHeight":
                            this._setPopupOption("popupHeight", value === "auto" ? this.initialOption("popupHeight") : value);
                            break;
                        case"pullRefreshEnabled":
                        case"useNativeScrolling":
                        case"pullingDownText":
                        case"pulledDownText":
                        case"refreshingText":
                        case"pageLoadingText":
                        case"onScroll":
                        case"onPullRefresh":
                        case"onPageLoading":
                        case"nextButtonText":
                        case"grouped":
                        case"groupTemplate":
                            this._setListOption(name);
                            break;
                        case"showNextButton":
                        case"pageLoadMode":
                            this._setListOption("pageLoadMode", this._getPageLoadMode());
                            break;
                        case"cleanSearchOnOpening":
                            break;
                        default:
                            this.callBase.apply(this, arguments)
                    }
                },
                focus: function() {
                    this.option("opened") ? this._setFocusPolicy() : this._focusTarget().focus()
                },
                field: function() {
                    return this._$field
                }
            });
        registerComponent("dxLookup", uiNamespace, Lookup);
        return Lookup
    });
    DevExpress.require(["/ui/widgets/ui.lookup"]);
    /*! Module widgets-base, file ui.autocomplete.js */
    DevExpress.define("/ui/widgets/ui.autocomplete", ["jquery", "/componentRegistrator", "/ui/widgets/ui.dropDownList", "/ui/uiNamespace"], function($, registerComponent, DropDownList, uiNamespace) {
        var AUTOCOMPLETE_CLASS = "dx-autocomplete",
            AUTOCOMPLETE_POPUP_WRAPPER_CLASS = "dx-autocomplete-popup-wrapper",
            CONTROL_KEY = {
                "9": "tab",
                "13": "enter",
                "16": "shift",
                "17": "ctrl",
                "18": "alt",
                "27": "escape",
                "33": "pageUp",
                "34": "pageDown",
                "35": "end",
                "36": "home",
                "37": "leftArrow",
                "38": "upArrow",
                "39": "rightArrow",
                "40": "downArrow"
            };
        var Autocomplete = DropDownList.inherit({
                _supportedKeys: function() {
                    var item = this._list ? this._list.option("focusedElement") : null;
                    return $.extend(this.callBase(), {
                            upArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                if (item && !item.prev().length) {
                                    this._clearFocusedItem();
                                    return false
                                }
                                return true
                            },
                            downArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                if (item && !item.next().length) {
                                    this._clearFocusedItem();
                                    return false
                                }
                                return true
                            },
                            enter: function(e) {
                                if (!item)
                                    this.close();
                                return true
                            }
                        })
                },
                _setOptionAliases: function() {
                    this.callBase();
                    $.extend(this._optionAliases, {displayExpr: "valueExpr"})
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            minSearchLength: 1,
                            maxItemCount: 10,
                            noDataText: "",
                            showDropButton: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return device.platform === "android"
                                },
                                options: {popupPosition: {offset: {
                                            h: -16,
                                            v: -9
                                        }}}
                            }])
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(AUTOCOMPLETE_CLASS);
                    this.setAria("autocomplete", "inline")
                },
                _loadValue: function() {
                    return $.Deferred().resolve(this.option("value"))
                },
                _displayGetterExpr: function() {
                    return this.option("valueExpr")
                },
                _setSelectedItem: function(item) {
                    this.callBase(item);
                    this.option("displayValue", this.option("value"))
                },
                _popupConfig: function() {
                    return $.extend(this.callBase(), {closeOnOutsideClick: $.proxy(function(e) {
                                return !$(e.target).closest(this.element()).length
                            }, this)})
                },
                _renderDimensions: function() {
                    this.callBase();
                    this._setPopupOption("width")
                },
                _popupWrapperClass: function() {
                    return this.callBase() + " " + AUTOCOMPLETE_POPUP_WRAPPER_CLASS
                },
                _listConfig: function() {
                    return $.extend(this.callBase(), {
                            pageLoadMode: "none",
                            indicateLoading: false
                        })
                },
                _listItemClickHandler: function(e) {
                    var value = this._displayGetter(e.itemData);
                    this.option("value", value);
                    this.close()
                },
                _refreshSelected: $.noop,
                _searchCanceled: function() {
                    this.callBase();
                    this.close()
                },
                _dataSourceOptions: function() {
                    return {paginate: true}
                },
                _searchDataSource: function() {
                    this._dataSource.pageSize(this.option("maxItemCount"));
                    this.callBase();
                    this._clearFocusedItem()
                },
                _clearFocusedItem: function() {
                    if (this._list) {
                        this._list.option("focusedElement", null);
                        this._list.option("selectedIndex", -1)
                    }
                },
                _renderValueEventName: function() {
                    return "input keyup"
                },
                _keyPressHandler: function(e) {
                    if (CONTROL_KEY[e.which || e.keyCode])
                        return;
                    this.callBase.apply(this, arguments);
                    this._search()
                },
                _optionChanged: function(args) {
                    if (args.name === "maxItemCount")
                        this._searchDataSource();
                    else
                        this.callBase(args)
                }
            });
        registerComponent("dxAutocomplete", uiNamespace, Autocomplete);
        return Autocomplete
    });
    DevExpress.require(["/ui/widgets/ui.autocomplete"]);
    /*! Module widgets-base, file ui.selectBox.js */
    DevExpress.define("/ui/widgets/ui.selectBox", ["jquery", "/utils/utils.common", "/utils/utils.inkRipple", "/componentRegistrator", "/ui/events/ui.events.utils", "/ui/widgets/ui.dropDownList", "/ui/uiNamespace"], function($, commonUtils, inkRipple, registerComponent, eventUtils, DropDownList, uiNamespace) {
        var SELECTBOX_CLASS = "dx-selectbox",
            SELECTBOX_POPUP_CLASS = "dx-selectbox-popup",
            SELECTBOX_SELECTED_CLASS = "dx-selectbox-selected",
            SELECTBOX_CONTAINER_CLASS = "dx-selectbox-container",
            SELECTBOX_POPUP_WRAPPER_CLASS = "dx-selectbox-popup-wrapper";
        var CONTROL_KEY = {
                "9": "tab",
                "13": "enter",
                "16": "shift",
                "17": "ctrl",
                "18": "alt",
                "27": "escape",
                "33": "pageUp",
                "34": "pageDown",
                "35": "end",
                "36": "home",
                "37": "leftArrow",
                "38": "upArrow",
                "39": "rightArrow",
                "40": "downArrow"
            };
        var SelectBox = DropDownList.inherit({
                _supportedKeys: function() {
                    var parent = this.callBase(),
                        clearSelectBox = function(e) {
                            if (this.option("showClearButton") && !this._isEditable()) {
                                e.preventDefault();
                                this.reset()
                            }
                        };
                    return $.extend({}, parent, {
                            tab: function(e) {
                                this.close()
                            },
                            upArrow: function(e) {
                                if (parent.upArrow.apply(this, arguments)) {
                                    if (!this.option("opened"))
                                        this._setNextValue(-1);
                                    return true
                                }
                            },
                            downArrow: function(e) {
                                if (parent.downArrow.apply(this, arguments)) {
                                    if (!this.option("opened"))
                                        this._setNextValue(1);
                                    return true
                                }
                            },
                            enter: function(e) {
                                if (this._input().val() === "") {
                                    this.option({
                                        selectedItem: null,
                                        value: null
                                    });
                                    this.close()
                                }
                                else {
                                    if (this.option("fieldEditEnabled"))
                                        e.preventDefault();
                                    if (parent.enter.apply(this, arguments))
                                        return this.option("opened")
                                }
                            },
                            backspace: clearSelectBox,
                            del: clearSelectBox
                        })
                },
                _selectFirstItem: function() {
                    if (this._isEditable())
                        this.callBase()
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            placeholder: Globalize.localize("Select"),
                            fieldTemplate: null,
                            valueChangeEvent: "keyup",
                            fieldEditEnabled: false,
                            showSelectionControls: false,
                            tooltipEnabled: false,
                            openOnFieldClick: true,
                            showDropButton: true,
                            displayCustomValue: false,
                            _isAdaptablePopupPosition: false,
                            useInkRipple: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return device.platform === "win" && device.version && device.version[0] === 8
                                },
                                options: {
                                    _isAdaptablePopupPosition: true,
                                    popupPosition: {
                                        at: "left top",
                                        offset: {
                                            h: 0,
                                            v: 0
                                        }
                                    }
                                }
                            }, {
                                device: function(device) {
                                    return device.platform === "android"
                                },
                                options: {
                                    _isAdaptablePopupPosition: true,
                                    popupPosition: {offset: {
                                            h: -16,
                                            v: -9
                                        }}
                                }
                            }, {
                                device: {platform: "android"},
                                options: {useInkRipple: true}
                            }])
                },
                _selectedItemClass: function() {
                    return SELECTBOX_SELECTED_CLASS
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(SELECTBOX_CLASS);
                    this.option("useInkRipple") && this._renderInkRipple();
                    this._renderTooltip()
                },
                _renderInkRipple: function() {
                    this._inkRipple = inkRipple.render()
                },
                _toggleActiveState: function($element, value, e) {
                    this.callBase.apply(this, arguments);
                    if (!this._inkRipple)
                        return;
                    var config = {
                            element: this._inputWrapper(),
                            jQueryEvent: e
                        };
                    if (value)
                        this._inkRipple.renderWave(config);
                    else
                        this._inkRipple.removeWave(config)
                },
                _createPopup: function() {
                    this.callBase();
                    this._updatePopupPosition();
                    this._popup.element().addClass(SELECTBOX_POPUP_CLASS)
                },
                _popupWrapperClass: function() {
                    return this.callBase() + " " + SELECTBOX_POPUP_WRAPPER_CLASS
                },
                _renderOpenedState: function() {
                    this.callBase();
                    if (this.option("opened")) {
                        this._updatePopupHeight();
                        this._scrollToSelectedItem()
                    }
                },
                _updatePopupPosition: function() {
                    if (!this.option("_isAdaptablePopupPosition") || this.option("popupPosition") !== this.initialOption("popupPosition"))
                        return;
                    if (this._isEditable()) {
                        var adaptablePopupPosition = $.extend(this._getDefaultPopupPosition(), {offset: {
                                    h: this.option("popupPosition").offset.h,
                                    v: -4
                                }});
                        this._setPopupOption("position", adaptablePopupPosition)
                    }
                    else
                        this._setPopupOption("position", this.initialOption("popupPosition"))
                },
                _scrollToSelectedItem: function() {
                    if (this._dataSource.paginate() && this._isEditable())
                        this._list.scrollTo(0);
                    else
                        this._list.scrollToItem(this._$list.find("." + this._selectedItemClass()))
                },
                _renderInputValue: function() {
                    return this.callBase().always($.proxy(function() {
                            this._renderTooltip();
                            this._renderInputAddons()
                        }, this))
                },
                _fitIntoRange: function(value, start, end) {
                    if (value > end)
                        return start;
                    if (value < start)
                        return end;
                    return value
                },
                _setNextValue: function(step) {
                    var dataSourceIsLoaded = this._dataSource.isLoaded() ? $.Deferred().resolve() : this._dataSource.load();
                    dataSourceIsLoaded.done($.proxy(function() {
                        var value = this._valueGetter(this._calcNextItem(step));
                        this._setValue(value)
                    }, this))
                },
                _calcNextItem: function(step) {
                    var items = this._dataSource.items();
                    var nextIndex = this._fitIntoRange(this._getSelectedIndex() + step, 0, items.length - 1);
                    return items[nextIndex]
                },
                _getSelectedIndex: function() {
                    var items = this._dataSource.items();
                    var selectedItem = this.option("selectedItem");
                    var result = -1;
                    $.each(items, $.proxy(function(index, item) {
                        if (this._isValueEquals(item, selectedItem)) {
                            result = index;
                            return false
                        }
                    }, this));
                    return result
                },
                _setSelectedItem: function(item) {
                    var isUnknownItem = !this._isCustomValueAllowed() && item === undefined;
                    this.callBase(isUnknownItem ? null : item)
                },
                _isCustomValueAllowed: function() {
                    return this.option("fieldEditEnabled") || this.callBase()
                },
                _displayValue: function(item) {
                    item = !commonUtils.isDefined(item) && this._isCustomValueAllowed() ? this.option("value") : item;
                    return this.callBase(item)
                },
                _listConfig: function() {
                    var result = $.extend(this.callBase(), {
                            pageLoadMode: "scrollBottom",
                            onSelectionChanged: this._getSelectionChangeHandler(),
                            selectionMode: "single"
                        });
                    if (this.option("showSelectionControls"))
                        $.extend(result, {showSelectionControls: true});
                    return result
                },
                _getSelectionChangeHandler: function() {
                    return this.option("showSelectionControls") ? $.proxy(this._selectionChangeHandler, this) : $.noop
                },
                _selectionChangeHandler: function(e) {
                    $.each(e.addedItems || [], $.proxy(function(_, addedItem) {
                        this._setValue(this._valueGetter(addedItem))
                    }, this))
                },
                _toggleOpenState: function() {
                    if (this.option("disabled") || !this._wasSearch() || this.option("opened") || !this._isEditable()) {
                        this.callBase.apply(this, arguments);
                        return
                    }
                    this._wasSearch(false);
                    this._filterDataSource(null);
                    this._input().focus()
                },
                _renderTooltip: function() {
                    if (this.option("tooltipEnabled"))
                        this.element().attr("title", this.option("displayValue"))
                },
                _renderDimensions: function() {
                    this.callBase();
                    this._setPopupOption("width")
                },
                _renderInput: function() {
                    this.callBase();
                    this._$container.addClass(SELECTBOX_CONTAINER_CLASS);
                    var eventName = eventUtils.addNamespace("blur", this.NAME);
                    this._input().off(eventName).on(eventName, $.proxy(this._fieldBlurHandler, this))
                },
                _fieldBlurHandler: function() {
                    if (this.option("searchEnabled") && !this.option("fieldEditEnabled")) {
                        var selectedItem = this.option("selectedItem");
                        this._renderInputValue().always($.proxy(function(e) {
                            this._setSelectedItem(selectedItem);
                            this._renderDisplayText(this._displayGetter(this.option("selectedItem")))
                        }, this))
                    }
                },
                _renderValueChangeEvent: function() {
                    if (this._isEditable())
                        this.callBase()
                },
                _isEditable: function() {
                    return this.option("fieldEditEnabled") || this.option("searchEnabled")
                },
                _fieldRenderData: function() {
                    return this.option("selectedItem")
                },
                _readOnlyPropValue: function() {
                    return !this._isEditable() || this.option("readOnly")
                },
                _isSelectedValue: function(value) {
                    return this._isValueEquals(value, this.option("value"))
                },
                _listItemClickHandler: function(e) {
                    var previousValue = this.option("value");
                    this._completeSelection(this._valueGetter(e.itemData));
                    if (this.option("searchEnabled") && previousValue === this._valueGetter(e.itemData))
                        this._renderDisplayText(this._displayGetter(e.itemData))
                },
                _completeSelection: function(value) {
                    if (value === undefined)
                        value = this.option("fieldEditEnabled") && this._searchValue() ? this._searchValue() : this.option("value");
                    this.option("opened", false);
                    if (this._wasSearch())
                        this._clearFilter();
                    this._setValue(value)
                },
                _setValue: function(value) {
                    this.option("value", value)
                },
                _clearValueHandler: function() {
                    this.reset()
                },
                _valueChangeEventHandler: function(e) {
                    if (CONTROL_KEY[e.which || e.keyCode])
                        return;
                    if (this.option("fieldEditEnabled")) {
                        this._valueUpdateSuppressed = true;
                        this.callBase.apply(this, arguments);
                        this._valueUpdateSuppressed = false
                    }
                    if (this.option("searchEnabled"))
                        this._search()
                },
                _createClearButton: function() {
                    var eventName = eventUtils.addNamespace("dxclick", this.NAME);
                    return this.callBase().on(eventName, function() {
                            return false
                        })
                },
                _search: function() {
                    if (this._needPassDataSourceToList())
                        this._wasSearch(true);
                    this.callBase()
                },
                _wasSearch: function(value) {
                    if (!arguments.length)
                        return this._wasSearchValue;
                    this._wasSearchValue = value
                },
                _filterDataSource: function(searchValue) {
                    this.callBase(searchValue);
                    this._setCollectionWidgetOption("noDataText", searchValue ? "" : this._list && this._list.initialOption("noDataText"))
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"_isAdaptablePopupPosition":
                            break;
                        case"tooltipEnabled":
                            this._renderTooltip();
                            break;
                        case"displayCustomValue":
                        case"fieldEditEnabled":
                        case"showSelectionControls":
                        case"useInkRipple":
                            this._invalidate();
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        registerComponent("dxSelectBox", uiNamespace, SelectBox);
        return SelectBox
    });
    DevExpress.require(["/ui/widgets/ui.selectBox"]);
    /*! Module widgets-base, file ui.tagBox.removeButton.js */
    DevExpress.define("/ui/widgets/tagBox/ui.tagBox.removeButton", ["jquery", "/ui/ui.widget"], function($, Widget) {
        var TAGBOX_TAG_REMOVE_BUTTON_CLASS = "dx-tag-remove-button";
        var TagRemoveButton = Widget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {activeStateEnabled: true})
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(TAGBOX_TAG_REMOVE_BUTTON_CLASS)
                }
            });
        return TagRemoveButton
    });
    /*! Module widgets-base, file ui.tagBox.js */
    DevExpress.define("/ui/widgets/ui.tagBox", ["jquery", "/utils/utils.common", "/componentRegistrator", "/ui/templates/ui.template.function", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer", "/ui/widgets/ui.selectBox", "/ui/uiNamespace", "/ui/widgets/tagBox/ui.tagBox.removeButton"], function($, commonUtils, registerComponent, FunctionTemplate, eventUtils, pointerEvents, SelectBox, uiNamespace, TagRemoveButton) {
        var TAGBOX_TAG_DATA_KEY = "dxTagData";
        var TAGBOX_CLASS = "dx-tagbox",
            TAGBOX_TAG_CONTAINER_CLASS = "dx-tag-container",
            TAGBOX_TAG_CLASS = "dx-tag",
            TAGBOX_TAG_CONTENT_CLASS = "dx-tag-content",
            TAGBOX_TAG_REMOVE_BUTTON_CLASS = "dx-tag-remove-button",
            TAGBOX_ONLY_SELECT_CLASS = "dx-tagbox-only-select",
            EMPTY_INPUT_CLASS = "dx-texteditor-empty";
        var TagBox = SelectBox.inherit({
                _supportedKeys: function() {
                    var parent = this.callBase();
                    return $.extend(parent, {
                            backspace: function(e) {
                                if (this._searchValue().length)
                                    return;
                                e.preventDefault();
                                e.stopPropagation();
                                var values = this._values();
                                this._removeTagWithUpdate(values[values.length - 1])
                            },
                            enter: function(e) {
                                if (this.option("fieldEditEnabled") && !this._$list.find(".dx-state-focused").length) {
                                    e.preventDefault();
                                    this._completeSelection()
                                }
                                else {
                                    this.option("opened") && e.preventDefault();
                                    this._keyboardProcessor._childProcessors[0].process(e)
                                }
                            }
                        })
                },
                _setNextValue: $.noop,
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            values: [],
                            onValuesChanged: null,
                            showDropButton: false,
                            tagTemplate: "tag",
                            selectAllText: Globalize.localize("dxList-selectAll")
                        })
                },
                _init: function() {
                    this.callBase();
                    this._initValuesChangedAction();
                    this._initDynamicTagTemplate();
                    this._values(this.option("values"));
                    this._updateValues()
                },
                _initValuesChangedAction: function() {
                    this._valuesChangedAction = this._createActionByOption("onValuesChanged", {excludeValidators: ["disabled", "readonly"]});
                    this._removeTagAction = this._createAction($.proxy(this._removeTagHandler, this))
                },
                _initDynamicTagTemplate: function() {
                    if (this._displayGetterExpr())
                        this._dynamicTemplates["tag"] = new FunctionTemplate($.proxy(function(data) {
                            return this._displayGetter(data)
                        }, this));
                    else
                        delete this._dynamicTemplates["tag"]
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(TAGBOX_CLASS);
                    this.element().toggleClass(TAGBOX_ONLY_SELECT_CLASS, !(this.option("searchEnabled") || this.option("fieldEditEnabled")));
                    var eventName = eventUtils.addNamespace("dxclick", "dxTagBoxTagRemove");
                    this.element().find(".dx-texteditor-container").off(eventName).on(eventName, "." + TAGBOX_TAG_REMOVE_BUTTON_CLASS, $.proxy(function(e) {
                        this._removeTagAction({jQueryEvent: e})
                    }, this))
                },
                _renderInputValue: function() {
                    return this.callBase().always($.proxy(function() {
                            this._renderMultiSelect()
                        }, this))
                },
                _listContentReadyHandler: function() {
                    this._suppressingSelectionChanged(function() {
                        this._valuesChangedAction = $.noop;
                        this._setListOption("selectedItems", this._selectedItems)
                    });
                    this.callBase();
                    this._initValuesChangedAction()
                },
                _suppressingSelectionChanged: function(callback) {
                    this._setListOption("onSelectionChanged", $.noop);
                    callback.call(this);
                    this._setListOption("onSelectionChanged", this._getSelectionChangeHandler())
                },
                _listConfig: function() {
                    var config = this.callBase();
                    if (this.option("showSelectionControls"))
                        $.extend(config, {
                            selectionMode: "all",
                            selectAllText: this.option("selectAllText")
                        });
                    return config
                },
                _renderMultiSelect: function() {
                    this._$tagsContainer = this.element().find(".dx-texteditor-container").addClass(TAGBOX_TAG_CONTAINER_CLASS);
                    this._renderInputSize();
                    this._clearFilter();
                    this._renderTags();
                    this._popup && this._popup.repaint()
                },
                _renderInputSize: function() {
                    var $input = this._input();
                    $input.prop("size", $input.val() ? $input.val().length + 2 : 1)
                },
                _renderTags: function() {
                    this._cleanTags();
                    var $tagsBag = $("<div>");
                    this._selectedItems = [];
                    var itemLoadDeferreds = $.map(this._values(), $.proxy(function(value) {
                            return this._renderTag(value, $tagsBag)
                        }, this));
                    $tagsBag.children().insertBefore(this._input());
                    $.when.apply($, itemLoadDeferreds).done($.proxy(this._renderInputAddons, this));
                    this._renderEmptyState()
                },
                _renderEmptyState: function() {
                    var hasNoValues = !this._values().length;
                    this.element().toggleClass(EMPTY_INPUT_CLASS, hasNoValues);
                    this._placeholder().toggle(hasNoValues);
                    this._renderDisplayText()
                },
                _renderDisplayText: function() {
                    this._input().val("");
                    this._renderInputSize()
                },
                _cleanTags: function() {
                    var $tags = this._tagElements();
                    var values = this._values();
                    $.each($tags, function(_, tag) {
                        var $tag = $(tag);
                        if ($.inArray($tag.data(TAGBOX_TAG_DATA_KEY), values) < 0)
                            $tag.remove()
                    })
                },
                _tagElements: function() {
                    return this.element().find("." + TAGBOX_TAG_CLASS)
                },
                _renderTag: function(value, $container) {
                    if (this._isTagRendered(value))
                        return $.Deferred().resolve();
                    var $tag = $("<div>").addClass(TAGBOX_TAG_CLASS).data(TAGBOX_TAG_DATA_KEY, value).appendTo($container),
                        tagTemplate = this._getTemplateByOption("tagTemplate");
                    var $tagContent = $("<div>").addClass(TAGBOX_TAG_CONTENT_CLASS).appendTo($tag);
                    new TagRemoveButton($("<div>")).element().appendTo($tag);
                    return this._loadItem(value).always($.proxy(function(item) {
                            item = commonUtils.isDefined(item) ? item : value;
                            tagTemplate.render(item, $tagContent);
                            this._selectedItems.push(item)
                        }, this))
                },
                _isTagRendered: function(value) {
                    var $tags = this._tagElements();
                    var result = false;
                    $.each($tags, function(_, tag) {
                        var $tag = $(tag);
                        if (value === $tag.data(TAGBOX_TAG_DATA_KEY)) {
                            result = true;
                            return false
                        }
                    });
                    return result
                },
                _toggleEmptinessEventHandler: function() {
                    this._toggleEmptiness(!this._values().length && !this._searchValue().length)
                },
                _removeTagHandler: function(args) {
                    var e = args.jQueryEvent;
                    e.stopPropagation();
                    var $tag = $(e.target).closest("." + TAGBOX_TAG_CLASS);
                    var itemValue = $tag.data(TAGBOX_TAG_DATA_KEY);
                    this._removeTagWithUpdate(itemValue)
                },
                _removeTagWithUpdate: function(itemValue) {
                    this._removeTag(itemValue);
                    this.option("values", this._values())
                },
                _selectionChangeHandler: function(e) {
                    $.each(e.removedItems || [], $.proxy(function(_, removedItem) {
                        this._removeTag(this._valueGetter(removedItem))
                    }, this));
                    $.each(e.addedItems || [], $.proxy(function(_, addedItem) {
                        this._addTag(this._valueGetter(addedItem))
                    }, this));
                    this.callBase(e);
                    this._suppressingSelectionChanged(function() {
                        this.option("values", this._values())
                    });
                    this._valuesChangedAction(e)
                },
                _removeTag: function(value) {
                    this.option().value = value;
                    var values = this._values(),
                        index = this._valueIndex(value);
                    if (index >= 0)
                        values.splice(index, 1)
                },
                _addTag: function(value) {
                    var values = this._values(),
                        index = this._valueIndex(value);
                    if (index < 0)
                        values.push(value)
                },
                _fieldRenderData: function() {
                    return this._selectedItems
                },
                _setValue: function(value) {
                    if (value === null || this._isSelectedValue(value))
                        return;
                    var values = this._values();
                    values.push(value);
                    this.option("values", values)
                },
                _isSelectedValue: function(value) {
                    return this._valueIndex(value) > -1
                },
                _valueIndex: function(value) {
                    var result = -1;
                    $.each(this._values(), $.proxy(function(index, selectedValue) {
                        if (this._isValueEquals(value, selectedValue)) {
                            result = index;
                            return false
                        }
                    }, this));
                    return result
                },
                _values: function(values) {
                    if (!arguments.length)
                        return this._valuesData || [];
                    this._valuesData = values.slice()
                },
                _optionValuesEqual: function(name, value, prevValue) {
                    if (name === "value")
                        return false;
                    this.callBase(name, value, prevValue)
                },
                reset: function() {
                    this.option("values", []);
                    this.callBase()
                },
                _updateValues: function() {
                    var lastValue = this._lastValue() === undefined ? null : this._lastValue();
                    this.option("value", lastValue)
                },
                _lastValue: function() {
                    return this._values().slice(-1).pop()
                },
                _valueChangeEventHandler: function(e) {
                    this._renderInputSize();
                    if (this.option("fieldEditEnabled") || !this._searchValue().length && !this._dataSource.searchValue())
                        return;
                    this.callBase(e)
                },
                _valueChangeArgs: function() {
                    var result = this.callBase.apply(this, arguments);
                    delete result.previousValue;
                    return $.extend(result, {values: this._values()})
                },
                _refreshSelected: function() {
                    this._list && this._suppressingSelectionChanged(function() {
                        this._setListOption("selectedItems", this._selectedItems);
                        this.callBase()
                    })
                },
                _setSelectedElement: function($element) {
                    this.callBase($element);
                    this._setValue(this.option("value"))
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"displayExpr":
                            this.callBase(args);
                            this._initDynamicTagTemplate();
                            this._invalidate();
                            break;
                        case"tagTemplate":
                            this._initDynamicTagTemplate();
                            this._invalidate();
                            break;
                        case"values":
                            this._values(args.value);
                            this._updateValues();
                            break;
                        case"onValuesChanged":
                            this._initValuesChangedAction();
                            break;
                        case"selectAllText":
                            this._setListOption("selectAllText", this.option("selectAllText"));
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        registerComponent("dxTagBox", uiNamespace, TagBox);
        return TagBox
    });
    DevExpress.require(["/ui/widgets/ui.tagBox"]);
    /*! Module widgets-base, file ui.multiView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx,
            translator = DX.require("/utils/utils.translator"),
            mathUtils = DX.require("/utils/utils.math"),
            commonUtils = DX.require("/utils/utils.common"),
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator");
        var MULTIVIEW_CLASS = "dx-multiview",
            MULTIVIEW_WRAPPER_CLASS = "dx-multiview-wrapper",
            MULTIVIEW_ITEM_CONTAINER_CLASS = "dx-multiview-item-container",
            MULTIVIEW_ITEM_CLASS = "dx-multiview-item",
            MULTIVIEW_ITEM_HIDDEN_CLASS = "dx-multiview-item-hidden",
            MULTIVIEW_ITEM_DATA_KEY = "dxMultiViewItemData",
            MULTIVIEW_ANIMATION_DURATION = 200;
        var toNumber = function(value) {
                return +value
            };
        var position = function($element) {
                return translator.locate($element).left
            };
        var move = function($element, position) {
                translator.move($element, {left: position})
            };
        var animation = {
                moveTo: function($element, position, duration, completeAction) {
                    fx.animate($element, {
                        type: "slide",
                        to: {left: position},
                        duration: duration,
                        complete: completeAction
                    })
                },
                complete: function($element) {
                    fx.stop($element, true)
                }
            };
        registerComponent("dxMultiView", ui, ui.CollectionWidget.inherit({
            _activeStateUnit: "." + MULTIVIEW_ITEM_CLASS,
            _supportedKeys: function() {
                return $.extend(this.callBase(), {
                        pageUp: $.noop,
                        pageDown: $.noop
                    })
            },
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        selectedIndex: 0,
                        swipeEnabled: true,
                        animationEnabled: true,
                        loop: false,
                        deferRendering: true,
                        _itemAttributes: {role: "tabpanel"},
                        loopItemFocus: false,
                        selectOnFocus: true,
                        selectionMode: "single",
                        selectionRequired: true,
                        selectionByClick: false
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return devices.real().generic && !devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _itemClass: function() {
                return MULTIVIEW_ITEM_CLASS
            },
            _itemDataKey: function() {
                return MULTIVIEW_ITEM_DATA_KEY
            },
            _itemContainer: function() {
                return this._$itemContainer
            },
            _itemElements: function() {
                return this._itemContainer().children(this._itemSelector())
            },
            _itemWidth: function() {
                if (!this._itemWidthValue)
                    this._itemWidthValue = this._$wrapper.width();
                return this._itemWidthValue
            },
            _clearItemWidthCache: function() {
                delete this._itemWidthValue
            },
            _itemsCount: function() {
                return this.option("items").length
            },
            _normalizeIndex: function(index) {
                var count = this._itemsCount();
                if (index < 0)
                    index = index + count;
                if (index >= count)
                    index = index - count;
                return index
            },
            _getRTLSignCorrection: function() {
                return this.option("rtlEnabled") ? -1 : 1
            },
            _init: function() {
                this.callBase.apply(this, arguments);
                var $element = this.element();
                $element.addClass(MULTIVIEW_CLASS);
                this._$wrapper = $("<div>").addClass(MULTIVIEW_WRAPPER_CLASS);
                this._$wrapper.appendTo($element);
                this._$itemContainer = $("<div>").addClass(MULTIVIEW_ITEM_CONTAINER_CLASS);
                this._$itemContainer.appendTo(this._$wrapper);
                this.option("loopItemFocus", this.option("loop"));
                this._initSwipeable()
            },
            _render: function() {
                this._deferredItems = [];
                this.callBase()
            },
            _renderItemContent: function(index, itemData, $container) {
                var renderContentDeferred = $.Deferred();
                var that = this,
                    callBase = this.callBase;
                var deferred = $.Deferred();
                deferred.done(function() {
                    var $itemContent = callBase.call(that, index, itemData, $container);
                    renderContentDeferred.resolve($itemContent)
                });
                this._deferredItems.push(deferred);
                this.option("deferRendering") || deferred.resolve();
                return renderContentDeferred.promise()
            },
            _renderSelection: function(addedSelection) {
                this._updateItems(addedSelection[0])
            },
            _updateItems: function(selectedIndex, newIndex) {
                this._updateItemsPosition(selectedIndex, newIndex);
                this._updateItemsVisibility(selectedIndex, newIndex)
            },
            _updateItemsPosition: function(selectedIndex, newIndex) {
                var $itemElements = this._itemElements(),
                    positionSign = -this._animationDirection(newIndex, selectedIndex),
                    $selectedItem = $itemElements.eq(selectedIndex);
                move($selectedItem, 0);
                move($itemElements.eq(newIndex), positionSign * 100 + "%")
            },
            _updateItemsVisibility: function(selectedIndex, newIndex) {
                var $itemElements = this._itemElements();
                $itemElements.each($.proxy(function(itemIndex, item) {
                    var $item = $(item),
                        isHidden = itemIndex !== selectedIndex && itemIndex !== newIndex;
                    if (!isHidden)
                        this._renderSpecificItem(itemIndex);
                    $item.toggleClass(MULTIVIEW_ITEM_HIDDEN_CLASS, isHidden);
                    this.setAria("hidden", isHidden || undefined, $item)
                }, this))
            },
            _renderSpecificItem: function(index) {
                var hasItemContent = this._itemElements().eq(index).find(this._itemContentClass()).length > 0;
                if (commonUtils.isDefined(index) && !hasItemContent)
                    this._deferredItems[index].resolve()
            },
            _setAriaSelected: $.noop,
            _updateSelection: function(addedSelection, removedSelection) {
                var newIndex = addedSelection[0],
                    prevIndex = removedSelection[0];
                animation.complete(this._$itemContainer);
                this._updateItems(prevIndex, newIndex);
                var animationDirection = this._animationDirection(newIndex, prevIndex);
                this._animateItemContainer(animationDirection * this._itemWidth(), $.proxy(function() {
                    move(this._$itemContainer, 0);
                    this._updateItems(newIndex);
                    this._$itemContainer.width()
                }, this))
            },
            _animateItemContainer: function(position, completeCallback) {
                var duration = this.option("animationEnabled") ? MULTIVIEW_ANIMATION_DURATION : 0;
                animation.moveTo(this._$itemContainer, position, duration, completeCallback)
            },
            _animationDirection: function(newIndex, prevIndex) {
                var containerPosition = position(this._$itemContainer),
                    indexDifference = (prevIndex - newIndex) * this._getRTLSignCorrection() * this._getItemFocusLoopSignCorrection(),
                    isSwipePresent = containerPosition !== 0,
                    directionSignVariable = isSwipePresent ? containerPosition : indexDifference;
                return mathUtils.sign(directionSignVariable)
            },
            _initSwipeable: function() {
                this._createComponent(this.element(), "dxSwipeable", {
                    disabled: !this.option("swipeEnabled"),
                    elastic: false,
                    itemSizeFunc: $.proxy(this._itemWidth, this),
                    onStart: $.proxy(function(args) {
                        this._swipeStartHandler(args.jQueryEvent)
                    }, this),
                    onUpdated: $.proxy(function(args) {
                        this._swipeUpdateHandler(args.jQueryEvent)
                    }, this),
                    onEnd: $.proxy(function(args) {
                        this._swipeEndHandler(args.jQueryEvent)
                    }, this)
                })
            },
            _swipeStartHandler: function(e) {
                animation.complete(this._$itemContainer);
                var selectedIndex = this.option("selectedIndex"),
                    loop = this.option("loop"),
                    lastIndex = this._itemsCount() - 1,
                    rtl = this.option("rtlEnabled");
                e.maxLeftOffset = toNumber(loop || (rtl ? selectedIndex > 0 : selectedIndex < lastIndex));
                e.maxRightOffset = toNumber(loop || (rtl ? selectedIndex < lastIndex : selectedIndex > 0));
                this._swipeDirection = null
            },
            _swipeUpdateHandler: function(e) {
                var offset = e.offset,
                    swipeDirection = mathUtils.sign(offset) * this._getRTLSignCorrection();
                move(this._$itemContainer, offset * this._itemWidth());
                if (swipeDirection !== this._swipeDirection) {
                    this._swipeDirection = swipeDirection;
                    var selectedIndex = this.option("selectedIndex"),
                        newIndex = this._normalizeIndex(selectedIndex - swipeDirection);
                    this._updateItems(selectedIndex, newIndex)
                }
            },
            _swipeEndHandler: function(e) {
                var targetOffset = e.targetOffset * this._getRTLSignCorrection();
                if (targetOffset) {
                    this.option("selectedIndex", this._normalizeIndex(this.option("selectedIndex") - targetOffset));
                    var $selectedElement = this.itemElements().filter(".dx-item-selected");
                    this.option("focusStateEnabled") && this.option("focusedElement", $selectedElement)
                }
                else
                    this._animateItemContainer(0, $.noop)
            },
            _getItemFocusLoopSignCorrection: function() {
                return this._itemFocusLooped ? -1 : 1
            },
            _moveFocus: function() {
                this.callBase.apply(this, arguments);
                this._itemFocusLooped = false
            },
            _prevItem: function($items) {
                var $result = this.callBase.apply(this, arguments);
                this._itemFocusLooped = $result.is($items.last());
                return $result
            },
            _nextItem: function($items) {
                var $result = this.callBase.apply(this, arguments);
                this._itemFocusLooped = $result.is($items.first());
                return $result
            },
            _dimensionChanged: function() {
                this._clearItemWidthCache()
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._dimensionChanged()
            },
            _optionChanged: function(args) {
                var value = args.value;
                switch (args.name) {
                    case"loop":
                        this.option("loopItemFocus", value);
                        break;
                    case"animationEnabled":
                        break;
                    case"swipeEnabled":
                        this.element().dxSwipeable("option", "disabled", !value);
                        break;
                    case"deferRendering":
                        this._invalidate();
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }));
        ui.dxMultiView.__internals = {animation: animation}
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.defaultAdapter.js */
    DevExpress.define("/ui/widgets/validation/ui.defaultAdapter", ["jquery", "/class"], function($, Class) {
        var DefaultAdapter = Class.inherit({
                ctor: function(editor, validator) {
                    var that = this;
                    that.editor = editor;
                    that.validator = validator;
                    that.validationRequestsCallbacks = $.Callbacks();
                    var handler = function(params) {
                            that.validationRequestsCallbacks.fire()
                        };
                    editor.validationRequest.add(handler);
                    editor.on("disposing", function() {
                        editor.validationRequest.remove(handler)
                    })
                },
                getValue: function() {
                    return this.editor.option("value")
                },
                getCurrentValidationError: function() {
                    return this.editor.option("validationError")
                },
                bypass: function() {
                    return this.editor.option("disabled")
                },
                applyValidationResults: function(params) {
                    this.editor.option({
                        isValid: params.isValid,
                        validationError: params.brokenRule
                    })
                },
                reset: function() {
                    this.editor.reset()
                },
                focus: function() {
                    this.editor.focus()
                }
            });
        return DefaultAdapter
    });
    /*! Module widgets-base, file ui.validator.js */
    DevExpress.define("/ui/widgets/ui.validator", ["jquery", "/ui/ui.errors", "/componentRegistrator", "/domComponent", "/ui/ui.validationMixin", "/ui/widgets/validation/ui.defaultAdapter", "/ui/uiNamespace"], function($, errors, registerComponent, DOMComponent, ValidationMixin, DefaultAdapter, uiNamespace) {
        var VALIDATOR_CLASS = "dx-validator";
        var Validator = DOMComponent.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {validationRules: []})
                },
                _init: function() {
                    this.callBase();
                    this._initGroupRegistration();
                    this.focused = $.Callbacks();
                    this._initAdapter()
                },
                _initGroupRegistration: function() {
                    var group = this._findGroup();
                    if (!this._groupWasInit)
                        this.on("disposing", function(args) {
                            DevExpress.validationEngine.removeRegistredValidator(args.component._validationGroup, args.component)
                        });
                    if (!this._groupWasInit || this._validationGroup !== group) {
                        DevExpress.validationEngine.removeRegistredValidator(this._validationGroup, this);
                        this._groupWasInit = true;
                        this._validationGroup = group;
                        DevExpress.validationEngine.registerValidatorInGroup(group, this)
                    }
                },
                _setOptionsByReference: function() {
                    this.callBase();
                    $.extend(this._optionsByReference, {validationGroup: true})
                },
                _initAdapter: function() {
                    var that = this,
                        dxStandardEditor = that.element().data("dx-validation-target"),
                        adapter = that.option("adapter");
                    if (!adapter) {
                        if (dxStandardEditor) {
                            adapter = new DefaultAdapter(dxStandardEditor, this);
                            adapter.validationRequestsCallbacks.add(function() {
                                that.validate()
                            });
                            this.option("adapter", adapter);
                            return
                        }
                        throw errors.Error("E0120");
                    }
                    if (adapter.validationRequestsCallbacks)
                        adapter.validationRequestsCallbacks.add(function() {
                            that.validate()
                        })
                },
                _render: function() {
                    this.element().addClass(VALIDATOR_CLASS);
                    this.callBase()
                },
                _visibilityChanged: function(visible) {
                    if (visible)
                        this._initGroupRegistration()
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"validationGroup":
                            this._initGroupRegistration();
                            return;
                        case"validationRules":
                            return;
                        case"adapter":
                            this._initAdapter();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                validate: function() {
                    var that = this,
                        adapter = that.option("adapter"),
                        name = that.option("name"),
                        bypass = adapter.bypass && adapter.bypass(),
                        value = adapter.getValue(),
                        currentError = adapter.getCurrentValidationError && adapter.getCurrentValidationError(),
                        rules = $.map(that.option("validationRules"), function(rule) {
                            rule.validator = that;
                            return rule
                        }),
                        result;
                    if (bypass)
                        result = {isValid: true};
                    else if (currentError && currentError.editorSpecific) {
                        currentError.validator = this;
                        result = {
                            isValid: false,
                            brokenRule: currentError
                        }
                    }
                    else
                        result = DevExpress.validationEngine.validate(value, rules, name);
                    this._applyValidationResult(result, adapter);
                    return result
                },
                reset: function() {
                    var that = this,
                        adapter = that.option("adapter"),
                        result = {
                            isValid: true,
                            brokenRule: null
                        };
                    adapter.reset();
                    this._applyValidationResult(result, adapter)
                },
                _applyValidationResult: function(result, adapter) {
                    var validatedAction = this._createActionByOption("onValidated");
                    result.validator = this;
                    adapter.applyValidationResults && adapter.applyValidationResults(result);
                    this.option({isValid: result.isValid});
                    validatedAction(result)
                },
                focus: function() {
                    var adapter = this.option("adapter");
                    adapter.focus()
                }
            }).include(ValidationMixin);
        registerComponent("dxValidator", uiNamespace, Validator);
        return Validator
    });
    DevExpress.require(["/ui/widgets/ui.validator"]);
    /*! Module widgets-base, file ui.validationSummary.js */
    DevExpress.define("/ui/widgets/ui.validationSummary", ["jquery", "/componentRegistrator", "/ui/ui.validationMixin", "/ui/uiNamespace"], function($, registerComponent, ValidationMixin, uiNamespace) {
        var VALIDATION_SUMMARY_CLASS = "dx-validationsummary",
            ITEM_CLASS = VALIDATION_SUMMARY_CLASS + "-item",
            ITEM_DATA_KEY = VALIDATION_SUMMARY_CLASS + "-item-data";
        var ValidationSummary = DevExpress.ui.CollectionWidget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            focusStateEnabled: false,
                            noDataText: null
                        })
                },
                _setOptionsByReference: function() {
                    this.callBase();
                    $.extend(this._optionsByReference, {validationGroup: true})
                },
                _init: function() {
                    this.callBase();
                    this._initGroupRegistration()
                },
                _initGroupRegistration: function() {
                    var group = this._findGroup(),
                        groupConfig = DevExpress.validationEngine.addGroup(group);
                    this._unsubscribeGroup();
                    this._groupWasInit = true;
                    this._validationGroup = group;
                    this.groupSubscription = $.proxy(this._groupValidationHandler, this);
                    groupConfig.on("validated", this.groupSubscription)
                },
                _unsubscribeGroup: function() {
                    var groupConfig = DevExpress.validationEngine.getGroupConfig(this._validationGroup);
                    groupConfig && groupConfig.off("validated", this.groupSubscription)
                },
                _getOrderedItems: function(validators, items) {
                    var orderedItems = [];
                    $.each(validators, function(_, validator) {
                        var firstItem = $.grep(items, function(item) {
                                if (item.validator === validator)
                                    return true
                            })[0];
                        if (firstItem)
                            orderedItems.push(firstItem)
                    });
                    return orderedItems
                },
                _groupValidationHandler: function(params) {
                    var that = this,
                        items = that._getOrderedItems(params.validators, $.map(params.brokenRules, function(rule) {
                            return {
                                    text: rule.message,
                                    validator: rule.validator
                                }
                        }));
                    that.validators = params.validators;
                    $.each(that.validators, function(_, validator) {
                        if (validator._validationSummary !== this) {
                            var handler = $.proxy(that._itemValidationHandler, that),
                                disposingHandler = function() {
                                    validator.off("validated", handler);
                                    validator._validationSummary = null;
                                    handler = null
                                };
                            validator.on("validated", handler);
                            validator.on("disposing", disposingHandler);
                            validator._validationSummary = this
                        }
                    });
                    that.option("items", items)
                },
                _itemValidationHandler: function(itemValidationResult) {
                    var items = this.option("items"),
                        isValid = itemValidationResult.isValid,
                        elementIndex,
                        replacementFound = false,
                        newMessage = itemValidationResult.brokenRule && itemValidationResult.brokenRule.message,
                        validator = itemValidationResult.validator;
                    if (isValid) {
                        $.each(items, function(index, item) {
                            if (item.validator === validator) {
                                elementIndex = index;
                                replacementFound = true;
                                return false
                            }
                        });
                        if (replacementFound)
                            items.splice(elementIndex, 1)
                    }
                    else {
                        $.each(items, function(index, item) {
                            if (item.validator === validator) {
                                item.text = newMessage;
                                replacementFound = true;
                                return false
                            }
                        });
                        if (!replacementFound)
                            items.push({
                                text: newMessage,
                                validator: validator
                            })
                    }
                    items = this._getOrderedItems(this.validators, items);
                    this.option("items", items)
                },
                _render: function() {
                    this.element().addClass(VALIDATION_SUMMARY_CLASS);
                    this.callBase()
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"validationGroup":
                            this._initGroupRegistration();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _itemClass: function() {
                    return ITEM_CLASS
                },
                _itemDataKey: function() {
                    return ITEM_DATA_KEY
                },
                _postprocessRenderItem: function(params) {
                    params.itemElement.on("click", function() {
                        params.itemData.validator.focus()
                    })
                },
                _dispose: function() {
                    this.callBase();
                    this._unsubscribeGroup()
                }
            }).include(ValidationMixin);
        registerComponent("dxValidationSummary", uiNamespace, ValidationSummary);
        return ValidationSummary
    });
    DevExpress.require(["/ui/widgets/ui.validationSummary"]);
    /*! Module widgets-base, file ui.validationGroup.js */
    DevExpress.define("/ui/widgets/ui.validationGroup", ["jquery", "/componentRegistrator", "/domComponent", "/ui/widgets/ui.validationSummary", "/ui/widgets/ui.validator", "/ui/uiNamespace"], function($, registerComponent, DOMComponent, ValidationSummary, Validator, uiNamespace) {
        var VALIDATION_ENGINE_CLASS = "dx-validationgroup";
        var ValidationGroup = DOMComponent.inherit({
                _getDefaultOptions: function() {
                    return this.callBase()
                },
                _init: function() {
                    this.callBase()
                },
                _render: function() {
                    var $element = this.element();
                    $element.addClass(VALIDATION_ENGINE_CLASS);
                    $element.find(".dx-validator").each(function(_, validatorContainer) {
                        Validator.getInstance($(validatorContainer))._initGroupRegistration()
                    });
                    $element.find(".dx-validationsummary").each(function(_, summaryContainer) {
                        ValidationSummary.getInstance($(summaryContainer))._initGroupRegistration()
                    });
                    this.callBase()
                },
                validate: function() {
                    return DevExpress.validationEngine.validateGroup(this)
                },
                reset: function() {
                    return DevExpress.validationEngine.resetGroup(this)
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        default:
                            this.callBase(args)
                    }
                },
                _dispose: function() {
                    DevExpress.validationEngine.removeGroup(this);
                    this.element().removeClass(VALIDATION_ENGINE_CLASS);
                    this.callBase()
                }
            });
        registerComponent("dxValidationGroup", uiNamespace, ValidationGroup);
        return ValidationGroup
    });
    DevExpress.require(["/ui/widgets/ui.validationGroup"]);
    /*! Module widgets-base, file ui.fileUploader.js */
    DevExpress.define("/ui/widgets/ui.fileUploader", ["jquery", "/utils/utils.browser", "/utils/utils.common", "/devices", "/componentRegistrator", "/ui/ui.editor", "/ui/widgets/ui.button", "/ui/widgets/track/ui.progressBar", "/ui/uiNamespace", "/ui/events/ui.events.utils"], function($, browser, commonUtils, devices, registerComponent, Editor, Button, ProgressBar, uiNamespace, eventUtils) {
        var FILEUPLOADER_CLASS = "dx-fileuploader",
            FILEUPLOADER_EMPTY_CLASS = "dx-fileuploader-empty",
            FILEUPLOADER_SHOW_FILE_LIST_CLASS = "dx-fileuploader-show-file-list",
            FILEUPLOADER_DRAGOVER_CLASS = "dx-fileuploader-dragover",
            FILEUPLOADER_FILEINPUT_TAG = "<input type='file'>",
            FILEUPLOADER_WRAPPER_CLASS = "dx-fileuploader-wrapper",
            FILEUPLOADER_CONTAINER_CLASS = "dx-fileuploader-container",
            FILEUPLOADER_CONTENT_CLASS = "dx-fileuploader-content",
            FILEUPLOADER_INPUT_WRAPPER_CLASS = "dx-fileuploader-input-wrapper",
            FILEUPLOADER_INPUT_CONTAINER_CLASS = "dx-fileuploader-input-container",
            FILEUPLOADER_INPUT_LABEL_CLASS = "dx-fileuploader-input-label",
            FILEUPLOADER_INPUT_CLASS = "dx-fileuploader-input",
            FILEUPLOADER_FILES_CONTAINER_CLASS = "dx-fileuploader-files-container",
            FILEUPLOADER_FILE_CONTAINER_CLASS = "dx-fileuploader-file-container",
            FILEUPLOADER_FILE_INFO_CLASS = "dx-fileuploader-file-info",
            FILEUPLOADER_FILE_STATUS_MESSAGE_CLASS = "dx-fileuploader-file-status-message",
            FILEUPLOADER_FILE_CLASS = "dx-fileuploader-file",
            FILEUPLOADER_FILE_NAME_CLASS = "dx-fileuploader-file-name",
            FILEUPLOADER_FILE_SIZE_CLASS = "dx-fileuploader-file-size",
            FILEUPLOADER_BUTTON_CLASS = "dx-fileuploader-button",
            FILEUPLOADER_BUTTON_CONTAINER_CLASS = "dx-fileuploader-button-container",
            FILEUPLOADER_CANCEL_BUTTON_CLASS = "dx-fileuploader-cancel-button",
            FILEUPLOADER_UPLOAD_BUTTON_CLASS = "dx-fileuploader-upload-button",
            FILEUPLOADER_AFTER_LOAD_DELAY = 400;
        var isFormDataSupported = function() {
                return !!window.FormData
            },
            getFormDataPrototype = function() {
                return FormData
            },
            getRequestPrototype = function() {
                return XMLHttpRequest
            };
        var FileUploader = Editor.inherit({
                _supportedKeys: function() {
                    var click = function(e) {
                            e.preventDefault();
                            var $selectButton = this._selectButton.element();
                            $selectButton.trigger("dxclick")
                        };
                    return $.extend(this.callBase(), {
                            space: click,
                            enter: click
                        })
                },
                _setOptionsByReference: function() {
                    this.callBase();
                    $.extend(this._optionsByReference, {value: true})
                },
                _setDeprecatedOptions: function() {
                    this.callBase();
                    $.extend(this._deprecatedOptions, {buttonText: {
                            since: "15.1",
                            alias: "selectButtonText"
                        }})
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            value: null,
                            values: [],
                            selectButtonText: Globalize.localize("dxFileUploader-selectFile"),
                            uploadButtonText: Globalize.localize("dxFileUploader-upload"),
                            labelText: Globalize.localize("dxFileUploader-dropFile"),
                            name: "files[]",
                            multiple: false,
                            accept: "",
                            uploadUrl: "/",
                            allowCanceling: true,
                            showFileList: true,
                            progress: 0,
                            readyToUploadMessage: Globalize.localize("dxFileUploader-readyToUpload"),
                            uploadedMessage: Globalize.localize("dxFileUploader-uploaded"),
                            uploadFailedMessage: Globalize.localize("dxFileUploader-uploadFailedMessage"),
                            uploadMode: "instantly",
                            onUploaded: null,
                            onProgress: null,
                            onUploadError: null,
                            validationMessageMode: "always",
                            validationTooltipOffset: {
                                h: 0,
                                v: 0
                            }
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }, {
                                device: {platform: "generic"},
                                options: {validationTooltipOffset: {h: 3}}
                            }, {
                                device: [{platform: "android"}, {platform: "win"}],
                                options: {validationTooltipOffset: {v: 0}}
                            }])
                },
                _init: function() {
                    this.option("value", null);
                    this.option("values", []);
                    this.callBase.apply(this, arguments);
                    this._initFileInput();
                    this._initLabel();
                    this._createFiles();
                    this._createUploadedAction();
                    this._createProgressAction();
                    this._createUploadErrorAction();
                    this.element().addClass(FILEUPLOADER_CLASS)
                },
                _initFileInput: function() {
                    if (!this._$fileInput) {
                        this._$fileInput = $(FILEUPLOADER_FILEINPUT_TAG);
                        this._$fileInput.on("change", $.proxy(this._inputChangeHandler, this)).on("click", $.proxy(function(e) {
                            return this._isCustomClickEvent
                        }, this))
                    }
                    this._$fileInput.prop({
                        multiple: this.option("multiple"),
                        name: this.option("name"),
                        accept: this.option("accept"),
                        tabindex: -1
                    })
                },
                _inputChangeHandler: function(e) {
                    if (this._doPreventInputChange)
                        return;
                    var fileName = this._$fileInput.val().replace(/^.*\\/, ''),
                        files = this._$fileInput.prop("files"),
                        values = [];
                    if (files && !files.length)
                        return;
                    if (files)
                        $.each(files, function(_, value) {
                            values.push(value)
                        });
                    else
                        values = [{name: fileName}];
                    this._shouldChangeValue = true;
                    this.option("values", values);
                    delete this._shouldChangeValue;
                    if (this.option("uploadMode") === "instantly")
                        this._uploadFiles()
                },
                _initLabel: function() {
                    if (!this._$inputLabel)
                        this._$inputLabel = $("<div>");
                    this._$inputLabel.text(this.option("labelText"))
                },
                _focusTarget: function() {
                    return this.element().find("." + FILEUPLOADER_BUTTON_CLASS)
                },
                _render: function() {
                    this._renderWrapper();
                    this._renderInputWrapper();
                    this._renderDragEvents();
                    this._renderSelectButton();
                    this._renderInputContainer();
                    this._renderFiles();
                    this._renderUploadButton();
                    this.callBase.apply(this, arguments)
                },
                _createFiles: function() {
                    this._files = [];
                    $.each(this.option("values"), $.proxy(function(_, value) {
                        this._files.push(this._createFile(value))
                    }, this))
                },
                _createUploadedAction: function() {
                    this._uploadedAction = this._createActionByOption("onUploaded")
                },
                _createProgressAction: function() {
                    this._progressAction = this._createActionByOption("onProgress")
                },
                _createUploadErrorAction: function() {
                    this._uploadErrorAction = this._createActionByOption("onUploadError")
                },
                _createFile: function(value) {
                    return {
                            value: value,
                            loadedSize: 0,
                            onProgress: $.Callbacks(),
                            onLoad: $.Callbacks(),
                            onError: $.Callbacks(),
                            onLoadStart: $.Callbacks()
                        }
                },
                _renderFiles: function() {
                    if (!this._$filesContainer)
                        this._$filesContainer = $("<div>").addClass(FILEUPLOADER_FILES_CONTAINER_CLASS).appendTo(this._$content);
                    else
                        this._$filesContainer.empty();
                    var showFileList = this.option("showFileList");
                    if (showFileList) {
                        var that = this;
                        $.each(this._files, function(_, file) {
                            that._renderFile(file)
                        })
                    }
                    this.element().toggleClass(FILEUPLOADER_SHOW_FILE_LIST_CLASS, showFileList);
                    this.element().toggleClass(FILEUPLOADER_EMPTY_CLASS, !this._files.length);
                    this._updateFileNameMaxWidth();
                    this._$validationMessage && this._$validationMessage.dxTooltip("repaint")
                },
                _renderFile: function(file) {
                    var value = file.value;
                    var $fileContainer = $("<div>").addClass(FILEUPLOADER_FILE_CONTAINER_CLASS).appendTo(this._$filesContainer);
                    this._renderFileButtons(file, $fileContainer);
                    file.$file = $("<div>").addClass(FILEUPLOADER_FILE_CLASS).appendTo($fileContainer);
                    var $fileInfo = $("<div>").addClass(FILEUPLOADER_FILE_INFO_CLASS).appendTo(file.$file);
                    file.$statusMessage = $("<div>").addClass(FILEUPLOADER_FILE_STATUS_MESSAGE_CLASS).text(this.option("readyToUploadMessage")).appendTo(file.$file);
                    $("<div>").addClass(FILEUPLOADER_FILE_NAME_CLASS).text(value.name).appendTo($fileInfo);
                    if (commonUtils.isDefined(value.size))
                        $("<div>").addClass(FILEUPLOADER_FILE_SIZE_CLASS).text(this._getFileSize(value.size)).appendTo($fileInfo)
                },
                _updateFileNameMaxWidth: function() {
                    var cancelButtonsCount = this.option("allowCanceling") ? 1 : 0,
                        uploadButtonsCount = this.option("uploadMode") === "useButtons" ? 1 : 0,
                        filesContainerWidth = this._$filesContainer.width(),
                        $buttonContainer = this._$filesContainer.find("." + FILEUPLOADER_BUTTON_CONTAINER_CLASS).eq(0),
                        buttonsWidth = $buttonContainer.width() * (cancelButtonsCount + uploadButtonsCount),
                        $fileSize = this._$filesContainer.find("." + FILEUPLOADER_FILE_SIZE_CLASS).eq(0);
                    var prevFileSize = $fileSize.text();
                    $fileSize.text("1000 Mb");
                    var fileSizeWidth = $fileSize.width();
                    $fileSize.text(prevFileSize);
                    this._$filesContainer.find("." + FILEUPLOADER_FILE_NAME_CLASS).css("max-width", filesContainerWidth - buttonsWidth - fileSizeWidth)
                },
                _renderFileButtons: function(file, $container) {
                    file.cancelButton = this._createComponent($("<div>").addClass(FILEUPLOADER_BUTTON_CLASS + " " + FILEUPLOADER_CANCEL_BUTTON_CLASS), Button, {
                        onClick: $.proxy(function() {
                            this._removeFile(file)
                        }, this),
                        icon: "close",
                        visible: this.option("allowCanceling"),
                        _templates: {}
                    });
                    $("<div>").addClass(FILEUPLOADER_BUTTON_CONTAINER_CLASS).append(file.cancelButton.element()).appendTo($container);
                    if (this.option("uploadMode") === "useButtons") {
                        file.uploadButton = this._createComponent($("<div>").addClass(FILEUPLOADER_BUTTON_CLASS + " " + FILEUPLOADER_UPLOAD_BUTTON_CLASS), Button, {
                            onClick: $.proxy(function(e) {
                                this._uploadFile(file)
                            }, this),
                            icon: "upload"
                        });
                        $("<div>").addClass(FILEUPLOADER_BUTTON_CONTAINER_CLASS).append(file.uploadButton.element()).appendTo($container);
                        file.onLoadStart.add($.proxy(function() {
                            file.uploadButton.element().remove()
                        }, this))
                    }
                },
                _removeFile: function(file) {
                    file.$file.parent().remove();
                    this._files.splice($.inArray(file, this._files), 1);
                    var values = this.option("values").slice();
                    values.splice($.inArray(file.value, values), 1);
                    this._shouldChangeValue = this._doPreventRecreatingFiles = true;
                    this.option("values", values);
                    this._shouldChangeValue = this._doPreventRecreatingFiles = false;
                    this.element().toggleClass(FILEUPLOADER_EMPTY_CLASS, !this._files.length);
                    this._doPreventInputChange = true;
                    this._$fileInput.val("");
                    this._doPreventInputChange = false
                },
                _getFileSize: function(size) {
                    var i = 0,
                        labels = [Globalize.localize("dxFileUploader-bytes"), Globalize.localize("dxFileUploader-kb"), Globalize.localize("dxFileUploader-Mb"), Globalize.localize("dxFileUploader-Gb")],
                        count = labels.length - 1;
                    while (i < count && size >= 1024) {
                        size /= 1024;
                        i++
                    }
                    return Math.round(size) + " " + labels[i]
                },
                _renderSelectButton: function() {
                    var $button = $("<div>").addClass(FILEUPLOADER_BUTTON_CLASS).appendTo(this._$inputWrapper);
                    this._selectButton = this._createComponent($button, Button, {
                        text: this.option("selectButtonText"),
                        focusStateEnabled: false,
                        _templates: {}
                    });
                    if (devices.real().deviceType === "desktop")
                        this._selectButton.option("onClick", $.proxy(this._selectButtonClickHandler, this));
                    else
                        $button.off("click").on("click", $.proxy(this._selectButtonClickHandler, this))
                },
                _selectButtonClickHandler: function() {
                    if (this.option("disabled"))
                        return false;
                    this._isCustomClickEvent = true;
                    this._$fileInput.click();
                    this._isCustomClickEvent = false
                },
                _renderUploadButton: function() {
                    if (this.option("uploadMode") !== "useButtons")
                        return;
                    var $uploadButton = $("<div>").addClass(FILEUPLOADER_BUTTON_CLASS).addClass(FILEUPLOADER_UPLOAD_BUTTON_CLASS).appendTo(this._$content);
                    this._uploadButton = this._createComponent($uploadButton, Button, {
                        text: this.option("uploadButtonText"),
                        onClick: $.proxy(this._uploadButtonClickHandler, this),
                        _templates: {}
                    })
                },
                _uploadButtonClickHandler: function() {
                    this._uploadFiles()
                },
                _renderInputContainer: function() {
                    this._$inputContainer = $("<div>").addClass(FILEUPLOADER_INPUT_CONTAINER_CLASS).appendTo(this._$inputWrapper);
                    if (browser.msie)
                        this._$inputContainer.css("display", "none");
                    this._$fileInput.addClass(FILEUPLOADER_INPUT_CLASS).appendTo(this._$inputContainer);
                    this._$inputLabel.addClass(FILEUPLOADER_INPUT_LABEL_CLASS).appendTo(this._$inputContainer)
                },
                _renderInputWrapper: function() {
                    this._$inputWrapper = $("<div>").addClass(FILEUPLOADER_INPUT_WRAPPER_CLASS).appendTo(this._$content)
                },
                _renderDragEvents: function() {
                    if (devices.real().platform !== "generic" || browser.msie)
                        return;
                    this._dragEventsCount = 0;
                    this._$inputWrapper.off("." + this.NAME).on(eventUtils.addNamespace("dragenter", this.NAME), $.proxy(this._dragEnterHandler, this)).on(eventUtils.addNamespace("dragleave", this.NAME), $.proxy(this._dragLeaveHandler, this)).on(eventUtils.addNamespace("drop", this.NAME), $.proxy(this._dropHandler, this))
                },
                _dragEnterHandler: function() {
                    if (this.option("disabled"))
                        return false;
                    this._dragEventsCount++;
                    this.element().addClass(FILEUPLOADER_DRAGOVER_CLASS)
                },
                _dragLeaveHandler: function() {
                    this._dragEventsCount--;
                    if (this._dragEventsCount <= 0)
                        this.element().removeClass(FILEUPLOADER_DRAGOVER_CLASS)
                },
                _dropHandler: function() {
                    this._dragEventsCount = 0;
                    this.element().removeClass(FILEUPLOADER_DRAGOVER_CLASS)
                },
                _renderWrapper: function() {
                    var $wrapper = $("<div>").addClass(FILEUPLOADER_WRAPPER_CLASS).appendTo(this.element());
                    var $container = $("<div>").addClass(FILEUPLOADER_CONTAINER_CLASS).appendTo($wrapper);
                    this._$content = $("<div>").addClass(FILEUPLOADER_CONTENT_CLASS).appendTo($container)
                },
                _clean: function() {
                    this._$fileInput.detach();
                    delete this._$filesContainer;
                    this.callBase.apply(this, arguments)
                },
                _uploadFiles: function() {
                    if (!isFormDataSupported())
                        return;
                    $.each(this._files, $.proxy(function(_, file) {
                        this._uploadFile(file)
                    }, this))
                },
                _uploadFile: function(file) {
                    if (file.progressBar)
                        return;
                    var $file = file.$file,
                        value = file.value;
                    this._initUploadRequest(file);
                    if ($file) {
                        file.progressBar = this._createProgressBar(value.size);
                        file.progressBar.element().appendTo($file);
                        this._initStatusMessage(file);
                        this._initCancelButton(file)
                    }
                    file.onLoad.add($.proxy(this._onLoadedHandler, this, file));
                    file.onError.add($.proxy(this._onErrorHandler, this, file));
                    file.onProgress.add($.proxy(this._onProgressHandler, this, file));
                    file.request.send(this._createFormData(this.option("name"), value))
                },
                _onErrorHandler: function(file, e) {
                    var that = this;
                    setTimeout(function() {
                        if (that.option("showFileList")) {
                            file.$statusMessage.text(that.option("uploadFailedMessage"));
                            file.$statusMessage.css("display", "");
                            file.progressBar.element().remove()
                        }
                    }, FILEUPLOADER_AFTER_LOAD_DELAY);
                    this._uploadErrorAction({
                        file: file,
                        jQueryEvent: e
                    })
                },
                _onLoadedHandler: function(file, e) {
                    var that = this;
                    setTimeout(function() {
                        if (that.option("showFileList")) {
                            file.$statusMessage.text(that.option("uploadedMessage"));
                            file.$statusMessage.css("display", "");
                            file.progressBar.element().remove()
                        }
                    }, FILEUPLOADER_AFTER_LOAD_DELAY);
                    this._uploadedAction({
                        file: file,
                        jQueryEvent: e
                    })
                },
                _onProgressHandler: function(file, e) {
                    var totalSize = this._getTotalSize(),
                        currentLoadedSize = 0,
                        loadedSize = this._getLoadedSize(),
                        progress = 0;
                    if (file) {
                        currentLoadedSize = Math.min(e.loaded, file.value.size);
                        var segmentSize = currentLoadedSize - file.loadedSize;
                        loadedSize += segmentSize;
                        file.progressBar && file.progressBar.option({
                            value: currentLoadedSize,
                            showStatus: true
                        });
                        this._progressAction({
                            file: file,
                            segmentSize: segmentSize,
                            bytesLoaded: e.loaded,
                            jQueryEvent: e
                        });
                        file.loadedSize = currentLoadedSize
                    }
                    if (totalSize)
                        progress = Math.round(loadedSize / totalSize * 100);
                    this.option("progress", progress);
                    this._setLoadedSize(loadedSize)
                },
                _initStatusMessage: function(file) {
                    file.$statusMessage.css("display", "none")
                },
                _initCancelButton: function(file) {
                    var cancelClickHandler = $.proxy(function() {
                            file.request.abort();
                            this._removeFile(file)
                        }, this);
                    file.cancelButton.option("onClick", cancelClickHandler);
                    var hideCancelButton = function() {
                            setTimeout(function() {
                                file.cancelButton.option({visible: false})
                            }, FILEUPLOADER_AFTER_LOAD_DELAY)
                        };
                    file.onLoad.add(hideCancelButton);
                    file.onError.add(hideCancelButton)
                },
                _initUploadRequest: function(file) {
                    var that = this;
                    file.request = this._createRequest(this.option("uploadUrl"));
                    file.loadedSize = 0;
                    file.request.onreadystatechange = $.proxy(function(e) {
                        if (e.currentTarget.readyState === 4) {
                            var status = e.currentTarget.status;
                            if (that._isStatusSuccess(status))
                                this.onLoad.fire(e);
                            else if (that._isStatusError(status) || !this._isProgressStarted) {
                                this._isError = true;
                                this.onError.fire(e)
                            }
                        }
                    }, file);
                    file.request.upload.onprogress = $.proxy(function(e) {
                        if (this._isError)
                            return;
                        this._isProgressStarted = true;
                        this.onProgress.fire(e)
                    }, file);
                    file.request.upload.onloadstart = $.proxy(function(e) {
                        this.onLoadStart.fire(e)
                    }, file)
                },
                _isStatusSuccess: function(status) {
                    return 200 <= status && status < 300
                },
                _isStatusError: function(status) {
                    return 400 <= status && status < 500
                },
                _createRequest: function(url) {
                    var Request = getRequestPrototype(),
                        request = new Request;
                    request.open("POST", url, true);
                    return request
                },
                _createFormData: function(fieldName, fieldValue) {
                    var FormData = getFormDataPrototype(),
                        formData = new FormData;
                    formData.append(fieldName, fieldValue);
                    return formData
                },
                _createProgressBar: function(fileSize) {
                    return this._createComponent($("<div>"), ProgressBar, {
                            value: undefined,
                            min: 0,
                            max: fileSize,
                            statusFormat: function(ratio) {
                                return Math.round(ratio * 100) + "%"
                            },
                            showStatus: false,
                            statusPosition: "right"
                        })
                },
                _getTotalSize: function() {
                    if (!this._totalSize) {
                        var files = this.option("values"),
                            totalSize = 0;
                        $.each(files, function(_, file) {
                            totalSize += file.size
                        });
                        this._totalSize = totalSize
                    }
                    return this._totalSize
                },
                _getLoadedSize: function() {
                    if (!this._loadedSize) {
                        var loadedSize = 0;
                        $.each(this._files, function(_, file) {
                            loadedSize += file.loadedSize
                        });
                        this._loadedSize = loadedSize
                    }
                    return this._loadedSize
                },
                _setLoadedSize: function(value) {
                    this._loadedSize = value
                },
                _recalculateProgress: function() {
                    delete this._totalSize;
                    delete this._loadedSize;
                    this._onProgressHandler()
                },
                _getValidationTooltipTarget: function() {
                    return this._$inputWrapper
                },
                _optionChanged: function(args) {
                    var value = args.value;
                    switch (args.name) {
                        case"height":
                        case"width":
                            this._updateFileNameMaxWidth();
                            this.callBase(args);
                            break;
                        case"value":
                            if (!this._shouldChangeValue) {
                                this._$fileInput.val("");
                                this.option("values", [])
                            }
                            this.callBase(args);
                            break;
                        case"values":
                            if (value.length && !this._shouldChangeValue)
                                this.option("values", []);
                            else {
                                if (!this._doPreventRecreatingFiles) {
                                    this._createFiles();
                                    this._renderFiles()
                                }
                                this.option("value", value[0] || null);
                                this._recalculateProgress()
                            }
                            break;
                        case"name":
                        case"accept":
                            this._initFileInput();
                            break;
                        case"multiple":
                            this._initFileInput();
                            if (!args.value)
                                this.option("values", []);
                            break;
                        case"selectButtonText":
                            this._selectButton.option("text", value);
                            break;
                        case"uploadButtonText":
                            this._uploadButton && this._uploadButton.option("text", value);
                            break;
                        case"readyToUploadMessage":
                        case"uploadedMessage":
                        case"uploadFailedMessage":
                            this._invalidate();
                            break;
                        case"labelText":
                            this._$inputLabel.text(value);
                            break;
                        case"showFileList":
                            this._renderFiles();
                            break;
                        case"uploadUrl":
                        case"progress":
                            break;
                        case"allowCanceling":
                        case"uploadMode":
                            this.reset();
                            this._invalidate();
                            break;
                        case"onUploaded":
                            this._createUploadedAction();
                            break;
                        case"onProgress":
                            this._createProgressAction();
                            break;
                        case"onUploadError":
                            this._createUploadErrorAction();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _valueChangeArgs: function() {
                    return $.extend(this.callBase.apply(this, arguments), {values: this.option("values")})
                }
            });
        FileUploader.__internals = {
            getFormDataPrototype: getFormDataPrototype,
            getRequestPrototype: getRequestPrototype,
            isFormDataSupported: isFormDataSupported,
            changeFileInputTag: function(tag) {
                FILEUPLOADER_FILEINPUT_TAG = tag
            },
            resetFileInputTag: function() {
                FILEUPLOADER_FILEINPUT_TAG = "<input type='file'>"
            },
            changeRequestClass: function(requestClass) {
                getRequestPrototype = function() {
                    return requestClass
                }
            },
            resetRequestClass: function() {
                getRequestPrototype = this.getRequestPrototype
            },
            changeFormDataClass: function(customFormData) {
                getFormDataPrototype = function() {
                    return customFormData
                }
            },
            resetFormDataClass: function() {
                getFormDataPrototype = this.getFormDataPrototype
            }
        };
        registerComponent("dxFileUploader", uiNamespace, FileUploader);
        return FileUploader
    });
    DevExpress.require(["/ui/widgets/ui.fileUploader"]);
    /*! Module widgets-base, file ui.tabPanel.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            support = DX.require("/utils/utils.support"),
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator");
        var TABPANEL_CLASS = "dx-tabpanel",
            TABPANEL_TABS_CLASS = "dx-tabpanel-tabs",
            TABPANEL_CONTAINER_CLASS = "dx-tabpanel-container";
        registerComponent("dxTabPanel", ui, ui.dxMultiView.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        itemTitleTemplate: "title",
                        hoverStateEnabled: true,
                        showNavButtons: false,
                        scrollByContent: true,
                        scrollingEnabled: true,
                        onTitleClick: null,
                        onTitleHold: null,
                        onTitleRendered: null
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return devices.real().generic && !devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }, {
                            device: function(device) {
                                return !support.touch
                            },
                            options: {swipeEnabled: false}
                        }, {
                            device: {platform: "generic"},
                            options: {animationEnabled: false}
                        }])
            },
            _init: function() {
                this.callBase();
                this.element().addClass(TABPANEL_CLASS);
                this.setAria("role", "tabpanel");
                this._renderLayout()
            },
            _renderLayout: function() {
                var $element = this.element();
                this._$tabContainer = $("<div>").addClass(TABPANEL_TABS_CLASS).appendTo($element);
                var $tabs = $("<div>").appendTo(this._$tabContainer);
                this._tabs = this._createComponent($tabs, "dxTabs", this._tabConfig());
                this._$container = $("<div>").addClass(TABPANEL_CONTAINER_CLASS).appendTo($element);
                this._$container.append(this._$wrapper);
                this._updateLayout()
            },
            _updateLayout: function() {
                var tabsHeight = this._$tabContainer.outerHeight();
                this._$container.css({
                    "margin-top": -tabsHeight,
                    "padding-top": tabsHeight
                })
            },
            _refreshActiveDescendant: function() {
                var tabs = this._tabs,
                    tabItems = tabs.itemElements(),
                    $activeTab = $(tabItems[tabs.option("selectedIndex")]),
                    id = this.getFocusedItemId();
                this.setAria("controls", undefined, $(tabItems));
                this.setAria("controls", id, $activeTab)
            },
            _tabConfig: function() {
                return {
                        selectOnFocus: true,
                        focusStateEnabled: this.option("focusStateEnabled"),
                        hoverStateEnabled: this.option("hoverStateEnabled"),
                        tabIndex: this.option("tabIndex"),
                        selectedIndex: this.option("selectedIndex"),
                        onItemClick: this.option("onTitleClick"),
                        onItemHold: this.option("onTitleHold"),
                        itemHoldTimeout: this.option("itemHoldTimeout"),
                        onSelectionChanged: $.proxy(function(e) {
                            this.option("selectedIndex", e.component.option("selectedIndex"));
                            this._refreshActiveDescendant()
                        }, this),
                        onItemRendered: this.option("onTitleRendered"),
                        itemTemplate: this._getTemplateByOption("itemTitleTemplate"),
                        items: this.option("items"),
                        scrollingEnabled: this.option("scrollingEnabled"),
                        scrollByContent: this.option("scrollByContent"),
                        showNavButtons: this.option("showNavButtons"),
                        itemTemplateProperty: "tabTemplate",
                        loopItemFocus: this.option("loop"),
                        selectionRequired: true,
                        onOptionChanged: $.proxy(function(args) {
                            var name = args.name,
                                value = args.value;
                            if (name === "focusedElement") {
                                var id = value ? value.index() : value;
                                var newItem = value ? this._itemElements().eq(id) : value;
                                this.option("focusedElement", newItem)
                            }
                        }, this),
                        onFocusIn: $.proxy(function(args) {
                            this._focusInHandler(args.jQueryEvent)
                        }, this),
                        onFocusOut: $.proxy(function(args) {
                            this._focusOutHandler(args.jQueryEvent)
                        }, this)
                    }
            },
            _renderFocusTarget: function() {
                this._focusTarget().attr("tabindex", -1);
                this._refreshActiveDescendant()
            },
            _updateFocusState: function(e, isFocused) {
                this.callBase(e, isFocused);
                if (e.target === this._tabs._focusTarget().get(0))
                    this._toggleFocusClass(isFocused, this._focusTarget())
            },
            _setTabsOption: function(name, value) {
                if (this._tabs)
                    this._tabs.option(name, value)
            },
            _visibilityChanged: function(visible) {
                if (visible) {
                    this._tabs._dimensionChanged();
                    this._updateLayout()
                }
            },
            _optionChanged: function(args) {
                var name = args.name,
                    value = args.value;
                switch (name) {
                    case"dataSource":
                        this.callBase(args);
                        break;
                    case"items":
                    case"selectedIndex":
                    case"selectedItem":
                    case"itemHoldTimeout":
                    case"focusStateEnabled":
                    case"hoverStateEnabled":
                        this._setTabsOption(name, value);
                        this.callBase(args);
                        break;
                    case"scrollingEnabled":
                    case"scrollByContent":
                    case"showNavButtons":
                        this._setTabsOption(name, value);
                        break;
                    case"focusedElement":
                        var id = value ? value.index() : value;
                        var newItem = value ? this._tabs._itemElements().eq(id) : value;
                        this._setTabsOption("focusedElement", newItem);
                        this.callBase(args);
                        this._tabs.focus();
                        break;
                    case"itemTitleTemplate":
                        this._setTabsOption("itemTemplate", this._getTemplateByOption("itemTitleTemplate"));
                        break;
                    case"onTitleClick":
                        this._setTabsOption("onItemClick", value);
                        break;
                    case"onTitleHold":
                        this._setTabsOption("onItemHold", value);
                        break;
                    case"onTitleRendered":
                        this._setTabsOption("onItemRendered", value);
                        break;
                    case"loop":
                        this._setTabsOption("loopItemFocus", value);
                        break;
                    default:
                        this.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.colorView.js */
    DevExpress.define("/ui/widgets/ui.colorView", ["jquery", "/utils/utils.translator", "/utils/utils.browser", "/color", "/devices", "/componentRegistrator", "/ui/ui.editor", "/ui/uiNamespace", "/ui/widgets/ui.numberBox", "/ui/widgets/ui.textBox"], function($, translator, browser, Color, devices, registerComponent, Editor, uiNamespace, NumberBox, TextBox) {
        var COLOR_VIEW_CLASS = "dx-colorview",
            COLOR_VIEW_CONTAINER_CLASS = "dx-colorview-container",
            COLOR_VIEW_ROW_CLASS = "dx-colorview-container-row",
            COLOR_VIEW_CELL_CLASS = "dx-colorview-container-cell",
            COLOR_VIEW_PALETTE_CLASS = "dx-colorview-palette",
            COLOR_VIEW_PALETTE_CELL_CLASS = "dx-colorview-palette-cell",
            COLOR_VIEW_PALETTE_HANDLE_CLASS = "dx-colorview-palette-handle",
            COLOR_VIEW_PALETTE_GRADIENT_CLASS = "dx-colorview-palette-gradient",
            COLOR_VIEW_PALETTE_GRADIENT_WHITE_CLASS = "dx-colorview-palette-gradient-white",
            COLOR_VIEW_PALETTE_GRADIENT_BLACK_CLASS = "dx-colorview-palette-gradient-black",
            COLOR_VIEW_HUE_SCALE_CLASS = "dx-colorview-hue-scale",
            COLOR_VIEW_HUE_SCALE_CELL_CLASS = "dx-colorview-hue-scale-cell",
            COLOR_VIEW_HUE_SCALE_HANDLE_CLASS = "dx-colorview-hue-scale-handle",
            COLOR_VIEW_HUE_SCALE_WRAPPER_CLASS = "dx-colorview-hue-scale-wrapper",
            COLOR_VIEW_CONTROLS_CONTAINER_CLASS = "dx-colorview-controls-container",
            COLOR_VIEW_RED_LABEL_CLASS = "dx-colorview-label-red",
            COLOR_VIEW_GREEN_LABEL_CLASS = "dx-colorview-label-green",
            COLOR_VIEW_BLUE_LABEL_CLASS = "dx-colorview-label-blue",
            COLOR_VIEW_HEX_LABEL_CLASS = "dx-colorview-label-hex",
            COLOR_VIEW_ALPHA_CHANNEL_SCALE_CLASS = "dx-colorview-alpha-channel-scale",
            COLOR_VIEW_APLHA_CHANNEL_ROW_CLASS = "dx-colorview-alpha-channel-row",
            COLOR_VIEW_ALPHA_CHANNEL_SCALE_WRAPPER_CLASS = "dx-colorview-alpha-channel-wrapper",
            COLOR_VIEW_ALPHA_CHANNEL_LABEL_CLASS = "dx-colorview-alpha-channel-label",
            COLOR_VIEW_ALPHA_CHANNEL_HANDLE_CLASS = "dx-colorview-alpha-channel-handle",
            COLOR_VIEW_ALPHA_CHANNEL_CELL_CLASS = "dx-colorview-alpha-channel-cell",
            COLOR_VIEW_ALPHA_CHANNEL_BORDER_CLASS = "dx-colorview-alpha-channel-border",
            COLOR_VIEW_COLOR_PREVIEW = "dx-colorview-color-preview",
            COLOR_VIEW_COLOR_PREVIEW_CONTAINER_CLASS = "dx-colorview-color-preview-container",
            COLOR_VIEW_COLOR_PREVIEW_CONTAINER_INNER_CLASS = "dx-colorview-color-preview-container-inner",
            COLOR_VIEW_COLOR_PREVIEW_COLOR_CURRENT = "dx-colorview-color-preview-color-current",
            COLOR_VIEW_COLOR_PREVIEW_COLOR_NEW = "dx-colorview-color-preview-color-new";
        var ColorView = Editor.inherit({
                _supportedKeys: function() {
                    var isRTL = this.option("rtlEnabled");
                    var that = this,
                        getHorizontalPaletteStep = function(e) {
                            var step = 100 / that._paletteWidth;
                            if (e.shiftKey)
                                step = step * that.option("keyStep");
                            step = step > 1 ? step : 1;
                            return Math.round(step)
                        },
                        updateHorizontalPaletteValue = function(step) {
                            var value = that._currentColor.hsv.s + step;
                            if (value > 100)
                                value = 100;
                            else if (value < 0)
                                value = 0;
                            that._currentColor.hsv.s = value;
                            updatePaletteValue()
                        },
                        getVerticalPaletteStep = function(e) {
                            var step = 100 / that._paletteHeight;
                            if (e.shiftKey)
                                step = step * that.option("keyStep");
                            step = step > 1 ? step : 1;
                            return Math.round(step)
                        },
                        updateVerticalPaletteValue = function(step) {
                            var value = that._currentColor.hsv.v + step;
                            if (value > 100)
                                value = 100;
                            else if (value < 0)
                                value = 0;
                            that._currentColor.hsv.v = value;
                            updatePaletteValue()
                        },
                        updatePaletteValue = function() {
                            that._placePaletteHandle();
                            that._updateColorFromHsv(that._currentColor.hsv.h, that._currentColor.hsv.s, that._currentColor.hsv.v)
                        },
                        getHueScaleStep = function(e) {
                            var step = 360 / (that._hueScaleWrapperHeight - that._hueScaleHandleHeight);
                            if (e.shiftKey)
                                step = step * that.option("keyStep");
                            step = step > 1 ? step : 1;
                            return step
                        },
                        updateHueScaleValue = function(step) {
                            that._currentColor.hsv.h += step;
                            that._placeHueScaleHandle();
                            var handleLocation = translator.locate(that._$hueScaleHandle);
                            that._updateColorHue(handleLocation.top + that._hueScaleHandleHeight / 2)
                        },
                        getAlphaScaleStep = function(e) {
                            var step = 1 / that._alphaChannelScaleWorkWidth;
                            if (e.shiftKey)
                                step = step * that.option("keyStep");
                            step = step > 0.01 ? step : 0.01;
                            step = isRTL ? -step : step;
                            return step
                        },
                        updateAlphaScaleValue = function(step) {
                            that._currentColor.a += step;
                            that._placeAlphaChannelHandle();
                            var handleLocation = translator.locate(that._$alphaChannelHandle);
                            that._calculateColorTransparenceByScaleWidth(handleLocation.left + that._alphaChannelHandleWidth / 2)
                        };
                    return $.extend(this.callBase(), {
                            upArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                if (e.ctrlKey) {
                                    if (this._currentColor.hsv.h <= 360 && !this._isTopColorHue)
                                        updateHueScaleValue(getHueScaleStep(e))
                                }
                                else if (this._currentColor.hsv.v < 100)
                                    updateVerticalPaletteValue(getVerticalPaletteStep(e))
                            },
                            downArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                if (e.ctrlKey) {
                                    if (this._currentColor.hsv.h >= 0) {
                                        if (this._isTopColorHue)
                                            this._currentColor.hsv.h = 360;
                                        updateHueScaleValue(-getHueScaleStep(e))
                                    }
                                }
                                else if (this._currentColor.hsv.v > 0)
                                    updateVerticalPaletteValue(-getVerticalPaletteStep(e))
                            },
                            rightArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                if (e.ctrlKey) {
                                    if (isRTL ? this._currentColor.a < 1 : this._currentColor.a > 0 && this.option("editAlphaChannel"))
                                        updateAlphaScaleValue(-getAlphaScaleStep(e))
                                }
                                else if (this._currentColor.hsv.s < 100)
                                    updateHorizontalPaletteValue(getHorizontalPaletteStep(e))
                            },
                            leftArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                if (e.ctrlKey) {
                                    if (isRTL ? this._currentColor.a > 0 : this._currentColor.a < 1 && this.option("editAlphaChannel"))
                                        updateAlphaScaleValue(getAlphaScaleStep(e))
                                }
                                else if (this._currentColor.hsv.s > 0)
                                    updateHorizontalPaletteValue(-getHorizontalPaletteStep(e))
                            },
                            enter: function(e) {
                                if (this.option("applyValueMode") === "useButtons")
                                    this.applyColor()
                            }
                        })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            value: null,
                            editAlphaChannel: false,
                            applyValueMode: "useButtons",
                            keyStep: 1
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }])
                },
                _init: function() {
                    this.callBase();
                    this._initColorAndOpacity()
                },
                _initColorAndOpacity: function() {
                    this._setCurrentColor(this.option("value"))
                },
                _setCurrentColor: function(value) {
                    value = value || "#000000";
                    var newColor = new Color(value);
                    if (!newColor.colorIsInvalid) {
                        if (!this._currentColor || this._makeRgba(this._currentColor) !== this._makeRgba(newColor)) {
                            this._currentColor = newColor;
                            if (this._$currentColor)
                                this._makeTransparentBackground(this._$currentColor, newColor)
                        }
                    }
                    else
                        this.option("value", this._currentColor.baseColor)
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(COLOR_VIEW_CLASS);
                    this._renderColorPickerContainer()
                },
                _enterKeyHandler: function() {
                    if (this.option("applyValueMode") === "useButtons")
                        this.applyColor()
                },
                _makeTransparentBackground: function($el, color) {
                    if (!(color instanceof Color))
                        color = new Color(color);
                    if (browser.msie && browser.version === "8.0")
                        $el.css({
                            background: color.toHex(),
                            filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=" + color.a * 100 + ")"
                        });
                    else
                        $el.css("backgroundColor", this._makeRgba(color))
                },
                _makeRgba: function(color) {
                    if (!(color instanceof Color))
                        color = new Color(color);
                    return "rgba(" + [color.r, color.g, color.b, color.a].join(", ") + ")"
                },
                _renderValue: function() {
                    this.callBase(this.option("editAlphaChannel") ? this._makeRgba(this._currentColor) : this.option("value"))
                },
                _renderColorPickerContainer: function() {
                    var $parent = this.element();
                    this._$colorPickerContainer = $("<div>", {
                        "class": COLOR_VIEW_CONTAINER_CLASS,
                        appendTo: $parent
                    });
                    this._renderHtmlRows();
                    this._renderPalette();
                    this._renderHueScale();
                    this._renderControlsContainer();
                    this._renderControls();
                    this._renderAlphaChannelElements()
                },
                _renderHtmlRows: function(updatedOption) {
                    var $renderedRows = this._$colorPickerContainer.find("." + COLOR_VIEW_ROW_CLASS),
                        renderedRowsCount = $renderedRows.length,
                        rowCount = this._calculateRowsCount(),
                        delta = renderedRowsCount - rowCount;
                    if (delta > 0) {
                        var index = this._calculateRemovedHtmlRowIndex(renderedRowsCount, updatedOption);
                        $renderedRows.eq(index).remove()
                    }
                    if (delta < 0) {
                        delta = Math.abs(delta);
                        var rows = [];
                        for (var i = 0; i < delta; i++)
                            rows.push($("<div>", {"class": COLOR_VIEW_ROW_CLASS}));
                        if (renderedRowsCount) {
                            var previousRowIndex = this._calculateHtmlRowIndex(renderedRowsCount, updatedOption);
                            $renderedRows.eq(previousRowIndex).after(rows)
                        }
                        else
                            this._$colorPickerContainer.append(rows)
                    }
                },
                _renderHtmlCellInsideRow: function(rowSelector, $rowParent, additionalClass) {
                    return $("<div>", {
                            "class": COLOR_VIEW_CELL_CLASS,
                            addClass: additionalClass,
                            appendTo: $rowParent.find("." + COLOR_VIEW_ROW_CLASS + rowSelector)
                        })
                },
                _calculateRowsCount: function() {
                    if (this.option("editAlphaChannel"))
                        return this.option("applyValueMode") === "instantly" ? 2 : 3;
                    return this.option("applyValueMode") === "instantly" ? 1 : 2
                },
                _calculateRemovedHtmlRowIndex: function(renderedRowsCount, updatedOption) {
                    var index = -1;
                    if (renderedRowsCount === 3) {
                        if (updatedOption === "editAlphaChannel")
                            index = -2;
                        if (updatedOption === "applyValueMode")
                            index = -1
                    }
                    return index
                },
                _calculateHtmlRowIndex: function(renderedRowsCount, updatedOption) {
                    var index = 0;
                    if (renderedRowsCount === 2)
                        if (updatedOption === "applyValueMode")
                            index = 1;
                    return index
                },
                _renderPalette: function() {
                    var $paletteCell = this._renderHtmlCellInsideRow(":first", this._$colorPickerContainer, COLOR_VIEW_PALETTE_CELL_CLASS),
                        $paletteGradientWhite = $("<div>", {"class": [COLOR_VIEW_PALETTE_GRADIENT_CLASS, COLOR_VIEW_PALETTE_GRADIENT_WHITE_CLASS].join(" ")}),
                        $paletteGradientBlack = $("<div>", {"class": [COLOR_VIEW_PALETTE_GRADIENT_CLASS, COLOR_VIEW_PALETTE_GRADIENT_BLACK_CLASS].join(" ")});
                    this._$palette = $("<div>", {
                        "class": COLOR_VIEW_PALETTE_CLASS,
                        css: {backgroundColor: this._currentColor.getPureColor().toHex()},
                        appendTo: $paletteCell
                    });
                    this._paletteHeight = this._$palette.height();
                    this._paletteWidth = this._$palette.width();
                    this._renderPaletteHandle();
                    this._$palette.append([$paletteGradientWhite, $paletteGradientBlack])
                },
                _renderPaletteHandle: function() {
                    this._createComponent(this._$paletteHandle = $("<div>", {
                        "class": COLOR_VIEW_PALETTE_HANDLE_CLASS,
                        appendTo: this._$palette
                    }), "dxDraggable", {
                        area: this._$palette,
                        allowMoveByClick: true,
                        boundOffset: $.proxy(function() {
                            return -this._paletteHandleHeight / 2
                        }, this),
                        onDrag: $.proxy(function(e) {
                            var paletteHandlePosition = translator.locate(this._$paletteHandle);
                            this._updateByDrag = true;
                            this._updateColorFromHsv(this._currentColor.hsv.h, this._calculateColorSaturation(paletteHandlePosition), this._calculateColorValue(paletteHandlePosition))
                        }, this)
                    });
                    this._paletteHandleWidth = this._$paletteHandle.width();
                    this._paletteHandleHeight = this._$paletteHandle.height();
                    this._placePaletteHandle()
                },
                _placePaletteHandle: function() {
                    translator.move(this._$paletteHandle, {
                        left: Math.round(this._paletteWidth * this._currentColor.hsv.s / 100 - this._paletteHandleWidth / 2),
                        top: Math.round(this._paletteHeight - this._paletteHeight * this._currentColor.hsv.v / 100 - this._paletteHandleHeight / 2)
                    })
                },
                _calculateColorValue: function(paletteHandlePosition) {
                    var value = Math.floor(paletteHandlePosition.top + this._paletteHandleHeight / 2);
                    return 100 - Math.round(value * 100 / this._paletteHeight)
                },
                _calculateColorSaturation: function(paletteHandlePosition) {
                    var saturation = Math.floor(paletteHandlePosition.left + this._paletteHandleWidth / 2);
                    return Math.round(saturation * 100 / this._paletteWidth)
                },
                _updateColorFromHsv: function(hue, saturation, value) {
                    var a = this._currentColor.a;
                    this._currentColor = new Color("hsv(" + [hue, saturation, value].join(",") + ")");
                    this._currentColor.a = a;
                    this._updateColorParamsAndColorPreview();
                    if (this.option("applyValueMode") === "instantly")
                        this.applyColor()
                },
                _renderHueScale: function() {
                    var $hueScaleCell = this._renderHtmlCellInsideRow(":first", this._$colorPickerContainer, COLOR_VIEW_HUE_SCALE_CELL_CLASS);
                    this._$hueScaleWrapper = $("<div>", {
                        "class": COLOR_VIEW_HUE_SCALE_WRAPPER_CLASS,
                        appendTo: $hueScaleCell
                    });
                    this._$hueScale = $("<div>", {
                        "class": COLOR_VIEW_HUE_SCALE_CLASS,
                        appendTo: this._$hueScaleWrapper
                    });
                    this._hueScaleHeight = this._$hueScale.height();
                    this._hueScaleWrapperHeight = this._$hueScaleWrapper.outerHeight();
                    this._renderHueScaleHandle()
                },
                _renderHueScaleHandle: function() {
                    this._createComponent(this._$hueScaleHandle = $("<div>", {
                        "class": COLOR_VIEW_HUE_SCALE_HANDLE_CLASS,
                        appendTo: this._$hueScaleWrapper
                    }), "dxDraggable", {
                        area: this._$hueScaleWrapper,
                        allowMoveByClick: true,
                        direction: "vertical",
                        onDrag: $.proxy(function(e) {
                            this._updateByDrag = true;
                            this._updateColorHue(translator.locate(this._$hueScaleHandle).top + this._hueScaleHandleHeight / 2)
                        }, this)
                    });
                    this._hueScaleHandleHeight = this._$hueScaleHandle.height();
                    this._placeHueScaleHandle()
                },
                _placeHueScaleHandle: function() {
                    var hueScaleHeight = this._hueScaleWrapperHeight,
                        handleHeight = this._hueScaleHandleHeight,
                        top = (hueScaleHeight - handleHeight) * (360 - this._currentColor.hsv.h) / 360;
                    if (hueScaleHeight < top + handleHeight)
                        top = hueScaleHeight - handleHeight;
                    if (top < 0)
                        top = 0;
                    translator.move(this._$hueScaleHandle, {top: Math.round(top)})
                },
                _updateColorHue: function(handlePosition) {
                    var hue = 360 - Math.round((handlePosition - this._hueScaleHandleHeight / 2) * 360 / (this._hueScaleWrapperHeight - this._hueScaleHandleHeight)),
                        saturation = this._currentColor.hsv.s,
                        value = this._currentColor.hsv.v;
                    this._isTopColorHue = false;
                    hue = hue < 0 ? 0 : hue;
                    if (hue >= 360) {
                        this._isTopColorHue = true;
                        hue = 0
                    }
                    this._updateColorFromHsv(hue, saturation, value);
                    this._$palette.css("backgroundColor", this._currentColor.getPureColor().toHex())
                },
                _renderControlsContainer: function() {
                    var $controlsContainerCell = this._renderHtmlCellInsideRow(":first", this._$colorPickerContainer);
                    this._$controlsContainer = $("<div>", {
                        "class": COLOR_VIEW_CONTROLS_CONTAINER_CLASS,
                        appendTo: $controlsContainerCell
                    })
                },
                _renderControls: function() {
                    this._renderColorsPreview();
                    this._renderRgbInputs();
                    this._renderHexInput()
                },
                _renderColorsPreview: function() {
                    var $colorsPreviewContainer = $("<div>", {
                            "class": COLOR_VIEW_COLOR_PREVIEW_CONTAINER_CLASS,
                            appendTo: this._$controlsContainer
                        }),
                        $colorsPreviewContainerInner = $("<div>", {
                            "class": COLOR_VIEW_COLOR_PREVIEW_CONTAINER_INNER_CLASS,
                            appendTo: $colorsPreviewContainer
                        });
                    this._$currentColor = $("<div>", {"class": [COLOR_VIEW_COLOR_PREVIEW, COLOR_VIEW_COLOR_PREVIEW_COLOR_CURRENT].join(" ")});
                    this._$newColor = $("<div>", {"class": [COLOR_VIEW_COLOR_PREVIEW, COLOR_VIEW_COLOR_PREVIEW_COLOR_NEW].join(" ")});
                    this._makeTransparentBackground(this._$currentColor, this._currentColor);
                    this._makeTransparentBackground(this._$newColor, this._currentColor);
                    $colorsPreviewContainerInner.append([this._$currentColor, this._$newColor])
                },
                _renderAlphaChannelElements: function() {
                    if (this.option("editAlphaChannel")) {
                        this._$colorPickerContainer.find("." + COLOR_VIEW_ROW_CLASS).eq(1).addClass(COLOR_VIEW_APLHA_CHANNEL_ROW_CLASS);
                        this._renderAlphaChannelScale();
                        this._renderAlphaChannelInput()
                    }
                },
                _renderRgbInputs: function() {
                    this._rgbInputsWithLabels = [this._renderEditorWithLabel({
                            editorType: NumberBox.publicName(),
                            value: this._currentColor.r,
                            onValueChanged: $.proxy(this._updateColor, this, false),
                            labelText: "R",
                            labelAriaText: Globalize.localize("dxColorView-ariaRed"),
                            labelClass: COLOR_VIEW_RED_LABEL_CLASS
                        }), this._renderEditorWithLabel({
                            editorType: NumberBox.publicName(),
                            value: this._currentColor.g,
                            onValueChanged: $.proxy(this._updateColor, this, false),
                            labelText: "G",
                            labelAriaText: Globalize.localize("dxColorView-ariaGreen"),
                            labelClass: COLOR_VIEW_GREEN_LABEL_CLASS
                        }), this._renderEditorWithLabel({
                            editorType: NumberBox.publicName(),
                            value: this._currentColor.b,
                            onValueChanged: $.proxy(this._updateColor, this, false),
                            labelText: "B",
                            labelAriaText: Globalize.localize("dxColorView-ariaBlue"),
                            labelClass: COLOR_VIEW_BLUE_LABEL_CLASS
                        })];
                    this._$controlsContainer.append(this._rgbInputsWithLabels);
                    this._rgbInputs = [this._rgbInputsWithLabels[0].find(".dx-numberbox").dxNumberBox("instance"), this._rgbInputsWithLabels[1].find(".dx-numberbox").dxNumberBox("instance"), this._rgbInputsWithLabels[2].find(".dx-numberbox").dxNumberBox("instance")];
                    $.each(this._rgbInputs, $.proxy(function(_, instance) {
                        this._attachEnterKeyHandler(instance)
                    }, this))
                },
                _renderEditorWithLabel: function(options) {
                    var $editor = $("<div>"),
                        $label = $("<label>", {
                            "class": options.labelClass,
                            text: options.labelText + ":",
                            append: $editor
                        }).off("dxclick").on("dxclick", function(e) {
                            e.preventDefault()
                        }),
                        editorType = options.editorType,
                        editorOptions = {
                            value: options.value,
                            onValueChanged: options.onValueChanged
                        };
                    if (editorType === NumberBox.publicName()) {
                        editorOptions.min = options.min || 0;
                        editorOptions.max = options.max || 255;
                        editorOptions.step = options.step || 1
                    }
                    $editor[editorType](editorOptions);
                    this.setAria("label", options.labelAriaText, $editor);
                    return $label
                },
                hexInputOptions: function() {
                    return {
                            editorType: TextBox.publicName(),
                            value: this._currentColor.toHex().replace("#", ""),
                            onValueChanged: $.proxy(this._updateColor, this, true),
                            labelClass: COLOR_VIEW_HEX_LABEL_CLASS,
                            labelText: "#",
                            labelAriaText: Globalize.localize("dxColorView-ariaHex")
                        }
                },
                _renderHexInput: function() {
                    this._hexInput = TextBox.getInstance(this._renderEditorWithLabel(this.hexInputOptions()).appendTo(this._$controlsContainer).find(".dx-textbox"));
                    this._attachEnterKeyHandler(this._hexInput)
                },
                _attachEnterKeyHandler: function(instance) {
                    instance.registerKeyHandler("enter", $.proxy(function(e) {
                        this._enterKeyHandler(e)
                    }, this))
                },
                _renderAlphaChannelScale: function() {
                    var $alphaChannelScaleCell = this._renderHtmlCellInsideRow(":eq(1)", this._$colorPickerContainer, COLOR_VIEW_ALPHA_CHANNEL_CELL_CLASS),
                        $alphaChannelBorder = $("<div>", {
                            "class": COLOR_VIEW_ALPHA_CHANNEL_BORDER_CLASS,
                            appendTo: $alphaChannelScaleCell
                        }),
                        $alphaChannelScaleWrapper = $("<div>", {
                            "class": COLOR_VIEW_ALPHA_CHANNEL_SCALE_WRAPPER_CLASS,
                            appendTo: $alphaChannelBorder
                        });
                    this._$alphaChannelScale = $("<div>", {
                        "class": COLOR_VIEW_ALPHA_CHANNEL_SCALE_CLASS,
                        appendTo: $alphaChannelScaleWrapper
                    });
                    this._makeCSSLinearGradient(this._$alphaChannelScale);
                    this._renderAlphaChannelHandle($alphaChannelScaleCell)
                },
                _makeCSSLinearGradient: function($el) {
                    var color = this._currentColor,
                        colorAsRgb = [color.r, color.g, color.b].join(","),
                        colorAsHex = color.toHex().replace("#", "");
                    var combineGradientString = function(colorAsRgb, colorAsHex) {
                            var rtlEnabled = this.option("rtlEnabled"),
                                startColor = "rgba(" + colorAsRgb + ", " + (rtlEnabled ? "1" : "0") + ")",
                                finishColor = "rgba(" + colorAsRgb + ", " + (rtlEnabled ? "0" : "1") + ")",
                                startColorIE = "'#" + (rtlEnabled ? "00" : "") + colorAsHex + "'",
                                finishColorIE = "'#" + (rtlEnabled ? "" : "00") + colorAsHex + "'";
                            return ["background-image: -webkit-linear-gradient(180deg, " + startColor + ", " + finishColor + ")", "background-image: -moz-linear-gradient(-90deg, " + startColor + ", " + finishColor + ")", "background-image: -ms-linear-gradient(-90deg, " + startColor + ", " + finishColor + ")", "background-image: -o-linear-gradient(-90deg, " + startColor + ", " + finishColor + ")", "background-image: linear-gradient(-90deg, " + startColor + ", " + finishColor + ")", "filter: progid:DXImageTransform.Microsoft.gradient(GradientType=1,startColorstr=" + startColorIE + ", endColorstr=" + finishColorIE + ")", "-ms-filter: progid:DXImageTransform.Microsoft.gradient(GradientType=1,startColorstr=" + startColorIE + ", endColorstr=" + finishColorIE + ")"].join(";")
                        };
                    $el.attr("style", combineGradientString.call(this, colorAsRgb, colorAsHex))
                },
                _renderAlphaChannelInput: function() {
                    var that = this,
                        $alphaChannelInputCell = this._renderHtmlCellInsideRow(":eq(1)", this._$colorPickerContainer);
                    that._alphaChannelInput = this._renderEditorWithLabel({
                        editorType: NumberBox.publicName(),
                        value: this._currentColor.a,
                        max: 1,
                        step: 0.1,
                        onValueChanged: function(e) {
                            var value = e.value;
                            value = that._currentColor.isValidAlpha(value) ? value : that._currentColor.a;
                            that._updateColorTransparence(value);
                            that._placeAlphaChannelHandle()
                        },
                        labelClass: COLOR_VIEW_ALPHA_CHANNEL_LABEL_CLASS,
                        labelText: "Alpha",
                        labelAriaText: Globalize.localize("dxColorView-ariaAlpha")
                    }).appendTo($alphaChannelInputCell).find(".dx-numberbox").dxNumberBox("instance");
                    this._attachEnterKeyHandler(that._alphaChannelInput)
                },
                _updateColorTransparence: function(transparence) {
                    this._currentColor.a = transparence;
                    this._makeTransparentBackground(this._$newColor, this._currentColor);
                    if (this.option("applyValueMode") === "instantly")
                        this.applyColor()
                },
                _renderAlphaChannelHandle: function($parent) {
                    this._createComponent(this._$alphaChannelHandle = $("<div>", {
                        "class": COLOR_VIEW_ALPHA_CHANNEL_HANDLE_CLASS,
                        appendTo: $parent
                    }), "dxDraggable", {
                        area: $parent,
                        allowMoveByClick: true,
                        direction: "horizontal",
                        onDrag: $.proxy(function(e) {
                            this._updateByDrag = true;
                            var $alphaChannelHandle = this._$alphaChannelHandle,
                                alphaChannelHandlePosition = translator.locate($alphaChannelHandle).left + this._alphaChannelHandleWidth / 2;
                            this._calculateColorTransparenceByScaleWidth(alphaChannelHandlePosition)
                        }, this)
                    });
                    this._alphaChannelHandleWidth = this._$alphaChannelHandle.width();
                    this._alphaChannelScaleWorkWidth = $parent.width() - this._alphaChannelHandleWidth;
                    this._placeAlphaChannelHandle()
                },
                _calculateColorTransparenceByScaleWidth: function(handlePosition) {
                    var transparence = (handlePosition - this._alphaChannelHandleWidth / 2) / this._alphaChannelScaleWorkWidth,
                        rtlEnabled = this.option("rtlEnabled");
                    transparence = rtlEnabled ? transparence : 1 - transparence;
                    if (handlePosition >= this._alphaChannelScaleWorkWidth + this._alphaChannelHandleWidth / 2)
                        transparence = rtlEnabled ? 1 : 0;
                    else if (transparence < 1)
                        transparence = transparence.toFixed(2);
                    this._alphaChannelInput.option("value", transparence)
                },
                _placeAlphaChannelHandle: function() {
                    var left = this._alphaChannelScaleWorkWidth * (1 - this._currentColor.a);
                    if (left < 0)
                        left = 0;
                    if (this._alphaChannelScaleWorkWidth < left)
                        left = this._alphaChannelScaleWorkWidth;
                    translator.move(this._$alphaChannelHandle, {left: this.option("rtlEnabled") ? this._alphaChannelScaleWorkWidth - left : left})
                },
                applyColor: function() {
                    var colorValue = this.option("editAlphaChannel") ? this._makeRgba(this._currentColor) : this._currentColor.toHex();
                    this._makeTransparentBackground(this._$currentColor, this._currentColor);
                    this.option("value", colorValue)
                },
                cancelColor: function() {
                    this._initColorAndOpacity();
                    this._refreshMarkup()
                },
                _updateColor: function(isHex) {
                    var rgba,
                        newColor;
                    if (isHex)
                        newColor = this._validateHex("#" + this._hexInput.option("value"));
                    else {
                        rgba = this._validateRgb();
                        if (this._alphaChannelInput) {
                            rgba.push(this._alphaChannelInput.option("value"));
                            newColor = "rgba(" + rgba.join(", ") + ")"
                        }
                        else
                            newColor = "rgb(" + rgba.join(", ") + ")"
                    }
                    if (!this._suppressEditorsValueUpdating) {
                        this._currentColor = new Color(newColor);
                        this._refreshMarkup();
                        if (this.option("applyValueMode") === "instantly")
                            this.applyColor()
                    }
                },
                _validateHex: function(hex) {
                    return this._currentColor.isValidHex(hex) ? hex : this._currentColor.toHex()
                },
                _validateRgb: function() {
                    var r = this._rgbInputs[0].option("value"),
                        g = this._rgbInputs[1].option("value"),
                        b = this._rgbInputs[2].option("value");
                    if (!this._currentColor.isValidRGB(r, g, b)) {
                        r = this._currentColor.r;
                        g = this._currentColor.g;
                        b = this._currentColor.b
                    }
                    return [r, g, b]
                },
                _refreshMarkup: function() {
                    this._placeHueScaleHandle();
                    this._placePaletteHandle();
                    this._updateColorParamsAndColorPreview();
                    this._$palette.css("backgroundColor", this._currentColor.getPureColor().toHex());
                    if (this._$alphaChannelHandle) {
                        this._updateColorTransparence(this._currentColor.a);
                        this._placeAlphaChannelHandle()
                    }
                },
                _updateColorParamsAndColorPreview: function() {
                    this._suppressEditorsValueUpdating = true;
                    this._hexInput.option("value", this._currentColor.toHex().replace("#", ""));
                    this._rgbInputs[0].option("value", this._currentColor.r);
                    this._rgbInputs[1].option("value", this._currentColor.g);
                    this._rgbInputs[2].option("value", this._currentColor.b);
                    this._suppressEditorsValueUpdating = false;
                    this._makeTransparentBackground(this._$newColor, this._currentColor);
                    if (this.option("editAlphaChannel")) {
                        this._makeCSSLinearGradient.call(this, this._$alphaChannelScale);
                        this._alphaChannelInput.option("value", this._currentColor.a)
                    }
                },
                _optionChanged: function(args) {
                    var value = args.value;
                    switch (args.name) {
                        case"value":
                            this._setCurrentColor(value);
                            if (!this._updateByDrag)
                                this._refreshMarkup();
                            this._updateByDrag = false;
                            this.callBase(args);
                            break;
                        case"editAlphaChannel":
                            if (this._$colorPickerContainer) {
                                this._renderHtmlRows("editAlphaChannel");
                                this._renderAlphaChannelElements()
                            }
                            break;
                        case"applyValueMode":
                            if (this._$colorPickerContainer)
                                this._renderHtmlRows("applyValueMode");
                            break;
                        case"keyStep":
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        registerComponent("dxColorView", uiNamespace, ColorView);
        return ColorView
    });
    /*! Module widgets-base, file ui.colorBox.js */
    DevExpress.define("/ui/widgets/ui.colorBox", ["jquery", "/color", "/componentRegistrator", "/ui/widgets/ui.colorView", "/ui/uiNamespace", "/ui/events/ui.events.utils", "/ui/widgets/ui.dropDownEditor"], function($, Color, registerComponent, ColorView, uiNamespace, eventUtils, DropDownEditor) {
        var COLOR_BOX_CLASS = "dx-colorbox",
            COLOR_BOX_INPUT_CLASS = COLOR_BOX_CLASS + "-input",
            COLOR_BOX_INPUT_CONTAINER_CLASS = COLOR_BOX_INPUT_CLASS + "-container",
            COLOR_BOX_COLOR_RESULT_PREVIEW_CLASS = COLOR_BOX_CLASS + "-color-result-preview",
            COLOR_BOX_COLOR_IS_NOT_DEFINED = COLOR_BOX_CLASS + "-color-is-not-defined",
            COLOR_BOX_OVERLAY_CLASS = COLOR_BOX_CLASS + "-overlay",
            COLOR_BOX_CONTAINER_CELL_CLASS = "dx-colorview-container-cell",
            COLOR_BOX_BUTTON_CELL_CLASS = "dx-colorview-button-cell",
            COLOR_BOX_BUTTONS_CONTAINER_CLASS = "dx-colorview-buttons-container",
            COLOR_BOX_APPLY_BUTTON_CLASS = "dx-colorview-apply-button",
            COLOR_BOX_CANCEL_BUTTON_CLASS = "dx-colorview-cancel-button";
        var colorEditorPrototype = ColorView.prototype,
            colorUtils = {
                makeTransparentBackground: $.proxy(colorEditorPrototype._makeTransparentBackground, colorEditorPrototype),
                makeRgba: $.proxy(colorEditorPrototype._makeRgba, colorEditorPrototype)
            };
        var ColorBox = DropDownEditor.inherit({
                _supportedKeys: function() {
                    var arrowHandler = function(e) {
                            e.stopPropagation();
                            if (this.option("opened")) {
                                e.preventDefault();
                                return true
                            }
                        };
                    var upArrowHandler = function(e) {
                            if (!this.option("opened")) {
                                e.preventDefault();
                                return false
                            }
                            if (e.altKey) {
                                this.close();
                                return false
                            }
                            return true
                        };
                    var downArrowHandler = function(e) {
                            if (!this.option("opened") && !e.altKey) {
                                e.preventDefault();
                                return false
                            }
                            if (!this.option("opened") && e.altKey) {
                                this._validatedOpening();
                                return false
                            }
                            return true
                        };
                    return $.extend(this.callBase(), {
                            tab: function(e) {
                                if (this.option("opened")) {
                                    e.preventDefault();
                                    this._colorView._rgbInputs[0].focus()
                                }
                            },
                            enter: this._enterKeyHandler,
                            leftArrow: arrowHandler,
                            rightArrow: arrowHandler,
                            upArrow: upArrowHandler,
                            downArrow: downArrowHandler
                        })
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            editAlphaChannel: false,
                            applyButtonText: Globalize.localize("OK"),
                            cancelButtonText: Globalize.localize("Cancel"),
                            applyValueMode: "useButtons",
                            keyStep: 1,
                            onApplyButtonClick: null,
                            onCancelButtonClick: null,
                            buttonsLocation: "bottom after"
                        })
                },
                _popupConfig: function() {
                    return $.extend(this.callBase(), {
                            height: "auto",
                            width: ""
                        })
                },
                _contentReadyHandler: function() {
                    this._createColorView();
                    this._addPopupBottomClasses()
                },
                _addPopupBottomClasses: function() {
                    var $popupBottom = this._popup.bottomToolbar();
                    if ($popupBottom) {
                        $popupBottom.addClass(COLOR_BOX_CONTAINER_CELL_CLASS).addClass(COLOR_BOX_BUTTON_CELL_CLASS).find(".dx-toolbar-items-container").addClass(COLOR_BOX_BUTTONS_CONTAINER_CLASS);
                        $popupBottom.find(".dx-popup-done").addClass(COLOR_BOX_APPLY_BUTTON_CLASS);
                        $popupBottom.find(".dx-popup-cancel").addClass(COLOR_BOX_CANCEL_BUTTON_CLASS)
                    }
                },
                _createColorView: function() {
                    this._popup.overlayContent().addClass(COLOR_BOX_OVERLAY_CLASS);
                    var $colorView = $("<div>").appendTo(this._popup.content());
                    this._colorView = this._createComponent($colorView, ColorView, this._colorViewConfig());
                    this._colorView._enterKeyHandler = $.proxy(this._enterKeyHandler, this);
                    $colorView.on("focus", $.proxy(function() {
                        this.focus()
                    }, this))
                },
                _colorViewConfig: function() {
                    var that = this;
                    return {
                            value: that.option("value"),
                            editAlphaChannel: that.option("editAlphaChannel"),
                            applyValueMode: that.option("applyValueMode"),
                            focusStateEnabled: that.option("focusStateEnabled"),
                            onValueChanged: function(args) {
                                var value = args.value;
                                that.option("value", value);
                                if (value)
                                    colorUtils.makeTransparentBackground(that._$colorResultPreview, value)
                            },
                            _keyboardProcessor: that._colorViewProccessor
                        }
                },
                _enterKeyHandler: function(e) {
                    var newValue = this._input().val(),
                        oldValue = this.option("editAlphaChannel") ? colorUtils.makeRgba(this.option("value")) : this.option("value");
                    var color = new Color(newValue);
                    if (color.colorIsInvalid && newValue !== "") {
                        this._input().val(oldValue);
                        return
                    }
                    if (newValue && newValue !== oldValue) {
                        this._applyColorFromInput(newValue);
                        this.option("value", this.option("editAlphaChannel") ? colorUtils.makeRgba(newValue) : newValue);
                        return false
                    }
                    if (this._colorView && this.option("applyValueMode") === "useButtons")
                        this._colorView.applyColor();
                    if (this.option("opened")) {
                        e.preventDefault();
                        this.close()
                    }
                    return false
                },
                _applyButtonHandler: function() {
                    this._colorView.applyColor();
                    if ($.isFunction(this.option("onApplyButtonClick")))
                        this.option("onApplyButtonClick")();
                    this.callBase()
                },
                _cancelButtonHandler: function() {
                    this._colorView.cancelColor();
                    if ($.isFunction(this.option("onCancelButtonClick")))
                        this.option("onCancelButtonClick")();
                    this.callBase()
                },
                _attachChildKeyboardEvents: function() {
                    this._colorViewProccessor = this._keyboardProcessor.attachChildProcessor();
                    if (this._colorView) {
                        this._colorView.option("_keyboardProcessor", this._colorViewProccessor);
                        return
                    }
                },
                _init: function() {
                    this.callBase()
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(COLOR_BOX_CLASS)
                },
                _renderInput: function() {
                    this.callBase();
                    this._input().addClass(COLOR_BOX_INPUT_CLASS);
                    this._renderColorPreview()
                },
                _renderColorPreview: function() {
                    this.element().wrapInner($("<div/>").addClass(COLOR_BOX_INPUT_CONTAINER_CLASS));
                    this._$colorBoxInputContainer = this.element().children().eq(0);
                    this._$colorResultPreview = $("<div>", {
                        "class": COLOR_BOX_COLOR_RESULT_PREVIEW_CLASS,
                        appendTo: this._$colorBoxInputContainer
                    });
                    if (!this.option("value"))
                        this._$colorBoxInputContainer.addClass(COLOR_BOX_COLOR_IS_NOT_DEFINED);
                    else
                        colorUtils.makeTransparentBackground(this._$colorResultPreview, this.option("value"))
                },
                _renderValue: function() {
                    var value = this.option("value");
                    this.option("text", this.option("editAlphaChannel") ? colorUtils.makeRgba(value) : value);
                    this.callBase()
                },
                _valueChangeEventHandler: function(e) {
                    var value = this._input().val();
                    if (value) {
                        value = this._applyColorFromInput(value);
                        if (this._colorView) {
                            this._colorView._setCurrentColor(value);
                            this._colorView._refreshMarkup()
                        }
                    }
                    this.callBase(e, value)
                },
                _applyColorFromInput: function(value) {
                    var newColor = new Color(value);
                    if (newColor.colorIsInvalid) {
                        value = this.option("value");
                        this._input().val(value)
                    }
                    return value
                },
                _optionChanged: function(args) {
                    var value = args.value,
                        name = args.name;
                    switch (name) {
                        case"value":
                            this._$colorBoxInputContainer.toggleClass(COLOR_BOX_COLOR_IS_NOT_DEFINED, !value);
                            if (value)
                                colorUtils.makeTransparentBackground(this._$colorResultPreview, value);
                            else
                                this._$colorResultPreview.removeAttr("style");
                            if (this._colorView)
                                this._colorView.option("value", value);
                            this.callBase(args);
                            break;
                        case"applyButtonText":
                        case"cancelButtonText":
                            this.callBase(args);
                            this._popup && this._addPopupBottomClasses();
                            break;
                        case"editAlphaChannel":
                        case"onCancelButtonClick":
                        case"onApplyButtonClick":
                        case"keyStep":
                            if (this._colorView)
                                this._colorView.option(name, value);
                            break;
                        case"applyValueMode":
                            if (this._colorView)
                                this._colorView.option(name, value);
                            this.callBase(args);
                            break;
                        case"rtlEnabled":
                            if (this._colorView)
                                this._colorView.option(name, value);
                            this.callBase(args);
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        registerComponent("dxColorBox", uiNamespace, ColorBox);
        ColorBox.__internals = {
            COLOR_BOX_CLASS: COLOR_BOX_CLASS,
            COLOR_BOX_INPUT_CLASS: COLOR_BOX_INPUT_CLASS,
            COLOR_BOX_INPUT_CONTAINER_CLASS: COLOR_BOX_INPUT_CONTAINER_CLASS,
            COLOR_BOX_COLOR_RESULT_PREVIEW_CLASS: COLOR_BOX_COLOR_RESULT_PREVIEW_CLASS,
            COLOR_BOX_COLOR_IS_NOT_DEFINED: COLOR_BOX_COLOR_IS_NOT_DEFINED,
            COLOR_BOX_OVERLAY_CLASS: COLOR_BOX_OVERLAY_CLASS
        };
        return ColorBox
    });
    DevExpress.require(["/ui/widgets/ui.colorBox"]);
    /*! Module widgets-base, file ui.form.js */
    (function($, DX) {
        var ui = DX.ui,
            errors = DX.require("/ui/ui.errors"),
            utils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget"),
            ValidationSummary = DX.require("/ui/widgets/ui.validationSummary"),
            ValidationGroup = DX.require("/ui/widgets/ui.validationGroup"),
            FORM_CLASS = "dx-form",
            FIELD_ITEM_CLASS = "dx-field-item",
            FIELD_ITEM_LABEL_TEXT_CLASS = "dx-field-item-label-text",
            FORM_GROUP_CLASS = "dx-form-group",
            FORM_GROUP_CONTENT_CLASS = "dx-form-group-content",
            FORM_GROUP_WITH_CAPTION_CLASS = "dx-form-group-with-caption",
            FORM_GROUP_CAPTION_CLASS = "dx-form-group-caption",
            HIDDEN_LABEL_CLASS = "dx-layout-manager-hidden-label",
            FIELD_ITEM_LABEL_CLASS = "dx-field-item-label",
            FIELD_ITEM_LABEL_CONTENT_CLASS = "dx-field-item-label-content",
            FIELD_ITEM_TAB_CLASS = "dx-field-item-tab",
            FORM_FIELD_ITEM_COL_CLASS = "dx-col-",
            GROUP_COL_COUNT_CLASS = "dx-group-colcount-",
            FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content",
            FORM_VALIDATION_SUMMARY = "dx-form-validation-summary",
            READONLY_STATE_CLASS = "dx-state-readonly",
            WIDGET_CLASS = "dx-widget";
        registerComponent("dxForm", ui, Widget.inherit({
            _init: function() {
                this.callBase();
                this._groupsColCount = []
            },
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        formData: {},
                        colCount: 1,
                        labelLocation: "left",
                        readOnly: false,
                        onFieldDataChanged: null,
                        customizeItem: null,
                        onEditorEnterKey: null,
                        minColWidth: 200,
                        alignItemLabels: true,
                        alignItemLabelsInAllGroups: true,
                        showColonAfterLabel: true,
                        showRequiredMark: true,
                        showOptionalMark: false,
                        requiredMark: "*",
                        optionalMark: Globalize.localize("dxForm-optionalMark"),
                        showValidationSummary: false,
                        items: undefined,
                        scrollingEnabled: false
                    })
            },
            _getColCount: function($element) {
                var index = 0,
                    isFinding = true,
                    $cols;
                while (isFinding) {
                    $cols = $element.find("." + FORM_FIELD_ITEM_COL_CLASS + index);
                    if (!$cols.length)
                        isFinding = false;
                    else
                        index++
                }
                return index
            },
            _createHiddenElement: function(rootLayoutManager) {
                this._$hiddenElement = $("<div/>").addClass(WIDGET_CLASS).addClass(HIDDEN_LABEL_CLASS).appendTo(document.body);
                var $hiddenLabel = rootLayoutManager._renderLabel({
                        text: " ",
                        location: this.option("labelLocation")
                    }).appendTo(this._$hiddenElement);
                this._hiddenLabelText = $hiddenLabel.find("." + FIELD_ITEM_LABEL_TEXT_CLASS).first()
            },
            _removeHiddenElement: function() {
                this._$hiddenElement.remove();
                this._hiddenLabelText = null
            },
            _getLabelWidthByText: function(text) {
                return this._hiddenLabelText.text(text).width()
            },
            _getLabelsSelectorByCol: function(index, options) {
                options = options || {};
                var cssExcludeTabbedSelector = options.excludeTabbed ? ":not(." + FIELD_ITEM_TAB_CLASS + ")" : "";
                return "." + (options.inOneColumn ? FIELD_ITEM_CLASS : FORM_FIELD_ITEM_COL_CLASS + index) + cssExcludeTabbedSelector + "> ." + FIELD_ITEM_LABEL_CLASS + " > ." + FIELD_ITEM_LABEL_CONTENT_CLASS
            },
            _applyLabelsWidthByCol: function($container, index, options) {
                var $labelTexts = $container.find(this._getLabelsSelectorByCol(index, options)),
                    labelWidth,
                    i,
                    maxWidth = 0;
                for (i = 0; i < $labelTexts.length; i++) {
                    labelWidth = this._getLabelWidthByText($labelTexts.eq(i).text());
                    if (labelWidth > maxWidth)
                        maxWidth = labelWidth
                }
                $labelTexts.width(maxWidth)
            },
            _applyLabelsWidth: function($container, excludeTabbed, inOneColumn) {
                var colCount = inOneColumn ? 1 : this._getColCount($container),
                    applyLabelsOptions = {
                        excludeTabbed: excludeTabbed,
                        inOneColumn: inOneColumn
                    },
                    i;
                for (i = 0; i < colCount; i++)
                    this._applyLabelsWidthByCol($container, i, applyLabelsOptions)
            },
            _getGroupElementsInColumn: function($container, columnIndex, colCount) {
                var cssColCountSelector = utils.isDefined(colCount) ? "." + GROUP_COL_COUNT_CLASS + colCount : "";
                return $container.find("." + FORM_FIELD_ITEM_COL_CLASS + columnIndex + " > ." + FIELD_ITEM_CONTENT_CLASS + " > ." + FORM_GROUP_CLASS + cssColCountSelector)
            },
            _applyLabelsWidthWithGroups: function($container, colCount, excludeTabbed) {
                var alignItemLabelsInAllGroups = this.option("alignItemLabelsInAllGroups"),
                    i,
                    j,
                    $groups,
                    applyLabelsOptions = {excludeTabbed: excludeTabbed},
                    groupColCount,
                    $groupsByCol;
                if (alignItemLabelsInAllGroups)
                    for (i = 0; i < colCount; i++) {
                        $groupsByCol = this._getGroupElementsInColumn($container, i);
                        this._applyLabelsWidthByCol($groupsByCol, 0, applyLabelsOptions);
                        for (j = 0; j < this._groupsColCount.length; j++) {
                            $groupsByCol = this._getGroupElementsInColumn($container, i, this._groupsColCount[j]);
                            groupColCount = this._getColCount($groupsByCol);
                            for (var k = 1; k < groupColCount; k++)
                                this._applyLabelsWidthByCol($groupsByCol, k, applyLabelsOptions)
                        }
                    }
                else {
                    $groups = this.element().find("." + FORM_GROUP_CLASS);
                    for (i = 0; i < $groups.length; i++)
                        this._applyLabelsWidth($groups.eq(i), excludeTabbed)
                }
            },
            _alignLabelsInColumn: function(options) {
                this._createHiddenElement(options.layoutManager);
                if (options.inOneColumn)
                    this._applyLabelsWidth(options.$container, options.excludeTabbed, true);
                else if (this._checkGrouping(options.items))
                    this._applyLabelsWidthWithGroups(options.$container, options.layoutManager._getColCount(), options.excludeTabbed);
                else
                    this._applyLabelsWidth(options.$container, options.excludeTabbed);
                this._removeHiddenElement()
            },
            _render: function() {
                this._clearEditorInstances();
                this.callBase();
                this.element().addClass(FORM_CLASS);
                this._toggleReadOnlyState()
            },
            _clearEditorInstances: function() {
                this._editorInstancesByField = {}
            },
            _alignLabels: function(layoutManager, inOneColumn) {
                this._alignLabelsInColumn({
                    $container: this.element(),
                    layoutManager: layoutManager,
                    excludeTabbed: true,
                    items: this.option("items"),
                    inOneColumn: inOneColumn
                })
            },
            _clean: function() {
                this.callBase();
                this._groupsColCount = []
            },
            _renderContentImpl: function() {
                this.callBase();
                this._renderForm();
                this._renderValidationGroup();
                if (this.option("scrollingEnabled"))
                    this._renderScrollable();
                this._renderLayout();
                this._renderValidationSummary()
            },
            _renderScrollable: function() {
                var useNativeScrolling = this.option("useNativeScrolling");
                this._scrollable = this._$form.dxScrollable({
                    useNative: !!useNativeScrolling,
                    useSimulatedScrollbar: !useNativeScrolling,
                    useKeyboard: false,
                    direction: "both",
                    bounceEnabled: false
                }).data("dxScrollable")
            },
            _getContent: function() {
                return this.option("scrollingEnabled") ? this._scrollable.content() : this._$form
            },
            _renderForm: function() {
                this._$form = $("<form>").appendTo(this.element());
                this.setAria("role", "form")
            },
            _renderValidationGroup: function() {
                this._$form.dxValidationGroup()
            },
            _renderValidationSummary: function() {
                var that = this,
                    $validationSummary = that._$form.find("." + FORM_VALIDATION_SUMMARY);
                if ($validationSummary.length > 0)
                    $validationSummary.remove();
                if (this.option("showValidationSummary"))
                    $("<div/>").addClass(FORM_VALIDATION_SUMMARY).dxValidationSummary({validationGroup: that}).appendTo(that._getContent())
            },
            _prepareItems: function(items, isTabbed) {
                if (items) {
                    var that = this,
                        extendedItems = [],
                        i,
                        item,
                        clonedItem;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        clonedItem = utils.isObject(item) ? $.extend({}, item) : item;
                        that._prepareGroupItem(clonedItem);
                        that._prepareTabbedItem(clonedItem);
                        that._prepareItemTemplate(clonedItem);
                        if (utils.isObject(clonedItem)) {
                            if (isTabbed)
                                clonedItem.cssItemClass = FIELD_ITEM_TAB_CLASS;
                            clonedItem.items = this._prepareItems(clonedItem.items, isTabbed)
                        }
                        extendedItems.push(clonedItem)
                    }
                    return extendedItems
                }
            },
            _prepareGroupItem: function(item) {
                if (item.itemType === "group") {
                    item.alignItemLabels = utils.ensureDefined(item.alignItemLabels, true);
                    if (item.template)
                        item.groupContentTemplate = this._getTemplate(item.template);
                    item.template = $.proxy(this._itemGroupTemplate, this, item)
                }
            },
            _prepareTabbedItem: function(item) {
                if (item.itemType === "tabbed") {
                    item.template = $.proxy(this._itemTabbedTemplate, this, item);
                    item.tabs = this._prepareItems(item.tabs, true)
                }
            },
            _prepareItemTemplate: function(item) {
                if (item.template)
                    item.template = this._getTemplate(item.template)
            },
            _checkGrouping: function(items) {
                if (items)
                    for (var i = 0; i < items.length; i++) {
                        var item = items[i];
                        if (item.itemType === "group")
                            return true
                    }
            },
            _renderLayout: function() {
                var that = this,
                    items = that.option("items"),
                    $content = that._getContent();
                items = that._prepareItems(items);
                that._testResultItems = items;
                that._rootLayoutManager = that._renderLayoutManager(items, $content, {
                    colCount: that.option("colCount"),
                    width: this.option("width"),
                    alignItemLabels: that.option("alignItemLabels"),
                    onLayoutChanged: function(inOneColumn) {
                        $.proxy(that._alignLabels, that)(that._rootLayoutManager, inOneColumn)
                    },
                    onContentReady: function(e) {
                        that._alignLabels(e.component, e.component.isLayoutChanged())
                    }
                })
            },
            _itemTabbedTemplate: function(item, e, $container) {
                var that = this,
                    tabPanelOptions = $.extend({}, item.tabPanelOptions, {
                        dataSource: item.tabs,
                        itemTemplate: function(itemData) {
                            var $layoutManager = $("<div/>"),
                                layoutManager,
                                alignItemLabels = utils.ensureDefined(itemData.alignItemLabels, true);
                            layoutManager = that._renderLayoutManager(itemData.items, $layoutManager, {
                                colCount: itemData.colCount,
                                alignItemLabels: alignItemLabels,
                                cssItemClass: itemData.cssItemClass,
                                onLayoutChanged: function(inOneColumn) {
                                    $.proxy(that._alignLabelsInColumn, that)({
                                        $container: $layoutManager,
                                        layoutManager: layoutManager,
                                        items: itemData.items,
                                        inOneColumn: inOneColumn
                                    })
                                }
                            });
                            if (alignItemLabels)
                                $.proxy(that._alignLabelsInColumn, that)({
                                    $container: $layoutManager,
                                    layoutManager: layoutManager,
                                    items: itemData.items,
                                    inOneColumn: layoutManager.isLayoutChanged()
                                });
                            return $layoutManager
                        }
                    });
                $("<div/>").appendTo($container).dxTabPanel(tabPanelOptions)
            },
            _itemGroupTemplate: function(item, e, $container) {
                var $group = $("<div/>").appendTo($container).toggleClass(FORM_GROUP_WITH_CAPTION_CLASS, utils.isDefined(item.caption) && item.caption.length).addClass(FORM_GROUP_CLASS),
                    $groupContent,
                    colCount,
                    layoutManager;
                if (item.caption)
                    $("<span/>").addClass(FORM_GROUP_CAPTION_CLASS).text(item.caption).appendTo($group);
                $groupContent = $("<div/>").addClass(FORM_GROUP_CONTENT_CLASS).appendTo($group);
                if (item.groupContentTemplate) {
                    var data = {
                            formData: this.option("formData"),
                            component: this
                        };
                    item.groupContentTemplate.render(data, $groupContent)
                }
                else {
                    layoutManager = this._renderLayoutManager(item.items, $groupContent, {
                        colCount: item.colCount,
                        alignItemLabels: item.alignItemLabels,
                        cssItemClass: item.cssItemClass
                    });
                    colCount = layoutManager._getColCount();
                    if ($.inArray(colCount, this._groupsColCount) === -1)
                        this._groupsColCount.push(colCount);
                    $group.addClass(GROUP_COL_COUNT_CLASS + colCount)
                }
            },
            _renderLayoutManager: function(items, $rootElement, options) {
                var $element = $("<div />"),
                    that = this,
                    config = $.extend({
                        items: items,
                        showRequiredMark: this.option("showRequiredMark"),
                        showOptionalMark: this.option("showOptionalMark"),
                        requiredMark: this.option("requiredMark"),
                        optionalMark: this.option("optionalMark"),
                        form: that,
                        layoutData: this.option("formData"),
                        labelLocation: this.option("labelLocation"),
                        customizeItem: this.option("customizeItem"),
                        minColWidth: this.option("minColWidth"),
                        showColonAfterLabel: this.option("showColonAfterLabel"),
                        onEditorEnterKey: this.option("onEditorEnterKey"),
                        onContentReady: function(args) {
                            that._updateEditorInstancesFromLayoutManager(args.component._editorInstancesByField);
                            options.onContentReady && options.onContentReady(args)
                        },
                        onFieldDataChanged: function(args) {
                            that._updateFieldValue(args.dataField, args.value)
                        }
                    }, {
                        colCount: options.colCount,
                        alignItemLabels: options.alignItemLabels,
                        cssItemClass: options.cssItemClass,
                        onLayoutChanged: options.onLayoutChanged,
                        width: options.width
                    });
                $element.appendTo($rootElement);
                return that._createComponent($element, "dxLayoutManager", config)
            },
            _updateEditorInstancesFromLayoutManager: function(instancesByDataFields) {
                $.extend(this._editorInstancesByField, instancesByDataFields)
            },
            _createComponent: function($element, type, config) {
                var that = this,
                    instance;
                config = config || {};
                that._extendConfig(config, {readOnly: that.option("readOnly")});
                instance = that.callBase($element, type, config);
                that._attachSyncSubscriptions(instance);
                return instance
            },
            _attachSyncSubscriptions: function(instance) {
                this.on("optionChanged", function(args) {
                    var formDataFieldStart = "formData.";
                    if (args.fullName.search(formDataFieldStart) === 0) {
                        var layoutDataField = args.fullName.replace(formDataFieldStart, "layoutData.");
                        instance.option(layoutDataField, args.value)
                    }
                    if (args.name === "readOnly")
                        instance.option(args.fullName, args.value)
                })
            },
            _toggleReadOnlyState: function(state) {
                this.element().toggleClass(READONLY_STATE_CLASS, state || this.option("readOnly"))
            },
            _optionChanged: function(args) {
                var rootNameOfComplexOption = this._getRootLevelOfExpectedComplexOption(args.fullName, ["formData", "items"]);
                if (rootNameOfComplexOption) {
                    this._customHandlerOfComplexOption(args, rootNameOfComplexOption);
                    return
                }
                switch (args.name) {
                    case"formData":
                        this._options[args.name] = args.value;
                        this._triggerOnFieldDataChangedByDataSet(args.value);
                        this._invalidate();
                        break;
                    case"items":
                    case"colCount":
                    case"onFieldDataChanged":
                    case"onEditorEnterKey":
                    case"labelLocation":
                    case"alignItemLabels":
                    case"showColonAfterLabel":
                    case"customizeItem":
                    case"alignItemLabelsInAllGroups":
                    case"showRequiredMark":
                    case"showOptionalMark":
                    case"requiredMark":
                    case"optionalMark":
                    case"scrollingEnabled":
                        this._invalidate();
                        break;
                    case"showValidationSummary":
                        this._renderValidationSummary();
                        break;
                    case"minColWidth":
                        if (this.option("colCount") === "auto")
                            this._invalidate();
                        break;
                    case"readOnly":
                        this._toggleReadOnlyState(args.value);
                        break;
                    case"width":
                        this.callBase(args);
                        this._rootLayoutManager.option(args.name, args.value);
                        this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isLayoutChanged());
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _getRootLevelOfExpectedComplexOption: function(fullOptionName, expextedRootNames) {
                var splittedFullName = fullOptionName.split("."),
                    result;
                if (splittedFullName.length > 1) {
                    var i,
                        rootOptionName = splittedFullName[0];
                    for (i = 0; i < expextedRootNames.length; i++)
                        if (rootOptionName.search(expextedRootNames[i]) !== -1)
                            result = expextedRootNames[i]
                }
                return result
            },
            _customHandlerOfComplexOption: function(args, rootOptionName) {
                var nameParts = args.fullName.split(".");
                switch (rootOptionName) {
                    case"items":
                        if (args.fullName.search("editorOptions") !== -1) {
                            var itemPath = this._getItemPath(nameParts),
                                item = this.option(itemPath),
                                instance = this.getEditor(item.dataField);
                            instance && instance.option(item.editorOptions)
                        }
                        break;
                    case"formData":
                        this._triggerOnFieldDataChanged({
                            dataField: nameParts[nameParts.length - 1],
                            value: args.value
                        });
                        break
                }
            },
            _getItemPath: function(nameParts) {
                var itemPath = nameParts[0],
                    i;
                for (i = 1; i < nameParts.length; i++)
                    if (nameParts[i].search("items") !== -1)
                        itemPath += "." + nameParts[i];
                    else
                        break;
                return itemPath
            },
            _triggerOnFieldDataChanged: function(args) {
                this._createActionByOption("onFieldDataChanged")(args)
            },
            _triggerOnFieldDataChangedByDataSet: function(data) {
                var that = this;
                if (data && utils.isObject(data))
                    $.each(data, function(dataField, value) {
                        that._triggerOnFieldDataChanged({
                            dataField: dataField,
                            value: value
                        })
                    })
            },
            _updateFieldValue: function(dataField, value) {
                this.option("formData." + dataField, value)
            },
            _generateItemsFromData: function(items) {
                var formData = this.option("formData"),
                    result = [];
                if (utils.isDefined(formData))
                    $.each(formData, function(dataField, value) {
                        if (!items || items && $.inArray(dataField, items) > -1)
                            result.push({dataField: dataField})
                    });
                if (items)
                    $.each(items, function(index, item) {
                        if (utils.isObject(item))
                            result.push(item)
                    });
                return result
            },
            _getItemByField: function(field, items) {
                var that = this,
                    fieldParts = utils.isObject(field) ? field : that._getFieldParts(field),
                    fieldName = fieldParts.fieldName,
                    fieldPath = fieldParts.fieldPath,
                    resultItem;
                if (items.length)
                    $.each(items, function(index, item) {
                        var itemType = item.itemType;
                        if (fieldPath.length) {
                            var path = fieldPath.slice();
                            item = that._getItemByFieldPath(path, fieldName, item)
                        }
                        else if (itemType === "group" && !item.caption) {
                            item.items = that._generateItemsFromData(item.items);
                            item = that._getItemByField({
                                fieldName: fieldName,
                                fieldPath: fieldPath
                            }, item.items)
                        }
                        if (item && (item.dataField === fieldName || item.name === fieldName || item.itemType === "group" && that._getTextWithoutSpaces(item.caption) === fieldName || that._getTextWithoutSpaces(item.title) === fieldName)) {
                            resultItem = item;
                            return false
                        }
                    });
                return resultItem
            },
            _getFieldParts: function(field) {
                var fieldSeparator = ".",
                    fieldName = field,
                    separatorIndex = fieldName.indexOf(fieldSeparator),
                    resultPath = [];
                while (separatorIndex !== -1) {
                    resultPath.push(fieldName.substr(0, separatorIndex));
                    fieldName = fieldName.substr(separatorIndex + 1);
                    separatorIndex = fieldName.indexOf(fieldSeparator)
                }
                return {
                        fieldName: fieldName,
                        fieldPath: resultPath.reverse()
                    }
            },
            _getItemByFieldPath: function(path, fieldName, item) {
                var that = this,
                    itemType = item.itemType,
                    subItemsField = that._getSubItemField(itemType),
                    isItemWithSubItems = itemType === "group" || itemType === "tabbed" || item.title,
                    result;
                do
                    if (isItemWithSubItems) {
                        var isGroupWithCaption = utils.isDefined(item.caption || item.title),
                            captionWithoutSpaces = that._getTextWithoutSpaces(item.caption || item.title),
                            pathNode;
                        item[subItemsField] = that._generateItemsFromData(item[subItemsField]);
                        if (isGroupWithCaption)
                            pathNode = path.pop();
                        if (!path.length) {
                            result = that._getItemByField(fieldName, item[subItemsField]);
                            if (result)
                                break
                        }
                        if (!isGroupWithCaption || isGroupWithCaption && captionWithoutSpaces === pathNode)
                            if (path.length)
                                result = that._searchItemInEverySubitem(path, fieldName, item[subItemsField])
                    }
                    else
                        break;
                while (path.length);
                return result
            },
            _getSubItemField: function(itemType) {
                return itemType === "tabbed" ? "tabs" : "items"
            },
            _searchItemInEverySubitem: function(path, fieldName, items) {
                var that = this,
                    result;
                $.each(items, function(index, groupItem) {
                    result = that._getItemByFieldPath(path, fieldName, groupItem);
                    if (result)
                        return false
                });
                return result
            },
            _getTextWithoutSpaces: function(text) {
                return text ? text.replace(" ", "") : undefined
            },
            _changeItemOption: function(item, option, value) {
                if (utils.isObject(item))
                    item[option] = value
            },
            _dimensionChanged: function() {
                if (this.option("colCount") === "auto")
                    this._refresh()
            },
            updateData: function(data, value) {
                var that = this;
                if (utils.isObject(data))
                    $.each(data, function(dataField, fieldValue) {
                        that._updateFieldValue(dataField, fieldValue)
                    });
                else if (typeof data === "string")
                    that._updateFieldValue(data, value)
            },
            getEditor: function(field) {
                return this._editorInstancesByField[field]
            },
            updateDimensions: function() {
                var that = this,
                    deferred = $.Deferred();
                if (that._scrollable)
                    that._scrollable.update().done(function() {
                        deferred.resolveWith(that)
                    });
                else
                    deferred.resolveWith(that);
                return deferred.promise()
            },
            itemOption: function(field, option, value) {
                var that = this,
                    argsCount = arguments.length,
                    items = that._generateItemsFromData(that.option("items")),
                    item = that._getItemByField(field, items);
                if (argsCount === 1)
                    return item;
                else {
                    if (argsCount === 3)
                        that._changeItemOption(item, option, value);
                    else if (utils.isObject(option))
                        $.each(option, function(optionName, optionValue) {
                            that._changeItemOption(item, optionName, optionValue)
                        });
                    this.option("items", items)
                }
            },
            validate: function() {
                try {
                    return DX.validationEngine.validateGroup(this)
                }
                catch(e) {
                    errors.log("E1036", e.message)
                }
            }
        }));
        ui.dxForm.__internals = {
            FORM_CLASS: FORM_CLASS,
            FORM_GROUP_CLASS: FORM_GROUP_CLASS,
            FORM_GROUP_CAPTION_CLASS: FORM_GROUP_CAPTION_CLASS,
            READONLY_STATE_CLASS: READONLY_STATE_CLASS,
            FORM_FIELD_ITEM_COL_CLASS: FORM_FIELD_ITEM_COL_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-base, file ui.form.layoutManager.js */
    (function($, DX) {
        var ui = DX.ui,
            normalizeIndexes = DX.require("/utils/utils.array").normalizeIndexes,
            errors = DX.require("/ui/ui.errors"),
            inflector = DX.require("/utils/utils.inflector"),
            utils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget"),
            Validator = DX.require("/ui/widgets/ui.validator"),
            FORM_EDITOR_BY_DEFAULT = "dxTextBox",
            FIELD_ITEM_CLASS = "dx-field-item",
            FIELD_EMPTY_ITEM_CLASS = "dx-field-empty-item",
            FIELD_ITEM_REQUIRED_CLASS = "dx-field-item-required",
            FIELD_ITEM_OPTIONAL_CLASS = "dx-field-item-optional",
            FIELD_ITEM_REQUIRED_MARK_CLASS = "dx-field-item-required-mark",
            FIELD_ITEM_OPTIONAL_MARK_CLASS = "dx-field-item-optional-mark",
            FIELD_ITEM_LABEL_CLASS = "dx-field-item-label",
            FIELD_ITEM_LABEL_BASELINE_CLASS = "dx-field-item-label-baseline",
            FIELD_ITEM_LABEL_CONTENT_CLASS = "dx-field-item-label-content",
            FIELD_ITEM_LABEL_TEXT_CLASS = "dx-field-item-label-text",
            FIELD_ITEM_LABEL_LOCATION_CLASS = "dx-field-item-label-location-",
            FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content",
            FIELD_ITEM_CONTENT_LOCATION_CLASS = "dx-field-item-content-location-",
            FIELD_ITEM_CONTENT_WRAPPER_CLASS = "dx-field-item-content-wrapper",
            FIELD_ITEM_HELP_TEXT_CLASS = "dx-field-item-help-text",
            FORM_LAYOUT_MANAGER_CLASS = "dx-layout-manager",
            LABEL_HORIZONTAL_ALIGNMENT_CLASS = "dx-label-h-align",
            LABEL_VERTICAL_ALIGNMENT_CLASS = "dx-label-v-align",
            LAYOUT_MANAGER_FIRST_ROW_CLASS = "dx-first-row",
            LAYOUT_MANAGER_FIRST_COL_CLASS = "dx-first-col",
            LAYOUT_MANAGER_LAST_COL_CLASS = "dx-last-col",
            LAYOUT_MANAGER_ONE_COLUMN = "dx-layout-manager-one-col",
            READONLY_STATE_CLASS = "dx-state-readonly";
        registerComponent("dxLayoutManager", ui.dxForm, Widget.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        layoutData: {},
                        readOnly: false,
                        colCount: 1,
                        labelLocation: "left",
                        onFieldDataChanged: null,
                        onEditorEnterKey: null,
                        customizeItem: null,
                        alignItemLabels: true,
                        minColWidth: 200,
                        showRequiredMark: true,
                        showOptionalMark: false,
                        requiredMark: "*",
                        optionalMark: Globalize.localize("dxForm-optionalMark")
                    })
            },
            _init: function() {
                this.callBase();
                this._syncDataWithItems();
                this._updateItems(this.option("layoutData"))
            },
            _syncDataWithItems: function() {
                var that = this,
                    userItems = that.option("items");
                if (utils.isDefined(userItems))
                    $.each(userItems, function(index, item) {
                        var value;
                        if (item.dataField && that._getDataByField(item.dataField) === undefined) {
                            if (item.editorOptions)
                                value = item.editorOptions.value;
                            that._updateFieldValue(item.dataField, value)
                        }
                    })
            },
            _getDataByField: function(dataField) {
                return dataField ? this.option("layoutData." + dataField) : null
            },
            _updateFieldValue: function(dataField, value) {
                if (utils.isDefined(dataField)) {
                    this.option("layoutData." + dataField, value);
                    this._triggerOnFieldDataChanged({
                        dataField: dataField,
                        value: value
                    })
                }
            },
            _triggerOnFieldDataChanged: function(args) {
                this._createActionByOption("onFieldDataChanged")(args)
            },
            _updateItems: function(layoutData) {
                var that = this,
                    userItems = this.option("items"),
                    customizeItem = that.option("customizeItem"),
                    items,
                    visibleItems;
                items = utils.isDefined(userItems) ? userItems : this._generateItemsByData(layoutData);
                if (utils.isDefined(items)) {
                    visibleItems = [];
                    $.each(items, function(index, item) {
                        if (typeof item === "string")
                            item = {dataField: item};
                        if (typeof item === "object" && !item.itemType)
                            item.itemType = "simple";
                        if (!utils.isDefined(item.editorType) && utils.isDefined(item.dataField)) {
                            var value = that._getDataByField(item.dataField);
                            item.editorType = utils.isDefined(value) ? that._getEditorTypeByDataType($.type(value)) : FORM_EDITOR_BY_DEFAULT
                        }
                        customizeItem && customizeItem(item);
                        var isItemVisibleDefined = utils.isDefined(item.visible);
                        if (utils.isObject(item) && !isItemVisibleDefined || isItemVisibleDefined && item.visible)
                            visibleItems.push(item)
                    });
                    this._items = visibleItems;
                    this._sortItems()
                }
            },
            _generateItemsByData: function(layoutData) {
                var result = [];
                if (utils.isDefined(layoutData))
                    $.each(layoutData, function(dataField, value) {
                        result.push({dataField: dataField})
                    });
                return result
            },
            _getEditorTypeByDataType: function(dataType) {
                switch (dataType) {
                    case"number":
                        return "dxNumberBox";
                    case"date":
                        return "dxDateBox";
                    case"boolean":
                        return "dxCheckBox";
                    default:
                        return "dxTextBox"
                }
            },
            _sortItems: function() {
                normalizeIndexes(this._items, "visibleIndex");
                this._sortIndexes()
            },
            _sortIndexes: function() {
                this._items.sort(function(itemA, itemB) {
                    var indexA = itemA.visibleIndex,
                        indexB = itemB.visibleIndex,
                        result;
                    if (indexA > indexB)
                        result = 1;
                    else if (indexA < indexB)
                        result = -1;
                    else
                        result = 0;
                    return result
                })
            },
            _render: function() {
                this._clearEditorInstances();
                this.element().addClass(FORM_LAYOUT_MANAGER_CLASS);
                this.callBase();
                this._toggleReadOnlyState()
            },
            _clearEditorInstances: function() {
                this._editorInstancesByField = {}
            },
            _renderContentImpl: function() {
                this.callBase();
                this._renderResponsiveBox()
            },
            _renderResponsiveBox: function() {
                var that = this,
                    colCount = that._getColCount(),
                    layoutItems;
                if (that._items && that._items.length) {
                    that._prepareItemsWithMerging(colCount);
                    layoutItems = that._generateLayoutItems();
                    that._responsiveBox = $("<div />").appendTo(that.element()).dxResponsiveBox({
                        onLayoutChanged: function() {
                            var onLayoutChanged = that.option("onLayoutChanged"),
                                isLayoutChanged = that.isLayoutChanged();
                            if (onLayoutChanged) {
                                that.element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, isLayoutChanged);
                                onLayoutChanged(isLayoutChanged)
                            }
                        },
                        onContentReady: function(e) {
                            if (that.option("onLayoutChanged"))
                                that.element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, that.isLayoutChanged(e.component));
                            that._fireContentReadyAction()
                        },
                        itemTemplate: function(e, itemData, $itemElement) {
                            if (!e.location)
                                return;
                            var itemRenderedCountInPreviousRows = e.location.row * colCount,
                                item = that._items[e.location.col + itemRenderedCountInPreviousRows],
                                $fieldItem = $("<div/>").addClass(item.cssClass).appendTo($itemElement);
                            if (e.location.row === 0)
                                $fieldItem.addClass(LAYOUT_MANAGER_FIRST_ROW_CLASS);
                            if (e.location.col === 0)
                                $fieldItem.addClass(LAYOUT_MANAGER_FIRST_COL_CLASS);
                            if (e.location.col === colCount - 1 || e.location.col + e.location.colspan === colCount)
                                $fieldItem.addClass(LAYOUT_MANAGER_LAST_COL_CLASS);
                            item.itemType === "empty" ? that._renderEmptyItem($fieldItem) : that._renderFieldItem(item, $fieldItem)
                        },
                        cols: that._generateRatio(colCount),
                        rows: that._generateRatio(that._getRowsCount(), true),
                        dataSource: layoutItems
                    }).data("dxResponsiveBox")
                }
            },
            _getColCount: function() {
                var colCount = this.option("colCount");
                if (colCount === "auto") {
                    if (!!this._cashedColCount)
                        return this._cashedColCount;
                    var minColWidth = this.option("minColWidth"),
                        width = this.element().width(),
                        itemsCount = this._items.length,
                        maxColCount = Math.floor(width / minColWidth) || 1;
                    this._cashedColCount = colCount = itemsCount < maxColCount ? itemsCount : maxColCount
                }
                return colCount < 1 ? 1 : colCount
            },
            _prepareItemsWithMerging: function(colCount) {
                var items = this._items.slice(0),
                    item,
                    itemsMergedByCol,
                    result = [],
                    j,
                    i;
                for (i = 0; i < items.length; i++) {
                    item = items[i];
                    result.push(item);
                    if (this.option("alignItemLabels") || item.alignItemLabels || item.colSpan)
                        item.col = this._getColByIndex(result.length - 1, colCount);
                    if (item.colSpan > 1 && item.col + item.colSpan <= colCount) {
                        itemsMergedByCol = [];
                        for (j = 0; j < item.colSpan - 1; j++)
                            itemsMergedByCol.push({merged: true});
                        result = result.concat(itemsMergedByCol)
                    }
                    else
                        delete item.colSpan
                }
                this._items = result
            },
            _getColByIndex: function(index, colCount) {
                return index % colCount
            },
            _generateLayoutItems: function() {
                var items = this._items,
                    colCount = this._getColCount(),
                    result = [],
                    item,
                    i;
                for (i = 0; i < items.length; i++) {
                    item = items[i];
                    if (!item.merged) {
                        var generatedItem = {location: {
                                    row: parseInt(i / colCount),
                                    col: this._getColByIndex(i, colCount)
                                }};
                        if (utils.isDefined(item.colSpan))
                            generatedItem.location.colspan = item.colSpan;
                        if (utils.isDefined(item.rowSpan))
                            generatedItem.location.rowspan = item.rowSpan;
                        result.push(generatedItem)
                    }
                }
                return result
            },
            _renderEmptyItem: function($container) {
                return $container.addClass(FIELD_EMPTY_ITEM_CLASS).html("&nbsp;")
            },
            _renderFieldItem: function(item, $container) {
                var name = this._getName(item),
                    id = name || new DX.data.Guid,
                    isRequired = utils.isDefined(item.isRequired) ? item.isRequired : !!item.validationRules,
                    labelOptions = $.extend({
                        showColon: this.option("showColonAfterLabel"),
                        location: this.option("labelLocation"),
                        id: id,
                        visible: true,
                        isRequired: isRequired,
                        hasBaselineAlign: this._isLabelNeedBaselineAlign(item)
                    }, item ? item.label : {}),
                    $editor = $("<div/>"),
                    $label,
                    helpID;
                $container.addClass(FIELD_ITEM_CLASS).addClass(isRequired ? FIELD_ITEM_REQUIRED_CLASS : FIELD_ITEM_OPTIONAL_CLASS).addClass(this.option("cssItemClass")).addClass(utils.isDefined(item.col) ? "dx-col-" + item.col : "");
                this._prepareLabelOptions(item.dataField, labelOptions);
                if (labelOptions.visible && labelOptions.text) {
                    $label = this._renderLabel(labelOptions);
                    $label.appendTo($container)
                }
                if (item.helpText)
                    helpID = new DX.data.Guid;
                this._appendEditorToField({
                    $fieldItem: $container,
                    $label: $label,
                    $editor: $editor,
                    labelOptions: labelOptions
                });
                this._renderEditor({
                    $container: $editor,
                    dataField: name,
                    editorType: item.editorType,
                    editorOptions: item.editorOptions,
                    template: this._getTemplateByFieldItem(item),
                    isRequired: isRequired,
                    helpID: helpID,
                    id: id
                });
                this._renderValidator($editor.children().first(), item);
                this._renderHelpText(item, $editor, helpID);
                this._attachClickHandler($label, $editor, item.editorType)
            },
            _getName: function(item) {
                return item.dataField || item.name
            },
            _isLabelNeedBaselineAlign: function(item) {
                var largeEditors = ["dxTextArea", "dxRadioGroup", "dxCalendar"];
                return !!item.helpText || $.inArray(item.editorType, largeEditors) !== -1
            },
            _prepareLabelOptions: function(dataField, options) {
                if (!options.text && dataField)
                    options.text = inflector.captionize(dataField);
                if (options.text)
                    options.text += options.showColon ? ":" : ""
            },
            _renderLabel: function(options) {
                if (utils.isDefined(options.text) && options.text.length > 0) {
                    var labelClasses = FIELD_ITEM_LABEL_CLASS + " " + FIELD_ITEM_LABEL_LOCATION_CLASS + options.location,
                        $label = $("<label />").addClass(labelClasses).attr("for", options.id),
                        $labelContent = $("<span/>").addClass(FIELD_ITEM_LABEL_CONTENT_CLASS).appendTo($label);
                    $("<span />").addClass(FIELD_ITEM_LABEL_TEXT_CLASS).text(options.text).appendTo($labelContent);
                    if (options.alignment)
                        $label.css("text-align", options.alignment);
                    if (options.location !== "top")
                        this._toggleBaselineLabelAlignment(options.hasBaselineAlign, $label);
                    $labelContent.append(this._renderLabelMark(options.isRequired));
                    return $label
                }
            },
            _toggleBaselineLabelAlignment: function(hasBaselineAlign, $label) {
                if (hasBaselineAlign)
                    $label.addClass(FIELD_ITEM_LABEL_BASELINE_CLASS)
            },
            _renderLabelMark: function(isRequired) {
                var $mark,
                    requiredMarksConfig = this._getRequiredMarksConfig(),
                    isRequiredMark = requiredMarksConfig.showRequiredMark && isRequired,
                    isOptionalMark = requiredMarksConfig.showOptionalMark && !isRequired;
                if (isRequiredMark || isOptionalMark) {
                    var markClass = isRequiredMark ? FIELD_ITEM_REQUIRED_MARK_CLASS : FIELD_ITEM_OPTIONAL_MARK_CLASS,
                        markText = isRequiredMark ? requiredMarksConfig.requiredMark : requiredMarksConfig.optionalMark;
                    $mark = $("<span />").addClass(markClass).html("&nbsp" + markText)
                }
                return $mark
            },
            _getRequiredMarksConfig: function() {
                if (!this._cashedRequiredConfig)
                    this._cashedRequiredConfig = {
                        showRequiredMark: this.option("showRequiredMark"),
                        showOptionalMark: this.option("showOptionalMark"),
                        requiredMark: this.option("requiredMark"),
                        optionalMark: this.option("optionalMark")
                    };
                return this._cashedRequiredConfig
            },
            _renderEditor: function(options) {
                var dataValue = this._getDataByField(options.dataField),
                    defaultEditorOptions = options.editorType === "dxTagBox" ? {values: dataValue || []} : {value: dataValue},
                    editorOptions;
                editorOptions = $.extend(defaultEditorOptions, options.editorOptions, {attr: {id: options.id}});
                this._createEditor(options.$container, {
                    editorType: options.editorType,
                    dataField: options.dataField,
                    template: options.template,
                    name: options.name,
                    helpID: options.helpID,
                    isRequired: options.isRequired
                }, editorOptions)
            },
            _renderValidator: function($editor, item) {
                var fieldName = this._getFieldLabelName(item),
                    validationRules = this._prepareValidationRules(item.validationRules, item.isRequired, item.itemType, fieldName);
                if (utils.isArray(validationRules))
                    this._createComponent($editor, Validator, {
                        validationRules: validationRules,
                        validationGroup: this.option("form")
                    })
            },
            _getFieldLabelName: function(item) {
                var isItemHaveCustomLabel = item.label && item.label.text,
                    itemName = isItemHaveCustomLabel ? null : this._getName(item);
                return isItemHaveCustomLabel ? item.label.text : itemName && inflector.captionize(itemName)
            },
            _prepareValidationRules: function(userValidationRules, isItemRequired, itemType, itemName) {
                var isSimpleItem = itemType === "simple",
                    validationRules;
                if (isSimpleItem)
                    if (userValidationRules)
                        validationRules = userValidationRules;
                    else
                        validationRules = isItemRequired ? [{
                                type: "required",
                                message: itemName + " is required"
                            }] : null;
                return validationRules
            },
            _createEditor: function($container, renderOptions, editorOptions) {
                var that = this,
                    template = renderOptions.template,
                    editorInstance;
                that._addItemContentClasses($container);
                if (template) {
                    var data = {
                            dataField: renderOptions.dataField,
                            editorOptions: editorOptions,
                            component: template.owner()
                        };
                    template.render(data, $container)
                }
                else {
                    var $editor = $("<div/>").appendTo($container);
                    try {
                        editorInstance = that._createComponent($editor, renderOptions.editorType, editorOptions);
                        editorInstance.setAria("describedby", renderOptions.helpID);
                        editorInstance.setAria("required", renderOptions.isRequired);
                        if (renderOptions.dataField) {
                            editorInstance.on("enterKey", function(args) {
                                that._createActionByOption("onEditorEnterKey")($.extend(args, {dataField: renderOptions.dataField}))
                            });
                            that._registerEditorInstance(editorInstance, renderOptions.dataField);
                            that.linkEditorToDataField(editorInstance, renderOptions.dataField, renderOptions.editorType)
                        }
                    }
                    catch(e) {
                        errors.log("E1035", e.message)
                    }
                }
            },
            _addItemContentClasses: function($itemContent) {
                var locationSpecificClass = this._getItemContentLocationSpecificClass();
                $itemContent.addClass([FIELD_ITEM_CONTENT_CLASS, locationSpecificClass].join(" "))
            },
            _getItemContentLocationSpecificClass: function() {
                var labelLocation = this.option("labelLocation"),
                    oppositeClasses = {
                        right: "left",
                        left: "right",
                        top: "bottom"
                    };
                return FIELD_ITEM_CONTENT_LOCATION_CLASS + oppositeClasses[labelLocation]
            },
            _registerEditorInstance: function(instance, dataField) {
                this._editorInstancesByField[dataField] = instance
            },
            _createComponent: function($editor, type, editorOptions) {
                var that = this,
                    readOnlyState = this.option("readOnly"),
                    instance;
                instance = that.callBase($editor, type, editorOptions);
                readOnlyState && instance.option("readOnly", readOnlyState);
                that.on("optionChanged", function(args) {
                    if (args.name === "readOnly")
                        instance.option(args.name, args.value)
                });
                return instance
            },
            _getTemplateByFieldItem: function(fieldItem) {
                return fieldItem.template ? this._getTemplate(fieldItem.template) : null
            },
            _appendEditorToField: function(params) {
                if (params.$label) {
                    var location = params.labelOptions.location;
                    if (location === "top" || location === "left")
                        params.$fieldItem.append(params.$editor);
                    if (location === "right")
                        params.$fieldItem.prepend(params.$editor);
                    this._addInnerItemAlignmentClass(params.$fieldItem, location)
                }
                else
                    params.$fieldItem.append(params.$editor)
            },
            _addInnerItemAlignmentClass: function($fieldItem, location) {
                if (location === "top")
                    $fieldItem.addClass(LABEL_VERTICAL_ALIGNMENT_CLASS);
                else
                    $fieldItem.addClass(LABEL_HORIZONTAL_ALIGNMENT_CLASS)
            },
            _renderHelpText: function(fieldItem, $editor, helpID) {
                var helpText = fieldItem.helpText;
                if (helpText) {
                    var $editorWrapper = $("<div>").addClass(FIELD_ITEM_CONTENT_WRAPPER_CLASS);
                    $editor.wrap($editorWrapper);
                    $("<div>").addClass(FIELD_ITEM_HELP_TEXT_CLASS).attr("id", helpID).text(helpText).appendTo($editor.parent())
                }
            },
            _attachClickHandler: function($label, $editor, editorType) {
                var isBooleanEditors = editorType === "dxCheckBox" || editorType === "dxSwitch";
                if ($label && isBooleanEditors)
                    $label.on("dxclick", function() {
                        $editor.children().trigger("dxclick")
                    })
            },
            _generateRatio: function(count, isAutoSize) {
                var result = [],
                    ratio,
                    i;
                for (i = 0; i < count; i++) {
                    ratio = {ratio: 1};
                    if (isAutoSize)
                        ratio.baseSize = "auto";
                    result.push(ratio)
                }
                return result
            },
            _getRowsCount: function() {
                return Math.ceil(this._items.length / this._getColCount())
            },
            _toggleReadOnlyState: function() {
                this.element().toggleClass(READONLY_STATE_CLASS, this.option("readOnly"))
            },
            _optionChanged: function(args) {
                if (args.fullName.search("layoutData.") === 0)
                    return;
                switch (args.name) {
                    case"showRequiredMark":
                    case"showOptionalMark":
                    case"requiredMark":
                    case"optionalMark":
                        this._cashedRequiredConfig = null;
                        this._invalidate();
                        break;
                    case"layoutData":
                    case"items":
                        this._syncDataWithItems();
                        this._updateItems(args.value);
                        this._invalidate();
                        break;
                    case"alignItemLabels":
                    case"labelLocation":
                        this._invalidate();
                        break;
                    case"customizeItem":
                        this._updateItems(this.option("layoutData"));
                        this._invalidate();
                        break;
                    case"colCount":
                        this._resetColCount();
                        break;
                    case"minColWidth":
                        if (this.option("colCount") === "auto")
                            this._resetColCount();
                        break;
                    case"readOnly":
                        this._toggleReadOnlyState();
                        break;
                    case"width":
                        this.callBase(args);
                        if (this.option("colCount") === "auto")
                            this._resetColCount();
                        break;
                    case"onFieldDataChanged":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _resetColCount: function() {
                this._cashedColCount = null;
                this._invalidate()
            },
            linkEditorToDataField: function(editorInstance, dataField, editorType) {
                var fullFieldName = "layoutData." + dataField,
                    that = this;
                that.on("optionChanged", function(args) {
                    if (args.fullName === fullFieldName)
                        switch (editorType) {
                            case"dxTagBox":
                                that._managedUpdateEditorOption(editorInstance, "values", args.value);
                                break;
                            case"dxSelectBox":
                                that._managedUpdateEditorOption(editorInstance, "value", args.value);
                                break;
                            default:
                                editorInstance.option("value", args.value)
                        }
                });
                editorInstance.on("valueChanged", function(args) {
                    switch (editorType) {
                        case"dxTagBox":
                            that._managedUpdateFieldValue(dataField, args.values);
                            break;
                        case"dxSelectBox":
                            that._managedUpdateFieldValue(dataField, args.value);
                            break;
                        default:
                            that._updateFieldValue(dataField, args.value)
                    }
                })
            },
            _managedUpdateEditorOption: function(editorInstance, optionName, value) {
                if (!this._isValueChangedCalled) {
                    this._isFieldValueChanged = true;
                    editorInstance.option(optionName, value);
                    this._isFieldValueChanged = false
                }
            },
            _managedUpdateFieldValue: function(dataField, value) {
                this._isValueChangedCalled = true;
                if (!this._isFieldValueChanged)
                    this._updateFieldValue(dataField, value);
                this._isValueChangedCalled = false
            },
            updateData: function(data, value) {
                var that = this;
                if (utils.isObject(data))
                    $.each(data, function(dataField, fieldValue) {
                        that._updateFieldValue(dataField, fieldValue)
                    });
                else if (typeof data === "string")
                    that._updateFieldValue(data, value)
            },
            getEditor: function(field) {
                return this._editorInstancesByField[field]
            },
            isLayoutChanged: function(component) {
                var responsiveBox = this._responsiveBox || component;
                if (responsiveBox)
                    return responsiveBox.option("currentScreenFactor") === responsiveBox.option("singleColumnScreen")
            }
        }));
        $.extend(ui.dxForm.__internals, {
            FIELD_ITEM_CLASS: FIELD_ITEM_CLASS,
            FIELD_EMPTY_ITEM_CLASS: FIELD_EMPTY_ITEM_CLASS,
            FIELD_ITEM_CONTENT_CLASS: FIELD_ITEM_CONTENT_CLASS,
            FIELD_ITEM_CONTENT_LOCATION_CLASS: FIELD_ITEM_CONTENT_LOCATION_CLASS,
            FIELD_ITEM_LABEL_CLASS: FIELD_ITEM_LABEL_CLASS,
            FIELD_ITEM_LABEL_BASELINE_CLASS: FIELD_ITEM_LABEL_BASELINE_CLASS,
            FIELD_ITEM_LABEL_LOCATION_CLASS: FIELD_ITEM_LABEL_LOCATION_CLASS,
            LABEL_HORIZONTAL_ALIGNMENT_CLASS: LABEL_HORIZONTAL_ALIGNMENT_CLASS,
            LABEL_VERTICAL_ALIGNMENT_CLASS: LABEL_VERTICAL_ALIGNMENT_CLASS,
            FORM_LAYOUT_MANAGER_CLASS: FORM_LAYOUT_MANAGER_CLASS,
            READONLY_STATE_CLASS: READONLY_STATE_CLASS,
            FIELD_ITEM_CONTENT_WRAPPER_CLASS: FIELD_ITEM_CONTENT_WRAPPER_CLASS,
            FIELD_ITEM_HELP_TEXT_CLASS: FIELD_ITEM_HELP_TEXT_CLASS,
            FIELD_ITEM_LABEL_CONTENT_CLASS: FIELD_ITEM_LABEL_CONTENT_CLASS,
            FIELD_ITEM_LABEL_TEXT_CLASS: FIELD_ITEM_LABEL_TEXT_CLASS,
            FIELD_ITEM_REQUIRED_CLASS: FIELD_ITEM_REQUIRED_CLASS,
            FIELD_ITEM_OPTIONAL_CLASS: FIELD_ITEM_OPTIONAL_CLASS,
            FIELD_ITEM_REQUIRED_MARK_CLASS: FIELD_ITEM_REQUIRED_MARK_CLASS,
            FIELD_ITEM_OPTIONAL_MARK_CLASS: FIELD_ITEM_OPTIONAL_MARK_CLASS,
            LAYOUT_MANAGER_ONE_COLUMN: LAYOUT_MANAGER_ONE_COLUMN
        })
    })(jQuery, DevExpress);
    DevExpress.MOD_WIDGETS_BASE = true
}
if (!window.DevExpress || !DevExpress.MOD_WIDGETS_WEB) {
    if (!window.DevExpress || !DevExpress.MOD_WIDGETS_BASE)
        throw Error('Required module is not referenced: widgets-base');
    /*! Module widgets-web, file ui.accordion.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx,
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var ACCORDION_CLASS = "dx-accordion",
            ACCORDION_WRAPPER_CLASS = "dx-accordion-wrapper",
            ACCORDION_ITEM_CLASS = "dx-accordion-item",
            ACCORDION_ITEM_OPENED_CLASS = "dx-accordion-item-opened",
            ACCORDION_ITEM_CLOSED_CLASS = "dx-accordion-item-closed",
            ACCORDION_ITEM_TITLE_CLASS = "dx-accordion-item-title",
            ACCORDION_ITEM_BODY_CLASS = "dx-accordion-item-body",
            ACCORDION_ITEM_DATA_KEY = "dxAccordionItemData",
            ACCORDION_ITEM_TITLE_DATA_KEY = "dxAccordionItemTitleData",
            ACCORDION_ITEM_CONTENT_DATA_KEY = "dxAccordionItemContentData";
        registerComponent("dxAccordion", ui, ui.CollectionWidget.inherit({
            _activeStateUnit: "." + ACCORDION_ITEM_CLASS,
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        hoverStateEnabled: true,
                        height: undefined,
                        itemTitleTemplate: "title",
                        onItemTitleClick: null,
                        onItemTitleHold: null,
                        selectedIndex: 0,
                        collapsible: false,
                        multiple: false,
                        animationDuration: 300,
                        deferRendering: true,
                        selectionByClick: true,
                        activeStateEnabled: true,
                        _itemAttributes: {role: "tab"}
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return devices.real().generic && !devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _itemElements: function() {
                return this._itemContainer().children(this._itemSelector())
            },
            _init: function() {
                this.callBase();
                this.option("selectionRequired", !this.option("collapsible"));
                this.option("selectionMode", this.option("multiple") ? "multi" : "single");
                var $element = this.element();
                $element.addClass(ACCORDION_CLASS);
                this._$container = $("<div>").addClass(ACCORDION_WRAPPER_CLASS);
                $element.append(this._$container)
            },
            _render: function() {
                this._deferredItems = [];
                this.callBase();
                this.setAria({
                    role: "tablist",
                    multiselectable: this.option("multiple")
                });
                this._attachItemTitleClickAction()
            },
            _itemDataKey: function() {
                return ACCORDION_ITEM_DATA_KEY
            },
            _itemClass: function() {
                return ACCORDION_ITEM_CLASS
            },
            _itemContainer: function() {
                return this._$container
            },
            _itemTitles: function() {
                return this._itemElements().find("." + ACCORDION_ITEM_TITLE_CLASS)
            },
            _itemContents: function() {
                return this._itemElements().find("." + ACCORDION_ITEM_BODY_CLASS)
            },
            _getItemData: function(target) {
                return $(target).parent().data(this._itemDataKey()) || this.callBase.apply(this, arguments)
            },
            _executeItemRenderAction: function(itemData, itemElement) {
                if (itemData.type)
                    return;
                this.callBase.apply(this, arguments)
            },
            _itemSelectHandler: function(e) {
                if ($(e.target).closest("." + ACCORDION_ITEM_BODY_CLASS).length)
                    return;
                this.callBase.apply(this, arguments)
            },
            _renderItemContent: function(index, itemData, $container) {
                $container = $container || this._itemContainer();
                var $itemTitle = this.callBase.apply(this, [index, $.extend({
                            type: "title",
                            titleTemplate: this._getTemplateByOption("itemTitleTemplate")
                        }, itemData), $container]);
                var $item = $itemTitle.parent();
                this._deferredItems.push($.Deferred());
                this._deferredItems[index].done($.proxy(this._renderItemBody, this, this.callBase, index, itemData, $item));
                if (!this.option("deferRendering"))
                    this._deferredItems[index].resolve()
            },
            _renderItemBody: function(baseRenderer, index, itemData, $item) {
                var $itemBody = $("<div>").appendTo($item);
                baseRenderer.apply(this, [index, $.extend({
                        type: "content",
                        template: this._getTemplateByOption("itemTemplate")
                    }, itemData), $itemBody])
            },
            _getItemTemplateName: function(itemData) {
                var templateProperty = this.option("itemTemplateProperty");
                if (itemData.type === "title")
                    templateProperty = "titleTemplate";
                return itemData && itemData[templateProperty] || this.option("itemTemplate")
            },
            _addItemContentClasses: function($container, itemData) {
                switch (itemData.type) {
                    case"title":
                        $container.addClass(ACCORDION_ITEM_TITLE_CLASS).data(ACCORDION_ITEM_TITLE_DATA_KEY, itemData);
                        break;
                    case"content":
                        $container.addClass(ACCORDION_ITEM_BODY_CLASS).data(ACCORDION_ITEM_CONTENT_DATA_KEY, itemData);
                        break;
                    default:
                        this.callBase.apply(this, arguments)
                }
            },
            _attachItemTitleClickAction: function() {
                var itemSelector = "." + ACCORDION_ITEM_TITLE_CLASS,
                    eventName = eventUtils.addNamespace("dxclick", this.NAME);
                this._itemContainer().off(eventName, itemSelector).on(eventName, itemSelector, $.proxy(this._itemTitleClickHandler, this))
            },
            _itemTitleClickHandler: function(e) {
                this._itemJQueryEventHandler(e, "onItemTitleClick")
            },
            _renderSelection: function(addedSelection, removedSelection) {
                this._itemElements().addClass(ACCORDION_ITEM_CLOSED_CLASS);
                this._updateItems(addedSelection, removedSelection, true)
            },
            _updateSelection: function(addedSelection, removedSelection) {
                this._updateItems(addedSelection, removedSelection, false)
            },
            _updateItems: function(addedSelection, removedSelection, skipAnimation) {
                var $items = this._itemElements(),
                    that = this;
                $.each(addedSelection, function(_, index) {
                    var $item = $items.eq(index);
                    if ($item.find("." + ACCORDION_ITEM_BODY_CLASS).length === 0)
                        that._deferredItems[index].resolve();
                    $item.addClass(ACCORDION_ITEM_OPENED_CLASS);
                    $item.removeClass(ACCORDION_ITEM_CLOSED_CLASS)
                });
                $.each(removedSelection, function(_, index) {
                    $items.eq(index).removeClass(ACCORDION_ITEM_OPENED_CLASS)
                });
                this._updateItemHeights(skipAnimation)
            },
            _updateItemHeights: function(skipAnimation) {
                var that = this,
                    itemHeight = this._splitFreeSpace(this._calculateFreeSpace());
                return $.when.apply($, $.map(this._itemElements(), function(item) {
                        return that._updateItemHeight($(item), itemHeight, skipAnimation)
                    }))
            },
            _updateItemHeight: function($item, itemHeight, skipAnimation) {
                var $title = $item.children("." + ACCORDION_ITEM_TITLE_CLASS);
                if (fx.isAnimating($item))
                    fx.stop($item);
                var startItemHeight = $item.outerHeight(),
                    finalItemHeight = $item.hasClass(ACCORDION_ITEM_OPENED_CLASS) ? itemHeight + $title.outerHeight() || $item.height("auto").outerHeight() : $title.outerHeight();
                return !skipAnimation ? this._animateItem($item, startItemHeight, finalItemHeight) : $item.css("height", finalItemHeight)
            },
            _animateItem: function(element, startHeight, endHeight) {
                return fx.animate(element, {
                        type: "slide",
                        from: {height: startHeight},
                        to: {height: endHeight},
                        duration: this.option("animationDuration"),
                        complete: $.proxy(function() {
                            if (this._deferredAnimate)
                                this._deferredAnimate.resolveWith(this);
                            this._itemElements().not("." + ACCORDION_ITEM_OPENED_CLASS).addClass(ACCORDION_ITEM_CLOSED_CLASS)
                        }, this)
                    })
            },
            _splitFreeSpace: function(freeSpace) {
                if (!freeSpace)
                    return freeSpace;
                return freeSpace / this.option("selectedItems").length
            },
            _calculateFreeSpace: function() {
                var height = this.option("height");
                if (height === undefined || height === "auto")
                    return;
                var $titles = this._itemTitles(),
                    itemsHeight = 0;
                $.each($titles, function(_, title) {
                    itemsHeight += $(title).outerHeight()
                });
                return this.element().height() - itemsHeight
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._dimensionChanged()
            },
            _dimensionChanged: function() {
                this._updateItemHeights(true)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"animationDuration":
                    case"onItemTitleClick":
                        break;
                    case"collapsible":
                        this.option("selectionRequired", !this.option("collapsible"));
                        break;
                    case"itemTitleTemplate":
                    case"onItemTitleHold":
                    case"height":
                    case"deferRendering":
                        this._invalidate();
                        break;
                    case"multiple":
                        this.option("selectionMode", args.value ? "multi" : "single");
                        break;
                    default:
                        this.callBase(args)
                }
            },
            expandItem: function(index) {
                this._deferredAnimate = $.Deferred();
                this.selectItem(index);
                return this._deferredAnimate.promise()
            },
            collapseItem: function(index) {
                this._deferredAnimate = $.Deferred();
                this.unselectItem(index);
                return this._deferredAnimate.promise()
            },
            updateDimensions: function() {
                return this._updateItemHeights(false)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pager.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            stringUtils = DX.require("/utils/utils.string"),
            Class = DevExpress.require("/class"),
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var PAGES_LIMITER = 4,
            PAGER_CLASS = 'dx-pager',
            PAGER_PAGE_CLASS = 'dx-page',
            PAGER_PAGES_CLASS = 'dx-pages',
            PAGER_SELECTION_CLASS = 'dx-selection',
            PAGER_PAGE_SEPARATOR_CLASS = 'dx-separator',
            PAGER_PAGE_SIZES_CLASS = 'dx-page-sizes',
            PAGER_PAGE_SIZE_CLASS = 'dx-page-size',
            PAGER_NAVIGATE_BUTTON = 'dx-navigate-button',
            PAGER_PREV_BUTTON_CLASS = "dx-prev-button",
            PAGER_NEXT_BUTTON_CLASS = "dx-next-button",
            PAGER_INFO_CLASS = "dx-info",
            PAGER_BUTTON_DISABLE_CLASS = "dx-button-disable";
        var Page = Class.inherit({
                ctor: function(value, index) {
                    var that = this;
                    that.index = index;
                    that._$page = $('<div />').text(value).addClass(PAGER_PAGE_CLASS)
                },
                value: function(value) {
                    var that = this;
                    if (commonUtils.isDefined(value))
                        that._$page.text(value);
                    else {
                        var text = that._$page.text();
                        if (commonUtils.isNumber(text))
                            return parseInt(text);
                        else
                            return text
                    }
                },
                element: function() {
                    return this._$page
                },
                select: function(value) {
                    this._$page.toggleClass(PAGER_SELECTION_CLASS, value)
                },
                render: function(rootElement, rtlEnabled) {
                    rtlEnabled ? this._$page.prependTo(rootElement) : this._$page.appendTo(rootElement)
                }
            });
        registerComponent("dxPager", ui, Widget.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        visible: true,
                        pagesNavigatorVisible: "auto",
                        pageIndex: 1,
                        maxPagesCount: 10,
                        pageCount: 10,
                        totalCount: 0,
                        pageSize: 5,
                        showPageSizes: true,
                        pageSizes: [5, 10],
                        hasKnownLastPage: true,
                        showNavigationButtons: false,
                        showInfo: false,
                        infoText: Globalize.localize("dxPager-infoText"),
                        rtlEnabled: false,
                        pageIndexChanged: $.noop,
                        pageSizeChanged: $.noop
                    })
            },
            _toggleVisibility: function(value) {
                var $element = this.element();
                if ($element)
                    $element.css("display", value ? "" : "none")
            },
            _getPages: function(currentPage, count) {
                var pages = [],
                    showMoreButton = !this.option("hasKnownLastPage"),
                    firstValue,
                    i;
                this._testPagesCount = count;
                this._testShowMoreButton = showMoreButton;
                if (count > 0 || showMoreButton)
                    if (count <= this.option("maxPagesCount")) {
                        for (i = 1; i <= count; i++)
                            pages.push(new Page(i, i - 1));
                        if (showMoreButton)
                            pages.push(new Page('>', i - 1))
                    }
                    else {
                        pages.push(new Page(1, 0));
                        firstValue = currentPage ? currentPage.value() - currentPage.index : 1;
                        for (i = 1; i <= PAGES_LIMITER; i++)
                            pages.push(new Page(firstValue + i, i));
                        pages.push(new Page(count, PAGES_LIMITER + 1));
                        if (showMoreButton)
                            pages.push(new Page('>', PAGES_LIMITER + 1))
                    }
                return pages
            },
            _getPageByValue: function(value) {
                var that = this,
                    page,
                    i;
                for (i = 0; i < that._pages.length; i++) {
                    page = that._pages[i];
                    if (page.value() === value)
                        return page
                }
            },
            _processSelectedPage: function(maxPagesCount, pageIndex, pageCount) {
                var that = this,
                    isPageIndexValid = false,
                    selectedPageIndex;
                if (that._pages) {
                    $.each(that._pages, function(key, page) {
                        if (pageIndex === page.value())
                            isPageIndexValid = true
                    });
                    if (!isPageIndexValid)
                        that.selectedPage = null
                }
                if (commonUtils.isDefined(that.selectedPage)) {
                    if (pageIndex === pageCount && pageCount > maxPagesCount && that.selectedPage.index !== PAGES_LIMITER + 1)
                        that.selectedPage.index = PAGES_LIMITER + 1
                }
                else if (pageIndex > PAGES_LIMITER && pageIndex < pageCount) {
                    selectedPageIndex = pageCount - PAGES_LIMITER < pageIndex ? PAGES_LIMITER - (pageCount - pageIndex) + 1 : 2;
                    that.selectedPage = new Page(pageIndex, selectedPageIndex)
                }
            },
            _selectPageByValue: function(value) {
                var that = this,
                    i,
                    page = that._getPageByValue(value),
                    pages = that._pages,
                    pagesLength = pages.length,
                    prevPage,
                    nextPage,
                    morePage;
                if (!commonUtils.isDefined(page))
                    return;
                prevPage = that._pages[page.index - 1];
                nextPage = that._pages[page.index + 1];
                if (nextPage && nextPage.value() === '>') {
                    morePage = nextPage;
                    nextPage = undefined;
                    pagesLength--;
                    pages.pop()
                }
                if (that.selectedPage)
                    that.selectedPage.select(false);
                page.select(true);
                that.selectedPage = page;
                if (nextPage && nextPage.value() - value > 1)
                    if (page.index !== 0) {
                        prevPage.value(value + 1);
                        that._pages.splice(page.index, 1);
                        that._pages.splice(page.index - 1, 0, page);
                        that._pages[page.index].index = page.index;
                        page.index = page.index - 1;
                        for (i = page.index - 1; i > 0; i--)
                            that._pages[i].value(that._pages[i + 1].value() - 1)
                    }
                    else
                        for (i = 0; i < pagesLength - 1; i++)
                            that._pages[i].value(i + 1);
                if (prevPage && value - prevPage.value() > 1)
                    if (page.index !== pagesLength - 1) {
                        nextPage.value(value - 1);
                        that._pages.splice(page.index, 1);
                        that._pages.splice(page.index + 1, 0, page);
                        that._pages[page.index].index = page.index;
                        page.index = page.index + 1;
                        for (i = page.index + 1; i < pagesLength - 1; i++)
                            that._pages[i].value(that._pages[i - 1].value() + 1)
                    }
                    else
                        for (i = 1; i <= pagesLength - 2; i++)
                            that._pages[pagesLength - 1 - i].value(that._pages[pagesLength - 1].value() - i);
                if (morePage)
                    pages.push(morePage)
            },
            _nextPage: function(direction) {
                var pageIndex = this.selectedPage && this.selectedPage.value(),
                    pageCount = this.option("pageCount");
                if (commonUtils.isDefined(pageIndex)) {
                    pageIndex = direction === "next" ? ++pageIndex : --pageIndex;
                    if (pageIndex > 0 && pageIndex <= pageCount)
                        this.option("pageIndex", pageIndex)
                }
            },
            _renderPages: function(pages) {
                var that = this,
                    $separator,
                    pageslength = pages.length,
                    clickPagesIndexAction = that._createAction(function(args) {
                        var e = args.jQueryEvent,
                            pageNumber = $(e.target).text(),
                            pageIndex = pageNumber === '>' ? that.option("pageCount") + 1 : Number(pageNumber);
                        that._testPageIndex = pageIndex;
                        that.option("pageIndex", pageIndex)
                    }),
                    page;
                if (pageslength > 1) {
                    that._pageClickHandler = function(e) {
                        clickPagesIndexAction({jQueryEvent: e})
                    };
                    that.$pagesChooser.on(eventUtils.addNamespace("dxclick", that.Name + "Pages"), '.' + PAGER_PAGE_CLASS, that._pageClickHandler)
                }
                for (var i = 0; i < pageslength; i++) {
                    page = pages[i];
                    page.render(that.$pagesChooser, that.option('rtlEnabled'));
                    that.setAria({
                        role: "button",
                        label: "Page " + page.value()
                    }, page.element());
                    if (pages[i + 1] && pages[i + 1].value() - page.value() > 1) {
                        $separator = $("<div>. . .</div>").addClass(PAGER_PAGE_SEPARATOR_CLASS);
                        that.option('rtlEnabled') ? $separator.prependTo(that.$pagesChooser) : $separator.appendTo(that.$pagesChooser)
                    }
                }
            },
            _renderPagesChooser: function() {
                var that = this,
                    pagesNavigatorVisible = that.option("pagesNavigatorVisible"),
                    $element = that.element();
                if (!$element)
                    return;
                if (!pagesNavigatorVisible) {
                    that.$pagesChooser && that.$pagesChooser.remove();
                    return
                }
                if (that._pages.length === 0) {
                    that.selectedPage = null;
                    return
                }
                if (commonUtils.isDefined(that.$pagesChooser))
                    that.$pagesChooser.empty();
                else
                    that.$pagesChooser = $('<div />').addClass(PAGER_PAGES_CLASS);
                if (pagesNavigatorVisible === "auto")
                    that.$pagesChooser.css("visibility", that._pages.length === 1 ? "hidden" : "");
                that._renderInfo();
                that._renderNavigateButton("prev");
                that._renderPages(that._pages);
                that._renderNavigateButton("next");
                if (!commonUtils.isDefined(that.$pagesChooser[0].parentElement))
                    that.$pagesChooser.appendTo($element)
            },
            _renderPagesSizeChooser: function() {
                var that = this,
                    i,
                    $pageSize,
                    currentPageSize = that.option("pageSize"),
                    pageSizes = that.option("pageSizes"),
                    showPageSizes = that.option("showPageSizes"),
                    pageSizeValue,
                    pagesSizesLength = pageSizes && pageSizes.length,
                    $element = that.element();
                if (!$element)
                    return;
                that._clickPagesSizeAction = that._createAction(function(args) {
                    var e = args.jQueryEvent;
                    pageSizeValue = parseInt($(e.target).text());
                    that._testPageSizeIndex = pageSizeValue;
                    that.option("pageSize", pageSizeValue)
                });
                if (commonUtils.isDefined(that.pagesSizeChooserElement))
                    that.pagesSizeChooserElement.empty();
                else
                    that.pagesSizeChooserElement = $('<div />').addClass(PAGER_PAGE_SIZES_CLASS).on(eventUtils.addNamespace("dxclick", that.Name + "PageSize"), '.' + PAGER_PAGE_SIZE_CLASS, function(e) {
                        that._clickPagesSizeAction({jQueryEvent: e})
                    });
                if (!showPageSizes || !pagesSizesLength)
                    return;
                that._testCurrentPageSize = currentPageSize;
                for (i = 0; i < pagesSizesLength; i++) {
                    $pageSize = $('<div />').text(pageSizes[i]).addClass(PAGER_PAGE_SIZE_CLASS);
                    that.setAria({
                        role: "button",
                        label: "Display " + pageSizes[i] + " items on page"
                    }, $pageSize);
                    if (currentPageSize === pageSizes[i])
                        $pageSize.addClass(PAGER_SELECTION_CLASS);
                    that.pagesSizeChooserElement.append($pageSize)
                }
                if (!commonUtils.isDefined(that.pagesSizeChooserElement[0].parentElement))
                    that.pagesSizeChooserElement.appendTo($element)
            },
            _renderInfo: function() {
                var infoText = this.option("infoText");
                if (this.option("showInfo") && commonUtils.isDefined(infoText))
                    $("<div>").addClass(PAGER_INFO_CLASS).text(stringUtils.format(infoText, this.selectedPage && this.selectedPage.value(), this.option("pageCount"), this.option("totalCount"))).appendTo(this.$pagesChooser)
            },
            _renderNavigateButton: function(direction) {
                var that = this,
                    currentPageIndex,
                    clickAction = that._createAction(function(e) {
                        that._nextPage(direction)
                    }),
                    $button,
                    enabled;
                if (that.option("showNavigationButtons")) {
                    currentPageIndex = that.option("pageIndex");
                    enabled = currentPageIndex > 1 && direction === "prev" || currentPageIndex < that.option("pageCount") && direction === "next";
                    $button = $("<div>").addClass(PAGER_NAVIGATE_BUTTON).addClass(!enabled ? PAGER_BUTTON_DISABLE_CLASS : "").on(eventUtils.addNamespace("dxclick", that.Name + "Pages"), function(e) {
                        clickAction({jQueryEvent: e})
                    });
                    that.setAria({
                        role: "button",
                        label: direction === "prev" ? "Previous page" : " Next page"
                    }, $button);
                    if (that.option("rtlEnabled")) {
                        $button.addClass(direction === "prev" ? PAGER_NEXT_BUTTON_CLASS : PAGER_PREV_BUTTON_CLASS);
                        $button.prependTo(this.$pagesChooser)
                    }
                    else {
                        $button.addClass(direction === "prev" ? PAGER_PREV_BUTTON_CLASS : PAGER_NEXT_BUTTON_CLASS);
                        $button.appendTo(this.$pagesChooser)
                    }
                }
            },
            _render: function() {
                this.callBase();
                this._update();
                this.element().addClass(PAGER_CLASS);
                this._toggleVisibility(this.option("visible"));
                this._renderPagesSizeChooser();
                this._renderPagesChooser()
            },
            _update: function() {
                var pageCount = this.option("pageCount"),
                    pageIndex = this.option("pageIndex");
                this._processSelectedPage(this.option("maxPagesCount"), pageIndex, pageCount);
                this._pages = this._getPages(this.selectedPage, pageCount);
                this._selectPageByValue(pageIndex)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"visible":
                        this._toggleVisibility(args.value);
                        break;
                    case"pageIndex":
                        var pageIndexChanged = this.option("pageIndexChanged");
                        if (pageIndexChanged)
                            pageIndexChanged(args.value);
                        this._update();
                        this._renderPagesChooser();
                        break;
                    case"maxPagesCount":
                    case"pageCount":
                    case"totalCount":
                    case"hasKnownLastPage":
                    case"pagesNavigatorVisible":
                    case"showNavigationButtons":
                        this._update();
                        this._renderPagesChooser();
                        break;
                    case"pageSize":
                        var pageSizeChanged = this.option("pageSizeChanged");
                        if (pageSizeChanged)
                            pageSizeChanged(args.value);
                        this._renderPagesSizeChooser();
                        break;
                    case"pageSizes":
                        this._renderPagesSizeChooser();
                        break;
                    default:
                        this._invalidate()
                }
            },
            _clean: function() {
                this.$pagesChooser && this.$pagesChooser.off(eventUtils.addNamespace("dxclick", this.Name + "Pages"), '.' + PAGER_PAGE_CLASS, this._pageClickHandler)
            },
            getHeight: function() {
                return this.option("visible") ? this.element().outerHeight() : 0
            }
        }));
        ui.dxPager.__internals = {
            PAGER_CLASS: PAGER_CLASS,
            PAGER_PAGE_CLASS: PAGER_PAGE_CLASS,
            PAGER_PAGES_CLASS: PAGER_PAGES_CLASS,
            PAGER_SELECTION_CLASS: PAGER_SELECTION_CLASS,
            PAGER_PAGE_SEPARATOR_CLASS: PAGER_PAGE_SEPARATOR_CLASS,
            PAGER_PAGE_SIZES_CLASS: PAGER_PAGE_SIZES_CLASS,
            PAGER_PAGE_SIZE_CLASS: PAGER_PAGE_SIZE_CLASS,
            PAGER_NAVIGATE_BUTTON: PAGER_NAVIGATE_BUTTON,
            PAGER_PREV_BUTTON_CLASS: PAGER_PREV_BUTTON_CLASS,
            PAGER_NEXT_BUTTON_CLASS: PAGER_NEXT_BUTTON_CLASS,
            PAGER_INFO_CLASS: PAGER_INFO_CLASS,
            PAGER_BUTTON_DISABLE_CLASS: PAGER_BUTTON_DISABLE_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.hierarchicalCollectionWidget.js */
    DevExpress.define("/ui/hierarchicalCollectionWidget/ui.hierarchicalCollectionWidget", ["jquery", "/devices", "/ui/templates/ui.template.function", "/utils/utils.icon"], function($, devices, FunctionTemplate, iconUtils) {
        var ui = DevExpress.ui,
            dataUtils = DevExpress.data.utils,
            DISABLED_STATE_CLASS = "dx-state-disabled";
        var HierarchicalCollectionWidget = ui.CollectionWidget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            keyExpr: "id",
                            displayExpr: "text",
                            selectedExpr: "selected",
                            disabledExpr: "disabled",
                            itemsExpr: "items",
                            hoverStateEnabled: true,
                            parentIdExpr: "parentId",
                            expandedExpr: "expanded"
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }])
                },
                _init: function() {
                    this.callBase();
                    this._initAccessors();
                    this._initDataAdapter();
                    this._initDynamicTemplates()
                },
                _initDataAdapter: function() {
                    var accessors = this._createDataAdapterAccessors();
                    this._dataAdapter = new ui.HierarchicalDataAdapter($.extend({
                        dataAccessors: {
                            getters: accessors.getters,
                            setters: accessors.setters
                        },
                        items: this.option("items")
                    }, this._getDataAdapterOptions()))
                },
                _getDataAdapterOptions: $.noop,
                _initDynamicTemplates: function() {
                    if (!this._useCustomExpressions()) {
                        delete this._dynamicTemplates["item"];
                        return
                    }
                    this._dynamicTemplates["item"] = new FunctionTemplate($.proxy(function(itemData) {
                        return $("<div>").append(this._getIconContainer(itemData)).append(this._getTextContainer(itemData)).append(this._getPopuotContainer(itemData))
                    }, this))
                },
                _useCustomExpressions: function() {
                    return this.option("displayExpr") !== "text" && this.option("displayExpr") !== "html"
                },
                _getIconContainer: function(itemData) {
                    var icon = itemData.icon || itemData.iconSrc;
                    return icon ? iconUtils.getImageContainer(icon) : undefined
                },
                _getTextContainer: function(itemData) {
                    return $("<span>").text(this._displayGetter(itemData))
                },
                _getPopuotContainer: $.noop,
                _initAccessors: function() {
                    var that = this;
                    $.each(this._getAccessors(), function(_, accessor) {
                        that._compileAccessor(accessor)
                    })
                },
                _getAccessors: function() {
                    return ["key", "display", "selected", "items", "disabled", "parentId", "expanded"]
                },
                _getChildNodes: function(node) {
                    var that = this,
                        arr = [];
                    $.each(node.internalFields.childrenKeys, function(_, key) {
                        var childNode = that._dataAdapter.getNodeByKey(key);
                        arr.push(childNode)
                    });
                    return arr
                },
                _hasChildren: function(node) {
                    return node.internalFields.childrenKeys.length
                },
                _compileAccessor: function(optionName) {
                    var getter = "_" + optionName + "Getter",
                        setter = "_" + optionName + "Setter",
                        optionExpr = this.option(optionName + "Expr");
                    if ($.isFunction(optionExpr)) {
                        this[setter] = function(obj, value) {
                            obj[optionExpr()] = value
                        };
                        this[getter] = function(obj) {
                            return obj[optionExpr()]
                        };
                        return
                    }
                    this[getter] = dataUtils.compileGetter(optionExpr);
                    this[setter] = dataUtils.compileSetter(optionExpr)
                },
                _createDataAdapterAccessors: function() {
                    var that = this,
                        accessors = {
                            getters: {},
                            setters: {}
                        };
                    $.each(this._getAccessors(), function(_, acessor) {
                        var getterName = "_" + acessor + "Getter",
                            setterName = "_" + acessor + "Setter",
                            newAccessor = acessor === "parentId" ? "parentKey" : acessor;
                        accessors.getters[newAccessor] = that[getterName];
                        accessors.setters[newAccessor] = that[setterName]
                    });
                    return accessors
                },
                _render: function() {
                    this.callBase();
                    this._focusTarget().addClass(this._widgetClass())
                },
                _widgetClass: $.noop,
                _renderItemFrame: function(index, itemData) {
                    var $itemFrame = this.callBase.apply(this, arguments);
                    $itemFrame.toggleClass(DISABLED_STATE_CLASS, !!this._disabledGetter(itemData));
                    return $itemFrame
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"displayExpr":
                        case"keyExpr":
                            if (!this._dynamicTemplates["item"])
                                this._initDynamicTemplates();
                            this._initAccessors();
                            this.repaint();
                            break;
                        case"itemsExpr":
                        case"selectedExpr":
                        case"disabledExpr":
                        case"expandedExpr":
                        case"parentIdExpr":
                            this._initAccessors();
                            this.repaint();
                            break;
                        case"items":
                            this._initDataAdapter();
                            this.callBase(args);
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            });
        return HierarchicalCollectionWidget
    });
    /*! Module widgets-web, file ui.dataConverter.js */
    (function($, DX, undefined) {
        var Class = DX.require("/class"),
            DataSource = DX.data.DataSource,
            commonUtils = DX.require("/utils/utils.common");
        var DataConverter = Class.inherit({
                ctor: function() {
                    this._dataStructure = [];
                    this._itemsCount = 0;
                    this._visibleItemsCount = 0
                },
                _indexByKey: {},
                _convertItemsToNodes: function(items, parentKey) {
                    var that = this;
                    $.each(items, function(_, item) {
                        var parentId = commonUtils.isDefined(parentKey) ? parentKey : that._getParentId(item),
                            node = that._convertItemToNode(item, parentId);
                        that._dataStructure.push(node);
                        that._indexByKey[node.internalFields.key] = that._dataStructure.length - 1;
                        if (that._itemHasChildren(item))
                            that._convertItemsToNodes(that._dataAccessors.getters.items(item), node.internalFields.key)
                    })
                },
                _getParentId: function(item) {
                    return this._dataType === "plain" ? this._dataAccessors.getters.parentKey(item) : undefined
                },
                _itemHasChildren: function(item) {
                    var items = this._dataAccessors.getters.items(item);
                    return items && items.length
                },
                _convertItemToNode: function(item, parentKey) {
                    this._itemsCount++;
                    item.visible !== false && this._visibleItemsCount++;
                    var that = this,
                        node = {internalFields: {
                                disabled: that._dataAccessors.getters.disabled(item) || false,
                                expanded: that._dataAccessors.getters.expanded(item) || false,
                                selected: that._dataAccessors.getters.selected(item) || false,
                                key: commonUtils.isDefined(that._dataAccessors.getters.key(item)) ? that._dataAccessors.getters.key(item) : that.getItemsCount(),
                                parentKey: commonUtils.isDefined(parentKey) ? parentKey : that._rootValue,
                                item: that._makeObjectFromPrimitive(item),
                                childrenKeys: []
                            }};
                    $.extend(true, node, item);
                    delete node.items;
                    return node
                },
                setChildrenKeys: function() {
                    var that = this;
                    new DataSource({
                        store: this._dataStructure,
                        map: function(item) {
                            return item.internalFields.key
                        },
                        group: "internalFields.parentKey"
                    }).load().done(function(parents) {
                        $.each(parents, function(_, parent) {
                            if (parent.key === that._rootValue)
                                return;
                            that._getByKey(parent.key).internalFields.childrenKeys = parent.items
                        })
                    })
                },
                _makeObjectFromPrimitive: function(item) {
                    if (commonUtils.isPrimitive(item)) {
                        var key = item;
                        item = {};
                        this._dataAccessors.setters.key(item, key)
                    }
                    return item
                },
                _convertToPublicNode: function(node, parent) {
                    if (!node)
                        return null;
                    var publicNode = {
                            text: this._dataAccessors.getters.display(node),
                            key: node.internalFields.key,
                            selected: node.internalFields.selected,
                            expanded: node.internalFields.expanded,
                            disabled: node.internalFields.disabled,
                            parent: parent || null,
                            itemData: node.internalFields.item,
                            children: [],
                            items: []
                        };
                    if (publicNode.parent) {
                        publicNode.parent.children.push(publicNode);
                        publicNode.parent.items.push(publicNode)
                    }
                    return publicNode
                },
                convertToPublicNodes: function(data, parent) {
                    if (!data.length)
                        return [];
                    var that = this,
                        publicNodes = [];
                    $.each(data, function(_, node) {
                        node = commonUtils.isPrimitive(node) ? that._getByKey(node) : node;
                        var publicNode = that._convertToPublicNode(node, parent);
                        publicNode.children = that.convertToPublicNodes(node.internalFields.childrenKeys, publicNode);
                        publicNodes.push(publicNode);
                        node.internalFields.publicNode = publicNode
                    });
                    return publicNodes
                },
                setDataAccessors: function(accessors) {
                    this._dataAccessors = accessors
                },
                _getByKey: function(key) {
                    return this._dataStructure[this._indexByKey[key]] || null
                },
                getByKey: function(data, key) {
                    var result = null,
                        that = this;
                    var getByKey = function(data, key) {
                            $.each(data, function(_, element) {
                                var currentElementKey = element.internalFields && element.internalFields.key || that._dataAccessors.getters.key(element),
                                    items = that._dataAccessors.getters.items(element);
                                if (currentElementKey === key) {
                                    result = element;
                                    return false
                                }
                                if (items)
                                    getByKey(items, key)
                            });
                            return result
                        };
                    return getByKey(data, key)
                },
                getItemsCount: function() {
                    return this._itemsCount
                },
                getVisibleItemsCount: function() {
                    return this._visibleItemsCount
                },
                createPlainStructure: function(items, rootValue, dataType) {
                    this._itemsCount = 0;
                    this._visibleItemsCount = 0;
                    this._rootValue = rootValue;
                    this._dataType = dataType;
                    this._indexByKey = {};
                    this._convertItemsToNodes(items);
                    this.setChildrenKeys();
                    return this._dataStructure
                }
            });
        DX.ui.HierarchicalDataConverter = DataConverter
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataAdapter.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            data = DX.data,
            Class = DX.require("/class"),
            commonUtils = DX.require("/utils/utils.common"),
            EXPANDED = "expanded",
            SELECTED = "selected";
        var DataAdapter = Class.inherit({
                ctor: function(options) {
                    this.options = {};
                    $.extend(this.options, this._defaultOptions(), options);
                    this.options.dataConverter.setDataAccessors(this.options.dataAccessors);
                    this._selectedNodesKeys = [];
                    this._expandedNodesKeys = [];
                    this._dataStructure = [];
                    this._createInternalDataStructure()
                },
                _defaultOptions: function() {
                    return {
                            dataAccessors: undefined,
                            items: [],
                            multipleSelection: true,
                            recursiveSelection: false,
                            recursiveExpansion: false,
                            rootValue: 0,
                            searchValue: "",
                            dataType: "tree",
                            dataConverter: new ui.HierarchicalDataConverter
                        }
                },
                _createInternalDataStructure: function() {
                    this._initialDataStructure = this.options.dataConverter.createPlainStructure(this.options.items, this.options.rootValue, this.options.dataType);
                    this._dataStructure = this.options.searchValue.length ? this.search(this.options.searchValue) : this._initialDataStructure;
                    this.options.dataConverter._dataStructure = this._dataStructure;
                    this._updateSelection();
                    this._updateExpansion()
                },
                _updateSelection: function() {
                    if (this.options.recursiveSelection) {
                        this._setChildrenSelection();
                        this._setParentSelection()
                    }
                    this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED)
                },
                _updateExpansion: function(key) {
                    if (this.options.recursiveExpansion)
                        key ? this._updateOneBranch(key) : this._setParentExpansion();
                    this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED)
                },
                _updateNodesKeysArray: function(property) {
                    var that = this,
                        array = [];
                    $.each(this._dataStructure, function(_, node) {
                        if (!that._isNodeVisible(node))
                            return;
                        if (!!node.internalFields[property])
                            if (property === EXPANDED || that.options.multipleSelection)
                                array.push(node.internalFields.key);
                            else
                                array = [node.internalFields.key]
                    });
                    return array
                },
                _isNodeVisible: function(node) {
                    return node.internalFields.item.visible !== false
                },
                _getByKey: function(data, key) {
                    return data === this._dataStructure ? this.options.dataConverter._getByKey(key) : this.options.dataConverter.getByKey(data, key)
                },
                _setChildrenSelection: function() {
                    var that = this;
                    $.each(this._dataStructure, function(_, node) {
                        if (!node.internalFields.childrenKeys.length)
                            return;
                        var isSelected = node.internalFields.selected;
                        isSelected === true && that._toggleChildrenSelection(node, isSelected)
                    })
                },
                _setParentSelection: function() {
                    var length = this._dataStructure.length;
                    for (var i = length - 1; i >= 0; i--) {
                        var node = this._dataStructure[i],
                            parent = this.options.dataConverter._getByKey(node.internalFields.parentKey);
                        if (node.internalFields.parentKey !== this.options.rootValue) {
                            var newParentState = this._calculateSelectedState(parent);
                            this._setFieldState(parent, newParentState, SELECTED)
                        }
                    }
                },
                _setParentExpansion: function(key) {
                    var that = this;
                    $.each(this._dataStructure, function(_, node) {
                        if (!node.internalFields.expanded)
                            return;
                        that._updateOneBranch(node.internalFields.key)
                    })
                },
                _updateOneBranch: function(key) {
                    var that = this,
                        node = this.getNodeByKey(key);
                    that._iterateParents(node, function(parent) {
                        that._setFieldState(parent, true, EXPANDED)
                    })
                },
                _iterateChildren: function(node, recursive, callback) {
                    var that = this;
                    $.each(node.internalFields.childrenKeys, function(_, key) {
                        var child = that.options.dataConverter._getByKey(key);
                        $.isFunction(callback) && callback(child);
                        if (child.internalFields.childrenKeys.length && recursive)
                            that._iterateChildren(child, recursive, callback)
                    })
                },
                _iterateParents: function(node, callback) {
                    if (node.internalFields.parentKey === this.options.rootValue)
                        return;
                    var parent = this.options.dataConverter._getByKey(node.internalFields.parentKey);
                    $.isFunction(callback) && callback(parent);
                    if (parent.internalFields.parentKey !== this.options.rootValue)
                        this._iterateParents(parent, callback)
                },
                _calculateSelectedState: function(node) {
                    var itemsCount = node.internalFields.childrenKeys.length,
                        selectedItemsCount = 0,
                        invisibleItemsCount = 0,
                        result = false;
                    for (var i = 0; i <= itemsCount - 1; i++) {
                        var childNode = this.options.dataConverter._getByKey(node.internalFields.childrenKeys[i]),
                            isChildInvisible = childNode.internalFields.item.visible === false,
                            childState = childNode.internalFields.selected;
                        if (isChildInvisible) {
                            invisibleItemsCount++;
                            continue
                        }
                        if (childState)
                            selectedItemsCount++;
                        else if (childState === undefined)
                            selectedItemsCount += 0.5
                    }
                    if (selectedItemsCount)
                        result = selectedItemsCount === itemsCount - invisibleItemsCount ? true : undefined;
                    return result
                },
                _toggleChildrenSelection: function(node, state) {
                    var that = this;
                    this._iterateChildren(node, true, function(child) {
                        if (that._isNodeVisible(child))
                            that._setFieldState(child, state, SELECTED)
                    })
                },
                _setFieldState: function(node, state, field) {
                    node.internalFields[field] = state;
                    this.options.dataAccessors.setters[field](node.internalFields.item, state)
                },
                getSelectedNodesKeys: function() {
                    return this._selectedNodesKeys
                },
                getExpandedNodesKeys: function() {
                    return this._expandedNodesKeys
                },
                getData: function() {
                    return this._dataStructure
                },
                getNodeByItem: function(item) {
                    var result = null;
                    $.each(this._dataStructure, function(_, node) {
                        if (node.internalFields.item === item) {
                            result = node;
                            return false
                        }
                    });
                    return result
                },
                getNodeByKey: function(key) {
                    return this._getByKey(this._dataStructure, key)
                },
                getTreeNodes: function() {
                    return this.options.dataConverter.convertToPublicNodes(this.getRootNodes())
                },
                getItemsCount: function() {
                    return this.options.dataConverter.getItemsCount()
                },
                getVisibleItemsCount: function() {
                    return this.options.dataConverter.getVisibleItemsCount()
                },
                getPublicNode: function(node) {
                    this.options.dataConverter.convertToPublicNodes(this.getRootNodes());
                    return node.internalFields.publicNode
                },
                getRootNodes: function() {
                    return data.query(this._dataStructure).filter(["internalFields.parentKey", this.options.rootValue]).toArray()
                },
                toggleSelection: function(key, state) {
                    var node = this._getByKey(this._dataStructure, key);
                    this._setFieldState(node, state, SELECTED);
                    if (this.options.recursiveSelection) {
                        state ? this._setChildrenSelection() : this._toggleChildrenSelection(node, state);
                        this._setParentSelection()
                    }
                    this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED)
                },
                toggleSelectAll: function(state) {
                    if (!commonUtils.isDefined(state))
                        return;
                    var that = this;
                    $.each(this._dataStructure, function(_, node) {
                        if (!that._isNodeVisible(node))
                            return;
                        that._setFieldState(node, state, SELECTED);
                        that._selectedNodesKeys = that._updateNodesKeysArray(SELECTED)
                    })
                },
                isAllSelected: function() {
                    if (this.getSelectedNodesKeys().length)
                        return this.getSelectedNodesKeys().length === this.getVisibleItemsCount() ? true : undefined;
                    else
                        return false
                },
                toggleExpansion: function(key, state) {
                    var node = this._getByKey(this._dataStructure, key);
                    this._setFieldState(node, state, EXPANDED);
                    if (state)
                        this._updateExpansion(key);
                    this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED)
                },
                search: function(substring) {
                    var that = this,
                        matches = [],
                        dataStructure = this._initialDataStructure,
                        dataConverter = this.options.dataConverter;
                    function lookForParents(matches, startIndex) {
                        while (startIndex < matches.length) {
                            var parentKey = matches[startIndex].internalFields.parentKey,
                                parent = dataConverter._getByKey(parentKey);
                            if (!parent || $.inArray(parent, matches) > -1) {
                                startIndex += 1;
                                continue
                            }
                            if (!parent.internalFields.expanded)
                                that._setFieldState(parent, true, EXPANDED);
                            matches.splice(startIndex, 0, parent);
                            lookForParents(matches, startIndex)
                        }
                    }
                    this.options.dataConverter._newIndexByKey = {};
                    for (var i = 0, size = dataStructure.length; i < size; i++)
                        if (this.options.dataAccessors.getters.display(dataStructure[i]).toLowerCase().indexOf(substring.toLowerCase()) > -1)
                            matches.push(dataStructure[i]);
                    lookForParents(matches, 0);
                    this.options.dataConverter._indexByKey = {};
                    $.each(matches, function(index, node) {
                        node.internalFields.childrenKeys = [];
                        that.options.dataConverter._indexByKey[node.internalFields.key] = index
                    });
                    this.options.dataConverter._dataStructure = matches;
                    this.options.dataConverter.setChildrenKeys();
                    matches = this.options.dataConverter._dataStructure;
                    return matches
                }
            });
        DX.ui.HierarchicalDataAdapter = DataAdapter
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.menuBase.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            commonUtils = DX.require("/utils/utils.common"),
            inkRipple = DX.require("/utils/utils.inkRipple"),
            HierarchicalCollectionWidget = DX.require("/ui/hierarchicalCollectionWidget/ui.hierarchicalCollectionWidget"),
            devices = DX.require("/devices");
        var DX_MENU_CLASS = "dx-menu",
            DX_MENU_BASE_CLASS = "dx-menu-base",
            ITEM_CLASS = DX_MENU_CLASS + "-item",
            DX_MENU_SELECTED_ITEM_CLASS = ITEM_CLASS + "-selected",
            DX_MENU_ITEM_WRAPPER_CLASS = ITEM_CLASS + "-wrapper",
            DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
            DX_MENU_ITEM_EXPANDED_CLASS = ITEM_CLASS + "-expanded",
            DX_MENU_SEPARATOR_CLASS = DX_MENU_CLASS + "-separator",
            DX_MENU_ITEM_LAST_GROUP_ITEM = DX_MENU_CLASS + "-last-group-item",
            DX_ITEM_HAS_TEXT = ITEM_CLASS + "-has-text",
            DX_ITEM_HAS_ICON = ITEM_CLASS + "-has-icon",
            DX_ITEM_HAS_SUBMENU = ITEM_CLASS + "-has-submenu",
            DX_MENU_ITEM_POPOUT_CLASS = ITEM_CLASS + "-popout",
            DX_MENU_ITEM_POPOUT_CONTAINER_CLASS = DX_MENU_ITEM_POPOUT_CLASS + "-container",
            DX_MENU_ITEM_CAPTION_CLASS = ITEM_CLASS + "-text",
            SINGLE_SELECTION_MODE = "single",
            DEFAULT_DELAY = {
                show: 50,
                hide: 300
            };
        var dxMenuBase = HierarchicalCollectionWidget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            items: [],
                            cssClass: "",
                            activeStateEnabled: true,
                            showSubmenuMode: {
                                name: "onHover",
                                delay: {
                                    show: 50,
                                    hide: 300
                                }
                            },
                            animation: {
                                show: {
                                    type: "fade",
                                    from: 0,
                                    to: 1,
                                    duration: 100
                                },
                                hide: {
                                    type: "fade",
                                    from: 1,
                                    to: 0,
                                    duration: 100
                                }
                            },
                            selectionByClick: false,
                            focusOnSelectedItem: false,
                            _remoteSelectionSync: false,
                            _itemAttributes: {role: "menuitem"},
                            useInkRipple: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: {platform: "android"},
                                options: {useInkRipple: true}
                            }])
                },
                _activeStateUnit: "." + ITEM_CLASS,
                _itemDataKey: function() {
                    return "dxMenuItemDataKey"
                },
                _itemClass: function() {
                    return ITEM_CLASS
                },
                _setAriaSelected: $.noop,
                _selectedItemClass: function() {
                    return DX_MENU_SELECTED_ITEM_CLASS
                },
                _widgetClass: function() {
                    return DX_MENU_BASE_CLASS
                },
                _focusTarget: function() {
                    return this._itemContainer()
                },
                _eventBindingTarget: function() {
                    return this._itemContainer()
                },
                _supportedKeys: function() {
                    var selectItem = function(e) {
                            var $item = this.option("focusedElement");
                            if (!$item || !this._isSelectionEnabled())
                                return;
                            this.selectItem($item[0])
                        };
                    return $.extend(this.callBase(), {
                            space: selectItem,
                            pageUp: $.noop,
                            pageDown: $.noop
                        })
                },
                _isSelectionEnabled: function() {
                    return this.option("selectionMode") === SINGLE_SELECTION_MODE
                },
                _init: function() {
                    this.callBase();
                    this._renderSelectedItem();
                    this._initActions()
                },
                _useCustomExpressions: function() {
                    return this.callBase() || this.option("itemsExpr") !== "items"
                },
                _getTextContainer: function(itemData) {
                    var itemText = this._displayGetter(itemData),
                        $itemContainer = $('<span>').addClass(DX_MENU_ITEM_CAPTION_CLASS),
                        itemContent = $.isPlainObject(itemData) ? itemText : String(itemData);
                    return itemText && $itemContainer.html(itemContent)
                },
                _getPopuotContainer: function(itemData) {
                    var items = this._itemsGetter(itemData),
                        $popOutContainer;
                    if (items && items.length) {
                        var $popOutImage = $('<div>').addClass(DX_MENU_ITEM_POPOUT_CLASS);
                        $popOutContainer = $('<span>').addClass(DX_MENU_ITEM_POPOUT_CONTAINER_CLASS).append($popOutImage)
                    }
                    return $popOutContainer
                },
                _getDataAdapterOptions: function() {
                    return {
                            rootValue: 0,
                            multipleSelection: false,
                            recursiveSelection: false,
                            recursiveExpansion: false,
                            searchValue: ""
                        }
                },
                _selectByItem: function(selectedItem) {
                    if (!selectedItem)
                        return;
                    var nodeToSelect = this._dataAdapter.getNodeByItem(selectedItem);
                    this._dataAdapter.toggleSelection(nodeToSelect.internalFields.key, true)
                },
                _renderSelectedItem: function() {
                    var selectedKeys = this._dataAdapter.getSelectedNodesKeys(),
                        selectedKey = selectedKeys.length && selectedKeys[0],
                        selectedItem = this.option("selectedItem");
                    if (!selectedKey) {
                        this._selectByItem(selectedItem);
                        return
                    }
                    var node = this._dataAdapter.getNodeByKey(selectedKey);
                    if (node.selectable === false)
                        return;
                    if (!selectedItem) {
                        this.option("selectedItem", node.internalFields.item);
                        return
                    }
                    if (selectedItem !== node.internalFields.item) {
                        this._dataAdapter.toggleSelection(selectedKey, false);
                        this._selectByItem(selectedItem)
                    }
                },
                _initActions: $.noop,
                _render: function() {
                    this.callBase();
                    this._addCustomCssClass(this.element());
                    this.option("useInkRipple") && this._renderInkRipple()
                },
                _renderInkRipple: function() {
                    this._inkRipple = inkRipple.render()
                },
                _toggleActiveState: function($element, value, e) {
                    this.callBase.apply(this, arguments);
                    if (!this._inkRipple)
                        return;
                    var config = {
                            element: $element,
                            jQueryEvent: e
                        };
                    if (value)
                        this._inkRipple.renderWave(config);
                    else
                        this._inkRipple.removeWave(config)
                },
                _getShowSubmenuMode: function() {
                    var defaultValue = "onClick",
                        optionValue = this.option("showSubmenuMode");
                    optionValue = commonUtils.isObject(optionValue) ? optionValue.name : optionValue;
                    return this._isDesktopDevice() ? optionValue : defaultValue
                },
                _initSelectedItems: $.noop,
                _isDesktopDevice: function() {
                    return devices.real().deviceType === "desktop"
                },
                _initEditStrategy: function() {
                    var strategy = ui.CollectionWidget.MenuBaseEditStrategy;
                    this._editStrategy = new strategy(this)
                },
                _addCustomCssClass: function($element) {
                    $element.addClass(this.option("cssClass"))
                },
                _itemWrapperSelector: function() {
                    return "." + DX_MENU_ITEM_WRAPPER_CLASS
                },
                _hoverStartHandler: function(e) {
                    var that = this,
                        $itemElement = that._getItemElementByEventArgs(e);
                    if (!$itemElement || that._isItemDisabled($itemElement))
                        return;
                    e.stopPropagation();
                    that.option("focusedElement", $itemElement);
                    if (that._getShowSubmenuMode() === "onHover")
                        this._showSubmenusTimeout = setTimeout($.proxy(that._showSubmenu, that, $itemElement), that._getSubmenuDelay("show"))
                },
                _isItemDisabled: function($item) {
                    return this._disabledGetter($item.data(this._itemDataKey()))
                },
                _showSubmenu: function($itemElement) {
                    clearTimeout(this._showSubmenusTimeout);
                    if (this._hasFocusClass($itemElement))
                        this._addExpandedClass($itemElement)
                },
                _addExpandedClass: function($itemElement) {
                    $itemElement.addClass(DX_MENU_ITEM_EXPANDED_CLASS)
                },
                _getSubmenuDelay: function(action) {
                    var delay = this.option("showSubmenuMode").delay;
                    if (!delay)
                        return DEFAULT_DELAY[action];
                    return commonUtils.isObject(delay) ? delay[action] : delay
                },
                _getItemElementByEventArgs: function(eventArgs) {
                    var $target = $(eventArgs.target);
                    if ($target.hasClass(this._itemClass()) || $target.get(0) === eventArgs.currentTarget)
                        return $target;
                    while (!$target.hasClass(this._itemClass())) {
                        $target = $target.parent();
                        if ($target.hasClass("dx-submenu"))
                            return null
                    }
                    return $target
                },
                _hoverEndHandler: $.noop,
                _hasSubmenu: function(node) {
                    return node.internalFields.childrenKeys.length
                },
                _renderContentImpl: function() {
                    this._renderItems(this._dataAdapter.getRootNodes())
                },
                _renderItems: function(nodes, submenuContainer) {
                    var that = this,
                        $nodeContainer;
                    if (nodes.length) {
                        $nodeContainer = this._renderContainer(this.element(), submenuContainer);
                        $.each(nodes, function(index, node) {
                            that._renderItem(index, node, $nodeContainer)
                        })
                    }
                },
                _renderContainer: function($wrapper) {
                    return $("<ul>").appendTo($wrapper).addClass(DX_MENU_ITEMS_CONTAINER_CLASS)
                },
                _createDOMElement: function($nodeContainer) {
                    var $node = $("<li>").appendTo($nodeContainer).addClass(DX_MENU_ITEM_WRAPPER_CLASS);
                    return $node
                },
                _renderItem: function(index, node, $nodeContainer) {
                    var items = this.option("items"),
                        $itemFrame;
                    this._renderSeparator(node, index, $nodeContainer);
                    if (node.internalFields.item.visible === false)
                        return;
                    var $node = this._createDOMElement($nodeContainer);
                    if (items[index + 1] && items[index + 1].beginGroup)
                        $node.addClass(DX_MENU_ITEM_LAST_GROUP_ITEM);
                    $itemFrame = this.callBase(index, node.internalFields.item, $node);
                    if (node.internalFields.item === this.option("selectedItem"))
                        $itemFrame.addClass(DX_MENU_SELECTED_ITEM_CLASS);
                    this._addContentClasses(node, $itemFrame);
                    if (this._hasSubmenu(node))
                        this.setAria("haspopup", "true", $itemFrame)
                },
                _addContentClasses: function(node, $itemFrame) {
                    if (this._displayGetter(node))
                        $itemFrame.addClass(DX_ITEM_HAS_TEXT);
                    if (node.icon || node.iconSrc)
                        $itemFrame.addClass(DX_ITEM_HAS_ICON);
                    if (this._hasSubmenu(node))
                        $itemFrame.addClass(DX_ITEM_HAS_SUBMENU)
                },
                _postprocessRenderItem: function(args) {
                    var $itemElement = $(args.itemElement),
                        selectedIndex = this._dataAdapter.getSelectedNodesKeys(),
                        node;
                    if (!selectedIndex.length || !this._selectedGetter(args.itemData) || !this._isItemSelectable(args.itemData)) {
                        this._setAriaSelected($itemElement, "false");
                        return
                    }
                    node = this._dataAdapter.getNodeByItem(args.itemData);
                    if (node.internalFields.key === selectedIndex[0]) {
                        $itemElement.addClass(this._selectedItemClass());
                        this._setAriaSelected($itemElement, "true")
                    }
                    else
                        this._setAriaSelected($itemElement, "false")
                },
                _isItemSelectable: function(item) {
                    return item.selectable !== false
                },
                _renderSeparator: function(node, index, $itemsContainer) {
                    if (node.beginGroup && index > 0)
                        this._needSeparate = true;
                    if (node.visible !== false && this._needSeparate) {
                        $("<li>").appendTo($itemsContainer).addClass(DX_MENU_SEPARATOR_CLASS);
                        this._needSeparate = false
                    }
                },
                _itemClickHandler: function(e) {
                    var itemClickActionHandler = this._createAction($.proxy(this._updateSubmenuVisibilityOnClick, this));
                    this._itemJQueryEventHandler(e, "onItemClick", {}, {afterExecute: $.proxy(itemClickActionHandler, this)})
                },
                _updateSubmenuVisibilityOnClick: function(actionArgs) {
                    this._updateSelectedItemOnClick(actionArgs);
                    if (this._getShowSubmenuMode() === "onClick")
                        this._addExpandedClass(actionArgs.args[0].itemElement)
                },
                _updateSelectedItemOnClick: function(actionArgs) {
                    var args = actionArgs.args ? actionArgs.args[0] : actionArgs,
                        selectedItemKey;
                    if (!this._isItemSelectionAllowed(args.itemData))
                        return;
                    selectedItemKey = this._dataAdapter.getSelectedNodesKeys();
                    var selectedNode = selectedItemKey.length && this._dataAdapter.getNodeByKey(selectedItemKey[0]);
                    if (selectedNode)
                        this._toggleItemSelection(selectedNode, false);
                    if (!selectedNode || selectedNode.internalFields.item !== args.itemData)
                        this.selectItem(args.itemData);
                    else {
                        this._fireSelectionChangeEvent(null, this.option("selectedItem"));
                        this._setOptionSilent("selectedItem", null)
                    }
                },
                _isItemSelectionAllowed: function(item) {
                    var isSelectionByClickEnabled = this._isSelectionEnabled() && this.option("selectionByClick");
                    return this._itemContainer() && isSelectionByClickEnabled && this._isItemSelectable(item) && !this._itemsGetter(item)
                },
                _syncSelectionOptions: $.noop,
                _optionChanged: function(args) {
                    if (this._cancelOptionChange)
                        return;
                    switch (args.name) {
                        case"showSubmenuMode":
                            break;
                        case"selectedItem":
                            var itemData = args.value,
                                node = this._dataAdapter.getNodeByItem(itemData),
                                selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
                            if (node && node.internalFields.key !== selectedKey) {
                                if (node.selectable === false)
                                    break;
                                if (selectedKey)
                                    this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false);
                                this._toggleItemSelection(node, true);
                                this._updateSelectedItems()
                            }
                            break;
                        case"_remoteSelectionSync":
                        case"cssClass":
                        case"position":
                        case"selectionByClick":
                        case"animation":
                        case"useInkRipple":
                            this._invalidate();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _toggleItemSelection: function(node, value) {
                    var itemElement = this._getElementByItem(node.internalFields.item);
                    itemElement && $(itemElement).toggleClass(DX_MENU_SELECTED_ITEM_CLASS);
                    this._dataAdapter.toggleSelection(node.internalFields.key, value)
                },
                _getElementByItem: function(itemData) {
                    var that = this,
                        result;
                    $.each(this._itemContainer().find("." + ITEM_CLASS), function(_, itemElement) {
                        if ($(itemElement).data(that._itemDataKey()) !== itemData)
                            return true;
                        result = itemElement;
                        return false
                    });
                    return result
                },
                _updateSelectedItems: function(oldSelection, newSelection) {
                    if (oldSelection || newSelection) {
                        this._updateSelection(newSelection, oldSelection);
                        this._fireSelectionChangeEvent(newSelection, oldSelection)
                    }
                },
                _fireSelectionChangeEvent: function(addedSelection, removedSelection) {
                    this._createActionByOption("onSelectionChanged", {excludeValidators: ["disabled", "readOnly"]})({
                        addedItems: [addedSelection],
                        removedItems: [removedSelection]
                    })
                },
                selectItem: function(itemElement) {
                    var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement,
                        node = this._dataAdapter.getNodeByItem(itemData),
                        selectedKey = this._dataAdapter.getSelectedNodesKeys()[0],
                        selectedItem = this.option("selectedItem");
                    if (node.internalFields.key !== selectedKey) {
                        if (selectedKey)
                            this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false);
                        this._toggleItemSelection(node, true);
                        this._updateSelectedItems(selectedItem, itemData);
                        this._setOptionSilent("selectedItem", itemData)
                    }
                },
                unselectItem: function(itemElement) {
                    var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement,
                        node = this._dataAdapter.getNodeByItem(itemData),
                        selectedItem = this.option("selectedItem");
                    if (node.internalFields.selected) {
                        this._toggleItemSelection(node, false);
                        this._updateSelectedItems(selectedItem, null);
                        this._setOptionSilent("selectedItem", null)
                    }
                }
            });
        dxMenuBase.publicName("dxMenuBase");
        ui.dxMenuBase = dxMenuBase
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.menuBase.edit.strategy.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            errors = DevExpress.require("/ui/ui.errors");
        ui.CollectionWidget.MenuBaseEditStrategy = ui.CollectionWidget.PlainEditStrategy.inherit({
            _getPlainItems: function() {
                return $.map(this._collectionWidget.option("items"), function getMenuItems(item) {
                        return item.items ? [item].concat($.map(item.items, getMenuItems)) : item
                    })
            },
            _stringifyItem: function(item) {
                var that = this;
                return JSON.stringify(item, function(key, value) {
                        if (key === "template")
                            return that._getTemplateString(value);
                        return value
                    })
            },
            _getTemplateString: function(template) {
                var result;
                if (typeof template === "object")
                    result = $(template).text();
                else
                    result = template.toString();
                return result
            },
            selectedItemIndices: function() {
                var selectedIndices = [],
                    dataAdapter = this._collectionWidget._dataAdapter,
                    items = dataAdapter.getData(),
                    selectedItem = dataAdapter.getNodeByKey(dataAdapter.getSelectedNodesKeys()[0]);
                if (selectedItem) {
                    var index = $.inArray(selectedItem, items);
                    if (index !== -1)
                        selectedIndices.push(index);
                    else
                        errors.log("W1002", selectedItem)
                }
                return selectedIndices
            },
            fetchSelectedItems: function(indices) {
                indices = indices || this._collectionWidget._selectedItemIndices;
                var items = this._getPlainItems(),
                    selectedItems = [];
                $.each(indices, function(_, index) {
                    selectedItems.push(items[index])
                });
                return selectedItems
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.contextMenu.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx,
            positionUtils = DX.require("/utils/utils.position"),
            commonUtils = DX.require("/utils/utils.common"),
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var DX_MENU_CLASS = "dx-menu",
            DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item",
            DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded",
            DX_MENU_PHONE_CLASS = "dx-menu-phone-overlay",
            DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
            DX_MENU_ITEM_WRAPPER_CLASS = DX_MENU_ITEM_CLASS + "-wrapper",
            DX_SUBMENU_CLASS = "dx-submenu",
            DX_CONTEXT_MENU_CLASS = "dx-context-menu",
            DX_HAS_CONTEXT_MENU_CLASS = "dx-has-context-menu",
            DX_STATE_DISABLED_CLASS = "dx-state-disabled",
            FOCUS_UP = "up",
            FOCUS_DOWN = "down",
            FOCUS_LEFT = "left",
            FOCUS_RIGHT = "right",
            FOCUS_FIRST = "first",
            FOCUS_LAST = "last",
            ACTIONS = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioning", "onLeftFirstItem", "onLeftLastItem", "onCloseRootSubmenu", "onExpandLastSubmenu"],
            LOCAL_SUBMENU_DIRECTIONS = [FOCUS_UP, FOCUS_DOWN, FOCUS_FIRST, FOCUS_LAST];
        registerComponent("dxContextMenu", ui, ui.dxMenuBase.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        alternativeInvocationMode: {
                            enabled: false,
                            invokingElement: null
                        },
                        position: {
                            at: "top left",
                            my: "top left"
                        },
                        onShowing: null,
                        onShown: null,
                        onHiding: null,
                        onHidden: null,
                        onPositioning: null,
                        submenuDirection: "auto",
                        visible: false,
                        target: window,
                        onLeftFirstItem: null,
                        onLeftLastItem: null,
                        onCloseRootSubmenu: null,
                        onExpandLastSubmenu: null
                    })
            },
            _initActions: function() {
                this._actions = {};
                $.each(ACTIONS, $.proxy(function(index, action) {
                    this._actions[action] = this._createActionByOption(action) || $.noop
                }, this))
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {
                    animation: true,
                    position: true,
                    selectedItem: true
                })
            },
            _itemContainer: function() {
                return this._overlay && this._overlay.content()
            },
            _supportedKeys: function() {
                var selectItem = function(e) {
                        var $item = this.option("focusedElement");
                        this.hide();
                        if (!$item || !this._isSelectionEnabled())
                            return;
                        this.selectItem($item[0])
                    };
                return $.extend(this.callBase(), {
                        space: selectItem,
                        esc: this.hide
                    })
            },
            _moveFocus: function(location) {
                var $items = this._getItemsByLocation(location),
                    $oldTarget = this._getActiveItem(true),
                    $newTarget,
                    $focusedItem = this.option("focusedElement");
                switch (location) {
                    case FOCUS_UP:
                        $newTarget = $focusedItem ? this._prevItem($items) : $items.last();
                        if ($oldTarget.is($items.first()))
                            this._actions.onLeftFirstItem($oldTarget);
                        break;
                    case FOCUS_DOWN:
                        $newTarget = $focusedItem ? this._nextItem($items) : $items.first();
                        if ($oldTarget.is($items.last()))
                            this._actions.onLeftLastItem($oldTarget);
                        break;
                    case FOCUS_RIGHT:
                        $newTarget = this.option("rtlEnabled") ? this._hideSubmenuHandler($items) : this._expandSubmenuHandler($items, location);
                        break;
                    case FOCUS_LEFT:
                        $newTarget = this.option("rtlEnabled") ? this._expandSubmenuHandler($items, location) : this._hideSubmenuHandler($items);
                        break;
                    case FOCUS_FIRST:
                        $newTarget = $items.first();
                        break;
                    case FOCUS_LAST:
                        $newTarget = $items.last();
                        break;
                    default:
                        return this.callBase(location)
                }
                if ($newTarget.length !== 0)
                    this.option("focusedElement", $newTarget)
            },
            _getItemsByLocation: function(location) {
                var $items,
                    $activeItem = this._getActiveItem(true),
                    expandedLocation = this.option("rtlEnabled") ? FOCUS_LEFT : FOCUS_RIGHT;
                if ($.inArray(location, LOCAL_SUBMENU_DIRECTIONS) >= 0)
                    $items = $activeItem.closest("." + DX_MENU_ITEMS_CONTAINER_CLASS).children().children();
                else {
                    $items = this._itemElements();
                    if (location !== expandedLocation)
                        $items = $items.filter(":visible")
                }
                return $items
            },
            _getAriaTarget: function() {
                return this.element()
            },
            _refreshActiveDescendant: function() {
                var $target = this._overlay.content(),
                    id = this.getFocusedItemId();
                if (!$target)
                    return this.callBase();
                this.setAria("activedescendant", "", $target);
                this.setAria("activedescendant", id, $target)
            },
            _hideSubmenuHandler: function($items) {
                var $curItem = this._getActiveItem(true),
                    $parentItem = $curItem.parents("." + DX_MENU_ITEM_EXPANDED_CLASS).first();
                if ($parentItem.length) {
                    this._hideSubmenusOnSameLevel($parentItem);
                    return $parentItem
                }
                this._actions.onCloseRootSubmenu($curItem);
                return $curItem
            },
            _expandSubmenuHandler: function($items, location) {
                var $curItem = this._getActiveItem(true),
                    node = this._dataAdapter.getNodeByItem(this._getItemData($curItem)),
                    isItemHasSubmenu = this._hasSubmenu(node),
                    $submenu = $curItem.children("." + DX_SUBMENU_CLASS);
                if (isItemHasSubmenu && !$curItem.hasClass(DX_STATE_DISABLED_CLASS)) {
                    if (!$submenu.length || $submenu.css("visibility") === "hidden")
                        this._showSubmenu($curItem);
                    return this._nextItem(this._getItemsByLocation(location))
                }
                this._actions.onExpandLastSubmenu($curItem);
                return $curItem
            },
            _render: function() {
                this.element().addClass(DX_HAS_CONTEXT_MENU_CLASS);
                this.callBase();
                this.setAria("role", "menu")
            },
            _renderContentImpl: function() {
                this._renderContextMenuOverlay();
                this._detachShowContextMenuEvents(this.option("target"));
                this._attachShowContextMenuEvents();
                this._attachInvokeContextMenuEvents();
                this.callBase()
            },
            _renderContextMenuOverlay: function() {
                var overlayOptions = this._getOverlayOptions(),
                    $overlayElement = $("<div>"),
                    $overlayContent;
                this._overlay = this._createComponent($overlayElement.appendTo(this._$element), "dxOverlay", overlayOptions);
                $overlayContent = this._overlay.content();
                $overlayContent.addClass(DX_CONTEXT_MENU_CLASS);
                this._addCustomCssClass($overlayContent);
                this._addPlatformDependentClass($overlayContent);
                if (this._overlay.option("visible"))
                    this._show()
            },
            _addPlatformDependentClass: function($element) {
                if (devices.current().phone)
                    $element.addClass(DX_MENU_PHONE_CLASS)
            },
            _detachShowContextMenuEvents: function(target) {
                var eventName = eventUtils.addNamespace("dxcontextmenu", this.NAME);
                $(target).off(eventName);
                this._overlay && this._overlay.content().off(eventName)
            },
            _attachShowContextMenuEvents: function() {
                var that = this,
                    eventName = eventUtils.addNamespace("dxcontextmenu", this.NAME),
                    contextMenuAction = this._createAction($.proxy(function(e) {
                        if (!that.option("alternativeInvocationMode").enabled)
                            that._show(e.jQueryEvent)
                    }, this), {validatingTargetName: "target"});
                contextMenuAction = this._createAction(contextMenuAction);
                this._overlay && this._overlay.content().on(eventName, $.noop);
                $(this.option("target")).on(eventName, $.proxy(function(e) {
                    contextMenuAction({
                        jQueryEvent: e,
                        target: $(e.currentTarget)
                    })
                }, this))
            },
            _attachInvokeContextMenuEvents: function() {
                var that = this,
                    eventName = eventUtils.addNamespace("dxclick", this.NAME),
                    contextMenuAction = this._createAction($.proxy(function() {
                        that.toggle()
                    }, this));
                if (this.option("alternativeInvocationMode").enabled && this._getInvokeTarget())
                    $(this._getInvokeTarget()).off(eventName).on(eventName, $.proxy(function(e) {
                        contextMenuAction({jQueryEvent: e})
                    }, this))
            },
            _getInvokeTarget: function() {
                return this.option("alternativeInvocationMode").invokingElement
            },
            _hoverEndHandler: function(e) {
                e.stopPropagation()
            },
            _renderDimensions: $.noop,
            _renderContainer: function($wrapper, submenuContainer) {
                var $itemsContainer,
                    $holder = submenuContainer || this._itemContainer();
                $wrapper = $("<div>");
                $wrapper.appendTo($holder).addClass(DX_SUBMENU_CLASS).css("visibility", submenuContainer ? "hidden" : "visible");
                $itemsContainer = this.callBase($wrapper);
                if (submenuContainer)
                    return $itemsContainer;
                if (this.option("width"))
                    return $itemsContainer.css("min-width", this.option("width"));
                if (this.option("height"))
                    return $itemsContainer.css("min-height", this.option("height"));
                return $itemsContainer
            },
            _renderSubmenuItems: function(node, $itemFrame) {
                this._renderItems(this._getChildNodes(node), $itemFrame)
            },
            _getOverlayOptions: function() {
                var position = this.option("position"),
                    overlayAnimation = this.option("animation"),
                    overlayOptions = {
                        focusStateEnabled: this.option("focusStateEnabled"),
                        animation: overlayAnimation,
                        closeOnOutsideClick: $.proxy(this._closeOnOutsideClickHandler, this),
                        closeOnTargetScroll: true,
                        deferRendering: false,
                        position: {
                            at: position.at,
                            my: position.my,
                            of: this.option("target"),
                            collision: "fit"
                        },
                        shading: false,
                        showTitle: false,
                        height: "auto",
                        width: "auto",
                        onShowing: $.proxy(this._overlayShowingActionHandler, this),
                        onShown: $.proxy(this._overlayShownActionHandler, this),
                        onHiding: $.proxy(this._overlayHidingActionHandler, this),
                        onHidden: $.proxy(this._overlayHiddenActionHandler, this),
                        onPositioned: $.proxy(this._overlayPositionedActionHandler, this),
                        onPositioning: $.proxy(this._overlayPositioningActionHandler, this)
                    };
                return overlayOptions
            },
            _overlayShowingActionHandler: function(arg) {
                this._actions.onShowing(arg);
                this._clearFocusedItem()
            },
            _overlayShownActionHandler: function(arg) {
                this._actions.onShown(arg);
                this._clearFocusedItem()
            },
            _clearFocusedItem: function() {
                this._removeFocusedItem();
                this.option("focusedElement", null)
            },
            _overlayHidingActionHandler: function(arg) {
                this._actions.onHiding(arg);
                if (!arg.cancel)
                    this._hideAllShownSubmenus()
            },
            _overlayHiddenActionHandler: function(arg) {
                this._actions.onHidden(arg);
                this._setOptionSilent("visible", false)
            },
            _overlayPositionedActionHandler: $.noop,
            _overlayPositioningActionHandler: $.noop,
            _closeOnOutsideClickHandler: function(e) {
                var $clickedItem,
                    $activeItemContainer,
                    $itemContainers,
                    $rootItem,
                    isRootItemClicked,
                    isInnerOverlayClicked,
                    isInvokeTarget = $(e.target).closest(this._getInvokeTarget());
                if (e.target === document)
                    return true;
                if (isInvokeTarget && isInvokeTarget.length)
                    return false;
                $activeItemContainer = this._getActiveItemsContainer(e.target);
                $itemContainers = this._getItemsContainers();
                $clickedItem = this._searchActiveItem(e.target);
                $rootItem = this.element().parents("." + DX_MENU_ITEM_CLASS);
                isRootItemClicked = $clickedItem[0] === $rootItem[0] && $clickedItem.length && $rootItem.length;
                isInnerOverlayClicked = this._isIncludeOverlay($activeItemContainer, $itemContainers) && $clickedItem.length;
                if (isInnerOverlayClicked || isRootItemClicked) {
                    if (this._getShowSubmenuMode() === "onClick")
                        this._hideAllShownChildSubmenus($clickedItem);
                    return false
                }
                return true
            },
            _getActiveItemsContainer: function(target) {
                return $(target).closest("." + DX_MENU_ITEMS_CONTAINER_CLASS)
            },
            _getItemsContainers: function() {
                return this._overlay._$content.find("." + DX_MENU_ITEMS_CONTAINER_CLASS)
            },
            _searchActiveItem: function(target) {
                return $(target).closest("." + DX_MENU_ITEM_CLASS).eq(0)
            },
            _isIncludeOverlay: function($activeOverlay, $allOverlays) {
                var isSame = false;
                $.each($allOverlays, function(index, $overlay) {
                    if ($activeOverlay.is($overlay) && !isSame)
                        isSame = true
                });
                return isSame
            },
            _hideAllShownChildSubmenus: function($clickedItem) {
                var that = this,
                    $submenuElements = $clickedItem.find("." + DX_SUBMENU_CLASS),
                    shownSubmenus = $.extend([], this._shownSubmenus),
                    $context;
                if ($submenuElements.length > 0)
                    $.each(shownSubmenus, function(index, $submenu) {
                        $context = that._searchActiveItem($submenu.context).parent();
                        if ($context.parent().is($clickedItem.parent().parent()) && !$context.is($clickedItem.parent()))
                            that._hideSubmenu($submenu)
                    })
            },
            _showSubmenu: function($item) {
                var node = this._dataAdapter.getNodeByItem(this._getItemData($item)),
                    isItemHasSubmenu = this._hasSubmenu(node),
                    isSubmenuVisible;
                this._hideSubmenusOnSameLevel($item);
                if (isItemHasSubmenu) {
                    this.callBase($item);
                    $item.closest("." + DX_MENU_ITEMS_CONTAINER_CLASS).find("." + DX_MENU_ITEM_EXPANDED_CLASS).removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                    if (!$item.children("." + DX_SUBMENU_CLASS).length)
                        this._renderSubmenuItems(node, $item, 2);
                    isSubmenuVisible = this._isSubmenuVisible($item.children("." + DX_SUBMENU_CLASS));
                    if (!isSubmenuVisible) {
                        $item.addClass(DX_MENU_ITEM_EXPANDED_CLASS);
                        this._drawSubmenu($item)
                    }
                }
            },
            _hideSubmenusOnSameLevel: function($item) {
                var $expandedItems = $item.closest("." + DX_MENU_ITEMS_CONTAINER_CLASS).find("." + DX_MENU_ITEM_EXPANDED_CLASS);
                if ($expandedItems.length) {
                    $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                    this._hideSubmenu($expandedItems.find("." + DX_SUBMENU_CLASS))
                }
            },
            _hideSubmenuGroup: function($submenu) {
                if (this._isSubmenuVisible($submenu))
                    this._hideSubmenuCore($submenu)
            },
            _isSubmenuVisible: function($submenu) {
                return $submenu.css("visibility") === "visible"
            },
            _drawSubmenu: function($itemElement) {
                var animation = this.option("animation") ? this.option("animation").show : {},
                    $submenu = $itemElement.children("." + DX_SUBMENU_CLASS);
                if (this._overlay && this._overlay.option("visible")) {
                    if (!commonUtils.isDefined(this._shownSubmenus))
                        this._shownSubmenus = [];
                    if ($.inArray($submenu, this._shownSubmenus))
                        this._shownSubmenus.push($submenu);
                    positionUtils.setup($submenu, this._getSubmenuPosition($itemElement));
                    animation && this._animate($submenu, animation);
                    $submenu.css("visibility", "visible")
                }
            },
            _animate: function($container, options) {
                fx.animate($container, options)
            },
            _getSubmenuPosition: function($rootItem) {
                var submenuDirection = this.option("submenuDirection").toLowerCase(),
                    $rootItemWrapper = $rootItem.parent("." + DX_MENU_ITEM_WRAPPER_CLASS),
                    position = {
                        collision: "flip",
                        of: $rootItemWrapper,
                        offset: {
                            h: 0,
                            v: -1
                        }
                    };
                switch (submenuDirection) {
                    case"left":
                        position.at = "left top";
                        position.my = "right top";
                        break;
                    case"right":
                        position.at = "right top";
                        position.my = "left top";
                        break;
                    default:
                        if (this.option("rtlEnabled")) {
                            position.at = "left top";
                            position.my = "right top"
                        }
                        else {
                            position.at = "right top";
                            position.my = "left top"
                        }
                        break
                }
                return position
            },
            _updateSubmenuVisibilityOnClick: function(actionArgs) {
                var $itemElement,
                    itemData,
                    node,
                    submenu,
                    $submenuElement,
                    notCloseMenuOnItemClick;
                if (actionArgs.args.length && actionArgs.args[0]) {
                    actionArgs.args[0].jQueryEvent.stopPropagation();
                    $itemElement = actionArgs.args[0].itemElement;
                    itemData = actionArgs.args[0].itemData;
                    node = this._dataAdapter.getNodeByItem(itemData);
                    if (!node)
                        return;
                    if ($itemElement.find("." + DX_CONTEXT_MENU_CLASS).length)
                        submenu = this._getSubmenuInstanceByRootElement($itemElement);
                    else
                        submenu = node.internalFields.childrenKeys.length && this._renderSubmenuItems(node, $itemElement, 2);
                    notCloseMenuOnItemClick = itemData && itemData.closeMenuOnClick === false;
                    $submenuElement = $itemElement.children("." + DX_SUBMENU_CLASS);
                    if ($itemElement.context === $submenuElement.context && $submenuElement.css("visibility") === "visible")
                        return;
                    if (!itemData || itemData.disabled || notCloseMenuOnItemClick)
                        return;
                    this._updateSelectedItemOnClick(actionArgs);
                    if ($submenuElement.length === 0) {
                        var $prevSubmenu = $($itemElement.parents("." + DX_SUBMENU_CLASS)[0]);
                        this._hideSubmenu($prevSubmenu);
                        if (!actionArgs.canceled && this._overlay && this._overlay.option("visible"))
                            this.option("visible", false)
                    }
                    else {
                        if (this._shownSubmenus && this._shownSubmenus.length > 0)
                            if (this._shownSubmenus[0].is($submenuElement) || this._shownSubmenus[0].has($submenuElement).length === 1)
                                this._hideSubmenu($submenuElement);
                            else
                                this._hideAllShownSubmenus();
                        this._showSubmenu($itemElement)
                    }
                }
            },
            _hideSubmenu: function($curSubmenu) {
                var that = this,
                    shownSubmenus = $.extend([], that._shownSubmenus);
                $.each(shownSubmenus, function(index, $submenu) {
                    if ($curSubmenu.is($submenu) || $curSubmenu.has($submenu).length) {
                        $submenu.parent().removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                        that._hideSubmenuCore($submenu)
                    }
                })
            },
            _hideSubmenuCore: function($submenu) {
                var index = $.inArray($submenu, this._shownSubmenus),
                    animation = this.option("animation") ? this.option("animation").hide : null;
                if (index >= 0)
                    this._shownSubmenus.splice(index, 1);
                this._stopAnimate($submenu);
                animation && this._animate($submenu, animation);
                $submenu.css("visibility", "hidden")
            },
            _stopAnimate: function($container) {
                fx.stop($container, true)
            },
            _hideAllShownSubmenus: function() {
                var that = this,
                    shownSubmenus = $.extend([], that._shownSubmenus),
                    $expandedItems = this._overlay.content().find("." + DX_MENU_ITEM_EXPANDED_CLASS);
                $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                $.each(shownSubmenus, function(_, $submenu) {
                    that._hideSubmenuCore($submenu)
                })
            },
            _visibilityChanged: function(visible) {
                if (visible) {
                    this._detachShowContextMenuEvents(this.option("target"));
                    this._attachShowContextMenuEvents();
                    this._attachInvokeContextMenuEvents()
                }
            },
            _optionChanged: function(args) {
                if (this._cancelOptionChange)
                    return;
                if ($.inArray(args.name, ACTIONS) > -1) {
                    this._initActions();
                    return
                }
                switch (args.name) {
                    case"visible":
                        this._toggleVisibility(args.value);
                        break;
                    case"alternativeInvocationMode":
                        this._invalidate();
                        break;
                    case"items":
                        if (this._overlay.option("visible"))
                            this._overlay.hide();
                        this.callBase(args);
                        break;
                    case"position":
                    case"submenuDirection":
                        this._invalidate();
                        break;
                    case"target":
                        args.previousValue && this._detachShowContextMenuEvents($(args.previousValue));
                        this._invalidate();
                        break;
                    case"focusedElement":
                        this.callBase(args);
                        break;
                    default:
                        if (this._overlay)
                            if (this._overlay.option("visible"))
                                this._overlay.hide();
                        this.callBase(args)
                }
            },
            _toggleVisibility: function(showing) {
                showing ? this._show() : this._hide()
            },
            _show: function(jQEvent) {
                var canShowMenu = !(this._overlay && this._positionContextMenu(jQEvent)),
                    id = new DevExpress.data.Guid,
                    promise;
                if (canShowMenu && this._overlay) {
                    this.option("focusedElement", this._itemElements().first());
                    promise = this._overlay.show();
                    this._overlay.content().attr({
                        id: id,
                        role: "menu"
                    });
                    this.setAria("owns", id);
                    this._setOptionSilent("visible", true)
                }
                return promise || $.Deferred().reject().promise()
            },
            _positionContextMenu: function(jQEvent) {
                var position = this.option("position"),
                    positioningAction = this._createActionByOption("onPositioning", actionArgs),
                    actionArgs;
                if (jQEvent && jQEvent.preventDefault)
                    position = {
                        at: "top left",
                        my: "top left",
                        of: jQEvent
                    };
                if (!position.of)
                    position.of = this.option("target");
                actionArgs = {
                    position: position,
                    jQueryEvent: jQEvent
                };
                positioningAction(actionArgs);
                if (!actionArgs.canceled && this._overlay)
                    position && this._overlay.option("position", position);
                else
                    actionArgs.jQueryEvent.cancel = true;
                return actionArgs.canceled
            },
            _hide: function() {
                var promise;
                if (this._overlay) {
                    this._overlay.content().removeAttr("id");
                    promise = this._overlay.hide();
                    this._setOptionSilent("visible", false)
                }
                this.setAria("owns", undefined);
                return promise || $.Deferred().reject().promise()
            },
            _clean: function() {
                if (this._overlay) {
                    this._overlay.element().remove();
                    this._overlay = null
                }
                this._detachShowContextMenuEvents($(this.option("target")))
            },
            toggle: function(showing) {
                var visible = this.option("visible");
                showing = showing === undefined ? !visible : showing;
                return showing ? this._show() : this._hide()
            },
            show: function() {
                return this.toggle(true)
            },
            hide: function() {
                return this.toggle(false)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.menu.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            positionUtils = DX.require("/utils/utils.position"),
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer"),
            hoverEvents = DX.require("/ui/events/ui.events.hover");
        var DX_MENU_CLASS = "dx-menu",
            DX_MENU_VERTICAL_CLASS = DX_MENU_CLASS + "-vertical",
            DX_MENU_HORIZONTAL_CLASS = DX_MENU_CLASS + "-horizontal",
            DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item",
            DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
            DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded",
            DX_CONTEXT_MENU_CLASS = "dx-context-menu",
            DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS = DX_CONTEXT_MENU_CLASS + "-container-border",
            DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS = "dx-context-menu-content-delimiter",
            DX_SUBMENU_CLASS = "dx-submenu",
            DX_STATE_DISABLED_CLASS = "dx-state-disabled",
            DX_STATE_FOCUSED_CLASS = "dx-state-focused",
            DX_STATE_HOVER_CLASS = "dx-state-hover",
            FOCUS_UP = "up",
            FOCUS_DOWN = "down",
            FOCUS_LEFT = "left",
            FOCUS_RIGHT = "right",
            SHOW_SUBMENU_OPERATION = "showSubmenu",
            NEXTITEM_OPERATION = "nextItem",
            PREVITEM_OPERATION = "prevItem",
            DEFAULT_SHOW_DELAY = 50,
            DEFAULT_HIDE_DELAY = 300,
            ACTIONS = ["onSubmenuShowing", "onSubmenuShown", "onSubmenuHiding", "onSubmenuHidden"],
            dxSubmenu = ui.dxContextMenu.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {orientation: "horizontal"})
                },
                _initDataAdapter: function() {
                    this._dataAdapter = this.option("_dataAdapter");
                    if (this._dataAdapter)
                        this._dataAdapter.options.rooValue = this.option("_parentKey");
                    else
                        this.callBase()
                },
                _renderContentImpl: function() {
                    this._renderContextMenuOverlay();
                    this._detachShowContextMenuEvents(this.option("target"));
                    this._attachShowContextMenuEvents();
                    this._attachInvokeContextMenuEvents();
                    var node = this._dataAdapter.getNodeByKey(this.option("_parentKey"));
                    node && this._renderItems(this._getChildNodes(node));
                    if (!this.option("_hideDelimiter"))
                        this._renderDelimiter()
                },
                _renderDelimiter: function() {
                    this.$contentDelimiter = $("<div>").appendTo(this._itemContainer()).addClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS)
                },
                _overlayPositionedActionHandler: function(arg) {
                    this._showDelimiter(arg)
                },
                _hoverEndHandler: function(e) {
                    this._toggleFocusClass(false, e.currentTarget)
                },
                _hoverStartHandler: function(e) {
                    this.callBase(e);
                    this._toggleFocusClass(true, e.currentTarget)
                },
                _showDelimiter: function(arg) {
                    var $submenu = this._itemContainer().children("." + DX_SUBMENU_CLASS).eq(0),
                        $rootItem = this.option("position").of,
                        position = {of: $submenu},
                        containerOffset,
                        rootOffset;
                    if (this.$contentDelimiter) {
                        containerOffset = arg.position;
                        rootOffset = $rootItem.offset();
                        this.$contentDelimiter.css("display", "block");
                        if (this.option("orientation") === "horizontal") {
                            this.$contentDelimiter.width($rootItem.width() < $submenu.width() ? $rootItem.width() - 2 : $submenu.width() - 2);
                            this.$contentDelimiter.height(2);
                            if (containerOffset.v.location > rootOffset.top)
                                if (Math.round(containerOffset.h.location) === Math.round(rootOffset.left)) {
                                    position.offset = "1 -1";
                                    position.at = "left top";
                                    position.my = "left top"
                                }
                                else {
                                    position.offset = "-1 -1";
                                    position.at = "right top";
                                    position.my = "right top"
                                }
                            else {
                                this.$contentDelimiter.height(5);
                                if (Math.round(containerOffset.h.location) === Math.round(rootOffset.left)) {
                                    position.offset = "1 4";
                                    position.at = "left bottom";
                                    position.my = "left bottom"
                                }
                                else {
                                    position.offset = "-1 2";
                                    position.at = "right bottom";
                                    position.my = "right bottom"
                                }
                            }
                        }
                        else if (this.option("orientation") === "vertical") {
                            this.$contentDelimiter.width(2);
                            this.$contentDelimiter.height($rootItem.height() < $submenu.height() ? $rootItem.height() - 2 : $submenu.height() - 2);
                            if (containerOffset.h.location > rootOffset.left)
                                if (Math.round(containerOffset.v.location) === Math.round(rootOffset.top)) {
                                    position.offset = "-1 1";
                                    position.at = "left top";
                                    position.my = "left top"
                                }
                                else {
                                    position.offset = "-1 -1";
                                    position.at = "left bottom";
                                    position.my = "left bottom"
                                }
                            else if (Math.round(containerOffset.v.location) === Math.round(rootOffset.top)) {
                                position.offset = "1 1";
                                position.at = "right top";
                                position.my = "right top"
                            }
                            else {
                                position.offset = "1 -1";
                                position.at = "right bottom";
                                position.my = "right bottom"
                            }
                        }
                        positionUtils.setup(this.$contentDelimiter, position)
                    }
                }
            });
        registerComponent("dxMenu", ui, ui.dxMenuBase.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        orientation: "horizontal",
                        submenuDirection: "auto",
                        showFirstSubmenuMode: {
                            name: "onClick",
                            delay: {
                                show: 50,
                                hide: 300
                            }
                        },
                        hideSubmenuOnMouseLeave: false,
                        onSubmenuShowing: null,
                        onSubmenuShown: null,
                        onSubmenuHiding: null,
                        onSubmenuHidden: null
                    })
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {
                    animation: true,
                    selectedItem: true
                })
            },
            _focusTarget: function() {
                return this.element()
            },
            _eventBindingTarget: function() {
                return this.element()
            },
            _getOrientation: function() {
                return this.option("orientation") === "vertical" ? "vertical" : "horizontal"
            },
            _isMenuHorizontal: function() {
                return this._getOrientation() === "horizontal"
            },
            _moveFocus: function(location) {
                var $items = this._itemElements().filter(":visible"),
                    isMenuHorizontal = this._isMenuHorizontal(),
                    argument,
                    $activeItem = this._getActiveItem(true),
                    operation,
                    navigationAction,
                    $newTarget;
                switch (location) {
                    case FOCUS_UP:
                        operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(PREVITEM_OPERATION);
                        argument = isMenuHorizontal ? $activeItem : $items;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    case FOCUS_DOWN:
                        operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(NEXTITEM_OPERATION);
                        argument = isMenuHorizontal ? $activeItem : $items;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    case FOCUS_RIGHT:
                        operation = isMenuHorizontal ? this._getItemsNavigationOperation(NEXTITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
                        argument = isMenuHorizontal ? $items : $activeItem;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    case FOCUS_LEFT:
                        operation = isMenuHorizontal ? this._getItemsNavigationOperation(PREVITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
                        argument = isMenuHorizontal ? $items : $activeItem;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    default:
                        return this.callBase(location)
                }
                if ($newTarget && $newTarget.length !== 0)
                    this.option("focusedElement", $newTarget)
            },
            _getItemsNavigationOperation: function(operation) {
                var navOperation = operation;
                if (this.option("rtlEnabled"))
                    navOperation = operation === PREVITEM_OPERATION ? NEXTITEM_OPERATION : PREVITEM_OPERATION;
                return navOperation
            },
            _getKeyboardNavigationAction: function(operation, argument) {
                var action = $.noop;
                switch (operation) {
                    case SHOW_SUBMENU_OPERATION:
                        if (!argument.hasClass(DX_STATE_DISABLED_CLASS))
                            action = $.proxy(this._showSubmenu, this, argument);
                        break;
                    case NEXTITEM_OPERATION:
                        action = $.proxy(this._nextItem, this, argument);
                        break;
                    case PREVITEM_OPERATION:
                        action = $.proxy(this._prevItem, this, argument);
                        break
                }
                return action
            },
            _init: function() {
                this.callBase();
                this._submenus = []
            },
            _initActions: function() {
                this._actions = {};
                $.each(ACTIONS, $.proxy(function(index, action) {
                    this._actions[action] = this._createActionByOption(action) || $.noop
                }, this))
            },
            _render: function() {
                this._visibleSubmenu = null;
                this.callBase();
                this.element().addClass(DX_MENU_CLASS);
                this.setAria("role", "menubar")
            },
            _getHideDelay: function() {
                var delay = this.option("showFirstSubmenuMode").delay;
                if (delay)
                    return commonUtils.isObject(delay) ? delay.hide : delay;
                else
                    return DEFAULT_HIDE_DELAY
            },
            _getShowDelay: function() {
                var delay = this.option("showFirstSubmenuMode").delay,
                    resultDelay;
                if (delay)
                    resultDelay = commonUtils.isObject(delay) ? delay.show : delay;
                else
                    resultDelay = DEFAULT_SHOW_DELAY;
                return resultDelay
            },
            _renderContainer: function() {
                var isVerticalMenu = this.option("orientation") === "vertical",
                    $wrapper = $("<div>");
                $wrapper.appendTo(this.element()).addClass(isVerticalMenu ? DX_MENU_VERTICAL_CLASS : DX_MENU_HORIZONTAL_CLASS);
                return this.callBase($wrapper).css("min-height", this._getValueHeight($wrapper))
            },
            _getValueHeight: function($root) {
                var $div = $("<div>").html("Jj").css({
                        width: "auto",
                        position: "fixed",
                        top: "-3000px",
                        left: "-3000px"
                    }).appendTo($root),
                    height = $div.height();
                $div.remove();
                return height
            },
            _renderSubmenuItems: function(node, $itemFrame) {
                var submenu = this._createSubmenu(node, $itemFrame);
                this._submenus.push(submenu);
                this._renderBorderElement($itemFrame);
                return submenu
            },
            _createSubmenu: function(node, $rootItem) {
                var $submenuContainer = $("<div>").addClass(DX_CONTEXT_MENU_CLASS).appendTo($rootItem);
                var items = this._getChildNodes(node),
                    result = this._createComponent($submenuContainer, "dxSubmenu", $.extend(this._getSubmenuOptions(), {
                        _dataAdapter: this._dataAdapter,
                        _parentKey: node.internalFields.key,
                        items: items,
                        position: this.getSubmenuPosition($rootItem)
                    }));
                this._attachSubmenuHandlers($rootItem, result);
                return result
            },
            _getSubmenuOptions: function() {
                var $submenuTarget = $("<div>"),
                    isMenuHorizontal = this._isMenuHorizontal();
                return {
                        itemTemplate: this.option("itemTemplate"),
                        templateProvider: this.option("templateProvider"),
                        target: $submenuTarget,
                        orientation: this.option("orientation"),
                        selectionMode: this.option("selectionMode"),
                        selectionByClick: this.option("selectionByClick"),
                        cssClass: this.option("cssClass"),
                        hoverStateEnabled: this.option("hoverStateEnabled"),
                        activeStateEnabled: this.option("activeStateEnabled"),
                        focusStateEnabled: this.option("focusStateEnabled"),
                        animation: this.option("animation"),
                        showSubmenuMode: this.option("showSubmenuMode"),
                        displayExpr: this.option("displayExpr"),
                        disabledExpr: this.option("disabledExpr"),
                        selectedExpr: this.option("selectedExpr"),
                        itemsExpr: this.option("itemsExpr"),
                        onSelectionChanged: $.proxy(this._nestedItemOnSelectionChangedHandler, this),
                        onItemClick: $.proxy(this._nestedItemOnItemClickHandler, this),
                        onItemRendered: this.option("onItemRendered"),
                        onLeftFirstItem: isMenuHorizontal ? null : $.proxy(this._moveMainMenuFocus, this, PREVITEM_OPERATION),
                        onLeftLastItem: isMenuHorizontal ? null : $.proxy(this._moveMainMenuFocus, this, NEXTITEM_OPERATION),
                        onCloseRootSubmenu: isMenuHorizontal ? $.proxy(this._moveMainMenuFocus, this, PREVITEM_OPERATION) : null,
                        onExpandLastSubmenu: isMenuHorizontal ? $.proxy(this._moveMainMenuFocus, this, NEXTITEM_OPERATION) : null,
                        _remoteSelectionSync: true,
                        _hideDelimiter: this.option("_hideDelimiter")
                    }
            },
            _getShowFirstSubmenuMode: function() {
                var modeName;
                if (commonUtils.isObject(this.option("showFirstSubmenuMode")))
                    modeName = this._isDesktopDevice() ? this.option("showFirstSubmenuMode").name : "onClick";
                else
                    modeName = this._isDesktopDevice() ? this.option("showFirstSubmenuMode") : "onClick";
                return modeName
            },
            _moveMainMenuFocus: function(direction) {
                var $expandedItem = this.element().find("." + DX_MENU_ITEM_EXPANDED_CLASS).first(),
                    $newItem;
                switch (direction) {
                    case PREVITEM_OPERATION:
                        $newItem = $expandedItem.parent().prev();
                        if (!$newItem.length)
                            $newItem = $expandedItem.parent().siblings().last();
                        $newItem = $newItem.children();
                        break;
                    case NEXTITEM_OPERATION:
                        $newItem = $expandedItem.parent().next();
                        if (!$newItem.length)
                            $newItem = $expandedItem.parent().siblings().first();
                        $newItem = $newItem.children();
                        break
                }
                this._visibleSubmenu && this._hideSubmenu(this._visibleSubmenu);
                this.focus();
                this.option("focusedElement", $newItem)
            },
            _nestedItemOnSelectionChangedHandler: function(args) {
                var selectedItem = args.addedItems.length && args.addedItems[0],
                    submenu = args.element.dxSubmenu("instance"),
                    onSelectionChanged = this._createActionByOption("onSelectionChanged", {});
                onSelectionChanged(args);
                selectedItem && this._clearSelectionInSubmenus(selectedItem[0], submenu);
                this._clearRootSelection();
                this._setOptionSilent("selectedItem", selectedItem)
            },
            _clearSelectionInSubmenus: function(item, targetSubmenu) {
                var that = this,
                    cleanAllSubmenus = !arguments.length;
                $.each(this._submenus, function(index, submenu) {
                    var $submenu = submenu._itemContainer(),
                        isOtherItem = !$submenu.is(targetSubmenu && targetSubmenu._itemContainer()),
                        $selectedItem = $submenu.find("." + that._selectedItemClass());
                    if (isOtherItem && $selectedItem.length || cleanAllSubmenus) {
                        var selectedItemData;
                        $selectedItem.removeClass(that._selectedItemClass());
                        selectedItemData = that._getItemData($selectedItem);
                        if (selectedItemData)
                            selectedItemData.selected = false;
                        submenu._clearSelectedItems()
                    }
                })
            },
            _clearRootSelection: function() {
                var $prevSelectedItem = this.element().find("." + DX_MENU_ITEMS_CONTAINER_CLASS).first().children().children().filter("." + this._selectedItemClass());
                if ($prevSelectedItem.length) {
                    var prevSelectedItemData;
                    prevSelectedItemData = this._getItemData($prevSelectedItem);
                    prevSelectedItemData.selected = false;
                    $prevSelectedItem.removeClass(this._selectedItemClass())
                }
            },
            _nestedItemOnItemClickHandler: function(arg) {
                var onItemClick = this._createActionByOption("onItemClick", {});
                onItemClick(arg)
            },
            _attachSubmenuHandlers: function($rootItem, submenu) {
                var that = this,
                    $submenuOverlayContent = submenu._overlay.content(),
                    submenus = $submenuOverlayContent.find("." + DX_SUBMENU_CLASS),
                    submenuMouseLeaveName = eventUtils.addNamespace(hoverEvents.end, this.NAME + "_submenu");
                submenu.option({
                    onShowing: $.proxy(this._submenuOnShowingHandler, this, $rootItem, submenu),
                    onShown: $.proxy(this._submenuOnShownHandler, this, $rootItem, submenu),
                    onHiding: $.proxy(this._submenuOnHidingHandler, this, $rootItem, submenu),
                    onHidden: $.proxy(this._submenuOnHiddenHandler, this, $rootItem, submenu)
                });
                $.each(submenus, function(index, submenu) {
                    $(submenu).off(submenuMouseLeaveName).on(submenuMouseLeaveName, null, $.proxy(that._submenuMouseLeaveHandler, that, $rootItem))
                })
            },
            _submenuOnShowingHandler: function($rootItem, submenu) {
                var $border = $rootItem.children("." + DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS);
                this._actions.onSubmenuShowing({
                    rootItem: $rootItem,
                    submenu: submenu
                });
                if (this._options.width !== undefined)
                    if (this._options.rtlEnabled)
                        $border.css("width", this._$element.width() - $rootItem.position().right);
                    else
                        $border.css("width", this._$element.width() - $rootItem.position().left);
                $border.show();
                $rootItem.addClass(DX_MENU_ITEM_EXPANDED_CLASS)
            },
            _submenuOnShownHandler: function($rootItem, submenu) {
                this._actions.onSubmenuShown({
                    rootItem: $rootItem,
                    submenu: submenu
                })
            },
            _submenuOnHidingHandler: function($rootItem, submenu, eventArgs) {
                var $border = $rootItem.children("." + DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS),
                    args = eventArgs;
                args.rootItem = $rootItem;
                args.submenu = submenu;
                this._actions.onSubmenuHiding(args);
                eventArgs = args;
                if (!eventArgs.cancel) {
                    $border.hide();
                    $rootItem.removeClass(DX_MENU_ITEM_EXPANDED_CLASS)
                }
            },
            _submenuOnHiddenHandler: function($rootItem, submenu) {
                this._actions.onSubmenuHidden({
                    rootItem: $rootItem,
                    submenu: submenu
                })
            },
            _submenuMouseLeaveHandler: function($rootItem, eventArgs) {
                var that = this,
                    target = $(eventArgs.relatedTarget).parents("." + DX_CONTEXT_MENU_CLASS)[0],
                    contextmenu = this._getSubmenuElementByRootElement($rootItem).dxSubmenu("instance")._overlay.content()[0];
                if (this.option("hideSubmenuOnMouseLeave") && target !== contextmenu) {
                    clearTimeout(this._showSubmenuTimer);
                    clearTimeout(this._hideSubmenuTimer);
                    setTimeout($.proxy(this._hideSubmenuAfterTimeout, this), that._getHideDelay(), $rootItem)
                }
            },
            _hideSubmenuAfterTimeout: function($rootItem) {
                var $submenu = this._getSubmenuElementByRootElement($rootItem),
                    hasVisibleSubmenu = this._visibleSubmenu,
                    isRootItemHovered = hasVisibleSubmenu && $(this._visibleSubmenu.context).hasClass(DX_STATE_HOVER_CLASS);
                if (hasVisibleSubmenu && !this._getFocusedSubmenuItem(this._visibleSubmenu).length && !isRootItemHovered)
                    $submenu.length && this._getSubmenuInstance($submenu).hide()
            },
            _getFocusedSubmenuItem: function($submenu) {
                return $submenu._overlay.content().find("." + DX_STATE_FOCUSED_CLASS)
            },
            _getSubmenuInstance: function($submenu) {
                return $submenu.data().dxSubmenu
            },
            _getSubmenuElementByRootElement: function($rootItem) {
                return $rootItem && $rootItem.children("." + DX_CONTEXT_MENU_CLASS)
            },
            _getSubmenuInstanceByRootElement: function($rootItem) {
                var $submenu = this._getSubmenuElementByRootElement($rootItem);
                return $submenu.length && this._getSubmenuInstance($submenu)
            },
            getSubmenuPosition: function($rootItem) {
                var isVerticalMenu = this.option("orientation").toLowerCase() === "vertical",
                    submenuDirection = this.option("submenuDirection").toLowerCase(),
                    rtlEnabled = this.option("rtlEnabled"),
                    submenuPosition = {
                        collision: "flip",
                        of: $rootItem
                    };
                switch (submenuDirection) {
                    case"leftortop":
                        submenuPosition.at = isVerticalMenu ? "left top" : "left top";
                        submenuPosition.my = isVerticalMenu ? "right top" : "left bottom";
                        break;
                    case"rightorbottom":
                        submenuPosition.at = isVerticalMenu ? "right top" : "left bottom";
                        submenuPosition.my = isVerticalMenu ? "left top" : "left top";
                        break;
                    default:
                        if (isVerticalMenu) {
                            submenuPosition.at = rtlEnabled ? "left top" : "right top";
                            submenuPosition.my = rtlEnabled ? "right top" : "left top"
                        }
                        else {
                            submenuPosition.at = rtlEnabled ? "right bottom" : "left bottom";
                            submenuPosition.my = rtlEnabled ? "right top" : "left top"
                        }
                        break
                }
                return submenuPosition
            },
            _renderBorderElement: function($item) {
                $("<div>").appendTo($item).addClass(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS).hide()
            },
            _hoverStartHandler: function(e) {
                var mouseMoveEventName = eventUtils.addNamespace(pointerEvents.move, this.NAME),
                    $item = this._getItemElementByEventArgs(e),
                    node = this._dataAdapter.getNodeByItem(this._getItemData($item)),
                    isSelectionActive = commonUtils.isDefined(e.buttons) && e.buttons === 1 || !commonUtils.isDefined(e.buttons) && e.which === 1;
                if (this._isItemDisabled($item))
                    return;
                $item.off(mouseMoveEventName);
                if (this._getShowFirstSubmenuMode() === "onHover" && node.internalFields.childrenKeys.length && !isSelectionActive) {
                    var submenu;
                    if ($item.find("." + DX_CONTEXT_MENU_CLASS).length)
                        submenu = this._getSubmenuInstanceByRootElement($item);
                    else
                        submenu = node.internalFields.childrenKeys.length && this._renderSubmenuItems(node, $item);
                    clearTimeout(this._hideSubmenuTimer);
                    clearTimeout(this._showSubmenuTimer);
                    if (!submenu._overlay.option("visible")) {
                        $item.on(mouseMoveEventName, $.proxy(this._itemMouseMoveHandler, this));
                        this._showSubmenuTimer = this._getHideDelay()
                    }
                    if (submenu === this._visibleSubmenu)
                        this._hideSubmenu(this._visibleSubmenu)
                }
            },
            _hoverEndHandler: function(eventArg) {
                var that = this,
                    $item = this._getItemElementByEventArgs(eventArg);
                if (this._isItemDisabled($item))
                    return;
                if ($(eventArg.relatedTarget).hasClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS))
                    return;
                if (this.option("hideSubmenuOnMouseLeave") && !$(eventArg.relatedTarget).hasClass(DX_MENU_ITEMS_CONTAINER_CLASS)) {
                    clearTimeout(this._showSubmenuTimer);
                    clearTimeout(this._hideSubmenuTimer);
                    this._hideSubmenuTimer = setTimeout(function() {
                        that._hideSubmenuAfterTimeout($item)
                    }, that._getHideDelay())
                }
            },
            _showSubmenu: function($itemElement) {
                var node = this._dataAdapter.getNodeByItem(this._getItemData($itemElement)),
                    submenu;
                if ($itemElement.find("." + DX_CONTEXT_MENU_CLASS).length)
                    submenu = this._getSubmenuInstanceByRootElement($itemElement);
                else
                    submenu = node.internalFields.childrenKeys.length && this._renderSubmenuItems(node, $itemElement);
                if (this._visibleSubmenu && this._visibleSubmenu !== submenu)
                    this._hideSubmenu(this._visibleSubmenu);
                submenu && submenu.show();
                this._visibleSubmenu = submenu;
                this._hoveredRootItem = $itemElement
            },
            _hideSubmenu: function(submenu) {
                submenu && submenu.hide();
                if (this._visibleSubmenu && this._visibleSubmenu === submenu)
                    this._visibleSubmenu = null;
                this._hoveredRootItem = null
            },
            _itemMouseMoveHandler: function(e) {
                if (e.pointers && e.pointers.length)
                    return;
                var that = this,
                    $item = $(e.currentTarget);
                if (!this._showSubmenuTimer)
                    return;
                clearTimeout(this._hideSubmenuTimer);
                clearTimeout(this._showSubmenuTimer);
                this._showSubmenuTimer = setTimeout(function() {
                    var node = that._dataAdapter.getNodeByItem(that._getItemData($item)),
                        submenu;
                    if ($item.find("." + DX_CONTEXT_MENU_CLASS).length)
                        submenu = that._getSubmenuInstanceByRootElement($item);
                    else
                        submenu = node.internalFields.childrenKeys.length && that._renderSubmenuItems(node, $item);
                    if (submenu && !submenu._overlay.option("visible"))
                        that._showSubmenu($item)
                }, that._getShowDelay())
            },
            _updateSubmenuVisibilityOnClick: function(actionArgs) {
                var $itemFrame,
                    node,
                    submenu,
                    args = actionArgs.args.length && actionArgs.args[0];
                if (args) {
                    args.jQueryEvent.stopPropagation();
                    node = this._dataAdapter.getNodeByItem(args.itemData);
                    $itemFrame = args.itemElement;
                    if (node.disabled)
                        return;
                    if ($itemFrame.find("." + DX_CONTEXT_MENU_CLASS).length)
                        submenu = this._getSubmenuInstanceByRootElement($itemFrame);
                    else
                        submenu = node.internalFields.childrenKeys.length && this._renderSubmenuItems(node, $itemFrame);
                    this._updateSelectedItemOnClick(actionArgs);
                    if (submenu)
                        if (submenu._overlay.option("visible")) {
                            if (this._getShowFirstSubmenuMode() === "onClick")
                                this._hideSubmenu(submenu)
                        }
                        else
                            this._showSubmenu($itemFrame);
                    else if (this._visibleSubmenu)
                        this._hideSubmenu(this._visibleSubmenu)
                }
            },
            _optionChanged: function(args) {
                if (this._cancelOptionChange)
                    return;
                this._hideShownSubmenuOnOptionChange(args.name);
                switch (args.name) {
                    case"orientation":
                    case"submenuDirection":
                    case"hideSubmenuOnMouseLeave":
                    case"showFirstSubmenuMode":
                        this._invalidate();
                        break;
                    case"showSubmenuMode":
                        this._changeSubmenusOption(args.name, args.value);
                        break;
                    case"onSubmenuShowing":
                    case"onSubmenuShown":
                    case"onSubmenuHiding":
                    case"onSubmenuHidden":
                        this._initActions();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _hideShownSubmenuOnOptionChange: function(optionName) {
                if (optionName !== "focusedElement" && this._visibleSubmenu)
                    this._hideSubmenu(this._visibleSubmenu)
            },
            _changeSubmenusOption: function(name, value) {
                $.each(this._submenus, function(index, submenu) {
                    submenu.option(name, value)
                })
            },
            selectItem: function(itemElement) {
                this._hideSubmenu(this._visibleSubmenu);
                this.callBase(itemElement)
            },
            unselectItem: function(itemElement) {
                this._hideSubmenu(this._visibleSubmenu);
                this.callBase(itemElement)
            }
        }));
        registerComponent("dxSubmenu", ui.dxMenu, dxSubmenu);
        ui.dxMenu.__internals = {}
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.treeView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            CheckBox = DX.require("/ui/widgets/ui.checkBox"),
            HierarchicalCollectionWidget = DX.require("/ui/hierarchicalCollectionWidget/ui.hierarchicalCollectionWidget"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer");
        var WIDGET_CLASS = "dx-treeview",
            NODE_CONTAINER_CLASS = "dx-treeview-node-container",
            OPENED_NODE_CONTAINER_CLASS = "dx-treeview-node-container-opened",
            NODE_CLASS = "dx-treeview-node",
            ITEM_CLASS = "dx-treeview-item",
            ITEM_WITH_CHECKBOX_CLASS = "dx-treeview-item-with-checkbox",
            ITEM_DATA_KEY = "dx-treeview-item-data",
            IS_LEAF = "dx-treeview-node-is-leaf",
            TOGGLE_ITEM_VISIBILITY_CLASS = "dx-treeview-toggle-item-visibility",
            TOGGLE_ITEM_VISIBILITY_OPENED_CLASS = "dx-treeview-toggle-item-visibility-opened",
            SELECT_ALL_ITEM_CLASS = "dx-treeview-select-all-item",
            DISABLED_STATE_CLASS = "dx-state-disabled",
            SELECTED_ITEM_CLASS = "dx-state-selected",
            DATA_ITEM_ID = "data-item-id",
            DBLCLICK_EVENT_NAME = "dxdblclick";
        var scrollableContainerUpdatedOnInit = $.noop;
        registerComponent("dxTreeView", ui, HierarchicalCollectionWidget.inherit({
            _supportedKeys: function(e) {
                var click = function(e) {
                        var $itemElement = this.option("focusedElement");
                        if (!$itemElement)
                            return;
                        e.target = $itemElement;
                        e.currentTarget = $itemElement;
                        this._itemClickHandler(e, $itemElement.find(">." + ITEM_CLASS))
                    };
                var select = function(e) {
                        e.preventDefault();
                        this._changeCheckBoxState(this.option("focusedElement"))
                    };
                var toggleExpandedNestedItems = function(state, e) {
                        if (!this.option("expandAllEnabled"))
                            return;
                        e.preventDefault();
                        var $rootElement = this.option("focusedElement");
                        if (!$rootElement)
                            return;
                        var rootItem = this._getItemData($rootElement.find("." + ITEM_CLASS));
                        this._toggleExpandedNestedItems([rootItem], state)
                    };
                return $.extend(this.callBase(), {
                        enter: this._showCheckboxes() ? select : click,
                        space: this._showCheckboxes() ? select : click,
                        asterisk: $.proxy(toggleExpandedNestedItems, this, true),
                        minus: $.proxy(toggleExpandedNestedItems, this, false)
                    })
            },
            _changeCheckBoxState: function($element) {
                var checkboxInstance = this._getCheckBoxInstance($element),
                    currentState = checkboxInstance.option("value");
                if (!checkboxInstance.option("disabled"))
                    this._updateItemSelection(!currentState, $element.find("." + ITEM_CLASS).get(0), true, $element)
            },
            _toggleExpandedNestedItems: function(items, state) {
                if (!items)
                    return;
                for (var i = 0, len = items.length; i < len; i++) {
                    var item = items[i],
                        node = this._dataAdapter.getNodeByItem(item);
                    this._toggleExpandedState(node, state);
                    this._toggleExpandedNestedItems(item.items, state)
                }
            },
            _getNodeElementById: function(id) {
                return this.element().find("[" + DATA_ITEM_ID + "='" + id + "']")
            },
            _activeStateUnit: "." + ITEM_CLASS,
            _widgetClass: function() {
                return WIDGET_CLASS
            },
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        animationEnabled: true,
                        dataStructure: "tree",
                        expandAllEnabled: false,
                        hasItemsExpr: "hasItems",
                        selectNodesRecursive: true,
                        expandNodesRecursive: true,
                        showCheckBoxesMode: "none",
                        selectAllText: Globalize.localize("dxList-selectAll"),
                        onItemSelected: null,
                        onItemExpanded: null,
                        onItemCollapsed: null,
                        scrollDirection: "vertical",
                        virtualModeEnabled: false,
                        rootValue: 0,
                        searchValue: "",
                        focusStateEnabled: false,
                        selectionMode: "multi"
                    })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    showCheckBoxes: {
                        since: "15.2",
                        message: "use 'showCheckBoxesMode' option instead"
                    },
                    selectAllEnabled: {
                        since: "15.2",
                        message: "use 'showCheckBoxesMode' option instead"
                    }
                })
            },
            _initSelectedItems: $.noop,
            _syncSelectionOptions: $.noop,
            _fireSelectionChanged: function() {
                var selectionChangePromise = this._selectionChangePromise;
                $.when(selectionChangePromise).done($.proxy(function() {
                    this._createActionByOption("onSelectionChanged", {excludeValidators: ["disabled", "readOnly"]})()
                }, this))
            },
            _renderItemFrame: function(index, itemData) {
                var $itemFrame = this.callBase.apply(this, arguments);
                $itemFrame.toggleClass(DISABLED_STATE_CLASS, !!this._disabledGetter(itemData));
                return $itemFrame
            },
            _checkBoxModeChange: function(value, previousValue) {
                if (previousValue === "none" || value === "none") {
                    this.repaint();
                    return
                }
                var selectAllExists = this._$selectAllItem && this._$selectAllItem.length;
                switch (value) {
                    case"selectAll":
                        !selectAllExists && this._renderSelectAllItem();
                        break;
                    case"normal":
                        if (selectAllExists) {
                            this._$selectAllItem.remove();
                            delete this._$selectAllItem
                        }
                        break
                }
            },
            _optionChanged: function(args) {
                var name = args.name,
                    value = args.value,
                    previousValue = args.previousValue;
                switch (name) {
                    case"showCheckBoxes":
                        this.option("showCheckBoxesMode", value ? "normal" : "none");
                        break;
                    case"selectAllEnabled":
                        this.option("showCheckBoxesMode", value ? "selectAll" : "normal");
                        break;
                    case"selectAllText":
                        if (this._$selectAllItem)
                            this._$selectAllItem.dxCheckBox("instance").option("text", value);
                        break;
                    case"showCheckBoxesMode":
                        this._checkBoxModeChange(value, previousValue);
                        break;
                    case"scrollDirection":
                        this._scrollableContainer.option("direction", value);
                        break;
                    case"items":
                        delete this._$selectAllItem;
                        this.callBase(args);
                        break;
                    case"hasItemsExpr":
                        this._initAccessors();
                        this.repaint();
                        break;
                    case"dataStructure":
                    case"rootValue":
                    case"searchValue":
                        this._initDataAdapter();
                        this.repaint();
                        break;
                    case"selectNodesRecursive":
                    case"expandNodesRecursive":
                    case"onItemSelected":
                    case"onItemExpanded":
                    case"onItemCollapsed":
                    case"expandAllEnabled":
                    case"animationEnabled":
                    case"virtualModeEnabled":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _initDataSource: function() {
                this.callBase();
                if (this._isVirtualMode())
                    this._dataSource.filter(this.option("parentIdExpr"), this.option("rootValue"))
            },
            _dataSourceLoadErrorHandler: function() {
                this._renderEmptyMessage()
            },
            _init: function() {
                this.callBase();
                this._initCheckBoxesMode()
            },
            _getAccessors: function() {
                return ["key", "display", "selected", "expanded", "items", "parentId", "disabled", "hasItems"]
            },
            _getDataAdapterOptions: function() {
                return {
                        rootValue: this.option("rootValue"),
                        recursiveSelection: this.option("selectNodesRecursive"),
                        recursiveExpansion: this.option("expandNodesRecursive"),
                        searchValue: this.option("searchValue"),
                        dataType: this.option("dataStructure")
                    }
            },
            _render: function() {
                var that = this;
                this.element().off(pointerEvents.down).on(pointerEvents.down, function(e) {
                    var $target = $(e.target).closest(that._activeStateUnit);
                    if (!$target.length)
                        e.preventDefault()
                });
                this.callBase();
                this.setAria("role", "tree")
            },
            _renderContentImpl: function() {
                if (this.option("items").length) {
                    this._renderScrollableContainer();
                    var $nodeContainer = this._renderNodeContainer();
                    this._scrollableContainer.content().append($nodeContainer);
                    this._renderItems($nodeContainer, this._dataAdapter.getRootNodes());
                    if (this._selectAllEnabled())
                        this._renderSelectAllItem($nodeContainer)
                }
                this._renderEmptyMessage()
            },
            _isVirtualMode: function() {
                return this.option("virtualModeEnabled") && this._isDataStructurePlain() && this.option("dataSource")
            },
            _isDataStructurePlain: function() {
                return this.option("dataStructure") === "plain"
            },
            _fireContentReadyAction: function() {
                this.callBase();
                if (this._scrollableContainer && this._scrollableContainer.content().height() > this.element().height()) {
                    this._scrollableContainer.update();
                    scrollableContainerUpdatedOnInit()
                }
            },
            _renderScrollableContainer: function() {
                this._scrollableContainer = this._createComponent($("<div>").appendTo(this.element()), "dxScrollable", {
                    direction: this.option("scrollDirection"),
                    useKeyboard: false
                })
            },
            _renderNodeContainer: function($parent) {
                var $container = $("<ul>").addClass(NODE_CONTAINER_CLASS);
                this.setAria("role", "group", $container);
                if ($parent) {
                    var itemData = this._getItemData($parent.find("> ." + ITEM_CLASS));
                    if (this._expandedGetter(itemData))
                        $container.addClass(OPENED_NODE_CONTAINER_CLASS);
                    $container.appendTo($parent)
                }
                return $container
            },
            _createDOMElement: function($nodeContainer, node) {
                var $node = $("<li>").addClass(NODE_CLASS).attr(DATA_ITEM_ID, node.internalFields.key).prependTo($nodeContainer);
                this.setAria({
                    role: "treeitem",
                    label: this._displayGetter(node.internalFields.item) || "",
                    expanded: node.internalFields.expanded || false
                }, $node);
                return $node
            },
            _showCheckboxes: function() {
                return this.option("showCheckBoxesMode") !== "none"
            },
            _selectAllEnabled: function() {
                return this.option("showCheckBoxesMode") === "selectAll"
            },
            _initCheckBoxesMode: function() {
                this._suppressDeprecatedWarnings();
                if (this.option("showCheckBoxesMode") !== "none")
                    return;
                this._suppressDeprecatedWarnings();
                var showCheckboxes = this.option("showCheckBoxes"),
                    selectAllEnabled = this.option("selectAllEnabled");
                this._resumeDeprecatedWarnings();
                this.option("showCheckBoxesMode", showCheckboxes ? selectAllEnabled ? "selectAll" : "normal" : "none");
                this._resumeDeprecatedWarnings()
            },
            _renderItems: function($nodeContainer, nodes) {
                var length = nodes.length - 1;
                for (var i = length; i >= 0; i--) {
                    var node = nodes[i];
                    var $node = this._createDOMElement($nodeContainer, node);
                    this._showCheckboxes() && this._renderCheckBox($node, node);
                    var $item = this._renderItem.call(this, node.internalFields.key, node.internalFields.item, $node);
                    this._attachDblclickToItem($item, node);
                    this._renderChildren($node, node)
                }
                this._renderFocusTarget()
            },
            _renderChildren: function($node, node) {
                if (this._hasChildren(node)) {
                    this._renderToggleItemVisibilityIcon($node, node);
                    this._renderSublevel($node, node)
                }
                else
                    this._addLeafClass($node)
            },
            _hasChildren: function(node) {
                if (this._isVirtualMode())
                    return this._hasItemsGetter(node.internalFields.item) !== false;
                return this.callBase(node)
            },
            _renderSublevel: function($node, node) {
                var $nestedNodeContainer = this._renderNodeContainer($node, node);
                if (!node.internalFields.expanded)
                    return;
                var childrenNodes = this._getChildNodes(node);
                this._renderItems($nestedNodeContainer, childrenNodes);
                $nestedNodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS)
            },
            _executeItemRenderAction: function(index, itemData, itemElement) {
                var node = this._dataAdapter.getNodeByItem(itemData);
                this._getItemRenderAction()({
                    itemElement: itemElement,
                    itemIndex: index,
                    itemData: itemData,
                    node: node
                })
            },
            _addLeafClass: function($node) {
                $node.addClass(IS_LEAF)
            },
            _attachDblclickToItem: function($item, node) {
                var that = this,
                    eventName = eventUtils.addNamespace(DBLCLICK_EVENT_NAME, that.NAME);
                $item.off(eventName).on(eventName, function(e) {
                    that._toggleExpandedState(node, undefined, e)
                })
            },
            _convertItemElementToNode: function(itemElement) {
                if (!itemElement || itemElement.internalFields)
                    return itemElement;
                var itemData = $(itemElement).get(0).nodeType ? this._getItemData($(itemElement)) : itemElement,
                    node = this._dataAdapter.getNodeByItem(itemData);
                return node
            },
            _toggleExpandedState: function(itemElement, state, e) {
                var node = this._convertItemElementToNode(itemElement);
                if (this._isVirtualMode()) {
                    var $node = this._getNodeElementById(node.internalFields.key);
                    this._createLoadIndicator($node)
                }
                var currentState = node.internalFields.expanded;
                if (node.internalFields.disabled || commonUtils.isDefined(currentState) && currentState === state)
                    return;
                if (!commonUtils.isDefined(state))
                    state = !currentState;
                this._dataAdapter.toggleExpansion(node.internalFields.key, state);
                node.internalFields.expanded = state;
                this._updateExpandedItemsUI(node, state, e)
            },
            _createLoadIndicator: function($node) {
                var $icon = $node.find(">." + TOGGLE_ITEM_VISIBILITY_CLASS),
                    $nodeContainer = $node.find(" > ." + NODE_CONTAINER_CLASS);
                if (!$icon.hasClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS) && $nodeContainer.is(":empty")) {
                    this._createComponent("<div>", "dxLoadIndicator", {}).element().appendTo($node);
                    $icon.hide()
                }
            },
            _renderToggleItemVisibilityIcon: function($node, node) {
                var $icon = $("<div>").addClass(TOGGLE_ITEM_VISIBILITY_CLASS).appendTo($node);
                if (node.internalFields.expanded && !this._isVirtualMode()) {
                    $icon.addClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS);
                    $node.parent().addClass(OPENED_NODE_CONTAINER_CLASS)
                }
                if (node.internalFields.disabled)
                    $icon.addClass(DISABLED_STATE_CLASS);
                this._renderToggleItemVisibilityIconClick($icon, node)
            },
            _renderToggleItemVisibilityIconClick: function($icon, node) {
                var eventName = eventUtils.addNamespace("dxclick", this.NAME),
                    that = this;
                $icon.off(eventName).on(eventName, function(e) {
                    that._toggleExpandedState(node, undefined, e)
                })
            },
            _updateExpandedItemsUI: function(node, state, e) {
                var $node = this._getNodeElementById(node.internalFields.key),
                    $icon = $node.find(">." + TOGGLE_ITEM_VISIBILITY_CLASS),
                    $nodeContainer = $node.find(" > ." + NODE_CONTAINER_CLASS);
                $icon.toggleClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS, state);
                if (state)
                    this._renderNestedItems($nodeContainer).done($.proxy(function(itemsLoaded) {
                        if (itemsLoaded) {
                            this._animateNodeContainer($nodeContainer, state);
                            this.setAria("expanded", state, $node);
                            this._fireExpandedStateUpdatedEvt(state, node, e)
                        }
                    }, this));
                else {
                    this.setAria("expanded", state, $node);
                    this._animateNodeContainer($nodeContainer, state);
                    this._fireExpandedStateUpdatedEvt(state, node, e)
                }
            },
            _animateNodeContainer: function($nodeContainer, state) {
                var nodeHeight = $nodeContainer.height();
                DX.fx.stop($nodeContainer, true);
                DX.fx.animate($nodeContainer, {
                    type: "custom",
                    duration: this.option("animationEnabled") ? 400 : 0,
                    from: {"max-height": state ? 0 : nodeHeight},
                    to: {"max-height": state ? nodeHeight : 0},
                    start: function() {
                        $nodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS)
                    },
                    complete: $.proxy(function() {
                        $nodeContainer.css("max-height", "none");
                        $nodeContainer.toggleClass(OPENED_NODE_CONTAINER_CLASS, state);
                        this._scrollableContainer.update()
                    }, this)
                })
            },
            _fireExpandedStateUpdatedEvt: function(isExpanded, node, e) {
                var optionName = isExpanded ? "onItemExpanded" : "onItemCollapsed",
                    target;
                var handler = this.option(optionName);
                if (handler)
                    if (commonUtils.isDefined(e))
                        this._itemJQueryEventHandler(e, optionName, {node: this._dataAdapter.getPublicNode(node)});
                    else {
                        target = this._getNodeElementById(node.internalFields.key);
                        this._itemEventHandler(target, optionName, {
                            jQueryEvent: e,
                            node: this._dataAdapter.getPublicNode(node)
                        })
                    }
            },
            _renderNestedItems: function($container) {
                if (!$container.is(":empty"))
                    return $.Deferred().resolve(true).promise();
                var itemElement = $container.parent().find(">." + ITEM_CLASS),
                    item = this._getItemData(itemElement),
                    node = this._dataAdapter.getNodeByItem(item),
                    d = $.Deferred();
                if (this._isVirtualMode())
                    this._renderVirtualNodes($container).done(function(items) {
                        d.resolve(items && items.length)
                    });
                else {
                    var nestedItems = this._getChildNodes(node);
                    this._renderItems($container, nestedItems);
                    d.resolve(true)
                }
                return d.promise()
            },
            _renderVirtualNodes: function($container) {
                var itemElement = $container.parent().find(">." + ITEM_CLASS),
                    itemData = this._getItemData(itemElement),
                    node = this._dataAdapter.getNodeByItem(itemData),
                    that = this;
                this._dataSource.filter([this.option("parentIdExpr"), node.internalFields.key]);
                return this._dataSource.load().done(function(data) {
                        var virtualNodes = [];
                        $.each(data, function(_, item) {
                            var virtualNode = that._dataAdapter.getNodeByItem(item);
                            virtualNode && virtualNodes.push(virtualNode)
                        });
                        that._renderItems($container, virtualNodes, false);
                        if (virtualNodes.length && !node.internalFields.selected) {
                            var firstItemKey = virtualNodes[0].internalFields.key,
                                $firstChild = that._getNodeElementById(firstItemKey);
                            that._updateParentsState(that._dataAdapter.getNodeByKey(firstItemKey), $firstChild)
                        }
                        that._normalizeIconState(itemElement, virtualNodes.length)
                    })
            },
            _normalizeIconState: function(itemElement, hasNewItems) {
                var $loadIndicator = itemElement.siblings(".dx-loadindicator"),
                    $icon = itemElement.siblings("." + TOGGLE_ITEM_VISIBILITY_CLASS);
                $loadIndicator.dxLoadIndicator("instance").option("visible", false);
                if (!hasNewItems) {
                    itemElement.siblings("." + TOGGLE_ITEM_VISIBILITY_CLASS).removeClass(TOGGLE_ITEM_VISIBILITY_CLASS);
                    itemElement.parent().addClass(IS_LEAF)
                }
                else
                    $icon.show()
            },
            _dataSourceChangedHandler: function(newItems) {
                var isInArray = $.inArray(newItems[0], this.option("items")) + 1;
                if (this._initialized && this._isVirtualMode() && !isInArray) {
                    this.option().items = this.option("items").concat(newItems);
                    this._initDataAdapter();
                    if (!this._contentAlreadyRendered)
                        this._renderContent()
                }
                else
                    this.option("items", newItems)
            },
            _renderContent: function() {
                if (this.option("items").length)
                    this._contentAlreadyRendered = true;
                this.callBase()
            },
            _renderSelectAllItem: function($container) {
                $container = $container || this.element().find("." + NODE_CONTAINER_CLASS).first();
                this._$selectAllItem = $("<div>").addClass(SELECT_ALL_ITEM_CLASS);
                var value = this._dataAdapter.isAllSelected();
                this._createComponent(this._$selectAllItem, CheckBox, {
                    value: value,
                    text: this.option("selectAllText"),
                    onValueChanged: $.proxy(this._toggleSelectAll, this)
                });
                this._toggleSelectedClass(this._$selectAllItem, value);
                $container.before(this._$selectAllItem)
            },
            _toggleSelectAll: function(args) {
                this._dataAdapter.toggleSelectAll(args.value);
                this._updateCheckBoxes();
                this._fireSelectionChanged()
            },
            _renderCheckBox: function($node, node) {
                var checkBoxValue = node.internalFields.selected;
                $node.addClass(ITEM_WITH_CHECKBOX_CLASS);
                this.setAria("selected", checkBoxValue, $node);
                var $checkbox = $("<div>").appendTo($node);
                this._createComponent($checkbox, CheckBox, {
                    value: checkBoxValue,
                    onValueChanged: $.proxy(this._changeCheckboxValue, this),
                    focusStateEnabled: false,
                    disabled: this._disabledGetter(node)
                });
                if (checkBoxValue !== false)
                    this._toggleSelectedClass($node, checkBoxValue);
                this._attachCheckboxClick($checkbox, node)
            },
            _toggleSelectedClass: function($node, value) {
                $node.toggleClass(SELECTED_ITEM_CLASS, !!value)
            },
            _attachCheckboxClick: function($checkbox, node) {
                var eventName = eventUtils.addNamespace("dxclick", this.NAME);
                var handleItemSelected = function(e) {
                        this._itemJQueryEventHandler(e, "onItemSelected", {node: this._dataAdapter.getPublicNode(node)})
                    };
                $checkbox.off(eventName).on(eventName, $.proxy(handleItemSelected, this))
            },
            _changeCheckboxValue: function(e) {
                var $node = e.element.parent("." + NODE_CLASS),
                    item = this._getItemData($node.find("> ." + ITEM_CLASS)),
                    node = this._dataAdapter.getNodeByItem(item),
                    value = e.value;
                this._toggleSelectedClass($node, value);
                this.setAria("selected", value, $node);
                if (node.internalFields.selected === value)
                    return;
                this._dataAdapter.toggleSelection(node.internalFields.key, value);
                if (e.jQueryEvent && !this.option("selectNodesRecursive"))
                    this._fireSelectionChanged();
                if (this._selectAllEnabled())
                    this._$selectAllItem.dxCheckBox("instance").option("value", this._dataAdapter.isAllSelected());
                else if (!e.jQueryEvent || !this.option("selectNodesRecursive"))
                    return;
                this._updateCheckBoxes();
                this._fireSelectionChanged()
            },
            _updateItemSelection: function(value, itemElement, suppressOnSelectionChanged, $node) {
                var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement,
                    node = commonUtils.isPrimitive(itemData) ? this._dataAdapter.getNodeByKey(itemData) : this._dataAdapter.getNodeByItem(itemData);
                if (node.internalFields.selected === value)
                    return;
                if (!$node) {
                    var $tmpNode = this._getNodeElementById(node.internalFields.key);
                    if ($tmpNode.length)
                        $node = $tmpNode
                }
                if ($node)
                    this._getCheckBoxInstance($node).option("value", value);
                else
                    this._dataAdapter.toggleSelection(node.internalFields.key, value);
                this._updateCheckBoxes();
                var handler = this.option("onItemSelected");
                if (handler)
                    handler.call(this, {
                        itemData: itemData,
                        node: this._dataAdapter.getPublicNode(node)
                    });
                this._fireSelectionChanged()
            },
            _getCheckBoxInstance: function($node) {
                return $node.find("> .dx-checkbox").dxCheckBox("instance")
            },
            _updateCheckBoxes: function() {
                var that = this;
                $.each(this._dataAdapter.getData(), function(_, node) {
                    var $node = that._getNodeElementById(node.internalFields.key);
                    if (!$node.length)
                        return;
                    var checkbox = that._getCheckBoxInstance($node),
                        nodeSelection = node.internalFields.selected;
                    if (checkbox.option("value") === nodeSelection)
                        return;
                    checkbox.option("value", nodeSelection);
                    that._toggleSelectedClass($node, nodeSelection)
                })
            },
            _updateParentsState: function(node, $node) {
                var parentNode = this._dataAdapter.getNodeByKey(node.internalFields.parentKey),
                    parentValue = parentNode.internalFields.selected,
                    $parentNode;
                if ($node && this._showCheckboxes()) {
                    $parentNode = $($node.parents("." + NODE_CLASS)[0]);
                    this._getCheckBoxInstance($parentNode).option("value", parentValue);
                    this._toggleSelectedClass($parentNode, parentValue)
                }
                if (parentNode.parentId)
                    this._updateParentsState(parentNode, $parentNode)
            },
            _itemEventHandlerImpl: function(initiator, action, actionArgs) {
                var $itemElement = $(initiator).closest("." + NODE_CLASS).find("> ." + ITEM_CLASS);
                return action($.extend(this._extendActionArgs($itemElement), actionArgs))
            },
            _itemContextMenuHandler: function(e) {
                this._createEventHandler("onItemContextMenu", e)
            },
            _itemHoldHandler: function(e) {
                this._createEventHandler("onItemHold", e)
            },
            _createEventHandler: function(eventName, e) {
                var itemData = this._getItemData(e.currentTarget),
                    node = this._dataAdapter.getNodeByItem(itemData);
                this._itemJQueryEventHandler(e, eventName, {node: this._dataAdapter.getPublicNode(node)})
            },
            _itemClass: function() {
                return ITEM_CLASS
            },
            _itemDataKey: function() {
                return ITEM_DATA_KEY
            },
            _selectionEnabled: function() {
                return true
            },
            _attachClickEvent: function() {
                var that = this,
                    itemSelector = that._itemSelector(),
                    eventName = eventUtils.addNamespace("dxclick", that.NAME),
                    pointerDownEvent = eventUtils.addNamespace(pointerEvents.down, this.NAME);
                that._itemContainer().off(eventName, itemSelector).on(eventName, itemSelector, function(e) {
                    that._itemClickHandler(e, $(this))
                }).off(pointerDownEvent, itemSelector).on(pointerDownEvent, itemSelector, $.proxy(this._itemPointerDownHandler, this))
            },
            _itemClickHandler: function(e, $item) {
                var itemData = this._getItemData($item),
                    node = this._dataAdapter.getNodeByItem(itemData);
                this._itemJQueryEventHandler(e, "onItemClick", {node: this._dataAdapter.getPublicNode(node)})
            },
            _updateSelectionToFirstItem: function($items, startIndex) {
                var itemIndex = startIndex;
                while (itemIndex >= 0) {
                    var $item = $($items[itemIndex]);
                    this._updateItemSelection(true, $item.find("." + ITEM_CLASS).get(0), true, $item);
                    itemIndex--
                }
            },
            _updateSelectionToLastItem: function($items, startIndex) {
                var itemIndex = startIndex,
                    length = $items.length;
                while (itemIndex < length) {
                    var $item = $($items[itemIndex]);
                    this._updateItemSelection(true, $item.find("." + ITEM_CLASS).get(0), true, $item);
                    itemIndex++
                }
            },
            _focusInHandler: function(e) {
                var currentTarget = e.currentTarget,
                    focusTargets = this._focusTarget();
                if ($.inArray(currentTarget, focusTargets) !== -1)
                    this._toggleFocusClass(true, currentTarget);
                if (!this.option("focusedElement")) {
                    var $activeItem = this._getActiveItem();
                    this.option("focusedElement", $activeItem.closest("." + NODE_CLASS))
                }
                else
                    this._setFocusedItem(this.option("focusedElement"))
            },
            _setFocusedItem: function($target) {
                if (!$target || !$target.length)
                    return;
                if (!$target.children().hasClass(DISABLED_STATE_CLASS))
                    this.callBase($target);
                this._scrollableContainer.scrollToElement($target.find("." + ITEM_CLASS).first())
            },
            _itemPointerDownHandler: function(e) {
                if (!this.option("focusStateEnabled"))
                    return;
                var $target = $(e.target).closest("." + NODE_CLASS);
                if ($target.hasClass(NODE_CLASS))
                    if ($target.hasClass(DISABLED_STATE_CLASS))
                        this.option("focusedElement", null);
                    else
                        this.option("focusedElement", $target)
            },
            _findNonDisabledNodes: function($nodes) {
                return $nodes.not(function() {
                        return $(this).find(">." + ITEM_CLASS).hasClass(DISABLED_STATE_CLASS)
                    })
            },
            _moveFocus: function(location, e) {
                var FOCUS_UP = "up",
                    FOCUS_DOWN = "down",
                    FOCUS_FIRST = "first",
                    FOCUS_LAST = "last",
                    FOCUS_LEFT = this.option("rtlEnabled") ? "right" : "left",
                    FOCUS_RIGHT = this.option("rtlEnabled") ? "left" : "right";
                this.element().find("." + NODE_CONTAINER_CLASS).each(function() {
                    DX.fx.stop(this, true)
                });
                var $items = this._findNonDisabledNodes(this._nodeElements());
                if ($items && $items.length)
                    switch (location) {
                        case FOCUS_UP:
                            var $prevItem = this._prevItem($items);
                            this.option("focusedElement", $prevItem);
                            if (e.shiftKey && this._showCheckboxes())
                                this._updateItemSelection(true, $prevItem.find("." + ITEM_CLASS).get(0), true, $prevItem);
                            break;
                        case FOCUS_DOWN:
                            var $nextItem = this._nextItem($items);
                            this.option("focusedElement", $nextItem);
                            if (e.shiftKey && this._showCheckboxes())
                                this._updateItemSelection(true, $nextItem.find("." + ITEM_CLASS).get(0), true, $nextItem);
                            break;
                        case FOCUS_FIRST:
                            var $firstItem = $items.first();
                            if (e.shiftKey && this._showCheckboxes())
                                this._updateSelectionToFirstItem($items, $items.index(this._prevItem($items)));
                            this.option("focusedElement", $firstItem);
                            break;
                        case FOCUS_LAST:
                            var $lastItem = $items.last();
                            if (e.shiftKey && this._showCheckboxes())
                                this._updateSelectionToLastItem($items, $items.index(this._nextItem($items)));
                            this.option("focusedElement", $lastItem);
                            break;
                        case FOCUS_RIGHT:
                            this._expandFocusedContainer();
                            break;
                        case FOCUS_LEFT:
                            this._collapseFocusedContainer();
                            break;
                        default:
                            this.callBase.apply(this, arguments);
                            return
                    }
            },
            _nodeElements: function() {
                return this.element().find("." + NODE_CLASS).not(":hidden")
            },
            _expandFocusedContainer: function() {
                var $focusedItem = this.option("focusedElement");
                if (!$focusedItem || $focusedItem.hasClass(IS_LEAF))
                    return;
                var $node = $focusedItem.find("." + NODE_CONTAINER_CLASS).eq(0);
                if ($node.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
                    this.option("focusedElement", this._nextItem(this._findNonDisabledNodes(this._nodeElements())));
                    return
                }
                var itemData = this._getItemData($focusedItem.find(">." + ITEM_CLASS)),
                    node = this._dataAdapter.getNodeByItem(itemData);
                this._toggleExpandedState(node, true)
            },
            _getClosestNonDisabledNode: function($node) {
                do
                    $node = $node.parent().closest("." + NODE_CLASS);
                while ($node.children(".dx-treeview-item.dx-state-disabled").length);
                return $node
            },
            _collapseFocusedContainer: function() {
                var $focusedItem = this.option("focusedElement");
                if (!$focusedItem)
                    return;
                var nodeElement = $focusedItem.find("." + NODE_CONTAINER_CLASS).eq(0);
                if (!$focusedItem.hasClass(IS_LEAF) && nodeElement.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
                    var itemData = this._getItemData($focusedItem.find(">." + ITEM_CLASS)),
                        node = this._dataAdapter.getNodeByItem(itemData);
                    this._toggleExpandedState(node, false)
                }
                else {
                    var collapsedNode = this._getClosestNonDisabledNode($focusedItem);
                    if (collapsedNode.length)
                        this.option("focusedElement", collapsedNode)
                }
            },
            updateDimensions: function() {
                var that = this,
                    deferred = $.Deferred();
                if (that._scrollableContainer)
                    that._scrollableContainer.update().done(function() {
                        deferred.resolveWith(that)
                    });
                else
                    deferred.resolveWith(that);
                return deferred.promise()
            },
            selectItem: function(itemElement) {
                this._updateItemSelection(true, itemElement)
            },
            unselectItem: function(itemElement) {
                this._updateItemSelection(false, itemElement)
            },
            expandItem: function(itemElement) {
                this._toggleExpandedState(itemElement, true)
            },
            collapseItem: function(itemElement) {
                this._toggleExpandedState(itemElement, false)
            },
            getNodes: function() {
                return this._dataAdapter.getTreeNodes()
            },
            selectAll: function() {
                if (this._selectAllEnabled())
                    this._$selectAllItem.dxCheckBox("instance").option("value", true);
                else
                    this._toggleSelectAll({value: true})
            },
            unselectAll: function() {
                if (this._selectAllEnabled())
                    this._$selectAllItem.dxCheckBox("instance").option("value", false);
                else
                    this._toggleSelectAll({value: false})
            }
        }));
        ui.dxTreeView.__internals = {
            WIDGET_CLASS: WIDGET_CLASS,
            NODE_CONTAINER_CLASS: NODE_CONTAINER_CLASS,
            OPENED_NODE_CONTAINER_CLASS: OPENED_NODE_CONTAINER_CLASS,
            ITEM_CLASS: ITEM_CLASS,
            NODE_CLASS: NODE_CLASS,
            ITEM_WITH_CHECKBOX_CLASS: ITEM_WITH_CHECKBOX_CLASS,
            ITEM_DATA_KEY: ITEM_DATA_KEY,
            IS_LEAF: IS_LEAF,
            TOGGLE_ITEM_VISIBILITY_CLASS: TOGGLE_ITEM_VISIBILITY_CLASS,
            TOGGLE_ITEM_VISIBILITY_OPENED_CLASS: TOGGLE_ITEM_VISIBILITY_OPENED_CLASS,
            SELECT_ALL_ITEM_CLASS: SELECT_ALL_ITEM_CLASS,
            scrollableContainerUpdatedOnInitAccessor: function(value) {
                if (value)
                    scrollableContainerUpdatedOnInit = value;
                return scrollableContainerUpdatedOnInit
            }
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.sortable.js */
    (function($, DX) {
        var ui = DX.ui,
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            addNamespace = eventUtils.addNamespace,
            registerComponent = DX.require("/componentRegistrator"),
            DOMComponent = DX.require("/domComponent");
        var SORTABLE_NAMESPACE = "dxSortable",
            SORTABLE_CLASS = "dx-sortable";
        function elementHasPoint(element, x, y) {
            var $item = $(element),
                offset = $item.offset();
            if (x >= offset.left && x <= offset.left + $item.outerWidth(true))
                if (y >= offset.top && y <= offset.top + $item.outerHeight(true))
                    return true
        }
        function getItemsOffset($elements) {
            var result = [];
            $.each($elements, function() {
                var item = this;
                if ($(item).is(':visible'))
                    result.push({
                        pos: $(item).offset().top + $(item).outerHeight(true) / 2,
                        item: $(item)
                    })
            });
            return result
        }
        registerComponent("dxSortable", ui, DOMComponent.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        onChanged: null,
                        onDragging: null,
                        itemRender: null,
                        groupSelector: null,
                        itemSelector: ".dx-sort-item",
                        itemContainerSelector: ".dx-sortable",
                        sourceClass: "dx-drag-source",
                        dragClass: "dx-drag",
                        targetClass: "dx-drag-target"
                    })
            },
            _renderItem: function($sourceItem, target) {
                var itemRender = this.option("itemRender"),
                    $item;
                if (itemRender)
                    $item = itemRender($sourceItem, target);
                else {
                    $item = $sourceItem.clone();
                    $item.css({
                        width: $sourceItem.width(),
                        height: $sourceItem.height()
                    })
                }
                return $item
            },
            _attachEventHandlers: function() {
                var that = this,
                    itemSelector = that.option("itemSelector"),
                    itemContainerSelector = that.option("itemContainerSelector"),
                    groupSelector = that.option("groupSelector"),
                    sourceClass = that.option("sourceClass"),
                    dragClass = that.option("dragClass"),
                    targetClass = that.option("targetClass"),
                    onDragging = that.option("onDragging"),
                    $sourceItem,
                    sourceIndex,
                    $targetItem,
                    $targetGroup,
                    startPosition,
                    $draggable,
                    $sourceGroup,
                    element = that.element(),
                    $groups,
                    i;
                element.off(addNamespace("dxdragstart dxdrag dxdragend dxdragenter dxdragleave dxdrop", SORTABLE_NAMESPACE)).on(addNamespace("dxdragstart", SORTABLE_NAMESPACE), itemSelector, function(e) {
                    $sourceItem = $(e.currentTarget);
                    startPosition = $sourceItem.offset();
                    startPosition.top -= element.offset().top;
                    startPosition.left -= element.offset().left;
                    sourceIndex = $sourceItem.index();
                    $groups = groupSelector ? element.find(groupSelector) : element;
                    $sourceGroup = $sourceItem.closest(groupSelector).attr("group");
                    $draggable = that._renderItem($sourceItem, 'drag').appendTo(element);
                    $targetItem = that._renderItem($sourceItem, 'target');
                    $draggable.addClass(dragClass);
                    $sourceItem.addClass(sourceClass);
                    $targetItem.addClass(targetClass)
                }).on(addNamespace("dxdrag", SORTABLE_NAMESPACE), function(e) {
                    var draggingArgs,
                        $item,
                        $itemContainer,
                        $items,
                        itemsOffset = [];
                    if (!$sourceItem)
                        return;
                    $draggable.css({
                        top: startPosition.top + e.offset.y,
                        left: startPosition.left + e.offset.x
                    });
                    $targetGroup && $targetGroup.removeClass(targetClass);
                    $targetGroup = undefined;
                    $.each($groups, function() {
                        if (elementHasPoint(this, e.pageX, e.pageY)) {
                            $targetGroup = $(this);
                            return false
                        }
                    });
                    if ($targetGroup) {
                        draggingArgs = {
                            sourceGroup: $sourceGroup,
                            sourceIndex: sourceIndex,
                            sourceElement: $sourceItem,
                            targetGroup: $targetGroup.attr("group"),
                            targetIndex: $targetItem.index()
                        };
                        onDragging && onDragging(draggingArgs)
                    }
                    if (draggingArgs && draggingArgs.cancel)
                        $targetGroup = undefined;
                    if ($targetGroup) {
                        $targetGroup.addClass(targetClass);
                        $itemContainer = $targetGroup.find(itemContainerSelector);
                        $items = $itemContainer.find(itemSelector);
                        itemsOffset = getItemsOffset($items);
                        for (i = 0; i < itemsOffset.length; i++)
                            if (e.pageY < itemsOffset[i].pos) {
                                $item = itemsOffset[i] && itemsOffset[i].item;
                                break
                            }
                        if ($item)
                            if (!$item.hasClass(sourceClass) && (!$item.prev().hasClass(sourceClass) || !$item.prev().is(":visible")))
                                $targetItem.insertBefore($item);
                            else
                                $targetItem.detach();
                        else if (!($items.last().is(":visible") && $items.last().hasClass(sourceClass)))
                            $targetItem.appendTo($itemContainer)
                    }
                    else
                        $targetItem.detach()
                }).on(addNamespace("dxdragend", SORTABLE_NAMESPACE), function() {
                    var onChanged = that.option("onChanged"),
                        changedArgs,
                        sourceGroup;
                    if ($sourceItem) {
                        if ($targetGroup) {
                            $targetGroup.removeClass(targetClass);
                            sourceGroup = $sourceItem.closest(groupSelector).attr("group");
                            changedArgs = {
                                sourceGroup: sourceGroup,
                                sourceIndex: sourceIndex,
                                sourceElement: $sourceItem,
                                targetGroup: $targetGroup.attr("group"),
                                targetIndex: $targetItem.index(),
                                removeSourceElement: true
                            };
                            if (sourceGroup !== changedArgs.targetGroup || $targetItem.parent().length) {
                                onChanged && onChanged(changedArgs);
                                if (changedArgs.removeSourceElement)
                                    $sourceItem.remove()
                            }
                        }
                        $sourceItem.removeClass(sourceClass);
                        $draggable.remove();
                        $sourceItem = null;
                        $targetItem.removeClass(targetClass);
                        $targetItem = null
                    }
                })
            },
            _init: function() {
                this.callBase();
                this._attachEventHandlers()
            },
            _render: function() {
                this.callBase();
                this.element().addClass(SORTABLE_CLASS)
            },
            _optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"onDragging":
                    case"onChanged":
                    case"itemRender":
                    case"groupSelector":
                    case"itemSelector":
                    case"itemContainerSelector":
                    case"sourceClass":
                    case"targetClass":
                    case"dragClass":
                        that._attachEventHandlers();
                        break;
                    default:
                        that.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.js */
    (function($, DX) {
        var ui = DX.ui,
            stringUtils = DX.require("/utils/utils.string"),
            browser = DX.require("/utils/utils.browser"),
            Class = DX.require("/class"),
            errors = DX.require("/ui/ui.errors"),
            logger = DX.require("/utils/utils.console").logger,
            formatHelper = DX.require("/utils/utils.formatHelper"),
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget");
        var DATAGRID_ROW_SELECTOR = ".dx-row",
            DATAGRID_DEPRECATED_TEMPLATE_WARNING = "Specifying grid templates with the name of a jQuery selector is now deprecated. Instead, use the jQuery object that references this selector.",
            DATE_INTERVAL_SELECTORS = {
                year: function(value) {
                    return value && value.getFullYear()
                },
                month: function(value) {
                    return value && value.getMonth() + 1
                },
                day: function(value) {
                    return value && value.getDate()
                },
                quarter: function(value) {
                    return value && Math.floor(value.getMonth() / 3) + 1
                },
                dayOfWeek: function(value) {
                    return value && value.getDay()
                },
                hour: function(value) {
                    return value && value.getHours()
                },
                minute: function(value) {
                    return value && value.getMinutes()
                },
                second: function(value) {
                    return value && value.getSeconds()
                }
            },
            DEFAULT_DATE_INTERVAL = ["year", "month", "day"];
        var ModuleItem = Class.inherit({
                _endUpdateCore: function(){},
                ctor: function(component) {
                    var that = this;
                    that._updateLockCount = 0;
                    that.component = component;
                    that._actions = {};
                    that._actionConfigs = {};
                    $.each(this.callbackNames() || [], function(index, name) {
                        var flags = that.callbackFlags(name);
                        that[this] = $.Callbacks(flags)
                    })
                },
                init: function(){},
                callbackNames: function(){},
                callbackFlags: function(name){},
                publicMethods: function(){},
                beginUpdate: function() {
                    this._updateLockCount++
                },
                endUpdate: function() {
                    this._updateLockCount--;
                    if (!this._updateLockCount)
                        this._endUpdateCore()
                },
                option: function(name) {
                    var component = this.component,
                        optionCache = component._optionCache;
                    if (arguments.length === 1 && optionCache) {
                        if (!(name in optionCache))
                            optionCache[name] = component.option(name);
                        return optionCache[name]
                    }
                    return component.option.apply(component, arguments)
                },
                localize: function(name) {
                    var optionCache = this.component._optionCache;
                    if (optionCache) {
                        if (!(name in optionCache))
                            optionCache[name] = Globalize.localize(name);
                        return optionCache[name]
                    }
                    return Globalize.localize(name)
                },
                on: function() {
                    return this.component.on.apply(this.component, arguments)
                },
                off: function() {
                    return this.component.off.apply(this.component, arguments)
                },
                optionChanged: function(args) {
                    if (args.name in this._actions) {
                        this.createAction(args.name, this._actionConfigs[args.name]);
                        args.handled = true
                    }
                },
                getAction: function(actionName) {
                    return this._actions[actionName]
                },
                setAria: function(name, value, $target) {
                    var target = $target.get(0),
                        prefix = name !== "role" && name !== "id" ? "aria-" : "";
                    if (target.setAttribute)
                        target.setAttribute(prefix + name, value);
                    else
                        $target.attr(prefix + name, value)
                },
                _createComponent: function() {
                    return this.component._createComponent.apply(this.component, arguments)
                },
                getController: function(name) {
                    return this.component._controllers[name]
                },
                createAction: function(actionName, config) {
                    var action;
                    if (commonUtils.isFunction(actionName)) {
                        action = this.component._createAction($.proxy(actionName, this), config);
                        return function(e) {
                                action({jQueryEvent: e})
                            }
                    }
                    else {
                        this._actions[actionName] = this.component._createActionByOption(actionName, config);
                        this._actionConfigs[actionName] = config
                    }
                },
                executeAction: function(actionName, options) {
                    var action = this._actions[actionName];
                    return action && action(options)
                },
                dispose: function() {
                    var that = this;
                    $.each(that.callbackNames() || [], function() {
                        that[this].empty()
                    })
                }
            });
        var Controller = ModuleItem;
        var ViewController = Controller.inherit({
                getView: function(name) {
                    return this.component._views[name]
                },
                getViews: function() {
                    return this.component._views
                }
            });
        var View = ModuleItem.inherit({
                _isReady: function() {
                    return this.component.isReady()
                },
                _endUpdateCore: function() {
                    this.callBase();
                    if (!this._isReady() && this._requireReady) {
                        this._requireRender = false;
                        this.component._requireResize = false
                    }
                    if (this._requireRender) {
                        this._requireRender = false;
                        this.render(this._$parent)
                    }
                },
                _invalidate: function(requireResize, requireReady) {
                    this._requireRender = true;
                    this.component._requireResize = this.component._requireResize || requireResize;
                    this._requireReady = this._requireReady || requireReady
                },
                _renderCore: function(options){},
                _resizeCore: function(){},
                _afterRender: function($root){},
                _parentElement: function() {
                    return this._$parent
                },
                ctor: function(component) {
                    this.callBase(component);
                    this.renderCompleted = $.Callbacks();
                    this.resizeCompleted = $.Callbacks()
                },
                element: function() {
                    return this._$element
                },
                isVisible: function() {
                    return true
                },
                getTemplate: function(name) {
                    return this.component._getTemplate(name)
                },
                render: function($parent, options) {
                    var $element = this._$element,
                        isVisible = this.isVisible();
                    this._requireReady = false;
                    if (!$element) {
                        $element = this._$element = $("<div />").appendTo($parent);
                        this._$parent = $parent
                    }
                    $element.toggleClass("dx-hidden", !isVisible);
                    if (isVisible) {
                        this.component._optionCache = {};
                        this._renderCore(options);
                        this.component._optionCache = undefined;
                        this._afterRender($parent);
                        this.renderCompleted.fire()
                    }
                },
                resize: function() {
                    this.isResizing = true;
                    this._resizeCore();
                    this.resizeCompleted.fire();
                    this.isResizing = false
                },
                focus: function() {
                    this.element().focus()
                }
            });
        var processModules = function(that, componentClass) {
                var modules = componentClass.modules,
                    controllerTypes = componentClass.controllerTypes || {},
                    viewTypes = componentClass.viewTypes || {};
                if (!componentClass.controllerTypes) {
                    $.each(modules, function() {
                        var controllers = this.controllers,
                            moduleName = this.name,
                            views = this.views;
                        controllers && $.each(controllers, function(name, type) {
                            if (controllerTypes[name])
                                throw errors.Error("E1001", moduleName, name);
                            else if (!(type && type.subclassOf && type.subclassOf(Controller))) {
                                type.subclassOf(Controller);
                                throw errors.Error("E1002", moduleName, name);
                            }
                            controllerTypes[name] = type
                        });
                        views && $.each(views, function(name, type) {
                            if (viewTypes[name])
                                throw errors.Error("E1003", moduleName, name);
                            else if (!(type && type.subclassOf && type.subclassOf(View)))
                                throw errors.Error("E1004", moduleName, name);
                            viewTypes[name] = type
                        })
                    });
                    $.each(modules, function() {
                        var extenders = this.extenders;
                        if (extenders) {
                            extenders.controllers && $.each(extenders.controllers, function(name, extender) {
                                if (controllerTypes[name])
                                    controllerTypes[name] = controllerTypes[name].inherit(extender)
                            });
                            extenders.views && $.each(extenders.views, function(name, extender) {
                                if (viewTypes[name])
                                    viewTypes[name] = viewTypes[name].inherit(extender)
                            })
                        }
                    });
                    componentClass.controllerTypes = controllerTypes;
                    componentClass.viewTypes = viewTypes
                }
                var registerPublicMethods = function(that, name, moduleItem) {
                        var publicMethods = moduleItem.publicMethods();
                        if (publicMethods)
                            $.each(publicMethods, function(index, methodName) {
                                if (moduleItem[methodName])
                                    if (!that[methodName])
                                        that[methodName] = function() {
                                            return moduleItem[methodName].apply(moduleItem, arguments)
                                        };
                                    else
                                        throw errors.Error("E1005", methodName);
                                else
                                    throw errors.Error("E1006", name, methodName);
                            })
                    };
                var createModuleItems = function(moduleTypes) {
                        var moduleItems = {};
                        $.each(moduleTypes, function(name, moduleType) {
                            var moduleItem = new moduleType(that);
                            moduleItem.name = name;
                            registerPublicMethods(that, name, moduleItem);
                            moduleItems[name] = moduleItem
                        });
                        return moduleItems
                    };
                that._controllers = createModuleItems(controllerTypes);
                that._views = createModuleItems(viewTypes)
            };
        var callModuleItemsMethod = function(that, methodName, args) {
                args = args || [];
                if (that._controllers)
                    $.each(that._controllers, function() {
                        this[methodName] && this[methodName].apply(this, args)
                    });
                if (that._views)
                    $.each(that._views, function() {
                        this[methodName] && this[methodName].apply(this, args)
                    })
            };
        registerComponent("dxDataGrid", ui, Widget.inherit({
            _activeStateUnit: DATAGRID_ROW_SELECTOR,
            _setDefaultOptions: function() {
                var that = this;
                that.callBase();
                $.each(ui.dxDataGrid.modules, function() {
                    if ($.isFunction(this.defaultOptions))
                        that.option(this.defaultOptions())
                })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    "editing.editMode": {
                        since: "15.2",
                        alias: "editing.mode"
                    },
                    "editing.editEnabled": {
                        since: "15.2",
                        alias: "editing.allowUpdating"
                    },
                    "editing.insertEnabled": {
                        since: "15.2",
                        alias: "editing.allowAdding"
                    },
                    "editing.removeEnabled": {
                        since: "15.2",
                        alias: "editing.allowDeleting"
                    }
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "ios"},
                            options: {showRowLines: true}
                        }, {
                            device: function() {
                                return browser.webkit
                            },
                            options: {loadPanel: {animation: {show: {
                                            easing: "cubic-bezier(1, 0, 1, 0)",
                                            duration: 500,
                                            from: {opacity: 0},
                                            to: {opacity: 1}
                                        }}}}
                        }])
            },
            _init: function() {
                var that = this;
                that.callBase();
                processModules(that, ui.dxDataGrid);
                callModuleItemsMethod(that, "init")
            },
            _clean: $.noop,
            _optionChanged: function(args) {
                var that = this;
                callModuleItemsMethod(that, "optionChanged", [args]);
                if (!args.handled)
                    that.callBase(args)
            },
            _dimensionChanged: function() {
                this.updateDimensions()
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this.updateDimensions()
            },
            _renderContentImpl: function() {
                var that = this;
                that.getView("gridView").render(that.element())
            },
            _renderContent: function() {
                this._renderContentImpl()
            },
            _getTemplate: function(templateName) {
                var template = templateName;
                if (commonUtils.isString(template) && template[0] === "#") {
                    template = $(templateName);
                    logger.warn(DATAGRID_DEPRECATED_TEMPLATE_WARNING)
                }
                return this.callBase(template)
            },
            _dispose: function() {
                var that = this;
                that.callBase();
                callModuleItemsMethod(that, "dispose")
            },
            isReady: function() {
                return this.getController("data").isReady()
            },
            beginUpdate: function() {
                var that = this;
                that.callBase();
                callModuleItemsMethod(that, "beginUpdate")
            },
            endUpdate: function() {
                var that = this;
                callModuleItemsMethod(that, "endUpdate");
                that.callBase()
            },
            getController: function(name) {
                return this._controllers[name]
            },
            getView: function(name) {
                return this._views[name]
            },
            focus: function(element) {
                this.callBase();
                if (commonUtils.isDefined(element))
                    this.getController("keyboardNavigation").focus(element)
            }
        }));
        var MAX_EQUAL_KEYS_LEVEL = 3;
        $.extend(ui.dxDataGrid, function() {
            var getIntervalSelector = function() {
                    var groupInterval,
                        data = arguments[1],
                        nameIntervalSelector,
                        value = this.calculateCellValue(data);
                    if (!commonUtils.isDefined(value))
                        return null;
                    else if (this.dataType === "date") {
                        nameIntervalSelector = arguments[0];
                        return DATE_INTERVAL_SELECTORS[nameIntervalSelector](value)
                    }
                    else if (this.dataType === "number") {
                        groupInterval = arguments[0];
                        return Math.floor(Number(value) / groupInterval) * groupInterval
                    }
                };
            var getDateValues = function(dateValue) {
                    if (commonUtils.isDate(dateValue))
                        return [dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate(), dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds()];
                    return $.map(("" + dateValue).split("/"), function(value, index) {
                            return index === 1 ? Number(value) - 1 : Number(value)
                        })
                };
            var getFilterExpressionForDate = function(filterValue, selectedFilterOperation, target) {
                    var column = this,
                        selector = getFilterSelector(column, target),
                        dateStart,
                        dateEnd,
                        values = getDateValues(filterValue),
                        dateInterval = ui.dxDataGrid.getGroupInterval(column)[values.length - 1];
                    switch (dateInterval) {
                        case"year":
                            dateStart = new Date(values[0], 0, 1),
                            dateEnd = new Date(values[0] + 1, 0, 1);
                            break;
                        case"month":
                            dateStart = new Date(values[0], values[1], 1),
                            dateEnd = new Date(values[0], values[1] + 1, 1);
                            break;
                        case"quarter":
                            dateStart = new Date(values[0], 3 * values[1], 1),
                            dateEnd = new Date(values[0], 3 * values[1] + 3, 1);
                            break;
                        case"hour":
                            dateStart = new Date(values[0], values[1], values[2], values[3]),
                            dateEnd = new Date(values[0], values[1], values[2], values[3] + 1);
                            break;
                        case"minute":
                            dateStart = new Date(values[0], values[1], values[2], values[3], values[4]),
                            dateEnd = new Date(values[0], values[1], values[2], values[3], values[4] + 1);
                            break;
                        case"second":
                            dateStart = new Date(values[0], values[1], values[2], values[3], values[4], values[5]),
                            dateEnd = new Date(values[0], values[1], values[2], values[3], values[4], values[5] + 1);
                            break;
                        default:
                            dateStart = new Date(values[0], values[1], values[2]),
                            dateEnd = new Date(values[0], values[1], values[2] + 1)
                    }
                    switch (selectedFilterOperation) {
                        case"<":
                            return [selector, "<", dateStart];
                        case"<=":
                            return [selector, "<", dateEnd];
                        case">":
                            return [selector, ">=", dateEnd];
                        case">=":
                            return [selector, ">=", dateStart];
                        case"<>":
                            return [[selector, "<", dateStart], "or", [selector, ">=", dateEnd]];
                        default:
                            return [[selector, ">=", dateStart], "and", [selector, "<", dateEnd]]
                    }
                };
            var getFilterExpressionForNumber = function(filterValue, selectedFilterOperation, target) {
                    var column = this,
                        interval,
                        startFilterValue,
                        endFilterValue,
                        selector = getFilterSelector(column, target),
                        values = ("" + filterValue).split("/"),
                        value = Number(values[values.length - 1]),
                        isExclude = column.filterType === "exclude",
                        groupInterval = ui.dxDataGrid.getGroupInterval(column);
                    if (target === "headerFilter" && groupInterval && commonUtils.isDefined(filterValue)) {
                        interval = groupInterval[values.length - 1];
                        startFilterValue = [selector, isExclude ? "<" : ">=", value];
                        endFilterValue = [selector, isExclude ? ">=" : "<", value + interval];
                        return [startFilterValue, isExclude ? "or" : "and", endFilterValue]
                    }
                    return [selector, selectedFilterOperation || "=", filterValue]
                };
            var getFilterSelector = function(column, target) {
                    var selector = column.dataField || column.selector;
                    if (target === "search")
                        selector = column.displayField || column.calculateDisplayValue || selector;
                    return selector
                };
            var getFilterExpressionByRange = function(filterValue, selectedFilterOperation, target) {
                    var column = this,
                        dataField = column.dataField;
                    if (commonUtils.isArray(filterValue) && commonUtils.isDefined(filterValue[0]) && commonUtils.isDefined(filterValue[1]))
                        return [[dataField, ">=", filterValue[0]], "and", [dataField, "<=", filterValue[1]]]
                };
            return {
                    __internals: {},
                    modules: [],
                    View: View,
                    ViewController: ViewController,
                    Controller: Controller,
                    registerModule: function(name, module) {
                        var modules = this.modules,
                            i;
                        for (i = 0; i < modules.length; i++)
                            if (modules[i].name === name)
                                return;
                        module.name = name;
                        modules.push(module);
                        delete this.controllerTypes,
                        delete this.viewTypes
                    },
                    unregisterModule: function(name) {
                        this.modules = $.grep(this.modules, function(module) {
                            return module.name !== name
                        });
                        delete this.controllerTypes,
                        delete this.viewTypes
                    },
                    processModules: processModules,
                    formatValue: function(value, options) {
                        var valueText = formatHelper.format(value, options.format, options.precision) || value && value.toString() || "",
                            formatObject = {
                                value: value,
                                valueText: options.getDisplayFormat ? options.getDisplayFormat(valueText) : valueText,
                                target: options.target || "row",
                                groupInterval: options.groupInterval
                            };
                        return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText
                    },
                    getDisplayValue: function(column, value, data) {
                        if (column.displayValueMap && column.displayValueMap[value] !== undefined)
                            return column.displayValueMap[value];
                        else if (column.calculateDisplayValue && data)
                            return column.calculateDisplayValue(data);
                        else if (column.lookup)
                            return column.lookup.calculateCellValue(value);
                        return value
                    },
                    getGroupRowSummaryText: function(summaryItems, summaryTexts) {
                        var result = "(",
                            i,
                            summaryItem;
                        for (i = 0; i < summaryItems.length; i++) {
                            summaryItem = summaryItems[i];
                            result += (i > 0 ? ", " : "") + ui.dxDataGrid.getSummaryText(summaryItem, summaryTexts)
                        }
                        return result += ")"
                    },
                    getSummaryText: function(summaryItem, summaryTexts) {
                        var displayFormat = summaryItem.displayFormat || summaryItem.columnCaption && summaryTexts[summaryItem.summaryType + "OtherColumn"] || summaryTexts[summaryItem.summaryType];
                        return this.formatValue(summaryItem.value, {
                                format: summaryItem.valueFormat,
                                precision: summaryItem.precision,
                                getDisplayFormat: function(valueText) {
                                    return displayFormat ? stringUtils.format(displayFormat, valueText, summaryItem.columnCaption) : valueText
                                },
                                customizeText: summaryItem.customizeText
                            })
                    },
                    equalKeys: function(key1, key2, level) {
                        var propertyName,
                            i;
                        level = level || 0;
                        if (level < MAX_EQUAL_KEYS_LEVEL)
                            if (commonUtils.isObject(key1) && commonUtils.isObject(key2)) {
                                for (propertyName in key1)
                                    if (key1.hasOwnProperty(propertyName) && !ui.dxDataGrid.equalKeys(key1[propertyName], key2[propertyName], level + 1))
                                        return false;
                                for (propertyName in key2)
                                    if (!(propertyName in key1))
                                        return false;
                                return true
                            }
                            else if (commonUtils.isArray(key1) && commonUtils.isArray(key2)) {
                                if (key1.length !== key2.length)
                                    return false;
                                for (i = 0; i < key1.length; i++)
                                    if (!ui.dxDataGrid.equalKeys(key1[i], key2[i], level + 1))
                                        return false;
                                return true
                            }
                            else if (commonUtils.isDate(key1) && commonUtils.isDate(key2))
                                return key1.getTime() === key2.getTime();
                            else
                                return key1 === key2;
                        return true
                    },
                    getIndexByKey: function(key, items, keyName) {
                        var index = -1,
                            item;
                        if (commonUtils.isArray(items)) {
                            keyName = arguments.length <= 2 && "key" || keyName;
                            for (var i = 0; i < items.length; i++) {
                                item = commonUtils.isDefined(keyName) ? items[i][keyName] : items[i];
                                if (ui.dxDataGrid.equalKeys(key, item)) {
                                    index = i;
                                    break
                                }
                            }
                        }
                        return index
                    },
                    normalizeSortingInfo: function(sort) {
                        sort = sort || [];
                        var result,
                            i;
                        result = DX.data.utils.normalizeSortingInfo(sort);
                        for (i = 0; i < sort.length; i++)
                            if (sort && sort[i] && sort[i].isExpanded !== undefined)
                                result[i].isExpanded = sort[i].isExpanded;
                        return result
                    },
                    getFormatByDataType: function(dataType) {
                        switch (dataType) {
                            case"date":
                                return "shortDate"
                        }
                    },
                    defaultCalculateFilterExpression: function(filterValue, selectedFilterOperation, target) {
                        var column = this,
                            selector = getFilterSelector(column, target),
                            isSearchByDisplayValue = column.calculateDisplayValue && target === "search",
                            dataType = isSearchByDisplayValue && column.lookup && column.lookup.dataType || column.dataType,
                            filter = null;
                        if (target === "headerFilter" && filterValue === null)
                            filter = [selector, selectedFilterOperation || "=", null];
                        else if (dataType === "string" && (!column.lookup || isSearchByDisplayValue))
                            filter = [selector, selectedFilterOperation || "contains", filterValue];
                        else if (column.selectedFilterOperation === "between")
                            return getFilterExpressionByRange.apply(column, arguments);
                        else if (dataType === "date" && commonUtils.isDefined(filterValue))
                            return getFilterExpressionForDate.apply(column, arguments);
                        else if (dataType === "number")
                            return getFilterExpressionForNumber.apply(column, arguments);
                        else if (dataType !== "object")
                            filter = [selector, selectedFilterOperation || "=", filterValue];
                        return filter
                    },
                    getGroupDataSourceParameters: function(column) {
                        var result = [],
                            groupInterval = this.getGroupInterval(column);
                        if (groupInterval)
                            if (column.dataType === "date") {
                                $.each(groupInterval, function(_, value) {
                                    result.push($.proxy(getIntervalSelector, column, value))
                                });
                                return result
                            }
                            else if (column.dataType === "number") {
                                $.each(groupInterval, function(index, interval) {
                                    result.push($.proxy(getIntervalSelector, column, interval))
                                });
                                return result
                            }
                        return function(data) {
                                var result = column.calculateCellValue(data);
                                if (result === undefined)
                                    result = null;
                                return result
                            }
                    },
                    getGroupInterval: function(column) {
                        var index,
                            result = [],
                            dateIntervals = ["year", "month", "day", "hour", "minute", "second"],
                            groupInterval = column.headerFilter && column.headerFilter.groupInterval,
                            interval = groupInterval === "quarter" ? "month" : groupInterval;
                        if (column.dataType === "date") {
                            result = DEFAULT_DATE_INTERVAL;
                            index = $.inArray(interval, dateIntervals);
                            if (index >= 0) {
                                result = dateIntervals.slice(0, index);
                                result.push(groupInterval);
                                return result
                            }
                            return result
                        }
                        else if (commonUtils.isDefined(groupInterval))
                            return commonUtils.isArray(groupInterval) ? groupInterval : [groupInterval]
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.stateStoring.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            logger = DX.require("/utils/utils.console").logger,
            storageUtils = DX.require("/utils/utils.storage"),
            commonUtils = DX.require("/utils/utils.common");
        var DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;
        var parseDates = function(state) {
                if (!state)
                    return;
                $.each(state, function(key, value) {
                    var date;
                    if ($.isPlainObject(value) || $.isArray(value))
                        parseDates(value);
                    else if (typeof value === "string") {
                        date = DATE_REGEX.exec(value);
                        if (date)
                            state[key] = new Date(Date.UTC(+date[1], +date[2] - 1, +date[3], +date[4], +date[5], +date[6]))
                    }
                })
            };
        var processLoadState = function(that) {
                var columnsController = that.getController("columns"),
                    selectionController = that.getController("selection"),
                    exportController = that.getController("export"),
                    dataController = that.getController("data"),
                    pagerView = that.getView("pagerView");
                if (columnsController)
                    columnsController.columnsChanged.add(function() {
                        var columnsState = columnsController.getUserState();
                        if (!dataGrid.equalKeys(that._state.columns, columnsState)) {
                            $.extend(that._state, {columns: columnsState});
                            that.isEnabled() && that.save()
                        }
                    });
                if (selectionController)
                    selectionController.selectionChanged.add(function(keys) {
                        $.extend(that._state, {selectedRowKeys: keys});
                        that.isEnabled() && that.save()
                    });
                if (dataController) {
                    that._initialPageSize = that.option("paging.pageSize");
                    dataController.changed.add(function() {
                        $.extend(that._state, {
                            searchText: that.option("searchPanel.text"),
                            pageIndex: dataController.pageIndex(),
                            pageSize: dataController.pageSize(),
                            allowedPageSizes: pagerView ? pagerView.getPageSizes() : undefined
                        });
                        that.isEnabled() && that.save()
                    })
                }
                if (exportController)
                    exportController.selectionOnlyChanged.add(function() {
                        $.extend(that._state, {exportSelectionOnly: exportController.selectionOnly()});
                        that.isEnabled() && that.save()
                    })
            };
        var applyState = function(that, state) {
                var allowedPageSizes = state.allowedPageSizes,
                    searchText = state.searchText,
                    selectedRowKeys = state.selectedRowKeys,
                    exportController = that.getController("export"),
                    columnsController = that.getController("columns"),
                    scrollingMode = that.option("scrolling.mode");
                that.component.beginUpdate();
                if (columnsController)
                    columnsController.setUserState(state.columns);
                if (exportController)
                    exportController.selectionOnly(state.exportSelectionOnly);
                that.option("selectedRowKeys", selectedRowKeys || []);
                if (allowedPageSizes && that.option("pager.allowedPageSizes") === "auto")
                    that.option("pager").allowedPageSizes = allowedPageSizes;
                that.option("searchPanel.text", searchText || "");
                that.option("paging.pageSize", scrollingMode !== "virtual" && scrollingMode !== "infinite" && state.pageSize ? state.pageSize : that._initialPageSize);
                that.option("paging.pageIndex", state.pageIndex || 0);
                that.component.endUpdate()
            };
        dataGrid.StateStoringController = dataGrid.ViewController.inherit(function() {
            var getStorage = function(options) {
                    var storage = options.type === "sessionStorage" ? storageUtils.sessionStorage() : localStorage;
                    if (!storage)
                        throw new Error("E1007");
                    return storage
                };
            var getUniqueStorageKey = function(options) {
                    return commonUtils.isDefined(options.storageKey) ? options.storageKey : "storage"
                };
            return {
                    _loadState: function() {
                        var options = this.option("stateStoring");
                        if (options.type === "custom")
                            return options.customLoad && options.customLoad();
                        try {
                            return JSON.parse(getStorage(options).getItem(getUniqueStorageKey(options)))
                        }
                        catch(e) {
                            logger.error(e.message)
                        }
                    },
                    _saveState: function(state) {
                        var options = this.option("stateStoring");
                        if (options.type === "custom") {
                            options.customSave && options.customSave(state);
                            return
                        }
                        try {
                            getStorage(options).setItem(getUniqueStorageKey(options), JSON.stringify(state))
                        }
                        catch(e) {}
                    },
                    publicMethods: function() {
                        return ["state"]
                    },
                    isEnabled: function() {
                        return this.option("stateStoring.enabled")
                    },
                    init: function() {
                        var that = this;
                        that._state = {};
                        that._isLoaded = false;
                        that._isLoading = false;
                        that._windowUnloadHandler = function() {
                            if (that._savingTimeoutID !== undefined)
                                that._saveState(that.state())
                        },
                        $(window).on("unload", that._windowUnloadHandler);
                        return that
                    },
                    isLoaded: function() {
                        return this._isLoaded
                    },
                    isLoading: function() {
                        return this._isLoading
                    },
                    load: function() {
                        var that = this,
                            loadResult;
                        that._isLoading = true;
                        loadResult = that._loadState();
                        if (!loadResult || !$.isFunction(loadResult.done))
                            loadResult = $.Deferred().resolve(loadResult);
                        loadResult.done(function(state) {
                            that._isLoaded = true;
                            that._isLoading = false;
                            that.state(state)
                        });
                        return loadResult
                    },
                    state: function(state) {
                        var that = this;
                        if (!arguments.length)
                            return $.extend(true, {}, that._state);
                        else {
                            that._state = $.extend({}, state);
                            parseDates(that._state)
                        }
                    },
                    save: function() {
                        var that = this;
                        clearTimeout(that._savingTimeoutID);
                        that._savingTimeoutID = setTimeout(function() {
                            that._saveState(that.state());
                            that._savingTimeoutID = undefined
                        }, that.option("stateStoring.savingTimeout"))
                    },
                    optionChanged: function(args) {
                        var that = this;
                        switch (args.name) {
                            case"stateStoring":
                                if (that.isEnabled() && that.isLoaded())
                                    that.load();
                                args.handled = true;
                                break;
                            default:
                                that.callBase(args)
                        }
                    },
                    dispose: function() {
                        clearTimeout(this._savingTimeoutID);
                        $(window).off("unload", this._windowUnloadHandler)
                    }
                }
        }());
        dataGrid.registerModule("stateStoring", {
            defaultOptions: function() {
                return {stateStoring: {
                            enabled: false,
                            storageKey: null,
                            type: "localStorage",
                            customLoad: null,
                            customSave: null,
                            savingTimeout: 2000
                        }}
            },
            controllers: {stateStoring: ui.dxDataGrid.StateStoringController},
            extenders: {controllers: {
                    stateStoring: {
                        init: function() {
                            this.callBase.apply(this, arguments);
                            processLoadState(this)
                        },
                        state: function(state) {
                            var result = this.callBase.apply(this, arguments);
                            if (state !== undefined)
                                applyState(this, $.extend({}, state));
                            return result
                        }
                    },
                    columns: {getVisibleColumns: function() {
                            var visibleColumns = this.callBase(),
                                stateStoringController = this.getController("stateStoring");
                            return stateStoringController.isEnabled() && !stateStoringController.isLoaded() ? [] : visibleColumns
                        }},
                    data: {
                        _refreshDataSource: function() {
                            var that = this,
                                callBase = that.callBase,
                                stateStoringController = that.getController("stateStoring");
                            if (stateStoringController.isEnabled() && !stateStoringController.isLoaded()) {
                                clearTimeout(that._restoreStateTimeoutID);
                                that._restoreStateTimeoutID = setTimeout(function() {
                                    stateStoringController.load().always(function() {
                                        that._restoreStateTimeoutID = null;
                                        callBase.call(that)
                                    })
                                })
                            }
                            else if (!that._restoreStateTimeoutID)
                                callBase.call(that)
                        },
                        isLoading: function() {
                            var that = this,
                                stateStoringController = that.getController("stateStoring");
                            return this.callBase() || stateStoringController.isLoading()
                        },
                        dispose: function() {
                            clearTimeout(this._restoreStateTimeoutID);
                            this.callBase()
                        }
                    }
                }}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnsController.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            errors = DX.require("/ui/ui.errors"),
            dataGrid = ui.dxDataGrid,
            normalizeSortingInfo = dataGrid.normalizeSortingInfo,
            normalizeIndexes = DX.require("/utils/utils.array").normalizeIndexes,
            objectUtils = DX.require("/utils/utils.object"),
            inflector = DX.require("/utils/utils.inflector"),
            dateUtils = DX.require("/utils/utils.date"),
            commonUtils = DX.require("/utils/utils.common"),
            knockoutUtils = DX.require("/utils/utils.knockout"),
            dataUtils = DX.data.utils,
            isDefined = commonUtils.isDefined;
        var USER_STATE_FIELD_NAMES_15_1 = ["filterValues", "filterType", "fixed", "fixedPosition"],
            USER_STATE_FIELD_NAMES = ["visibleIndex", "dataField", "name", "dataType", "width", "visible", "sortOrder", "sortIndex", "groupIndex", "filterValue", "selectedFilterOperation"].concat(USER_STATE_FIELD_NAMES_15_1),
            DATAGRID_COMMAND_EXPAND_CLASS = "dx-command-expand";
        dataGrid.checkChanges = function(changes, changeNames) {
            var changesWithChangeNamesCount = 0,
                i;
            for (i = 0; i < changeNames.length; i++)
                if (changes[changeNames[i]])
                    changesWithChangeNamesCount++;
            return changes.length && changes.length === changesWithChangeNamesCount
        };
        var ColumnsController = dataGrid.Controller.inherit(function() {
                var DEFAULT_COLUMN_OPTIONS = {
                        visible: true,
                        showInColumnChooser: true
                    },
                    DATATYPE_OPERATIONS = {
                        number: ["=", "<>", "<", ">", "<=", ">=", "between"],
                        string: ["contains", "notcontains", "startswith", "endswith", "=", "<>"],
                        date: ["=", "<>", "<", ">", "<=", ">=", "between"]
                    },
                    COLUMN_INDEX_OPTIONS = {
                        visibleIndex: true,
                        groupIndex: true,
                        grouped: true,
                        sortIndex: true,
                        sortOrder: true
                    },
                    GROUP_LOCATION = "group",
                    COLUMN_CHOOSER_LOCATION = "columnChooser";
                var createColumn = function(that, columnOptions, userStateColumnOptions) {
                        var commonColumnOptions,
                            calculatedColumnOptions;
                        if (columnOptions) {
                            if (commonUtils.isString(columnOptions))
                                columnOptions = {dataField: columnOptions};
                            if (columnOptions.command)
                                return $.extend(true, {}, columnOptions);
                            else {
                                commonColumnOptions = that.getCommonSettings();
                                if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField)
                                    columnOptions = $.extend({}, columnOptions, {dataField: userStateColumnOptions.dataField});
                                calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions);
                                return $.extend(true, {}, DEFAULT_COLUMN_OPTIONS, commonColumnOptions, calculatedColumnOptions, columnOptions, {selector: null})
                            }
                        }
                    };
                var createColumnsFromOptions = function(that, columnsOptions) {
                        var result = [];
                        if (columnsOptions)
                            $.each(columnsOptions, function(index, columnOptions) {
                                var userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[index]) && that._columnsUserState[index],
                                    column = createColumn(that, columnOptions, userStateColumnOptions);
                                if (column)
                                    result.push(column)
                            });
                        return result
                    };
                var getValueDataType = function(value) {
                        var dataType = $.type(value);
                        if (dataType !== "string" && dataType !== "boolean" && dataType !== "number" && dataType !== "date" && dataType !== "object")
                            dataType = undefined;
                        return dataType
                    };
                var getSerializationFormat = function(dataType, value) {
                        switch (dataType) {
                            case"date":
                                if (commonUtils.isNumber(value))
                                    return "number";
                                else if (commonUtils.isString(value))
                                    return "yyyy/MM/dd";
                                break;
                            case"number":
                                if (commonUtils.isString(value))
                                    return "string"
                        }
                    };
                var updateSerializers = function(options, dataType) {
                        if (!options.deserializeValue) {
                            if (dataType === "date") {
                                options.deserializeValue = function(value) {
                                    return dateUtils.deserializeDate(value, this.serializationFormat)
                                };
                                options.serializeValue = function(value) {
                                    return dateUtils.serializeDate(value, this.serializationFormat)
                                }
                            }
                            if (dataType === "number") {
                                options.deserializeValue = function(value) {
                                    return commonUtils.isDefined(value) ? Number(value) : value
                                };
                                options.serializeValue = function(value) {
                                    return commonUtils.isDefined(value) && this.serializationFormat === "string" ? value.toString() : value
                                }
                            }
                        }
                    };
                var getAlignmentByDataType = function(dataType, isRTL) {
                        switch (dataType) {
                            case"number":
                                return "right";
                            case"boolean":
                                return "center";
                            default:
                                return commonUtils.getDefaultAlignment(isRTL)
                        }
                    };
                var getCustomizeTextByDataType = function(dataType) {
                        if (dataType === "boolean")
                            return function(e) {
                                    if (e.value === true)
                                        return this.trueText || "true";
                                    else if (e.value === false)
                                        return this.falseText || "false";
                                    else
                                        return e.valueText || ""
                                }
                    };
                var createColumnsFromDataSource = function(that, dataSource) {
                        var firstItems = getFirstItems(dataSource),
                            fieldName,
                            processedFields = {},
                            i,
                            result = [];
                        for (i = 0; i < firstItems.length; i++)
                            if (firstItems[i])
                                for (fieldName in firstItems[i])
                                    processedFields[fieldName] = true;
                        for (fieldName in processedFields)
                            if (fieldName.indexOf("__") !== 0) {
                                var column = createColumn(that, fieldName);
                                result.push(column)
                            }
                        return result
                    };
                var equalSortParameters = dataGrid.equalSortParameters = function(sortParameters1, sortParameters2) {
                        var i;
                        sortParameters1 = $.isPlainObject(sortParameters1) ? [sortParameters1] : sortParameters1;
                        sortParameters2 = $.isPlainObject(sortParameters2) ? [sortParameters2] : sortParameters2;
                        if ($.isArray(sortParameters1) && $.isArray(sortParameters2)) {
                            if (sortParameters1.length !== sortParameters2.length)
                                return false;
                            else
                                for (i = 0; i < sortParameters1.length; i++)
                                    if (sortParameters1[i].selector !== sortParameters2[i].selector || sortParameters1[i].desc !== sortParameters2[i].desc || Boolean(sortParameters1[i].isExpanded) !== Boolean(sortParameters2[i].isExpanded))
                                        return false;
                            return true
                        }
                        else
                            return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length)
                    };
                var equalFilterParameters = dataGrid.equalFilterParameters = function(filter1, filter2) {
                        var i;
                        if ($.isArray(filter1) && $.isArray(filter2)) {
                            if (filter1.length !== filter2.length)
                                return false;
                            else
                                for (i = 0; i < filter1.length; i++)
                                    if (!equalFilterParameters(filter1[i], filter2[i]))
                                        return false;
                            return true
                        }
                        else if ($.isFunction(filter1) && filter1.columnIndex >= 0 && $.isFunction(filter2) && filter2.columnIndex >= 0)
                            return filter1.columnIndex === filter2.columnIndex;
                        else
                            return dataUtils.toComparable(filter1) === dataUtils.toComparable(filter2)
                    };
                var getFirstItems = function(dataSource) {
                        var groupsCount,
                            items = [];
                        var getFirstItemsCore = function(items, groupsCount) {
                                var i,
                                    childItems;
                                if (!items || !groupsCount)
                                    return items;
                                for (i = 0; i < items.length; i++) {
                                    childItems = getFirstItemsCore(items[i].items || items[i].collapsedItems, groupsCount - 1);
                                    if (childItems && childItems.length)
                                        return childItems
                                }
                            };
                        if (dataSource && dataSource.items().length > 0) {
                            groupsCount = normalizeSortingInfo(dataSource.group()).length;
                            items = getFirstItemsCore(dataSource.items(), groupsCount) || []
                        }
                        return items
                    };
                var updateColumnIndexes = function(that) {
                        $.each(that._columns, function(index, column) {
                            column.index = index
                        });
                        $.each(that._commandColumns, function(index, column) {
                            column.index = -(index + 1)
                        })
                    };
                var updateColumnGroupIndexes = function(that, currentColumn) {
                        normalizeIndexes(that._columns, "groupIndex", currentColumn, function(column) {
                            var grouped = column.grouped;
                            delete column.grouped;
                            return grouped
                        })
                    };
                var updateColumnSortIndexes = function(that, currentColumn) {
                        $.each(that._columns, function(index, column) {
                            if (isDefined(column.sortIndex) && !isSortOrderValid(column.sortOrder))
                                delete column.sortIndex
                        });
                        normalizeIndexes(that._columns, "sortIndex", currentColumn, function(column) {
                            return !isDefined(column.groupIndex) && isSortOrderValid(column.sortOrder)
                        })
                    };
                var updateColumnVisibleIndexes = function(that, currentColumn) {
                        normalizeIndexes(that._columns, "visibleIndex", currentColumn)
                    };
                var getColumnIndexByVisibleIndex = function(that, visibleIndex, location) {
                        var columns = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getChooserColumns() : that.getVisibleColumns(),
                            column = columns[visibleIndex];
                        return column && isDefined(column.index) ? column.index : -1
                    };
                var moveColumnToGroup = function(that, column, groupIndex) {
                        var groupColumns = that.getGroupColumns(),
                            i;
                        if (groupIndex >= 0) {
                            for (i = 0; i < groupColumns.length; i++)
                                if (groupColumns[i].groupIndex >= groupIndex)
                                    groupColumns[i].groupIndex++
                        }
                        else {
                            groupIndex = 0;
                            for (i = 0; i < groupColumns.length; i++)
                                groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1)
                        }
                        column.groupIndex = groupIndex
                    };
                var checkUserStateColumn = function(column, userStateColumn) {
                        return column && userStateColumn && userStateColumn.name === column.name && (userStateColumn.dataField === column.dataField || column.name)
                    };
                var applyUserState = function(that) {
                        var columnsUserState = that._columnsUserState,
                            ignoreColumnOptionNames = that._ignoreColumnOptionNames || [],
                            columns = that._columns,
                            resultColumns = [],
                            column,
                            i;
                        function handleStateField(index, fieldName) {
                            if ($.inArray(fieldName, ignoreColumnOptionNames) >= 0)
                                return;
                            if (fieldName === "dataType")
                                column[fieldName] = column[fieldName] || columnsUserState[i][fieldName];
                            else if ($.inArray(fieldName, USER_STATE_FIELD_NAMES_15_1) >= 0) {
                                if (fieldName in columnsUserState[i])
                                    column[fieldName] = columnsUserState[i][fieldName]
                            }
                            else
                                column[fieldName] = columnsUserState[i][fieldName]
                        }
                        if (columnsUserState) {
                            if (columns.length !== columnsUserState.length)
                                return;
                            for (i = 0; i < columnsUserState.length; i++) {
                                column = isDefined(columnsUserState[i].initialIndex) ? columns[columnsUserState[i].initialIndex] : columns[i];
                                if (column && checkUserStateColumn(column, columnsUserState[i])) {
                                    column = $.extend({}, column);
                                    $.each(USER_STATE_FIELD_NAMES, handleStateField);
                                    resultColumns.push(column)
                                }
                                else
                                    return
                            }
                            assignColumns(that, resultColumns)
                        }
                    };
                var updateIndexes = function(that, column) {
                        updateColumnIndexes(that);
                        updateColumnGroupIndexes(that, column);
                        updateColumnSortIndexes(that, column);
                        updateColumnVisibleIndexes(that, column)
                    };
                var assignColumns = function(that, columns) {
                        that._columns = columns;
                        that._visibleColumns = undefined;
                        that.updateColumnDataTypes()
                    };
                var updateColumnChanges = function(that, changeType, optionName, columnIndex) {
                        var columnChanges = that._columnChanges || {
                                optionNames: {length: 0},
                                changeTypes: {length: 0},
                                columnIndex: columnIndex
                            };
                        optionName = optionName || "all";
                        var changeTypes = columnChanges.changeTypes;
                        if (changeType && !changeTypes[changeType]) {
                            changeTypes[changeType] = true;
                            changeTypes.length++
                        }
                        var optionNames = columnChanges.optionNames;
                        if (optionName && !optionNames[optionName]) {
                            optionNames[optionName] = true;
                            optionNames.length++
                        }
                        if (columnIndex === undefined || columnIndex !== columnChanges.columnIndex)
                            delete columnChanges.columnIndex;
                        that._columnChanges = columnChanges;
                        that._visibleColumns = undefined
                    };
                var fireColumnsChanged = function(that) {
                        var onColumnsChanging = that.option("onColumnsChanging"),
                            columnChanges = that._columnChanges;
                        if (that.isInitialized() && !that._updateLockCount && columnChanges) {
                            if (onColumnsChanging) {
                                that._updateLockCount++;
                                onColumnsChanging($.extend({component: that.component}, columnChanges));
                                that._updateLockCount--
                            }
                            that._columnChanges = undefined;
                            if (columnChanges.optionNames && columnChanges.optionNames.dataField)
                                that.reinit();
                            that.columnsChanged.firing = true;
                            that.columnsChanged.fire(columnChanges);
                            that.columnsChanged.firing = false
                        }
                    };
                var columnOptionCore = function(that, column, optionName, value, notFireEvent) {
                        var optionGetter = dataUtils.compileGetter(optionName),
                            changeType;
                        if (arguments.length === 3)
                            return optionGetter(column, {functionsAsIs: true});
                        if (optionGetter(column, {functionsAsIs: true}) !== value) {
                            if (optionName === "groupIndex")
                                changeType = "grouping";
                            else if (optionName === "sortIndex" || optionName === "sortOrder")
                                changeType = "sorting";
                            else
                                changeType = "columns";
                            dataUtils.compileSetter(optionName)(column, value, {functionsAsIs: true});
                            if (!notFireEvent)
                                updateColumnChanges(that, changeType, optionName, column.index)
                        }
                    };
                var isSortOrderValid = function(sortOrder) {
                        return sortOrder === "asc" || sortOrder === "desc"
                    };
                var addExpandColumn = function(that) {
                        that.addCommandColumn({
                            command: "expand",
                            width: "auto",
                            cssClass: DATAGRID_COMMAND_EXPAND_CLASS,
                            allowEditing: false,
                            allowGrouping: false,
                            allowSorting: false,
                            allowResizing: false,
                            allowReordering: false,
                            allowHiding: false
                        })
                    };
                var defaultSetCellValue = function(data, value) {
                        var path = this.dataField.split("."),
                            dotCount = path.length - 1,
                            name,
                            i;
                        if (this.serializeValue)
                            value = this.serializeValue(value);
                        for (i = 0; i < dotCount; i++) {
                            name = path[i];
                            data = data[name] = data[name] || {}
                        }
                        data[path[dotCount]] = value
                    };
                return {
                        _endUpdateCore: function() {
                            fireColumnsChanged(this)
                        },
                        init: function() {
                            var that = this,
                                columns = that.option("columns");
                            that._commandColumns = that._commandColumns || [];
                            that._columns = that._columns || [];
                            addExpandColumn(that);
                            that._isColumnsFromOptions = !!columns;
                            if (that._isColumnsFromOptions) {
                                assignColumns(that, columns ? createColumnsFromOptions(that, columns) : []);
                                applyUserState(that)
                            }
                            else
                                assignColumns(that, that._columnsUserState ? createColumnsFromOptions(that, that._columnsUserState) : that._columns);
                            if (that._dataSourceApplied)
                                that.applyDataSource(that._dataSource, true);
                            else
                                updateIndexes(that)
                        },
                        callbackNames: function() {
                            return ["columnsChanged"]
                        },
                        optionChanged: function(args) {
                            switch (args.name) {
                                case"columns":
                                    args.handled = true;
                                    this._columnsUserState = null;
                                    this._ignoreColumnOptionNames = null;
                                    this.init();
                                    break;
                                case"commonColumnSettings":
                                case"columnAutoWidth":
                                case"allowColumnResizing":
                                case"allowColumnReordering":
                                case"columnFixing":
                                case"grouping":
                                case"groupPanel":
                                case"regenerateColumnsByVisibleItems":
                                case"customizeColumns":
                                case"editing":
                                    args.handled = true;
                                    this.reinit();
                                    break;
                                case"rtlEnabled":
                                    this.reinit();
                                    break;
                                default:
                                    this.callBase(args)
                            }
                        },
                        publicMethods: function() {
                            return ["addColumn", "columnOption", "columnCount", "clearSorting", "clearGrouping"]
                        },
                        applyDataSource: function(dataSource, forceApplying) {
                            var that = this,
                                isDataSourceLoaded = dataSource && dataSource.isLoaded();
                            that._dataSource = dataSource;
                            if (!that._dataSourceApplied || that._dataSourceColumnsCount === 0 || forceApplying || that.option("regenerateColumnsByVisibleItems"))
                                if (isDataSourceLoaded) {
                                    if (!that._isColumnsFromOptions) {
                                        assignColumns(that, createColumnsFromDataSource(that, dataSource));
                                        that._dataSourceColumnsCount = that._columns.length;
                                        applyUserState(that)
                                    }
                                    return that.updateColumns(dataSource, forceApplying)
                                }
                        },
                        reset: function() {
                            this._dataSourceApplied = false;
                            this._dataSourceColumnsCount = undefined;
                            this.reinit()
                        },
                        reinit: function() {
                            this._columnsUserState = this.getUserState();
                            this._ignoreColumnOptionNames = null;
                            this.init()
                        },
                        isInitialized: function() {
                            return !!this._columns.length
                        },
                        isDataSourceApplied: function() {
                            return this._dataSourceApplied
                        },
                        getCommonSettings: function() {
                            var commonColumnSettings = this.option("commonColumnSettings") || {},
                                groupingOptions = this.option("grouping") || {},
                                groupPanelOptions = this.option("groupPanel") || {};
                            return $.extend({
                                    allowFixing: this.option("columnFixing.enabled"),
                                    allowResizing: this.option("allowColumnResizing"),
                                    allowReordering: this.option("allowColumnReordering"),
                                    autoExpandGroup: groupingOptions.autoExpandAll,
                                    allowCollapsing: groupingOptions.allowCollapsing,
                                    allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible
                                }, commonColumnSettings)
                        },
                        isColumnOptionUsed: function(optionName) {
                            for (var i = 0; i < this._columns.length; i++)
                                if (this._columns[i][optionName])
                                    return true
                        },
                        isAllDataTypesDefined: function() {
                            var columns = this._columns,
                                i;
                            if (!columns.length)
                                return false;
                            for (i = 0; i < columns.length; i++)
                                if (!columns[i].dataType)
                                    return false;
                            return true
                        },
                        getColumns: function() {
                            return this._columns
                        },
                        getGroupColumns: function() {
                            var result = [];
                            $.each(this._columns, function() {
                                var column = this;
                                if (isDefined(column.groupIndex))
                                    result[column.groupIndex] = column
                            });
                            return result
                        },
                        getVisibleColumns: function() {
                            this._visibleColumns = this._visibleColumns || this._getVisibleColumnsCore();
                            return this._visibleColumns
                        },
                        getFixedColumns: function() {
                            var that = this,
                                result = [],
                                isColumnFixing = that._isColumnFixing(),
                                notFixedColumnCount = 0,
                                transparentColumnIndex,
                                visibleColumns;
                            if (isColumnFixing) {
                                visibleColumns = that.getVisibleColumns();
                                $.each(visibleColumns, function(index, column) {
                                    if (!column.command && !column.fixed) {
                                        notFixedColumnCount++;
                                        if (!isDefined(transparentColumnIndex))
                                            transparentColumnIndex = index
                                    }
                                });
                                if (notFixedColumnCount < visibleColumns.length) {
                                    result = visibleColumns.slice(0);
                                    notFixedColumnCount > 0 && result.splice(transparentColumnIndex, notFixedColumnCount, {
                                        command: "transparent",
                                        colspan: notFixedColumnCount
                                    })
                                }
                            }
                            return result
                        },
                        _isColumnFixing: function() {
                            var isColumnFixing = this.option("columnFixing.enabled");
                            !isColumnFixing && $.each(this._columns, function(_, column) {
                                if (column.fixed) {
                                    isColumnFixing = true;
                                    return false
                                }
                            });
                            return isColumnFixing
                        },
                        _getExpandColumnsCore: function() {
                            return this.getGroupColumns()
                        },
                        getExpandColumns: function() {
                            var expandColumns = this._getExpandColumnsCore(),
                                expandColumn;
                            if (expandColumns.length)
                                expandColumn = this.columnOption("command:expand");
                            expandColumns = $.map(expandColumns, function(column) {
                                return $.extend({}, column, {visibleWidth: "auto"}, expandColumn, {index: column.index})
                            });
                            return expandColumns
                        },
                        _getVisibleColumnsCore: function() {
                            var result = this.getExpandColumns(),
                                positiveIndexedColumns = [{}, {}, {}],
                                negativeIndexedColumns = {},
                                notGroupedColumnsCount = 0,
                                isFixedToEnd,
                                rtlEnabled = this.option("rtlEnabled"),
                                columns = this._columns.length ? this._commandColumns.concat(this._columns) : [];
                            $.each(columns, function() {
                                var column = this,
                                    visibleIndex = column.visibleIndex,
                                    indexedColumns;
                                if (column.visible && (!isDefined(column.groupIndex) || column.showWhenGrouped)) {
                                    column = $.extend(true, {}, column);
                                    if (visibleIndex < 0) {
                                        visibleIndex = -visibleIndex;
                                        indexedColumns = negativeIndexedColumns
                                    }
                                    else if (column.fixed || column.command) {
                                        isFixedToEnd = column.fixedPosition === "right";
                                        if (rtlEnabled)
                                            isFixedToEnd = !isFixedToEnd;
                                        if (isFixedToEnd || column.command)
                                            indexedColumns = positiveIndexedColumns[2];
                                        else
                                            indexedColumns = positiveIndexedColumns[0]
                                    }
                                    else
                                        indexedColumns = positiveIndexedColumns[1];
                                    indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];
                                    indexedColumns[visibleIndex].push(column);
                                    notGroupedColumnsCount++
                                }
                            });
                            objectUtils.orderEach(negativeIndexedColumns, function(_, columns) {
                                result.unshift.apply(result, columns)
                            });
                            $.each(positiveIndexedColumns, function(index, positiveColumns) {
                                objectUtils.orderEach(positiveColumns, function(_, columns) {
                                    result.push.apply(result, columns)
                                })
                            });
                            if (!notGroupedColumnsCount && this._columns.length)
                                result.push({command: "empty"});
                            return result
                        },
                        getHiddenColumns: function() {
                            var result = [];
                            $.each(this._columns, function(_, column) {
                                if (!column.visible)
                                    result.push(column)
                            });
                            return result
                        },
                        getChooserColumns: function() {
                            return $.grep(this.getHiddenColumns(), function(column) {
                                    return column.showInColumnChooser
                                })
                        },
                        allowMoveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                            var that = this,
                                columnIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation),
                                sourceColumn = that._columns[columnIndex];
                            if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {
                                if (sourceLocation === targetLocation) {
                                    if (sourceLocation === COLUMN_CHOOSER_LOCATION)
                                        return false;
                                    return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex
                                }
                                else if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION)
                                    return sourceColumn && sourceColumn.allowGrouping;
                                else if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION)
                                    return sourceColumn && sourceColumn.allowHiding;
                                return true
                            }
                            return false
                        },
                        moveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                            var that = this,
                                fromIndex,
                                toIndex,
                                targetGroupIndex,
                                isGroupMoving = sourceLocation === GROUP_LOCATION || targetLocation === GROUP_LOCATION,
                                column;
                            fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation);
                            toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation);
                            if (fromIndex >= 0) {
                                column = that._columns[fromIndex];
                                targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;
                                if (isDefined(column.groupIndex) && sourceLocation === GROUP_LOCATION) {
                                    if (targetGroupIndex > column.groupIndex)
                                        targetGroupIndex--;
                                    delete column.groupIndex;
                                    delete column.sortOrder;
                                    updateColumnGroupIndexes(that)
                                }
                                if (targetLocation === GROUP_LOCATION) {
                                    moveColumnToGroup(that, column, targetGroupIndex);
                                    updateColumnGroupIndexes(that)
                                }
                                else if (toVisibleIndex >= 0) {
                                    if (toIndex < 0)
                                        column.visibleIndex = undefined;
                                    else {
                                        var targetColumn = that._columns[toIndex];
                                        if (column.fixed ^ targetColumn.fixed)
                                            column.visibleIndex = undefined;
                                        else
                                            column.visibleIndex = targetColumn.visibleIndex
                                    }
                                    updateColumnVisibleIndexes(that, column)
                                }
                                column.visible = targetLocation !== COLUMN_CHOOSER_LOCATION;
                                updateColumnChanges(that, isGroupMoving ? "grouping" : "columns");
                                fireColumnsChanged(that)
                            }
                        },
                        changeSortOrder: function(columnIndex, sortOrder) {
                            var that = this,
                                sortingOptions = that.option("sorting"),
                                sortingMode = sortingOptions && sortingOptions.mode,
                                needResetSorting = sortingMode === "single" || !sortOrder,
                                allowSorting = sortingMode === "single" || sortingMode === "multiple",
                                column = that._columns[columnIndex],
                                nextSortOrder = function(column) {
                                    if (sortOrder === "ctrl") {
                                        if (!("sortOrder" in column && "sortIndex" in column))
                                            return false;
                                        delete column.sortOrder;
                                        delete column.sortIndex
                                    }
                                    else if (isDefined(column.groupIndex) || isDefined(column.sortIndex))
                                        column.sortOrder = column.sortOrder === "desc" ? "asc" : "desc";
                                    else
                                        column.sortOrder = "asc";
                                    return true
                                },
                                isSortingChanged = false;
                            if (allowSorting && column && column.allowSorting) {
                                if (needResetSorting && !isDefined(column.groupIndex))
                                    $.each(that._columns, function(index) {
                                        if (index !== columnIndex && this.sortOrder && !isDefined(this.groupIndex)) {
                                            delete this.sortOrder;
                                            delete this.sortIndex;
                                            isSortingChanged = true
                                        }
                                    });
                                if (isSortOrderValid(sortOrder)) {
                                    if (column.sortOrder !== sortOrder) {
                                        column.sortOrder = sortOrder;
                                        isSortingChanged = true
                                    }
                                }
                                else if (sortOrder === "none") {
                                    if (column.sortOrder) {
                                        delete column.sortIndex;
                                        delete column.sortOrder;
                                        isSortingChanged = true
                                    }
                                }
                                else
                                    isSortingChanged = nextSortOrder(column)
                            }
                            if (isSortingChanged) {
                                updateColumnSortIndexes(that);
                                updateColumnChanges(that, "sorting");
                                fireColumnsChanged(that)
                            }
                        },
                        getSortDataSourceParameters: function(useLocalSelector) {
                            var that = this,
                                sortColumns = [],
                                sort = [];
                            $.each(that._columns, function() {
                                if ((this.dataField || this.selector || this.calculateCellValue) && isDefined(this.sortIndex) && !isDefined(this.groupIndex))
                                    sortColumns[this.sortIndex] = this
                            });
                            $.each(sortColumns, function() {
                                var sortOrder = this && this.sortOrder;
                                if (isSortOrderValid(sortOrder))
                                    sort.push({
                                        selector: this.calculateSortValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,
                                        desc: this.sortOrder === "desc"
                                    })
                            });
                            return sort.length > 0 ? sort : null
                        },
                        getGroupDataSourceParameters: function(useLocalSelector) {
                            var group = [];
                            $.each(this.getGroupColumns(), function() {
                                var selector = this.calculateGroupValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;
                                if (selector)
                                    group.push({
                                        selector: selector,
                                        desc: this.sortOrder === "desc",
                                        isExpanded: !!this.autoExpandGroup
                                    })
                            });
                            return group.length > 0 ? group : null
                        },
                        refresh: function(updateNewLookupsOnly) {
                            var deferreds = [];
                            $.each(this._columns, function() {
                                var lookup = this.lookup;
                                if (lookup && !this.calculateDisplayValue) {
                                    if (updateNewLookupsOnly && lookup.valueMap)
                                        return;
                                    if (lookup.update)
                                        deferreds.push(lookup.update())
                                }
                            });
                            return $.when.apply($, deferreds)
                        },
                        updateColumnDataTypes: function(dataSource) {
                            var firstItems = getFirstItems(dataSource),
                                rtlEnabled = this.option("rtlEnabled");
                            $.each(this._columns, function(index, column) {
                                var i,
                                    value,
                                    dataType,
                                    lookupDataType,
                                    valueDataType,
                                    lookup = column.lookup;
                                if (column.calculateCellValue && firstItems.length) {
                                    if (!column.dataType || lookup && !lookup.dataType) {
                                        for (i = 0; i < firstItems.length; i++) {
                                            value = column.calculateCellValue(firstItems[i]);
                                            valueDataType = column.dataType || getValueDataType(value);
                                            dataType = dataType || valueDataType;
                                            if (dataType && valueDataType && dataType !== valueDataType)
                                                dataType = "string";
                                            if (lookup) {
                                                valueDataType = lookup.dataType || getValueDataType(dataGrid.getDisplayValue(column, value, firstItems[i]));
                                                lookupDataType = lookupDataType || valueDataType;
                                                if (lookupDataType && valueDataType && lookupDataType !== valueDataType)
                                                    lookupDataType = "string"
                                            }
                                        }
                                        column.dataType = dataType;
                                        if (lookup)
                                            lookup.dataType = lookupDataType
                                    }
                                    if (!column.serializationFormat || lookup && !lookup.serializationFormat)
                                        for (i = 0; i < firstItems.length; i++) {
                                            value = column.calculateCellValue(firstItems[i], true);
                                            column.serializationFormat = column.serializationFormat || getSerializationFormat(column.dataType, value);
                                            if (lookup)
                                                lookup.serializationFormat = lookup.serializationFormat || getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value, true))
                                        }
                                }
                                column.selector = column.selector || function(data) {
                                    return column.calculateCellValue(data)
                                };
                                $.each(["calculateSortValue", "calculateGroupValue"], function(_, calculateCallbackName) {
                                    var calculateCallback = column[calculateCallbackName];
                                    if (commonUtils.isFunction(calculateCallback) && !calculateCallback.isProxy) {
                                        column[calculateCallbackName] = function(data) {
                                            return calculateCallback.call(column, data)
                                        };
                                        column[calculateCallbackName].isProxy = true
                                    }
                                });
                                if (commonUtils.isString(column.calculateDisplayValue)) {
                                    column.displayField = column.calculateDisplayValue;
                                    column.calculateDisplayValue = dataUtils.compileGetter(column.displayField)
                                }
                                if (column.calculateDisplayValue)
                                    column.displayValueMap = column.displayValueMap || {};
                                updateSerializers(column, column.dataType);
                                if (lookup)
                                    updateSerializers(lookup, lookup.dataType);
                                dataType = lookup ? lookup.dataType : column.dataType;
                                if (dataType) {
                                    column.alignment = column.alignment || getAlignmentByDataType(dataType, rtlEnabled);
                                    column.format = column.format || dataGrid.getFormatByDataType(dataType);
                                    column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);
                                    if (!isDefined(column.filterOperations))
                                        column.filterOperations = !lookup && DATATYPE_OPERATIONS[dataType] || [];
                                    column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || "=";
                                    column.defaultSelectedFilterOperation = column.selectedFilterOperation;
                                    column.showEditorAlways = isDefined(column.showEditorAlways) ? column.showEditorAlways : dataType === "boolean" && !column.cellTemplate
                                }
                            })
                        },
                        _customizeColumns: function(columns) {
                            var that = this,
                                customizeColumns = that.option("customizeColumns");
                            if (customizeColumns) {
                                customizeColumns(columns);
                                assignColumns(that, createColumnsFromOptions(that, columns))
                            }
                        },
                        updateColumns: function(dataSource, forceApplying) {
                            var that = this,
                                sortParameters,
                                groupParameters;
                            if (!forceApplying)
                                that.updateSortingGrouping(dataSource);
                            if (!dataSource || dataSource.isLoaded()) {
                                sortParameters = dataSource ? dataSource.sort() || [] : that.getSortDataSourceParameters();
                                groupParameters = dataSource ? dataSource.group() || [] : that.getGroupDataSourceParameters();
                                that._customizeColumns(that._columns);
                                updateIndexes(that);
                                return $.when(that.refresh(true)).always(function() {
                                        if (dataSource) {
                                            that.updateColumnDataTypes(dataSource);
                                            that._dataSourceApplied = true
                                        }
                                        if (!equalSortParameters(sortParameters, that.getSortDataSourceParameters()))
                                            updateColumnChanges(that, "sorting");
                                        if (!equalSortParameters(groupParameters, that.getGroupDataSourceParameters()))
                                            updateColumnChanges(that, "grouping");
                                        updateColumnChanges(that, "columns");
                                        fireColumnsChanged(that)
                                    })
                            }
                        },
                        updateSortingGrouping: function(dataSource, fromDataSource) {
                            var that = this,
                                sortParameters,
                                groupParameters,
                                columnsGroupParameters,
                                columnsSortParameters,
                                isColumnsChanged,
                                updateSortGroupParameterIndexes = function(columns, sortParameters, indexParameterName) {
                                    var i,
                                        selector,
                                        isExpanded;
                                    $.each(columns, function(index, column) {
                                        delete column[indexParameterName];
                                        if (sortParameters)
                                            for (i = 0; i < sortParameters.length; i++) {
                                                selector = sortParameters[i].selector;
                                                isExpanded = sortParameters[i].isExpanded;
                                                if (selector === column.dataField || selector === column.name || selector === column.selector || selector === column.calculateCellValue || selector === column.calculateGroupValue) {
                                                    column.sortOrder = column.sortOrder || (sortParameters[i].desc ? "desc" : "asc");
                                                    if (isExpanded !== undefined)
                                                        column.autoExpandGroup = isExpanded;
                                                    column[indexParameterName] = i;
                                                    break
                                                }
                                            }
                                    })
                                };
                            if (dataSource) {
                                sortParameters = normalizeSortingInfo(dataSource.sort());
                                groupParameters = normalizeSortingInfo(dataSource.group());
                                columnsGroupParameters = that.getGroupDataSourceParameters();
                                columnsSortParameters = that.getSortDataSourceParameters();
                                if (!that._columns.length) {
                                    $.each(groupParameters, function(index, group) {
                                        that._columns.push(group.selector)
                                    });
                                    $.each(sortParameters, function(index, sort) {
                                        that._columns.push(sort.selector)
                                    });
                                    assignColumns(that, createColumnsFromOptions(that, that._columns))
                                }
                                if ((fromDataSource || !columnsGroupParameters && !that._hasUserState) && !equalSortParameters(groupParameters, columnsGroupParameters)) {
                                    that.__groupingUpdated = true;
                                    updateSortGroupParameterIndexes(that._columns, groupParameters, "groupIndex");
                                    if (fromDataSource) {
                                        updateColumnChanges(that, "grouping");
                                        isColumnsChanged = true
                                    }
                                }
                                if ((fromDataSource || !columnsSortParameters && !that._hasUserState) && !equalSortParameters(sortParameters, columnsSortParameters)) {
                                    that.__sortingUpdated = true;
                                    updateSortGroupParameterIndexes(that._columns, sortParameters, "sortIndex");
                                    if (fromDataSource) {
                                        updateColumnChanges(that, "sorting");
                                        isColumnsChanged = true
                                    }
                                }
                                if (isColumnsChanged)
                                    fireColumnsChanged(that)
                            }
                        },
                        updateFilter: function(filter, localFiltering, columnIndex) {
                            var that = this;
                            if (!commonUtils.isArray(filter))
                                return;
                            var column,
                                i;
                            columnIndex = filter.columnIndex || columnIndex;
                            if (localFiltering && commonUtils.isString(filter[0])) {
                                column = that.columnOption(filter[0]);
                                if (column && column.selector) {
                                    filter[0] = column.selector;
                                    filter[0].columnIndex = column.index
                                }
                            }
                            else if (commonUtils.isFunction(filter[0]))
                                filter[0].columnIndex = columnIndex;
                            for (i = 0; i < filter.length; i++)
                                that.updateFilter(filter[i], localFiltering, columnIndex)
                        },
                        columnCount: function() {
                            return this._columns.length
                        },
                        columnOption: function(identificator, option, value, notFireEvent) {
                            var that = this,
                                i,
                                identificatorOptionName = commonUtils.isString(identificator) && identificator.substr(0, identificator.indexOf(":")),
                                columns = identificator < 0 || identificatorOptionName === "command" ? that._commandColumns : that._columns,
                                needUpdateIndexes,
                                column;
                            if (identificator === undefined)
                                return;
                            if (identificatorOptionName)
                                identificator = identificator.substr(identificatorOptionName.length + 1);
                            for (i = 0; i < columns.length; i++)
                                if (identificatorOptionName) {
                                    if ("" + columns[i][identificatorOptionName] === identificator) {
                                        column = columns[i];
                                        break
                                    }
                                }
                                else if (columns[i].index === identificator || columns[i].name === identificator || columns[i].dataField === identificator || columns[i].caption === identificator) {
                                    column = columns[i];
                                    break
                                }
                            if (column) {
                                if (arguments.length === 1)
                                    return $.extend({}, column);
                                if (commonUtils.isString(option))
                                    if (arguments.length === 2)
                                        return columnOptionCore(that, column, option);
                                    else {
                                        needUpdateIndexes = needUpdateIndexes || COLUMN_INDEX_OPTIONS[option];
                                        columnOptionCore(that, column, option, value, notFireEvent)
                                    }
                                else if (commonUtils.isObject(option))
                                    $.each(option, function(optionName, value) {
                                        needUpdateIndexes = needUpdateIndexes || COLUMN_INDEX_OPTIONS[optionName];
                                        columnOptionCore(that, column, optionName, value, notFireEvent)
                                    });
                                if (needUpdateIndexes)
                                    updateIndexes(that, column);
                                fireColumnsChanged(that)
                            }
                        },
                        clearSorting: function() {
                            var that = this,
                                columnCount = this.columnCount(),
                                i;
                            that.beginUpdate();
                            for (i = 0; i < columnCount; i++)
                                that.columnOption(i, "sortOrder", undefined);
                            that.endUpdate()
                        },
                        clearGrouping: function() {
                            var that = this,
                                columnCount = this.columnCount(),
                                i;
                            that.beginUpdate();
                            for (i = 0; i < columnCount; i++)
                                that.columnOption(i, "groupIndex", undefined);
                            that.endUpdate()
                        },
                        getVisibleIndex: function(index) {
                            var i,
                                visibleColumns = this.getVisibleColumns();
                            for (i = 0; i < visibleColumns.length; i++)
                                if (visibleColumns[i].index === index)
                                    return i;
                            return -1
                        },
                        addColumn: function(options) {
                            var that = this,
                                column = createColumn(that, options);
                            that._columns.push(column);
                            updateIndexes(that, column);
                            that.updateColumns(that._dataSource)
                        },
                        deleteColumn: function(id) {
                            var that = this,
                                columnIndex = that.columnOption(id, "index");
                            if (columnIndex >= 0) {
                                that._columns.splice(columnIndex, 1);
                                updateIndexes(that);
                                that.updateColumns(that._dataSource)
                            }
                        },
                        addCommandColumn: function(options) {
                            var commandColumns = this._commandColumns,
                                i;
                            for (i = 0; i < commandColumns.length; i++)
                                if (commandColumns[i].command === options.command)
                                    return;
                            commandColumns.push(options)
                        },
                        getUserState: function() {
                            var columns = this._columns,
                                result = [],
                                i;
                            function handleStateField(index, value) {
                                if (columns[i][value] !== undefined)
                                    result[i][value] = columns[i][value]
                            }
                            for (i = 0; i < columns.length; i++) {
                                result[i] = {};
                                $.each(USER_STATE_FIELD_NAMES, handleStateField)
                            }
                            return result
                        },
                        setUserState: function(state) {
                            var that = this,
                                commonColumnSettings,
                                ignoreColumnOptionNames = that.option("stateStoring.ignoreColumnOptionNames");
                            if (!ignoreColumnOptionNames) {
                                ignoreColumnOptionNames = [];
                                commonColumnSettings = that.getCommonSettings();
                                if (!that.option("columnChooser.enabled"))
                                    ignoreColumnOptionNames.push("visible");
                                if (that.option("sorting.mode") === "none")
                                    ignoreColumnOptionNames.push("sortIndex", "sortOrder");
                                if (!commonColumnSettings.allowGrouping)
                                    ignoreColumnOptionNames.push("groupIndex");
                                if (!commonColumnSettings.allowFixing)
                                    ignoreColumnOptionNames.push("fixed", "fixedPosition");
                                if (!commonColumnSettings.allowResizing)
                                    ignoreColumnOptionNames.push("width", "visibleWidth");
                                if (!that.option("filterRow.visible"))
                                    ignoreColumnOptionNames.push("filterValue", "selectedFilterOperation");
                                if (!that.option("headerFilter.visible"))
                                    ignoreColumnOptionNames.push("filterValues", "filterType")
                            }
                            that._columnsUserState = state;
                            that._ignoreColumnOptionNames = ignoreColumnOptionNames;
                            that._hasUserState = !!state;
                            that.init()
                        },
                        _createCalculatedColumnOptions: function(columnOptions) {
                            var calculatedColumnOptions = {},
                                dataField = columnOptions.dataField,
                                getter;
                            if (dataField) {
                                if (commonUtils.isString(dataField)) {
                                    getter = dataUtils.compileGetter(dataField);
                                    calculatedColumnOptions = {
                                        caption: inflector.captionize(dataField),
                                        calculateCellValue: function(data, skipDeserialization) {
                                            var value = getter(data);
                                            return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value
                                        },
                                        setCellValue: defaultSetCellValue,
                                        parseValue: function(text) {
                                            var column = this,
                                                result,
                                                parsedValue;
                                            if (column.dataType === "number") {
                                                if (commonUtils.isString(text)) {
                                                    parsedValue = Globalize.parseFloat(text);
                                                    if (commonUtils.isNumber(parsedValue))
                                                        result = parsedValue
                                                }
                                                else if (commonUtils.isDefined(text))
                                                    result = Number(text)
                                            }
                                            else if (column.dataType === "boolean") {
                                                if (text === column.trueText)
                                                    result = true;
                                                else if (text === column.falseText)
                                                    result = false
                                            }
                                            else if (column.dataType === "date") {
                                                parsedValue = Globalize.parseDate(text);
                                                if (parsedValue)
                                                    result = parsedValue
                                            }
                                            else
                                                result = text;
                                            return result
                                        }
                                    }
                                }
                                calculatedColumnOptions.allowFiltering = true
                            }
                            else
                                calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression;
                            calculatedColumnOptions.calculateFilterExpression = function() {
                                return dataGrid.defaultCalculateFilterExpression.apply(this, arguments)
                            };
                            calculatedColumnOptions.createFilterExpression = function() {
                                var result;
                                if (this.calculateFilterExpression)
                                    result = this.calculateFilterExpression.apply(this, arguments);
                                if (result)
                                    result.columnIndex = this.index;
                                return result
                            };
                            if (!dataField || !commonUtils.isString(dataField))
                                $.extend(true, calculatedColumnOptions, {
                                    allowSorting: false,
                                    allowGrouping: false,
                                    calculateCellValue: function() {
                                        return null
                                    }
                                });
                            if (columnOptions.dataType)
                                calculatedColumnOptions.userDataType = columnOptions.dataType;
                            if (columnOptions.lookup)
                                calculatedColumnOptions.lookup = {
                                    calculateCellValue: function(value, skipDeserialization) {
                                        if (this.valueExpr)
                                            value = this.valueMap && this.valueMap[value];
                                        return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value
                                    },
                                    updateValueMap: function() {
                                        var calculateValue,
                                            calculateDisplayValue,
                                            item,
                                            i;
                                        this.valueMap = {};
                                        if (this.items) {
                                            calculateValue = dataUtils.compileGetter(this.valueExpr);
                                            calculateDisplayValue = dataUtils.compileGetter(this.displayExpr);
                                            for (i = 0; i < this.items.length; i++) {
                                                item = this.items[i];
                                                this.valueMap[calculateValue(item)] = calculateDisplayValue(item)
                                            }
                                        }
                                    },
                                    update: function() {
                                        var that = this,
                                            dataSource = that.dataSource,
                                            dataSourceOptions;
                                        if (dataSource) {
                                            if (commonUtils.isFunction(dataSource) && !knockoutUtils.isObservable(dataSource))
                                                dataSource = dataSource({});
                                            if (commonUtils.isObject(dataSource) || commonUtils.isArray(dataSource)) {
                                                if (that.valueExpr) {
                                                    dataSourceOptions = dataUtils.normalizeDataSourceOptions(dataSource);
                                                    dataSourceOptions.paginate = false;
                                                    dataSource = new DX.data.DataSource(dataSourceOptions);
                                                    return dataSource.load().done(function(data) {
                                                            that.items = data;
                                                            that.updateValueMap && that.updateValueMap()
                                                        })
                                                }
                                            }
                                            else
                                                errors.log("E1016")
                                        }
                                        else
                                            that.updateValueMap && that.updateValueMap()
                                    }
                                };
                            calculatedColumnOptions.resizedCallbacks = $.Callbacks();
                            if (columnOptions.resized)
                                calculatedColumnOptions.resizedCallbacks.add($.proxy(columnOptions.resized, columnOptions));
                            $.each(calculatedColumnOptions, function(optionName) {
                                var defaultOptionName;
                                if (commonUtils.isFunction(calculatedColumnOptions[optionName]) && optionName.indexOf("default") !== 0) {
                                    defaultOptionName = "default" + optionName.charAt(0).toUpperCase() + optionName.substr(1);
                                    calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName]
                                }
                            });
                            return calculatedColumnOptions
                        }
                    }
            }());
        ui.dxDataGrid.ColumnsController = ColumnsController;
        dataGrid.registerModule("columns", {
            defaultOptions: function() {
                return {
                        commonColumnSettings: {
                            allowFiltering: true,
                            allowHiding: true,
                            allowSorting: true,
                            allowEditing: true,
                            encodeHtml: true,
                            trueText: Globalize.localize("dxDataGrid-trueText"),
                            falseText: Globalize.localize("dxDataGrid-falseText")
                        },
                        allowColumnReordering: false,
                        allowColumnResizing: false,
                        columns: undefined,
                        regenerateColumnsByVisibleItems: false,
                        customizeColumns: null
                    }
            },
            controllers: {columns: ColumnsController}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.selection.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_ROW_SELECTION_CLASS = "dx-selection",
            DATAGRID_SELECT_CHECKBOX_CLASS = "dx-select-checkbox",
            DATAGRID_CHECKBOXES_HIDDEN_CLASS = "dx-select-checkboxes-hidden",
            DATAGRID_COMMAND_SELECT_CLASS = "dx-command-select",
            DATAGRID_SELECTION_DISABLED_CLASS = "dx-selection-disabled",
            DATAGRID_DATA_ROW_CLASS = "dx-data-row";
        $.extend(dataGrid.__internals, {
            DATAGRID_ROW_SELECTION_CLASS: DATAGRID_ROW_SELECTION_CLASS,
            DATAGRID_SELECTION_DISABLED_CLASS: DATAGRID_SELECTION_DISABLED_CLASS,
            DATAGRID_COMMAND_SELECT_CLASS: DATAGRID_COMMAND_SELECT_CLASS
        });
        var SHOW_CHECKBOXES_MODE = "selection.showCheckBoxesMode";
        var SELECTION_MODE = "selection.mode";
        var isSelectable = function(selectionMode) {
                return selectionMode === "single" || selectionMode === "multiple"
            };
        dataGrid.SelectionController = dataGrid.Controller.inherit(function() {
            var indexOfSelectedItemKey = function(that, key, isSelectAll) {
                    var index,
                        selectedItemKeys = isSelectAll ? that._unselectedItemKeys : that._selectedItemKeys;
                    if (commonUtils.isObject(key)) {
                        for (index = 0; index < selectedItemKeys.length; index++)
                            if (equalKeys(selectedItemKeys[index], key))
                                return index;
                        return -1
                    }
                    else
                        return $.inArray(key, selectedItemKeys)
                };
            var addSelectedItem = function(that, itemData) {
                    var key = that.getController("data").keyOf(itemData);
                    if (indexOfSelectedItemKey(that, key) === -1) {
                        that._selectedItemKeys.push(key);
                        that._addedItemKeys.push(key);
                        that._selectedItems.push(itemData)
                    }
                };
            var removeSelectedItem = function(that, key) {
                    var keyIndex = indexOfSelectedItemKey(that, key);
                    if (keyIndex >= 0) {
                        that._selectedItemKeys.splice(keyIndex, 1);
                        that._removedItemKeys.push(key);
                        that._selectedItems.splice(keyIndex, 1)
                    }
                };
            var clearSelectedItems = function(that) {
                    setSelectedItems(that, [], [])
                };
            var setSelectedItems = function(that, keys, items) {
                    var i,
                        oldSelectedItemKeys = that._selectedItemKeys;
                    that._selectedItemKeys = keys;
                    that._selectedItems = items;
                    that._unselectedItemKeys = [];
                    for (i = 0; i < oldSelectedItemKeys.length; i++)
                        if ($.inArray(oldSelectedItemKeys[i], keys) === -1)
                            that._removedItemKeys.push(oldSelectedItemKeys[i]);
                    for (i = 0; i < keys.length; i++)
                        if ($.inArray(keys[i], oldSelectedItemKeys) === -1)
                            that._addedItemKeys.push(keys[i])
                };
            var equalKeys = dataGrid.equalKeys;
            var resetItemSelectionWhenShiftKeyPressed = function(that) {
                    delete that._shiftFocusedItemIndex
                };
            var isDataItem = function(row) {
                    return row && row.rowType === "data" && !row.inserted
                };
            var changeItemSelectionWhenShiftKeyPressed = function(that, itemIndex, items) {
                    var isSelectedItemsChanged = false,
                        itemIndexStep,
                        index,
                        dataController = that.getController("data"),
                        isFocusedItemSelected = items[that._focusedItemIndex] && that.isRowSelected(dataController.keyOf(items[that._focusedItemIndex].data));
                    var addRemoveSelectedItem = function(that, data, isRemove) {
                            if (isRemove)
                                removeSelectedItem(that, dataController.keyOf(data));
                            else
                                addSelectedItem(that, data)
                        };
                    if (!commonUtils.isDefined(that._shiftFocusedItemIndex))
                        that._shiftFocusedItemIndex = that._focusedItemIndex;
                    if (that._shiftFocusedItemIndex !== that._focusedItemIndex) {
                        itemIndexStep = that._focusedItemIndex < that._shiftFocusedItemIndex ? 1 : -1;
                        for (index = that._focusedItemIndex; index !== that._shiftFocusedItemIndex; index += itemIndexStep)
                            if (isDataItem(items[index])) {
                                addRemoveSelectedItem(that, items[index].data, true);
                                isSelectedItemsChanged = true
                            }
                    }
                    if (itemIndex !== that._shiftFocusedItemIndex) {
                        itemIndexStep = itemIndex < that._shiftFocusedItemIndex ? 1 : -1;
                        for (index = itemIndex; index !== that._shiftFocusedItemIndex; index += itemIndexStep)
                            if (isDataItem(items[index])) {
                                addRemoveSelectedItem(that, items[index].data, false);
                                isSelectedItemsChanged = true
                            }
                    }
                    if (isDataItem(items[that._focusedItemIndex]) && !isFocusedItemSelected) {
                        addRemoveSelectedItem(that, items[that._focusedItemIndex].data, false);
                        isSelectedItemsChanged = true
                    }
                    return isSelectedItemsChanged
                };
            var createSelectedItemsFilterCriteria = function(dataSource, selectedItemKeys, isSelectAll) {
                    var keyCriteria,
                        i,
                        key = dataSource && dataSource.key(),
                        criteria = [];
                    if (dataSource)
                        if (key)
                            $.each(selectedItemKeys, function(index, keyValue) {
                                if (criteria.length > 0)
                                    criteria.push(isSelectAll ? "and" : "or");
                                if ($.isArray(key)) {
                                    keyCriteria = [];
                                    for (i = 0; i < key.length; i++) {
                                        if (i > 0)
                                            keyCriteria.push(isSelectAll ? "or" : "and");
                                        keyCriteria.push([key[i], isSelectAll ? "<>" : "=", keyValue[key[i]]])
                                    }
                                    criteria.push(keyCriteria)
                                }
                                else
                                    criteria.push([key, isSelectAll ? "<>" : "=", keyValue])
                            });
                        else
                            criteria = function(item) {
                                var i;
                                for (i = 0; i < selectedItemKeys.length; i++)
                                    if (equalKeys(selectedItemKeys[i], item))
                                        return !isSelectAll;
                                return isSelectAll
                            };
                    if (criteria.length > 0 || $.isFunction(criteria))
                        return criteria
                };
            var updateSelectedItems = function(that) {
                    var changedItemIndexes = [],
                        dataController = that.getController("data"),
                        isSelectionWithCheckboxes = that.isSelectionWithCheckboxes(),
                        addedItemKeys,
                        removedItemKeys;
                    if (dataController) {
                        $.each(dataController.items(), function(index, row) {
                            if (isDataItem(row) && row.isSelected !== that.isRowSelected(row.key))
                                changedItemIndexes.push(index)
                        });
                        if (that.option(SHOW_CHECKBOXES_MODE) === "onClick")
                            if (that._selectedItemKeys.length > 1)
                                that.startSelectionWithCheckboxes();
                            else if (that._selectedItemKeys.length === 0 && that._removedItemKeys.length)
                                that.stopSelectionWithCheckboxes();
                        if (changedItemIndexes.length || isSelectionWithCheckboxes !== that.isSelectionWithCheckboxes())
                            dataController.updateItems({
                                changeType: "updateSelection",
                                itemIndexes: changedItemIndexes
                            });
                        addedItemKeys = that._addedItemKeys;
                        removedItemKeys = that._removedItemKeys;
                        if (addedItemKeys.length || removedItemKeys.length) {
                            that._selectedItemsInternalChange = true;
                            that.option("selectedRowKeys", that._selectedItemKeys.slice(0));
                            that._selectedItemsInternalChange = false;
                            that.selectionChanged.fire(that._selectedItemKeys);
                            that._addedItemKeys = [];
                            that._removedItemKeys = [];
                            that.executeAction("onSelectionChanged", {
                                selectedRowsData: that._selectedItems,
                                selectedRowKeys: that._selectedItemKeys,
                                currentSelectedRowKeys: addedItemKeys,
                                currentDeselectedRowKeys: removedItemKeys
                            })
                        }
                    }
                };
            var updateSelectColumn = function(that) {
                    var columnsController = that.getController("columns"),
                        isSelectColumnVisible = that.isSelectColumnVisible();
                    columnsController.addCommandColumn({
                        command: "select",
                        visible: isSelectColumnVisible,
                        visibleIndex: -1,
                        dataType: "boolean",
                        alignment: "center",
                        cssClass: DATAGRID_COMMAND_SELECT_CLASS,
                        width: "auto"
                    });
                    columnsController.columnOption("command:select", "visible", isSelectColumnVisible)
                };
            return {
                    init: function() {
                        var that = this;
                        that._isSelectionWithCheckboxes = false;
                        that._focusedItemIndex = -1;
                        that._selectedItemKeys = [];
                        that._unselectedItemKeys = [];
                        that._selectedItems = [];
                        that._addedItemKeys = [];
                        that._removedItemKeys = [];
                        updateSelectColumn(that);
                        that.createAction("onSelectionChanged", {excludeValidators: ["disabled", "readOnly"]})
                    },
                    callbackNames: function() {
                        return ["selectionChanged"]
                    },
                    optionChanged: function(args) {
                        var that = this;
                        that.callBase(args);
                        switch (args.name) {
                            case"selection":
                                that.init();
                                that.getController("columns").updateColumns();
                                args.handled = true;
                                break;
                            case"selectedRowKeys":
                                if (commonUtils.isArray(args.value) && !that._selectedItemsInternalChange)
                                    that.selectRows(args.value);
                                args.handled = true;
                                break
                        }
                    },
                    publicMethods: function() {
                        return ["selectRows", "deselectRows", "selectRowsByIndexes", "getSelectedRowKeys", "getSelectedRowsData", "clearSelection", "selectAll", "deselectAll", "startSelectionWithCheckboxes", "stopSelectionWithCheckboxes", "isRowSelected"]
                    },
                    isRowSelected: function(key) {
                        var index = indexOfSelectedItemKey(this, key);
                        return index !== -1
                    },
                    isSelectColumnVisible: function() {
                        var showCheckBoxesMode = this.option(SHOW_CHECKBOXES_MODE);
                        return this.option(SELECTION_MODE) === "multiple" && (showCheckBoxesMode === "always" || showCheckBoxesMode === "onClick" || this._isSelectionWithCheckboxes)
                    },
                    isSelectAll: function() {
                        var dataController = this.getController("data"),
                            items = dataController.items(),
                            combinedFilter = dataController.getCombinedFilter(),
                            selectedItems = this.getSelectedRowsData(),
                            i;
                        if (combinedFilter)
                            DX.data.query(selectedItems).filter(combinedFilter).enumerate().done(function(items) {
                                selectedItems = items
                            });
                        if (!selectedItems.length) {
                            for (i = 0; i < items.length; i++)
                                if (items[i].selected)
                                    return;
                            return false
                        }
                        else if (selectedItems.length >= dataController.totalCount())
                            return true
                    },
                    selectAll: function() {
                        if (this.option(SHOW_CHECKBOXES_MODE) === "onClick")
                            this.startSelectionWithCheckboxes();
                        return this.selectedItemKeys([], true, false, true)
                    },
                    deselectAll: function() {
                        return this.selectedItemKeys([], true, true, true)
                    },
                    clearSelection: function() {
                        this.selectedItemKeys([])
                    },
                    refresh: function() {
                        return this.selectedItemKeys(this.option("selectedRowKeys") || [])
                    },
                    selectedItemKeys: function(value, preserve, isDeselect, isSelectAll) {
                        var that = this,
                            keys,
                            criteria,
                            isFunctionCriteria,
                            deferred,
                            dataController = that.getController("data"),
                            dataSource = dataController.dataSource(),
                            store = dataSource && dataSource.store(),
                            dataSourceFilter,
                            filter,
                            deselectItems = [],
                            loadOptions;
                        if (commonUtils.isDefined(value)) {
                            if (store) {
                                keys = $.isArray(value) ? $.extend([], value) : [value];
                                if (keys.length || isSelectAll) {
                                    criteria = createSelectedItemsFilterCriteria(dataSource, keys, isSelectAll);
                                    isFunctionCriteria = $.isFunction(criteria);
                                    if (criteria || isSelectAll) {
                                        if (isSelectAll)
                                            dataSourceFilter = dataController.getCombinedFilter();
                                        if (criteria && !isFunctionCriteria && dataSourceFilter) {
                                            filter = [];
                                            filter.push(criteria);
                                            filter.push(dataSourceFilter)
                                        }
                                        else if (dataSourceFilter)
                                            filter = dataSourceFilter;
                                        else if (criteria && !isFunctionCriteria)
                                            filter = criteria;
                                        deferred = $.Deferred();
                                        if (isDeselect)
                                            new DX.data.ArrayStore(that._selectedItems).load({filter: filter}).done(function(items) {
                                                deselectItems = items
                                            });
                                        loadOptions = {
                                            filter: filter,
                                            select: dataSource.select()
                                        };
                                        $.each(store._customLoadOptions() || [], function(_, optionName) {
                                            loadOptions[optionName] = dataSource.loadOptions()[optionName]
                                        });
                                        new DX.data.ArrayStore(deselectItems.length ? deselectItems : dataSource.items()).load({filter: criteria}).done(function(items) {
                                            if (!isSelectAll && (deselectItems.length || items.length === keys.length))
                                                deferred.resolve(items);
                                            else {
                                                dataController.setSelectionLoading(true);
                                                store.load(loadOptions).done(function(items) {
                                                    new DX.data.ArrayStore(items).load({filter: criteria}).done(deferred.resolve)
                                                }).fail($.proxy(deferred.reject, deferred)).always(function() {
                                                    dataController.setSelectionLoading(false)
                                                })
                                            }
                                        })
                                    }
                                }
                            }
                            deferred = deferred || $.Deferred().resolve([]);
                            deferred.done(function(items) {
                                var i,
                                    key,
                                    item,
                                    keys = [];
                                if (store && items.length > 0)
                                    for (i = 0; i < items.length; i++) {
                                        item = items[i];
                                        key = store.keyOf(item);
                                        if (preserve)
                                            if (isDeselect)
                                                removeSelectedItem(that, key);
                                            else
                                                addSelectedItem(that, item);
                                        else
                                            keys.push(key)
                                    }
                                if (!preserve)
                                    setSelectedItems(that, keys, items);
                                updateSelectedItems(that)
                            });
                            return deferred
                        }
                        else
                            return that._selectedItemKeys
                    },
                    getSelectedRowKeys: function() {
                        return this.selectedItemKeys()
                    },
                    selectRows: function(keys, preserve) {
                        return this.selectedItemKeys(keys, preserve)
                    },
                    deselectRows: function(keys) {
                        return this.selectedItemKeys(keys, true, true)
                    },
                    selectRowsByIndexes: function(indexes) {
                        var items = this.getController("data").items(),
                            keys = [];
                        if (!commonUtils.isArray(indexes))
                            indexes = Array.prototype.slice.call(arguments, 0);
                        $.each(indexes, function() {
                            var item = items[this];
                            if (item && item.rowType === "data")
                                keys.push(item.key)
                        });
                        return this.selectRows(keys)
                    },
                    getSelectedRowsData: function() {
                        return this._selectedItems
                    },
                    changeItemSelection: function(itemIndex, keys) {
                        var that = this,
                            dataController = that.getController("data"),
                            items = dataController.items(),
                            item = items[itemIndex],
                            itemData = item && item.data,
                            selectionMode = that.option(SELECTION_MODE),
                            isSelectedItemsChanged,
                            isSelected,
                            itemKey;
                        if (isSelectable(selectionMode) && isDataItem(item)) {
                            itemKey = dataController.keyOf(itemData);
                            keys = keys || {};
                            if (that.isSelectionWithCheckboxes())
                                keys.control = true;
                            if (keys.shift && selectionMode === "multiple" && that._focusedItemIndex >= 0)
                                isSelectedItemsChanged = changeItemSelectionWhenShiftKeyPressed(that, itemIndex, items);
                            else if (keys.control) {
                                resetItemSelectionWhenShiftKeyPressed(that);
                                isSelected = that.isRowSelected(itemKey);
                                if (selectionMode === "single")
                                    clearSelectedItems(that);
                                if (isSelected)
                                    removeSelectedItem(that, itemKey);
                                else
                                    addSelectedItem(that, itemData);
                                isSelectedItemsChanged = true
                            }
                            else {
                                resetItemSelectionWhenShiftKeyPressed(that);
                                if (that._selectedItemKeys.length !== 1 || !equalKeys(that._selectedItemKeys[0], itemKey)) {
                                    setSelectedItems(that, [itemKey], [itemData]);
                                    isSelectedItemsChanged = true
                                }
                            }
                            if (isSelectedItemsChanged) {
                                that._focusedItemIndex = itemIndex;
                                updateSelectedItems(that);
                                return true
                            }
                        }
                        return false
                    },
                    focusedItemIndex: function(itemIndex) {
                        var that = this;
                        if (commonUtils.isDefined(itemIndex))
                            that._focusedItemIndex = itemIndex;
                        else
                            return that._focusedItemIndex
                    },
                    isSelectionWithCheckboxes: function() {
                        var selectionMode = this.option(SELECTION_MODE),
                            showCheckBoxesMode = this.option(SHOW_CHECKBOXES_MODE);
                        return selectionMode === "multiple" && (showCheckBoxesMode === "always" || this._isSelectionWithCheckboxes)
                    },
                    startSelectionWithCheckboxes: function() {
                        var that = this,
                            isSelectColumnVisible = that.isSelectColumnVisible();
                        if (that.option(SELECTION_MODE) === "multiple" && !that.isSelectionWithCheckboxes()) {
                            that._isSelectionWithCheckboxes = true;
                            updateSelectColumn(that);
                            if (isSelectColumnVisible === that.isSelectColumnVisible() && that.option(SHOW_CHECKBOXES_MODE) === "onClick")
                                updateSelectedItems(that);
                            return true
                        }
                        return false
                    },
                    stopSelectionWithCheckboxes: function() {
                        var that = this;
                        if (that._isSelectionWithCheckboxes) {
                            that._isSelectionWithCheckboxes = false;
                            updateSelectColumn(that);
                            return true
                        }
                        return false
                    }
                }
        }());
        $.extend(dataGrid.__internals, {DATAGRID_CHECKBOXES_HIDDEN_CLASS: DATAGRID_CHECKBOXES_HIDDEN_CLASS});
        dataGrid.registerModule("selection", {
            defaultOptions: function() {
                return {
                        selection: {
                            mode: "none",
                            showCheckBoxesMode: "onClick",
                            allowSelectAll: true
                        },
                        selectedRowKeys: []
                    }
            },
            controllers: {selection: dataGrid.SelectionController},
            extenders: {
                controllers: {data: {
                        setDataSource: function(dataSource) {
                            this.callBase(dataSource);
                            if (dataSource)
                                this.getController("selection").refresh()
                        },
                        setSelectionLoading: function(isLoading) {
                            this._isSelectionLoading = isLoading;
                            this._fireLoadingChanged()
                        },
                        isLoading: function() {
                            var isLoading = this.callBase();
                            return isLoading || !!this._isSelectionLoading
                        },
                        pageIndex: function(value) {
                            var that = this,
                                dataSource = that._dataSource;
                            if (dataSource && value && dataSource.pageIndex() !== value)
                                that.getController("selection").focusedItemIndex(-1);
                            return that.callBase(value)
                        },
                        _processDataItem: function() {
                            var that = this,
                                selectionController = that.getController("selection"),
                                hasSelectColumn = selectionController.isSelectColumnVisible(),
                                dataItem = this.callBase.apply(this, arguments);
                            dataItem.isSelected = selectionController.isRowSelected(dataItem.key);
                            if (hasSelectColumn && dataItem.values)
                                dataItem.values[0] = dataItem.isSelected;
                            return dataItem
                        },
                        refresh: function() {
                            var that = this,
                                d = $.Deferred();
                            this.callBase.apply(this, arguments).done(function() {
                                that.getController("selection").refresh().done(d.resolve).fail(d.reject)
                            }).fail(d.reject);
                            return d.promise()
                        }
                    }},
                views: {
                    columnHeadersView: {
                        _renderCore: function(options) {
                            var that = this;
                            that.getController("selection").selectionChanged.remove(that._selectionChangedHandler);
                            that.callBase(options)
                        },
                        _getDefaultTemplate: function(column) {
                            var that = this,
                                groupElement,
                                selectionController = that.getController("selection"),
                                dataController = that.getController("data");
                            if (column.command === "select")
                                return function($cell, options) {
                                        var column = options.column;
                                        if (column.command === "select") {
                                            $cell.addClass(DATAGRID_EDITOR_CELL_CLASS);
                                            groupElement = $("<div />").appendTo($cell).addClass(DATAGRID_SELECT_CHECKBOX_CLASS);
                                            that.setAria("label", Globalize.localize("dxDataGrid-ariaSelectAll"), $cell);
                                            that.getController("editorFactory").createEditor(groupElement, $.extend({}, column, {
                                                parentType: "headerRow",
                                                value: selectionController.isSelectAll(),
                                                tabIndex: -1,
                                                setValue: function(value, e) {
                                                    if (e.jQueryEvent && selectionController.isSelectAll() !== value) {
                                                        if (e.previousValue === undefined || e.previousValue) {
                                                            selectionController.deselectAll();
                                                            e.component.option("value", false)
                                                        }
                                                        if (e.previousValue === false)
                                                            if (that.option("selection.allowSelectAll"))
                                                                selectionController.selectAll();
                                                            else
                                                                e.component.option("value", false);
                                                        e.jQueryEvent.preventDefault()
                                                    }
                                                }
                                            }));
                                            $cell.on("dxclick", that.createAction(function(e) {
                                                var event = e.jQueryEvent;
                                                if (!$(event.target).closest("." + DATAGRID_SELECT_CHECKBOX_CLASS).length)
                                                    $(event.currentTarget).children().trigger("dxclick");
                                                event.preventDefault()
                                            }));
                                            that._selectionChangedHandler = function() {
                                                if (that.option("selection.mode") === "multiple")
                                                    groupElement.dxCheckBox("instance").option("value", selectionController.isSelectAll())
                                            };
                                            that._dataChangedHandler = function(e) {
                                                if (!e || e.changeType === "refresh")
                                                    that._selectionChangedHandler()
                                            };
                                            dataController.changed.add(that._dataChangedHandler);
                                            selectionController.selectionChanged.add(that._selectionChangedHandler)
                                        }
                                    };
                            else
                                return that.callBase(column)
                        }
                    },
                    rowsView: {
                        _getDefaultTemplate: function(column) {
                            var that = this,
                                groupElement;
                            if (column.command === "select")
                                return function(container, options) {
                                        if (options.rowType === "data" && !options.row.inserted) {
                                            container.addClass(DATAGRID_EDITOR_CELL_CLASS);
                                            container.on("dxclick", that.createAction(function(e) {
                                                var selectionController = that.getController("selection"),
                                                    event = e.jQueryEvent,
                                                    rowIndex = that.getRowIndex($(event.currentTarget).closest("." + DATAGRID_ROW_CLASS));
                                                if (rowIndex >= 0) {
                                                    selectionController.startSelectionWithCheckboxes();
                                                    selectionController.changeItemSelection(rowIndex, {shift: event.shiftKey})
                                                }
                                            }));
                                            that.setAria("label", Globalize.localize("dxDataGrid-ariaSelectRow"), container);
                                            groupElement = $("<div />").addClass(DATAGRID_SELECT_CHECKBOX_CLASS).appendTo(container);
                                            that.getController("editorFactory").createEditor(groupElement, $.extend({}, column, {
                                                parentType: "dataRow",
                                                value: options.value,
                                                tabIndex: -1,
                                                setValue: function(value, e) {
                                                    if (e && e.jQueryEvent && e.jQueryEvent.type === "keydown")
                                                        container.trigger("dxclick", e)
                                                }
                                            }))
                                        }
                                    };
                            else
                                return that.callBase(column)
                        },
                        _update: function(change) {
                            var that = this,
                                tableElements = that.getTableElements();
                            if (change.changeType === "updateSelection") {
                                if (tableElements.length > 0) {
                                    $.each(tableElements, function(_, tableElement) {
                                        $.each(change.itemIndexes || [], function(_, index) {
                                            var $row,
                                                isSelected;
                                            if (change.items[index]) {
                                                $row = that._getRowElements($(tableElement)).eq(index);
                                                isSelected = !!change.items[index].isSelected;
                                                $row.toggleClass(DATAGRID_ROW_SELECTION_CLASS, isSelected).find("." + DATAGRID_SELECT_CHECKBOX_CLASS).dxCheckBox("option", "value", isSelected);
                                                that.setAria("selected", isSelected, $row)
                                            }
                                        })
                                    });
                                    that._updateCheckboxesClass()
                                }
                            }
                            else
                                that.callBase(change)
                        },
                        _createTable: function() {
                            var that = this,
                                selectionMode = that.option("selection.mode"),
                                $table = that.callBase.apply(that, arguments);
                            if (selectionMode !== "none")
                                $table.on(eventUtils.addNamespace("dxhold", "dxDataGridRowsView"), "." + DATAGRID_DATA_ROW_CLASS, that.createAction(function(e) {
                                    var selectionController = that.getController("selection"),
                                        event = e.jQueryEvent,
                                        rowIndex = $(event.target).closest("." + DATAGRID_DATA_ROW_CLASS).index();
                                    if (that.option(SHOW_CHECKBOXES_MODE) === "onLongTap")
                                        if (selectionController.isSelectionWithCheckboxes())
                                            selectionController.stopSelectionWithCheckboxes();
                                        else
                                            selectionController.startSelectionWithCheckboxes();
                                    else {
                                        if (that.option(SHOW_CHECKBOXES_MODE) === "onClick")
                                            selectionController.startSelectionWithCheckboxes();
                                        selectionController.changeItemSelection(rowIndex, {control: true})
                                    }
                                })).on("mousedown selectstart", that.createAction(function(e) {
                                    var event = e.jQueryEvent;
                                    if (event.shiftKey)
                                        event.preventDefault()
                                }));
                            return $table
                        },
                        _createRow: function(row) {
                            var $row = this.callBase(row),
                                isSelected;
                            if (row) {
                                isSelected = !!row.isSelected;
                                $row.toggleClass(DATAGRID_ROW_SELECTION_CLASS, isSelected);
                                this.setAria("selected", isSelected, $row)
                            }
                            return $row
                        },
                        _rowClick: function(e) {
                            var that = this,
                                jQueryEvent = e.jQueryEvent,
                                isCommandSelect = $(jQueryEvent.target).closest("." + DATAGRID_COMMAND_SELECT_CLASS).length,
                                isSelectionDisabled = $(jQueryEvent.target).closest("." + DATAGRID_SELECTION_DISABLED_CLASS).length;
                            if (!isCommandSelect) {
                                if (!isSelectionDisabled && that.option(SHOW_CHECKBOXES_MODE) !== "always")
                                    if (that.getController("selection").changeItemSelection(e.rowIndex, {
                                        control: jQueryEvent.ctrlKey,
                                        shift: jQueryEvent.shiftKey
                                    })) {
                                        jQueryEvent.preventDefault();
                                        e.handled = true
                                    }
                                that.callBase(e)
                            }
                        },
                        _renderCore: function(change) {
                            this.callBase(change);
                            this._updateCheckboxesClass()
                        },
                        _updateCheckboxesClass: function() {
                            var tableElements = this.getTableElements(),
                                selectionController = this.getController("selection"),
                                isCheckBoxesHidden = selectionController.isSelectColumnVisible() && !selectionController.isSelectionWithCheckboxes();
                            $.each(tableElements, function(_, tableElement) {
                                $(tableElement).toggleClass(DATAGRID_CHECKBOXES_HIDDEN_CLASS, isCheckBoxesHidden)
                            })
                        }
                    }
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.editorFactory.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            browser = DX.require("/utils/utils.browser"),
            positionUtils = DX.require("/utils/utils.position"),
            defaultDateTimeFormat = DX.require("/utils/utils.formatHelper").defaultDateTimeFormat,
            commonUtils = DX.require("/utils/utils.common"),
            knockoutUtils = DX.require("/utils/utils.knockout"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer"),
            addNamespace = eventUtils.addNamespace;
        var DATAGRID_CHECKBOX_SIZE_CLASS = "dx-datagrid-checkbox-size",
            DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
            DATAGRID_EDITOR_INLINE_BLOCK = "dx-editor-inline-block",
            DATAGRID_MODULE_NAMESPACE = "dxDataGridEditorFactory",
            DATAGRID_UPDATE_FOCUS_EVENTS = addNamespace(pointerEvents.down + " focusin dxclick", DATAGRID_MODULE_NAMESPACE),
            DATAGRID_FOCUS_OVERLAY_CLASS = "dx-datagrid-focus-overlay",
            DATAGRID_FOCUSED_ELEMENT_CLASS = "dx-focused",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target",
            DATAGRID_POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
            DX_HIDDEN = "dx-hidden",
            TAB_KEY = 9;
        dataGrid.EditorFactoryController = dataGrid.ViewController.inherit(function() {
            var getResultConfig = function(config, options) {
                    return $.extend(config, {
                            readOnly: options.readOnly,
                            rtlEnabled: options.rtlEnabled,
                            disabled: options.disabled,
                            placeholder: options.placeholder
                        }, options.editorOptions)
                };
            var getTextEditorConfig = function(options) {
                    var isIE = browser.msie && parseInt(browser.version) <= 11,
                        isValueChanged = false;
                    return getResultConfig({
                            placeholder: options.placeholder,
                            width: options.width,
                            value: options.value,
                            onValueChanged: function(e) {
                                var updateValue = function(e) {
                                        isValueChanged = false;
                                        options && options.setValue(e.value)
                                    };
                                window.clearTimeout(e.component._valueChangeTimeoutID);
                                if (e.jQueryEvent && e.jQueryEvent.type === "keyup")
                                    if (options.parentType === "filterRow" || options.parentType === "searchPanel")
                                        e.component._valueChangeTimeoutID = window.setTimeout(function() {
                                            updateValue(e)
                                        }, commonUtils.isDefined(options.updateValueTimeout) ? options.updateValueTimeout : 0);
                                    else
                                        isValueChanged = true;
                                else
                                    updateValue(e)
                            },
                            onFocusOut: function(e) {
                                if (isIE && isValueChanged) {
                                    isValueChanged = false;
                                    options.setValue(e.component.option("value"))
                                }
                            },
                            onEnterKey: function(e) {
                                if (isIE && isValueChanged) {
                                    isValueChanged = false;
                                    options.setValue(e.component.option("value"))
                                }
                            },
                            valueChangeEvent: "change" + (options.parentType === "filterRow" || isIE ? " keyup" : "")
                        }, options)
                };
            var prepareDateBox = function(options) {
                    options.editorName = "dxDateBox";
                    options.editorOptions = getResultConfig({
                        value: options.value,
                        customOverlayCssClass: "dx-datagrid",
                        onValueChanged: function(args) {
                            options.setValue(args.value)
                        },
                        formatString: commonUtils.isString(options.format) && defaultDateTimeFormat[options.format.toLowerCase()] || options.format,
                        formatWidthCalculator: null,
                        width: "auto"
                    }, options)
                };
            var prepareTextBox = function(options) {
                    var config = getTextEditorConfig(options),
                        isSearching = options.parentType === "searchPanel",
                        toString = function(value) {
                            return commonUtils.isDefined(value) ? value.toString() : ""
                        };
                    config.value = toString(options.value);
                    config.valueChangeEvent += isSearching ? " keyup search" : "";
                    config.mode = isSearching ? "search" : "text";
                    options.editorName = "dxTextBox";
                    options.editorOptions = config
                };
            var prepareNumberBox = function(options) {
                    var config = getTextEditorConfig(options);
                    config.value = commonUtils.isDefined(options.value) ? options.value : null;
                    options.editorName = "dxNumberBox";
                    options.editorOptions = config
                };
            var prepareBooleanEditor = function(options) {
                    if (options.parentType === "filterRow")
                        prepareSelectBox($.extend(options, {lookup: {
                                displayExpr: function(data) {
                                    if (data === true)
                                        return options.trueText || "true";
                                    else if (data === false)
                                        return options.falseText || "false"
                                },
                                dataSource: [true, false],
                                rtlEnabled: options.rtlEnabled,
                                disabled: options.disabled
                            }}));
                    else
                        prepareCheckBox(options)
                };
            var prepareSelectBox = function(options) {
                    var lookup = options.lookup,
                        displayGetter,
                        dataSource,
                        postProcess,
                        isFilterRow = options.parentType === "filterRow";
                    if (lookup) {
                        displayGetter = DX.data.utils.compileGetter(lookup.displayExpr);
                        dataSource = lookup.dataSource;
                        if (commonUtils.isFunction(dataSource) && !knockoutUtils.isObservable(dataSource))
                            dataSource = dataSource(options.row || {});
                        if (commonUtils.isObject(dataSource) || commonUtils.isArray(dataSource)) {
                            dataSource = DX.data.utils.normalizeDataSourceOptions(dataSource);
                            if (isFilterRow) {
                                postProcess = dataSource.postProcess;
                                dataSource.postProcess = function(items) {
                                    if (this.pageIndex() === 0) {
                                        items = items.slice(0);
                                        items.unshift(null)
                                    }
                                    if (postProcess)
                                        return postProcess.call(this, items);
                                    return items
                                }
                            }
                        }
                        options.editorName = "dxSelectBox";
                        options.editorOptions = getResultConfig({
                            searchEnabled: true,
                            value: options.value,
                            valueExpr: options.lookup.valueExpr,
                            searchExpr: options.lookup.searchExpr || options.lookup.displayExpr,
                            showClearButton: Boolean(lookup.allowClearing && !isFilterRow),
                            displayExpr: function(data) {
                                if (data === null)
                                    return options.showAllText;
                                return displayGetter(data)
                            },
                            dataSource: dataSource,
                            onValueChanged: function(e) {
                                options.setValue(e.value, e.component.option("text"))
                            }
                        }, options)
                    }
                };
            var prepareCheckBox = function(options) {
                    options.editorName = "dxCheckBox";
                    options.editorOptions = getResultConfig({
                        value: options.value,
                        hoverStateEnabled: !options.readOnly,
                        focusStateEnabled: !options.readOnly,
                        activeStateEnabled: false,
                        onValueChanged: function(e) {
                            options.setValue && options.setValue(e.value, e)
                        },
                        tabIndex: options.tabIndex ? options.tabIndex : 0
                    }, options)
                };
            var createEditorCore = function(that, options) {
                    if (options.editorName && options.editorOptions && options.editorElement[options.editorName]) {
                        if (options.editorName === "dxCheckBox")
                            options.editorElement.addClass(DATAGRID_CHECKBOX_SIZE_CLASS);
                        that._createComponent(options.editorElement, options.editorName, options.editorOptions);
                        if (options.editorName === "dxTextBox")
                            options.editorElement.dxTextBox("instance").registerKeyHandler("enter", $.noop)
                    }
                };
            return {
                    _getFocusedElement: function($dataGridElement) {
                        return $dataGridElement.find("[tabindex]:focus, input:focus")
                    },
                    _updateFocusCore: function() {
                        var $focus = this._$focusedElement,
                            $dataGridElement = this.component && this.component.element(),
                            $focusCell,
                            hideBorders;
                        if ($dataGridElement) {
                            $focus = this._getFocusedElement($dataGridElement);
                            if ($focus.length) {
                                if (!$focus.hasClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS)) {
                                    $focusCell = $focus.closest(".dx-row > td, ." + DATAGRID_CELL_FOCUS_DISABLED_CLASS);
                                    hideBorders = $focusCell.get(0) !== $focus.get(0) && $focusCell.hasClass(DATAGRID_EDITOR_INLINE_BLOCK);
                                    $focus = $focusCell
                                }
                                if ($focus.length && !$focus.hasClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS)) {
                                    this.focus($focus, hideBorders);
                                    return
                                }
                            }
                        }
                        this.loseFocus()
                    },
                    _updateFocus: function(e) {
                        var that = this,
                            isFocusOverlay = e && e.jQueryEvent && $(e.jQueryEvent.target).hasClass(DATAGRID_FOCUS_OVERLAY_CLASS);
                        that._isFocusOverlay = that._isFocusOverlay || isFocusOverlay;
                        clearTimeout(that._updateFocusTimeoutID);
                        that._updateFocusTimeoutID = setTimeout(function() {
                            delete that._updateFocusTimeoutID;
                            if (!that._isFocusOverlay)
                                that._updateFocusCore();
                            that._isFocusOverlay = false
                        })
                    },
                    _updateFocusOverlaySize: function($element, position) {
                        var location = positionUtils.calculate($element, $.extend({collision: "fit"}, position));
                        if (location.h.oversize > 0)
                            $element.outerWidth($element.outerWidth() - location.h.oversize);
                        if (location.v.oversize > 0)
                            $element.outerHeight($element.outerHeight() - location.v.oversize)
                    },
                    callbackNames: function() {
                        return ["focused"]
                    },
                    focus: function($element, hideBorder) {
                        var that = this;
                        if ($element === undefined)
                            return that._$focusedElement;
                        else if ($element)
                            setTimeout(function() {
                                var $focusOverlay = that._$focusOverlay = that._$focusOverlay || $("<div>").addClass(DATAGRID_FOCUS_OVERLAY_CLASS + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS),
                                    focusOverlayPosition;
                                if (hideBorder)
                                    that._$focusOverlay && that._$focusOverlay.addClass(DX_HIDDEN);
                                else {
                                    var align = browser.msie ? "left bottom" : browser.mozilla ? "right bottom" : "left top",
                                        $content = $element.closest("." + DATAGRID_CONTENT_CLASS);
                                    $focusOverlay.removeClass(DX_HIDDEN).appendTo($content).outerWidth($element.outerWidth() + 1).outerHeight($element.outerHeight() + 1);
                                    focusOverlayPosition = {
                                        my: align,
                                        at: align,
                                        of: $element,
                                        boundary: $content.length && $content
                                    };
                                    that._updateFocusOverlaySize($focusOverlay, focusOverlayPosition);
                                    positionUtils.setup($focusOverlay, focusOverlayPosition);
                                    $focusOverlay.css("visibility", "visible")
                                }
                                that._$focusedElement && that._$focusedElement.removeClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
                                $element.addClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
                                that._$focusedElement = $element;
                                that.focused.fire($element)
                            })
                    },
                    resize: function() {
                        var $focusedElement = this._$focusedElement;
                        if ($focusedElement)
                            this.focus($focusedElement)
                    },
                    loseFocus: function() {
                        this._$focusedElement && this._$focusedElement.removeClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
                        this._$focusedElement = null;
                        this._$focusOverlay && this._$focusOverlay.addClass(DX_HIDDEN)
                    },
                    init: function() {
                        this.createAction("onEditorPreparing", {
                            excludeValidators: ["designMode", "disabled", "readOnly"],
                            category: "rendering"
                        });
                        this.createAction("onEditorPrepared", {
                            excludeValidators: ["designMode", "disabled", "readOnly"],
                            category: "rendering"
                        });
                        this._updateFocusHandler = this._updateFocusHandler || this.createAction($.proxy(this._updateFocus, this));
                        $(document).on(DATAGRID_UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
                        this._attachContainerEventHandlers()
                    },
                    _attachContainerEventHandlers: function() {
                        var that = this,
                            $container = that.component && that.component.element(),
                            isIE10OrLower = browser.msie && parseInt(browser.version) < 11;
                        if ($container) {
                            $container.on(addNamespace("keydown", DATAGRID_MODULE_NAMESPACE), function(e) {
                                if (e.which === TAB_KEY)
                                    that._updateFocusHandler(e)
                            });
                            isIE10OrLower && $container.on([pointerEvents.down, pointerEvents.up, "dxclick"].join(" "), "." + DATAGRID_POINTER_EVENTS_TARGET_CLASS, $.proxy(that._focusOverlayEventProxy, that))
                        }
                    },
                    _focusOverlayEventProxy: function(e) {
                        var $target = $(e.target),
                            $currentTarget = $(e.currentTarget),
                            element,
                            needProxy = $target.hasClass(DATAGRID_POINTER_EVENTS_TARGET_CLASS) || $target.hasClass(DATAGRID_POINTER_EVENTS_NONE_CLASS),
                            $focusedElement = this._$focusedElement;
                        if (!needProxy || $currentTarget.hasClass(DX_HIDDEN))
                            return;
                        $currentTarget.addClass(DX_HIDDEN);
                        element = $target.get(0).ownerDocument.elementFromPoint(e.clientX, e.clientY);
                        eventUtils.fireEvent({
                            originalEvent: e,
                            target: element
                        });
                        e.stopPropagation();
                        $currentTarget.removeClass(DX_HIDDEN);
                        $focusedElement && $focusedElement.find("input").focus()
                    },
                    dispose: function() {
                        clearTimeout(this._updateFocusTimeoutID);
                        $(document).off(DATAGRID_UPDATE_FOCUS_EVENTS, this._updateFocusHandler)
                    },
                    createEditor: function($container, options) {
                        options.rtlEnabled = this.option("rtlEnabled");
                        options.disabled = this.option("disabled");
                        options.cancel = false;
                        options.editorElement = $container;
                        if (options.lookup)
                            prepareSelectBox(options);
                        else
                            switch (options.dataType) {
                                case"date":
                                    prepareDateBox(options);
                                    break;
                                case"boolean":
                                    prepareBooleanEditor(options);
                                    break;
                                case"number":
                                    prepareNumberBox(options);
                                    break;
                                default:
                                    prepareTextBox(options);
                                    break
                            }
                        this.executeAction("onEditorPreparing", options);
                        if (options.cancel)
                            return;
                        createEditorCore(this, options);
                        this.executeAction("onEditorPrepared", options)
                    }
                }
        }());
        $.extend(dataGrid.__internals, {DATAGRID_FOCUSED_ELEMENT_CLASS: DATAGRID_FOCUSED_ELEMENT_CLASS});
        dataGrid.registerModule("editorFactory", {
            defaultOptions: function() {
                return {}
            },
            controllers: {editorFactory: dataGrid.EditorFactoryController},
            extenders: {controllers: {columnsResizer: {_startResizing: function(args) {
                            this.callBase(args);
                            if (this.isResizing())
                                this.getController("editorFactory").loseFocus()
                        }}}}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnsView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            browser = DX.require("/utils/utils.browser"),
            commonUtils = DX.require("/utils/utils.common"),
            devices = DX.require("/devices"),
            dataGrid = ui.dxDataGrid;
        var DATAGRID_SCROLL_CONTAINER_CLASS = "dx-datagrid-scroll-container",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_GROUP_SPACE_CLASS = "dx-datagrid-group-space",
            DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
            DATAGRID_DETAIL_ROW_CLASS = "dx-master-detail-row",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_COLUMN_INDICATORS_CLASS = "dx-column-indicators",
            DATAGRID_TABLE_FIXED_CLASS = "dx-datagrid-table-fixed",
            DATAGRID_INDICATOR_ALIGNMENT_CLASS = "dx-indicator-alignment-",
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            DATAGRID_CELL_HINT_VISIBLE = "dxCellHintVisible",
            indicatorNamesClass = {
                sort: "dx-sort",
                headerFilter: "dx-header-filter"
            };
        var appendElementTemplate = {render: function(element, container) {
                    container.append(element)
                }};
        dataGrid.getWidths = function($tableElement) {
            var cells,
                result = [],
                width,
                clientRect;
            if ($tableElement) {
                cells = $tableElement.children("tbody").children("tr").filter(":not(." + DATAGRID_GROUP_ROW_CLASS + ")").filter(":not(." + DATAGRID_DETAIL_ROW_CLASS + ")").first().find("> td");
                $.each(cells, function(index, item) {
                    width = item.offsetWidth;
                    if (item.getBoundingClientRect) {
                        clientRect = item.getBoundingClientRect();
                        if (clientRect.width > width)
                            width = Math.ceil(clientRect.width)
                    }
                    result.push(width)
                })
            }
            return result
        };
        dataGrid.ColumnsView = dataGrid.View.inherit({
            _getColumnAlignment: function(alignment, rtlEnabled) {
                rtlEnabled = rtlEnabled || this.option("rtlEnabled");
                return alignment !== "center" ? alignment : commonUtils.getDefaultAlignment(rtlEnabled)
            },
            _applyColumnState: function(options) {
                var that = this,
                    rtlEnabled = this.option("rtlEnabled"),
                    columnAlignment = that._getColumnAlignment(options.column.alignment, rtlEnabled),
                    parameters = $.extend(true, {columnAlignment: columnAlignment}, options),
                    $indicatorsContainer = that._createIndicatorContainer(parameters),
                    $span = $("<span />").addClass(indicatorNamesClass[options.name]),
                    getIndicatorAlignment = function() {
                        if (rtlEnabled)
                            return columnAlignment === "left" ? "right" : "left";
                        return columnAlignment
                    };
                parameters.container = $indicatorsContainer;
                parameters.indicator = $span;
                that._renderIndicator(parameters);
                $indicatorsContainer[!options.showColumnLines && getIndicatorAlignment() === "left" ? "appendTo" : "prependTo"](options.rootElement).addClass(DATAGRID_INDICATOR_ALIGNMENT_CLASS + columnAlignment);
                return $span
            },
            _createIndicatorContainer: function(options) {
                var $indicatorsContainer = options.rootElement.find("." + DATAGRID_COLUMN_INDICATORS_CLASS),
                    indicatorAlignment = options.columnAlignment === "left" ? "right" : "left";
                if (!$indicatorsContainer.length)
                    $indicatorsContainer = $("<div/>").addClass(DATAGRID_COLUMN_INDICATORS_CLASS);
                return $indicatorsContainer.css("float", options.showColumnLines ? indicatorAlignment : null)
            },
            _getIndicatorContainer: function($cell) {
                return $cell && $cell.find("." + DATAGRID_COLUMN_INDICATORS_CLASS)
            },
            _renderIndicator: function(options) {
                var $container = options.container,
                    $indicator = options.indicator;
                $container && $indicator && $container.append($indicator)
            },
            _updateIndicators: function(indicatorName) {
                var that = this,
                    columns = that.getColumns(),
                    $cells = that.getColumnElements(),
                    $cell,
                    i;
                for (i = 0; i < columns.length; i++) {
                    $cell = $cells.eq(i);
                    that._updateIndicator($cell, columns[i], indicatorName)
                }
            },
            _updateIndicator: function($cell, column, indicatorName) {
                if (!column.command)
                    return this._applyColumnState({
                            name: indicatorName,
                            rootElement: $cell,
                            column: column,
                            showColumnLines: this.option("showColumnLines")
                        })
            },
            _updateCell: function($cell, parameters) {
                if (parameters.rowType)
                    this._cellPrepared($cell, parameters)
            },
            _createCell: function(column) {
                var defaultAlignment = commonUtils.getDefaultAlignment(this.option("rtlEnabled")),
                    alignment = column.alignment || defaultAlignment;
                var cell = window.document.createElement("td");
                cell.style.textAlign = alignment;
                var $cell = $(cell);
                this.setAria("role", "gridcell", $cell);
                if (!commonUtils.isDefined(column.groupIndex) && column.cssClass)
                    $cell.addClass(column.cssClass);
                if (column.command === "expand")
                    $cell.addClass(DATAGRID_GROUP_SPACE_CLASS);
                return $cell
            },
            _createRow: function(row) {
                return $("<tr />").addClass(DATAGRID_ROW_CLASS).attr("role", "row")
            },
            _createTable: function(columns) {
                var that = this,
                    $table = $("<table />").addClass(DATAGRID_TABLE_CLASS).addClass(DATAGRID_TABLE_FIXED_CLASS).attr("role", "grid");
                if (columns) {
                    $table.append(that._createColGroup(columns));
                    if (devices.real().ios)
                        $table.append("<thead><tr></tr></thead>")
                }
                if (browser.mozilla)
                    $table.on("mousedown", "td", function(e) {
                        if (e.ctrlKey)
                            e.preventDefault()
                    });
                if (that.option("cellHintEnabled"))
                    $table.on("mousemove", ".dx-row > td", this.createAction(function(args) {
                        var e = args.jQueryEvent,
                            $element = $(e.target),
                            $cell = $(e.currentTarget),
                            $row = $cell.parent(),
                            isDataRow = $row.hasClass("dx-data-row"),
                            isHeaderRow = $row.hasClass("dx-header-row"),
                            $cells = $row.children(),
                            visibleColumns = that._columnsController.getVisibleColumns(),
                            visibleColumnIndex = $cells.index($cell),
                            column = visibleColumns[visibleColumnIndex];
                        if (!isDataRow && !isHeaderRow || isDataRow && column && !column.cellTemplate || isHeaderRow && column && !column.headerCellTemplate) {
                            if ($element.data(DATAGRID_CELL_HINT_VISIBLE)) {
                                $element.removeAttr("title");
                                $element.data(DATAGRID_CELL_HINT_VISIBLE, false)
                            }
                            if ($element[0].scrollWidth > $element[0].clientWidth && !$element.attr("title")) {
                                $element.attr("title", $element.text());
                                $element.data(DATAGRID_CELL_HINT_VISIBLE, true)
                            }
                        }
                    }));
                var getOptions = function(event) {
                        var cellElement = $(event.currentTarget),
                            rowOptions = cellElement.parent().data("options"),
                            options = rowOptions && rowOptions.cells && rowOptions.cells[cellElement.index()];
                        return $.extend({}, options, {
                                cellElement: cellElement,
                                jQueryEvent: event,
                                eventType: event.type
                            })
                    };
                if (that.option("onCellClick"))
                    $table.on("dxclick", ".dx-row > td", function(e) {
                        that.executeAction("onCellClick", getOptions(e))
                    });
                if (that.option("onCellHoverChanged")) {
                    $table.on("mouseover", ".dx-row > td", function(e) {
                        that.executeAction("onCellHoverChanged", getOptions(e))
                    });
                    $table.on("mouseout", ".dx-row > td", function(e) {
                        that.executeAction("onCellHoverChanged", getOptions(e))
                    })
                }
                $table.on("dxclick", ".dx-row", that.createAction(function(e) {
                    var jQueryEvent = e.jQueryEvent;
                    if (!$(jQueryEvent.target).closest("a").length) {
                        e.rowIndex = that.getRowIndex(jQueryEvent.currentTarget);
                        e.rowElement = $(jQueryEvent.currentTarget);
                        e.columns = that.getColumns();
                        that._rowClick(e)
                    }
                }));
                return $table
            },
            _rowClick: $.noop,
            _createColGroup: function(columns) {
                var i,
                    j,
                    colgroupElement = $("<colgroup />"),
                    colspan,
                    columnsLength = columns.length;
                for (i = 0; i < columnsLength; i++) {
                    colspan = columns[i].colspan || 1;
                    for (j = 0; j < colspan; j++)
                        colgroupElement.append(this._createCol(columns[i]))
                }
                return colgroupElement
            },
            _createCol: function(column) {
                return $("<col />").width(column.visibleWidth || column.width)
            },
            renderDelayedTemplates: function() {
                var templateParameters,
                    delayedTemplates = this._delayedTemplates;
                while (delayedTemplates.length) {
                    templateParameters = delayedTemplates.shift();
                    templateParameters.template.render(templateParameters.options, templateParameters.container);
                    if (templateParameters.options.column)
                        this._updateCell(templateParameters.container, templateParameters.options)
                }
            },
            _processTemplate: function(template, options) {
                var that = this,
                    renderingTemplate;
                if (template && template.render)
                    renderingTemplate = {
                        allowRenderToDetachedContainer: template.allowRenderToDetachedContainer,
                        render: function(options, container) {
                            template.render(container, options)
                        }
                    };
                else if ($.isFunction(template))
                    renderingTemplate = {render: function(options, container) {
                            template(container, options)
                        }};
                else {
                    if (!that._templatesCache[template])
                        that._templatesCache[template] = that.getTemplate(template);
                    renderingTemplate = that._templatesCache[template]
                }
                return renderingTemplate
            },
            _renderTemplate: function(container, template, options) {
                var that = this,
                    renderingTemplate = that._processTemplate(template, options);
                if (renderingTemplate)
                    if (renderingTemplate.allowRenderToDetachedContainer) {
                        renderingTemplate.render(options, container);
                        return true
                    }
                    else
                        that._delayedTemplates.push({
                            template: renderingTemplate,
                            container: container,
                            options: options
                        });
                return false
            },
            _appendRow: function($table, $row) {
                var that = this;
                if (that.option("rowTemplate") && that._delayedTemplates.length && $row)
                    that._delayedTemplates.push({
                        container: $table,
                        template: appendElementTemplate,
                        options: $row
                    });
                else
                    $table.append($row)
            },
            _renderCore: function(change) {
                var $root = this.element().parent();
                if (!$root || $root.parent().length)
                    this.renderDelayedTemplates()
            },
            _renderTable: function(options) {
                options = options || {};
                var that = this,
                    $table;
                options.columns = that._columnsController.getVisibleColumns();
                $table = that._createTable(options.columns);
                that._renderRows($table, options);
                return $table
            },
            _renderRows: function($table, options) {
                var that = this,
                    i,
                    rows = that._getRows(options.change);
                for (i = 0; i < rows.length; i++)
                    that._renderRow($table, $.extend({row: rows[i]}, options))
            },
            _renderRow: function($table, options) {
                var that = this,
                    $row;
                options.row.cells = [];
                $row = that._createRow(options.row);
                that._renderCells($row, options);
                that._appendRow($table, $row);
                that._rowPrepared($row, $.extend({columns: options.columns}, options.row))
            },
            _renderCells: function($row, options) {
                var that = this,
                    i,
                    columnIndex = 0,
                    row = options.row,
                    columns = options.columns;
                for (i = 0; i < columns.length; i++) {
                    that._renderCell($row, $.extend({
                        column: columns[i],
                        columnIndex: columnIndex,
                        value: row.values && row.values[columnIndex]
                    }, options));
                    if (commonUtils.isDefined(columns[i].colspan))
                        columnIndex += columns[i].colspan;
                    else
                        columnIndex++
                }
            },
            _renderCell: function($row, options) {
                var that = this,
                    cellOptions = that._getCellOptions(options),
                    column = options.column,
                    $cell;
                options.row.cells.push(cellOptions);
                $cell = that._createCell(column);
                if (!commonUtils.isDefined(column.command))
                    that.setAria("label", that.localize("dxDataGrid-ariaColumn") + " " + column.caption + ", " + that.localize("dxDataGrid-ariaValue") + " " + cellOptions.text, $cell);
                that._renderCellContent($cell, cellOptions);
                $row.get(0).appendChild($cell.get(0));
                return $cell
            },
            _renderCellContent: function($cell, options) {
                var template = this._getCellTemplate(options);
                if (!template || this._renderTemplate($cell, template, options))
                    this._updateCell($cell, options)
            },
            _getCellTemplate: function(options){},
            _getRows: function() {
                return []
            },
            _getCellOptions: function(options) {
                return {
                        column: options.column,
                        columnIndex: options.columnIndex,
                        rowType: options.row.rowType
                    }
            },
            _cellPrepared: function($cell, options) {
                options.cellElement = $cell;
                this.executeAction("onCellPrepared", options)
            },
            _rowPrepared: function($row, options) {
                $row.data("options", options);
                options.rowElement = $row;
                this.executeAction("onRowPrepared", options)
            },
            _columnOptionChanged: function(e) {
                var optionNames = e.optionNames;
                if (dataGrid.checkChanges(optionNames, ["width", "visibleWidth"])) {
                    var visibleColumns = this._columnsController.getVisibleColumns();
                    var widths = $.map(visibleColumns, function(column) {
                            return column.visibleWidth || column.width || "auto"
                        });
                    this.setColumnWidths(widths);
                    return
                }
                if (!this._requireReady)
                    this.render()
            },
            getTableElements: function() {
                return this._tableElement || $()
            },
            _getTableElement: function() {
                return this._tableElement
            },
            _setTableElement: function(tableElement) {
                this._tableElement = tableElement
            },
            optionChanged: function(args) {
                this.callBase(args);
                switch (args.name) {
                    case"cellHintEnabled":
                    case"onCellPrepared":
                    case"onRowPrepared":
                    case"onCellHoverChanged":
                        this._invalidate(true, true);
                        args.handled = true;
                        break
                }
            },
            init: function() {
                var that = this;
                that._scrollLeft = 0;
                that._columnsController = that.getController("columns");
                that._dataController = that.getController("data");
                that._delayedTemplates = [];
                that._templatesCache = {};
                that.createAction("onCellClick");
                that.createAction("onRowClick");
                that.createAction("onCellHoverChanged", {excludeValidators: ["disabled", "readOnly"]});
                that.createAction("onCellPrepared", {
                    excludeValidators: ["designMode", "disabled", "readOnly"],
                    category: "rendering"
                });
                that.createAction("onRowPrepared", {
                    excludeValidators: ["designMode", "disabled", "readOnly"],
                    category: "rendering",
                    afterExecute: function(e) {
                        that._afterRowPrepared(e)
                    }
                });
                that._columnsController.columnsChanged.add($.proxy(that._columnOptionChanged, that));
                that._dataController && that._dataController.changed.add($.proxy(that._handleDataChanged, that))
            },
            _afterRowPrepared: $.noop,
            _handleDataChanged: function(e){},
            callbackNames: function() {
                return ["scrollChanged"]
            },
            scrollTo: function(pos) {
                var that = this,
                    $element = that.element(),
                    $scrollContainer = $element && $element.find("." + DATAGRID_SCROLL_CONTAINER_CLASS);
                that._skipScrollChanged = false;
                if (commonUtils.isDefined(pos) && commonUtils.isDefined(pos.left) && that._scrollLeft !== pos.left) {
                    that._scrollLeft = pos.left;
                    $scrollContainer && $scrollContainer.scrollLeft(Math.round(pos.left));
                    that._skipScrollChanged = true
                }
            },
            wrapTableInScrollContainer: function($table) {
                var that = this,
                    $scrollContainer;
                $scrollContainer = $("<div/>").on("scroll", function() {
                    !that._skipScrollChanged && that.scrollChanged.fire({left: $scrollContainer.scrollLeft()}, that.name);
                    that._skipScrollChanged = false
                }).addClass(DATAGRID_CONTENT_CLASS).addClass(DATAGRID_SCROLL_CONTAINER_CLASS).append($table);
                return $scrollContainer
            },
            getColumnWidths: function() {
                var that = this,
                    result = [],
                    tableElement = that._getTableElement();
                if (tableElement)
                    result = dataGrid.getWidths(tableElement);
                return result
            },
            setColumnWidths: function(widths) {
                var $cols,
                    i,
                    j,
                    columnIndex,
                    columns,
                    tableElements = this.getTableElements(true);
                if (tableElements.length && widths)
                    for (i = 0; i < tableElements.length; i++) {
                        columnIndex = 0;
                        $cols = $(tableElements[i]).find("col");
                        columns = this.getColumns($(tableElements[i]));
                        for (j = 0; j < columns.length; j++) {
                            if (columns[j].colspan) {
                                columnIndex += columns[j].colspan;
                                continue
                            }
                            $cols.eq(columnIndex).css("width", widths[columnIndex] || "auto");
                            columnIndex++
                        }
                    }
            },
            getCellElements: function(rowIndex) {
                var $row = this._getRowElements().eq(rowIndex);
                return $row.children()
            },
            getCellElement: function(rowIndex, columnIdentificator) {
                var that = this,
                    $cells = that.getCellElements(rowIndex),
                    $cell,
                    columnsController = that._columnsController,
                    columnIndex,
                    columnVisibleIndex = columnIdentificator;
                if (commonUtils.isString(columnIdentificator)) {
                    columnIndex = columnsController.columnOption(columnIdentificator, "index");
                    columnVisibleIndex = columnsController.getVisibleIndex(columnIndex)
                }
                if ($cells.length && columnVisibleIndex >= 0)
                    $cell = $cells.eq(columnVisibleIndex);
                if ($cell && $cell.length)
                    return $cell
            },
            getColumnElements: function(){},
            getColumns: function() {
                return this._columnsController.getVisibleColumns()
            },
            getCell: function(cellPosition, rows) {
                var $rows = rows || this._getRowElements(),
                    $cells;
                if ($rows.length > 0 && cellPosition.rowIndex >= 0) {
                    cellPosition.rowIndex = cellPosition.rowIndex < $rows.length ? cellPosition.rowIndex : $rows.length - 1;
                    $cells = this.getCellElements(cellPosition.rowIndex);
                    if ($cells && $cells.length > 0)
                        return $cells.eq($cells.length > cellPosition.columnIndex ? cellPosition.columnIndex : $cells.length - 1)
                }
            },
            getRowsCount: function() {
                var tableElement = this._getTableElement();
                if (tableElement && tableElement.length === 1)
                    return tableElement[0].rows.length;
                return 0
            },
            _getRowElements: function(tableElement) {
                tableElement = tableElement || this._getTableElement();
                return tableElement && tableElement.children("tbody").children("." + DATAGRID_ROW_CLASS) || $()
            },
            getRowIndex: function($row) {
                return this._getRowElements().index($row)
            },
            getBoundingRect: function(){},
            getName: function(){}
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_INDICATOR_ALIGNMENT_CLASS: DATAGRID_INDICATOR_ALIGNMENT_CLASS,
            DATAGRID_GROUP_SPACE_CLASS: DATAGRID_GROUP_SPACE_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_ROW_CLASS: DATAGRID_ROW_CLASS,
            DATAGRID_GROUP_ROW_CLASS: DATAGRID_GROUP_ROW_CLASS,
            DATAGRID_TABLE_CLASS: DATAGRID_TABLE_CLASS,
            DATAGRID_TABLE_FIXED_CLASS: DATAGRID_TABLE_FIXED_CLASS,
            DATAGRID_SCROLL_CONTAINER_CLASS: DATAGRID_SCROLL_CONTAINER_CLASS,
            DATAGRID_COLUMN_INDICATORS_CLASS: DATAGRID_COLUMN_INDICATORS_CLASS,
            DATAGRID_HEADER_ROW_CLASS: DATAGRID_HEADER_ROW_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnChooserModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            themes = DX.require("/ui/ui.themes"),
            Button = DX.require("/ui/widgets/ui.button");
        var DATAGRID_COLUMN_CHOOSER_CLASS = "dx-datagrid-column-chooser",
            DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS = "dx-datagrid-column-chooser-button",
            DATAGRID_COLUMN_CHOOSER_ICON_NAME = "column-chooser",
            DATAGRID_COLUMN_CHOOSER_ITEM_CLASS = "dx-column-chooser-item",
            DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS = "dx-column-chooser-message",
            DATAGRID_HEADERS_DRAG_ACTION_CLASS = "dx-datagrid-drag-action";
        dataGrid.ColumnChooserController = dataGrid.ViewController.inherit({
            renderShowColumnChooserButton: function($element) {
                var that = this,
                    columnChooserEnabled = that.option("columnChooser.enabled"),
                    $showColumnChooserButton = $element.find("." + DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS),
                    $columnChooserButton;
                if (columnChooserEnabled)
                    if (!$showColumnChooserButton.length) {
                        $columnChooserButton = $("<div />").addClass(DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS).appendTo($element);
                        that._createComponent($columnChooserButton, Button, {
                            icon: DATAGRID_COLUMN_CHOOSER_ICON_NAME,
                            onClick: function() {
                                that.getView("columnChooserView").showColumnChooser()
                            },
                            hint: that.option("columnChooser.title"),
                            _templates: {}
                        })
                    }
                    else
                        $showColumnChooserButton.show();
                else
                    $showColumnChooserButton.hide()
            },
            getPosition: function() {
                var rowsView = this.getView("rowsView");
                return {
                        my: "right bottom",
                        at: "right bottom",
                        of: rowsView && rowsView.element(),
                        collision: "fit",
                        offset: "-2 -2",
                        boundaryOffset: "2 2"
                    }
            }
        });
        dataGrid.ColumnChooserView = dataGrid.ColumnsView.inherit({
            _updateItems: function() {
                var chooserColumns = this._columnsController.getChooserColumns(),
                    columnChooserOptions = this.option("columnChooser"),
                    $content = this._popupContainer.content(),
                    scrollableInstance = this._createComponent($content, "dxScrollable", dataGrid.createScrollableOptions(this));
                this._renderColumnChooserItems($content, chooserColumns);
                if (!chooserColumns.length)
                    $("<span />").addClass(DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS).text(columnChooserOptions ? columnChooserOptions.emptyPanelText : "").appendTo(scrollableInstance.content())
            },
            _initializePopupContainer: function() {
                var that = this,
                    $element = that.element().addClass(DATAGRID_COLUMN_CHOOSER_CLASS),
                    columnChooserOptions = that.option("columnChooser"),
                    theme = themes.current(),
                    isGenericTheme = theme && theme.indexOf("generic") > -1,
                    isAndroid5Theme = theme && theme.indexOf("android5") > -1,
                    dxPopupOptions = {
                        visible: false,
                        shading: false,
                        showCloseButton: false,
                        dragEnabled: true,
                        buttons: [{
                                text: columnChooserOptions.title,
                                toolbar: "top",
                                location: isGenericTheme || isAndroid5Theme ? "before" : "center"
                            }],
                        position: that.getController("columnChooser").getPosition(),
                        width: columnChooserOptions.width,
                        height: columnChooserOptions.height,
                        rtlEnabled: that.option("rtlEnabled"),
                        container: columnChooserOptions.container
                    };
                if (isGenericTheme)
                    $.extend(dxPopupOptions, {showCloseButton: true});
                else
                    dxPopupOptions.buttons[dxPopupOptions.buttons.length] = {shortcut: "cancel"};
                if (!commonUtils.isDefined(this._popupContainer)) {
                    that._popupContainer = that._createComponent($element, "dxPopup", dxPopupOptions);
                    that._popupContainer.on("optionChanged", function(args) {
                        if (args.name === "visible")
                            that.renderCompleted.fire()
                    })
                }
                else
                    this._popupContainer.option(dxPopupOptions)
            },
            _renderCore: function() {
                if (this._popupContainer)
                    this._updateItems()
            },
            _renderColumnChooserItems: function($container, chooserColumns) {
                var dxScrollable = $container.dxScrollable("instance"),
                    $scrollableContainer = dxScrollable.content(),
                    $item;
                $scrollableContainer.empty();
                $.each(chooserColumns, function(index, chooserColumn) {
                    $item = $("<div />").addClass(chooserColumn.cssClass).addClass(DATAGRID_COLUMN_CHOOSER_ITEM_CLASS).toggleClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS, chooserColumn.allowHiding).text(chooserColumn.caption).appendTo($scrollableContainer)
                });
                dxScrollable.update()
            },
            getColumnElements: function() {
                var $content = this._popupContainer && this._popupContainer.content();
                return $content && $content.find("." + DATAGRID_COLUMN_CHOOSER_ITEM_CLASS)
            },
            getName: function() {
                return "columnChooser"
            },
            getColumns: function() {
                return this._columnsController.getChooserColumns()
            },
            allowDragging: function(column) {
                return this.isColumnChooserVisible() && column && column.allowHiding
            },
            getBoundingRect: function() {
                var that = this,
                    container = that._popupContainer && that._popupContainer._container(),
                    offset;
                if (container && container.is(":visible")) {
                    offset = container.offset();
                    return {
                            left: offset.left,
                            top: offset.top,
                            right: offset.left + container.outerWidth(),
                            bottom: offset.top + container.outerHeight()
                        }
                }
                return null
            },
            showColumnChooser: function() {
                this._isPopupContainerShown = true;
                if (!this._popupContainer) {
                    this._initializePopupContainer();
                    this.render()
                }
                this._popupContainer.show()
            },
            hideColumnChooser: function() {
                if (this._popupContainer) {
                    this._popupContainer.hide();
                    this._isPopupContainerShown = false
                }
            },
            isColumnChooserVisible: function() {
                var popupContainer = this._popupContainer;
                return popupContainer && popupContainer.option("visible")
            },
            publicMethods: function() {
                return ["showColumnChooser", "hideColumnChooser"]
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_COLUMN_CHOOSER_CLASS: DATAGRID_COLUMN_CHOOSER_CLASS,
            DATAGRID_COLUMN_CHOOSER_ITEM_CLASS: DATAGRID_COLUMN_CHOOSER_ITEM_CLASS,
            DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS: DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS,
            DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS: DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS
        });
        dataGrid.registerModule("columnChooser", {
            defaultOptions: function() {
                return {columnChooser: {
                            enabled: false,
                            width: 250,
                            height: 260,
                            title: Globalize.localize("dxDataGrid-columnChooserTitle"),
                            emptyPanelText: Globalize.localize("dxDataGrid-columnChooserEmptyText"),
                            container: undefined
                        }}
            },
            controllers: {columnChooser: dataGrid.ColumnChooserController},
            views: {columnChooserView: dataGrid.ColumnChooserView},
            extenders: {views: {headerPanel: {
                        _renderShowColumnChooserButton: function() {
                            this.getController("columnChooser").renderShowColumnChooserButton(this.element())
                        },
                        _renderCore: function() {
                            this.callBase();
                            this._renderShowColumnChooserButton()
                        },
                        optionChanged: function(args) {
                            switch (args.name) {
                                case"columnChooser":
                                    this._renderShowColumnChooserButton();
                                    args.handled = true;
                                    break;
                                default:
                                    this.callBase(args)
                            }
                        },
                        isVisible: function() {
                            var that = this,
                                columnChooserEnabled = that.option("columnChooser.enabled");
                            return that.callBase() || columnChooserEnabled
                        }
                    }}}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.dataSourceAdapter.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid;
        function cloneItems(items, groupCount) {
            if (items) {
                items = items.slice(0);
                if (groupCount)
                    for (var i = 0; i < items.length; i++) {
                        items[i] = $.extend({key: items[i].key}, items[i]);
                        items[i].items = cloneItems(items[i].items, groupCount - 1)
                    }
            }
            return items
        }
        dataGrid.DataSourceAdapter = dataGrid.Controller.inherit(function() {
            function calculateOperationTypes(loadOptions, lastLoadOptions) {
                var operationTypes = {};
                if (lastLoadOptions) {
                    operationTypes = {
                        sorting: !dataGrid.equalSortParameters(loadOptions.sort, lastLoadOptions.sort),
                        grouping: !dataGrid.equalSortParameters(loadOptions.group, lastLoadOptions.group),
                        filtering: !dataGrid.equalFilterParameters(loadOptions.filter, lastLoadOptions.filter),
                        pageIndex: loadOptions.pageIndex !== lastLoadOptions.pageIndex,
                        pageSize: loadOptions.pageSize !== lastLoadOptions.pageSize
                    };
                    operationTypes.reload = operationTypes.sorting || operationTypes.grouping || operationTypes.filtering || operationTypes.pageSize;
                    operationTypes.paging = operationTypes.pageIndex || operationTypes.pageSize
                }
                return operationTypes
            }
            return {
                    init: function(dataSource, remoteOperations) {
                        var that = this;
                        that._dataSource = dataSource;
                        that._remoteOperations = remoteOperations || {};
                        that._isLastPage = !dataSource.isLastPage();
                        that._hasLastPage = false;
                        that._currentTotalCount = 0;
                        that.changed = $.Callbacks();
                        that.loadingChanged = $.Callbacks();
                        that.loadError = $.Callbacks();
                        that.customizeStoreLoadOptions = $.Callbacks();
                        that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
                        that._dataLoadingHandler = $.proxy(that._handleDataLoading, that);
                        that._dataLoadedHandler = $.proxy(that._handleDataLoaded, that);
                        that._loadingChangedHandler = $.proxy(that._handleLoadingChanged, that);
                        that._loadErrorHandler = $.proxy(that._handleLoadError, that);
                        dataSource.on("changed", that._dataChangedHandler);
                        dataSource.on("customizeStoreLoadOptions", that._dataLoadingHandler);
                        dataSource.on("customizeLoadResult", that._dataLoadedHandler);
                        dataSource.on("loadingChanged", that._loadingChangedHandler);
                        dataSource.on("loadError", that._loadErrorHandler);
                        $.each(dataSource, function(memberName, member) {
                            if (!that[memberName] && $.isFunction(member))
                                that[memberName] = function() {
                                    return this._dataSource[memberName].apply(this._dataSource, arguments)
                                }
                        })
                    },
                    remoteOperations: function() {
                        return this._remoteOperations
                    },
                    dispose: function(isSharedDataSource) {
                        var that = this,
                            dataSource = that._dataSource;
                        dataSource.off("changed", that._dataChangedHandler);
                        dataSource.off("customizeStoreLoadOptions", that._dataLoadingHandler);
                        dataSource.off("customizeLoadResult", that._dataLoadedHandler);
                        dataSource.off("loadingChanged", that._loadingChangedHandler);
                        dataSource.off("loadError", that._loadErrorHandler);
                        if (!isSharedDataSource)
                            dataSource.dispose()
                    },
                    refresh: function(storeLoadOptions, isReload, operationTypes) {
                        var that = this,
                            dataSource = that._dataSource;
                        if (isReload || operationTypes.reload) {
                            that._currentTotalCount = 0;
                            that._isLastPage = !dataSource.paginate();
                            that._hasLastPage = that._isLastPage
                        }
                    },
                    _handleDataLoading: function(options) {
                        var that = this,
                            dataSource = that._dataSource,
                            lastLoadOptions = that._lastLoadOptions,
                            loadOptions,
                            operationTypes;
                        that.customizeStoreLoadOptions.fire(options);
                        options.delay = this.option("loadingTimeout");
                        options.originalStoreLoadOptions = options.storeLoadOptions;
                        options.remoteOperations = $.extend({}, this.remoteOperations());
                        var isReload = !that.isLoaded() && !that._isRefreshing;
                        that._lastLoadOptions = loadOptions = $.extend({
                            pageIndex: dataSource.pageIndex(),
                            pageSize: dataSource.pageSize()
                        }, options.storeLoadOptions);
                        operationTypes = calculateOperationTypes(loadOptions, lastLoadOptions);
                        that._isRefreshing = true;
                        $.when(that.refresh(options.storeLoadOptions, isReload, operationTypes)).always(function() {
                            if (that._lastOperationId === options.operationId)
                                that.load();
                            that._isRefreshing = false
                        });
                        dataSource.cancel(that._lastOperationId);
                        that._lastOperationId = options.operationId;
                        if (that._isRefreshing)
                            dataSource.cancel(that._lastOperationId)
                    },
                    _handleDataLoaded: function(options) {
                        options.storeLoadOptions = options.originalStoreLoadOptions
                    },
                    _handleLoadingChanged: function(isLoading) {
                        this.loadingChanged.fire(isLoading)
                    },
                    _handleLoadError: function(error) {
                        this.changed.fire({
                            changeType: "loadError",
                            error: error
                        });
                        this.loadError.fire(error)
                    },
                    _handleDataChanged: function(args) {
                        var that = this,
                            currentTotalCount,
                            dataSource = that._dataSource,
                            itemsCount = that.itemsCount();
                        that._isLastPage = !itemsCount || !that.pageSize() || itemsCount < that.pageSize();
                        if (that._isLastPage)
                            that._hasLastPage = true;
                        if (dataSource.totalCount() >= 0) {
                            if (dataSource.pageIndex() >= that.pageCount()) {
                                dataSource.pageIndex(that.pageCount() - 1);
                                dataSource.load()
                            }
                        }
                        else {
                            currentTotalCount = dataSource.pageIndex() * that.pageSize() + itemsCount;
                            that._currentTotalCount = Math.max(that._currentTotalCount, currentTotalCount);
                            if (itemsCount === 0 && dataSource.pageIndex() >= that.pageCount()) {
                                dataSource.pageIndex(that.pageCount() - 1);
                                dataSource.load()
                            }
                        }
                        if (!dataSource.isLoading()) {
                            this.component._optionCache = {};
                            this.changed.fire(args);
                            this.component._optionCache = undefined
                        }
                    },
                    isLastPage: function() {
                        return this._isLastPage
                    },
                    totalCount: function() {
                        return parseInt(this._currentTotalCount || this._dataSource.totalCount())
                    },
                    itemsCount: function() {
                        return this._dataSource.items().length
                    },
                    totalItemsCount: function() {
                        return this.totalCount()
                    },
                    pageSize: function() {
                        var dataSource = this._dataSource;
                        if (!arguments.length && !dataSource.paginate())
                            return 0;
                        return dataSource.pageSize.apply(dataSource, arguments)
                    },
                    pageCount: function() {
                        var that = this,
                            count = that.totalItemsCount(),
                            pageSize = that.pageSize();
                        if (pageSize && count > 0)
                            return Math.max(1, Math.ceil(count / pageSize));
                        return 1
                    },
                    hasKnownLastPage: function() {
                        return this._hasLastPage || this._dataSource.totalCount() >= 0
                    }
                }
        }());
        dataGrid.DataSourceAdapter = dataGrid.DataSourceAdapter.inherit({
            reload: function(full) {
                return full ? this._dataSource.reload() : this._dataSource.load()
            },
            refresh: function(storeLoadOptions, isReload, operationTypes) {
                var that = this,
                    remoteOperations = that._remoteOperations;
                that.callBase.apply(that, arguments);
                if (isReload) {
                    that._cachedStoreData = undefined;
                    that._cachedPagingData = undefined
                }
                else {
                    if (operationTypes.reload)
                        that._cachedPagingData = undefined;
                    $.each(operationTypes, function(operationType, value) {
                        if (value && remoteOperations[operationType]) {
                            that._cachedStoreData = undefined;
                            that._cachedPagingData = undefined
                        }
                    })
                }
            },
            _handleDataLoading: function(options) {
                this.callBase(options);
                this._handleDataLoadingCore(options)
            },
            _handleDataLoadingCore: function(options) {
                var remoteOperations = options.remoteOperations;
                if (remoteOperations.grouping && options.storeLoadOptions.group)
                    remoteOperations.paging = false;
                options.loadOptions = {};
                var localLoadOptionNames = {
                        filter: !remoteOperations.filtering,
                        sort: !remoteOperations.sorting,
                        group: !remoteOperations.grouping,
                        summary: !remoteOperations.summary,
                        skip: !remoteOperations.paging,
                        take: !remoteOperations.paging,
                        requireTotalCount: !remoteOperations.paging
                    };
                $.each(options.storeLoadOptions, function(optionName, optionValue) {
                    if (localLoadOptionNames[optionName]) {
                        options.loadOptions[optionName] = optionValue;
                        delete options.storeLoadOptions[optionName]
                    }
                });
                if (!options.storeLoadOptions.isLoadingAll)
                    options.data = this._cachedStoreData
            },
            _handleDataLoaded: function(options) {
                var callBase = this.callBase,
                    loadOptions = options.loadOptions,
                    localPaging = options.remoteOperations && !options.remoteOperations.paging,
                    isCaching = this.option("cacheEnabled") !== false && localPaging && options.storeLoadOptions && !options.storeLoadOptions.isLoadingAll;
                if (!loadOptions) {
                    this._dataSource.cancel(options.operationId);
                    return
                }
                if (localPaging) {
                    options.skip = loadOptions.skip;
                    options.take = loadOptions.take;
                    delete loadOptions.skip;
                    delete loadOptions.take
                }
                if (loadOptions.group)
                    loadOptions.group = options.group || loadOptions.group;
                var groupCount = dataGrid.normalizeSortingInfo(options.storeLoadOptions.group || loadOptions.group).length;
                if (isCaching && this._cachedPagingData)
                    options.data = cloneItems(this._cachedPagingData, groupCount);
                else {
                    if (isCaching && !this._cachedStoreData)
                        this._cachedStoreData = cloneItems(options.data, dataGrid.normalizeSortingInfo(options.storeLoadOptions.group).length);
                    new DX.data.ArrayStore(options.data).load(loadOptions).done(function(data) {
                        options.data = data
                    });
                    if (isCaching)
                        this._cachedPagingData = cloneItems(options.data, groupCount)
                }
                if (loadOptions.requireTotalCount && localPaging) {
                    options.extra = $.isPlainObject(options.extra) ? options.extra : {};
                    options.extra.totalCount = options.data.length
                }
                this._handleDataLoadedCore(options);
                callBase.apply(this, arguments)
            },
            _handleDataLoadedCore: function(options) {
                if (options.remoteOperations && !options.remoteOperations.paging) {
                    if (options.skip !== undefined)
                        options.data = options.data.slice(options.skip);
                    if (options.take !== undefined)
                        options.data = options.data.slice(0, options.take)
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.groupingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            errors = DevExpress.require("/ui/ui.errors"),
            commonUtils = DX.require("/utils/utils.common"),
            Class = DX.require("/class"),
            normalizeSortingInfo = DX.data.utils.normalizeSortingInfo;
        var DATAGRID_GROUP_PANEL_CLASS = "dx-datagrid-group-panel",
            DATAGRID_GROUP_PANEL_MESSAGE_CLASS = "dx-group-panel-message",
            DATAGRID_GROUP_PANEL_ITEM_CLASS = "dx-group-panel-item",
            DATAGRID_GROUP_OPENED_CLASS = "dx-datagrid-group-opened",
            DATAGRID_GROUP_CLOSED_CLASS = "dx-datagrid-group-closed",
            DATAGRID_EXPAND_CLASS = "dx-datagrid-expand",
            DATAGRID_SELECTION_DISABLED_CLASS = "dx-selection-disabled";
        var GroupingDataSourceAdapterExtender = function() {
                return {
                        init: function() {
                            this.callBase.apply(this, arguments);
                            this._grouping = this._createGroupingHelper()
                        },
                        _createGroupingHelper: function() {
                            var remoteOperations = this.remoteOperations();
                            if (remoteOperations.filtering && remoteOperations.sorting && remoteOperations.paging && !remoteOperations.grouping)
                                return new dataGrid.ExpandedGroupingHelper(this);
                            else
                                return new dataGrid.CollapsedGroupingHelper(this)
                        },
                        totalItemsCount: function() {
                            var that = this,
                                totalCount = that.callBase();
                            return totalCount > 0 && that._dataSource.group() && that._dataSource.requireTotalCount() ? totalCount + that._grouping.totalCountCorrection() : totalCount
                        },
                        itemsCount: function() {
                            return this._dataSource.group() ? this._grouping.itemsCount() || 0 : this.callBase()
                        },
                        allowCollapseAll: function() {
                            return this._grouping.allowCollapseAll()
                        },
                        isRowExpanded: function(key) {
                            var groupInfo = this._grouping.findGroupInfo(key);
                            return groupInfo ? groupInfo.isExpanded : !this._grouping.allowCollapseAll()
                        },
                        collapseAll: function(groupIndex) {
                            if (!this._grouping.allowCollapseAll()) {
                                errors.log("E1018");
                                return false
                            }
                            return this._collapseExpandAll(groupIndex, false)
                        },
                        expandAll: function(groupIndex) {
                            return this._collapseExpandAll(groupIndex, true)
                        },
                        _collapseExpandAll: function(groupIndex, isExpand) {
                            var that = this,
                                dataSource = that._dataSource,
                                group = dataSource.group(),
                                groups = normalizeSortingInfo(group || []),
                                i;
                            if (groups.length) {
                                for (i = 0; i < groups.length; i++)
                                    if (groupIndex === undefined || groupIndex === i)
                                        groups[i].isExpanded = isExpand;
                                    else if (group && group[i])
                                        groups[i].isExpanded = group[i].isExpanded;
                                dataSource.group(groups);
                                that._grouping.foreachGroups(function(groupInfo, parents) {
                                    if (groupIndex === undefined || groupIndex === parents.length - 1)
                                        groupInfo.isExpanded = isExpand
                                }, false, true)
                            }
                            return true
                        },
                        refresh: function(storeLoadOptions) {
                            this.callBase.apply(this, arguments);
                            return this._grouping.refresh.apply(this._grouping, arguments)
                        },
                        changeRowExpand: function(path) {
                            var that = this,
                                dataSource = that._dataSource;
                            if (dataSource.group()) {
                                dataSource._changeLoadingCount(1);
                                return that._changeRowExpandCore(path).always(function() {
                                        dataSource._changeLoadingCount(-1)
                                    })
                            }
                        },
                        _changeRowExpandCore: function(path) {
                            return this._grouping.changeRowExpand(path)
                        },
                        getGroupsInfo: function() {
                            return this._grouping._groupsInfo
                        },
                        _handleDataLoading: function(options) {
                            return this._grouping.handleDataLoading(options, $.proxy(this.callBase, this))
                        },
                        _handleDataLoaded: function(options) {
                            return this._grouping.handleDataLoaded(options, $.proxy(this.callBase, this))
                        },
                        _handleDataLoadedCore: function(options) {
                            return this._grouping.handleDataLoadedCore(options, $.proxy(this.callBase, this))
                        }
                    }
            }();
        dataGrid.GroupingHelper = Class.inherit(function() {
            var findGroupInfoByKey = function(groupsInfo, key) {
                    var hash = groupsInfo.hash;
                    return hash && hash[key]
                };
            var getGroupInfoIndexByOffset = function(groupsInfo, offset) {
                    var index;
                    for (index = 0; index < groupsInfo.length; index++)
                        if (groupsInfo[index].offset > offset)
                            break;
                    return index
                };
            var updateGroupInfoOffsets = function(groupsInfo, parents) {
                    var groupInfo,
                        index,
                        newIndex;
                    for (index = 0; index < groupsInfo.length; index++) {
                        groupInfo = groupsInfo[index];
                        if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {
                            groupsInfo.splice(index, 1);
                            groupInfo.offset = groupInfo.data.offset;
                            for (var parentIndex = 0; parentIndex < parents.length; parentIndex++)
                                parents[parentIndex].offset = groupInfo.offset;
                            newIndex = getGroupInfoIndexByOffset(groupsInfo, groupInfo.offset);
                            groupsInfo.splice(newIndex, 0, groupInfo);
                            if (newIndex > index)
                                index--
                        }
                    }
                };
            var cleanGroupsInfo = function(groupsInfo, groupIndex, groupsCount) {
                    var i;
                    for (i = 0; i < groupsInfo.length; i++)
                        if (groupIndex + 1 >= groupsCount)
                            groupsInfo[i].children = [];
                        else
                            cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount)
                };
            return {
                    ctor: function(dataSourceAdapter) {
                        this._dataSource = dataSourceAdapter;
                        this.reset()
                    },
                    reset: function() {
                        this._groupsInfo = [];
                        this._totalCountCorrection = 0;
                        this._itemsCount = 0
                    },
                    totalCountCorrection: function() {
                        return this._totalCountCorrection
                    },
                    updateTotalItemsCount: function(totalCountCorrection) {
                        this._totalCountCorrection = totalCountCorrection || 0
                    },
                    _isGroupItemCountable: function(item) {
                        return !this._isVirtualPaging() || !item.isContinuation
                    },
                    _isVirtualPaging: function() {
                        var scrollingMode = this._dataSource.option("scrolling.mode");
                        return scrollingMode === "virtual" || scrollingMode === "infinite"
                    },
                    itemsCount: function() {
                        return this._itemsCount
                    },
                    updateItemsCount: function(data, groupsCount) {
                        function calculateItemsCount(that, items, groupsCount) {
                            var i,
                                result = 0;
                            if (items)
                                if (!groupsCount)
                                    result = items.length;
                                else
                                    for (i = 0; i < items.length; i++) {
                                        if (that._isGroupItemCountable(items[i]))
                                            result++;
                                        result += calculateItemsCount(that, items[i].items, groupsCount - 1)
                                    }
                            return result
                        }
                        this._itemsCount = calculateItemsCount(this, data, groupsCount)
                    },
                    foreachGroups: function(callback, childrenAtFirst, foreachCollapsedGroups, updateOffsets) {
                        var that = this;
                        function foreachGroupsCore(groupsInfo, callback, childrenAtFirst, parents) {
                            var i,
                                callbackResult,
                                callbackResults = [];
                            function executeCallback(callback, data, parents, callbackResults) {
                                var callbackResult = data && callback(data, parents);
                                callbackResults.push(callbackResult);
                                return callbackResult
                            }
                            for (i = 0; i < groupsInfo.length; i++) {
                                parents.push(groupsInfo[i].data);
                                if (!childrenAtFirst && executeCallback(callback, groupsInfo[i].data, parents, callbackResults) === false)
                                    return false;
                                if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded || foreachCollapsedGroups) {
                                    callbackResult = foreachGroupsCore(groupsInfo[i].children, callback, childrenAtFirst, parents);
                                    callbackResults.push(callbackResult);
                                    if (callbackResult === false)
                                        return false
                                }
                                if (childrenAtFirst && executeCallback(callback, groupsInfo[i].data, parents, callbackResults) === false)
                                    return false;
                                if (!groupsInfo[i].data || groupsInfo[i].data.offset !== groupsInfo[i].offset)
                                    updateOffsets = true;
                                parents.pop()
                            }
                            var currentParents = parents.slice(0);
                            return updateOffsets && $.when.apply($, callbackResults).always(function() {
                                    updateGroupInfoOffsets(groupsInfo, currentParents)
                                })
                        }
                        return foreachGroupsCore(that._groupsInfo, callback, childrenAtFirst, [])
                    },
                    findGroupInfo: function(path) {
                        var that = this,
                            pathIndex,
                            groupInfo,
                            groupsInfo = that._groupsInfo;
                        for (pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {
                            groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
                            groupsInfo = groupInfo && groupInfo.children
                        }
                        return groupInfo && groupInfo.data
                    },
                    addGroupInfo: function(groupInfoData) {
                        var that = this,
                            index,
                            groupInfo,
                            path = groupInfoData.path,
                            pathIndex,
                            groupsInfo = that._groupsInfo;
                        for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                            groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
                            if (!groupInfo) {
                                groupInfo = {
                                    key: path[pathIndex],
                                    offset: groupInfoData.offset,
                                    data: {
                                        offset: groupInfoData.offset,
                                        isExpanded: true,
                                        path: path.slice(0, pathIndex + 1)
                                    },
                                    children: []
                                };
                                index = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);
                                groupsInfo.splice(index, 0, groupInfo);
                                groupsInfo.hash = groupsInfo.hash || {};
                                groupsInfo.hash[groupInfo.key] = groupInfo
                            }
                            if (pathIndex === path.length - 1) {
                                groupInfo.data = groupInfoData;
                                if (groupInfo.offset !== groupInfoData.offset)
                                    updateGroupInfoOffsets(groupsInfo)
                            }
                            groupsInfo = groupInfo.children
                        }
                    },
                    allowCollapseAll: function() {
                        return true
                    },
                    refresh: function(storeLoadOptions) {
                        var that = this,
                            groupIndex,
                            oldGroups = normalizeSortingInfo(that._group || []),
                            groups = normalizeSortingInfo(storeLoadOptions.group || []),
                            groupsCount = Math.min(oldGroups.length, groups.length);
                        that._group = storeLoadOptions.group;
                        for (groupIndex = 0; groupIndex < groupsCount; groupIndex++)
                            if (oldGroups[groupIndex].selector !== groups[groupIndex].selector) {
                                groupsCount = groupIndex;
                                break
                            }
                        if (!groupsCount)
                            that.reset();
                        else
                            cleanGroupsInfo(that._groupsInfo, 0, groupsCount)
                    },
                    handleDataLoading: function(options, callBase) {
                        callBase(options)
                    },
                    handleDataLoaded: function(options, callBase) {
                        callBase(options)
                    },
                    handleDataLoadedCore: function(options, callBase) {
                        callBase(options)
                    }
                }
        }());
        dataGrid.DataSourceAdapter = dataGrid.DataSourceAdapter.inherit(GroupingDataSourceAdapterExtender);
        var GroupingDataControllerExtender = function() {
                return {
                        init: function() {
                            var that = this;
                            that.callBase();
                            that.createAction("onRowExpanding");
                            that.createAction("onRowExpanded");
                            that.createAction("onRowCollapsing");
                            that.createAction("onRowCollapsed")
                        },
                        _processItems: function(items, changeType) {
                            var groupColumns = this._columnsController.getGroupColumns();
                            if (items.length && groupColumns.length)
                                items = this._processGroupItems(items, groupColumns.length);
                            return this.callBase(items, changeType)
                        },
                        _processItem: function(item, options) {
                            if (commonUtils.isDefined(item.groupIndex) && commonUtils.isString(item.rowType) && item.rowType.indexOf("group") === 0) {
                                item = this._processGroupItem(item, options);
                                options.dataIndex = 0
                            }
                            else
                                item = this.callBase.apply(this, arguments);
                            return item
                        },
                        _processGroupItem: function(item, options) {
                            return item
                        },
                        _processGroupItems: function(items, groupsCount, options) {
                            var that = this,
                                scrollingMode,
                                i,
                                item,
                                resultItems,
                                path;
                            if (!options) {
                                scrollingMode = that.option("scrolling.mode");
                                options = {
                                    collectContinuationItems: scrollingMode !== "virtual" && scrollingMode !== "infinite",
                                    resultItems: [],
                                    path: []
                                }
                            }
                            resultItems = options.resultItems;
                            path = options.path;
                            if (options.data)
                                if (options.collectContinuationItems || !options.data.isContinuation)
                                    resultItems.push({
                                        rowType: "group",
                                        data: options.data,
                                        groupIndex: path.length - 1,
                                        isExpanded: !!options.data.items,
                                        key: path,
                                        values: path
                                    });
                            if (items)
                                if (groupsCount === 0)
                                    resultItems.push.apply(resultItems, items);
                                else
                                    for (i = 0; i < items.length; i++) {
                                        item = items[i];
                                        if (item) {
                                            options.data = item;
                                            options.path = path.concat(item.key);
                                            that._processGroupItems(item.items, groupsCount - 1, options);
                                            options.data = undefined;
                                            options.path = path
                                        }
                                    }
                            return resultItems
                        },
                        publicMethods: function() {
                            return this.callBase().concat(["collapseAll", "expandAll", "isRowExpanded", "expandRow", "collapseRow"])
                        },
                        collapseAll: function(groupIndex) {
                            var dataSource = this._dataSource;
                            if (dataSource && dataSource.collapseAll(groupIndex)) {
                                dataSource.pageIndex(0);
                                dataSource.reload(true)
                            }
                        },
                        expandAll: function(groupIndex) {
                            var dataSource = this._dataSource;
                            if (dataSource && dataSource.expandAll(groupIndex)) {
                                dataSource.pageIndex(0);
                                dataSource.reload(true)
                            }
                        },
                        changeRowExpand: function(key) {
                            var that = this,
                                expanded = that.isRowExpanded(key),
                                args = {
                                    key: key,
                                    expanded: expanded
                                };
                            that.executeAction(expanded ? "onRowCollapsing" : "onRowExpanding", args);
                            if (!args.cancel)
                                return $.when(that._changeRowExpandCore(key)).done(function() {
                                        args.expanded = !expanded;
                                        that.executeAction(expanded ? "onRowCollapsed" : "onRowExpanded", args)
                                    })
                        },
                        _changeRowExpandCore: function(key) {
                            var that = this,
                                dataSource = this._dataSource,
                                d;
                            if (!dataSource)
                                return;
                            d = $.Deferred();
                            $.when(dataSource.changeRowExpand(key)).done(function() {
                                that.load().done(d.resolve).fail(d.reject)
                            }).fail(d.reject);
                            return d
                        },
                        isRowExpanded: function(key) {
                            var dataSource = this._dataSource;
                            return dataSource && dataSource.isRowExpanded(key)
                        },
                        expandRow: function(key) {
                            if (!this.isRowExpanded(key))
                                this.changeRowExpand(key)
                        },
                        collapseRow: function(key) {
                            if (this.isRowExpanded(key))
                                this.changeRowExpand(key)
                        },
                        optionChanged: function(args) {
                            if (args.name === "grouping")
                                args.name = "dataSource";
                            this.callBase(args)
                        }
                    }
            }();
        var GroupingHeaderPanelExtender = function() {
                return {
                        _renderGroupPanel: function() {
                            var that = this,
                                $element = that.element(),
                                groupPanelOptions = that.option("groupPanel"),
                                $groupPanel,
                                groupColumns = that.getController("columns").getGroupColumns();
                            $groupPanel = $element.find("." + DATAGRID_GROUP_PANEL_CLASS);
                            if (groupPanelOptions && groupPanelOptions.visible) {
                                if (!$groupPanel.length)
                                    $groupPanel = $("<div />").addClass(DATAGRID_GROUP_PANEL_CLASS).prependTo($element);
                                else
                                    $groupPanel.show();
                                that._renderGroupPanelItems($groupPanel, groupColumns);
                                if (groupPanelOptions.allowColumnDragging && !groupColumns.length)
                                    $("<div />").addClass(DATAGRID_GROUP_PANEL_MESSAGE_CLASS).text(groupPanelOptions.emptyPanelText).appendTo($groupPanel)
                            }
                            else
                                $groupPanel.hide()
                        },
                        _renderGroupPanelItems: function($groupPanel, groupColumns) {
                            var that = this;
                            $groupPanel.empty();
                            $.each(groupColumns, function(index, groupColumn) {
                                that._createGroupPanelItem($groupPanel, groupColumn)
                            })
                        },
                        _createGroupPanelItem: function($rootElement, groupColumn) {
                            return $("<div />").addClass(groupColumn.cssClass).addClass(DATAGRID_GROUP_PANEL_ITEM_CLASS).appendTo($rootElement).text(groupColumn.caption)
                        },
                        _renderCore: function() {
                            this.callBase.apply(this, arguments);
                            this._renderGroupPanel()
                        },
                        allowDragging: function(column) {
                            var groupPanelOptions = this.option("groupPanel");
                            return groupPanelOptions && groupPanelOptions.visible && groupPanelOptions.allowColumnDragging && column && column.allowGrouping
                        },
                        getColumnElements: function() {
                            var $element = this.element();
                            return $element && $element.find("." + DATAGRID_GROUP_PANEL_ITEM_CLASS)
                        },
                        getColumns: function() {
                            return this.getController("columns").getGroupColumns()
                        },
                        getBoundingRect: function() {
                            var that = this,
                                $element = that.element(),
                                offset;
                            if ($element && $element.find("." + DATAGRID_GROUP_PANEL_CLASS).length) {
                                offset = $element.offset();
                                return {
                                        top: offset.top,
                                        bottom: offset.top + $element.height()
                                    }
                            }
                            return null
                        },
                        getName: function() {
                            return "group"
                        },
                        isVisible: function() {
                            return this.callBase() || this.option("groupPanel.visible")
                        },
                        optionChanged: function(args) {
                            if (args.name === "groupPanel") {
                                this._renderGroupPanel();
                                args.handled = true
                            }
                            else
                                this.callBase(args)
                        }
                    }
            }();
        dataGrid.GroupingHeaderPanelExtender = GroupingHeaderPanelExtender;
        var GroupingRowsViewExtender = function() {
                return {
                        _rowClick: function(e) {
                            var that = this,
                                dataController = that.getController("data"),
                                $expandElement = $(e.jQueryEvent.target).closest("." + DATAGRID_EXPAND_CLASS),
                                key;
                            if ($expandElement.length) {
                                key = dataController.getKeyByRowIndex(e.rowIndex);
                                dataController.changeRowExpand(key);
                                e.jQueryEvent.preventDefault();
                                e.handled = true
                            }
                            that.callBase(e)
                        },
                        _getDefaultTemplate: function(column) {
                            var that = this;
                            if (column.command === "expand")
                                return function(container, options) {
                                        if (commonUtils.isDefined(options.value) && !(options.data && options.data.isContinuation) && !options.row.inserted) {
                                            container.addClass(DATAGRID_EXPAND_CLASS).addClass(DATAGRID_SELECTION_DISABLED_CLASS);
                                            $("<div>").addClass(options.value ? DATAGRID_GROUP_OPENED_CLASS : DATAGRID_GROUP_CLOSED_CLASS).appendTo(container);
                                            that.setAria("label", options.value ? that.localize("dxDataGrid-ariaCollapse") : that.localize("dxDataGrid-ariaExpand"), container)
                                        }
                                    };
                            return that.callBase(column)
                        }
                    }
            }();
        $.extend(dataGrid.__internals, {
            DATAGRID_GROUP_PANEL_CLASS: DATAGRID_GROUP_PANEL_CLASS,
            DATAGRID_GROUP_PANEL_MESSAGE_CLASS: DATAGRID_GROUP_PANEL_MESSAGE_CLASS,
            DATAGRID_GROUP_PANEL_ITEM_CLASS: DATAGRID_GROUP_PANEL_ITEM_CLASS,
            DATAGRID_GROUP_OPENED_CLASS: DATAGRID_GROUP_OPENED_CLASS,
            DATAGRID_GROUP_CLOSED_CLASS: DATAGRID_GROUP_CLOSED_CLASS,
            DATAGRID_EXPAND_CLASS: DATAGRID_EXPAND_CLASS,
            DATAGRID_SELECTION_DISABLED_CLASS: DATAGRID_SELECTION_DISABLED_CLASS
        });
        dataGrid.registerModule("grouping", {
            defaultOptions: function() {
                return {
                        grouping: {
                            autoExpandAll: true,
                            allowCollapsing: true,
                            groupContinuesMessage: Globalize.localize("dxDataGrid-groupContinuesMessage"),
                            groupContinuedMessage: Globalize.localize("dxDataGrid-groupContinuedMessage")
                        },
                        groupPanel: {
                            visible: false,
                            emptyPanelText: Globalize.localize("dxDataGrid-groupPanelEmptyText"),
                            allowColumnDragging: true
                        }
                    }
            },
            extenders: {
                controllers: {data: GroupingDataControllerExtender},
                views: {
                    headerPanel: GroupingHeaderPanelExtender,
                    rowsView: GroupingRowsViewExtender
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.grouping.server.js */
    (function($, DX) {
        var dataUtils = DX.data.utils,
            dataGrid = DX.ui.dxDataGrid,
            normalizeSortingInfo = dataGrid.normalizeSortingInfo,
            keysEqual = dataUtils.keysEqual;
        var loadTotalCount = function(store, options) {
                var d = $.Deferred(),
                    loadOptions = $.extend({
                        skip: 0,
                        take: 1,
                        requireTotalCount: true
                    }, options);
                store.load(loadOptions).done(function(data, extra) {
                    if (extra && isFinite(extra.totalCount))
                        d.resolve(extra.totalCount);
                    else
                        store.totalCount(options).done($.proxy(d.resolve, d)).fail($.proxy(d.reject, d))
                }).fail($.proxy(d.reject, d));
                return d
            };
        dataGrid.ExpandedGroupingHelper = dataGrid.GroupingHelper.inherit(function() {
            var foreachCollapsedGroups = function(that, callback, updateOffsets) {
                    return that.foreachGroups(function(groupInfo) {
                            if (!groupInfo.isExpanded)
                                return callback(groupInfo)
                        }, false, false, updateOffsets)
                };
            var correctSkipLoadOption = function(that, skip) {
                    var skipCorrection = 0,
                        resultSkip = skip || 0;
                    if (skip) {
                        foreachCollapsedGroups(that, function(groupInfo) {
                            if (groupInfo.offset - skipCorrection >= skip)
                                return false;
                            skipCorrection += groupInfo.count - 1
                        });
                        resultSkip += skipCorrection
                    }
                    return resultSkip
                };
            var processGroupItems = function(that, items, path, offset, skipFirstItem, take) {
                    var i,
                        item,
                        offsetInfo,
                        removeLastItemsCount = 0,
                        needRemoveFirstItem = false;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item.items !== undefined) {
                            path.push(item.key);
                            var groupInfo = that.findGroupInfo(path);
                            if (groupInfo && !groupInfo.isExpanded) {
                                item.collapsedItems = item.items;
                                item.items = null;
                                offset += groupInfo.count;
                                take--;
                                if (take < 0)
                                    removeLastItemsCount++;
                                if (skipFirstItem)
                                    needRemoveFirstItem = true
                            }
                            else if (item.items) {
                                offsetInfo = processGroupItems(that, item.items, path, offset, skipFirstItem, take);
                                if (skipFirstItem)
                                    if (offsetInfo.offset - offset > 1)
                                        item.isContinuation = true;
                                    else
                                        needRemoveFirstItem = true;
                                offset = offsetInfo.offset;
                                take = offsetInfo.take;
                                if (take < 0)
                                    if (item.items.length)
                                        item.isContinuationOnNextPage = true;
                                    else
                                        removeLastItemsCount++
                            }
                            path.pop()
                        }
                        else {
                            if (skipFirstItem)
                                needRemoveFirstItem = true;
                            offset++;
                            take--;
                            if (take < 0)
                                removeLastItemsCount++
                        }
                        skipFirstItem = false
                    }
                    if (needRemoveFirstItem)
                        items.splice(0, 1);
                    if (removeLastItemsCount)
                        items.splice(-removeLastItemsCount, removeLastItemsCount);
                    return {
                            offset: offset,
                            take: take
                        }
                };
            var pathEquals = function(path1, path2) {
                    var i;
                    if (path1.length !== path2.length)
                        return false;
                    for (i = 0; i < path1.length; i++)
                        if (!keysEqual(null, path1[i], path2[i]))
                            return false;
                    return true
                };
            var updateGroupOffsets = function(that, items, path, offset, additionalGroupInfo) {
                    var i,
                        item;
                    if (!items)
                        return;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if ("key" in item && item.items !== undefined) {
                            path.push(item.key);
                            if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation)
                                additionalGroupInfo.offset = offset;
                            var groupInfo = that.findGroupInfo(path);
                            if (groupInfo && !groupInfo.isExpanded) {
                                if (!item.isContinuation) {
                                    groupInfo.offset = offset;
                                    offset += groupInfo.count
                                }
                            }
                            else
                                offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo);
                            path.pop()
                        }
                        else
                            offset++
                    }
                    return offset
                };
            var removeGroupLoadOption = function(storeLoadOptions, loadOptions) {
                    var groups,
                        sorts;
                    if (loadOptions.group) {
                        groups = normalizeSortingInfo(loadOptions.group);
                        sorts = normalizeSortingInfo(storeLoadOptions.sort);
                        storeLoadOptions.sort = dataUtils.arrangeSortingInfo(groups, sorts);
                        delete loadOptions.group
                    }
                };
            var createGroupFilter = dataGrid.createGroupFilter = function(path, storeLoadOptions) {
                    var groups = normalizeSortingInfo(storeLoadOptions.group),
                        i,
                        filter = [];
                    for (i = 0; i < path.length; i++)
                        filter.push([groups[i].selector, "=", path[i]]);
                    if (storeLoadOptions.filter)
                        filter.push(storeLoadOptions.filter);
                    return dataGrid.combineFilters(filter)
                };
            var createNotGroupFilter = function(path, storeLoadOptions, group) {
                    var groups = normalizeSortingInfo(group || storeLoadOptions.group),
                        i,
                        j,
                        filterElement,
                        filter = [];
                    for (i = 0; i < path.length; i++) {
                        filterElement = [];
                        for (j = 0; j <= i; j++)
                            filterElement.push([groups[j].selector, i === j ? "<>" : "=", path[j]]);
                        filter.push(dataGrid.combineFilters(filterElement))
                    }
                    filter = dataGrid.combineFilters(filter, "or");
                    return dataGrid.combineFilters([filter, storeLoadOptions.filter])
                };
            var createOffsetFilter = function(path, storeLoadOptions) {
                    var groups = normalizeSortingInfo(storeLoadOptions.group),
                        i,
                        j,
                        filterElement,
                        filter = [];
                    for (i = 0; i < path.length; i++) {
                        filterElement = [];
                        for (j = 0; j <= i; j++)
                            filterElement.push([groups[j].selector, i === j ? groups[j].desc ? ">" : "<" : "=", path[j]]);
                        filter.push(dataGrid.combineFilters(filterElement))
                    }
                    filter = dataGrid.combineFilters(filter, "or");
                    return dataGrid.combineFilters([filter, storeLoadOptions.filter])
                };
            return {
                    handleDataLoading: function(options, callBase) {
                        callBase(options);
                        var that = this,
                            storeLoadOptions = options.storeLoadOptions,
                            loadOptions,
                            collapsedPaths = [],
                            collapsedItemsCount = 0,
                            skipFirstItem = false,
                            take,
                            group = options.loadOptions.group,
                            skipCorrection = 0;
                        removeGroupLoadOption(storeLoadOptions, options.loadOptions);
                        options.group = options.group || group;
                        if (storeLoadOptions.isLoadingAll)
                            return;
                        loadOptions = $.extend({}, storeLoadOptions);
                        loadOptions.skip = correctSkipLoadOption(that, storeLoadOptions.skip);
                        if (loadOptions.skip && loadOptions.take && group) {
                            loadOptions.skip--;
                            loadOptions.take++;
                            skipFirstItem = true
                        }
                        if (loadOptions.take && group) {
                            take = loadOptions.take;
                            loadOptions.take++
                        }
                        foreachCollapsedGroups(that, function(groupInfo) {
                            if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection)
                                return false;
                            else if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {
                                skipCorrection += groupInfo.count - 1;
                                collapsedPaths.push(groupInfo.path);
                                collapsedItemsCount += groupInfo.count
                            }
                        });
                        $.each(collapsedPaths, function() {
                            loadOptions.filter = createNotGroupFilter(this, loadOptions, group)
                        });
                        options.storeLoadOptions = loadOptions;
                        options.collapsedPaths = collapsedPaths;
                        options.collapsedItemsCount = collapsedItemsCount;
                        options.skip = loadOptions.skip || 0;
                        options.skipFirstItem = skipFirstItem;
                        options.take = take
                    },
                    handleDataLoaded: function(options, callBase) {
                        var that = this,
                            data = options.data,
                            pathIndex,
                            query,
                            collapsedPaths = options.collapsedPaths,
                            groups = normalizeSortingInfo(options.group),
                            groupCount = groups.length;
                        function appendCollapsedPath(data, path, groups) {
                            if (!data || !path.length || !groups.length)
                                return;
                            var i,
                                keyValue,
                                pathValue = dataUtils.toComparable(path[0], true);
                            for (i = 0; i < data.length; i++) {
                                keyValue = dataUtils.toComparable(data[i].key, true);
                                if (groups[0].desc ? pathValue >= keyValue : pathValue <= keyValue)
                                    break
                            }
                            if (!data.length || pathValue !== keyValue)
                                data.splice(i, 0, {
                                    key: path[0],
                                    items: []
                                });
                            appendCollapsedPath(data[i].items, path.slice(1), groups.slice(1))
                        }
                        callBase(options);
                        if (groupCount) {
                            query = DX.data.query(data);
                            DX.data.utils.multiLevelGroup(query, groups).enumerate().done(function(groupedData) {
                                data = groupedData
                            });
                            if (collapsedPaths)
                                for (pathIndex = 0; pathIndex < collapsedPaths.length; pathIndex++)
                                    appendCollapsedPath(data, collapsedPaths[pathIndex], groups);
                            if (!options.storeLoadOptions.isLoadingAll) {
                                processGroupItems(that, data, [], options.skip, options.skipFirstItem, options.take);
                                that.updateItemsCount(data, groupCount)
                            }
                            options.data = data;
                            if (options.collapsedItemsCount && options.extra && options.extra.totalCount >= 0)
                                options.extra.totalCount += options.collapsedItemsCount
                        }
                    },
                    updateTotalItemsCount: function() {
                        var itemsCountCorrection = 0;
                        foreachCollapsedGroups(this, function(groupInfo) {
                            if (groupInfo.count)
                                itemsCountCorrection -= groupInfo.count - 1
                        });
                        this.callBase(itemsCountCorrection)
                    },
                    changeRowExpand: function(path) {
                        var that = this,
                            dataSource = that._dataSource,
                            beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex(),
                            dataSourceItems = dataSource.items(),
                            offset = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize()),
                            groupInfo = that.findGroupInfo(path),
                            groupCountQuery;
                        if (groupInfo && !groupInfo.isExpanded)
                            groupCountQuery = $.Deferred().resolve(groupInfo.count);
                        else
                            groupCountQuery = loadTotalCount(dataSource.store(), {filter: createGroupFilter(path, {
                                    filter: dataSource.filter(),
                                    group: dataSource.group()
                                })});
                        return $.when(groupCountQuery).done(function(count) {
                                count = parseInt(count.length ? count[0] : count);
                                if (groupInfo) {
                                    updateGroupOffsets(that, dataSourceItems, [], offset);
                                    groupInfo.isExpanded = !groupInfo.isExpanded;
                                    groupInfo.count = count
                                }
                                else {
                                    groupInfo = {
                                        offset: -1,
                                        count: count,
                                        path: path,
                                        isExpanded: false
                                    };
                                    updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);
                                    if (groupInfo.offset >= 0)
                                        that.addGroupInfo(groupInfo)
                                }
                                that.updateTotalItemsCount()
                            }).fail(function() {
                                dataSource.fireEvent("loadError", arguments)
                            })
                    },
                    allowCollapseAll: function() {
                        return false
                    },
                    refresh: function(storeLoadOptions, isReload, operationTypes) {
                        var that = this,
                            dataSource = that._dataSource,
                            store = dataSource.store();
                        this.callBase.apply(this, arguments);
                        if (isReload || operationTypes.reload)
                            return foreachCollapsedGroups(that, function(groupInfo) {
                                    var groupCountQuery = loadTotalCount(store, {filter: createGroupFilter(groupInfo.path, storeLoadOptions)}),
                                        groupOffsetQuery = loadTotalCount(store, {filter: createOffsetFilter(groupInfo.path, storeLoadOptions)});
                                    dataSource._changeLoadingCount(1);
                                    return $.when(groupOffsetQuery, groupCountQuery).done(function(offset, count) {
                                            offset = parseInt(offset.length ? offset[0] : offset);
                                            count = parseInt(count.length ? count[0] : count);
                                            groupInfo.offset = offset;
                                            if (groupInfo.count !== count) {
                                                groupInfo.count = count;
                                                that.updateTotalItemsCount()
                                            }
                                        }).fail(function() {
                                            dataSource.fireEvent("loadError", arguments)
                                        }).always(function() {
                                            dataSource._changeLoadingCount(-1)
                                        })
                                }, true)
                    }
                }
        }());
        $.extend(DX.ui.dxDataGrid.__internals, {loadTotalCount: loadTotalCount})
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.grouping.client.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            normalizeSortingInfo = dataGrid.normalizeSortingInfo;
        dataGrid.CollapsedGroupingHelper = dataGrid.GroupingHelper.inherit(function() {
            var foreachExpandedGroups = function(that, callback) {
                    return that.foreachGroups(function(groupInfo, parents) {
                            if (groupInfo.isExpanded)
                                return callback(groupInfo, parents)
                        }, true)
                };
            var processGroupItems = function(that, items, groupsCount, expandedInfo, path) {
                    var i,
                        item;
                    expandedInfo.items = expandedInfo.items || [];
                    expandedInfo.paths = expandedInfo.paths || [];
                    expandedInfo.count = expandedInfo.count || 0;
                    expandedInfo.lastCount = expandedInfo.lastCount || 0;
                    if (!groupsCount)
                        return;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item.items !== undefined) {
                            path.push(item.key);
                            var groupInfo = that.findGroupInfo(path);
                            if (!groupInfo || !groupInfo.isExpanded) {
                                item.collapsedItems = item.items;
                                item.items = null
                            }
                            else if (item.items)
                                processGroupItems(that, item.items, groupsCount - 1, expandedInfo, path);
                            else if (groupInfo && groupInfo.isExpanded && groupsCount === 1 && item.count) {
                                expandedInfo.items.push(item);
                                expandedInfo.paths.push(path.slice(0));
                                expandedInfo.count += expandedInfo.lastCount;
                                expandedInfo.lastCount = item.count
                            }
                            path.pop()
                        }
                    }
                };
            var updateGroupInfos = function(that, items, groupsCount, offset) {
                    return updateGroupInfosCore(that, items, 0, groupsCount, [], offset)
                };
            var updateGroupInfosCore = function(that, items, groupIndex, groupsCount, path, offset) {
                    var item,
                        totalCount = 0,
                        i,
                        groupInfo;
                    if (groupIndex >= groupsCount)
                        return items.length;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item) {
                            path.push(item.key);
                            groupInfo = that.findGroupInfo(path);
                            if (!groupInfo)
                                that.addGroupInfo({
                                    isExpanded: that._isGroupExpanded(groupIndex),
                                    path: path.slice(0),
                                    offset: offset + i,
                                    count: item.count > 0 ? item.count : item.items.length
                                });
                            else {
                                groupInfo.count = item.count > 0 ? item.count : item.items.length;
                                groupInfo.offset = offset + i
                            }
                            totalCount += item.items || !item.count ? updateGroupInfosCore(that, item.items, groupIndex + 1, groupsCount, path, 0) : item.count;
                            path.pop()
                        }
                    }
                    return totalCount
                };
            var isGroupExpanded = function(groups, groupIndex) {
                    return groups && groups.length && groups[groupIndex] && !!groups[groupIndex].isExpanded
                };
            var getTotalOffset = function(groupInfos, pageSize, offset) {
                    var groupIndex,
                        groupSize,
                        totalOffset = offset;
                    for (groupIndex = 0; groupIndex < groupInfos.length; groupIndex++) {
                        groupSize = groupInfos[groupIndex].offset + 1;
                        if (groupIndex > 0) {
                            groupSize += groupInfos[groupIndex - 1].childrenTotalCount;
                            if (pageSize)
                                groupSize += getContinuationGroupCount(totalOffset, pageSize, groupSize, groupIndex - 1) * groupIndex
                        }
                        totalOffset += groupSize
                    }
                    return totalOffset
                };
            var getContinuationGroupCount = function(groupOffset, pageSize, groupSize, groupIndex) {
                    groupIndex = groupIndex || 0;
                    if (pageSize > 1 && groupSize > 0) {
                        var pageOffset = groupOffset - Math.floor(groupOffset / pageSize) * pageSize || pageSize;
                        pageOffset += groupSize - groupIndex - 2;
                        if (pageOffset < 0)
                            pageOffset += pageSize;
                        return Math.floor(pageOffset / (pageSize - groupIndex - 1))
                    }
                    return 0
                };
            DX.ui.dxDataGrid.getContinuationGroupCount = getContinuationGroupCount;
            return {
                    updateTotalItemsCount: function(options) {
                        var totalItemsCount = 0,
                            totalCount = options.extra && options.extra.totalCount || 0,
                            totalGroupCount = options.extra && options.extra.totalGroupCount || 0,
                            pageSize = this._dataSource.pageSize(),
                            isVirtualPaging = this._isVirtualPaging();
                        foreachExpandedGroups(this, function(groupInfo, parents) {
                            groupInfo.childrenTotalCount = 0
                        });
                        foreachExpandedGroups(this, function(groupInfo, parents) {
                            var totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, totalItemsCount),
                                count = groupInfo.count + groupInfo.childrenTotalCount;
                            if (!isVirtualPaging)
                                count += getContinuationGroupCount(totalOffset, pageSize, count, parents.length - 1);
                            if (parents[parents.length - 2])
                                parents[parents.length - 2].childrenTotalCount += count;
                            else
                                totalItemsCount += count
                        });
                        this.callBase(totalItemsCount - totalCount + totalGroupCount)
                    },
                    _isGroupExpanded: function(groupIndex) {
                        var groups = this._dataSource.group();
                        return isGroupExpanded(groups, groupIndex)
                    },
                    _updatePagingOptions: function(options) {
                        var that = this,
                            isVirtualPaging = that._isVirtualPaging(),
                            pageSize = that._dataSource.pageSize(),
                            skips = [],
                            takes = [],
                            skipChildrenTotalCount = 0,
                            childrenTotalCount = 0;
                        if (options.take) {
                            foreachExpandedGroups(this, function(groupInfo) {
                                groupInfo.childrenTotalCount = 0;
                                groupInfo.skipChildrenTotalCount = 0
                            });
                            foreachExpandedGroups(that, function(groupInfo, parents) {
                                var skip,
                                    take,
                                    takeCorrection = 0,
                                    parentTakeCorrection = 0,
                                    totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, childrenTotalCount),
                                    continuationGroupCount = 0,
                                    skipContinuationGroupCount = 0,
                                    groupInfoCount = groupInfo.count + groupInfo.childrenTotalCount,
                                    childrenGroupInfoCount = groupInfoCount;
                                skip = options.skip - totalOffset;
                                if (totalOffset <= options.skip + options.take && groupInfoCount) {
                                    take = options.take;
                                    if (!isVirtualPaging) {
                                        continuationGroupCount = getContinuationGroupCount(totalOffset, pageSize, groupInfoCount, parents.length - 1);
                                        groupInfoCount += continuationGroupCount * parents.length;
                                        childrenGroupInfoCount += continuationGroupCount;
                                        if (pageSize && skip >= 0) {
                                            takeCorrection = parents.length;
                                            parentTakeCorrection = parents.length - 1;
                                            skipContinuationGroupCount = Math.floor(skip / pageSize)
                                        }
                                    }
                                    if (skip >= 0) {
                                        if (totalOffset + groupInfoCount > options.skip)
                                            skips.unshift(skip - skipContinuationGroupCount * takeCorrection - groupInfo.skipChildrenTotalCount);
                                        if (totalOffset + groupInfoCount >= options.skip + take)
                                            takes.unshift(take - takeCorrection - groupInfo.childrenTotalCount + groupInfo.skipChildrenTotalCount)
                                    }
                                    else if (totalOffset + groupInfoCount >= options.skip + take)
                                        takes.unshift(take + skip - groupInfo.childrenTotalCount)
                                }
                                if (totalOffset <= options.skip)
                                    if (parents[parents.length - 2])
                                        parents[parents.length - 2].skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1 - skipContinuationGroupCount * parentTakeCorrection);
                                    else
                                        skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1);
                                if (totalOffset <= options.skip + take) {
                                    groupInfoCount = Math.min(childrenGroupInfoCount, skip + take - (skipContinuationGroupCount + 1) * parentTakeCorrection);
                                    if (parents[parents.length - 2])
                                        parents[parents.length - 2].childrenTotalCount += groupInfoCount;
                                    else
                                        childrenTotalCount += groupInfoCount
                                }
                            });
                            options.skip -= skipChildrenTotalCount;
                            options.take -= childrenTotalCount - skipChildrenTotalCount
                        }
                        options.skips = skips;
                        options.takes = takes
                    },
                    changeRowExpand: function(path) {
                        var that = this,
                            groupInfo = that.findGroupInfo(path);
                        if (groupInfo) {
                            groupInfo.isExpanded = !groupInfo.isExpanded;
                            return $.Deferred().resolve()
                        }
                        return $.Deferred().reject()
                    },
                    handleDataLoadedCore: function(options, callBase) {
                        var that = this,
                            groupCount = normalizeSortingInfo(options.storeLoadOptions.group || options.loadOptions.group).length,
                            totalCount;
                        if (options.storeLoadOptions.isLoadingAll) {
                            callBase(options);
                            return
                        }
                        totalCount = updateGroupInfos(that, options.data, groupCount, 0);
                        if (!options.remoteOperations.paging)
                            if (groupCount && options.extra) {
                                options.extra.totalCount = totalCount;
                                options.extra.totalGroupCount = options.data.length
                            }
                        that.updateTotalItemsCount(options);
                        that._updatePagingOptions(options);
                        callBase(options);
                        that._processPaging(options, groupCount);
                        var expandedInfo = {};
                        processGroupItems(that, options.data, groupCount, expandedInfo, []);
                        expandedInfo.skip = options.skips[groupCount - 1];
                        if (options.takes[groupCount - 1] !== undefined) {
                            expandedInfo.take = expandedInfo.count ? expandedInfo.count - (expandedInfo.skip || 0) : 0;
                            expandedInfo.take += options.takes[groupCount - 1]
                        }
                        var data = options.data;
                        if (expandedInfo.paths.length && options.storeLoadOptions.group) {
                            var expandedFilters = [];
                            $.each(expandedInfo.paths, function(_, expandedPath) {
                                expandedFilters.push(dataGrid.createGroupFilter(expandedPath, {group: options.storeLoadOptions.group}))
                            });
                            var filter = dataGrid.combineFilters(expandedFilters, "or");
                            filter = dataGrid.combineFilters([options.storeLoadOptions.filter, filter]);
                            options.data = $.Deferred();
                            $.when(expandedInfo.take === 0 ? [] : that._dataSource.store().load({
                                filter: filter,
                                sort: options.storeLoadOptions.sort,
                                skip: expandedInfo.skip,
                                take: expandedInfo.take
                            })).done(function(items) {
                                $.each(expandedInfo.items, function(index, item) {
                                    DX.data.query(items).filter(expandedFilters[index]).enumerate().done(function(expandedItems) {
                                        item.items = expandedItems
                                    })
                                });
                                options.data.resolve(data)
                            }).fail(options.data.reject)
                        }
                        that.updateItemsCount(data, groupCount)
                    },
                    _processPaging: function(options, groupCount) {
                        var skips,
                            takes,
                            i,
                            item,
                            items;
                        skips = options.skips;
                        takes = options.takes;
                        items = options.data;
                        for (i = 0; items && i < groupCount; i++) {
                            item = items[0];
                            items = item && item.items;
                            if (skips[i] !== undefined) {
                                item.isContinuation = true;
                                if (items) {
                                    items = items.slice(skips[i]);
                                    item.items = items
                                }
                            }
                        }
                        items = options.data;
                        for (i = 0; items && i < groupCount; i++) {
                            item = items[items.length - 1];
                            items = item && item.items;
                            if (item) {
                                var maxTakeCount = item.count - (item.isContinuation && skips[i] || 0) || items.length;
                                if (takes[i] !== undefined && maxTakeCount > takes[i]) {
                                    item.isContinuationOnNextPage = true;
                                    if (items) {
                                        items = items.slice(0, takes[i]);
                                        item.items = items
                                    }
                                }
                            }
                        }
                    },
                    refresh: function(storeLoadOptions) {
                        var that = this,
                            oldGroups = normalizeSortingInfo(that._group),
                            isExpanded,
                            groupIndex;
                        function handleGroup(groupInfo, parents) {
                            if (parents.length === groupIndex + 1)
                                groupInfo.isExpanded = isExpanded
                        }
                        for (groupIndex = 0; groupIndex < oldGroups.length; groupIndex++) {
                            isExpanded = isGroupExpanded(storeLoadOptions.group, groupIndex);
                            if (isGroupExpanded(that._group, groupIndex) !== isExpanded)
                                that.foreachGroups(handleGroup)
                        }
                        that.callBase.apply(this, arguments);
                        that.foreachGroups(function(groupInfo) {
                            groupInfo.count = 0
                        })
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.masterDetailModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            DATAGRID_MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
            DATAGRID_MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row",
            DATAGRID_ROW_LINES_CLASS = "dx-row-lines";
        $.extend(dataGrid.__internals, {
            DATAGRID_MASTER_DETAIL_CELL_CLASS: DATAGRID_MASTER_DETAIL_CELL_CLASS,
            DATAGRID_MASTER_DETAIL_ROW_CLASS: DATAGRID_MASTER_DETAIL_ROW_CLASS,
            DATAGRID_ROW_LINES_CLASS: DATAGRID_ROW_LINES_CLASS
        });
        dataGrid.registerModule("masterDetail", {
            defaultOptions: function() {
                return {masterDetail: {
                            enabled: false,
                            autoExpandAll: false,
                            template: null
                        }}
            },
            extenders: {
                controllers: {
                    editorFactory: {focus: function($element, hideBorder) {
                            if ($element && $element.hasClass(DATAGRID_MASTER_DETAIL_CELL_CLASS))
                                this.loseFocus();
                            else
                                return this.callBase($element, hideBorder)
                        }},
                    columns: {_getExpandColumnsCore: function() {
                            var expandColumns = this.callBase();
                            if (this.option("masterDetail.enabled"))
                                expandColumns.push({});
                            return expandColumns
                        }},
                    data: function() {
                        var initMasterDetail = function(that) {
                                that._expandedItems = [];
                                that._isExpandAll = that.option("masterDetail.autoExpandAll")
                            };
                        return {
                                init: function() {
                                    var that = this;
                                    initMasterDetail(that);
                                    that.callBase()
                                },
                                expandAll: function(groupIndex) {
                                    var that = this;
                                    if (groupIndex < 0) {
                                        that._isExpandAll = true;
                                        that._expandedItems = [];
                                        that.updateItems()
                                    }
                                    else
                                        that.callBase.apply(that, arguments)
                                },
                                collapseAll: function(groupIndex) {
                                    var that = this;
                                    if (groupIndex < 0) {
                                        that._isExpandAll = false;
                                        that._expandedItems = [];
                                        that.updateItems()
                                    }
                                    else
                                        that.callBase.apply(that, arguments)
                                },
                                isRowExpanded: function(key) {
                                    var that = this,
                                        expandIndex = dataGrid.getIndexByKey(key, that._expandedItems);
                                    if (commonUtils.isArray(key))
                                        return that.callBase.apply(that, arguments);
                                    else
                                        return !!(that._isExpandAll ^ (expandIndex >= 0 && that._expandedItems[expandIndex].visible))
                                },
                                _changeRowExpandCore: function(key) {
                                    var that = this,
                                        expandIndex,
                                        rowIndex;
                                    if (commonUtils.isArray(key))
                                        return that.callBase.apply(that, arguments);
                                    else {
                                        expandIndex = dataGrid.getIndexByKey(key, that._expandedItems);
                                        if (expandIndex >= 0) {
                                            var visible = that._expandedItems[expandIndex].visible;
                                            that._expandedItems[expandIndex].visible = !visible
                                        }
                                        else
                                            that._expandedItems.push({
                                                key: key,
                                                visible: true
                                            });
                                        rowIndex = that.getRowIndexByKey(key);
                                        that.updateItems({
                                            changeType: "update",
                                            rowIndices: [rowIndex, rowIndex + 1]
                                        })
                                    }
                                },
                                _processDataItem: function(data, options) {
                                    var that = this,
                                        dataItem = that.callBase.apply(that, arguments);
                                    dataItem.isExpanded = that.isRowExpanded(dataItem.key);
                                    if (options.detailColumnIndex === undefined) {
                                        options.detailColumnIndex = -1;
                                        $.each(options.visibleColumns, function(index, column) {
                                            if (column.command === "expand" && !commonUtils.isDefined(column.groupIndex)) {
                                                options.detailColumnIndex = index;
                                                return false
                                            }
                                        })
                                    }
                                    if (options.detailColumnIndex >= 0)
                                        dataItem.values[options.detailColumnIndex] = dataItem.isExpanded;
                                    return dataItem
                                },
                                _processItems: function(items, changeType) {
                                    var that = this,
                                        expandIndex,
                                        result = [];
                                    items = that.callBase.apply(that, arguments);
                                    if (this._isLoadingAll)
                                        return items;
                                    if (changeType === "refresh")
                                        that._expandedItems = $.grep(that._expandedItems, function(item) {
                                            return item.visible
                                        });
                                    $.each(items, function(index, item) {
                                        result.push(item);
                                        expandIndex = dataGrid.getIndexByKey(item.key, that._expandedItems);
                                        if (item.rowType === "data" && (item.isExpanded || expandIndex >= 0) && !item.inserted)
                                            result.push({
                                                visible: item.isExpanded,
                                                rowType: "detail",
                                                key: item.key,
                                                data: item.data,
                                                values: []
                                            })
                                    });
                                    return result
                                },
                                optionChanged: function(args) {
                                    var that = this,
                                        value,
                                        previousValue,
                                        isEnabledChanged,
                                        isAutoExpandAllChanged;
                                    if (args.name === "masterDetail") {
                                        args.name = "dataSource";
                                        switch (args.fullName) {
                                            case"masterDetail":
                                                value = args.value || {};
                                                previousValue = args.previousValue || {};
                                                isEnabledChanged = value.enabled !== previousValue.enabled;
                                                isAutoExpandAllChanged = value.autoExpandAll !== previousValue.autoExpandAll;
                                                break;
                                            case"masterDetail.enabled":
                                                isEnabledChanged = true;
                                                break;
                                            case"masterDetail.autoExpandAll":
                                                isAutoExpandAllChanged = true;
                                                break
                                        }
                                        if (isEnabledChanged || isAutoExpandAllChanged)
                                            initMasterDetail(that)
                                    }
                                    that.callBase(args)
                                },
                                refresh: function() {
                                    var that = this;
                                    initMasterDetail(that);
                                    return that.callBase.apply(that, arguments)
                                }
                            }
                    }()
                },
                views: {rowsView: function() {
                        return {
                                _getColumnTemplate: function(options) {
                                    var that = this,
                                        column = options.column,
                                        template;
                                    if (column.command === "detail")
                                        template = that.option("masterDetail.template") || that._getDefaultTemplate(column);
                                    else
                                        template = that.callBase.apply(that, arguments);
                                    return template
                                },
                                _createRow: function(row) {
                                    var $row = this.callBase(row);
                                    if (row && row.rowType === "detail") {
                                        this.option("showRowLines") && $row.addClass(DATAGRID_ROW_LINES_CLASS);
                                        $row.addClass(DATAGRID_MASTER_DETAIL_ROW_CLASS).toggle(row.visible)
                                    }
                                    return $row
                                },
                                _getGroupCellOptions: function(options) {
                                    var row = options.row,
                                        groupColumns = this._columnsController.getGroupColumns(),
                                        columnIndex = groupColumns.length + options.columnsCountBeforeGroups,
                                        emptyCellsCount = columnIndex + Number(this.option("masterDetail.enabled"));
                                    if (row && row.rowType === "detail")
                                        return {
                                                columnIndex: columnIndex,
                                                emptyCellsCount: emptyCellsCount,
                                                colspan: options.columns.length - emptyCellsCount
                                            };
                                    return this.callBase(options)
                                },
                                _renderCells: function($row, options) {
                                    var row = options.row,
                                        $detailCell,
                                        groupCellOptions,
                                        i;
                                    if (row.rowType === "detail") {
                                        groupCellOptions = this._getGroupCellOptions(options);
                                        for (i = 0; i < groupCellOptions.emptyCellsCount; i++)
                                            this._renderCell($row, {
                                                value: null,
                                                row: row,
                                                rowIndex: row.rowIndex,
                                                column: options.columns[i]
                                            });
                                        $detailCell = this._renderCell($row, {
                                            value: null,
                                            row: row,
                                            rowIndex: row.rowIndex,
                                            column: {command: "detail"},
                                            columnIndex: groupCellOptions.columnIndex
                                        });
                                        $detailCell.addClass(DATAGRID_MASTER_DETAIL_CELL_CLASS).attr("colspan", groupCellOptions.colspan)
                                    }
                                    else
                                        this.callBase.apply(this, arguments)
                                }
                            }
                    }()}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.editing.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            addNamespace = eventUtils.addNamespace,
            objectUtils = DX.require("/utils/utils.object"),
            commonUtils = DX.require("/utils/utils.common"),
            dialog = DX.require("/ui/ui.dialog"),
            Button = DX.require("/ui/widgets/ui.button"),
            errors = DevExpress.require("/ui/ui.errors"),
            getIndexByKey = dataGrid.getIndexByKey;
        var DATAGRID_LINK_CLASS = "dx-link",
            DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
            DATAGRID_ROW_SELECTED = "dx-selection",
            DATAGRID_EDIT_ROW = "dx-edit-row",
            DATAGRID_EDIT_FORM_CLASS = "dx-datagrid-edit-form",
            DATAGRID_EDIT_BUTTON_CLASS = "dx-edit-button",
            DATAGRID_INSERT_INDEX = "__DX_INSERT_INDEX__",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_ROW_REMOVED = "dx-row-removed",
            DATAGRID_ROW_INSERTED = "dx-row-inserted",
            DATAGRID_ROW_MODIFIED = "dx-row-modified",
            DATAGRID_CELL_MODIFIED = "dx-cell-modified",
            DATAGRID_CELL_HIGHLIGHT_OUTLINE = "dx-highlight-outline",
            DATAGRID_EDITING_NAMESPACE = "dxDataGridEditing",
            DATAGRID_FOCUS_OVERLAY_CLASS = "dx-datagrid-focus-overlay",
            DATAGRID_READONLY_CLASS = "dx-datagrid-readonly",
            DATAGRID_DATA_ROW_CLASS = "dx-data-row",
            CHECKBOX_CLASS = "dx-checkbox",
            DATAGRID_EDITOR_INLINE_BLOCK = "dx-editor-inline-block",
            DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
            DATAGRID_EDIT_MODE_BATCH = "batch",
            DATAGRID_EDIT_MODE_ROW = "row",
            DATAGRID_EDIT_MODE_CELL = "cell",
            DATAGRID_EDIT_MODE_FORM = "form",
            DATA_EDIT_DATA_INSERT_TYPE = "insert",
            DATA_EDIT_DATA_UPDATE_TYPE = "update",
            DATA_EDIT_DATA_REMOVE_TYPE = "remove",
            DATAGRID_POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
            DATAGRID_POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target";
        var getEditMode = function(that) {
                var editMode = that.option("editing.mode");
                if (editMode === DATAGRID_EDIT_MODE_BATCH || editMode === DATAGRID_EDIT_MODE_CELL || editMode === DATAGRID_EDIT_MODE_FORM)
                    return editMode;
                return DATAGRID_EDIT_MODE_ROW
            };
        var isRowEditMode = function(that) {
                var editMode = getEditMode(that);
                return editMode === DATAGRID_EDIT_MODE_ROW || editMode === DATAGRID_EDIT_MODE_FORM
            };
        dataGrid.EditingController = dataGrid.ViewController.inherit(function() {
            var getDefaultEditorTemplate = function(that) {
                    return function(container, options) {
                            var $editor = $("<div/>").appendTo(container);
                            that.getController("editorFactory").createEditor($editor, $.extend({}, options.column, {
                                value: options.value,
                                setValue: options.setValue,
                                row: options.row,
                                parentType: "dataRow",
                                width: null,
                                readOnly: !options.setValue
                            }))
                        }
                };
            return {
                    init: function() {
                        var that = this;
                        that._insertIndex = 1;
                        that._editRowIndex = -1;
                        that._editData = [];
                        that._editColumnIndex = -1;
                        that._columnsController = that.getController("columns");
                        that._dataController = that.getController("data");
                        if (!that._dataChangedHandler) {
                            that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
                            that._dataController.changed.add(that._dataChangedHandler)
                        }
                        if (!that._saveEditorHandler) {
                            that.createAction("onInitNewRow", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onRowInserting", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onRowInserted", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onEditingStart", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onRowUpdating", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onRowUpdated", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onRowRemoving", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onRowRemoved", {excludeValidators: ["disabled", "readOnly"]});
                            that._saveEditorHandler = that.createAction(function(e) {
                                var event = e.jQueryEvent,
                                    visibleColumns,
                                    isEditorPopup,
                                    isDomElement,
                                    isFocusOverlay,
                                    $targetCell,
                                    allowEditing,
                                    columnIndex,
                                    isDataRow,
                                    rowIndex;
                                if (!isRowEditMode(that) && that.isEditing() && !that._editCellInProgress) {
                                    isEditorPopup = $(event.target).closest(".dx-dropdowneditor-overlay").length;
                                    isDomElement = $(event.target).closest(document).length;
                                    isFocusOverlay = $(event.target).hasClass(DATAGRID_FOCUS_OVERLAY_CLASS);
                                    isDataRow = $(event.target).closest("." + DATAGRID_DATA_ROW_CLASS).length;
                                    visibleColumns = that._columnsController.getVisibleColumns();
                                    $targetCell = $(event.target).closest("." + DATAGRID_ROW_CLASS + "> td");
                                    columnIndex = $targetCell[0] && $targetCell[0].cellIndex;
                                    rowIndex = that.getView("rowsView").getRowIndex($targetCell.parent());
                                    allowEditing = visibleColumns[columnIndex] && visibleColumns[columnIndex].allowEditing;
                                    if ((!isDataRow || isDataRow && !allowEditing && !that.isEditCell(rowIndex, columnIndex)) && !isEditorPopup && !isFocusOverlay && isDomElement)
                                        that.closeEditCell()
                                }
                            });
                            $(document).on("dxclick", that._saveEditorHandler)
                        }
                        that._updateEditColumn();
                        that._updateEditButtons()
                    },
                    _handleDataChanged: function(args) {
                        if (this.option("scrolling.mode") === "standard")
                            this.resetRowAndPageIndeces();
                        if (args.changeType === "prepend")
                            $.each(this._editData, function(_, editData) {
                                editData.rowIndex += args.items.length;
                                if (editData.type === DATA_EDIT_DATA_INSERT_TYPE)
                                    editData.key.rowIndex += args.items.length
                            })
                    },
                    getEditMode: function() {
                        return getEditMode(this)
                    },
                    getFirstEditableColumnIndex: function() {
                        var columnsController = this.getController("columns"),
                            visibleColumns = columnsController.getVisibleColumns(),
                            columnIndex;
                        $.each(visibleColumns, function(index, column) {
                            if (column.allowEditing) {
                                columnIndex = index;
                                return false
                            }
                        });
                        return columnIndex
                    },
                    getFirstEditableCellInRow: function(rowIndex) {
                        return this.getView("rowsView").getCellElement(rowIndex ? rowIndex : 0, this.getFirstEditableColumnIndex())
                    },
                    getFocusedCellInRow: function(rowIndex) {
                        return this.getFirstEditableCellInRow(rowIndex)
                    },
                    getIndexByKey: function(key, items) {
                        return getIndexByKey(key, items)
                    },
                    hasChanges: function() {
                        var that = this,
                            result = false;
                        for (var i = 0; i < that._editData.length; i++)
                            if (that._editData[i].type) {
                                result = true;
                                break
                            }
                        return result
                    },
                    dispose: function() {
                        this.callBase();
                        $(document).off("dxclick", this._saveEditorHandler)
                    },
                    optionChanged: function(args) {
                        if (args.name === "editing") {
                            this.init();
                            args.handled = true
                        }
                        else
                            this.callBase(args)
                    },
                    publicMethods: function() {
                        return ["insertRow", "addRow", "removeRow", "deleteRow", "undeleteRow", "editRow", "editCell", "closeEditCell", "saveEditData", "cancelEditData", "hasEditData"]
                    },
                    refresh: function() {
                        if (getEditMode(this) !== DATAGRID_EDIT_MODE_BATCH)
                            this.init();
                        else {
                            this._editRowIndex = -1;
                            this._editColumnIndex = -1
                        }
                    },
                    isEditing: function() {
                        return this._editRowIndex > -1
                    },
                    isEditRow: function(rowIndex) {
                        return (getEditMode(this) === DATAGRID_EDIT_MODE_ROW || getEditMode(this) === DATAGRID_EDIT_MODE_FORM) && this._editRowIndex === rowIndex
                    },
                    getEditFormRowIndex: function() {
                        return getEditMode(this) === DATAGRID_EDIT_MODE_FORM ? this._editRowIndex : -1
                    },
                    isEditCell: function(rowIndex, columnIndex) {
                        return this._editRowIndex === rowIndex && this._editColumnIndex === columnIndex
                    },
                    _needInsertItem: function(editData, changeType) {
                        var that = this,
                            dataSource = that._dataController.dataSource(),
                            srollingMode = that.option("scrolling.mode"),
                            pageIndex = dataSource.pageIndex(),
                            beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : pageIndex,
                            endPageIndex = dataSource.endPageIndex ? dataSource.endPageIndex() : pageIndex;
                        if (srollingMode !== "standard")
                            switch (changeType) {
                                case"append":
                                    return editData.key.pageIndex === endPageIndex;
                                case"prepend":
                                    return editData.key.pageIndex === beginPageIndex;
                                case"refresh":
                                    editData.key.rowIndex = 0;
                                    editData.key.pageIndex = 0;
                                    break;
                                default:
                                    return editData.key.pageIndex >= beginPageIndex && editData.key.pageIndex <= endPageIndex
                            }
                        return editData.key.pageIndex === pageIndex
                    },
                    processItems: function(items, changeType) {
                        var that = this,
                            i,
                            key,
                            data,
                            editData = that._editData;
                        that.update();
                        for (i = 0; i < editData.length; i++) {
                            key = editData[i].key;
                            data = {key: key};
                            if (editData[i].type === DATA_EDIT_DATA_INSERT_TYPE && that._needInsertItem(editData[i], changeType)) {
                                data[DATAGRID_INSERT_INDEX] = key[DATAGRID_INSERT_INDEX];
                                items.splice(key.rowIndex, 0, data)
                            }
                        }
                        return items
                    },
                    processDataItem: function(item, columns, generateDataValues) {
                        var that = this,
                            editIndex,
                            editData,
                            data,
                            key = item.data[DATAGRID_INSERT_INDEX] ? item.data.key : item.key,
                            editMode;
                        editIndex = getIndexByKey(key, that._editData);
                        if (editIndex >= 0) {
                            editMode = getEditMode(that);
                            editData = that._editData[editIndex];
                            data = editData.data;
                            switch (editData.type) {
                                case DATA_EDIT_DATA_INSERT_TYPE:
                                    item.inserted = true;
                                    item.key = key;
                                    item.data = data;
                                    break;
                                case DATA_EDIT_DATA_UPDATE_TYPE:
                                    item.modified = true;
                                    item.data = $.extend(true, {}, item.data, data);
                                    item.modifiedValues = generateDataValues(data, columns);
                                    break;
                                case DATA_EDIT_DATA_REMOVE_TYPE:
                                    if (editMode === DATAGRID_EDIT_MODE_BATCH)
                                        item.data = $.extend(true, {}, item.data, data);
                                    item.removed = true;
                                    break
                            }
                        }
                    },
                    insertRow: function() {
                        errors.log("W0002", "dxDataGrid", "insertRow", "15.2", "Use the 'addRow' method instead");
                        return this.addRow()
                    },
                    addRow: function() {
                        var that = this,
                            dataController = that._dataController,
                            store = dataController.store(),
                            key = store && store.key(),
                            rowsView = that.getView("rowsView"),
                            param = {data: {}},
                            insertKey = {
                                pageIndex: dataController.pageIndex(),
                                rowIndex: rowsView ? rowsView.getTopVisibleItemIndex() : 0
                            },
                            oldEditRowIndex = that._editRowIndex,
                            editMode = getEditMode(that),
                            $firstCell;
                        if (editMode === DATAGRID_EDIT_MODE_CELL && that.hasChanges())
                            that.saveEditData();
                        that.refresh();
                        if (editMode !== DATAGRID_EDIT_MODE_BATCH) {
                            if (that._insertIndex > 1)
                                return;
                            that._editRowIndex = insertKey.rowIndex
                        }
                        if (!key)
                            param.data.__KEY__ = String(new DX.data.Guid);
                        that.executeAction("onInitNewRow", param);
                        insertKey[DATAGRID_INSERT_INDEX] = that._insertIndex++;
                        that._addEditData({
                            key: insertKey,
                            data: param.data,
                            type: DATA_EDIT_DATA_INSERT_TYPE
                        });
                        dataController.updateItems({
                            changeType: "update",
                            rowIndices: [oldEditRowIndex, insertKey.rowIndex]
                        });
                        $firstCell = that.getFirstEditableCellInRow(insertKey.rowIndex);
                        that._delayedInputFocus($firstCell, function() {
                            var $cell = that.getFirstEditableCellInRow(insertKey.rowIndex);
                            $cell && $cell.trigger("dxclick")
                        });
                        that._afterInsertRow({
                            key: insertKey,
                            data: param.data
                        })
                    },
                    _isEditingStart: function(options) {
                        this.executeAction("onEditingStart", options);
                        return options.cancel
                    },
                    _beforeEditCell: function(rowIndex, columnIndex, item) {
                        if (getEditMode(this) === DATAGRID_EDIT_MODE_CELL && !item.inserted && this.hasChanges()) {
                            this.saveEditData();
                            if (this.hasChanges())
                                return true
                        }
                    },
                    editRow: function(rowIndex) {
                        var that = this,
                            dataController = that._dataController,
                            items = dataController.items(),
                            item = items[rowIndex],
                            params = {
                                data: item.data,
                                cancel: false
                            },
                            oldEditRowIndex = that._editRowIndex,
                            $editingCell;
                        if (rowIndex === oldEditRowIndex)
                            return true;
                        if (!item.inserted)
                            params.key = item.key;
                        if (that._isEditingStart(params))
                            return;
                        that.init();
                        that._pageIndex = dataController.pageIndex();
                        that._editRowIndex = items[0].inserted ? rowIndex - 1 : rowIndex;
                        that._addEditData({
                            data: {},
                            key: item.key,
                            oldData: item.data
                        });
                        dataController.updateItems({
                            changeType: "update",
                            rowIndices: [oldEditRowIndex, rowIndex]
                        });
                        if (getEditMode(that) === DATAGRID_EDIT_MODE_ROW || getEditMode(that) === DATAGRID_EDIT_MODE_FORM) {
                            $editingCell = that.getFocusedCellInRow(that._editRowIndex);
                            that._delayedInputFocus($editingCell, function() {
                                $editingCell && that.component.focus($editingCell)
                            })
                        }
                    },
                    editCell: function(rowIndex, columnIndex) {
                        var that = this,
                            columnsController = that._columnsController,
                            dataController = that._dataController,
                            items = dataController.items(),
                            item = items[rowIndex],
                            params = {
                                data: item && item.data,
                                cancel: false
                            },
                            oldEditRowIndex = that._editRowIndex,
                            oldEditColumnIndex = that._editColumnIndex,
                            columns = columnsController.getVisibleColumns(),
                            showEditorAlways;
                        if (commonUtils.isString(columnIndex)) {
                            columnIndex = columnsController.columnOption(columnIndex, "index");
                            columnIndex = columnsController.getVisibleIndex(columnIndex)
                        }
                        params.column = columnsController.getVisibleColumns()[columnIndex];
                        showEditorAlways = params.column && params.column.showEditorAlways;
                        if (params.column && item && item.rowType === "data" && !item.removed && !isRowEditMode(that)) {
                            if (this.isEditCell(rowIndex, columnIndex))
                                return true;
                            if (that._beforeEditCell(rowIndex, columnIndex, item))
                                return true;
                            if (!item.inserted)
                                params.key = item.key;
                            if (that._isEditingStart(params))
                                return true;
                            that._editRowIndex = rowIndex;
                            that._editColumnIndex = columnIndex;
                            that._pageIndex = dataController.pageIndex();
                            that._addEditData({
                                data: {},
                                key: item.key,
                                oldData: item.data
                            });
                            if (!showEditorAlways || columns[oldEditColumnIndex] && !columns[oldEditColumnIndex].showEditorAlways) {
                                that._editCellInProgress = true;
                                that.getController("editorFactory").loseFocus();
                                dataController.updateItems({
                                    changeType: "update",
                                    rowIndices: [oldEditRowIndex, that._editRowIndex]
                                })
                            }
                            that._focusEditingCell(function() {
                                that._editCellInProgress = false
                            });
                            return true
                        }
                        return false
                    },
                    _delayedInputFocus: function($cell, beforeFocusCallback) {
                        setTimeout(function() {
                            if (beforeFocusCallback)
                                beforeFocusCallback();
                            $cell.find("[tabindex], input").first().focus()
                        })
                    },
                    _focusEditingCell: function(beforeFocusCallback) {
                        var that = this,
                            $editCell = that.getView("rowsView").getCellElement(that._editRowIndex, that._editColumnIndex);
                        that._delayedInputFocus($editCell, beforeFocusCallback)
                    },
                    removeRow: function(rowIndex) {
                        errors.log("W0002", "dxDataGrid", "removeRow", "15.2", "Use the 'deleteRow' method instead");
                        return this.deleteRow(rowIndex)
                    },
                    deleteRow: function(rowIndex) {
                        var that = this,
                            editingOptions = that.option("editing"),
                            editingTexts = editingOptions && editingOptions.texts,
                            confirmDeleteTitle = editingTexts && editingTexts.confirmDeleteTitle,
                            isBatchMode = editingOptions && editingOptions.mode === DATAGRID_EDIT_MODE_BATCH,
                            confirmDeleteMessage = editingTexts && editingTexts.confirmDeleteMessage,
                            dataController = that._dataController,
                            removeByKey,
                            showDialogTitle,
                            oldEditRowIndex = that._editRowIndex,
                            item = dataController.items()[rowIndex],
                            key = item && item.key;
                        if (item) {
                            removeByKey = function(key) {
                                that.refresh();
                                var editIndex = getIndexByKey(key, that._editData);
                                if (editIndex >= 0)
                                    if (that._editData[editIndex].type === DATA_EDIT_DATA_INSERT_TYPE)
                                        that._editData.splice(editIndex, 1);
                                    else
                                        that._editData[editIndex].type = DATA_EDIT_DATA_REMOVE_TYPE;
                                else
                                    that._addEditData({
                                        key: key,
                                        oldData: item.data,
                                        type: DATA_EDIT_DATA_REMOVE_TYPE
                                    });
                                if (isBatchMode)
                                    dataController.updateItems({
                                        changeType: "update",
                                        rowIndices: [oldEditRowIndex, rowIndex]
                                    });
                                else
                                    that.saveEditData()
                            };
                            if (isBatchMode || !confirmDeleteMessage)
                                removeByKey(key);
                            else {
                                showDialogTitle = commonUtils.isDefined(confirmDeleteTitle) && confirmDeleteTitle.length > 0;
                                dialog.confirm(confirmDeleteMessage, confirmDeleteTitle, showDialogTitle).done(function(confirmResult) {
                                    if (confirmResult)
                                        removeByKey(key)
                                })
                            }
                        }
                    },
                    undeleteRow: function(rowIndex) {
                        var that = this,
                            dataController = that._dataController,
                            item = dataController.items()[rowIndex],
                            oldEditRowIndex = that._editRowIndex,
                            key = item && item.key;
                        if (item) {
                            var editIndex = getIndexByKey(key, that._editData),
                                editData;
                            if (editIndex >= 0) {
                                editData = that._editData[editIndex];
                                if ($.isEmptyObject(editData.data))
                                    that._editData.splice(editIndex, 1);
                                else
                                    editData.type = DATA_EDIT_DATA_UPDATE_TYPE;
                                dataController.updateItems({
                                    changeType: "update",
                                    rowIndices: [oldEditRowIndex, rowIndex]
                                })
                            }
                        }
                    },
                    _saveEditDataCore: function(deferreds, processedKeys) {
                        var that = this,
                            store = that._dataController.store(),
                            hasCanceledData = false;
                        function executeEditingAction(actionName, params, func) {
                            var deferred = $.Deferred();
                            that.executeAction(actionName, params);
                            function createFailureHandler(deferred) {
                                return function(arg) {
                                        var error = arg instanceof Error ? arg : new Error(arg && String(arg) || "Unknown error");
                                        deferred.reject(error)
                                    }
                            }
                            $.when(params.cancel).done(function(cancel) {
                                if (cancel)
                                    deferred.resolve("cancel");
                                else
                                    func(params).done(deferred.resolve).fail(createFailureHandler(deferred))
                            }).fail(createFailureHandler(deferred));
                            return deferred
                        }
                        $.each(that._editData, function(index, editData) {
                            var data = editData.data,
                                oldData = editData.oldData,
                                key = editData.key,
                                type = editData.type,
                                deferred,
                                doneDeferred,
                                params;
                            if (that._beforeSaveEditData(editData, index))
                                return;
                            switch (type) {
                                case DATA_EDIT_DATA_REMOVE_TYPE:
                                    params = {
                                        data: oldData,
                                        key: key,
                                        cancel: false
                                    };
                                    deferred = executeEditingAction("onRowRemoving", params, function() {
                                        return store.remove(key)
                                    });
                                    break;
                                case DATA_EDIT_DATA_INSERT_TYPE:
                                    params = {
                                        data: data,
                                        cancel: false
                                    };
                                    deferred = executeEditingAction("onRowInserting", params, function() {
                                        return store.insert(params.data)
                                    });
                                    break;
                                case DATA_EDIT_DATA_UPDATE_TYPE:
                                    params = {
                                        newData: data,
                                        oldData: oldData,
                                        key: key,
                                        cancel: false
                                    };
                                    deferred = executeEditingAction("onRowUpdating", params, function() {
                                        return store.update(key, params.newData)
                                    });
                                    break
                            }
                            if (deferred) {
                                doneDeferred = $.Deferred();
                                deferred.always(function() {
                                    processedKeys.push(key)
                                }).always(doneDeferred.resolve);
                                deferreds.push(doneDeferred.promise())
                            }
                        });
                        return hasCanceledData
                    },
                    _processSaveEditDataResult: function(results, processedKeys) {
                        var that = this,
                            dataController = that._dataController,
                            i,
                            arg,
                            editIndex,
                            isError,
                            editMode = getEditMode(that);
                        for (i = 0; i < results.length; i++) {
                            arg = results[i];
                            editIndex = getIndexByKey(processedKeys[i], that._editData);
                            if (that._editData[editIndex]) {
                                isError = arg && arg instanceof Error;
                                if (isError) {
                                    that._editData[editIndex].error = arg;
                                    dataController.dataErrorOccurred.fire(arg);
                                    if (editMode !== DATAGRID_EDIT_MODE_BATCH)
                                        return false
                                }
                                else if (arg !== "cancel")
                                    that._editData.splice(editIndex, 1);
                                else
                                    return false
                            }
                        }
                        return true
                    },
                    _fireSaveEditDataEvents: function(editData) {
                        var that = this;
                        $.each(editData, function(_, itemData) {
                            var data = itemData.data,
                                key = itemData.key,
                                type = itemData.type,
                                params = {
                                    key: key,
                                    data: data
                                };
                            if (itemData.error)
                                params.error = itemData.error;
                            switch (type) {
                                case DATA_EDIT_DATA_REMOVE_TYPE:
                                    that.executeAction("onRowRemoved", $.extend({}, params, {data: itemData.oldData}));
                                    break;
                                case DATA_EDIT_DATA_INSERT_TYPE:
                                    that.executeAction("onRowInserted", params);
                                    break;
                                case DATA_EDIT_DATA_UPDATE_TYPE:
                                    that.executeAction("onRowUpdated", params);
                                    break
                            }
                        })
                    },
                    saveEditData: function() {
                        var that = this,
                            processedKeys = [],
                            deferreds = [],
                            dataController = that._dataController,
                            rowIndex = that._editRowIndex,
                            editData = $.extend({}, that._editData),
                            editMode = getEditMode(that),
                            result = $.Deferred();
                        var resetEditIndices = function(that) {
                                that._editColumnIndex = -1;
                                that._editRowIndex = -1
                            };
                        if (that._beforeSaveEditData()) {
                            that._afterSaveEditData();
                            return
                        }
                        that._saveEditDataCore(deferreds, processedKeys);
                        if (deferreds.length) {
                            $.when.apply($, deferreds).done(function() {
                                if (that._processSaveEditDataResult(arguments, processedKeys)) {
                                    resetEditIndices(that);
                                    $.when(dataController.refresh()).always(function() {
                                        that._fireSaveEditDataEvents(editData);
                                        that._afterSaveEditData();
                                        result.resolve()
                                    })
                                }
                            }).fail(result.resolve);
                            return result.promise()
                        }
                        if (isRowEditMode(that)) {
                            if (!that.hasChanges())
                                that.cancelEditData()
                        }
                        else if (editMode === DATAGRID_EDIT_MODE_BATCH || editMode === DATAGRID_EDIT_MODE_CELL) {
                            resetEditIndices(that);
                            dataController.updateItems(rowIndex >= 0 && {
                                changeType: "update",
                                rowIndices: [rowIndex]
                            })
                        }
                        else
                            that._focusEditingCell();
                        that._afterSaveEditData();
                        return result.resolve().promise()
                    },
                    _updateEditColumn: function() {
                        var that = this,
                            editing = that.option("editing"),
                            isEditColumnVisible = editing && ((editing.allowUpdating || editing.allowAdding) && isRowEditMode(that) || editing.allowDeleting);
                        that._columnsController.addCommandColumn({
                            command: "edit",
                            visible: isEditColumnVisible,
                            cssClass: "dx-command-edit",
                            width: "auto"
                        });
                        that._columnsController.columnOption("command:edit", "visible", isEditColumnVisible)
                    },
                    _updateEditButtons: function() {
                        var that = this,
                            saveChangesButton = that._saveChangesButton,
                            cancelChangesButton = that._cancelChangesButton,
                            hasChanges = that.hasChanges();
                        if (saveChangesButton)
                            saveChangesButton.option("disabled", !hasChanges);
                        if (cancelChangesButton)
                            cancelChangesButton.option("disabled", !hasChanges)
                    },
                    cancelEditData: function() {
                        var that = this,
                            dataController = that._dataController;
                        that._beforeCancelEditData();
                        that.init();
                        dataController.updateItems()
                    },
                    hasEditData: function() {
                        return this.hasChanges()
                    },
                    closeEditCell: function() {
                        var that = this,
                            editMode = getEditMode(that),
                            oldEditRowIndex = that._editRowIndex,
                            dataController = that._dataController;
                        if (!isRowEditMode(that))
                            setTimeout(function() {
                                if (editMode === DATAGRID_EDIT_MODE_CELL && that.hasChanges())
                                    that.saveEditData();
                                else if (oldEditRowIndex >= 0) {
                                    that._editRowIndex = -1;
                                    that._editColumnIndex = -1;
                                    dataController.updateItems({
                                        changeType: "update",
                                        rowIndices: [oldEditRowIndex]
                                    })
                                }
                            })
                    },
                    update: function() {
                        var that = this,
                            dataController = that._dataController;
                        if (dataController && that._pageIndex !== dataController.pageIndex()) {
                            that.refresh();
                            that._pageIndex = dataController.pageIndex()
                        }
                        that._updateEditButtons()
                    },
                    updateFieldValue: function(options, value, text) {
                        var that = this,
                            data = {},
                            rowKey = options.key,
                            $cellElement = options.cellElement,
                            editMode = getEditMode(that),
                            params;
                        if (rowKey !== undefined && options.column.setCellValue) {
                            if (editMode === DATAGRID_EDIT_MODE_BATCH && $cellElement)
                                $cellElement.addClass(DATAGRID_CELL_MODIFIED);
                            options.value = value;
                            options.column.setCellValue(data, value, text);
                            if (text && options.column.displayValueMap)
                                options.column.displayValueMap[value] = text;
                            params = {
                                data: data,
                                key: rowKey,
                                oldData: options.data,
                                type: DATA_EDIT_DATA_UPDATE_TYPE
                            };
                            that._addEditData(params);
                            that._updateEditButtons();
                            if (options.column.showEditorAlways && getEditMode(that) === DATAGRID_EDIT_MODE_CELL && options.row && !options.row.inserted)
                                that.saveEditData().always(function() {
                                    that._editColumnIndex = options.columnIndex;
                                    that._editRowIndex = options.row.rowIndex;
                                    that._focusEditingCell()
                                });
                            else if (options.row && (text !== undefined || options.column.setCellValue !== options.column.defaultSetCellValue))
                                that._dataController.updateItems({
                                    changeType: "update",
                                    rowIndices: [options.row.rowIndex]
                                })
                        }
                    },
                    _addEditData: function(options) {
                        var that = this,
                            editDataIndex = getIndexByKey(options.key, that._editData);
                        if (editDataIndex < 0) {
                            editDataIndex = that._editData.length;
                            that._editData.push(options)
                        }
                        if (that._editData[editDataIndex]) {
                            options.type = that._editData[editDataIndex].type || options.type;
                            objectUtils.deepExtendArraySafe(that._editData[editDataIndex], {
                                data: options.data,
                                type: options.type
                            })
                        }
                        return editDataIndex
                    },
                    _formEditorPrepared: function(){},
                    getFormEditorTemplate: function(detailCellOptions, column, item) {
                        var that = this;
                        return function(options, $container) {
                                var cellOptions = $.extend({}, detailCellOptions, {
                                        value: column.calculateCellValue(detailCellOptions.data),
                                        column: $.extend({}, column, {editorOptions: item.editorOptions}),
                                        columnIndex: column.index,
                                        setValue: column.allowEditing && function(value) {
                                            that.updateFieldValue(cellOptions, value)
                                        }
                                    });
                                var template = column.editCellTemplate || getDefaultEditorTemplate(that);
                                template($container, cellOptions);
                                that._formEditorPrepared(cellOptions, $container)
                            }
                    },
                    getEditFormTemplate: function(options) {
                        var that = this;
                        return function($container, detailOptions) {
                                var editFormOptions = that.option("editing.form"),
                                    items = that.option("editing.form.items"),
                                    userCustomizeItem = that.option("editing.form.customizeItem");
                                if (!items) {
                                    var columns = that.getController("columns").getColumns();
                                    items = [];
                                    $.each(columns, function(_, column) {
                                        items.push({
                                            column: column,
                                            name: column.name,
                                            dataField: column.dataField
                                        })
                                    })
                                }
                                that._createComponent($("<div>").appendTo($container), "dxForm", $.extend({}, editFormOptions, {
                                    items: items,
                                    customizeItem: function(item) {
                                        var column = item.column || that._columnsController.columnOption(item.name || item.dataField);
                                        if (column) {
                                            item.label = item.label || {};
                                            item.label.text = item.label.text || column.caption;
                                            item.template = item.template || that.getFormEditorTemplate(detailOptions, column, item);
                                            item.column = column;
                                            if (column.formItem)
                                                $.extend(item, column.formItem)
                                        }
                                        userCustomizeItem && userCustomizeItem.call(this, item)
                                    }
                                }));
                                var $buttonsContainer = $("<div>").addClass("dx-datagrid-form-buttons-container").appendTo($container);
                                that._createComponent($("<div>").appendTo($buttonsContainer), Button, {
                                    text: that.option("editing.texts.cancelRowChanges"),
                                    onClick: $.proxy(that.cancelEditData, that)
                                });
                                that._createComponent($("<div>").appendTo($buttonsContainer), Button, {
                                    text: that.option("editing.texts.saveRowChanges"),
                                    onClick: $.proxy(that.saveEditData, that)
                                })
                            }
                    },
                    getColumnTemplate: function(options) {
                        var that = this,
                            column = options.column,
                            rowIndex = options.row && options.row.rowIndex,
                            template,
                            editingOptions,
                            editingTexts,
                            allowUpdating,
                            isRowMode = isRowEditMode(that),
                            isRowEditing = that.isEditRow(rowIndex),
                            isCellEditing = that.isEditCell(rowIndex, options.columnIndex),
                            editingStartOptions;
                        if ((column.showEditorAlways || column.setCellValue && (isRowEditing && column.allowEditing || isCellEditing)) && options.rowType === "data" && !commonUtils.isDefined(column.command)) {
                            allowUpdating = that.option("editing.allowUpdating");
                            if (((allowUpdating || isRowEditing) && column.allowEditing || isCellEditing) && (isRowMode && isRowEditing || !isRowMode)) {
                                if (column.showEditorAlways) {
                                    editingStartOptions = {
                                        cancel: false,
                                        key: options.row.key,
                                        data: options.row.data,
                                        column: column
                                    };
                                    that._isEditingStart(editingStartOptions)
                                }
                                if (!editingStartOptions || !editingStartOptions.cancel)
                                    options.setValue = function(value, text) {
                                        that.updateFieldValue(options, value, text)
                                    }
                            }
                            template = column.editCellTemplate || getDefaultEditorTemplate(that)
                        }
                        else if (column.command === "edit" && options.rowType === "data")
                            template = function(container, options) {
                                var createLink = function(container, text, methodName, options) {
                                        var $link = $("<a />").addClass(DATAGRID_LINK_CLASS).text(text).on(addNamespace("dxclick", DATAGRID_EDITING_NAMESPACE), that.createAction(function(params) {
                                                var e = params.jQueryEvent;
                                                e.stopPropagation();
                                                setTimeout(function() {
                                                    options.row && that[methodName](options.row.rowIndex)
                                                })
                                            }));
                                        options.rtlEnabled ? container.prepend($link, "&nbsp;") : container.append($link, "&nbsp;")
                                    };
                                container.css("text-align", "center");
                                options.rtlEnabled = that.option("rtlEnabled");
                                editingOptions = that.option("editing") || {};
                                editingTexts = editingOptions.texts || {};
                                if (options.row && options.row.rowIndex === that._editRowIndex && isRowMode) {
                                    createLink(container, editingTexts.saveRowChanges, "saveEditData", options);
                                    createLink(container, editingTexts.cancelRowChanges, "cancelEditData", options)
                                }
                                else {
                                    if (editingOptions.allowUpdating && isRowMode)
                                        createLink(container, editingTexts.editRow, "editRow", options);
                                    if (editingOptions.allowDeleting)
                                        if (options.row.removed)
                                            createLink(container, editingTexts.undeleteRow, "undeleteRow", options);
                                        else
                                            createLink(container, editingTexts.deleteRow, "deleteRow", options)
                                }
                            };
                        else if (column.command === "detail" && options.rowType === "detail" && isRowEditing)
                            template = that.getEditFormTemplate(options);
                        return template
                    },
                    renderEditButtons: function(rootElement) {
                        var that = this,
                            insertButton = rootElement.find("." + DATAGRID_EDIT_BUTTON_CLASS),
                            editingOptions = that.option("editing") || {},
                            editingTexts = that.option("editing.texts") || {},
                            titleButtonTextByClassNames = {
                                cancel: editingTexts.cancelAllChanges,
                                save: editingTexts.saveAllChanges,
                                addrow: editingTexts.addRow
                            };
                        var createEditButton = function(rootElement, className, methodName) {
                                return that._createComponent($("<div />").addClass(DATAGRID_EDIT_BUTTON_CLASS).addClass("dx-datagrid-" + className + "-button").appendTo(rootElement), Button, {
                                        icon: "edit-button-" + className,
                                        onClick: function(options) {
                                            var e = options.jQueryEvent;
                                            e.stopPropagation();
                                            that[methodName]()
                                        },
                                        hint: titleButtonTextByClassNames && titleButtonTextByClassNames[className]
                                    })
                            };
                        if (insertButton.length)
                            insertButton.remove();
                        if ((editingOptions.allowUpdating || editingOptions.allowAdding || editingOptions.allowDeleting) && getEditMode(that) === DATAGRID_EDIT_MODE_BATCH) {
                            that._cancelChangesButton = createEditButton(rootElement, "cancel", "cancelEditData");
                            that._saveChangesButton = createEditButton(rootElement, "save", "saveEditData");
                            that._updateEditButtons()
                        }
                        if (editingOptions.allowAdding)
                            createEditButton(rootElement, "addrow", "addRow")
                    },
                    createHighlightCell: function($cell) {
                        var $highlight = $cell.find("." + DATAGRID_CELL_HIGHLIGHT_OUTLINE);
                        if (!$highlight.length)
                            $cell.wrapInner($("<div>").addClass(DATAGRID_CELL_HIGHLIGHT_OUTLINE + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS))
                    },
                    resetRowAndPageIndeces: function(alwaysRest) {
                        var that = this;
                        $.each(that._editData, function(_, editData) {
                            if (editData.pageIndex !== that._pageIndex || alwaysRest) {
                                delete editData.pageIndex;
                                delete editData.rowIndex
                            }
                        })
                    },
                    _afterInsertRow: function(options){},
                    _beforeSaveEditData: function(editData, editIndex){},
                    _afterSaveEditData: function(){},
                    _beforeCancelEditData: function(){}
                }
        }());
        dataGrid.registerModule("editing", {
            defaultOptions: function() {
                return {editing: {
                            mode: "row",
                            allowAdding: false,
                            allowUpdating: false,
                            allowDeleting: false,
                            texts: {
                                editRow: Globalize.localize("dxDataGrid-editingEditRow"),
                                saveAllChanges: Globalize.localize("dxDataGrid-editingSaveAllChanges"),
                                saveRowChanges: Globalize.localize("dxDataGrid-editingSaveRowChanges"),
                                cancelAllChanges: Globalize.localize("dxDataGrid-editingCancelAllChanges"),
                                cancelRowChanges: Globalize.localize("dxDataGrid-editingCancelRowChanges"),
                                addRow: Globalize.localize("dxDataGrid-editingAddRow"),
                                deleteRow: Globalize.localize("dxDataGrid-editingDeleteRow"),
                                undeleteRow: Globalize.localize("dxDataGrid-editingUndeleteRow"),
                                confirmDeleteMessage: Globalize.localize("dxDataGrid-editingConfirmDeleteMessage"),
                                confirmDeleteTitle: Globalize.localize("dxDataGrid-editingConfirmDeleteTitle")
                            },
                            form: {colCount: 2}
                        }}
            },
            controllers: {editing: dataGrid.EditingController},
            extenders: {
                controllers: {
                    data: {
                        init: function() {
                            this._editingController = this.getController("editing");
                            this.callBase()
                        },
                        reload: function(full) {
                            var d,
                                editingController = this.getController("editing");
                            this._editingController.refresh();
                            d = this.callBase(full);
                            return d && d.done(function() {
                                    editingController.resetRowAndPageIndeces(true)
                                })
                        },
                        _updateItemsCore: function(change) {
                            this.callBase(change);
                            var editFormItem = this.items()[this.getController("editing").getEditFormRowIndex()];
                            if (editFormItem)
                                editFormItem.rowType = "detail"
                        },
                        _processItems: function(items, changeType) {
                            items = this._editingController.processItems(items, changeType);
                            return this.callBase(items, changeType)
                        },
                        _processDataItem: function(dataItem, options) {
                            this._editingController.processDataItem(dataItem, options.visibleColumns, this.generateDataValues);
                            return this.callBase(dataItem, options)
                        },
                        _processItem: function(item, options) {
                            item = this.callBase(item, options);
                            if (item.inserted) {
                                options.dataIndex--;
                                delete item.dataIndex
                            }
                            return item
                        }
                    },
                    columnsResizer: {_startResizing: function(args) {
                            var that = this,
                                editingController = that.getController("editing"),
                                isCellEditing = function() {
                                    var editingOptions = that.option("editing");
                                    return editingOptions && editingOptions.mode !== DATAGRID_EDIT_MODE_ROW && editingController.isEditing()
                                };
                            that.callBase(args);
                            if (that.isResizing() && isCellEditing())
                                editingController.closeEditCell()
                        }}
                },
                views: {
                    rowsView: {
                        publicMethods: function() {
                            return this.callBase().concat(["cellValue"])
                        },
                        _getColumnTemplate: function(options) {
                            var that = this,
                                template = that.getController("editing").getColumnTemplate(options);
                            return template || that.callBase(options)
                        },
                        _createTable: function() {
                            var that = this,
                                editing = that.option("editing"),
                                $table = that.callBase.apply(that, arguments);
                            if (editing && !isRowEditMode(that) && editing.allowUpdating)
                                $table.on(addNamespace("dxhold", "dxDataGridRowsView"), "td:not(." + DATAGRID_EDITOR_CELL_CLASS + ")", that.createAction(function(e) {
                                    var editingController = that.getController("editing");
                                    if (editingController.isEditing())
                                        editingController.closeEditCell()
                                }));
                            return $table
                        },
                        _createRow: function(row) {
                            var $row = this.callBase(row),
                                editingController,
                                isEditRow,
                                isRowRemoved,
                                isRowInserted,
                                isRowModified;
                            if (row) {
                                editingController = this.getController("editing");
                                isEditRow = editingController.isEditRow(row.rowIndex);
                                isRowRemoved = !!row.removed;
                                isRowInserted = !!row.inserted;
                                isRowModified = !!row.modified;
                                if (getEditMode(this) === DATAGRID_EDIT_MODE_BATCH)
                                    isRowRemoved && $row.addClass(DATAGRID_ROW_REMOVED);
                                else
                                    isEditRow && $row.addClass(DATAGRID_EDIT_ROW);
                                isRowInserted && $row.addClass(DATAGRID_ROW_INSERTED);
                                isRowModified && $row.addClass(DATAGRID_ROW_MODIFIED);
                                if (isEditRow || isRowInserted || isRowRemoved)
                                    $row.removeClass(DATAGRID_ROW_SELECTED);
                                if (isEditRow && row.rowType === "detail")
                                    $row.addClass(DATAGRID_EDIT_FORM_CLASS)
                            }
                            return $row
                        },
                        _rowClick: function(e) {
                            var that = this,
                                editingController = that.getController("editing"),
                                $targetCell = $(e.jQueryEvent.target).closest("." + DATAGRID_ROW_CLASS + "> td"),
                                columnIndex = that.getCellIndex($targetCell),
                                allowUpdating = that.option("editing.allowUpdating"),
                                column = that._columnsController.getVisibleColumns()[columnIndex],
                                allowEditing = column && (column.allowEditing || editingController.isEditCell(e.rowIndex, columnIndex));
                            if ($targetCell.hasClass(DATAGRID_POINTER_EVENTS_NONE_CLASS))
                                return;
                            if (!(allowUpdating && allowEditing && editingController.editCell(e.rowIndex, columnIndex)) && !editingController.isEditRow(e.rowIndex))
                                that.callBase(e)
                        },
                        _cellPrepared: function($cell, parameters) {
                            var columnIndex = parameters.columnIndex,
                                editingController = this.getController("editing"),
                                isCommandCell = !!parameters.column.command,
                                isEditableCell = parameters.setValue;
                            parameters.isEditing = editingController.isEditCell(parameters.rowIndex, parameters.columnIndex) || editingController.isEditRow(parameters.rowIndex) && parameters.column.allowEditing;
                            if (!commonUtils.isDefined(parameters.column.command) && (parameters.isEditing || parameters.column.showEditorAlways)) {
                                var alignment = parameters.column.alignment;
                                $cell.addClass(DATAGRID_EDITOR_CELL_CLASS).toggleClass(DATAGRID_READONLY_CLASS, !isEditableCell).toggleClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS, !isEditableCell);
                                if (alignment)
                                    $cell.find("input").first().css("text-align", alignment)
                            }
                            var firstChild = $cell.get(0).firstChild;
                            if (firstChild && firstChild.className && firstChild.className.indexOf(CHECKBOX_CLASS) >= 0)
                                $cell.addClass(DATAGRID_EDITOR_INLINE_BLOCK).toggleClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS, isCommandCell || !isEditableCell);
                            var modifiedValues = parameters.row && (parameters.row.inserted ? parameters.row.values : parameters.row.modifiedValues);
                            if (modifiedValues && modifiedValues[columnIndex] !== undefined && parameters.column && !isCommandCell) {
                                editingController.createHighlightCell($cell);
                                $cell.addClass(DATAGRID_CELL_MODIFIED)
                            }
                            else if (isEditableCell)
                                editingController.createHighlightCell($cell, true);
                            this.callBase.apply(this, arguments)
                        },
                        _update: function(change) {
                            this.callBase(change);
                            if (change.changeType === "updateSelection")
                                this.getTableElements().children("tbody").children("." + DATAGRID_EDIT_ROW).removeClass(DATAGRID_ROW_SELECTED)
                        },
                        cellValue: function(rowIndex, columnIdentificator, value, text) {
                            var cellOptions = this.getCellOptions(rowIndex, columnIdentificator);
                            if (cellOptions)
                                if (value === undefined)
                                    return cellOptions.value;
                                else
                                    this.getController("editing").updateFieldValue(cellOptions, value, text || '')
                        }
                    },
                    headerPanel: {
                        _renderCore: function() {
                            this.callBase();
                            this.getController("editing").renderEditButtons(this.element())
                        },
                        isVisible: function() {
                            var that = this,
                                editingOptions = that.getController("editing").option("editing");
                            return that.callBase() || editingOptions && (editingOptions.allowAdding || (editingOptions.allowUpdating || editingOptions.allowDeleting) && editingOptions.mode === DATAGRID_EDIT_MODE_BATCH)
                        }
                    }
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_LINK_CLASS: DATAGRID_LINK_CLASS,
            DATAGRID_EDITOR_CELL_CLASS: DATAGRID_EDITOR_CELL_CLASS,
            DATAGRID_EDIT_ROW: DATAGRID_EDIT_ROW,
            DATAGRID_EDIT_BUTTON_CLASS: DATAGRID_EDIT_BUTTON_CLASS,
            DATAGRID_CELL_MODIFIED: DATAGRID_CELL_MODIFIED,
            DATAGRID_ROW_REMOVED: DATAGRID_ROW_REMOVED,
            DATAGRID_ROW_INSERTED: DATAGRID_ROW_INSERTED,
            DATAGRID_ROW_MODIFIED: DATAGRID_ROW_MODIFIED,
            DATAGRID_CELL_HIGHLIGHT_OUTLINE: DATAGRID_CELL_HIGHLIGHT_OUTLINE,
            DATAGRID_FOCUS_OVERLAY_CLASS: DATAGRID_FOCUS_OVERLAY_CLASS,
            DATAGRID_READONLY_CLASS: DATAGRID_READONLY_CLASS,
            DATAGRID_CELL_FOCUS_DISABLED_CLASS: DATAGRID_CELL_FOCUS_DISABLED_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.validationModule.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            Button = DX.require("/ui/widgets/ui.button"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer"),
            Validator = DX.require("/ui/widgets/ui.validator");
        var DATAGRID_INVALIDATE_CLASS = "dx-datagrid-invalid",
            DATAGRID_INVALID_MESSAGE_CLASS = "dx-invalid-message",
            DATAGRID_INVALID_MESSAGE_ALWAYS_CLASS = "dx-invalid-message-always",
            DATAGRID_REVERT_BUTTON_CLASS = "dx-revert-button",
            DATAGRID_REVERT_TOOLTIP_CLASS = "dx-datagrid-revert-tooltip",
            DATAGRID_CELL_HIGHLIGHT_OUTLINE = "dx-highlight-outline",
            DATAGRID_INSERT_INDEX = "__DX_INSERT_INDEX__",
            DATAGRID_EDIT_MODE_ROW = "row",
            DATAGRID_EDIT_MODE_BATCH = "batch",
            DATAGRID_EDIT_MODE_CELL = "cell";
        dataGrid.ValidatingController = dataGrid.Controller.inherit(function() {
            return {
                    init: function() {
                        this._editingController = this.getController("editing");
                        this.createAction("onRowValidating")
                    },
                    _rowValidating: function(editData, validate) {
                        var that = this,
                            brokenRules = validate ? validate.brokenRules || validate.brokenRule && [validate.brokenRule] : [],
                            isValid = validate ? validate.isValid : editData.isValid,
                            parameters = {
                                brokenRules: brokenRules,
                                isValid: isValid,
                                key: editData.key,
                                newData: editData.data,
                                oldData: editData.oldData,
                                errorText: null
                            };
                        that.executeAction("onRowValidating", parameters);
                        editData.isValid = parameters.isValid;
                        editData.errorText = parameters.errorText;
                        return parameters
                    },
                    validate: function(isFull) {
                        var that = this,
                            isValid = true,
                            editingController = that._editingController;
                        isFull = isFull || editingController.getEditMode() === DATAGRID_EDIT_MODE_ROW;
                        if (that._isValidationInProgress)
                            return false;
                        that._isValidationInProgress = true;
                        if (isFull)
                            $.each(editingController._editData, function(index, editData) {
                                var validationResult;
                                if (editData.type) {
                                    validationResult = that.validateGroup(editData);
                                    if (!validationResult.isValid)
                                        $.each(validationResult.brokenRules, function() {
                                            var value = this.validator.option("adapter").getValue();
                                            if (value === undefined)
                                                value = null;
                                            if (this.column)
                                                editingController.updateFieldValue({
                                                    key: editData.key,
                                                    column: this.column
                                                }, value, true)
                                        });
                                    isValid = isValid && validationResult.isValid
                                }
                            });
                        else if (that._currentCellValidator)
                            isValid = that.validateGroup(that._currentCellValidator._findGroup()).isValid;
                        that._isValidationInProgress = false;
                        return isValid
                    },
                    validateGroup: function(editData) {
                        var that = this,
                            validateGroup = DX.validationEngine.getGroupConfig(editData),
                            validationResults;
                        if (validateGroup && validateGroup.validators.length)
                            validationResults = DX.validationEngine.validateGroup(editData);
                        return that._rowValidating(editData, validationResults)
                    },
                    updateEditData: function(editData) {
                        this.setDisableApplyValidationResults(true);
                        editData.isValid = DX.validationEngine.getGroupConfig(editData) ? DX.validationEngine.validateGroup(editData).isValid : true;
                        this.setDisableApplyValidationResults(false)
                    },
                    setValidator: function(validator) {
                        this._currentCellValidator = validator
                    },
                    getValidator: function() {
                        return this._currentCellValidator
                    },
                    removeValidators: function(editIndex) {
                        var that = this,
                            editingController = that._editingController;
                        $.each(editingController._editData, function(index, editData) {
                            var validateGroup = DX.validationEngine.getGroupConfig(editData);
                            if (!commonUtils.isDefined(editIndex) || editIndex === index)
                                if (validateGroup)
                                    for (var i = 0; i < validateGroup.validators.length; i++) {
                                        validateGroup.validators[i]._dispose();
                                        i--
                                    }
                        })
                    },
                    createValidator: function(parameters, $container) {
                        var that = this,
                            editingController = that._editingController,
                            column = parameters.column,
                            editData,
                            editIndex = editingController.getIndexByKey(parameters.key, editingController._editData),
                            defaultValidationResult = function(options) {
                                if (options.brokenRule) {
                                    options.brokenRule.columnIndex = column.index;
                                    options.brokenRule.column = column
                                }
                                if ($container && !that.getDisableApplyValidationResults()) {
                                    if (!options.isValid) {
                                        var $focus = $container.find(":focus");
                                        editingController.createHighlightCell($container, true);
                                        if (!$focus.is(":focus"))
                                            $focus.focus().trigger(pointerEvents.down)
                                    }
                                    $container.toggleClass(DATAGRID_INVALIDATE_CLASS, !options.isValid)
                                }
                            };
                        if (!commonUtils.isArray(column.validationRules))
                            return;
                        if (editIndex < 0 && column.showEditorAlways)
                            editIndex = editingController._addEditData({key: parameters.key});
                        if (editIndex >= 0) {
                            editData = editingController._editData[editIndex];
                            return new Validator($container || {}, {
                                    name: column.caption,
                                    validationRules: $.extend(true, [], column.validationRules),
                                    validationGroup: editData,
                                    adapter: $container && $container.hasClass("dx-widget") ? null : {
                                        getValue: function() {
                                            var value = column.calculateCellValue(editData.data || {});
                                            return value !== undefined ? value : parameters.value
                                        },
                                        applyValidationResults: defaultValidationResult
                                    }
                                })
                        }
                    },
                    setDisableApplyValidationResults: function(flag) {
                        this._disableApplyValidationResults = flag
                    },
                    getDisableApplyValidationResults: function() {
                        return this._disableApplyValidationResults
                    }
                }
        }());
        dataGrid.registerModule("validating", {
            defaultOptions: function() {
                return {editing: {texts: {validationCancelChanges: Globalize.localize("dxDataGrid-validationCancelChanges")}}}
            },
            controllers: {validating: dataGrid.ValidatingController},
            extenders: {
                controllers: {
                    editing: {
                        _addEditData: function(options) {
                            var that = this,
                                validatingController = that.getController("validating"),
                                editDataIndex = that.callBase(options),
                                editData;
                            if (editDataIndex >= 0) {
                                editData = that._editData[editDataIndex];
                                validatingController.updateEditData(editData)
                            }
                            return editDataIndex
                        },
                        _updateRowAndPageIndices: function() {
                            var that = this,
                                startInsertIndex = that.getView("rowsView").getTopVisibleItemIndex(),
                                rowIndex = startInsertIndex;
                            $.each(that._editData, function(_, editData) {
                                if (!editData.isValid && editData.pageIndex !== that._pageIndex) {
                                    editData.pageIndex = that._pageIndex;
                                    if (editData.type === "insert")
                                        editData.rowIndex = startInsertIndex;
                                    else
                                        editData.rowIndex = rowIndex;
                                    rowIndex++
                                }
                            })
                        },
                        processItems: function(items, changeType) {
                            var that = this,
                                dataController = that.getController("data"),
                                i,
                                editData = that._editData,
                                itemsCount = items.length,
                                insertCount = 0,
                                getIndexByEditData = function(editData, items) {
                                    var index = -1,
                                        isInsert = editData.type === "insert",
                                        key = editData.key;
                                    $.each(items, function(i, item) {
                                        if (dataGrid.equalKeys(key, isInsert ? item : dataController.keyOf(item))) {
                                            index = i;
                                            return false
                                        }
                                    });
                                    return index
                                },
                                addInValidItem = function(editData) {
                                    var data = {key: editData.key},
                                        index = getIndexByEditData(editData, items),
                                        rowIndex;
                                    if (index >= 0 && that.option("scrolling.mode") === "standard")
                                        return;
                                    editData.rowIndex = editData.rowIndex > itemsCount ? editData.rowIndex % itemsCount : editData.rowIndex;
                                    rowIndex = editData.rowIndex;
                                    data[DATAGRID_INSERT_INDEX] = 1;
                                    if (index >= 0) {
                                        items.splice(index, 1);
                                        rowIndex -= insertCount
                                    }
                                    items.splice(rowIndex, 0, data);
                                    insertCount++
                                };
                            that.update();
                            if (that.getEditMode() === DATAGRID_EDIT_MODE_BATCH && changeType !== "prepend" && changeType !== "append")
                                for (i = 0; i < editData.length; i++)
                                    if (editData[i].type && editData[i].pageIndex === that._pageIndex && editData[i].key.pageIndex !== that._pageIndex)
                                        addInValidItem(editData[i]);
                            return that.callBase(items, changeType)
                        },
                        processDataItem: function(item, columns, generateDataValues) {
                            var that = this,
                                editIndex,
                                editData,
                                isInserted = item.data[DATAGRID_INSERT_INDEX],
                                key = isInserted ? item.data.key : item.key,
                                editMode = that.getEditMode();
                            if (editMode === DATAGRID_EDIT_MODE_BATCH && isInserted && key) {
                                editIndex = dataGrid.getIndexByKey(key, that._editData);
                                if (editIndex >= 0) {
                                    editData = that._editData[editIndex];
                                    if (editData.type !== "insert") {
                                        item.data = $.extend(true, {}, editData.oldData, editData.data);
                                        item.key = key
                                    }
                                }
                            }
                            that.callBase.apply(that, arguments)
                        },
                        _afterInsertRow: function(options) {
                            var validatingController = this.getController("validating"),
                                hiddenColumns = this.getController("columns").getHiddenColumns();
                            $.each(hiddenColumns, function(_, column) {
                                validatingController.createValidator({
                                    column: column,
                                    key: options.key,
                                    value: column.calculateCellValue(options.data)
                                })
                            });
                            this.callBase(options)
                        },
                        _beforeSaveEditData: function(editData, editIndex) {
                            var that = this,
                                isValid,
                                isFullValid,
                                result = that.callBase.apply(that, arguments),
                                validatingController = that.getController("validating");
                            if (editData) {
                                isValid = editData.type === "remove" || editData.isValid;
                                if (isValid)
                                    validatingController.removeValidators(editIndex);
                                result = result || !isValid
                            }
                            else {
                                isFullValid = validatingController.validate(true);
                                that._updateRowAndPageIndices();
                                if (that.getEditMode() === DATAGRID_EDIT_MODE_CELL) {
                                    if (!isFullValid) {
                                        that._focusEditingCell();
                                        result = true
                                    }
                                }
                                else if (that.getEditMode() === DATAGRID_EDIT_MODE_ROW)
                                    result = !isFullValid
                            }
                            return result
                        },
                        _beforeEditCell: function(rowIndex, columnIndex, item) {
                            var result = this.callBase(rowIndex, columnIndex, item),
                                $cell = this.component.getCellElement(rowIndex, columnIndex),
                                validator = $cell.data("dxValidator");
                            if (this.getEditMode(this) === DATAGRID_EDIT_MODE_CELL && (!validator || validator.validate().isValid))
                                return result
                        },
                        _afterSaveEditData: function() {
                            var that = this;
                            $.each(that._editData, function(_, editData) {
                                that._showErrorRow(editData)
                            })
                        },
                        _beforeCancelEditData: function() {
                            var validatingController = this.getController("validating");
                            validatingController.removeValidators();
                            this.callBase()
                        },
                        _showErrorRow: function(editData) {
                            var errorHandling = this.getController("errorHandling"),
                                items = this.getController("data").items(),
                                rowIndex = this.getIndexByKey(editData.key, items);
                            if (!editData.isValid && editData.errorText && rowIndex >= 0)
                                errorHandling && errorHandling.renderErrorRow(editData.errorText, rowIndex)
                        },
                        updateFieldValue: function(options, value) {
                            var that = this;
                            that.callBase.apply(that, arguments);
                            if (that.getEditMode() === DATAGRID_EDIT_MODE_ROW) {
                                var currentValidator = that.getController("validating").getValidator();
                                currentValidator && currentValidator.validate()
                            }
                        },
                        createHighlightCell: function($cell, skipValidation) {
                            var isValid = true,
                                validator;
                            if (!skipValidation) {
                                validator = $cell.data("dxValidator");
                                if (validator)
                                    isValid = validator.validate().isValid
                            }
                            if (isValid)
                                this.callBase($cell)
                        },
                        _formEditorPrepared: function(cellOptions, $container) {
                            this.callBase.apply(this, arguments);
                            this.getController("validating").createValidator(cellOptions, $container.children(".dx-widget"))
                        }
                    },
                    editorFactory: {
                        _showRevertButton: function($cell) {
                            var that = this,
                                $targetElement = $cell.find("." + DATAGRID_CELL_HIGHLIGHT_OUTLINE).first();
                            $("<div>").addClass(DATAGRID_REVERT_TOOLTIP_CLASS).appendTo($cell).dxTooltip({
                                animation: null,
                                visible: true,
                                target: $targetElement,
                                closeOnOutsideClick: false,
                                closeOnTargetScroll: false,
                                boundary: that._rowsView.element(),
                                contentTemplate: function() {
                                    return new Button($("<div>").addClass(DATAGRID_REVERT_BUTTON_CLASS), {
                                            icon: "revert",
                                            hint: that.option("editing.texts.validationCancelChanges"),
                                            onClick: function() {
                                                that._editingController.cancelEditData()
                                            }
                                        }).element()
                                },
                                position: {
                                    my: "left top",
                                    at: "right top",
                                    of: $targetElement,
                                    offset: "1 0",
                                    collision: "flip"
                                }
                            })
                        },
                        _showValidationMessage: function($cell, message, alignment) {
                            var that = this;
                            $("<div/>").addClass(DATAGRID_INVALID_MESSAGE_CLASS).addClass(DATAGRID_INVALID_MESSAGE_ALWAYS_CLASS).text(message).appendTo($cell).dxTooltip({
                                target: $cell,
                                container: $cell,
                                visible: true,
                                closeOnOutsideClick: false,
                                closeOnTargetScroll: false,
                                position: {
                                    collision: "fit flip",
                                    boundary: that._rowsView.element(),
                                    boundaryOffset: "0 0",
                                    offset: "1 -10",
                                    my: "top " + alignment,
                                    at: "bottom " + alignment
                                },
                                onPositioned: function() {
                                    that._rowsView.element() && that._rowsView.updateFreeSpaceRowHeight()
                                }
                            })
                        },
                        init: function() {
                            this.callBase();
                            this._editingController = this.getController("editing");
                            this._rowsView = this.getView("rowsView")
                        },
                        loseFocus: function(skipValidator) {
                            if (!skipValidator)
                                this.getController("validating").setValidator(null);
                            this.callBase()
                        },
                        focus: function($element, hideBorder) {
                            var that = this,
                                $cell = $element && $element.closest("td"),
                                validator = $cell && $cell.data("dxValidator"),
                                validationResult,
                                $tooltips = $cell && $cell.closest(".dx-datagrid-rowsview").find(".dx-editor-cell .dx-tooltip"),
                                column = $cell && that.getController("columns").getVisibleColumns()[$cell.index()];
                            $tooltips && $tooltips.remove();
                            if (validator && column) {
                                that.getController("validating").setValidator(validator);
                                if (validator.option("adapter").getValue() !== undefined) {
                                    validationResult = validator.validate();
                                    if (!validationResult.isValid) {
                                        hideBorder = true;
                                        that._showValidationMessage($cell, validationResult.brokenRule.message, column.alignment);
                                        if (that._editingController.getEditMode() === DATAGRID_EDIT_MODE_CELL)
                                            that._showRevertButton($cell)
                                    }
                                }
                            }
                            !hideBorder && that._rowsView.element() && that._rowsView.updateFreeSpaceRowHeight();
                            return that.callBase($element, hideBorder)
                        }
                    }
                },
                views: {rowsView: {
                        updateFreeSpaceRowHeight: function() {
                            var that = this,
                                $rowElements = that._getRowElements(),
                                $freeSpaceRowElements = that._getFreeSpaceRowElements(),
                                $freeSpaceRowElement = $freeSpaceRowElements.first(),
                                $tooltipContent = that.element().find(".dx-invalid-message .dx-overlay-content");
                            that.callBase();
                            if ($tooltipContent.length && $freeSpaceRowElement && $rowElements.length === 1 && (!$freeSpaceRowElement.is(":visible") || $tooltipContent.outerHeight() > $freeSpaceRowElement.outerHeight())) {
                                $freeSpaceRowElements.show();
                                $freeSpaceRowElements.height($tooltipContent.outerHeight())
                            }
                        },
                        _cellPrepared: function($cell, parameters) {
                            this.getController("validating").createValidator(parameters, $cell);
                            this.callBase.apply(this, arguments)
                        }
                    }}
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_REVERT_TOOLTIP_CLASS: DATAGRID_REVERT_TOOLTIP_CLASS,
            DATAGRID_REVERT_BUTTON_CLASS: DATAGRID_REVERT_BUTTON_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.dataController.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            errors = DevExpress.require("/ui/ui.errors"),
            commonUtils = DX.require("/utils/utils.common"),
            DataHelperMixin = DX.require("/ui/ui.dataHelper");
        dataGrid.proxyMethod = function(instance, methodName, defaultResult) {
            if (!instance[methodName])
                instance[methodName] = function() {
                    var dataSource = this._dataSource;
                    return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult
                }
        };
        dataGrid.combineFilters = function(filters, operation) {
            var resultFilter = [],
                i;
            operation = operation || "and";
            for (i = 0; i < filters.length; i++) {
                if (!filters[i])
                    continue;
                if (resultFilter.length)
                    resultFilter.push(operation);
                resultFilter.push(filters[i])
            }
            if (resultFilter.length === 1)
                resultFilter = resultFilter[0];
            if (resultFilter.length)
                return resultFilter
        };
        dataGrid.DataController = dataGrid.Controller.inherit({}).include(DataHelperMixin).inherit(function() {
            var members = {
                    init: function() {
                        var that = this;
                        that._items = [];
                        that._columnsController = that.getController("columns");
                        that._columnsChangedHandler = $.proxy(that._handleColumnsChanged, that);
                        that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
                        that._loadingChangedHandler = $.proxy(that._handleLoadingChanged, that);
                        that._loadErrorHandler = $.proxy(that._handleLoadError, that);
                        that._customizeStoreLoadOptionsHandler = $.proxy(that._handleCustomizeStoreLoadOptions, that);
                        that._columnsController.columnsChanged.add(that._columnsChangedHandler);
                        that._isLoading = false;
                        that._isCustomLoading = false;
                        that._refreshDataSource();
                        that.createAction("onDataErrorOccurred");
                        that.dataErrorOccurred.add(function(error) {
                            return that.executeAction("onDataErrorOccurred", {error: error})
                        })
                    },
                    callbackNames: function() {
                        return ["changed", "loadingChanged", "dataErrorOccurred", "pageChanged", "dataSourceChanged"]
                    },
                    callbackFlags: function(name) {
                        if (name === "dataErrorOccurred")
                            return "stopOnFalse"
                    },
                    publicMethods: function() {
                        return ["beginCustomLoading", "endCustomLoading", "refresh", "filter", "clearFilter", "getCombinedFilter", "keyOf", "byKey", "getDataByKeys", "pageIndex", "pageSize", "pageCount", "totalCount", "_disposeDataSource", "getKeyByRowIndex", "getRowIndexByKey"]
                    },
                    optionChanged: function(args) {
                        var that = this;
                        function handled() {
                            args.handled = true
                        }
                        function reload() {
                            that._columnsController.reset();
                            that._refreshDataSource()
                        }
                        if (args.name === "dataSource" && args.name === args.fullName && args.value === args.previousValue) {
                            handled();
                            that.refresh();
                            return
                        }
                        switch (args.name) {
                            case"cacheEnabled":
                            case"loadingTimeout":
                            case"remoteOperations":
                                handled();
                                break;
                            case"dataSource":
                            case"scrolling":
                            case"paging":
                                handled();
                                reload();
                                break;
                            case"rtlEnabled":
                                reload();
                                break;
                            default:
                                that.callBase(args)
                        }
                    },
                    isReady: function() {
                        return !this._isLoading
                    },
                    getCombinedFilter: function() {
                        return this.combinedFilter()
                    },
                    combinedFilter: function(filter) {
                        var that = this,
                            dataSource = that._dataSource,
                            columnsController = that._columnsController,
                            additionalFilter;
                        if (dataSource) {
                            if (filter === undefined)
                                filter = dataSource.filter();
                            additionalFilter = that._calculateAdditionalFilter();
                            if (additionalFilter)
                                if (columnsController.isDataSourceApplied() || columnsController.isAllDataTypesDefined())
                                    filter = dataGrid.combineFilters([additionalFilter, filter]);
                            columnsController.updateFilter(filter, !dataSource.remoteOperations().filtering)
                        }
                        return filter
                    },
                    _handleCustomizeStoreLoadOptions: function(e) {
                        var columnsController = this._columnsController,
                            dataSource = this._dataSource,
                            storeLoadOptions = e.storeLoadOptions;
                        if (this._isLoadingAll) {
                            storeLoadOptions.isLoadingAll = true;
                            delete storeLoadOptions.skip;
                            delete storeLoadOptions.take
                        }
                        storeLoadOptions.filter = this.combinedFilter(storeLoadOptions.filter);
                        if (!columnsController.isDataSourceApplied())
                            columnsController.updateColumnDataTypes(dataSource);
                        this._columnsUpdating = true;
                        columnsController.updateSortingGrouping(dataSource, !this._isFirstLoading);
                        this._columnsUpdating = false;
                        storeLoadOptions.sort = columnsController.getSortDataSourceParameters();
                        storeLoadOptions.group = columnsController.getGroupDataSourceParameters();
                        dataSource.sort(storeLoadOptions.sort);
                        dataSource.group(storeLoadOptions.group);
                        storeLoadOptions.sort = columnsController.getSortDataSourceParameters(!dataSource.remoteOperations().sorting);
                        e.group = columnsController.getGroupDataSourceParameters(true);
                        this._isFirstLoading = false
                    },
                    _handleColumnsChanged: function(e) {
                        var that = this,
                            changeTypes = e.changeTypes,
                            optionNames = e.optionNames,
                            filterValue,
                            filterValues;
                        var updateItemsHandler = function() {
                                that._columnsController.columnsChanged.remove(updateItemsHandler);
                                that.updateItems()
                            };
                        if (changeTypes.sorting || changeTypes.grouping) {
                            if (that._dataSource && !that._columnsUpdating) {
                                that._dataSource.group(that._columnsController.getGroupDataSourceParameters());
                                that._dataSource.sort(that._columnsController.getSortDataSourceParameters());
                                that.reload()
                            }
                            that.pageChanged.fire()
                        }
                        else if (changeTypes.columns) {
                            if (optionNames.filterValues || optionNames.filterValue || optionNames.selectedFilterOperation)
                                if (this.option("filterRow.applyFilter") !== "onClick" || optionNames.filterValues) {
                                    filterValue = that._columnsController.columnOption(e.columnIndex, "filterValue");
                                    filterValues = that._columnsController.columnOption(e.columnIndex, "filterValues");
                                    if (commonUtils.isArray(filterValues) || e.columnIndex === undefined || commonUtils.isDefined(filterValue) || !optionNames.selectedFilterOperation || optionNames.filterValue)
                                        that._applyFilter()
                                }
                            if (!that._needApplyFilter && !dataGrid.checkChanges(optionNames, ["width", "visibleWidth", "filterValue", "selectedFilterOperation", "filterValues"]))
                                that._columnsController.columnsChanged.add(updateItemsHandler)
                        }
                    },
                    _handleDataChanged: function(e) {
                        var that = this,
                            dataSource = that._dataSource,
                            columnsController = that._columnsController,
                            isAllDataTypesDefined = columnsController.isAllDataTypesDefined();
                        if (dataSource && !that._isDataSourceApplying && !that._isLoadingAll) {
                            that._isDataSourceApplying = true;
                            $.when(that._columnsController.applyDataSource(dataSource)).done(function() {
                                if (that._isLoading)
                                    that._handleLoadingChanged(false);
                                that._isDataSourceApplying = false;
                                var additionalFilter = that._calculateAdditionalFilter(),
                                    needApplyFilter = that._needApplyFilter;
                                that._needApplyFilter = false;
                                if (needApplyFilter && additionalFilter && additionalFilter.length && !isAllDataTypesDefined) {
                                    errors.log("W1005", that.component.NAME);
                                    that._applyFilter()
                                }
                                else
                                    that.updateItems(e)
                            });
                            if (that._isDataSourceApplying)
                                that._handleLoadingChanged(true);
                            that._needApplyFilter = !that._columnsController.isDataSourceApplied()
                        }
                    },
                    _handleLoadingChanged: function(isLoading) {
                        this._isLoading = isLoading;
                        this._fireLoadingChanged()
                    },
                    _handleLoadError: function(e) {
                        this.dataErrorOccurred.fire(e)
                    },
                    _initDataSource: function() {
                        var that = this,
                            dataSource = this.option("dataSource"),
                            pageIndex = this.option("paging.pageIndex"),
                            pageSize = this.option("paging.pageSize"),
                            scrollingMode = that.option("scrolling.mode"),
                            pagingEnabled = this.option("paging.enabled"),
                            appendMode = scrollingMode === "infinite",
                            virtualMode = scrollingMode === "virtual",
                            oldDataSource = this._dataSource;
                        that.callBase();
                        dataSource = that._dataSource;
                        that._isFirstLoading = true;
                        if (dataSource) {
                            dataSource.requireTotalCount(!appendMode);
                            if (pagingEnabled !== undefined)
                                dataSource.paginate(pagingEnabled || virtualMode || appendMode);
                            if (pageSize !== undefined)
                                dataSource.pageSize(pageSize);
                            if (pageIndex !== undefined)
                                dataSource.pageIndex(pageIndex);
                            that._dataSource = oldDataSource;
                            that.setDataSource(dataSource)
                        }
                        else if (oldDataSource)
                            that.updateItems()
                    },
                    _loadDataSource: function() {
                        var dataSource = this._dataSource;
                        dataSource && dataSource.load()
                    },
                    _processItems: function(items) {
                        var that = this,
                            visibleColumns = that._columnsController.getVisibleColumns(),
                            options = {
                                visibleColumns: visibleColumns,
                                dataIndex: 0
                            },
                            result = [];
                        $.each(items, function(index, item) {
                            if (commonUtils.isDefined(item)) {
                                item = that._processItem(item, options);
                                result.push(item)
                            }
                        });
                        return result
                    },
                    _processItem: function(item, options) {
                        item = this._generateDataItem(item);
                        item = this._processDataItem(item, options);
                        item.dataIndex = options.dataIndex++;
                        return item
                    },
                    _generateDataItem: function(data) {
                        return {
                                rowType: "data",
                                data: data,
                                key: this.keyOf(data)
                            }
                    },
                    _processDataItem: function(dataItem, options) {
                        dataItem.values = this.generateDataValues(dataItem.data, options.visibleColumns);
                        return dataItem
                    },
                    generateDataValues: function(data, columns) {
                        var values = [],
                            column,
                            value;
                        for (var i = 0; i < columns.length; i++) {
                            column = columns[i];
                            value = null;
                            if (column.command)
                                value = null;
                            else if (column.calculateCellValue)
                                value = column.calculateCellValue(data);
                            else if (column.dataField)
                                value = data[column.dataField];
                            values.push(value)
                        }
                        return values
                    },
                    _updateItemsCore: function(change) {
                        var that = this,
                            items,
                            dataSource = that._dataSource,
                            changeType = change.changeType || "refresh";
                        change.changeType = changeType;
                        if (dataSource) {
                            items = change.items || dataSource.items();
                            items = that._processItems(items.slice(0), changeType);
                            change.items = items;
                            switch (changeType) {
                                case"prepend":
                                    that._items.unshift.apply(that._items, items);
                                    break;
                                case"append":
                                    that._items.push.apply(that._items, items);
                                    break;
                                case"update":
                                    var prevIndex = -1,
                                        rowIndices = change.rowIndices.slice(0),
                                        rowIndexCorrection = 0;
                                    rowIndices.sort(function(a, b) {
                                        return a - b
                                    });
                                    for (var i = 0; i < rowIndices.length; i++)
                                        if (rowIndices[i] < 0) {
                                            rowIndices.splice(i, 1);
                                            i--
                                        }
                                    change.items = [];
                                    change.rowIndices = [];
                                    change.changeTypes = [];
                                    var equalItems = function(item1, item2, strictEqual) {
                                            return dataGrid.equalKeys(item1.key, item2.key) && (!strictEqual || item1.rowType === item2.rowType)
                                        };
                                    $.each(rowIndices, function(index, rowIndex) {
                                        var oldItem,
                                            newItem,
                                            oldNextItem,
                                            newNextItem;
                                        rowIndex += rowIndexCorrection;
                                        if (prevIndex === rowIndex)
                                            return;
                                        change.rowIndices.push(rowIndex);
                                        prevIndex = rowIndex;
                                        oldItem = that._items[rowIndex];
                                        oldNextItem = that._items[rowIndex + 1];
                                        newItem = items[rowIndex];
                                        newNextItem = items[rowIndex + 1];
                                        if (newItem)
                                            change.items.push(newItem);
                                        if (oldItem && newItem && equalItems(oldItem, newItem)) {
                                            changeType = "update";
                                            that._items[rowIndex] = newItem;
                                            if (oldItem.visible !== newItem.visible)
                                                change.items.splice(-1, 1, {visible: newItem.visible})
                                        }
                                        else if (newItem && !oldItem || newNextItem && equalItems(oldItem, newNextItem, true)) {
                                            changeType = "insert";
                                            that._items.splice(rowIndex, 0, newItem);
                                            rowIndexCorrection++
                                        }
                                        else if (oldItem && !newItem || oldNextItem && equalItems(newItem, oldNextItem, true)) {
                                            changeType = "remove";
                                            that._items.splice(rowIndex, 1);
                                            rowIndexCorrection--;
                                            prevIndex = -1
                                        }
                                        change.changeTypes.push(changeType)
                                    });
                                    break;
                                default:
                                    that._items = items.slice(0);
                                    break
                            }
                            $.each(that._items, function(index, item) {
                                item.rowIndex = index
                            })
                        }
                        else
                            that._items = []
                    },
                    updateItems: function(change) {
                        change = change || {};
                        this._updateItemsCore(change);
                        this.changed.fire(change)
                    },
                    isLoading: function() {
                        return this._isLoading || this._isCustomLoading
                    },
                    _fireLoadingChanged: function(messageText) {
                        this.loadingChanged.fire(this.isLoading(), messageText)
                    },
                    _calculateAdditionalFilter: function() {
                        return null
                    },
                    _applyFilter: function() {
                        var that = this,
                            dataSource = that._dataSource;
                        if (dataSource) {
                            dataSource.pageIndex(0);
                            return that.reload().done($.proxy(that.pageChanged, "fire"))
                        }
                    },
                    filter: function(filterExpr) {
                        var dataSource = this._dataSource;
                        if (arguments.length === 0)
                            return dataSource ? dataSource.filter() : undefined;
                        filterExpr = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0) : filterExpr;
                        if (dataSource)
                            dataSource.filter(filterExpr);
                        this._applyFilter()
                    },
                    clearFilter: function(filterName) {
                        var that = this,
                            columnsController = that._columnsController,
                            clearColumnOption = function(optionName) {
                                var columnCount = columnsController.columnCount(),
                                    index;
                                for (index = 0; index < columnCount; index++)
                                    columnsController.columnOption(index, optionName, undefined)
                            };
                        that.component.beginUpdate();
                        if (arguments.length > 0)
                            switch (filterName) {
                                case"dataSource":
                                    that.filter(null);
                                    break;
                                case"search":
                                    that.searchByText("");
                                    break;
                                case"header":
                                    clearColumnOption("filterValues");
                                    break;
                                case"row":
                                    clearColumnOption("filterValue");
                                    break
                            }
                        else {
                            that.filter(null);
                            that.searchByText("");
                            clearColumnOption("filterValue");
                            clearColumnOption("filterValues")
                        }
                        that.component.endUpdate()
                    },
                    _fireDataSourceChanged: function() {
                        var that = this;
                        var changedHandler = function() {
                                that.changed.remove(changedHandler);
                                that.dataSourceChanged.fire()
                            };
                        that.changed.add(changedHandler)
                    },
                    _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
                        var dataSourceAdapter = new dataGrid.DataSourceAdapter(this.component);
                        dataSourceAdapter.init(dataSource, remoteOperations);
                        return dataSourceAdapter
                    },
                    _createDataSourceAdapter: function(dataSource) {
                        var remoteOperations = this.option("remoteOperations");
                        if (remoteOperations === "auto")
                            remoteOperations = dataSource.store() instanceof DX.data.ArrayStore ? {} : {
                                filtering: true,
                                sorting: true,
                                paging: true
                            };
                        if (remoteOperations === true)
                            remoteOperations = {
                                filtering: true,
                                sorting: true,
                                paging: true,
                                grouping: true,
                                summary: true
                            };
                        return this._createDataSourceAdapterCore(dataSource, remoteOperations)
                    },
                    setDataSource: function(dataSource) {
                        var that = this,
                            oldDataSource = that._dataSource;
                        if (oldDataSource) {
                            oldDataSource.changed.remove(that._dataChangedHandler);
                            oldDataSource.loadingChanged.remove(that._loadingChangedHandler);
                            oldDataSource.loadError.remove(that._loadErrorHandler);
                            oldDataSource.customizeStoreLoadOptions.remove(that._customizeStoreLoadOptionsHandler);
                            oldDataSource.dispose(that._isSharedDataSource)
                        }
                        if (dataSource)
                            dataSource = that._createDataSourceAdapter(dataSource);
                        that._dataSource = dataSource;
                        if (dataSource) {
                            that._fireDataSourceChanged();
                            that._isLoading = !dataSource.isLoaded();
                            that._needApplyFilter = true;
                            dataSource.changed.add(that._dataChangedHandler);
                            dataSource.loadingChanged.add(that._loadingChangedHandler);
                            dataSource.loadError.add(that._loadErrorHandler);
                            dataSource.customizeStoreLoadOptions.add(that._customizeStoreLoadOptionsHandler)
                        }
                    },
                    items: function() {
                        return this._items
                    },
                    isEmpty: function() {
                        return !this.items().length
                    },
                    pageCount: function() {
                        return this._dataSource ? this._dataSource.pageCount() : 1
                    },
                    dataSource: function() {
                        return this._dataSource
                    },
                    store: function() {
                        var dataSource = this._dataSource;
                        return dataSource && dataSource.store()
                    },
                    loadAll: function(data) {
                        var that = this,
                            d = $.Deferred(),
                            dataSource = that._dataSource;
                        if (dataSource)
                            if (data) {
                                var options = {
                                        data: data,
                                        storeLoadOptions: {isLoadingAll: true},
                                        loadOptions: {
                                            group: dataSource.group(),
                                            sort: dataSource.sort()
                                        }
                                    };
                                dataSource._handleDataLoaded(options);
                                d.resolve(that._processItems(options.data), options.totalAggregates)
                            }
                            else if (!that.isLoading()) {
                                that._isLoadingAll = true;
                                dataSource.load(true).done(function(items) {
                                    items = that._processItems(items.slice(0));
                                    d.resolve(items)
                                }).fail(d.reject).always(function() {
                                    that._isLoadingAll = false
                                })
                            }
                            else
                                d.reject();
                        else
                            d.resolve([]);
                        return d
                    },
                    getKeyByRowIndex: function(rowIndex) {
                        var item = this.items()[rowIndex];
                        if (item)
                            return item.key
                    },
                    getRowIndexByKey: function(key) {
                        return dataGrid.getIndexByKey(key, this.items())
                    },
                    keyOf: function(data) {
                        var store = this.store();
                        if (store)
                            return store.keyOf(data)
                    },
                    byKey: function(key) {
                        var store = this.store(),
                            rowIndex = this.getRowIndexByKey(key),
                            result;
                        if (!store)
                            return;
                        if (rowIndex >= 0)
                            result = $.Deferred().resolve(this.items()[rowIndex].data);
                        return result || store.byKey(key)
                    },
                    getDataByKeys: function(rowKeys) {
                        var that = this,
                            result = $.Deferred(),
                            deferreds = [],
                            data = [];
                        $.each(rowKeys, function(index, key) {
                            deferreds.push(that.byKey(key).done(function(keyData) {
                                data[index] = keyData
                            }))
                        });
                        $.when.apply($, deferreds).always(function() {
                            result.resolve(data)
                        });
                        return result
                    },
                    pageIndex: function(value) {
                        var that = this,
                            pagingOptions = that.option("paging"),
                            dataSource = that._dataSource;
                        if (dataSource) {
                            if (value !== undefined)
                                if (dataSource.pageIndex() !== value) {
                                    dataSource.pageIndex(value);
                                    if (pagingOptions)
                                        pagingOptions.pageIndex = value;
                                    return dataSource.load().done($.proxy(that.pageChanged, "fire"))
                                }
                            return dataSource.pageIndex()
                        }
                        return 0
                    },
                    pageSize: function(value) {
                        var that = this,
                            pagingOptions = that.option("paging"),
                            dataSource = that._dataSource;
                        if (value === undefined)
                            return dataSource ? dataSource.pageSize() : 0;
                        if (dataSource)
                            if (dataSource.pageSize() !== value) {
                                dataSource.pageIndex(0);
                                dataSource.pageSize(value);
                                if (pagingOptions)
                                    pagingOptions.pageSize = value;
                                return dataSource.reload().done($.proxy(that.pageChanged, "fire"))
                            }
                    },
                    beginCustomLoading: function(messageText) {
                        this._isCustomLoading = true;
                        this._fireLoadingChanged(messageText)
                    },
                    endCustomLoading: function() {
                        this._isCustomLoading = false;
                        this._fireLoadingChanged()
                    },
                    refresh: function() {
                        var that = this,
                            d = $.Deferred();
                        $.when(this._columnsController.refresh()).always(function() {
                            $.when(that.reload(true)).done(d.resolve).fail(d.reject)
                        });
                        return d
                    },
                    _disposeDataSource: function() {
                        this.setDataSource(null)
                    }
                };
            dataGrid.proxyMethod(members, "load");
            dataGrid.proxyMethod(members, "reload");
            dataGrid.proxyMethod(members, "itemsCount", 0);
            dataGrid.proxyMethod(members, "totalItemsCount", 0);
            dataGrid.proxyMethod(members, "hasKnownLastPage", true);
            dataGrid.proxyMethod(members, "isLoaded", true);
            dataGrid.proxyMethod(members, "totalCount", 0);
            return members
        }());
        dataGrid.registerModule("data", {
            defaultOptions: function() {
                return {
                        loadingTimeout: 0,
                        dataSource: null,
                        cacheEnabled: true,
                        onDataErrorOccurred: null,
                        remoteOperations: "auto",
                        paging: {
                            enabled: true,
                            pageSize: undefined,
                            pageIndex: undefined
                        }
                    }
            },
            controllers: {data: ui.dxDataGrid.DataController}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.virtualScrollingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            translator = DX.require("/utils/utils.translator"),
            Class = DevExpress.require("/class");
        var DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_FREESPACE_CLASS = "dx-freespace-row",
            DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
            DATAGRID_BOTTOM_LOAD_PANEL_CLASS = "dx-datagrid-bottom-load-panel",
            DATAGRID_TABLE_CONTENT_CLASS = "dx-datagrid-table-content",
            DATAGRID_GROUP_SPACE_CLASS = "dx-datagrid-group-space",
            DATAGRID_SCROLLABLE_CONTAINER = "dx-scrollable-container",
            DATAGRID_SCROLLABLE_CONTENT = "dx-scrollable-content",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            SCROLLING_MODE_INFINITE = "infinite",
            SCROLLING_MODE_VIRTUAL = "virtual",
            PIXELS_LIMIT = 250000,
            CONTENT_HEIHGT_LIMIT = 15000000;
        dataGrid.__MAX_VIRTUAL_CONTENT_SIZE = CONTENT_HEIHGT_LIMIT;
        var isVirtualMode = function(that) {
                return !that._isLoadingAll && that.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL
            };
        var isAppendMode = function(that) {
                return !that._isLoadingAll && that.option("scrolling.mode") === SCROLLING_MODE_INFINITE
            };
        var VirtualScrollController = Class.inherit(function() {
                var getViewportPageCount = function(that) {
                        var pageSize = that._dataSource.pageSize();
                        return pageSize && that._viewportSize >= 0 ? Math.ceil(that._viewportSize / pageSize) : 1
                    };
                var getPreloadPageCount = function(that) {
                        var preloadEnabled = that.option('scrolling.preloadEnabled'),
                            pageCount = getViewportPageCount(that);
                        if (pageCount) {
                            if (preloadEnabled)
                                pageCount++;
                            if (isAppendMode(that))
                                pageCount--
                        }
                        return pageCount
                    };
                var getBeginPageIndex = function(that) {
                        return that._cache.length ? that._cache[0].pageIndex : -1
                    };
                var getEndPageIndex = function(that) {
                        return that._cache.length ? that._cache[that._cache.length - 1].pageIndex : -1
                    };
                var fireChanged = function(that, changed, args) {
                        that._isChangedFiring = true;
                        changed(args);
                        that._isChangedFiring = false
                    };
                var processDelayChanged = function(that, changed) {
                        if (that._isDelayChanged) {
                            that._isDelayChanged = false;
                            fireChanged(that, changed);
                            return true
                        }
                    };
                var processChanged = function(that, changed, changeType, isDelayChanged) {
                        var dataSource = that._dataSource,
                            items = dataSource.items(),
                            change;
                        if (changeType && !that._isDelayChanged)
                            change = {
                                changeType: changeType,
                                items: items
                            };
                        var viewportItems = that._dataSource.viewportItems();
                        if (changeType === "append")
                            viewportItems.push.apply(viewportItems, items);
                        else if (changeType === "prepend")
                            viewportItems.unshift.apply(viewportItems, items);
                        else
                            that._dataSource.viewportItems(items);
                        dataSource.updateLoading();
                        that._lastPageIndex = that.pageIndex();
                        that._isDelayChanged = isDelayChanged;
                        that._isLoadingAll = false;
                        if (!isDelayChanged)
                            fireChanged(that, changed, change)
                    };
                return {
                        ctor: function(component, dataSource) {
                            var that = this;
                            that._dataSource = dataSource;
                            that.component = component;
                            that._pageIndex = that._lastPageIndex = dataSource.pageIndex();
                            that._cache = [];
                            that._viewportSize = 0;
                            that._viewportItemSize = 20;
                            that._viewportItemIndex = -1;
                            that._sizeRatio = 1;
                            that._items = [];
                            that._cache = []
                        },
                        option: function(name) {
                            return this.component.option.apply(this.component, arguments)
                        },
                        virtualItemsCount: function() {
                            var that = this,
                                pageIndex,
                                itemsCount = 0,
                                beginItemsCount,
                                endItemsCount;
                            if (isVirtualMode(that)) {
                                pageIndex = getBeginPageIndex(that);
                                if (pageIndex < 0)
                                    pageIndex = 0;
                                beginItemsCount = pageIndex * that._dataSource.pageSize();
                                itemsCount = that._cache.length * that._dataSource.pageSize();
                                endItemsCount = Math.max(0, that._dataSource.totalItemsCount() - itemsCount - beginItemsCount);
                                return {
                                        begin: beginItemsCount,
                                        end: endItemsCount
                                    }
                            }
                        },
                        setViewportPosition: function(position) {
                            var that = this,
                                scrollingTimeout = that.option("scrolling.timeout") || 0;
                            that._position = position;
                            clearTimeout(that._scrollTimeoutID);
                            if (scrollingTimeout > 0)
                                that._scrollTimeoutID = setTimeout(function() {
                                    that._setViewportPositionCore(position)
                                }, scrollingTimeout);
                            else
                                that._setViewportPositionCore(position)
                        },
                        getViewportPosition: function() {
                            return this._position || 0
                        },
                        _setViewportPositionCore: function(position) {
                            var that = this,
                                virtualItemsCount = that.virtualItemsCount(),
                                sizeRatio = that._sizeRatio || 1,
                                itemSize = that._viewportItemSize,
                                offset = virtualItemsCount ? Math.floor(virtualItemsCount.begin * itemSize * sizeRatio) : 0;
                            if (virtualItemsCount && position >= offset && position <= offset + that._contentSize)
                                that.setViewportItemIndex(virtualItemsCount.begin + (position - offset) / itemSize);
                            else
                                that.setViewportItemIndex(position / (itemSize * sizeRatio))
                        },
                        setContentSize: function(size) {
                            var that = this,
                                virtualItemsCount = that.virtualItemsCount();
                            that._contentSize = size;
                            if (virtualItemsCount) {
                                var virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + that.itemsCount()) * that._viewportItemSize;
                                if (virtualContentSize > CONTENT_HEIHGT_LIMIT)
                                    that._sizeRatio = CONTENT_HEIHGT_LIMIT / virtualContentSize;
                                else
                                    that._sizeRatio = 1
                            }
                        },
                        getContentOffset: function() {
                            var that = this,
                                virtualItemsCount = that.virtualItemsCount();
                            return virtualItemsCount ? Math.floor(virtualItemsCount.begin * that._viewportItemSize * that._sizeRatio) : 0
                        },
                        getVirtualContentSize: function() {
                            var that = this,
                                virtualItemsCount = that.virtualItemsCount();
                            return virtualItemsCount ? (virtualItemsCount.begin + virtualItemsCount.end) * that._viewportItemSize * that._sizeRatio + that._contentSize : 0
                        },
                        getViewportItemIndex: function() {
                            return this._viewportItemIndex
                        },
                        setViewportItemIndex: function(itemIndex) {
                            var that = this,
                                pageSize = that._dataSource.pageSize(),
                                pageCount = that._dataSource.pageCount(),
                                virtualMode = isVirtualMode(that),
                                appendMode = isAppendMode(that),
                                totalItemsCount = that._dataSource.totalItemsCount(),
                                needLoad = that._viewportItemIndex < 0,
                                lastPageSize,
                                maxPageIndex,
                                newPageIndex;
                            that._viewportItemIndex = itemIndex;
                            if (pageSize && (virtualMode || appendMode) && totalItemsCount >= 0) {
                                if (that._viewportSize && itemIndex + that._viewportSize >= totalItemsCount)
                                    if (that._dataSource.hasKnownLastPage()) {
                                        newPageIndex = pageCount - 1;
                                        lastPageSize = totalItemsCount % pageSize;
                                        if (newPageIndex > 0 && lastPageSize > 0 && lastPageSize < pageSize / 2)
                                            newPageIndex--
                                    }
                                    else
                                        newPageIndex = pageCount;
                                else {
                                    newPageIndex = Math.floor(itemIndex / pageSize);
                                    maxPageIndex = pageCount - 1;
                                    newPageIndex = Math.max(newPageIndex, 0);
                                    newPageIndex = Math.min(newPageIndex, maxPageIndex)
                                }
                                if (that.pageIndex() !== newPageIndex || needLoad) {
                                    that.pageIndex(newPageIndex);
                                    that.load()
                                }
                            }
                        },
                        viewportItemSize: function(size) {
                            if (size !== undefined)
                                this._viewportItemSize = size;
                            return this._viewportItemSize
                        },
                        viewportSize: function(size) {
                            if (size !== undefined)
                                this._viewportSize = size;
                            return this._viewportSize
                        },
                        pageIndex: function(pageIndex) {
                            if (isVirtualMode(this) || isAppendMode(this)) {
                                if (pageIndex !== undefined)
                                    this._pageIndex = pageIndex;
                                return this._pageIndex
                            }
                            else
                                return this._dataSource.pageIndex(pageIndex)
                        },
                        beginPageIndex: function(defaultPageIndex) {
                            var beginPageIndex = getBeginPageIndex(this);
                            if (beginPageIndex < 0)
                                beginPageIndex = defaultPageIndex !== undefined ? defaultPageIndex : this.pageIndex();
                            return beginPageIndex
                        },
                        endPageIndex: function() {
                            var endPageIndex = getEndPageIndex(this);
                            return endPageIndex > 0 ? endPageIndex : this._lastPageIndex
                        },
                        load: function(isLoadingAll) {
                            var beginPageIndex = getBeginPageIndex(this),
                                pageIndexForLoad = -1,
                                dataSource = this._dataSource,
                                result;
                            var loadCore = function(that, pageIndex) {
                                    var dataSource = that._dataSource;
                                    if (pageIndex === that.pageIndex() || !dataSource.isLoading() && pageIndex < dataSource.pageCount() || !dataSource.hasKnownLastPage() && pageIndex === dataSource.pageCount()) {
                                        dataSource.pageIndex(pageIndex);
                                        return dataSource.load()
                                    }
                                };
                            this._isLoadingAll = isLoadingAll;
                            if (isVirtualMode(this) || isAppendMode(this)) {
                                if (beginPageIndex < 0 || !this._cache[this._pageIndex - beginPageIndex])
                                    pageIndexForLoad = this._pageIndex;
                                if (beginPageIndex >= 0 && pageIndexForLoad < 0 && this._viewportSize >= 0)
                                    if (beginPageIndex > 0 && getEndPageIndex(this) + 1 === dataSource.pageCount() && this._cache.length < getPreloadPageCount(this) + 1)
                                        pageIndexForLoad = beginPageIndex - 1;
                                    else if (beginPageIndex + this._cache.length <= this._pageIndex + getPreloadPageCount(this))
                                        pageIndexForLoad = beginPageIndex + this._cache.length;
                                if (pageIndexForLoad >= 0)
                                    result = loadCore(this, pageIndexForLoad);
                                dataSource.updateLoading()
                            }
                            else
                                result = dataSource.load();
                            if (!result && this._lastPageIndex !== this.pageIndex())
                                this._dataSource.onChanged({changeType: "pageIndex"});
                            return result || $.Deferred().resolve()
                        },
                        loadIfNeed: function() {
                            var that = this;
                            if ((isVirtualMode(that) || isAppendMode(that)) && !that._dataSource.isLoading() && !that._isChangedFiring)
                                that.load()
                        },
                        handleDataChanged: function(callBase) {
                            var that = this,
                                beginPageIndex,
                                dataSource = that._dataSource,
                                lastCacheLength = that._cache.length,
                                changeType,
                                removeInvisiblePages,
                                cacheItem;
                            if (isVirtualMode(that) || isAppendMode(that)) {
                                beginPageIndex = getBeginPageIndex(that);
                                if (beginPageIndex >= 0) {
                                    if (isVirtualMode(that) && beginPageIndex + that._cache.length !== dataSource.pageIndex() && beginPageIndex - 1 !== dataSource.pageIndex())
                                        that._cache = [];
                                    if (isAppendMode(that) && dataSource.pageIndex() === 0)
                                        that._cache = []
                                }
                                cacheItem = {
                                    pageIndex: dataSource.pageIndex(),
                                    itemsCount: that.itemsCount(true)
                                };
                                if (that.option("scrolling.removeInvisiblePages"))
                                    removeInvisiblePages = that._cache.length > 2;
                                else
                                    processDelayChanged(that, callBase);
                                removeInvisiblePages = that.option("scrolling.removeInvisiblePages") && that._cache.length > 2;
                                if (beginPageIndex === dataSource.pageIndex() + 1) {
                                    if (removeInvisiblePages)
                                        that._cache.pop();
                                    else
                                        changeType = "prepend";
                                    that._cache.unshift(cacheItem)
                                }
                                else {
                                    if (removeInvisiblePages)
                                        that._cache.shift();
                                    else
                                        changeType = "append";
                                    that._cache.push(cacheItem)
                                }
                                processChanged(that, callBase, that._cache.length > 1 ? changeType : undefined, lastCacheLength === 0);
                                that.load().done(function() {
                                    if (processDelayChanged(that, callBase))
                                        that.load()
                                })
                            }
                            else
                                processChanged(that, callBase)
                        },
                        itemsCount: function(isBase) {
                            var itemsCount = 0;
                            if (!isBase && isVirtualMode(this))
                                $.each(this._cache, function() {
                                    itemsCount += this.itemsCount
                                });
                            else
                                itemsCount = this._dataSource.itemsCount();
                            return itemsCount
                        },
                        reset: function() {
                            this._cache = []
                        },
                        dispose: function() {
                            clearTimeout(this._scrollTimeoutID)
                        }
                    }
            }());
        ui.dxDataGrid.VirtualScrollController = VirtualScrollController;
        var VirtualScrollingDataSourceAdapterExtender = function() {
                var updateLoading = function(that) {
                        var beginPageIndex = that._virtualScrollController.beginPageIndex(-1);
                        if (isVirtualMode(that))
                            if (beginPageIndex < 0 || that.viewportSize() >= 0 && that.getViewportItemIndex() >= 0 && (beginPageIndex * that.pageSize() > that.getViewportItemIndex() || beginPageIndex * that.pageSize() + that.itemsCount() < that.getViewportItemIndex() + that.viewportSize()) && that._dataSource.isLoading()) {
                                if (!that._isLoading) {
                                    that._isLoading = true;
                                    that.loadingChanged.fire(true)
                                }
                            }
                            else if (that._isLoading) {
                                that._isLoading = false;
                                that.loadingChanged.fire(false)
                            }
                    };
                return {
                        init: function(dataSource) {
                            var that = this;
                            that.callBase.apply(that, arguments);
                            that._isLoading = true;
                            that._items = [];
                            that._isLoaded = true;
                            that._virtualScrollController = new VirtualScrollController(that.component, {
                                pageSize: function() {
                                    return that.pageSize()
                                },
                                totalItemsCount: function() {
                                    return that.totalItemsCount()
                                },
                                hasKnownLastPage: function() {
                                    return that.hasKnownLastPage()
                                },
                                pageIndex: function(index) {
                                    return dataSource.pageIndex(index)
                                },
                                isLoading: function() {
                                    return dataSource.isLoading()
                                },
                                pageCount: function() {
                                    return that.pageCount()
                                },
                                load: function() {
                                    return dataSource.load()
                                },
                                updateLoading: function() {
                                    updateLoading(that)
                                },
                                itemsCount: function() {
                                    return that.itemsCount(true)
                                },
                                items: function() {
                                    return dataSource.items()
                                },
                                viewportItems: function(items) {
                                    if (items)
                                        that._items = items;
                                    return that._items
                                },
                                onChanged: function(e) {
                                    that.changed.fire(e)
                                }
                            })
                        },
                        _handleLoadingChanged: function(isLoading) {
                            var that = this;
                            if (!isVirtualMode(that)) {
                                that._isLoading = isLoading;
                                that.callBase.apply(that, arguments)
                            }
                        },
                        _handleLoadError: function() {
                            var that = this;
                            that._isLoadingAll = false;
                            that._isLoading = false;
                            that.loadingChanged.fire(false);
                            that.callBase.apply(that, arguments)
                        },
                        _handleDataChanged: function() {
                            var callBase = $.proxy(this.callBase, this);
                            this._virtualScrollController.handleDataChanged(callBase)
                        },
                        items: function() {
                            return this._items
                        },
                        itemsCount: function(isBase) {
                            if (isBase)
                                return this.callBase();
                            return this._virtualScrollController.itemsCount()
                        },
                        virtualItemsCount: function() {
                            return this._virtualScrollController.virtualItemsCount()
                        },
                        getViewportItemIndex: function() {
                            return this._virtualScrollController.getViewportItemIndex()
                        },
                        setViewportItemIndex: function(itemIndex) {
                            return this._virtualScrollController.setViewportItemIndex(itemIndex)
                        },
                        viewportSize: function(size) {
                            return this._virtualScrollController.viewportSize(size)
                        },
                        pageIndex: function(pageIndex) {
                            return this._virtualScrollController.pageIndex(pageIndex)
                        },
                        beginPageIndex: function() {
                            return this._virtualScrollController.beginPageIndex()
                        },
                        endPageIndex: function() {
                            return this._virtualScrollController.endPageIndex()
                        },
                        load: function(isLoadingAll) {
                            return this._virtualScrollController.load(isLoadingAll)
                        },
                        loadIfNeed: function() {
                            return this._virtualScrollController.loadIfNeed()
                        },
                        isLoading: function() {
                            return this._isLoading
                        },
                        isLoaded: function() {
                            return this._dataSource.isLoaded() && this._isLoaded
                        },
                        _changeRowExpandCore: function() {
                            var result = this.callBase.apply(this, arguments);
                            this._virtualScrollController.reset();
                            updateLoading(this);
                            return result
                        },
                        refresh: function(storeLoadOptions, isReload, operationTypes) {
                            var that = this,
                                dataSource = that._dataSource;
                            if (isReload || operationTypes.reload) {
                                that._virtualScrollController.reset();
                                that._isLoaded = false;
                                updateLoading(that);
                                that._isLoaded = true;
                                if (isAppendMode(that)) {
                                    that.pageIndex(0);
                                    dataSource.pageIndex(0);
                                    storeLoadOptions.pageIndex = 0;
                                    storeLoadOptions.skip = 0
                                }
                                else {
                                    dataSource.pageIndex(that.pageIndex());
                                    if (dataSource.paginate())
                                        storeLoadOptions.skip = that.pageIndex() * that.pageSize()
                                }
                            }
                            return that.callBase.apply(that, arguments)
                        }
                    }
            }();
        dataGrid.DataSourceAdapter = dataGrid.DataSourceAdapter.inherit(VirtualScrollingDataSourceAdapterExtender);
        var VirtualScrollingRowsViewExtender = function() {
                return {
                        _renderCore: function() {
                            var that = this,
                                startRenderDate = new Date;
                            that.callBase.apply(that, arguments);
                            that._updateContentPosition();
                            that._renderTime = new Date - startRenderDate
                        },
                        _renderContent: function(contentElement, tableElement) {
                            var that = this,
                                virtualItemsCount = that._dataController.virtualItemsCount();
                            if (virtualItemsCount) {
                                tableElement.addClass(DATAGRID_TABLE_CONTENT_CLASS);
                                if (!contentElement.children().length)
                                    contentElement.append(tableElement);
                                else
                                    contentElement.children().first().replaceWith(tableElement);
                                if (contentElement.children("table").length === 1) {
                                    contentElement.append(that._createTable());
                                    that._contentHeight = 0
                                }
                                return contentElement
                            }
                            else
                                return that.callBase.apply(that, arguments)
                        },
                        _updateContent: function(contentElement, change, tableElement) {
                            var that = this,
                                contentTable,
                                changeType = change && change.changeType;
                            if (changeType === "append" || changeType === "prepend") {
                                contentTable = contentElement.children().first();
                                tableElement.children("tbody").children("tr")[changeType === "append" ? "appendTo" : "prependTo"](contentTable);
                                tableElement.remove();
                                that._getFreeSpaceRowElements().not(":last").remove()
                            }
                            else
                                that.callBase.apply(that, arguments);
                            that._updateBottomLoading()
                        },
                        _updateContentPosition: function() {
                            var that = this,
                                contentElement,
                                contentHeight,
                                $tables,
                                $contentTable,
                                virtualTable,
                                rowHeight = that._rowHeight || 20,
                                virtualItemsCount = that._dataController.virtualItemsCount(),
                                isRenderVirtualTableContentRequired;
                            if (virtualItemsCount) {
                                contentElement = that._findContentElement();
                                $tables = contentElement.children();
                                $contentTable = $tables.eq(0);
                                virtualTable = $tables.eq(1);
                                that._contentTableHeight = $contentTable.outerHeight();
                                contentHeight = (virtualItemsCount.begin + virtualItemsCount.end + that._dataController.itemsCount()) * that._rowHeight;
                                if (contentHeight > CONTENT_HEIHGT_LIMIT)
                                    that._heightRatio = CONTENT_HEIHGT_LIMIT / contentHeight;
                                else
                                    that._heightRatio = 1;
                                contentHeight = (virtualItemsCount.begin + virtualItemsCount.end) * rowHeight * that._heightRatio + that._contentTableHeight;
                                translator.move($contentTable, {top: Math.floor(virtualItemsCount.begin * rowHeight * that._heightRatio)});
                                isRenderVirtualTableContentRequired = that._contentHeight !== contentHeight || contentHeight === 0 || !that._isTableLinesDisplaysCorrect(virtualTable) || !that._isColumnElementsEqual($contentTable.find("col"), virtualTable.find("col"));
                                if (isRenderVirtualTableContentRequired) {
                                    that._contentHeight = contentHeight;
                                    that._renderVirtualTableContent(virtualTable, contentHeight)
                                }
                                return true
                            }
                            return false
                        },
                        _isTableLinesDisplaysCorrect: function(table) {
                            var hasColumnLines = table.find("." + DATAGRID_COLUMN_LINES_CLASS).length > 0;
                            return hasColumnLines === this.option("showColumnLines")
                        },
                        _isColumnElementsEqual: function($columns, $virtualColumns) {
                            var result = $columns.length === $virtualColumns.length;
                            if (result)
                                $.each($columns, function(index, element) {
                                    if (element.style.width !== $virtualColumns[index].style.width) {
                                        result = false;
                                        return result
                                    }
                                });
                            return result
                        },
                        _renderVirtualTableContent: function(container, height) {
                            var that = this,
                                columns = that._columnsController.getVisibleColumns(),
                                html = that._createColGroup(columns).prop("outerHTML"),
                                freeSpaceCellsHtml = "",
                                i,
                                columnLinesClass = that.option("showColumnLines") ? DATAGRID_COLUMN_LINES_CLASS : "",
                                createFreeSpaceRowHtml = function(height) {
                                    return "<tr style='height:" + height + "px;' class='" + DATAGRID_FREESPACE_CLASS + " " + DATAGRID_ROW_CLASS + " " + columnLinesClass + "' >" + freeSpaceCellsHtml + "</tr>"
                                };
                            for (i = 0; i < columns.length; i++)
                                freeSpaceCellsHtml += columns[i].command === "expand" ? "<td class='" + DATAGRID_GROUP_SPACE_CLASS + "'/>" : "<td />";
                            while (height > PIXELS_LIMIT) {
                                html += createFreeSpaceRowHtml(PIXELS_LIMIT);
                                height -= PIXELS_LIMIT
                            }
                            html += createFreeSpaceRowHtml(height);
                            container.addClass(DATAGRID_TABLE_CLASS);
                            container.html(html)
                        },
                        _findBottomLoadPanel: function() {
                            var $element = this.element();
                            var $bottomLoadPanel = $element && $element.find("." + DATAGRID_BOTTOM_LOAD_PANEL_CLASS);
                            if ($bottomLoadPanel && $bottomLoadPanel.length)
                                return $bottomLoadPanel
                        },
                        _updateBottomLoading: function() {
                            var that = this,
                                scrollingMode = that.option("scrolling.mode"),
                                virtualMode = scrollingMode === SCROLLING_MODE_VIRTUAL,
                                appendMode = scrollingMode === SCROLLING_MODE_INFINITE,
                                showBottomLoading = !that._dataController.hasKnownLastPage() && that._dataController.isLoaded() && (virtualMode || appendMode),
                                bottomLoadPanelElement = that._findBottomLoadPanel();
                            if (showBottomLoading) {
                                if (!bottomLoadPanelElement)
                                    $("<div />").addClass(DATAGRID_BOTTOM_LOAD_PANEL_CLASS).append(that._createComponent($("<div />"), "dxLoadIndicator").element()).appendTo(that._findContentElement())
                            }
                            else if (bottomLoadPanelElement)
                                bottomLoadPanelElement.remove()
                        },
                        _handleScroll: function(e) {
                            var that = this;
                            if (that._hasHeight && that._rowHeight)
                                that._setViewportScrollTop(e.scrollOffset.top);
                            that.callBase.apply(that, arguments)
                        },
                        _setViewportScrollTop: function(scrollTop) {
                            var that = this,
                                scrollingTimeout = Math.min(that.option("scrolling.timeout") || 0, that._renderTime || 0);
                            clearTimeout(that._scrollTimeoutID);
                            if (scrollingTimeout > 0)
                                that._scrollTimeoutID = setTimeout(function() {
                                    that._setViewportScrollTopCore(scrollTop)
                                }, scrollingTimeout);
                            else
                                that._setViewportScrollTopCore(scrollTop)
                        },
                        _setViewportScrollTopCore: function(scrollTop) {
                            var that = this,
                                virtualItemsCount = that._dataController.virtualItemsCount(),
                                heightRatio = that._heightRatio || 1,
                                rowHeight = that._rowHeight,
                                beginHeight = virtualItemsCount ? Math.floor(virtualItemsCount.begin * rowHeight * heightRatio) : 0;
                            if (virtualItemsCount && scrollTop >= beginHeight && scrollTop <= beginHeight + that._contentTableHeight)
                                that._dataController.setViewportItemIndex(virtualItemsCount.begin + (scrollTop - beginHeight) / rowHeight);
                            else
                                that._dataController.setViewportItemIndex(scrollTop / (rowHeight * heightRatio))
                        },
                        _renderScrollableCore: function($element) {
                            var that = this;
                            that.callBase.apply(that, arguments);
                            that._subscribeToWindowScrollEvents($element)
                        },
                        _subscribeToWindowScrollEvents: function($element) {
                            var that = this,
                                $componentContainer = that.component.element(),
                                $scrollElement;
                            if (!$componentContainer)
                                return;
                            if (!that._windowScrollEvents) {
                                that._windowScrollEvents = true;
                                var createWindowScrollHandler = function($scrollElement, oldHandler) {
                                        var handler = function(e) {
                                                var scrollTop = $scrollElement.scrollTop();
                                                if (!that._hasHeight && that._rowHeight) {
                                                    scrollTop -= $element.offset().top;
                                                    scrollTop = scrollTop > 0 ? scrollTop : 0;
                                                    that._scrollTop = scrollTop;
                                                    that._setViewportScrollTop(scrollTop)
                                                }
                                            };
                                        if (oldHandler)
                                            return function(e) {
                                                    handler(e);
                                                    oldHandler(e)
                                                };
                                        return handler
                                    };
                                var subscribeToScrollEvents = function($scrollElement) {
                                        var dxScrollable = $scrollElement.data("dxScrollable"),
                                            isDocument = $scrollElement.get(0).nodeName === "#document",
                                            scrollHandler,
                                            oldScrollHandler;
                                        if (dxScrollable) {
                                            oldScrollHandler = dxScrollable.option("onScroll");
                                            scrollHandler = createWindowScrollHandler($scrollElement, oldScrollHandler);
                                            dxScrollable.option("onScroll", scrollHandler);
                                            that.on("disposing", function() {
                                                if (dxScrollable.option("onScroll") === scrollHandler)
                                                    dxScrollable.option("onScroll", oldScrollHandler)
                                            })
                                        }
                                        else if (isDocument || $scrollElement.css("overflow-y") === "auto") {
                                            if (isDocument)
                                                $scrollElement = $(window);
                                            scrollHandler = createWindowScrollHandler($scrollElement);
                                            $scrollElement.on("scroll", scrollHandler);
                                            that.on("disposing", function() {
                                                $scrollElement.off("scroll", scrollHandler)
                                            })
                                        }
                                    };
                                for ($scrollElement = that.component.element().parent(); $scrollElement.length; $scrollElement = $scrollElement.parent())
                                    subscribeToScrollEvents($scrollElement)
                            }
                        },
                        _needUpdateRowHeight: function(itemsCount) {
                            var that = this;
                            return that.callBase.apply(that, arguments) || itemsCount > 0 && that.option("scrolling.mode") === SCROLLING_MODE_INFINITE
                        },
                        _updateRowHeight: function() {
                            var that = this,
                                viewportHeight;
                            that.callBase.apply(that, arguments);
                            if (that._rowHeight) {
                                that._updateContentPosition();
                                viewportHeight = that._hasHeight ? that.element().outerHeight() : $(window).outerHeight();
                                that._dataController.viewportSize(Math.round(viewportHeight / that._rowHeight))
                            }
                        },
                        setLoading: function(isLoading, messageText) {
                            var that = this,
                                callBase = that.callBase,
                                hasBottomLoadPanel = !!that._findBottomLoadPanel() && that._dataController.isLoaded();
                            if (hasBottomLoadPanel)
                                isLoading = false;
                            callBase.call(that, isLoading, messageText)
                        },
                        _resizeCore: function() {
                            this.callBase();
                            var dataSource = this._dataController.dataSource();
                            if (dataSource && dataSource.loadIfNeed)
                                dataSource.loadIfNeed()
                        },
                        getTableElements: function(isVirtualTable) {
                            var result = this.callBase();
                            if (isVirtualTable && this.option("scrolling.mode") === "virtual")
                                result = result.add(this.element().find("> ." + DATAGRID_SCROLLABLE_CONTAINER + " > ." + DATAGRID_SCROLLABLE_CONTENT + "> ." + DATAGRID_CONTENT_CLASS).children(":not(." + DATAGRID_TABLE_CONTENT_CLASS + ")"));
                            return result
                        },
                        dispose: function() {
                            clearTimeout(this._scrollTimeoutID);
                            this.callBase()
                        }
                    }
            }();
        $.extend(dataGrid.__internals, {
            DATAGRID_BOTTOM_LOAD_PANEL_CLASS: DATAGRID_BOTTOM_LOAD_PANEL_CLASS,
            DATAGRID_TABLE_CONTENT_CLASS: DATAGRID_TABLE_CONTENT_CLASS
        });
        dataGrid.registerModule("virtualScrolling", {
            defaultOptions: function() {
                return {scrolling: {
                            timeout: 300,
                            mode: "standard",
                            preloadEnabled: false,
                            useNative: "auto"
                        }}
            },
            extenders: {
                controllers: {data: function() {
                        var members = {};
                        dataGrid.proxyMethod(members, "virtualItemsCount");
                        dataGrid.proxyMethod(members, "viewportSize");
                        dataGrid.proxyMethod(members, "setViewportItemIndex");
                        return members
                    }()},
                views: {rowsView: VirtualScrollingRowsViewExtender}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnHeadersView.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common");
        var DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_HEADERS_CLASS = "dx-datagrid-headers",
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            DATAGRID_NOWRAP_CLASS = "dx-datagrid-nowrap",
            DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
            DATAGRID_CONTEXT_MENU_SORT_ASC_ICON = "context-menu-sort-asc",
            DATAGRID_CONTEXT_MENU_SORT_DESC_ICON = "context-menu-sort-desc",
            DATAGRID_CONTEXT_MENU_SORT_NONE_ICON = "context-menu-sort-none",
            DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
            DATAGRID_COLUMN_INDICATORS_CLASS = "dx-column-indicators";
        var createCellContent = function($cell, showColumnLines) {
                return $("<div />").addClass(DATAGRID_CELL_CONTENT_CLASS).appendTo($cell)
            };
        dataGrid.ColumnHeadersView = dataGrid.ColumnsView.inherit({
            _getDefaultTemplate: function(column) {
                var that = this,
                    template,
                    showColumnLines = that.option("showColumnLines");
                if (column.command)
                    template = function($container, options) {
                        var column = options.column;
                        $container.html("&nbsp;");
                        $container.addClass(column.cssClass)
                    };
                else
                    template = function($container, options) {
                        var $content = createCellContent($container, showColumnLines);
                        $content.text(column.caption)
                    };
                return template
            },
            _getHeaderTemplate: function(column) {
                return !commonUtils.isDefined(column.command) && column.headerCellTemplate || {
                        allowRenderToDetachedContainer: true,
                        render: this._getDefaultTemplate(column)
                    }
            },
            _processTemplate: function(template, options) {
                var that = this,
                    resultTemplate,
                    column = options.column,
                    renderingTemplate = this.callBase(template);
                if (renderingTemplate && column.headerCellTemplate)
                    resultTemplate = {render: function(options, $container) {
                            var $content = createCellContent($container, that.option("showColumnLines"));
                            renderingTemplate.render(options, $content)
                        }};
                else
                    resultTemplate = renderingTemplate;
                return resultTemplate
            },
            _handleDataChanged: function(e) {
                if (this._isGroupingChanged || this._requireReady) {
                    this._isGroupingChanged = false;
                    this.render()
                }
            },
            _renderCell: function($row, options) {
                var $cell = this.callBase($row, options);
                if (options.row.rowType === "header") {
                    $cell.addClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS);
                    if (!commonUtils.isDefined(options.column.command)) {
                        this.setAria("role", "columnheader", $cell);
                        this.setAria("label", options.column.caption + " " + Globalize.localize("dxDataGrid-ariaColumn"), $cell)
                    }
                }
                return $cell
            },
            _createRow: function(row) {
                var $row = this.callBase(row).toggleClass(DATAGRID_COLUMN_LINES_CLASS, this.option("showColumnLines"));
                if (row.rowType === "header")
                    $row.addClass(DATAGRID_HEADER_ROW_CLASS);
                return $row
            },
            _renderCore: function() {
                var that = this,
                    $container = that.element();
                if (!that._dataController.isLoaded())
                    return;
                $container.addClass(DATAGRID_HEADERS_CLASS).toggleClass(DATAGRID_NOWRAP_CLASS, !that.option("wordWrapEnabled")).empty();
                that._setTableElement(that._renderTable());
                that.callBase.apply(that, arguments)
            },
            _resizeCore: function() {
                var that = this;
                var scrollLeft = that._scrollLeft;
                that.callBase();
                that._scrollLeft = 0;
                that.scrollTo({left: scrollLeft})
            },
            _renderTable: function() {
                var $table = this.callBase.apply(this, arguments),
                    $content = this.element();
                this.wrapTableInScrollContainer($table).appendTo($content);
                return $table
            },
            _getRows: function() {
                var result = [];
                if (this.option("showColumnHeaders"))
                    result.push({rowType: "header"});
                return result
            },
            _getCellTemplate: function(options) {
                if (options.rowType === "header")
                    return this._getHeaderTemplate(options.column)
            },
            _columnOptionChanged: function(e) {
                var changeTypes = e.changeTypes,
                    optionNames = e.optionNames,
                    showColumnLines = this.option("showColumnLines");
                if (changeTypes.grouping) {
                    this._isGroupingChanged = true;
                    return
                }
                this.callBase(e);
                if (optionNames.width || optionNames.visibleWidth) {
                    !showColumnLines && this._updateColumnTextWidths();
                    this.resizeCompleted.fire()
                }
            },
            _updateColumnTextWidths: function() {
                var that = this,
                    widths = [],
                    indicatorWidth,
                    $indicatorContainer,
                    columns = that.getColumns(),
                    $cells = that.getColumnElements();
                if (!$cells)
                    return;
                $.each(columns, function(index, column) {
                    indicatorWidth = 0;
                    $indicatorContainer = that._getIndicatorContainer($($cells[index]));
                    if ($indicatorContainer.length)
                        indicatorWidth = $indicatorContainer.outerWidth();
                    widths[index] = $($cells[index]).width() - (column.alignment === "center" ? indicatorWidth * 2 : indicatorWidth)
                });
                $.each($cells, function(index, cell) {
                    if (widths.length && widths[index] > 0)
                        $(cell).find("." + DATAGRID_CELL_CONTENT_CLASS).css("max-width", widths[index])
                })
            },
            _isElementVisible: function(elementOptions) {
                return elementOptions && elementOptions.visible
            },
            getHeadersRowHeight: function() {
                var tableElement = this._getTableElement();
                if (tableElement) {
                    var $headerRow = tableElement.find("." + DATAGRID_HEADER_ROW_CLASS).first();
                    return $headerRow && $headerRow.height()
                }
                return 0
            },
            getHeaderElement: function(index) {
                var columnElements = this.getColumnElements();
                return columnElements && columnElements.eq(index)
            },
            getColumnElements: function() {
                if (this.option("showColumnHeaders"))
                    return this.getCellElements(0)
            },
            getColumnWidths: function() {
                var that = this,
                    indicatorWidth,
                    $indicatorElements,
                    columns = that.getColumns(),
                    $columnElements = that.getColumnElements(),
                    resultWidths = that.callBase();
                if ($columnElements && resultWidths && $columnElements.length === resultWidths.length)
                    $.each($columnElements, function(index, columnElement) {
                        $indicatorElements = $(columnElement).find("." + DATAGRID_COLUMN_INDICATORS_CLASS);
                        if ($indicatorElements.length) {
                            indicatorWidth = $indicatorElements.outerWidth(true);
                            resultWidths[index] += columns[index].alignment === "center" ? indicatorWidth * 2 : indicatorWidth
                        }
                    });
                return resultWidths
            },
            allowDragging: function(column, draggingPanels) {
                var i,
                    columns = this.getColumns(),
                    draggableColumnCount = 0,
                    draggingPanel,
                    allowDrag = function(column) {
                        return column.allowReordering || column.allowGrouping || column.allowHiding
                    };
                for (i = 0; i < columns.length; i++)
                    if (allowDrag(columns[i]))
                        draggableColumnCount++;
                if (draggableColumnCount <= 1)
                    return false;
                else if (!draggingPanels)
                    return (this.option("allowColumnReordering") || this._columnsController.isColumnOptionUsed("allowReordering")) && column && column.allowReordering;
                for (i = 0; i < draggingPanels.length; i++) {
                    draggingPanel = draggingPanels[i];
                    if (draggingPanel && draggingPanel.allowDragging(column))
                        return true
                }
                return false
            },
            getBoundingRect: function() {
                var that = this,
                    offset,
                    $columnElements = that.getColumnElements();
                if ($columnElements && $columnElements.length) {
                    offset = that._getTableElement().offset();
                    return {top: offset.top}
                }
                return null
            },
            getName: function() {
                return "headers"
            },
            getColumnCount: function() {
                var $columnElements = this.getColumnElements();
                return $columnElements ? $columnElements.length : 0
            },
            init: function() {
                var that = this;
                that.callBase();
                that._scrollerWidth = 0
            },
            isVisible: function() {
                return this.option("showColumnHeaders")
            },
            setScrollerSpacing: function(width) {
                var that = this,
                    $element = that.element(),
                    rtlEnabled = that.option("rtlEnabled");
                that._scrollerWidth = width;
                $element && $element.css(rtlEnabled ? {paddingLeft: width} : {paddingRight: width})
            },
            optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"showColumnHeaders":
                    case"wordWrapEnabled":
                    case"showColumnLines":
                        that._invalidate(true, true);
                        args.handled = true;
                        break;
                    default:
                        that.callBase(args)
                }
            },
            getHeight: function() {
                var that = this,
                    $element = that.element();
                return $element ? $element.height() : 0
            },
            getContextMenuItems: function($targetElement) {
                var that = this,
                    $cell,
                    column,
                    onItemClick,
                    sortingOptions;
                if ($targetElement.closest("." + DATAGRID_HEADER_ROW_CLASS).length) {
                    $cell = $targetElement.closest("td");
                    column = $cell.length && that.getColumns($targetElement)[$cell[0].cellIndex];
                    sortingOptions = that.option("sorting");
                    if (sortingOptions && sortingOptions.mode !== "none" && column && column.allowSorting) {
                        onItemClick = function(params) {
                            setTimeout(function() {
                                that._columnsController.changeSortOrder(column.index, params.itemData.value)
                            })
                        };
                        return [{
                                    text: sortingOptions.ascendingText,
                                    value: "asc",
                                    disabled: column.sortOrder === "asc",
                                    icon: DATAGRID_CONTEXT_MENU_SORT_ASC_ICON,
                                    onItemClick: onItemClick
                                }, {
                                    text: sortingOptions.descendingText,
                                    value: "desc",
                                    disabled: column.sortOrder === "desc",
                                    icon: DATAGRID_CONTEXT_MENU_SORT_DESC_ICON,
                                    onItemClick: onItemClick
                                }, {
                                    text: sortingOptions.clearText,
                                    value: "none",
                                    disabled: !column.sortOrder,
                                    icon: DATAGRID_CONTEXT_MENU_SORT_NONE_ICON,
                                    onItemClick: onItemClick
                                }]
                    }
                    return []
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_HEADERS_CLASS: DATAGRID_HEADERS_CLASS,
            DATAGRID_HEADER_ROW_CLASS: DATAGRID_HEADER_ROW_CLASS,
            DATAGRID_NOWRAP_CLASS: DATAGRID_NOWRAP_CLASS
        });
        dataGrid.registerModule("columnHeaders", {
            defaultOptions: function() {
                return {
                        showColumnHeaders: true,
                        cellHintEnabled: true
                    }
            },
            views: {columnHeadersView: dataGrid.ColumnHeadersView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.filterRow.js */
    (function($, DX) {
        var ui = DX.ui,
            commonUtils = DX.require("/utils/utils.common"),
            dataGrid = ui.dxDataGrid,
            Editor = DX.require("/ui/ui.editor");
        var OPERATION_ICONS = {
                "=": "filter-operation-equals",
                "<>": "filter-operation-not-equals",
                "<": "filter-operation-less",
                "<=": "filter-operation-less-equal",
                ">": "filter-operation-greater",
                ">=": "filter-operation-greater-equal",
                "default": "filter-operation-default",
                notcontains: "filter-operation-not-contains",
                contains: "filter-operation-contains",
                startswith: "filter-operation-starts-with",
                endswith: "filter-operation-ends-with",
                between: "filter-operation-between"
            };
        var FILTERING_TIMEOUT = 700,
            DATAGRID_CLASS = "dx-datagrid",
            DATAGRID_FIRST_CELL_CLASS = "dx-first-cell",
            DATAGRID_FILTER_ROW_CLASS = "dx-datagrid-filter-row",
            DATAGRID_MENU_CLASS = "dx-menu",
            DATAGRID_MENU_IMAGE_CLASS = "dx-menu-image",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_EDITOR_WITH_MENU_CLASS = "dx-editor-with-menu",
            DATAGRID_EDITOR_CONTAINER_CLASS = "dx-editor-container",
            DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
            DATAGRID_FILTER_MENU = "dx-filter-menu",
            DATAGRID_APPLY_BUTTON_CLASS = "dx-apply-button",
            DATAGRID_HIGHLIGHT_OUTLINE_CLASS = "dx-highlight-outline",
            DATAGRID_FOCUSED_CLASS = "dx-focused",
            DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
            DATAGRID_FILTER_RANGE_POPUP_CLASS = "dx-datagrid-filter-range-popup",
            DATAGRID_FILTER_RANGE_CONTENT_CLASS = "dx-filter-range-content";
        var ColumnHeadersViewFilterRowExtender = function() {
                var getEditorInstance = function($editorContainer) {
                        var $editor = $editorContainer && $editorContainer.children(),
                            componentNames = $editor && $editor.data("dxComponents"),
                            editor = componentNames && componentNames.length && $editor.data(componentNames[0]);
                        if (editor instanceof Editor)
                            return editor
                    };
                var getRangeTextByFilterValue = function(column) {
                        var filterValue = column.filterValue,
                            result = "";
                        if (commonUtils.isArray(filterValue)) {
                            result = dataGrid.formatValue(filterValue[0], column);
                            if (dataGrid.formatValue(filterValue[1], column) !== "")
                                result += " - " + dataGrid.formatValue(filterValue[1], column)
                        }
                        else if (commonUtils.isDefined(filterValue))
                            result = dataGrid.formatValue(filterValue, column);
                        return result === "" ? "&nbsp;" : result
                    };
                var getFilterValue = function(that, columnIndex, $editorContainer) {
                        var column = that._columnsController.columnOption(columnIndex),
                            filterValue = column && column.filterValue,
                            isFiltrerRange = $editorContainer.closest("." + DATAGRID_FILTER_RANGE_POPUP_CLASS).length;
                        if (filterValue && commonUtils.isArray(filterValue))
                            if (isFiltrerRange)
                                return filterValue[1];
                            else
                                return filterValue[0];
                        return !isFiltrerRange ? filterValue : undefined
                    };
                var normalizeFilterValue = function(filterValue, column, $editorContainer) {
                        if (column.selectedFilterOperation === "between")
                            if ($editorContainer.closest("." + DATAGRID_FILTER_RANGE_POPUP_CLASS).length)
                                return [commonUtils.isArray(column.filterValue) ? column.filterValue[0] : column.filterValue, filterValue];
                            else
                                return [filterValue, commonUtils.isArray(column.filterValue) ? column.filterValue[1] : undefined];
                        return filterValue
                    };
                var updateFilterValue = function(that, options) {
                        var value = options.value === "" ? undefined : options.value,
                            $editorContainer = options.container,
                            column = that._columnsController.columnOption(options.column.index),
                            filterValue = getFilterValue(that, column.index, $editorContainer);
                        if (!commonUtils.isDefined(filterValue) && !commonUtils.isDefined(value))
                            return;
                        if (filterValue !== value)
                            that._applyingFilter = !that._applyFilterViewController._isOnClick();
                        that._applyFilterViewController.setHighLight($editorContainer, filterValue !== value);
                        that._columnsController.columnOption(column.index, "filterValue", normalizeFilterValue(value, column, $editorContainer))
                    };
                return {
                        _updateEditorValue: function(column, $editorContainer) {
                            var that = this,
                                editor = getEditorInstance($editorContainer);
                            editor && editor.option("value", getFilterValue(that, column.index, $editorContainer))
                        },
                        _columnOptionChanged: function(e) {
                            var that = this,
                                optionNames = e.optionNames,
                                popupInstance,
                                visibleIndex,
                                column,
                                $cell,
                                $editorContainer,
                                $editorRange,
                                $rangeContent,
                                $menu;
                            if (dataGrid.checkChanges(optionNames, ["filterValue", "selectedFilterOperation"]) && e.columnIndex !== undefined) {
                                visibleIndex = that.getController("columns").getVisibleIndex(e.columnIndex);
                                column = that.getController("columns").columnOption(e.columnIndex);
                                $cell = that.element().find("." + DATAGRID_FILTER_ROW_CLASS).children().eq(visibleIndex);
                                $rangeContent = $cell.find("." + DATAGRID_FILTER_RANGE_CONTENT_CLASS);
                                $editorContainer = $cell.find("." + DATAGRID_EDITOR_CONTAINER_CLASS).first();
                                if (optionNames.filterValue) {
                                    that._updateEditorValue(column, $editorContainer);
                                    popupInstance = $cell.find("." + DATAGRID_FILTER_RANGE_POPUP_CLASS).data("dxPopup");
                                    if (popupInstance) {
                                        $editorRange = popupInstance.content().find("." + DATAGRID_EDITOR_CONTAINER_CLASS).first();
                                        that._updateEditorValue(column, $editorRange)
                                    }
                                    $rangeContent.length && $rangeContent.html(getRangeTextByFilterValue(column))
                                }
                                if (optionNames.selectedFilterOperation)
                                    if (visibleIndex >= 0 && column) {
                                        $menu = $cell.find("." + DATAGRID_MENU_CLASS);
                                        if ($menu.length) {
                                            that._updateFilterOperationChooser($menu, column, $editorContainer);
                                            if (column.selectedFilterOperation === "between")
                                                that._showFilterRangePopup($cell, column);
                                            else if ($editorContainer.find("." + DATAGRID_FILTER_RANGE_CONTENT_CLASS).length) {
                                                that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, column));
                                                that._hideFilterRangePopup()
                                            }
                                        }
                                    }
                                return
                            }
                            that.callBase(e)
                        },
                        _resizeCore: function() {
                            this.callBase.apply(this, arguments);
                            this._filterRangePopupInstance && this._filterRangePopupInstance.repaint()
                        },
                        isFilterRowVisible: function() {
                            return this._isElementVisible(this.option("filterRow"))
                        },
                        isVisible: function() {
                            return this.callBase() || this.isFilterRowVisible()
                        },
                        init: function() {
                            this.callBase();
                            this._applyFilterViewController = this.getController("applyFilter")
                        },
                        _initFilterRangePopup: function($cell, column) {
                            var that = this,
                                $popup = $("<div/>").addClass(DATAGRID_FILTER_RANGE_POPUP_CLASS).appendTo($cell);
                            return this._createComponent($popup, "dxPopup", {
                                    height: "auto",
                                    shading: false,
                                    showTitle: false,
                                    closeOnTargetScroll: true,
                                    closeOnOutsideClick: function(e) {
                                        return !$cell.find($(e.target)).length
                                    },
                                    animation: false,
                                    position: {
                                        my: "top",
                                        at: "bottom",
                                        of: $cell,
                                        offset: "0 1"
                                    },
                                    contentTemplate: function(contentElement) {
                                        var $editorContainer = $("<div/>").addClass(DATAGRID_EDITOR_CONTAINER_CLASS).appendTo(contentElement);
                                        that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, column));
                                        $editorContainer.find("input").on("keydown", function(e) {
                                            var $prevElement = $cell.find("[tabindex]").not(e.target).first();
                                            if (e.which === 9) {
                                                e.preventDefault();
                                                that._hideFilterRangePopup();
                                                if (e.shiftKey) {
                                                    if (!$prevElement.length)
                                                        $prevElement = $cell.prev().find("[tabindex]").last();
                                                    $prevElement.focus()
                                                }
                                                else
                                                    $cell.next().find("[tabindex]").first().focus()
                                            }
                                        });
                                        return contentElement
                                    },
                                    onShowing: function(e) {
                                        var $endEditorInput = e.component.overlayContent().find("input"),
                                            $editorContainer = $cell.find("." + DATAGRID_EDITOR_CONTAINER_CLASS).first(),
                                            updatedColumn = that._columnsController.columnOption(column.index);
                                        $editorContainer.closest("." + DATAGRID_EDITOR_WITH_MENU_CLASS).removeClass(DATAGRID_EDITOR_WITH_MENU_CLASS);
                                        that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, updatedColumn));
                                        $editorContainer.find("input").on("keydown", function(e) {
                                            if (e.which === 9) {
                                                e.preventDefault();
                                                $endEditorInput.focus()
                                            }
                                        })
                                    },
                                    onShown: function() {
                                        var $editorContainer = $cell.find("." + DATAGRID_EDITOR_CONTAINER_CLASS).first();
                                        that._focusEditor($editorContainer)
                                    },
                                    onHidden: function() {
                                        var updatedColumn = that._columnsController.columnOption(column.index);
                                        $cell.find("." + DATAGRID_MENU_CLASS).parent().addClass(DATAGRID_EDITOR_WITH_MENU_CLASS);
                                        if (updatedColumn.selectedFilterOperation === "between") {
                                            that._renderFilterRangeContent($cell, updatedColumn);
                                            that.component.updateDimensions()
                                        }
                                    }
                                })
                        },
                        _updateFilterRangePopup: function(options) {
                            var popupInstance = this._filterRangePopupInstance;
                            popupInstance && popupInstance.option(options)
                        },
                        _showFilterRangePopup: function($cell, column) {
                            var that = this,
                                $popup = $cell.children("." + DATAGRID_FILTER_RANGE_POPUP_CLASS),
                                popupInstance = $popup.length && $popup.data("dxPopup");
                            if (!popupInstance && column)
                                popupInstance = that._initFilterRangePopup($cell, column);
                            if (!popupInstance.option("visible")) {
                                that._filterRangePopupInstance && that._filterRangePopupInstance.hide();
                                that._filterRangePopupInstance = popupInstance;
                                that._updateFilterRangePopup({width: $cell.outerWidth(true)});
                                that._filterRangePopupInstance && that._filterRangePopupInstance.show()
                            }
                        },
                        _hideFilterRangePopup: function() {
                            var popupInstance = this._filterRangePopupInstance;
                            popupInstance && popupInstance.hide()
                        },
                        getFilterRangePopupInstance: function() {
                            return this._filterRangePopupInstance
                        },
                        _createRow: function(row) {
                            var $row = this.callBase(row);
                            if (row.rowType === "filter")
                                $row.addClass(DATAGRID_FILTER_ROW_CLASS);
                            return $row
                        },
                        _getRows: function() {
                            var result = this.callBase();
                            if (this.isFilterRowVisible())
                                result.push({rowType: "filter"});
                            return result
                        },
                        _renderCellContent: function($cell, options) {
                            var that = this,
                                column = options.column,
                                $container,
                                $editorContainer;
                            if (options.rowType === "filter") {
                                $cell.toggleClass(DATAGRID_FIRST_CELL_CLASS, options.columnIndex === 0);
                                if (column.command)
                                    $cell.html("&nbsp;");
                                else if (column.allowFiltering) {
                                    that.setAria("label", Globalize.localize("dxDataGrid-ariaColumn") + " " + column.caption + ", " + Globalize.localize("dxDataGrid-ariaFilterCell"), $cell);
                                    $cell.addClass(DATAGRID_EDITOR_CELL_CLASS);
                                    $container = $("<div />").appendTo($cell);
                                    $editorContainer = $("<div />").addClass(DATAGRID_EDITOR_CONTAINER_CLASS).appendTo($container);
                                    if (column.selectedFilterOperation === "between")
                                        that._renderFilterRangeContent($cell, column);
                                    else
                                        that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, column));
                                    if (column.alignment)
                                        $cell.find("input").first().css("text-align", column.alignment);
                                    if (column.filterOperations && column.filterOperations.length)
                                        that._renderFilterOperationChooser($container, column, $editorContainer)
                                }
                            }
                            that.callBase($cell, options)
                        },
                        _getEditorOptions: function($editorContainer, column) {
                            var that = this,
                                result = $.extend({}, column, {
                                    value: getFilterValue(that, column.index, $editorContainer),
                                    parentType: "filterRow",
                                    showAllText: that.option("filterRow.showAllText"),
                                    updateValueTimeout: that.option("filterRow.applyFilter") === "onClick" ? 0 : FILTERING_TIMEOUT,
                                    width: null,
                                    setValue: function(value) {
                                        updateFilterValue(that, {
                                            column: column,
                                            value: value,
                                            container: $editorContainer
                                        })
                                    }
                                });
                            if (column.selectedFilterOperation === "between")
                                if (!$editorContainer.closest("." + DATAGRID_FILTER_RANGE_POPUP_CLASS).length)
                                    result.placeholder = that.option("filterRow.betweenStartText");
                                else
                                    result.placeholder = that.option("filterRow.betweenEndText");
                            return result
                        },
                        _renderEditor: function($editorContainer, options) {
                            $editorContainer.empty();
                            return this.getController("editorFactory").createEditor($("<div />").appendTo($editorContainer), options)
                        },
                        _renderFilterRangeContent: function($cell, column) {
                            var that = this,
                                $editorContainer = $cell.find("." + DATAGRID_EDITOR_CONTAINER_CLASS).first();
                            $editorContainer.empty();
                            $("<div/>").addClass(DATAGRID_FILTER_RANGE_CONTENT_CLASS).attr("tabindex", 0).html(getRangeTextByFilterValue(column)).on("focusin", function(e) {
                                that._showFilterRangePopup($cell, column)
                            }).appendTo($editorContainer)
                        },
                        _updateFilterOperationChooser: function($menu, column, $editorContainer) {
                            var that = this,
                                isCellWasFocused;
                            that._createComponent($menu, "dxMenu", {
                                _templates: {},
                                activeStateEnabled: false,
                                selectionMode: "single",
                                cssClass: DATAGRID_CLASS + " " + DATAGRID_CELL_FOCUS_DISABLED_CLASS + " " + DATAGRID_FILTER_MENU,
                                showFirstSubmenuMode: "onHover",
                                hideSubmenuOnMouseLeave: true,
                                items: [{
                                        disabled: column.filterOperations && column.filterOperations.length ? false : true,
                                        icon: OPERATION_ICONS[column.selectedFilterOperation || "default"],
                                        selectable: false,
                                        items: that._getFilterOperationMenuItems(column)
                                    }],
                                onItemClick: function(properties) {
                                    var selectedFilterOperation = properties.itemData.name;
                                    if (properties.itemData.items || selectedFilterOperation === column.selectedFilterOperation)
                                        return;
                                    if (selectedFilterOperation)
                                        that._columnsController.columnOption(column.index, "selectedFilterOperation", selectedFilterOperation);
                                    else
                                        that._columnsController.columnOption(column.index, {
                                            selectedFilterOperation: column.defaultSelectedFilterOperation,
                                            filterValue: undefined
                                        });
                                    that._applyFilterViewController.setHighLight($editorContainer, true);
                                    that._focusEditor($editorContainer)
                                },
                                onSubmenuShown: function() {
                                    isCellWasFocused = that._isEditorFocused($editorContainer);
                                    that.getController("editorFactory").loseFocus()
                                },
                                onSubmenuHiding: function(e) {
                                    $menu.blur();
                                    $menu.dxMenu("instance").option("focusedElement", null);
                                    isCellWasFocused && that._focusEditor($editorContainer)
                                },
                                rtlEnabled: that.option("rtlEnabled")
                            })
                        },
                        _isEditorFocused: function($container) {
                            return $container.hasClass(DATAGRID_FOCUSED_CLASS) || $container.parents("." + DATAGRID_FOCUSED_CLASS).length
                        },
                        _focusEditor: function($container, showCellFocus) {
                            this.getController("editorFactory").focus($container);
                            $container.find("input").focus()
                        },
                        _renderFilterOperationChooser: function($container, column, $editorContainer) {
                            var that = this,
                                $menu;
                            if (that.option("filterRow.showOperationChooser")) {
                                $container.addClass(DATAGRID_EDITOR_WITH_MENU_CLASS);
                                $menu = $("<div />").prependTo($container);
                                that._updateFilterOperationChooser($menu, column, $editorContainer)
                            }
                        },
                        _getFilterOperationMenuItems: function(column) {
                            var that = this,
                                result = [{}],
                                filterRowOptions = that.option("filterRow"),
                                operationDescriptions = filterRowOptions && filterRowOptions.operationDescriptions || {};
                            if (column.filterOperations && column.filterOperations.length) {
                                result = $.map(column.filterOperations, function(value) {
                                    return {
                                            name: value,
                                            selected: (column.selectedFilterOperation || column.defaultFilterOperation) === value,
                                            text: operationDescriptions[value],
                                            icon: OPERATION_ICONS[value]
                                        }
                                });
                                result.push({
                                    name: null,
                                    text: filterRowOptions && filterRowOptions.resetOperationText,
                                    icon: OPERATION_ICONS["default"]
                                })
                            }
                            return result
                        },
                        optionChanged: function(args) {
                            var that = this;
                            switch (args.name) {
                                case"filterRow":
                                case"showColumnLines":
                                    this._invalidate(true, true);
                                    args.handled = true;
                                    break;
                                default:
                                    that.callBase(args);
                                    break
                            }
                        }
                    }
            }();
        var DataControllerFilterRowExtender = {_calculateAdditionalFilter: function() {
                    var that = this,
                        filters = [that.callBase()],
                        columns = that._columnsController.getVisibleColumns();
                    $.each(columns, function() {
                        var filter;
                        if (this.allowFiltering && this.calculateFilterExpression && commonUtils.isDefined(this.filterValue)) {
                            filter = this.createFilterExpression(this.filterValue, this.selectedFilterOperation || this.defaultFilterOperation, "filterRow");
                            filters.push(filter)
                        }
                    });
                    return dataGrid.combineFilters(filters)
                }};
        dataGrid.ApplyFilterViewController = dataGrid.ViewController.inherit({
            _isOnClick: function() {
                return this.option("filterRow.applyFilter") === "onClick"
            },
            _getHeaderPanel: function() {
                if (!this._headerPanel)
                    this._headerPanel = this.getView("headerPanel");
                return this._headerPanel
            },
            setHighLight: function($element, value) {
                if (this._isOnClick()) {
                    $element && $element.toggleClass(DATAGRID_HIGHLIGHT_OUTLINE_CLASS, value);
                    this._getHeaderPanel().enableApplyButton(value)
                }
            },
            removeHighLights: function() {
                if (this._isOnClick()) {
                    var columnHeadersView = this.getView("columnHeadersView");
                    columnHeadersView.element().find("." + DATAGRID_FILTER_ROW_CLASS + " ." + DATAGRID_HIGHLIGHT_OUTLINE_CLASS).removeClass(DATAGRID_HIGHLIGHT_OUTLINE_CLASS);
                    this._getHeaderPanel().enableApplyButton(false)
                }
            }
        });
        dataGrid.registerModule("filterRow", {
            defaultOptions: function() {
                return {filterRow: {
                            visible: false,
                            showOperationChooser: true,
                            showAllText: Globalize.localize("dxDataGrid-filterRowShowAllText"),
                            resetOperationText: Globalize.localize("dxDataGrid-filterRowResetOperationText"),
                            applyFilter: "auto",
                            applyFilterText: Globalize.localize("dxDataGrid-applyFilterText"),
                            operationDescriptions: {
                                "=": Globalize.localize("dxDataGrid-filterRowOperationEquals"),
                                "<>": Globalize.localize("dxDataGrid-filterRowOperationNotEquals"),
                                "<": Globalize.localize("dxDataGrid-filterRowOperationLess"),
                                "<=": Globalize.localize("dxDataGrid-filterRowOperationLessOrEquals"),
                                ">": Globalize.localize("dxDataGrid-filterRowOperationGreater"),
                                ">=": Globalize.localize("dxDataGrid-filterRowOperationGreaterOrEquals"),
                                startswith: Globalize.localize("dxDataGrid-filterRowOperationStartsWith"),
                                contains: Globalize.localize("dxDataGrid-filterRowOperationContains"),
                                notcontains: Globalize.localize("dxDataGrid-filterRowOperationNotContains"),
                                endswith: Globalize.localize("dxDataGrid-filterRowOperationEndsWith"),
                                between: Globalize.localize("dxDataGrid-filterRowOperationBetween")
                            },
                            betweenStartText: Globalize.localize("dxDataGrid-filterRowOperationBetweenStartText"),
                            betweenEndText: Globalize.localize("dxDataGrid-filterRowOperationBetweenEndText")
                        }}
            },
            controllers: {applyFilter: dataGrid.ApplyFilterViewController},
            extenders: {
                controllers: {
                    data: DataControllerFilterRowExtender,
                    columnsResizer: {
                        _startResizing: function() {
                            var that = this,
                                cellIndex,
                                popupInstance;
                            that.callBase.apply(that, arguments);
                            if (that.isResizing()) {
                                popupInstance = that._columnHeadersView.getFilterRangePopupInstance();
                                if (popupInstance) {
                                    cellIndex = popupInstance.element().closest("td").index();
                                    if (cellIndex === that._targetPoint.columnIndex || cellIndex === that._targetPoint.columnIndex + 1)
                                        popupInstance.overlayContent().hide()
                                }
                            }
                        },
                        _endResizing: function(args) {
                            var that = this,
                                $cell,
                                popupInstance;
                            if (that.isResizing()) {
                                popupInstance = that._columnHeadersView.getFilterRangePopupInstance();
                                if (popupInstance) {
                                    $cell = popupInstance.element().closest("td");
                                    that._columnHeadersView._updateFilterRangePopup({width: $cell.outerWidth(true)});
                                    popupInstance.overlayContent().show()
                                }
                            }
                            that.callBase.apply(that, arguments)
                        }
                    }
                },
                views: {
                    columnHeadersView: ColumnHeadersViewFilterRowExtender,
                    headerPanel: {
                        _isShowApplyFilterButton: function() {
                            var filterRowOptions = this.option("filterRow");
                            return filterRowOptions && filterRowOptions.visible && filterRowOptions.applyFilter === "onClick"
                        },
                        _renderCore: function() {
                            var that = this,
                                disabled = that._applyButton ? that._applyButton.option("disabled") : true;
                            that.callBase();
                            that._$applyButton && that._$applyButton.remove();
                            if (that._isShowApplyFilterButton()) {
                                that._applyButton = that._createComponent($("<div>").addClass(DATAGRID_APPLY_BUTTON_CLASS).appendTo(that.element()), "dxButton", {
                                    disabled: disabled,
                                    hint: that.option("filterRow.applyFilterText"),
                                    icon: "apply-filter",
                                    onClick: function() {
                                        that._dataController._applyFilter();
                                        that._applyFilterViewController.removeHighLights()
                                    }
                                });
                                that._$applyButton = that._applyButton.element()
                            }
                        },
                        init: function() {
                            this.callBase();
                            this._dataController = this.getController("data");
                            this._applyFilterViewController = this.getController("applyFilter")
                        },
                        enableApplyButton: function(value) {
                            this._applyButton && this._applyButton.option("disabled", !value)
                        },
                        isVisible: function() {
                            return this.callBase() || this._isShowApplyFilterButton()
                        },
                        optionChanged: function(args) {
                            if (args.name === "filterRow") {
                                this._invalidate();
                                args.handled = true
                            }
                            else
                                this.callBase(args)
                        }
                    }
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_FILTER_ROW_CLASS: DATAGRID_FILTER_ROW_CLASS,
            DATAGRID_MENU_CLASS: DATAGRID_MENU_CLASS,
            DATAGRID_MENU_IMAGE_CLASS: DATAGRID_MENU_IMAGE_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_EDITOR_WITH_MENU_CLASS: DATAGRID_EDITOR_WITH_MENU_CLASS,
            DATAGRID_EDITOR_CONTAINER_CLASS: DATAGRID_EDITOR_CONTAINER_CLASS,
            DATAGRID_HIGHLIGHT_OUTLINE_CLASS: DATAGRID_HIGHLIGHT_OUTLINE_CLASS,
            DATAGRID_APPLY_BUTTON_CLASS: DATAGRID_APPLY_BUTTON_CLASS
        });
        dataGrid.ColumnHeadersViewFilterRowExtender = ColumnHeadersViewFilterRowExtender;
        dataGrid.DataControllerFilterRowExtender = DataControllerFilterRowExtender
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.headerPanel.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_HEADER_PANEL_CLASS = "dx-datagrid-header-panel";
        dataGrid.HeaderPanel = dataGrid.ColumnsView.inherit({
            _renderCore: function() {
                this.element().addClass(DATAGRID_HEADER_PANEL_CLASS)
            },
            getHeaderPanel: function() {
                return this.element()
            },
            getHeight: function() {
                var $element = this.element();
                return $element ? $element.outerHeight(true) : 0
            },
            isVisible: function() {
                return false
            }
        });
        $.extend(dataGrid.__internals, {DATAGRID_HEADER_PANEL_CLASS: DATAGRID_HEADER_PANEL_CLASS});
        dataGrid.registerModule("headerPanel", {
            defaultOptions: function() {
                return {}
            },
            views: {headerPanel: dataGrid.HeaderPanel}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.headerFilter.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common");
        var DATAGRID_HEADER_FILTER_CLASS = "dx-header-filter",
            DATAGRID_HEADER_FILTER_MENU_CLASS = "dx-header-filter-menu",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATE_INTERVAL_FORMATS = {
                month: {
                    format: 'month',
                    dateType: 'full'
                },
                quarter: {
                    format: 'quarter',
                    dateType: 'full'
                },
                dayOfWeek: {
                    format: 'dayOfWeek',
                    dateType: 'full'
                }
            };
        var allowHeaderFiltering = function(column) {
                return commonUtils.isDefined(column.allowHeaderFiltering) ? column.allowHeaderFiltering : column.allowFiltering
            };
        dataGrid.HeaderFilterController = dataGrid.ViewController.inherit(function() {
            var getFormatOptions = function(value, column, currentLevel) {
                    var groupInterval = dataGrid.getGroupInterval(column),
                        result = $.extend({target: "headerFilter"}, column);
                    if (groupInterval) {
                        result.groupInterval = groupInterval[currentLevel];
                        if (column.dataType === "date")
                            result.format = DATE_INTERVAL_FORMATS[groupInterval[currentLevel]];
                        else if (column.dataType === "number")
                            result.getDisplayFormat = function() {
                                var formatOptions = {
                                        format: column.format,
                                        precision: column.precision
                                    },
                                    firstValueText = dataGrid.formatValue(value, formatOptions),
                                    secondValue = value + groupInterval[currentLevel],
                                    secondValueText = dataGrid.formatValue(secondValue, formatOptions);
                                return firstValueText && secondValueText ? firstValueText + " - " + secondValueText : ""
                            }
                    }
                    return result
                };
            return {
                    init: function() {
                        this._columnsController = this.getController("columns");
                        this._dataController = this.getController("data");
                        this._headerFilterView = this.getView("headerFilterView")
                    },
                    _updateSelectedState: function(items, column) {
                        var i = items.length;
                        while (i--) {
                            if (dataGrid.getIndexByKey(items[i].value, column.filterValues, null) > -1 ^ column.filterType === "exclude")
                                items[i].selected = true;
                            if ("items" in items[i])
                                this._updateSelectedState(items[i].items, column)
                        }
                    },
                    _normalizeGroupItem: function(item, currentLevel, options) {
                        var value,
                            displayValue,
                            path = options.path,
                            valueSelector = options.valueSelector,
                            displaySelector = options.displaySelector,
                            column = options.column;
                        if (valueSelector && displaySelector) {
                            value = valueSelector(item);
                            displayValue = displaySelector(item)
                        }
                        else {
                            value = item.key;
                            displayValue = value
                        }
                        item = commonUtils.isObject(item) ? item : {};
                        path.push(value);
                        if (path.length === 1)
                            item.value = path[0];
                        else
                            item.value = path.join("/");
                        item.text = dataGrid.formatValue(displayValue, getFormatOptions(displayValue, column, currentLevel));
                        if (!item.text)
                            item.text = options.headerFilterOptions.texts.emptyValue;
                        delete item.key;
                        return item
                    },
                    _processGroupItems: function(groupItems, currentLevel, path, options) {
                        var that = this,
                            displaySelector,
                            valueSelector,
                            column = options.column,
                            lookup = column.lookup,
                            level = options.level;
                        path = path || [];
                        currentLevel = currentLevel || 0;
                        if (lookup) {
                            displaySelector = DX.data.utils.compileGetter(lookup.displayExpr);
                            valueSelector = DX.data.utils.compileGetter(lookup.valueExpr)
                        }
                        for (var i = 0; i < groupItems.length; i++) {
                            groupItems[i] = that._normalizeGroupItem(groupItems[i], currentLevel, {
                                column: options.column,
                                headerFilterOptions: options.headerFilterOptions,
                                displaySelector: displaySelector,
                                valueSelector: valueSelector,
                                path: path
                            });
                            if ("items" in groupItems[i])
                                if (currentLevel === level || !commonUtils.isDefined(groupItems[i].value))
                                    delete groupItems[i].items;
                                else
                                    that._processGroupItems(groupItems[i].items, currentLevel + 1, path, options);
                            path.pop()
                        }
                    },
                    getDataSource: function(column) {
                        var that = this,
                            cutoffLevel,
                            origPostProcess,
                            group = $.proxy(column.calculateGroupValue, column) || dataGrid.getGroupDataSourceParameters(column),
                            dataSource = that._dataController.dataSource(),
                            headerFilterDataSource = column.headerFilter && column.headerFilter.dataSource,
                            store = dataSource.store(),
                            headerFilterOptions = that.option("headerFilter"),
                            options = {component: that.component};
                        if (commonUtils.isDefined(headerFilterDataSource) && !commonUtils.isFunction(headerFilterDataSource)) {
                            dataSource = DX.data.utils.normalizeDataSourceOptions(headerFilterDataSource);
                            dataSource.postProcess = function(items) {
                                that._updateSelectedState(items, column);
                                return items
                            };
                            return dataSource
                        }
                        if (column.lookup) {
                            dataSource = DX.data.utils.normalizeDataSourceOptions(column.lookup.dataSource);
                            dataSource.postProcess = function(items) {
                                if (this.pageIndex() === 0) {
                                    items = items.slice(0);
                                    items.unshift(null)
                                }
                                that._processGroupItems(items, null, null, {
                                    level: 0,
                                    column: column,
                                    headerFilterOptions: headerFilterOptions
                                });
                                that._updateSelectedState(items, column);
                                return items
                            };
                            options.dataSource = dataSource
                        }
                        else {
                            cutoffLevel = commonUtils.isArray(group) ? group.length - 1 : 0;
                            that._currentColumn = column;
                            if (column.dataType === "date")
                                group = group;
                            else
                                group = group;
                            options.dataSource = {
                                filter: that._dataController.getCombinedFilter(),
                                group: group,
                                load: function(options) {
                                    var d = $.Deferred();
                                    $.when(options.userData.data || store.load({
                                        filter: options.filter,
                                        expand: dataSource.loadOptions().expand,
                                        dataField: column.dataField || column.name
                                    })).done(function(data) {
                                        options.userData.data = data;
                                        new DX.data.ArrayStore(data).load(options).done(function(data) {
                                            that._processGroupItems(data, null, null, {
                                                level: cutoffLevel,
                                                column: column,
                                                headerFilterOptions: headerFilterOptions
                                            });
                                            that._updateSelectedState(data, column);
                                            that._currentColumn = null;
                                            d.resolve(data)
                                        }).fail(d.reject)
                                    }).fail(d.reject);
                                    return d
                                }
                            }
                        }
                        if (commonUtils.isFunction(headerFilterDataSource)) {
                            headerFilterDataSource.call(column, options);
                            origPostProcess = options.dataSource.postProcess;
                            options.dataSource.postProcess = function(data) {
                                var items = origPostProcess && origPostProcess.apply(this, arguments) || data;
                                that._updateSelectedState(items, column);
                                return items
                            }
                        }
                        return options.dataSource
                    },
                    getCurrentColumn: function() {
                        return this._currentColumn
                    },
                    showHeaderFilterMenu: function(columnIndex) {
                        var that = this,
                            column = $.extend(true, {}, that._columnsController.getColumns()[columnIndex]);
                        if (column) {
                            var visibleIndex = that._columnsController.getVisibleIndex(columnIndex),
                                isGroupColumn = column && commonUtils.isDefined(column.groupIndex),
                                view = isGroupColumn ? that.getView("headerPanel") : that.getView("columnHeadersView"),
                                $columnElement = view.getColumnElements().eq(isGroupColumn ? column.groupIndex : visibleIndex),
                                groupInterval = dataGrid.getGroupInterval(column);
                            var options = $.extend(column, {
                                    type: groupInterval && groupInterval.length > 1 ? "tree" : "list",
                                    apply: function() {
                                        that._columnsController.columnOption(columnIndex, {
                                            filterValues: this.filterValues,
                                            filterType: this.filterType
                                        })
                                    },
                                    onShowing: function(e) {
                                        var dxResizableInstance = e.component.overlayContent().dxResizable("instance");
                                        dxResizableInstance && dxResizableInstance.option("onResizeEnd", function(e) {
                                            var columnsController = that.getController("columns"),
                                                headerFilterByColumn = columnsController.columnOption(options.dataField, "headerFilter");
                                            headerFilterByColumn = headerFilterByColumn || {};
                                            headerFilterByColumn.width = e.width;
                                            headerFilterByColumn.height = e.height;
                                            columnsController.columnOption(options.dataField, "headerFilter", headerFilterByColumn, true)
                                        })
                                    }
                                });
                            options.dataSource = that.getDataSource(options);
                            that._headerFilterView.showHeaderFilterMenu($columnElement, options)
                        }
                    },
                    hideHeaderFilterMenu: function() {
                        this._headerFilterView.hideHeaderFilterMenu()
                    }
                }
        }());
        dataGrid.HeaderFilterView = dataGrid.View.inherit({
            getPopupContainer: function() {
                return this._popupContainer
            },
            getListContainer: function() {
                return this._listContainer
            },
            applyHeaderFilter: function(options) {
                var that = this,
                    list = that.getListContainer(),
                    isSelectAll = list.element().find(".dx-checkbox").eq(0).hasClass("dx-checkbox-checked"),
                    filterValues = [];
                var fillSelectedItemKeys = function(filterValues, items, isExclude) {
                        $.each(items, function() {
                            if (!!this.selected ^ isExclude)
                                filterValues.push(this.value);
                            else if (this.items && this.items.length)
                                fillSelectedItemKeys(filterValues, this.items)
                        })
                    };
                if (!isSelectAll) {
                    if (options.type === "tree") {
                        fillSelectedItemKeys(filterValues, list.option("items"), options.filterType === "exclude");
                        options.filterValues = filterValues
                    }
                    options.apply()
                }
                else if (commonUtils.isArray(options.filterValues)) {
                    options.filterValues = [];
                    options.apply()
                }
                that.hideHeaderFilterMenu()
            },
            showHeaderFilterMenu: function($columnElement, options) {
                var that = this,
                    popupContainer;
                if (options) {
                    that._initializePopupContainer(options);
                    popupContainer = that.getPopupContainer();
                    that.hideHeaderFilterMenu();
                    that.updatePopup($columnElement, options);
                    popupContainer.show()
                }
            },
            hideHeaderFilterMenu: function() {
                var headerFilterMenu = this.getPopupContainer();
                headerFilterMenu && headerFilterMenu.hide()
            },
            updatePopup: function($element, options) {
                var that = this,
                    alignment = options.alignment === "right" ? "left" : "right";
                if (that._popupContainer) {
                    that._cleanPopupContent();
                    that._popupContainer.option("position", {
                        my: alignment + " top",
                        at: alignment + " bottom",
                        of: $element,
                        collision: "flip fit"
                    })
                }
            },
            _cleanPopupContent: function() {
                this._popupContainer && this._popupContainer.content().empty()
            },
            _initializePopupContainer: function(options) {
                var that = this,
                    $element = that.element(),
                    headerFilterOptions = that.option("headerFilter"),
                    width = options.headerFilter && options.headerFilter.width || headerFilterOptions && headerFilterOptions.width,
                    height = options.headerFilter && options.headerFilter.height || headerFilterOptions && headerFilterOptions.height,
                    dxPopupOptions = {
                        width: width,
                        height: height,
                        visible: false,
                        shading: false,
                        showTitle: false,
                        showCloseButton: false,
                        closeOnTargetScroll: true,
                        closeOnOutsideClick: true,
                        onShown: function() {
                            that._initializeListContainer(options)
                        },
                        buttons: [{
                                toolbar: "bottom",
                                location: "after",
                                widget: "button",
                                options: {
                                    text: headerFilterOptions.texts.ok,
                                    onClick: function() {
                                        that.applyHeaderFilter(options)
                                    }
                                }
                            }, {
                                toolbar: "bottom",
                                location: "after",
                                widget: "button",
                                options: {
                                    text: headerFilterOptions.texts.cancel,
                                    onClick: function() {
                                        that.hideHeaderFilterMenu()
                                    }
                                }
                            }],
                        resizeEnabled: true,
                        onShowing: options.onShowing
                    };
                if (!commonUtils.isDefined(that._popupContainer))
                    that._popupContainer = that._createComponent($element, "dxPopup", dxPopupOptions);
                else
                    that._popupContainer.option(dxPopupOptions)
            },
            _initializeListContainer: function(options) {
                var that = this,
                    $content = that._popupContainer.content(),
                    widgetOptions = {
                        dataSource: options.dataSource,
                        onContentReady: function() {
                            that.renderCompleted.fire()
                        }
                    };
                if (options.type === "tree")
                    that._listContainer = that._createComponent($("<div/>").appendTo($content), "dxTreeView", $.extend(widgetOptions, {
                        showCheckBoxesMode: 'selectAll',
                        keyExpr: "id"
                    }));
                else
                    that._listContainer = that._createComponent($("<div/>").appendTo($content), "dxList", $.extend(widgetOptions, {
                        pageLoadMode: "scrollBottom",
                        pullRefreshEnabled: true,
                        showSelectionControls: true,
                        selectionMode: "all",
                        itemTemplate: function(data, _, elem) {
                            return elem.text(data.text)
                        },
                        onSelectionChanged: function(e) {
                            var items = e.component.option("items"),
                                selectedItems = e.component.option("selectedItems");
                            if (!e.component._selectedItemsUpdating)
                                if (selectedItems.length === 0 && items.length) {
                                    options.filterType = "include";
                                    options.filterValues = []
                                }
                                else if (selectedItems.length === items.length) {
                                    options.filterType = "exclude";
                                    options.filterValues = []
                                }
                            $.each(items, function(index, item) {
                                var selected = dataGrid.getIndexByKey(item, selectedItems, null) >= 0,
                                    oldSelected = !!item.selected,
                                    filterValueIndex;
                                if (oldSelected !== selected) {
                                    item.selected = selected;
                                    options.filterValues = options.filterValues || [];
                                    filterValueIndex = dataGrid.getIndexByKey(item.value, options.filterValues, null);
                                    if (filterValueIndex >= 0)
                                        options.filterValues.splice(filterValueIndex, 1);
                                    if (selected ^ options.filterType === "exclude")
                                        options.filterValues.push(item.value)
                                }
                            })
                        },
                        onContentReady: function(e) {
                            var component = e.component,
                                items = component.option("items"),
                                selectedItems = [],
                                selectAllCheckBox = e.element.find(".dx-list-select-all-checkbox").dxCheckBox("instance");
                            $.each(items, function() {
                                if (this.selected)
                                    selectedItems.push(this)
                            });
                            component._selectedItemsUpdating = true;
                            component.option("selectedItems", selectedItems);
                            component._selectedItemsUpdating = false;
                            if (options.filterValues && options.filterValues.length)
                                selectAllCheckBox.option("value", undefined)
                        }
                    }))
            },
            _renderCore: function(options) {
                this.element().addClass(DATAGRID_HEADER_FILTER_MENU_CLASS)
            },
            init: function() {
                this._headerFilterController = this.getController("headerFilter")
            }
        });
        var headerFilterMixin = dataGrid.headerFilterMixin = {
                _applyColumnState: function(options) {
                    var $headerFilterIndicator,
                        rootElement = options.rootElement,
                        column = options.column;
                    if (options.name === "headerFilter") {
                        rootElement.find("." + DATAGRID_HEADER_FILTER_CLASS).remove();
                        if (allowHeaderFiltering(column))
                            $headerFilterIndicator = this.callBase(options).toggleClass("dx-header-filter-empty", !column.filterValues || !column.filterValues.length);
                        return $headerFilterIndicator
                    }
                    return this.callBase(options)
                },
                _renderIndicator: function(options) {
                    var rtlEnabled,
                        $container = options.container,
                        $indicator = options.indicator;
                    if (options.name === "headerFilter") {
                        rtlEnabled = this.option("rtlEnabled");
                        if ($container.children().length && (!rtlEnabled && options.columnAlignment === "right" || rtlEnabled && options.columnAlignment === "left")) {
                            $container.prepend($indicator);
                            return
                        }
                    }
                    this.callBase(options)
                },
                optionChanged: function(args) {
                    if (args.name === "headerFilter") {
                        this._invalidate();
                        args.handled = true
                    }
                    else
                        this.callBase(args)
                }
            };
        var ColumnHeadersViewHeaderFilterExtender = $.extend({}, headerFilterMixin, {
                _renderCellContent: function($cell, options) {
                    var that = this,
                        $headerFilterIndicator,
                        column = options.column;
                    that.callBase($cell, options);
                    if (!column.command && !commonUtils.isDefined(column.groupIndex) && allowHeaderFiltering(column) && that.option("headerFilter.visible") && options.rowType === "header") {
                        $headerFilterIndicator = that._applyColumnState({
                            name: "headerFilter",
                            rootElement: $cell,
                            column: column,
                            showColumnLines: that.option("showColumnLines")
                        });
                        $headerFilterIndicator && that._subscribeToIndicatorEvent($headerFilterIndicator, column, "headerFilter")
                    }
                },
                _subscribeToIndicatorEvent: function($indicator, column, indicatorName) {
                    var that = this;
                    if (indicatorName === "headerFilter")
                        $indicator.on("dxclick", that.createAction(function(e) {
                            var event = e.jQueryEvent;
                            event.stopPropagation();
                            that.getController("headerFilter").showHeaderFilterMenu(column.index)
                        }))
                },
                _updateIndicator: function($cell, column, indicatorName) {
                    var $indicator = this.callBase($cell, column, indicatorName);
                    $indicator && this._subscribeToIndicatorEvent($indicator, column, indicatorName)
                },
                _columnOptionChanged: function(e) {
                    var optionNames = e.optionNames;
                    if (dataGrid.checkChanges(optionNames, ["filterValues", "filterType"])) {
                        this._updateIndicators("headerFilter");
                        return
                    }
                    this.callBase(e)
                }
            });
        var HeaderPanelHeaderFilterExtender = $.extend({}, headerFilterMixin, {_createGroupPanelItem: function($rootElement, groupColumn) {
                    var that = this,
                        $item = that.callBase.apply(that, arguments),
                        $headerFilterIndicator;
                    if (!groupColumn.command && allowHeaderFiltering(groupColumn) && that.option("headerFilter.visible")) {
                        $headerFilterIndicator = that._applyColumnState({
                            name: "headerFilter",
                            rootElement: $item,
                            column: {
                                alignment: commonUtils.getDefaultAlignment(that.option("rtlEnabled")),
                                filterValues: groupColumn.filterValues,
                                allowHeaderFiltering: true
                            },
                            showColumnLines: true
                        });
                        $headerFilterIndicator && $headerFilterIndicator.on("dxclick", that.createAction(function(e) {
                            var event = e.jQueryEvent;
                            event.stopPropagation();
                            that.getController("headerFilter").showHeaderFilterMenu(groupColumn.index)
                        }))
                    }
                    return $item
                }});
        var DataControllerFilterRowExtender = {_calculateAdditionalFilter: function() {
                    var that = this,
                        filters = [that.callBase()],
                        columns = that._columnsController.getVisibleColumns(),
                        headerFilterController = that.getController("headerFilter"),
                        currentColumn = headerFilterController.getCurrentColumn();
                    $.each(columns, function(_, column) {
                        var filter;
                        if (currentColumn && currentColumn.index === column.index)
                            return;
                        if (allowHeaderFiltering(column) && column.calculateFilterExpression && commonUtils.isArray(column.filterValues) && column.filterValues.length) {
                            var filterValues = [],
                                isExclude = column.filterType === "exclude";
                            $.each(column.filterValues, function(_, filterValue) {
                                if (commonUtils.isArray(filterValue))
                                    filter = filterValue;
                                else {
                                    if (column.deserializeValue && column.dataType !== "date" && column.dataType !== "number")
                                        filterValue = column.deserializeValue(filterValue);
                                    filter = column.createFilterExpression(filterValue, isExclude ? "<>" : "=", "headerFilter")
                                }
                                filter.columnIndex = column.index;
                                if (filterValues.length > 0)
                                    filterValues.push(isExclude ? "and" : "or");
                                filterValues.push(filter)
                            });
                            filters.push(filterValues)
                        }
                    });
                    return dataGrid.combineFilters(filters)
                }};
        dataGrid.registerModule("headerFilter", {
            defaultOptions: function() {
                return {headerFilter: {
                            visible: false,
                            width: 252,
                            height: 300,
                            texts: {
                                emptyValue: Globalize.localize("dxDataGrid-headerFilterEmptyValue"),
                                ok: Globalize.localize("dxDataGrid-headerFilterOK"),
                                cancel: Globalize.localize("dxDataGrid-headerFilterCancel")
                            }
                        }}
            },
            controllers: {headerFilter: dataGrid.HeaderFilterController},
            views: {headerFilterView: dataGrid.HeaderFilterView},
            extenders: {
                controllers: {data: DataControllerFilterRowExtender},
                views: {
                    columnHeadersView: ColumnHeadersViewHeaderFilterExtender,
                    headerPanel: HeaderPanelHeaderFilterExtender
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_HEADER_FILTER_CLASS: DATAGRID_HEADER_FILTER_CLASS,
            DATAGRID_HEADER_FILTER_MENU_CLASS: DATAGRID_HEADER_FILTER_MENU_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.sortingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var DATAGRID_SORT_CLASS = "dx-sort",
            DATAGRID_SORTUP_CLASS = "dx-sort-up",
            DATAGRID_SORTDOWN_CLASS = "dx-sort-down",
            DATAGRID_HEADERS_ACTION_CLASS = "dx-datagrid-action",
            DATAGRID_COLUMN_INDICATORS_CLASS = "dx-column-indicators",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            COLUMN_HEADERS_VIEW_NAMESPACE = "dxDataGridColumnHeadersView";
        var sortingMixin = dataGrid.sortingMixin = {
                _applyColumnState: function(options) {
                    var that = this,
                        side,
                        sortingMode = that.option("sorting.mode"),
                        rootElement = options.rootElement,
                        column = options.column,
                        $indicatorsContainer = rootElement.find("." + DATAGRID_COLUMN_INDICATORS_CLASS);
                    if (options.name === "sort") {
                        side = that.option("rtlEnabled") ? "right" : "left";
                        if ((sortingMode === "single" || sortingMode === "multiple") && column.allowSorting)
                            options.rootElement.addClass(DATAGRID_HEADERS_ACTION_CLASS);
                        rootElement.find("." + DATAGRID_SORT_CLASS).remove();
                        !$indicatorsContainer.children().length && $indicatorsContainer.remove();
                        rootElement.children("." + DATAGRID_CELL_CONTENT_CLASS).css("margin-" + side, "");
                        if (commonUtils.isDefined(column.sortOrder)) {
                            var ariaSortState = column.sortOrder === "asc" ? "ascending" : "descending";
                            that.setAria("sort", ariaSortState, rootElement);
                            var $sortIndicator = that.callBase(options).toggleClass(DATAGRID_SORTUP_CLASS, column.sortOrder === "asc").toggleClass(DATAGRID_SORTDOWN_CLASS, column.sortOrder === "desc");
                            if (column.alignment === "center")
                                rootElement.children("." + DATAGRID_CELL_CONTENT_CLASS).css("margin-" + side, $sortIndicator.outerWidth(true));
                            return $sortIndicator
                        }
                        else
                            that.setAria("sort", "none", rootElement)
                    }
                    else
                        return that.callBase(options)
                },
                _renderIndicator: function(options) {
                    var rtlEnabled,
                        $container = options.container,
                        $indicator = options.indicator;
                    if (options.name === "sort") {
                        rtlEnabled = this.option("rtlEnabled");
                        if ($container.children().length && (!rtlEnabled && options.columnAlignment === "left" || rtlEnabled && options.columnAlignment === "right")) {
                            $container.prepend($indicator);
                            return
                        }
                    }
                    this.callBase(options)
                },
                _updateIndicator: function($cell, column, indicatorName) {
                    if (indicatorName === "sort" && commonUtils.isDefined(column.groupIndex))
                        return;
                    this.callBase.apply(this, arguments)
                }
            };
        var ColumnHeadersViewSortingExtender = $.extend({}, sortingMixin, {
                _createRow: function(row) {
                    var that = this,
                        $row = that.callBase(row);
                    if (row.rowType === "header")
                        $row.on(eventUtils.addNamespace("dxclick", COLUMN_HEADERS_VIEW_NAMESPACE), "> td", that.createAction(function(e) {
                            var keyName = null,
                                event = e.jQueryEvent,
                                $cellElement = $(event.currentTarget),
                                columnIndex = $cellElement.index(),
                                visibleColumns = that._columnsController.getVisibleColumns(),
                                column = visibleColumns[columnIndex];
                            if (column && !commonUtils.isDefined(column.groupIndex) && !column.command) {
                                if (event.shiftKey)
                                    keyName = "shift";
                                else if (event.ctrlKey)
                                    keyName = "ctrl";
                                setTimeout(function() {
                                    that._columnsController.changeSortOrder(column.index, keyName)
                                })
                            }
                        }));
                    return $row
                },
                _renderCellContent: function($cell, options) {
                    var that = this,
                        column = options.column;
                    that.callBase($cell, options);
                    if (!column.command && options.rowType === "header")
                        that._applyColumnState({
                            name: "sort",
                            rootElement: $cell,
                            column: column,
                            showColumnLines: that.option("showColumnLines")
                        })
                },
                _columnOptionChanged: function(e) {
                    var changeTypes = e.changeTypes;
                    if (changeTypes.length === 1 && changeTypes.sorting) {
                        this._updateIndicators("sort");
                        return
                    }
                    this.callBase(e)
                },
                optionChanged: function(args) {
                    var that = this;
                    switch (args.name) {
                        case"sorting":
                            that._invalidate();
                            args.handled = true;
                            break;
                        default:
                            that.callBase(args)
                    }
                }
            });
        var HeaderPanelSortingExtender = $.extend({}, sortingMixin, {
                _createGroupPanelItem: function($rootElement, groupColumn) {
                    var that = this,
                        $item = that.callBase.apply(that, arguments);
                    $item.on(eventUtils.addNamespace("dxclick", "dxDataGridHeaderPanel"), that.createAction(function(e) {
                        setTimeout(function() {
                            that.getController("columns").changeSortOrder(groupColumn.index)
                        })
                    }));
                    that._applyColumnState({
                        name: "sort",
                        rootElement: $item,
                        column: {
                            alignment: that.option("rtlEnabled") ? "right" : "left",
                            allowSorting: groupColumn.allowSorting,
                            sortOrder: groupColumn.sortOrder === "desc" ? "desc" : "asc"
                        },
                        showColumnLines: true
                    });
                    return $item
                },
                optionChanged: function(args) {
                    var that = this;
                    switch (args.name) {
                        case"sorting":
                            that._invalidate();
                            args.handled = true;
                            break;
                        default:
                            that.callBase(args)
                    }
                }
            });
        dataGrid.registerModule("sorting", {
            defaultOptions: function() {
                return {sorting: {
                            mode: "single",
                            ascendingText: Globalize.localize("dxDataGrid-sortingAscendingText"),
                            descendingText: Globalize.localize("dxDataGrid-sortingDescendingText"),
                            clearText: Globalize.localize("dxDataGrid-sortingClearText")
                        }}
            },
            extenders: {views: {
                    columnHeadersView: ColumnHeadersViewSortingExtender,
                    headerPanel: HeaderPanelSortingExtender
                }}
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_SORT_CLASS: DATAGRID_SORT_CLASS,
            DATAGRID_SORTUP_CLASS: DATAGRID_SORTUP_CLASS,
            DATAGRID_SORTDOWN_CLASS: DATAGRID_SORTDOWN_CLASS,
            DATAGRID_HEADERS_ACTION_CLASS: DATAGRID_HEADERS_ACTION_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.search.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            selectors = DX.require("/integration/jquery/jquery.selectors");
        var DATAGRID_SEARCH_PANEL_CLASS = "dx-datagrid-search-panel",
            DATAGRID_SEARCH_TEXT_CLASS = "dx-datagrid-search-text",
            FILTERING_TIMEOUT = 700;
        function allowSearch(column) {
            return commonUtils.isDefined(column.allowSearch) ? column.allowSearch : column.allowFiltering
        }
        function parseValue(column, text) {
            var lookup = column.lookup;
            if (lookup)
                return column.parseValue.call(lookup, text);
            else
                return column.parseValue ? column.parseValue(text) : text
        }
        dataGrid.registerModule("search", {
            defaultOptions: function() {
                return {searchPanel: {
                            visible: false,
                            width: 160,
                            placeholder: Globalize.localize("dxDataGrid-searchPanelPlaceholder"),
                            highlightSearchText: true,
                            text: ""
                        }}
            },
            extenders: {
                controllers: {data: function() {
                        var calculateSearchFilter = function(that, text) {
                                var i,
                                    column,
                                    columns = that._columnsController.getColumns(),
                                    filterValue,
                                    lookup,
                                    filters = [];
                                if (!text)
                                    return null;
                                function onQueryDone(items) {
                                    var i,
                                        valueGetter = DX.data.utils.compileGetter(lookup.valueExpr),
                                        value;
                                    for (i = 0; i < items.length; i++) {
                                        value = valueGetter(items[i]);
                                        filters.push(column.createFilterExpression(value, null, "search"))
                                    }
                                }
                                for (i = 0; i < columns.length; i++) {
                                    column = columns[i];
                                    if (allowSearch(column) && column.calculateFilterExpression) {
                                        lookup = column.lookup;
                                        filterValue = parseValue(column, text);
                                        if (lookup && lookup.items)
                                            DX.data.query(lookup.items).filter(column.createFilterExpression.call({
                                                dataField: lookup.displayExpr,
                                                dataType: lookup.dataType,
                                                calculateFilterExpression: column.calculateFilterExpression
                                            }, filterValue, null, "search")).enumerate().done(onQueryDone);
                                        else if (filterValue !== undefined)
                                            filters.push(column.createFilterExpression(filterValue, null, "search"))
                                    }
                                }
                                return dataGrid.combineFilters(filters, "or")
                            };
                        return {
                                publicMethods: function() {
                                    return this.callBase().concat(["searchByText"])
                                },
                                _calculateAdditionalFilter: function() {
                                    var that = this,
                                        filter = that.callBase(),
                                        searchFilter = calculateSearchFilter(that, that.option("searchPanel.text"));
                                    return dataGrid.combineFilters([filter, searchFilter])
                                },
                                searchByText: function(text) {
                                    this.option("searchPanel.text", text)
                                },
                                optionChanged: function(args) {
                                    var that = this;
                                    switch (args.fullName) {
                                        case"searchPanel.text":
                                        case"searchPanel":
                                            that._applyFilter();
                                            args.handled = true;
                                            break;
                                        default:
                                            that.callBase(args)
                                    }
                                }
                            }
                    }()},
                views: {
                    headerPanel: function() {
                        var getSearchPanelOptions = function(that) {
                                return that.option("searchPanel")
                            };
                        return {
                                _renderSearchPanel: function() {
                                    var that = this,
                                        $element = that.element(),
                                        dataController = that.getController("data"),
                                        searchPanelOptions = getSearchPanelOptions(that);
                                    if (searchPanelOptions && searchPanelOptions.visible) {
                                        if (!that._$searchPanel) {
                                            that._$searchPanel = $("<div/>").addClass(DATAGRID_SEARCH_PANEL_CLASS).prependTo($element);
                                            that.setAria("label", Globalize.localize("dxDataGrid-ariaSearchInGrid"), that._$searchPanel)
                                        }
                                        else
                                            that._$searchPanel.show();
                                        that.getController("editorFactory").createEditor(that._$searchPanel, {
                                            width: searchPanelOptions.width,
                                            placeholder: searchPanelOptions.placeholder,
                                            parentType: "searchPanel",
                                            value: that.option("searchPanel.text"),
                                            updateValueTimeout: FILTERING_TIMEOUT,
                                            setValue: function(value) {
                                                dataController.searchByText(value)
                                            }
                                        });
                                        that.resize()
                                    }
                                    else
                                        that._$searchPanel && that._$searchPanel.hide()
                                },
                                _renderCore: function() {
                                    this.callBase();
                                    this._renderSearchPanel()
                                },
                                focus: function() {
                                    var textBox = this._$searchPanel.dxTextBox("instance");
                                    if (textBox)
                                        textBox.focus()
                                },
                                isVisible: function() {
                                    var searchPanelOptions = getSearchPanelOptions(this);
                                    return this.callBase() || searchPanelOptions && searchPanelOptions.visible
                                },
                                optionChanged: function(args) {
                                    if (args.name === "searchPanel") {
                                        this._renderSearchPanel();
                                        args.handled = true
                                    }
                                    else
                                        this.callBase(args)
                                }
                            }
                    }(),
                    rowsView: {
                        _highlightSearchText: function(cellElement, isEquals, column) {
                            var that = this,
                                $parent,
                                searchHTML,
                                searchText = that.option("searchPanel.text");
                            if (searchText && that.option("searchPanel.highlightSearchText")) {
                                if (isEquals && column) {
                                    var value = parseValue(column, searchText);
                                    searchText = dataGrid.formatValue(value, column);
                                    if (!searchText)
                                        return
                                }
                                searchHTML = $("<div>").text(searchText).html();
                                $parent = cellElement.parent();
                                if (!$parent.length)
                                    $parent = $("<div>").append(cellElement);
                                $.each($parent.find(selectors.icontains + "('" + searchText + "')"), function(index, element) {
                                    $.each($(element).contents(), function(index, content) {
                                        if (content.nodeType !== 3)
                                            return;
                                        var highlightSearchTextInTextNode = function($content, searchText) {
                                                var $searchTextSpan = $("<span />").addClass(DATAGRID_SEARCH_TEXT_CLASS),
                                                    text = $content.text(),
                                                    index = text.toLowerCase().indexOf(searchText.toLowerCase());
                                                if (index >= 0) {
                                                    if ($content[0].textContent)
                                                        $content[0].textContent = text.substr(0, index);
                                                    else
                                                        $content[0].nodeValue = text.substr(0, index);
                                                    $content.after($searchTextSpan.text(text.substr(index, searchText.length)));
                                                    $content = $(document.createTextNode(text.substr(index + searchText.length))).insertAfter($searchTextSpan);
                                                    return highlightSearchTextInTextNode($content, searchText)
                                                }
                                            };
                                        if (isEquals) {
                                            if ($(content).text().toLowerCase() === searchText.toLowerCase())
                                                $(this).replaceWith($("<span />").addClass(DATAGRID_SEARCH_TEXT_CLASS).text($(content).text()))
                                        }
                                        else
                                            highlightSearchTextInTextNode($(content), searchText)
                                    })
                                })
                            }
                        },
                        _renderCore: function($table, options) {
                            this.callBase.apply(this, arguments);
                            if (this.option("rowTemplate"))
                                this._highlightSearchText(this._getTableElement())
                        },
                        _updateCell: function($cell, parameters) {
                            var that = this,
                                column = parameters.column,
                                isEquals = column.dataType !== "string";
                            if (allowSearch(column))
                                that._highlightSearchText($cell, isEquals, column);
                            that.callBase($cell, parameters)
                        }
                    }
                }
            }
        });
        dataGrid.__internals = $.extend({}, dataGrid.__internals, {
            DATAGRID_SEARCH_PANEL_CLASS: DATAGRID_SEARCH_PANEL_CLASS,
            DATAGRID_SEARCH_TEXT_CLASS: DATAGRID_SEARCH_TEXT_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.rowsView.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            support = DX.require("/utils/utils.support"),
            removeEvent = DX.require("/ui/events/ui.events.remove"),
            ko = window.ko;
        var DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
            DATAGRID_ROWS_VIEW_CLASS = "dx-datagrid-rowsview",
            DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_DATA_ROW_CLASS = "dx-data-row",
            DATAGRID_FREESPACE_CLASS = "dx-freespace-row",
            DATAGRID_NODATA_TEXT_CLASS = "dx-datagrid-nodata",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_NOWRAP_CLASS = "dx-datagrid-nowrap",
            DATAGRID_ROW_LINES_CLASS = "dx-row-lines",
            DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
            DATAGRID_ROW_ALTERNATION_CLASS = "dx-row-alt",
            DATAGRID_LAST_ROW_BORDER = "dx-last-row-border",
            DATAGRID_LOADPANEL_HIDE_TIMEOUT = 200,
            DATAGRID_SPACE_REGEXP = /\s/g;
        var createScrollableOptions = function(that) {
                var scrollingOptions = that.option("scrolling"),
                    useNativeScrolling = that.option("scrolling.useNative");
                var options = $.extend({}, scrollingOptions, {
                        direction: "both",
                        bounceEnabled: false,
                        useKeyboard: false
                    });
                if (useNativeScrolling === undefined)
                    useNativeScrolling = true;
                if (useNativeScrolling === "auto") {
                    delete options.useNative;
                    delete options.useSimulatedScrollbar
                }
                else {
                    options.useNative = !!useNativeScrolling;
                    options.useSimulatedScrollbar = !useNativeScrolling
                }
                return options
            };
        dataGrid.createScrollableOptions = createScrollableOptions;
        dataGrid.RowsView = dataGrid.ColumnsView.inherit({
            _getDefaultTemplate: function(column) {
                switch (column.command) {
                    case"empty":
                        return function(container) {
                                container.html("&nbsp;")
                            };
                    default:
                        return function($container, options) {
                                var isDataTextEmpty = (!options.text || !options.text.replace(DATAGRID_SPACE_REGEXP, "")) && options.rowType === "data",
                                    text = isDataTextEmpty ? "&nbsp;" : options.text,
                                    container = $container.get(0);
                                if (column.encodeHtml && !isDataTextEmpty)
                                    if ("textContent" in container)
                                        container.textContent = text;
                                    else
                                        container.innerText = text;
                                else
                                    container.innerHTML = text
                            }
                }
            },
            _getDefaultGroupTemplate: function() {
                var that = this,
                    summaryTexts = that.option("summary.texts");
                return function(container, options) {
                        var data = options.data,
                            text = options.column.caption + ": " + options.text;
                        if (options.summaryItems && options.summaryItems.length)
                            text += " " + dataGrid.getGroupRowSummaryText(options.summaryItems, summaryTexts);
                        if (data)
                            if (options.groupContinuedMessage && options.groupContinuesMessage)
                                text += " (" + options.groupContinuedMessage + ". " + options.groupContinuesMessage + ")";
                            else if (options.groupContinuesMessage)
                                text += " (" + options.groupContinuesMessage + ")";
                            else if (options.groupContinuedMessage)
                                text += " (" + options.groupContinuedMessage + ")";
                        container.addClass("dx-group-cell");
                        container.text(text)
                    }
            },
            _update: function(change){},
            _getColumnTemplate: function(options) {
                var that = this,
                    column = options.column,
                    template;
                if (options.rowType === "group" && column.groupIndex !== undefined && !column.showWhenGrouped)
                    template = column.groupCellTemplate || {
                        allowRenderToDetachedContainer: true,
                        render: that._getDefaultGroupTemplate()
                    };
                else
                    template = column.cellTemplate || {
                        allowRenderToDetachedContainer: true,
                        render: that._getDefaultTemplate(column)
                    };
                return template
            },
            _getCellTemplate: function(options) {
                return this._getColumnTemplate(options)
            },
            _createRow: function(row) {
                var $row = this.callBase(row),
                    isGroup,
                    isDataRow,
                    isRowExpanded;
                if (row) {
                    isGroup = row.rowType === "group";
                    isDataRow = row.rowType === "data";
                    isDataRow && $row.addClass(DATAGRID_DATA_ROW_CLASS);
                    isDataRow && row.dataIndex % 2 === 1 && this.option("rowAlternationEnabled") && $row.addClass(DATAGRID_ROW_ALTERNATION_CLASS);
                    isDataRow && this.option("showRowLines") && $row.addClass(DATAGRID_ROW_LINES_CLASS);
                    this.option("showColumnLines") && $row.addClass(DATAGRID_COLUMN_LINES_CLASS);
                    if (isGroup) {
                        $row.addClass(DATAGRID_GROUP_ROW_CLASS);
                        isRowExpanded = row.isExpanded;
                        this.setAria("role", "rowgroup", $row);
                        this.setAria("expanded", commonUtils.isDefined(isRowExpanded) && isRowExpanded.toString(), $row)
                    }
                }
                return $row
            },
            _afterRowPrepared: function(e) {
                var arg = e.args[0],
                    context = e.context,
                    dataController = this._dataController,
                    values;
                if (!arg.data || arg.rowType !== "data" || !this.option("twoWayBindingEnabled"))
                    return;
                if (context.$watch) {
                    var watcher = context.$watch(function() {
                            return dataController.generateDataValues(arg.data, arg.columns)
                        }, function(oldValue, newValue) {
                            if (oldValue !== newValue) {
                                watcher();
                                dataController.updateItems({
                                    changeType: "update",
                                    rowIndices: [arg.rowIndex]
                                })
                            }
                        }, true);
                    arg.rowElement.on(removeEvent.name, function() {
                        watcher()
                    })
                }
                else if (support.hasKo)
                    ko.computed(function() {
                        if (values)
                            dataController.updateItems({
                                changeType: "update",
                                rowIndices: [arg.rowIndex]
                            });
                        values = dataController.generateDataValues(arg.data, arg.columns)
                    }, null, {disposeWhenNodeIsRemoved: arg.rowElement.get(0)})
            },
            _renderScrollable: function($table) {
                var that = this,
                    $element = that.element();
                if (!$element.children().length)
                    $element.append("<div />");
                that._renderLoadPanel($element);
                that._renderScrollableCore($element)
            },
            _handleScroll: function(e) {
                var that = this;
                that._scrollTop = e.scrollOffset.top;
                that._scrollLeft = e.scrollOffset.left;
                that.scrollChanged.fire(e.scrollOffset, that.name)
            },
            _renderScrollableCore: function($element) {
                var that = this,
                    dxScrollableOptions = createScrollableOptions(that),
                    scrollHandler = $.proxy(that._handleScroll, that);
                dxScrollableOptions.onScroll = scrollHandler;
                dxScrollableOptions.onStop = scrollHandler;
                that._scrollable = that._createComponent($element, "dxScrollable", dxScrollableOptions);
                that._scrollableContainer = that._scrollable._$container
            },
            _renderLoadPanel: function($element) {
                var that = this,
                    loadPanelOptions;
                if ($element.dxLoadPanel) {
                    that._loadPanel && that._loadPanel.element().remove();
                    loadPanelOptions = that.option("loadPanel");
                    if (loadPanelOptions && loadPanelOptions.enabled) {
                        loadPanelOptions = $.extend({
                            shading: false,
                            message: loadPanelOptions.text,
                            position: {of: $element},
                            container: $element
                        }, loadPanelOptions);
                        that._loadPanel = that._createComponent($("<div />").appendTo($element.parent()), "dxLoadPanel", loadPanelOptions)
                    }
                    else
                        that._loadPanel = null
                }
            },
            _renderContent: function(contentElement, tableElement) {
                contentElement.replaceWith($("<div>").addClass(DATAGRID_CONTENT_CLASS).append(tableElement));
                return this._findContentElement()
            },
            _updateContent: function(contentElement, change, newTableElement) {
                var that = this,
                    tableElement = that._getTableElement(),
                    changeType = change && change.changeType,
                    executors = [];
                switch (changeType) {
                    case"update":
                        $.each(change.rowIndices, function(index, rowIndex) {
                            var $newRowElement = that._getRowElements(newTableElement).eq(index),
                                changeType = change.changeTypes[index],
                                item = change.items && change.items[index];
                            executors.push(function() {
                                var $rowsElement = that._getRowElements(),
                                    $rowElement = $rowsElement.eq(rowIndex);
                                switch (changeType) {
                                    case"update":
                                        if (commonUtils.isDefined(item.visible) && item.visible !== $rowElement.is(":visible"))
                                            $rowElement.toggle(item.visible);
                                        else
                                            $rowElement.replaceWith($newRowElement);
                                        break;
                                    case"insert":
                                        if (!$rowsElement.length)
                                            $newRowElement.prependTo(tableElement);
                                        else if ($rowElement.length)
                                            $newRowElement.insertBefore($rowElement);
                                        else
                                            $newRowElement.insertAfter($rowsElement.last());
                                        break;
                                    case"remove":
                                        $rowElement.remove();
                                        break
                                }
                            })
                        });
                        $.each(executors, function() {
                            this()
                        });
                        newTableElement.remove();
                        break;
                    default:
                        that._setTableElement(newTableElement);
                        contentElement.addClass(DATAGRID_CONTENT_CLASS);
                        that._renderContent(contentElement, newTableElement);
                        break
                }
            },
            _renderFreeSpaceRow: function(tableElement) {
                var that = this,
                    i,
                    freeSpaceRowElement = that._createRow(),
                    columns = this.getColumns();
                freeSpaceRowElement.addClass(DATAGRID_FREESPACE_CLASS).toggleClass(DATAGRID_COLUMN_LINES_CLASS, that.option("showColumnLines"));
                for (i = 0; i < columns.length; i++)
                    freeSpaceRowElement.append(that._createCell(columns[i]));
                that._appendRow(tableElement, freeSpaceRowElement)
            },
            _needUpdateRowHeight: function(itemsCount) {
                return itemsCount > 0 && !this._rowHeight
            },
            _updateRowHeight: function() {
                var that = this,
                    tableElement = that._getTableElement(),
                    tableHeight,
                    itemsCount = that._dataController.items().length,
                    $freeSpaceRowElement;
                if (tableElement && that._needUpdateRowHeight(itemsCount)) {
                    tableHeight = tableElement.outerHeight();
                    $freeSpaceRowElement = that._getFreeSpaceRowElements().first();
                    if ($freeSpaceRowElement && $freeSpaceRowElement.is(":visible"))
                        tableHeight -= $freeSpaceRowElement.outerHeight();
                    that._rowHeight = tableHeight / itemsCount
                }
            },
            _findContentElement: function() {
                var $element = this.element(),
                    $scrollableContent;
                if ($element) {
                    $scrollableContent = $element.find(".dx-scrollable-content");
                    if (!$scrollableContent)
                        $scrollableContent = $element;
                    return $scrollableContent.children().first()
                }
            },
            _getRowElements: function(tableElement) {
                var $rows = this.callBase(tableElement);
                return $rows && $rows.not("." + DATAGRID_FREESPACE_CLASS)
            },
            _getFreeSpaceRowElements: function() {
                var tableElements = this.getTableElements();
                return tableElements && tableElements.children("tbody").children("." + DATAGRID_FREESPACE_CLASS)
            },
            _getNoDataText: function() {
                return this.option("noDataText")
            },
            _updateNoDataText: function($element) {
                $element = $element || this.element();
                var noDataElement = $element.find("." + DATAGRID_NODATA_TEXT_CLASS),
                    isVisible = this._dataController.isEmpty(),
                    isLoading = this._dataController.isLoading(),
                    rtlEnabled = this.option("rtlEnabled");
                if (!noDataElement.length)
                    noDataElement = $("<span>").addClass(DATAGRID_NODATA_TEXT_CLASS).appendTo($element);
                if (isVisible && !isLoading)
                    noDataElement.text(this._getNoDataText()).css({
                        marginTop: -Math.floor(noDataElement.height() / 2),
                        marginRight: rtlEnabled ? -Math.floor(noDataElement.width() / 2) : 0,
                        marginLeft: rtlEnabled ? 0 : -Math.floor(noDataElement.width() / 2)
                    }).removeClass("dx-hidden");
                else
                    noDataElement.addClass("dx-hidden")
            },
            _rowClick: function(e) {
                var item = this._dataController.items()[e.rowIndex] || {};
                this.executeAction("onRowClick", $.extend({evaluate: function(expr) {
                        var getter = DX.data.utils.compileGetter(expr);
                        return getter(item.data)
                    }}, e, item))
            },
            _getGroupCellOptions: function(options) {
                var columnIndex = (options.row.groupIndex || 0) + options.columnsCountBeforeGroups;
                return {
                        columnIndex: columnIndex,
                        colspan: options.columns.length - columnIndex - 1
                    }
            },
            _renderCells: function($row, options) {
                if (options.row.rowType === "group")
                    this._renderGroupedCells($row, options);
                else if (options.row.values)
                    this.callBase($row, options)
            },
            _renderGroupedCells: function($row, options) {
                var $groupCell,
                    row = options.row,
                    i,
                    columns = options.columns,
                    rowIndex = row.rowIndex,
                    isExpanded,
                    groupColumn,
                    groupColumnAlignment,
                    groupCellOptions = this._getGroupCellOptions(options);
                for (i = 0; i <= groupCellOptions.columnIndex; i++) {
                    if (i === groupCellOptions.columnIndex && columns[i].allowCollapsing && options.scrollingMode !== "infinite")
                        isExpanded = !!row.isExpanded;
                    else
                        isExpanded = null;
                    this._renderCell($row, {
                        value: isExpanded,
                        row: row,
                        rowIndex: rowIndex,
                        column: {
                            command: "expand",
                            cssClass: columns[i].cssClass
                        },
                        columnIndex: i
                    })
                }
                groupColumnAlignment = commonUtils.getDefaultAlignment(this.option("rtlEnabled"));
                groupColumn = $.extend({}, columns[groupCellOptions.columnIndex], {
                    command: null,
                    cssClass: null,
                    showWhenGrouped: false,
                    alignment: groupColumnAlignment
                });
                $groupCell = this._renderCell($row, {
                    value: row.values[row.groupIndex],
                    row: row,
                    rowIndex: rowIndex,
                    column: groupColumn,
                    columnIndex: groupCellOptions.columnIndex
                });
                $groupCell.attr("colspan", groupCellOptions.colspan)
            },
            _renderRows: function($table, options) {
                var that = this,
                    i,
                    columns = options.columns,
                    columnsCountBeforeGroups = 0,
                    scrollingMode = that.option("scrolling.mode");
                for (i = 0; i < columns.length; i++)
                    if (columns[i].command === "expand") {
                        columnsCountBeforeGroups = i;
                        break
                    }
                that.callBase($table, $.extend({
                    scrollingMode: scrollingMode,
                    columnsCountBeforeGroups: columnsCountBeforeGroups
                }, options));
                that._renderFreeSpaceRow($table)
            },
            _renderRow: function($table, options) {
                var that = this,
                    row = options.row,
                    rowTemplate = that.option("rowTemplate");
                if ((row.rowType === "data" || row.rowType === "group") && !commonUtils.isDefined(row.groupIndex) && rowTemplate)
                    that._renderTemplate($table, rowTemplate, $.extend({columns: options.columns}, row));
                else
                    that.callBase($table, options)
            },
            _renderTable: function(options) {
                var $table = this.callBase(options);
                if (!commonUtils.isDefined(this._getTableElement())) {
                    this._setTableElement($table);
                    this._renderScrollable($table)
                }
                return $table
            },
            _renderCore: function(change) {
                var that = this,
                    $table,
                    $content,
                    $element = that.element();
                $element.addClass(DATAGRID_ROWS_VIEW_CLASS).toggleClass(DATAGRID_NOWRAP_CLASS, !that.option("wordWrapEnabled"));
                $table = that._renderTable({change: change});
                $content = that._findContentElement();
                that._updateContent($content, change, $table);
                that.callBase(change);
                that._lastColumnWidths = null
            },
            _getRows: function(change) {
                return change && change.items || this._dataController.items()
            },
            _getCellOptions: function(options) {
                var that = this,
                    parameters,
                    column = options.column,
                    row = options.row,
                    data = row.data,
                    summaryCells = row && row.summaryCells,
                    value = options.value,
                    displayValue = dataGrid.getDisplayValue(column, value, data),
                    groupingOptions = that.option("grouping"),
                    scrollingMode = that.option("scrolling.mode");
                parameters = $.extend(this.callBase(options), {
                    value: value,
                    displayValue: displayValue,
                    row: row,
                    key: row.key,
                    data: data,
                    rowType: row.rowType,
                    values: row.values,
                    text: !commonUtils.isDefined(column.command) && dataGrid.formatValue(displayValue, column),
                    rowIndex: row.rowIndex,
                    summaryItems: summaryCells && summaryCells[options.columnIndex],
                    resized: column.resizedCallbacks
                });
                if (commonUtils.isDefined(column.groupIndex) && scrollingMode !== "virtual" && scrollingMode !== "infinite") {
                    parameters.groupContinuesMessage = data && data.isContinuationOnNextPage && groupingOptions && groupingOptions.groupContinuesMessage;
                    parameters.groupContinuedMessage = data && data.isContinuation && groupingOptions && groupingOptions.groupContinuedMessage
                }
                return parameters
            },
            getCellOptions: function(rowIndex, columnIdentificator) {
                var $row = this._getRowElements().eq(rowIndex),
                    rowOptions = $row.data("options"),
                    $cell = this.getCellElement(rowIndex, columnIdentificator),
                    cellOptions = $cell && rowOptions && rowOptions.cells && rowOptions.cells[$cell.index()],
                    column;
                if (rowOptions && !cellOptions && commonUtils.isString(columnIdentificator)) {
                    column = this._columnsController.columnOption(columnIdentificator);
                    if (column)
                        cellOptions = this._getCellOptions({
                            value: column.calculateCellValue(rowOptions.data),
                            rowIndex: rowOptions.rowIndex,
                            row: rowOptions,
                            column: column
                        })
                }
                return cellOptions
            },
            getRow: function(index) {
                var rows = this._getRowElements();
                if (rows.length > index)
                    return $(rows[index])
            },
            getCellIndex: function($cell) {
                var cellIndex = $cell.length ? $cell[0].cellIndex : -1;
                return cellIndex
            },
            updateFreeSpaceRowHeight: function() {
                var that = this,
                    elementHeight,
                    contentElement = that._findContentElement(),
                    freeSpaceRowElements = that._getFreeSpaceRowElements(),
                    contentHeight = 0,
                    freespaceRowCount,
                    scrollingMode,
                    resultHeight;
                if (freeSpaceRowElements && contentElement) {
                    freeSpaceRowElements.hide();
                    elementHeight = that.element().height();
                    contentHeight = contentElement.outerHeight();
                    resultHeight = elementHeight - contentHeight - that.getScrollbarWidth(true);
                    if (that._dataController.items().length > 0) {
                        if (resultHeight > 0 || !that._dataController.items().length) {
                            freeSpaceRowElements.height(resultHeight);
                            freeSpaceRowElements.show()
                        }
                        else if (!that._hasHeight) {
                            freespaceRowCount = that._dataController.pageSize() - that._dataController.items().length;
                            scrollingMode = that.option("scrolling.mode");
                            if (freespaceRowCount > 0 && that._dataController.pageCount() > 1 && scrollingMode !== "virtual" && scrollingMode !== "infinite") {
                                freeSpaceRowElements.height(freespaceRowCount * that._rowHeight);
                                freeSpaceRowElements.show()
                            }
                        }
                    }
                    else {
                        freeSpaceRowElements.height(0);
                        freeSpaceRowElements.show()
                    }
                }
            },
            _columnOptionChanged: function(e) {
                var optionNames = e.optionNames;
                if (e.changeTypes.grouping)
                    return;
                if (optionNames.width || optionNames.visibleWidth) {
                    this.callBase(e);
                    this._fireColumnResizedCallbacks()
                }
            },
            getScrollable: function() {
                return this._scrollable
            },
            init: function() {
                var that = this,
                    dataController = that.getController("data");
                that.callBase();
                that._editorFactoryController = that.getController("editorFactory");
                that._rowHeight = 0;
                that._scrollTop = 0;
                that._scrollLeft = 0;
                that._hasHeight = false;
                dataController.loadingChanged.add(function(isLoading, messageText) {
                    that.setLoading(isLoading, messageText)
                });
                var scrollToCurrentPageHandler = function() {
                        that.scrollToPage(dataController.pageIndex())
                    };
                dataController.pageChanged.add(scrollToCurrentPageHandler);
                dataController.dataSourceChanged.add(function() {
                    that._handleScroll({scrollOffset: {
                            top: that._scrollTop,
                            left: that._scrollLeft
                        }})
                })
            },
            _handleDataChanged: function(change) {
                var that = this;
                switch (change.changeType) {
                    case"refresh":
                    case"prepend":
                    case"append":
                    case"update":
                        that.render(null, change);
                        break;
                    default:
                        that._update(change);
                        break
                }
            },
            publicMethods: function() {
                return ["isScrollbarVisible", "getTopVisibleRowData", "getScrollbarWidth", "getCellElement"]
            },
            contentWidth: function() {
                return this.element().width() - this.getScrollbarWidth()
            },
            getScrollbarWidth: function(isHorizontal) {
                var scrollableContainer = this._scrollableContainer && this._scrollableContainer.get(0),
                    scrollbarWidth = 0;
                if (scrollableContainer)
                    if (!isHorizontal)
                        scrollbarWidth = scrollableContainer.offsetWidth - scrollableContainer.clientWidth;
                    else
                        scrollbarWidth = scrollableContainer.offsetHeight - scrollableContainer.clientHeight;
                return scrollbarWidth
            },
            _fireColumnResizedCallbacks: function() {
                var that = this,
                    lastColumnWidths = that._lastColumnWidths || [],
                    columnWidths = [],
                    columns = that.getColumns(),
                    i;
                for (i = 0; i < columns.length; i++) {
                    columnWidths[i] = columns[i].visibleWidth;
                    if (columns[i].resizedCallbacks && !commonUtils.isDefined(columns[i].groupIndex) && lastColumnWidths[i] !== columnWidths[i])
                        columns[i].resizedCallbacks.fire(columnWidths[i])
                }
                that._lastColumnWidths = columnWidths
            },
            _updateLastRowBorder: function() {
                var $freeSpaceRow = this._getFreeSpaceRowElements().first(),
                    isFreeSpaceRowHidden = $freeSpaceRow.css("display") === "none";
                if (this.option("showBorders") && this.option("showRowLines") && isFreeSpaceRowHidden)
                    this.element().addClass(DATAGRID_LAST_ROW_BORDER)
            },
            _updateScrollable: function() {
                var dxScrollable = this.element().data("dxScrollable");
                if (dxScrollable)
                    dxScrollable._visibilityChanged(true)
            },
            _resizeCore: function() {
                var that = this;
                that.callBase();
                that._fireColumnResizedCallbacks();
                that._updateRowHeight();
                that._updateNoDataText();
                that.updateFreeSpaceRowHeight();
                that._updateLastRowBorder();
                that._updateScrollable();
                that.setLoading(that._dataController.isLoading())
            },
            scrollToPage: function(pageIndex) {
                var that = this,
                    scrollingMode = that.option("scrolling.mode"),
                    dataController = that._dataController,
                    pageSize = dataController ? dataController.pageSize() : 0,
                    scrollPosition;
                if (scrollingMode === "virtual" || scrollingMode === "infinite")
                    scrollPosition = pageIndex * that._rowHeight * pageSize;
                else
                    scrollPosition = 0;
                that.scrollTo({
                    y: scrollPosition,
                    x: that._scrollLeft
                })
            },
            scrollTo: function(location) {
                var $element = this.element(),
                    dxScrollable = $element && $element.data("dxScrollable");
                if (dxScrollable)
                    dxScrollable.scrollTo(location)
            },
            height: function(height) {
                var that = this,
                    $element = this.element(),
                    freeSpaceRowElements;
                if (commonUtils.isDefined(height)) {
                    that._hasHeight = height !== "auto";
                    if ($element)
                        $element.height(height);
                    freeSpaceRowElements = this._getFreeSpaceRowElements();
                    freeSpaceRowElements && freeSpaceRowElements.hide()
                }
                else
                    return $element ? $element.height() : 0
            },
            setLoading: function(isLoading, messageText) {
                var that = this,
                    loadPanel = that._loadPanel,
                    dataController = that._dataController,
                    loadPanelOptions = that.option("loadPanel") || {},
                    animation = dataController.isLoaded() ? loadPanelOptions.animation : null,
                    visibilityOptions;
                if (loadPanel) {
                    visibilityOptions = {
                        message: messageText || loadPanelOptions.text,
                        animation: animation,
                        visible: isLoading
                    };
                    clearTimeout(that._hideLoadingTimeoutID);
                    if (loadPanel.option("visible") && !isLoading)
                        that._hideLoadingTimeoutID = setTimeout(function() {
                            loadPanel.option(visibilityOptions)
                        }, DATAGRID_LOADPANEL_HIDE_TIMEOUT);
                    else
                        loadPanel.option(visibilityOptions);
                    that._updateNoDataText()
                }
            },
            isScrollbarVisible: function() {
                var $element = this.element();
                return $element ? this._findContentElement().outerHeight() - $element.height() > 0 : false
            },
            setRowsOpacity: function(columnIndex, value) {
                var that = this,
                    $rows = that._getRowElements().not("." + DATAGRID_GROUP_ROW_CLASS) || [];
                $.each($rows, function(rowIndex, row) {
                    if (!$(row).hasClass(DATAGRID_GROUP_ROW_CLASS))
                        that.getCellElements(rowIndex).eq(columnIndex).css({opacity: value})
                })
            },
            getTopVisibleItemIndex: function() {
                var that = this,
                    itemIndex = 0,
                    prevOffsetTop = 0,
                    offsetTop = 0,
                    rowElements,
                    rowElelemnt,
                    scrollPosition = that._scrollTop,
                    contentElementOffsetTop = that._findContentElement().offset().top,
                    items = that._dataController.items(),
                    tableElement = that._getTableElement();
                if (items.length && tableElement) {
                    rowElements = tableElement.children("tbody").children(".dx-row:visible, .dx-error-row").not("." + DATAGRID_FREESPACE_CLASS);
                    for (itemIndex = 0; itemIndex < items.length; itemIndex++) {
                        prevOffsetTop = offsetTop;
                        rowElelemnt = rowElements.eq(itemIndex);
                        if (rowElelemnt.length) {
                            offsetTop = rowElelemnt.offset().top - contentElementOffsetTop;
                            if (offsetTop > scrollPosition) {
                                if (scrollPosition * 2 < offsetTop + prevOffsetTop && itemIndex)
                                    itemIndex--;
                                break
                            }
                        }
                    }
                    if (itemIndex && itemIndex === items.length)
                        itemIndex--
                }
                return itemIndex
            },
            getTopVisibleRowData: function() {
                var itemIndex = this.getTopVisibleItemIndex(),
                    items = this._dataController.items();
                if (items[itemIndex])
                    return items[itemIndex].data
            },
            optionChanged: function(args) {
                var that = this;
                that.callBase(args);
                switch (args.name) {
                    case"wordWrapEnabled":
                    case"showColumnLines":
                    case"showRowLines":
                    case"rowAlternationEnabled":
                    case"rowTemplate":
                    case"twoWayBindingEnabled":
                        that._invalidate(true, true);
                        args.handled = true;
                        break;
                    case"scrolling":
                        that._rowHeight = null;
                        that._tableElement = null;
                        args.handled = true;
                        break;
                    case"rtlEnabled":
                        that._rowHeight = null;
                        that._tableElement = null;
                        break;
                    case"loadPanel":
                        that._tableElement = null;
                        that._invalidate(true, true);
                        args.handled = true;
                        break;
                    case"noDataText":
                        that._updateNoDataText();
                        args.handled = true;
                        break
                }
            },
            dispose: function() {
                clearTimeout(this._hideLoadingTimeoutID)
            },
            setScrollerSpacing: function(){}
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_GROUP_ROW_CLASS: DATAGRID_GROUP_ROW_CLASS,
            DATAGRID_ROWS_VIEW_CLASS: DATAGRID_ROWS_VIEW_CLASS,
            DATAGRID_TABLE_CLASS: DATAGRID_TABLE_CLASS,
            DATAGRID_FREESPACE_CLASS: DATAGRID_FREESPACE_CLASS,
            DATAGRID_NODATA_TEXT_CLASS: DATAGRID_NODATA_TEXT_CLASS,
            DATAGRID_NOWRAP_CLASS: DATAGRID_NOWRAP_CLASS,
            DATAGRID_ROW_LINES_CLASS: DATAGRID_ROW_LINES_CLASS,
            DATAGRID_COLUMN_LINES_CLASS: DATAGRID_COLUMN_LINES_CLASS,
            DATAGRID_ROW_ALTERNATION_CLASS: DATAGRID_ROW_ALTERNATION_CLASS,
            DATAGRID_LAST_ROW_BORDER: DATAGRID_LAST_ROW_BORDER
        });
        dataGrid.registerModule("rows", {
            defaultOptions: function() {
                return {
                        hoverStateEnabled: false,
                        loadPanel: {
                            enabled: true,
                            text: Globalize.localize("Loading"),
                            width: 200,
                            height: 70,
                            showIndicator: true,
                            indicatorSrc: "",
                            showPane: true
                        },
                        rowTemplate: null,
                        columnAutoWidth: false,
                        noDataText: Globalize.localize("dxDataGrid-noDataText"),
                        wordWrapEnabled: false,
                        showColumnLines: true,
                        showRowLines: false,
                        rowAlternationEnabled: false,
                        activeStateEnabled: false,
                        twoWayBindingEnabled: true
                    }
            },
            views: {rowsView: dataGrid.RowsView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.pager.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common");
        var DATAGRID_PAGER_CLASS = "dx-datagrid-pager";
        var MAX_PAGES_COUNT = 10;
        dataGrid.PagerView = dataGrid.View.inherit({
            init: function() {
                var that = this,
                    dataController = that.getController("data");
                that._isVisible = false;
                dataController.changed.add(function(e) {
                    if (!e || e.changeType !== "update")
                        that.render()
                })
            },
            _getPager: function() {
                var $element = this.element();
                return $element && $element.data("dxPager")
            },
            _renderCore: function() {
                var that = this,
                    $element = that.element().addClass(DATAGRID_PAGER_CLASS),
                    pagerOptions = that.option("pager") || {},
                    dataController = that.getController("data"),
                    options = {
                        maxPagesCount: MAX_PAGES_COUNT,
                        pageIndex: 1 + (parseInt(dataController.pageIndex()) || 0),
                        pageCount: dataController.pageCount(),
                        pageSize: dataController.pageSize(),
                        showPageSizes: pagerOptions.showPageSizeSelector,
                        showInfo: pagerOptions.showInfo,
                        pagesNavigatorVisible: pagerOptions.visible,
                        showNavigationButtons: pagerOptions.showNavigationButtons,
                        pageSizes: that.getPageSizes(),
                        totalCount: dataController.totalCount(),
                        hasKnownLastPage: dataController.hasKnownLastPage(),
                        pageIndexChanged: function(pageIndex) {
                            if (dataController.pageIndex() !== pageIndex - 1)
                                setTimeout(function() {
                                    dataController.pageIndex(pageIndex - 1)
                                })
                        },
                        pageSizeChanged: function(pageSize) {
                            setTimeout(function() {
                                dataController.pageSize(pageSize)
                            })
                        }
                    };
                if (commonUtils.isDefined(pagerOptions.infoText))
                    options.infoText = pagerOptions.infoText;
                that._createComponent($element, "dxPager", options)
            },
            getPageSizes: function() {
                var that = this,
                    dataController = that.getController("data"),
                    pagerOptions = that.option("pager"),
                    allowedPageSizes = pagerOptions && pagerOptions.allowedPageSizes,
                    pageSize = dataController.pageSize();
                if (!commonUtils.isDefined(that._pageSizes) || $.inArray(pageSize, that._pageSizes) === -1) {
                    that._pageSizes = [];
                    if (pagerOptions)
                        if ($.isArray(allowedPageSizes))
                            that._pageSizes = allowedPageSizes;
                        else if (allowedPageSizes && pageSize > 1)
                            that._pageSizes = [Math.floor(pageSize / 2), pageSize, pageSize * 2]
                }
                return that._pageSizes
            },
            isVisible: function() {
                var that = this,
                    dataController = that.getController("data"),
                    pagerOptions = that.option("pager"),
                    pagerVisible = pagerOptions && pagerOptions.visible,
                    scrolling = that.option("scrolling");
                if (that._isVisible)
                    return true;
                if (pagerVisible === "auto")
                    if (scrolling && (scrolling.mode === "virtual" || scrolling.mode === "infinite"))
                        pagerVisible = false;
                    else
                        pagerVisible = dataController.pageCount() > 1 || dataController.isLoaded() && !dataController.hasKnownLastPage();
                that._isVisible = pagerVisible;
                return pagerVisible
            },
            getHeight: function() {
                var pager = this._getPager();
                return pager && this.isVisible() ? pager.getHeight() : 0
            },
            optionChanged: function(args) {
                var that = this,
                    name = args.name,
                    isPager = name === "pager",
                    isPaging = name === "paging",
                    isDataSource = name === "dataSource",
                    isScrolling = name === "scrolling";
                if (isPager || isPaging || isScrolling || isDataSource) {
                    if (isPager || isPaging)
                        that._pageSizes = null;
                    if (isPager || isPaging || isScrolling)
                        that._isVisible = false;
                    if (!isDataSource) {
                        that._invalidate();
                        if (isPager && that.component)
                            that.component.resize()
                    }
                    args.handled = true
                }
            }
        });
        dataGrid.registerModule("pager", {
            defaultOptions: function() {
                return {pager: {
                            visible: "auto",
                            showPageSizeSelector: false,
                            allowedPageSizes: "auto"
                        }}
            },
            views: {pagerView: dataGrid.PagerView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnsResizingReorderingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            commonUtils = DX.require("/utils/utils.common"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer"),
            addNamespace = eventUtils.addNamespace,
            dataGrid = ui.dxDataGrid,
            fx = DX.fx;
        var DATAGRID_COLUMNS_SEPARATOR_CLASS = "dx-datagrid-columns-separator",
            DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT = "dx-datagrid-columns-separator-transparent",
            DATAGRID_DRAGGING_HEADER_CLASS = "dx-datagrid-drag-header",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_HEADERS_DRAG_ACTION_CLASS = "dx-datagrid-drag-action",
            DATAGRID_TRACKER_CLASS = "dx-datagrid-tracker",
            DATAGRID_BLOCK_SEPARATOR_CLASS = "dx-block-separator",
            DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS = "dx-datagrid-drop-highlight",
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            WIDGET_CLASS = "dx-widget",
            DATAGRID_MODULE_NAMESPACE = "dxDataGridResizingReordering",
            COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH = 10,
            DRAGGING_DELTA = 5;
        var allowResizing = function(that) {
                return that.option("allowColumnResizing") || that.getController("columns").isColumnOptionUsed("allowResizing")
            };
        var allowReordering = function(that) {
                return that.option("allowColumnReordering") || that.getController("columns").isColumnOptionUsed("allowReordering")
            };
        dataGrid.getPointsByColumns = function(items, pointCreated, isVertical) {
            var cellsLength = items.length,
                notCreatePoint = false,
                point,
                i,
                item,
                offset,
                result = [],
                rtlEnabled,
                columnIndex = 0;
            for (i = 0; i <= cellsLength; i++) {
                if (i < cellsLength) {
                    item = items.eq(columnIndex);
                    offset = item.offset();
                    rtlEnabled = item.css("direction") === "rtl"
                }
                point = {
                    index: i,
                    x: offset ? offset.left + (!isVertical && rtlEnabled ^ i === cellsLength ? item.outerWidth() : 0) : 0,
                    y: offset ? offset.top + (isVertical && i === cellsLength ? item.outerHeight() : 0) : 0,
                    columnIndex: columnIndex
                };
                if (pointCreated)
                    notCreatePoint = pointCreated(point);
                if (!notCreatePoint)
                    result.push(point);
                columnIndex++
            }
            return result
        };
        dataGrid.TrackerView = dataGrid.View.inherit({
            _renderCore: function(options) {
                this.callBase();
                this.element().addClass(DATAGRID_TRACKER_CLASS);
                this.hide()
            },
            init: function() {
                var that = this,
                    $element;
                that.callBase();
                that.getController("tablePosition").positionChanged.add(function(position) {
                    $element = that.element();
                    if ($element && $element.hasClass(DATAGRID_TRACKER_CLASS)) {
                        $element.css({top: position.top});
                        $element.height(position.height)
                    }
                })
            },
            isVisible: function() {
                return allowResizing(this)
            },
            show: function() {
                this.element().show()
            },
            hide: function() {
                this.element().hide()
            },
            setHeight: function(value) {
                this.element().height(value)
            }
        });
        dataGrid.SeparatorView = dataGrid.View.inherit({
            _renderSeparator: function(){},
            _renderCore: function(options) {
                this.callBase(options);
                this._isShown = true;
                this._renderSeparator();
                this.hide()
            },
            show: function() {
                this._isShown = true
            },
            hide: function() {
                this._isShown = false
            },
            height: function(value) {
                var $element = this.element();
                if ($element)
                    if (commonUtils.isDefined(value))
                        $element.height(value);
                    else
                        return $element.height()
            },
            width: function(value) {
                var $element = this.element();
                if ($element)
                    if (commonUtils.isDefined(value))
                        $element.width(value);
                    else
                        return $element.width()
            }
        });
        dataGrid.ColumnsSeparatorView = dataGrid.SeparatorView.inherit({
            _renderSeparator: function() {
                this.callBase();
                var $element = this.element();
                $element.addClass(DATAGRID_COLUMNS_SEPARATOR_CLASS)
            },
            _subscribeToEvent: function() {
                var that = this,
                    $element;
                that.getController("tablePosition").positionChanged.add(function(position) {
                    $element = that.element();
                    if ($element) {
                        $element.css({top: position.top});
                        $element.height(position.height)
                    }
                })
            },
            isVisible: function() {
                return this.option("showColumnHeaders") && (allowReordering(this) || allowResizing(this))
            },
            init: function() {
                this.callBase();
                this._isTransparent = allowResizing(this);
                if (this.isVisible())
                    this._subscribeToEvent()
            },
            show: function() {
                var that = this,
                    $element = this.element();
                if ($element && !that._isShown)
                    if (that._isTransparent)
                        $element.removeClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT);
                    else
                        $element.show();
                this.callBase()
            },
            hide: function() {
                var $element = this.element();
                if ($element && this._isShown)
                    if (this._isTransparent)
                        $element.addClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT);
                    else
                        $element.hide();
                this.callBase()
            },
            moveByX: function(outerX) {
                var $element = this.element();
                if ($element) {
                    $element.css("left", outerX - this._parentElement().offset().left);
                    this._testPosx = outerX
                }
            },
            changeCursor: function(cursorName) {
                cursorName = commonUtils.isDefined(cursorName) ? cursorName : "";
                var $element = this.element();
                if ($element) {
                    $element.css("cursor", cursorName);
                    this._testCursorName = cursorName
                }
            }
        });
        dataGrid.BlockSeparatorView = dataGrid.SeparatorView.inherit({
            _renderSeparator: function() {
                this.callBase();
                this.element().addClass(DATAGRID_BLOCK_SEPARATOR_CLASS).html("&nbsp;")
            },
            hide: function() {
                var that = this,
                    $parent = this._parentElement(),
                    $element = this.element();
                if ($element && this._isShown)
                    $element.hide();
                if ($parent && !$parent.children("." + DATAGRID_BLOCK_SEPARATOR_CLASS).length)
                    $parent.prepend(that.element());
                that.callBase()
            },
            isVisible: function() {
                var groupPanelOptions = this.option("groupPanel"),
                    columnChooserOptions = this.option("columnChooser");
                return groupPanelOptions && groupPanelOptions.visible || columnChooserOptions && columnChooserOptions.enabled
            },
            show: function(targetLocation) {
                var that = this,
                    $element = this.element(),
                    startAnimate = function(toOptions) {
                        fx.stop($element, true);
                        fx.animate($element, {
                            type: "slide",
                            from: {
                                width: 0,
                                display: toOptions.display
                            },
                            to: toOptions,
                            duration: 300,
                            easing: "swing"
                        })
                    };
                if ($element && !that._isShown)
                    switch (targetLocation) {
                        case"group":
                            startAnimate({
                                width: "50px",
                                display: "inline-block"
                            });
                            break;
                        case"columnChooser":
                            startAnimate({
                                width: "100%",
                                display: "block"
                            });
                            break;
                        default:
                            $element.show()
                    }
                that.callBase()
            }
        });
        dataGrid.DraggingHeaderView = dataGrid.View.inherit({
            _isDragging: false,
            _getDropOptions: function() {
                var that = this;
                if (that._dragOptions)
                    return {
                            sourceColumnIndex: that._dragOptions.columnIndex,
                            sourceColumnElement: that._dragOptions.columnElement,
                            sourceLocation: that._dragOptions.sourceLocation,
                            targetColumnIndex: that._dropColumnIndex,
                            targetLocation: that._dropLocation
                        }
            },
            _getDraggingPanelByPos: function(pos) {
                var that = this,
                    result;
                $.each(that._dragOptions.draggingPanels, function(index, draggingPanel) {
                    if (draggingPanel) {
                        var boundingRect = draggingPanel.getBoundingRect();
                        if (boundingRect && (boundingRect.bottom === undefined || pos.y < boundingRect.bottom) && (boundingRect.top === undefined || pos.y > boundingRect.top) && (boundingRect.left === undefined || pos.x > boundingRect.left) && (boundingRect.right === undefined || pos.x < boundingRect.right)) {
                            result = draggingPanel;
                            return false
                        }
                    }
                });
                return result
            },
            _renderCore: function() {
                this.element().addClass(DATAGRID_DRAGGING_HEADER_CLASS + " " + DATAGRID_CELL_CONTENT_CLASS + " " + WIDGET_CLASS).css("display", "none")
            },
            dispose: function() {
                var element = this.element();
                this._dragOptions = null;
                element && element.parent().find("." + DATAGRID_DRAGGING_HEADER_CLASS).remove()
            },
            isVisible: function() {
                var columnsController = this.getController("columns"),
                    commonColumnSettings = columnsController.getCommonSettings();
                return this.option("showColumnHeaders") && (allowReordering(this) || commonColumnSettings.allowGrouping || commonColumnSettings.allowHiding)
            },
            init: function() {
                this.callBase();
                this._controller = this.getController("draggingHeader");
                this._columnsResizerViewController = this.getController("columnsResizer")
            },
            dragHeader: function(options) {
                var that = this,
                    columnElement = options.columnElement;
                that._dragOptions = options;
                that._isDragging = true;
                that._dropColumnIndex = options.columnIndex;
                that._dropLocation = options.sourceLocation;
                that._onSelectStart = document.onselectstart;
                document.onselectstart = function() {
                    return false
                };
                that.element().css({
                    textAlign: columnElement && columnElement.css("text-align"),
                    height: columnElement && columnElement.height(),
                    width: columnElement && columnElement.width(),
                    whiteSpace: columnElement && columnElement.css("white-space")
                }).addClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS).text(options.sourceColumn.caption);
                that.element().appendTo($(document.body))
            },
            moveHeader: function(args) {
                var e = args.jQueryEvent,
                    that = e.data.that,
                    newLeft,
                    newTop,
                    moveDeltaX,
                    moveDeltaY,
                    eventData = eventUtils.eventData(e),
                    isResizing = that._columnsResizerViewController ? that._columnsResizerViewController.isResizing() : false,
                    dragOptions = that._dragOptions;
                if (that._isDragging && !isResizing) {
                    moveDeltaX = Math.abs(eventData.x - dragOptions.columnElement.offset().left - dragOptions.deltaX);
                    moveDeltaY = Math.abs(eventData.y - dragOptions.columnElement.offset().top - dragOptions.deltaY);
                    if (that.element().is(":visible") || moveDeltaX > DRAGGING_DELTA || moveDeltaY > DRAGGING_DELTA) {
                        that.element().show();
                        newLeft = eventData.x - dragOptions.deltaX;
                        newTop = eventData.y - dragOptions.deltaY;
                        that.element().offset({
                            left: newLeft,
                            top: newTop
                        });
                        that.dockHeader(eventData)
                    }
                    e.preventDefault()
                }
            },
            dockHeader: function(eventData) {
                var that = this,
                    targetDraggingPanel = that._getDraggingPanelByPos(eventData),
                    controller = that._controller,
                    i,
                    params,
                    centerPosition;
                if (targetDraggingPanel) {
                    var rtlEnabled = that.option("rtlEnabled"),
                        isVerticalOrientation = targetDraggingPanel.getName() === "columnChooser",
                        axisName = isVerticalOrientation ? "y" : "x",
                        columnElements = targetDraggingPanel.getColumnElements() || [],
                        pointsByColumns = controller._generatePointsByColumns($.extend({}, that._dragOptions, {
                            targetDraggingPanel: targetDraggingPanel,
                            columns: targetDraggingPanel.getColumns(),
                            columnElements: columnElements,
                            isVerticalOrientation: isVerticalOrientation
                        }));
                    that._dropLocation = targetDraggingPanel.getName();
                    if (pointsByColumns.length > 0)
                        for (i = 0; i < pointsByColumns.length; i++) {
                            centerPosition = pointsByColumns[i + 1] && (pointsByColumns[i][axisName] + pointsByColumns[i + 1][axisName]) / 2;
                            if (centerPosition === undefined || (rtlEnabled && axisName === "x" ? eventData[axisName] > centerPosition : eventData[axisName] < centerPosition)) {
                                that._dropColumnIndex = pointsByColumns[i].columnIndex;
                                params = that._getDropOptions();
                                if (columnElements[i])
                                    params.targetColumnElement = columnElements.eq(i);
                                else {
                                    params.targetColumnElement = columnElements.last();
                                    params.isLast = true
                                }
                                params.posX = pointsByColumns[i].x;
                                controller.dock(params);
                                break
                            }
                        }
                    else {
                        that._dropColumnIndex = -1;
                        params = that._getDropOptions();
                        controller.dock(params)
                    }
                }
            },
            dropHeader: function(args) {
                var e = args.jQueryEvent,
                    that = e.data.that,
                    controller = that._controller;
                that.element().hide();
                if (controller && that._isDragging)
                    controller.drop(that._getDropOptions());
                that.element().appendTo(that._parentElement());
                that._dragOptions = null;
                that._isDragging = false;
                document.onselectstart = that._onSelectStart || null
            }
        });
        dataGrid.ColumnsResizerViewController = dataGrid.ViewController.inherit({
            _isHeadersRowArea: function(posY) {
                if (this._columnHeadersView) {
                    var element = this._columnHeadersView.element(),
                        headersRowHeight,
                        offsetTop;
                    if (element) {
                        offsetTop = element.offset().top;
                        headersRowHeight = this._columnHeadersView.getHeadersRowHeight();
                        return posY >= offsetTop && posY <= offsetTop + headersRowHeight
                    }
                }
                return false
            },
            _pointCreated: function(point, cellsLength, columns) {
                var currentColumn,
                    nextColumn;
                if (point.index > 0 && point.index < cellsLength) {
                    point.columnIndex -= 1;
                    currentColumn = columns[point.columnIndex] || {};
                    nextColumn = columns[point.columnIndex + 1] || {};
                    return !(currentColumn.allowResizing && nextColumn.allowResizing)
                }
                return true
            },
            _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
                if (pointsByColumns)
                    for (var i = 0; i < pointsByColumns.length; i++)
                        if (pointsByColumns[i].x - deltaX <= currentX && currentX <= pointsByColumns[i].x + deltaX)
                            return pointsByColumns[i];
                return null
            },
            _moveSeparator: function(args) {
                var e = args.jQueryEvent,
                    that = e.data,
                    pointsByColumns = that._pointsByColumns,
                    columnsSeparatorWidth = that._columnsSeparatorView.width(),
                    columnsSeparatorOffset = that._columnsSeparatorView.element().offset(),
                    deltaX = columnsSeparatorWidth / 2,
                    parentOffsetLeft = that._$parentContainer.offset().left,
                    eventData = eventUtils.eventData(e);
                if (that._isResizing) {
                    if (parentOffsetLeft <= eventData.x && eventData.x <= parentOffsetLeft + that._$parentContainer.width())
                        if (that._updateColumnsWidthIfNeeded(that._targetPoint.columnIndex, eventData.x)) {
                            that._columnsSeparatorView.moveByX(that._targetPoint.x + (eventData.x - that._resizingInfo.startPosX));
                            that._tablePositionController.update();
                            e.preventDefault()
                        }
                }
                else if (that._isHeadersRowArea(eventData.y)) {
                    that._targetPoint = that._getTargetPoint(pointsByColumns, eventData.x, columnsSeparatorWidth);
                    that._isReadyResizing = false;
                    that._columnsSeparatorView.changeCursor();
                    if (that._targetPoint && columnsSeparatorOffset.top <= eventData.y && columnsSeparatorOffset.top + that._columnsSeparatorView.height() >= eventData.y) {
                        that._columnsSeparatorView.changeCursor("col-resize");
                        that._columnsSeparatorView.moveByX(that._targetPoint.x - deltaX);
                        that._isReadyResizing = true;
                        e.preventDefault()
                    }
                }
                else {
                    that._isReadyResizing = false;
                    that._columnsSeparatorView.changeCursor()
                }
            },
            _endResizing: function(args) {
                var e = args.jQueryEvent,
                    that = e.data;
                if (that._isResizing) {
                    that._generatePointsByColumns();
                    that._resizingInfo = null;
                    that._columnsSeparatorView.hide();
                    that._columnsSeparatorView.changeCursor();
                    that._trackerView.hide();
                    that._isReadyResizing = false;
                    that._isResizing = false
                }
            },
            _setupResizingInfo: function(posX) {
                var that = this,
                    currentHeader = that._columnHeadersView.getHeaderElement(that._targetPoint.columnIndex),
                    nextHeader = that._columnHeadersView.getHeaderElement(that._targetPoint.columnIndex + 1);
                that._resizingInfo = {
                    startPosX: posX,
                    currentColumnWidth: currentHeader && currentHeader.length > 0 ? currentHeader.outerWidth() : 0,
                    nextColumnWidth: nextHeader && nextHeader.length > 0 ? nextHeader.outerWidth() : 0
                }
            },
            _startResizing: function(args) {
                var e = args.jQueryEvent,
                    that = e.data,
                    eventData = eventUtils.eventData(e);
                if (eventUtils.isTouchEvent(e))
                    if (that._isHeadersRowArea(eventData.y)) {
                        that._targetPoint = that._getTargetPoint(that._pointsByColumns, eventData.x, COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH);
                        if (that._targetPoint) {
                            that._columnsSeparatorView.moveByX(that._targetPoint.x - that._columnsSeparatorView.width() / 2);
                            that._isReadyResizing = true
                        }
                    }
                    else
                        that._isReadyResizing = false;
                if (that._isReadyResizing) {
                    if (that._targetPoint)
                        that._testColumnIndex = that._targetPoint.columnIndex;
                    that._setupResizingInfo(eventData.x);
                    that._columnsSeparatorView.show();
                    that._trackerView.show();
                    that._isResizing = true;
                    e.preventDefault();
                    e.stopPropagation()
                }
            },
            _generatePointsByColumns: function() {
                var that = this,
                    columns = that._columnsController ? that._columnsController.getVisibleColumns() : [],
                    cells = that._columnHeadersView.getColumnElements(),
                    pointsByColumns = [];
                if (cells && cells.length > 0)
                    pointsByColumns = dataGrid.getPointsByColumns(cells, function(point) {
                        return that._pointCreated(point, cells.length, columns)
                    });
                that._pointsByColumns = pointsByColumns
            },
            _unsubscribeFromEvents: function() {
                this._moveSeparatorHandler && this._$parentContainer.off(addNamespace(pointerEvents.move, DATAGRID_MODULE_NAMESPACE), this._moveSeparatorHandler);
                this._startResizingHandler && this._$parentContainer.off(addNamespace(pointerEvents.down, DATAGRID_MODULE_NAMESPACE), this._startResizingHandler);
                if (this._endResizingHandler) {
                    this._columnsSeparatorView.element().off(addNamespace(pointerEvents.up, DATAGRID_MODULE_NAMESPACE), this._endResizingHandler);
                    $(document).off(addNamespace(pointerEvents.up, DATAGRID_MODULE_NAMESPACE), this._endResizingHandler)
                }
            },
            _subscribeToEvents: function() {
                this._moveSeparatorHandler = this.createAction(this._moveSeparator);
                this._startResizingHandler = this.createAction(this._startResizing);
                this._endResizingHandler = this.createAction(this._endResizing);
                this._$parentContainer.on(addNamespace(pointerEvents.move, DATAGRID_MODULE_NAMESPACE), this, this._moveSeparatorHandler);
                this._$parentContainer.on(addNamespace(pointerEvents.down, DATAGRID_MODULE_NAMESPACE), this, this._startResizingHandler);
                this._columnsSeparatorView.element().on(addNamespace(pointerEvents.up, DATAGRID_MODULE_NAMESPACE), this, this._endResizingHandler);
                $(document).on(addNamespace(pointerEvents.up, DATAGRID_MODULE_NAMESPACE), this, this._endResizingHandler)
            },
            _updateColumnsWidthIfNeeded: function(columnIndex, posX) {
                var deltaX,
                    isUpdated = false,
                    nextCellWidth,
                    columnsController = this._columnsController,
                    visibleColumns = columnsController.getVisibleColumns(),
                    columnsSeparatorWidth = this._columnsSeparatorView.width(),
                    column,
                    nextColumn,
                    cellWidth;
                deltaX = posX - this._resizingInfo.startPosX;
                if (this.option("rtlEnabled"))
                    deltaX = -deltaX;
                cellWidth = this._resizingInfo.currentColumnWidth + deltaX;
                nextCellWidth = this._resizingInfo.nextColumnWidth - deltaX;
                isUpdated = !(cellWidth <= columnsSeparatorWidth || nextCellWidth <= columnsSeparatorWidth);
                if (isUpdated) {
                    column = visibleColumns[columnIndex];
                    nextColumn = visibleColumns[columnIndex + 1];
                    columnsController.beginUpdate();
                    column && columnsController.columnOption(column.index, "visibleWidth", undefined);
                    nextColumn && columnsController.columnOption(nextColumn.index, "visibleWidth", undefined);
                    column && columnsController.columnOption(column.index, "width", Math.floor(cellWidth));
                    nextColumn && columnsController.columnOption(nextColumn.index, "width", Math.floor(nextCellWidth));
                    columnsController.endUpdate()
                }
                return isUpdated
            },
            isResizing: function() {
                return this._isResizing
            },
            init: function() {
                var that = this,
                    gridView,
                    previousScrollbarVisibility,
                    generatePointsByColumnsScrollHandler = function(offset) {
                        if (that._scrollLeft !== offset.left) {
                            that._scrollLeft = offset.left;
                            that._generatePointsByColumns()
                        }
                    },
                    generatePointsByColumnsHandler = function() {
                        that._generatePointsByColumns()
                    };
                that.callBase();
                if (allowResizing(that)) {
                    that._columnsSeparatorView = that.getView("columnsSeparatorView");
                    that._columnHeadersView = that.getView("columnHeadersView");
                    that._trackerView = that.getView("trackerView");
                    that._rowsView = that.getView("rowsView");
                    that._columnsController = that.getController("columns");
                    that._tablePositionController = that.getController("tablePosition");
                    that._$parentContainer = that._columnsSeparatorView.component.element();
                    that._columnHeadersView.renderCompleted.add(generatePointsByColumnsHandler);
                    that._columnHeadersView.resizeCompleted.add(generatePointsByColumnsHandler);
                    that._columnsSeparatorView.renderCompleted.add(function() {
                        that._unsubscribeFromEvents();
                        that._subscribeToEvents()
                    });
                    that._rowsView.renderCompleted.add(function() {
                        that._rowsView.scrollChanged.remove(generatePointsByColumnsScrollHandler);
                        that._rowsView.scrollChanged.add(generatePointsByColumnsScrollHandler)
                    });
                    gridView = that.getView("gridView");
                    previousScrollbarVisibility = that._rowsView.getScrollbarWidth() !== 0;
                    that.getController("tablePosition").positionChanged.add(function() {
                        if (that._isResizing && !that._rowsView.isResizing) {
                            var scrollbarVisibility = that._rowsView.getScrollbarWidth() !== 0;
                            if (previousScrollbarVisibility !== scrollbarVisibility) {
                                previousScrollbarVisibility = scrollbarVisibility;
                                gridView.resize()
                            }
                            else
                                that._rowsView.updateFreeSpaceRowHeight()
                        }
                    })
                }
            },
            dispose: function() {
                this._unsubscribeFromEvents()
            }
        });
        dataGrid.TablePositionViewController = dataGrid.ViewController.inherit({
            update: function() {
                var $element = this._columnHeadersView.element(),
                    columnsHeadersHeight = this._columnHeadersView ? this._columnHeadersView.getHeight() : 0,
                    rowsHeight = this._rowsView ? this._rowsView.height() - this._rowsView.getScrollbarWidth(true) : 0;
                this.positionChanged.fire({
                    height: columnsHeadersHeight + rowsHeight,
                    top: $element && $element.length > 0 ? Math.floor($element[0].offsetTop) : 0
                })
            },
            init: function() {
                var that = this;
                that.callBase();
                that._columnHeadersView = this.getView("columnHeadersView");
                that._rowsView = this.getView("rowsView");
                that._pagerView = this.getView("pagerView");
                that._rowsView.resizeCompleted.add(function() {
                    that.update()
                })
            },
            ctor: function(component) {
                this.callBase(component);
                this.positionChanged = $.Callbacks()
            }
        });
        dataGrid.DraggingHeaderViewController = dataGrid.ViewController.inherit({
            _generatePointsByColumns: function(options) {
                var that = this;
                return dataGrid.getPointsByColumns(options.columnElements, function(point) {
                        return that._pointCreated(point, options.columns, options.targetDraggingPanel.getName(), options.sourceColumn)
                    }, options.isVerticalOrientation)
            },
            _pointCreated: function(point, columns, location, sourceColumn) {
                var targetColumn = columns[point.columnIndex],
                    prevColumn = columns[point.columnIndex - 1];
                switch (location) {
                    case"columnChooser":
                        return true;
                    case"headers":
                        return sourceColumn && !sourceColumn.allowReordering || (!targetColumn || !targetColumn.allowReordering) && (!prevColumn || !prevColumn.allowReordering);
                    default:
                        return columns.length === 0
                }
            },
            _subscribeToEvents: function(draggingHeader, draggingPanels) {
                var that = this;
                $.each(draggingPanels, function(_, draggingPanel) {
                    if (draggingPanel) {
                        var columnElements = draggingPanel.getColumnElements() || [],
                            nameDraggingPanel = draggingPanel.getName(),
                            columns = draggingPanel.getColumns() || [];
                        $.each(columnElements, function(index, columnElement) {
                            var $columnElement = $(columnElement);
                            if (draggingPanel.allowDragging(columns[index], draggingPanels)) {
                                $columnElement.addClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS);
                                $columnElement.on(addNamespace("dxdragstart", DATAGRID_MODULE_NAMESPACE), that.createAction(function(args) {
                                    var e = args.jQueryEvent,
                                        eventData = eventUtils.eventData(e);
                                    draggingHeader.dragHeader({
                                        deltaX: eventData.x - $(e.currentTarget).offset().left,
                                        deltaY: eventData.y - $(e.currentTarget).offset().top,
                                        sourceColumn: columns[index],
                                        columnIndex: index,
                                        columnElement: $columnElement,
                                        sourceLocation: nameDraggingPanel,
                                        draggingPanels: draggingPanels
                                    })
                                }));
                                $columnElement.on(addNamespace("dxdrag", DATAGRID_MODULE_NAMESPACE), {that: draggingHeader}, that.createAction(draggingHeader.moveHeader));
                                $columnElement.on(addNamespace("dxdragend", DATAGRID_MODULE_NAMESPACE), {that: draggingHeader}, that.createAction(draggingHeader.dropHeader))
                            }
                        })
                    }
                })
            },
            _unsubscribeFromEvents: function(draggingHeader, draggingPanels) {
                $.each(draggingPanels, function(_, draggingPanel) {
                    if (draggingPanel) {
                        var columnElements = draggingPanel.getColumnElements() || [];
                        $.each(columnElements, function(index, columnElement) {
                            var $columnElement = $(columnElement);
                            $columnElement.off(addNamespace("dxdragstart", DATAGRID_MODULE_NAMESPACE));
                            $columnElement.off(addNamespace("dxdrag", DATAGRID_MODULE_NAMESPACE));
                            $columnElement.off(addNamespace("dxdragend", DATAGRID_MODULE_NAMESPACE));
                            $columnElement.removeClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS)
                        })
                    }
                })
            },
            _getSeparator: function(targetLocation) {
                return targetLocation === "headers" ? this._columnsSeparatorView : this._blockSeparatorView
            },
            hideSeparators: function() {
                var blockSeparator = this._blockSeparatorView,
                    columnsSeparator = this._columnsSeparatorView;
                this._animationColumnIndex = null;
                blockSeparator && blockSeparator.hide();
                columnsSeparator && columnsSeparator.hide()
            },
            init: function() {
                var that = this,
                    subscribeToEvents;
                that.callBase();
                that._columnsController = that.getController("columns");
                that._columnHeadersView = that.getView("columnHeadersView");
                that._columnsSeparatorView = that.getView("columnsSeparatorView");
                that._draggingHeaderView = that.getView("draggingHeaderView");
                that._rowsView = that.getView("rowsView");
                that._blockSeparatorView = that.getView("blockSeparatorView");
                that._headerPanelView = that.getView("headerPanel");
                that._columnChooserView = that.getView("columnChooserView");
                subscribeToEvents = function() {
                    if (that._draggingHeaderView) {
                        var draggingPanels = [that._columnChooserView, that._columnHeadersView, that._headerPanelView];
                        that._unsubscribeFromEvents(that._draggingHeaderView, draggingPanels);
                        that._subscribeToEvents(that._draggingHeaderView, draggingPanels)
                    }
                };
                that._columnHeadersView.renderCompleted.add(subscribeToEvents);
                that._headerPanelView && that._headerPanelView.renderCompleted.add(subscribeToEvents);
                that._columnChooserView && that._columnChooserView.renderCompleted.add(subscribeToEvents)
            },
            allowDrop: function(parameters) {
                return this._columnsController.allowMoveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
            },
            dock: function(parameters) {
                var that = this,
                    targetColumnIndex = parameters.targetColumnIndex,
                    sourceLocation = parameters.sourceLocation,
                    sourceColumnIndex = parameters.sourceColumnIndex,
                    sourceColumnElement = parameters.sourceColumnElement,
                    targetLocation = parameters.targetLocation,
                    separator = that._getSeparator(targetLocation),
                    hasTargetColumnIndex = targetColumnIndex >= 0;
                var showSeparator = function() {
                        if (that._animationColumnIndex !== targetColumnIndex) {
                            that.hideSeparators();
                            separator.element()[parameters.isLast ? "insertAfter" : "insertBefore"](parameters.targetColumnElement);
                            that._animationColumnIndex = targetColumnIndex;
                            separator.show(targetLocation)
                        }
                    };
                that._columnHeadersView.element().find("." + DATAGRID_HEADER_ROW_CLASS).toggleClass(DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS, sourceLocation !== "headers" && targetLocation === "headers" && !hasTargetColumnIndex);
                if (separator) {
                    if (sourceColumnElement) {
                        sourceColumnElement.css({opacity: 0.5});
                        if (sourceLocation === "headers")
                            that._rowsView.setRowsOpacity(sourceColumnIndex, 0.5)
                    }
                    if (that.allowDrop(parameters) && hasTargetColumnIndex)
                        if (targetLocation === "group" || targetLocation === "columnChooser")
                            showSeparator();
                        else {
                            that.hideSeparators();
                            separator.moveByX(parameters.posX - separator.width());
                            separator.show()
                        }
                    else
                        that.hideSeparators()
                }
            },
            drop: function(parameters) {
                var sourceColumnElement = parameters.sourceColumnElement;
                if (sourceColumnElement) {
                    sourceColumnElement.css({opacity: ""});
                    this._rowsView.setRowsOpacity(parameters.sourceColumnIndex, "");
                    this._columnHeadersView.element().find("." + DATAGRID_HEADER_ROW_CLASS).removeClass(DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS)
                }
                if (this.allowDrop(parameters)) {
                    var separator = this._getSeparator(parameters.targetLocation);
                    if (separator)
                        separator.hide();
                    this._columnsController.moveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
                }
            },
            dispose: function() {
                if (this._draggingHeaderView)
                    this._unsubscribeFromEvents(this._draggingHeaderView, [this._columnChooserView, this._columnHeadersView, this._headerPanelView])
            }
        });
        dataGrid.__internals = $.extend({}, dataGrid.__internals, {
            DATAGRID_COLUMNS_SEPARATOR_CLASS: DATAGRID_COLUMNS_SEPARATOR_CLASS,
            DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT: DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT,
            DATAGRID_DRAGGING_HEADER_CLASS: DATAGRID_DRAGGING_HEADER_CLASS,
            DATAGRID_HEADERS_DRAG_ACTION_CLASS: DATAGRID_HEADERS_DRAG_ACTION_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_TRACKER_CLASS: DATAGRID_TRACKER_CLASS,
            DATAGRID_MODULE_NAMESPACE: DATAGRID_MODULE_NAMESPACE,
            DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS: DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS,
            WIDGET_CLASS: WIDGET_CLASS
        });
        dataGrid.registerModule("columnsResizingReordering", {
            views: {
                columnsSeparatorView: dataGrid.ColumnsSeparatorView,
                blockSeparatorView: dataGrid.BlockSeparatorView,
                draggingHeaderView: dataGrid.DraggingHeaderView,
                trackerView: dataGrid.TrackerView
            },
            controllers: {
                draggingHeader: dataGrid.DraggingHeaderViewController,
                tablePosition: dataGrid.TablePositionViewController,
                columnsResizer: dataGrid.ColumnsResizerViewController
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.contextMenuView.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_CLASS = "dx-datagrid",
            DATAGRID_CONTEXT_MENU = "dx-context-menu",
            viewName = {
                columnHeadersView: "header",
                rowsView: "content",
                footerView: "footer"
            },
            VIEW_NAMES = ["columnHeadersView", "rowsView", "footerView"];
        dataGrid.ContextMenuController = dataGrid.ViewController.inherit({
            init: function() {
                this.createAction("onContextMenuPreparing")
            },
            getContextMenuItems: function($targetElement) {
                var that = this,
                    view,
                    options,
                    rowIndex,
                    columnIndex,
                    $targetRowElement,
                    $targetCellElement,
                    menuItems;
                $.each(VIEW_NAMES, function() {
                    view = that.getView(this);
                    if (view && view.element().find($targetElement).length) {
                        $targetCellElement = $targetElement.closest("td");
                        $targetRowElement = $targetCellElement.closest(".dx-row");
                        rowIndex = view.getRowIndex($targetRowElement);
                        columnIndex = $targetCellElement[0] && $targetCellElement[0].cellIndex;
                        options = {
                            targetElement: $targetElement,
                            target: viewName[this],
                            rowIndex: rowIndex,
                            row: view._getRows()[rowIndex],
                            columnIndex: columnIndex,
                            column: view.getColumns()[columnIndex],
                            items: view.getContextMenuItems && view.getContextMenuItems($targetElement)
                        };
                        that.executeAction("onContextMenuPreparing", options);
                        menuItems = options.items;
                        if (menuItems)
                            return false
                    }
                });
                return menuItems
            }
        });
        dataGrid.ContextMenuView = dataGrid.View.inherit({_renderCore: function() {
                var that = this;
                this._createComponent(that.element().addClass(DATAGRID_CONTEXT_MENU), "dxContextMenu", {
                    onPositioning: function(actionArgs) {
                        var event = actionArgs.jQueryEvent,
                            $targetElement = $(event.target),
                            contextMenuInstance = actionArgs.component,
                            items = that.getController("contextMenu").getContextMenuItems($targetElement);
                        if (items) {
                            contextMenuInstance.option("items", items);
                            event.stopPropagation()
                        }
                        else
                            actionArgs.canceled = true
                    },
                    onItemClick: function(params) {
                        params.itemData.onItemClick && params.itemData.onItemClick(params)
                    },
                    cssClass: DATAGRID_CLASS,
                    target: that.component.element()
                })
            }});
        dataGrid.registerModule("contextMenu", {
            defaultOptions: function() {
                return {onContextMenuPreparing: null}
            },
            controllers: {contextMenu: dataGrid.ContextMenuController},
            views: {contextMenuView: dataGrid.ContextMenuView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.keyboardNavigation.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            KeyboardProcessor = DX.require("/ui/ui.keyboardProcessor"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer");
        var DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
            DATAGRID_ROWS_VIEW_CLASS = "dx-datagrid-rowsview",
            DATAGRID_MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row",
            DATAGRID_GROUP_FOOTER_CLASS = "dx-datagrid-group-footer",
            DATAGRID_COMMAND_EXPAND_CLASS = "dx-command-expand",
            DATAGRID_CLASS_SELECTOR = ".dx-datagrid",
            DATAGRID_INTERACTIVE_ELEMENTS_SELECTOR = ".dx-checkbox, .dx-menu, input, textarea",
            DATAGRID_VIEWS = ["rowsView"],
            DATAGRID_EDIT_MODE_ROW = "row",
            DATAGRID_EDIT_MODE_FORM = "form";
        dataGrid.KeyboardNavigationController = dataGrid.ViewController.inherit({
            _isRowEditMode: function() {
                var editMode = this._editingController.getEditMode();
                return editMode === DATAGRID_EDIT_MODE_ROW || editMode === DATAGRID_EDIT_MODE_FORM
            },
            _focusView: function(view, viewIndex) {
                this._focusedViews.viewIndex = viewIndex;
                this._focusedView = view
            },
            _focusInteractiveElement: function($cell) {
                var $focusedElement = $cell.find(DATAGRID_INTERACTIVE_ELEMENTS_SELECTOR).first();
                this._testInteractiveElement = $focusedElement;
                $focusedElement.focus()
            },
            _updateFocus: function() {
                var that = this,
                    $cell = that._getFocusedCell();
                if ($cell) {
                    if (that._hasSkipRow($cell.parent()))
                        $cell = that._getNextCell(this._focusedCellPosition && this._focusedCellPosition.rowIndex > 0 ? "upArrow" : "downArrow");
                    if ($cell && $cell.length > 0)
                        setTimeout(function() {
                            if (that.getController("editorFactory").focus())
                                that._focus($cell);
                            that._editingController.isEditing() && $.proxy(that._focusInteractiveElement, that)($cell)
                        })
                }
            },
            _clickHandler: function(e) {
                var event = e.jQueryEvent,
                    $cell = $(event.currentTarget),
                    $grid = $(event.target).closest(DATAGRID_CLASS_SELECTOR).parent();
                if ($grid.is(this.component.element()) && this._isCellValid($cell, true)) {
                    this._focusView(event.data.view, event.data.viewIndex);
                    this._updateFocusedCellPosition($cell);
                    if (!this._editingController.isEditing())
                        $cell.focus()
                }
                else
                    this._resetFocusedCell(this)
            },
            _initFocusedViews: function() {
                var that = this,
                    clickAction = that.createAction(that._clickHandler);
                that._focusedViews = [];
                $.each(DATAGRID_VIEWS, function(key, viewName) {
                    var view = that.getView(viewName);
                    if (view && view.isVisible())
                        that._focusedViews.push(view)
                });
                $.each(that._focusedViews, function(index, view) {
                    if (view)
                        view.renderCompleted.add(function() {
                            var $element = view.element();
                            $element.off(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), clickAction);
                            $element.on(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), "." + DATAGRID_ROW_CLASS + " td", {
                                viewIndex: index,
                                view: view
                            }, clickAction);
                            that._initKeyDownProcessor(that, $element, that._keyDownHandler);
                            if (that._focusedView && that._focusedView.name === view.name && that._isNeedFocus)
                                that._updateFocus()
                        })
                })
            },
            _initKeyDownProcessor: function(context, element, handler) {
                if (this._keyDownProcessor) {
                    this._keyDownProcessor.dispose();
                    this._keyDownProcessor = null
                }
                this._keyDownProcessor = new KeyboardProcessor({
                    element: element,
                    context: context,
                    handler: handler
                })
            },
            _getFocusedCell: function() {
                if (this._focusedView && this._focusedCellPosition)
                    return this._focusedView.getCell(this._focusedCellPosition)
            },
            _updateFocusedCellPosition: function($cell) {
                var that = this,
                    rowsView = that.getView("rowsView");
                if ($cell.length > 0)
                    this._focusedCellPosition = {
                        columnIndex: rowsView.getCellIndex($cell),
                        rowIndex: $cell.parent().length > 0 && that._focusedView ? that._focusedView.getRowIndex($cell.parent()) : null
                    }
            },
            _isCellValid: function($cell, allCommandColumns) {
                if (commonUtils.isDefined($cell)) {
                    var rowsView = this.getView("rowsView"),
                        visibleColumns = this._columnsController.getVisibleColumns(),
                        rowIndex = rowsView.getRowIndex($cell.parent()),
                        columnIndex = rowsView.getCellIndex($cell),
                        column = visibleColumns[columnIndex],
                        editMode = this._editingController.getEditMode(),
                        isEditingCurrentRow = editMode === DATAGRID_EDIT_MODE_ROW ? this._editingController.isEditRow(rowIndex) : this._editingController.isEditing(),
                        isValidGroupSpaceColumn = function() {
                            return column && !commonUtils.isDefined(column.groupIndex) || parseInt($cell.attr("colspan")) > 1
                        };
                    if (visibleColumns.length > columnIndex && isValidGroupSpaceColumn()) {
                        var isExpandColumn = !allCommandColumns ? column.command === "expand" : false;
                        return column && !commonUtils.isDefined(column.command) && (!isEditingCurrentRow || column.allowEditing) || isExpandColumn
                    }
                }
            },
            _isCellByPositionValid: function(cellPosition, allCommandColumns) {
                var $cell = this._focusedView && this._focusedView.getCell(cellPosition);
                return this._isCellValid($cell, allCommandColumns)
            },
            _isGroupRow: function($row) {
                return $row && $row.hasClass(DATAGRID_GROUP_ROW_CLASS)
            },
            _focus: function($cell) {
                var $row = $cell.parent(),
                    $focusedCell = this._getFocusedCell(),
                    $focusElement;
                $focusedCell && $focusedCell.attr("tabindex", null);
                if (this._isGroupRow($row)) {
                    $focusElement = $row;
                    this._focusedCellPosition.rowIndex = this._focusedView.getRowIndex($row)
                }
                else {
                    $focusElement = $cell;
                    this._updateFocusedCellPosition($cell)
                }
                $focusElement.attr("tabindex", 0);
                $focusElement.focus();
                this.getController("editorFactory").focus($focusElement)
            },
            _hasSkipRow: function($row) {
                return $row && ($row.hasClass(DATAGRID_MASTER_DETAIL_ROW_CLASS) || $row.hasClass(DATAGRID_GROUP_FOOTER_CLASS))
            },
            _enterKeyHandler: function(eventArgs, isEditing) {
                var $cell = this._getFocusedCell(),
                    editingOptions = this.option("editing"),
                    rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
                    $row = this._focusedView && this._focusedView.getRow(rowIndex);
                if (this.option("grouping.allowCollapsing") && this._isGroupRow($row) || this.option("masterDetail.enabled") && $cell.hasClass(DATAGRID_COMMAND_EXPAND_CLASS)) {
                    var key = this._dataController.getKeyByRowIndex(rowIndex),
                        item = this._dataController.items()[rowIndex];
                    if (key !== undefined && item && item.data && !item.data.isContinuation)
                        this._dataController.changeRowExpand(key)
                }
                else if (isEditing) {
                    this._updateFocusedCellPosition(this._getCellElementFromTarget(eventArgs.originalEvent.target));
                    if (this._isRowEditMode())
                        setTimeout($.proxy(this._editingController.saveEditData, this._editingController));
                    else
                        this._editingController.closeEditCell()
                }
                else {
                    var column = this._columnsController.getVisibleColumns()[this._focusedCellPosition.columnIndex];
                    if (editingOptions.allowUpdating && column.allowEditing)
                        if (this._isRowEditMode())
                            this._editingController.editRow(rowIndex);
                        else
                            this._focusedCellPosition && this._editingController.editCell(rowIndex, this._focusedCellPosition.columnIndex)
                }
            },
            _leftRightKeysHandler: function(eventArgs, isEditing) {
                var rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
                    $row = this._focusedView && this._focusedView.getRow(rowIndex),
                    directionCode,
                    $cell;
                if (!isEditing && !this._isGroupRow($row)) {
                    directionCode = this._getDirectionCodeByKey(eventArgs.key);
                    $cell = this._getNextCell(directionCode);
                    if ($cell && this._isCellValid($cell))
                        this._focus($cell);
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _getDirectionCodeByKey: function(key) {
                var directionCode;
                if (this.option("rtlEnabled"))
                    directionCode = key === "leftArrow" ? "nextInRow" : "previousInRow";
                else
                    directionCode = key === "leftArrow" ? "previousInRow" : "nextInRow";
                return directionCode
            },
            _upDownKeysHandler: function(eventArgs, isEditing) {
                var rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
                    $cell;
                if (!isEditing) {
                    if (rowIndex === 0 || this._focusedView && rowIndex === this._focusedView.getRowsCount() - 1);
                    $cell = this._getNextCell(eventArgs.key);
                    if ($cell && this._isCellValid($cell))
                        this._focus($cell);
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _pageUpKeyHandler: function(eventArgs) {
                var scrollingMode = this.option("scrolling.mode"),
                    pageIndex = this._dataController.pageIndex(),
                    isVirtualScrolling = scrollingMode === "virtual" || scrollingMode === "infinite";
                if (pageIndex > 0 && !isVirtualScrolling) {
                    this._dataController.pageIndex(pageIndex - 1);
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _pageDownKeyHandler: function(eventArgs) {
                var scrollingMode = this.option("scrolling.mode"),
                    isVirtualScrolling = scrollingMode === "virtual" || scrollingMode === "infinite",
                    pageIndex = this._dataController.pageIndex(),
                    pageCount = this._dataController.pageCount();
                if (pageIndex < pageCount - 1 && !isVirtualScrolling) {
                    this._dataController.pageIndex(pageIndex + 1);
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _spaceKeyHandler: function(eventArgs, isEditing) {
                var rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null;
                if (this.option("selection") && this.option("selection").mode !== "none" && !isEditing) {
                    this._selectionController.changeItemSelection(rowIndex, {
                        shift: eventArgs.shift,
                        control: eventArgs.ctrl
                    });
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _crtlAKeyHandler: function(eventArgs) {
                if (eventArgs.ctrl && this.option("selection.mode") === "multiple" && this.option("selection.allowSelectAll")) {
                    this._selectionController.selectAll();
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _tabKeyHandler: function(eventArgs, isEditing) {
                var editingOptions = this.option("editing"),
                    direction = eventArgs.shift ? "previous" : "next",
                    isOriginalHandlerRequired = !eventArgs.shift && this._isLastValidCell(this._focusedCellPosition) || eventArgs.shift && this._isFirstValidCell(this._focusedCellPosition),
                    $cell;
                if ($(eventArgs.originalEvent.target).closest("." + DATAGRID_MASTER_DETAIL_ROW_CLASS).length) {
                    $cell = this._getNextCell(direction, null, null, true);
                    $cell.attr("tabindex", 0);
                    this._updateFocusedCellPosition($cell);
                    return
                }
                if (editingOptions && eventArgs.originalEvent.target && !isOriginalHandlerRequired)
                    if (isEditing) {
                        var column,
                            isEditingAllowed;
                        this._updateFocusedCellPosition(this._getCellElementFromTarget(eventArgs.originalEvent.target));
                        $cell = this._getNextCell(direction);
                        column = this._columnsController.getVisibleColumns()[this.getView("rowsView").getCellIndex($cell)];
                        isEditingAllowed = editingOptions.allowUpdating && column.allowEditing;
                        if (!isEditingAllowed)
                            this._editingController.closeEditCell();
                        if (this._focusCell($cell))
                            if (!this._isRowEditMode() && isEditingAllowed)
                                this._editingController.editCell(this._focusedCellPosition.rowIndex, this._focusedCellPosition.columnIndex);
                            else
                                this._focusInteractiveElement($cell)
                    }
                    else {
                        $cell = this._getNextCell(direction, this._getElementType(eventArgs.originalEvent.target));
                        this._focusCell($cell)
                    }
                if (isOriginalHandlerRequired) {
                    if (this._editingController.isEditing() && this._editingController.getEditMode() !== this._isRowEditMode())
                        this._editingController.closeEditCell()
                }
                else
                    eventArgs.originalEvent.preventDefault()
            },
            _focusCell: function($cell) {
                if (this._isCellValid($cell)) {
                    this._focus($cell);
                    return true
                }
            },
            _getElementType: function(target) {
                return $(target).is("tr") ? "row" : "cell"
            },
            _escapeKeyHandler: function(eventArgs, isEditing) {
                if (isEditing) {
                    var $cell = this._getCellElementFromTarget(eventArgs.originalEvent.target);
                    this._updateFocusedCellPosition($cell);
                    if (!this._isRowEditMode())
                        this._editingController.closeEditCell();
                    else
                        this._editingController.cancelEditData();
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _ctrlFKeyHandler: function(eventArgs) {
                if (eventArgs.ctrl && this.option("searchPanel") && this.option("searchPanel").visible) {
                    this._testHeaderPanelFocused = true;
                    this._headerPanel.focus();
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _keyDownHandler: function(e) {
                var isEditing = this._editingController.isEditing(),
                    args = {
                        handled: false,
                        jQueryEvent: e.originalEvent
                    };
                this.executeAction("onKeyDown", args);
                if (e.originalEvent.isDefaultPrevented())
                    return;
                this._isNeedFocus = true;
                this._isNeedScroll = true;
                if (!args.handled) {
                    switch (e.key) {
                        case"leftArrow":
                        case"rightArrow":
                            this._leftRightKeysHandler(e, isEditing);
                            break;
                        case"upArrow":
                        case"downArrow":
                            this._upDownKeysHandler(e, isEditing);
                            break;
                        case"pageUp":
                            this._pageUpKeyHandler(e);
                            break;
                        case"pageDown":
                            this._pageDownKeyHandler(e);
                            break;
                        case"space":
                            this._spaceKeyHandler(e, isEditing);
                            break;
                        case"A":
                            this._crtlAKeyHandler(e);
                            break;
                        case"tab":
                            this._tabKeyHandler(e, isEditing);
                            break;
                        case"enter":
                            this._enterKeyHandler(e, isEditing);
                            break;
                        case"escape":
                            this._escapeKeyHandler(e, isEditing);
                            break;
                        case"F":
                            this._ctrlFKeyHandler(e);
                            break
                    }
                    e.originalEvent.stopPropagation()
                }
            },
            _isLastRow: function(rowIndex) {
                return rowIndex === this.getController("data").items().length - 1
            },
            _getNextCell: function(keyCode, elementType, cellPosition) {
                var focusedCellPosition = cellPosition || this._focusedCellPosition,
                    includeCommandCells = $.inArray(keyCode, ["next", "previous"]) > -1,
                    rowIndex,
                    newFocusedCellPosition,
                    $cell,
                    $row;
                if (this._focusedView && focusedCellPosition) {
                    newFocusedCellPosition = this._getNewPositionByCode({
                        columnIndex: focusedCellPosition.columnIndex,
                        rowIndex: focusedCellPosition.rowIndex
                    }, elementType, keyCode);
                    $cell = this._focusedView.getCell(newFocusedCellPosition);
                    if (!this._isCellValid($cell) && this._isCellInRow(newFocusedCellPosition.columnIndex, includeCommandCells))
                        $cell = this._getNextCell(keyCode, "cell", newFocusedCellPosition);
                    $row = $cell && $cell.parent();
                    if (this._hasSkipRow($row)) {
                        rowIndex = this._focusedView.getRowIndex($row);
                        if (!this._isLastRow(rowIndex))
                            $cell = this._getNextCell(keyCode, "row", {
                                columnIndex: focusedCellPosition.columnIndex,
                                rowIndex: rowIndex
                            });
                        else
                            return null
                    }
                    return $cell
                }
                return null
            },
            _getNewPositionByCode: function(cellPosition, elementType, code) {
                var columnIndex = cellPosition.columnIndex,
                    rowIndex = cellPosition.rowIndex,
                    visibleColumnsCount = this.getController("columns").getVisibleColumns().length;
                switch (code) {
                    case"nextInRow":
                    case"next":
                        if (columnIndex < visibleColumnsCount - 1 && !this._isLastValidCell({
                            columnIndex: columnIndex,
                            rowIndex: rowIndex
                        }) && elementType !== "row")
                            columnIndex++;
                        else if (!this._isLastRow(rowIndex) && code === "next") {
                            columnIndex = 0;
                            rowIndex++
                        }
                        break;
                    case"previousInRow":
                    case"previous":
                        if (columnIndex > 0 && !this._isFirstValidCell({
                            columnIndex: columnIndex,
                            rowIndex: rowIndex
                        }) && elementType !== "row")
                            columnIndex--;
                        else if (rowIndex > 0 && code === "previous") {
                            columnIndex = visibleColumnsCount - 1;
                            rowIndex--
                        }
                        break;
                    case"upArrow":
                        rowIndex = rowIndex > 0 ? rowIndex - 1 : rowIndex;
                        break;
                    case"downArrow":
                        rowIndex = !this._isLastRow(rowIndex) ? rowIndex + 1 : rowIndex;
                        break
                }
                return {
                        columnIndex: columnIndex,
                        rowIndex: rowIndex
                    }
            },
            _isFirstValidCell: function(cellPosition) {
                var isFirstValidCell = false;
                if (cellPosition.rowIndex === 0 && cellPosition.columnIndex >= 0)
                    isFirstValidCell = isFirstValidCell || !this._haveValidCellBeforePosition(cellPosition);
                return isFirstValidCell
            },
            _haveValidCellBeforePosition: function(cellPosition) {
                var columnIndex = cellPosition.columnIndex,
                    hasValidCells = false;
                while (columnIndex > 0 && !hasValidCells) {
                    var checkingPosition = {
                            columnIndex: --columnIndex,
                            rowIndex: cellPosition.rowIndex
                        };
                    hasValidCells = this._isCellByPositionValid(checkingPosition)
                }
                return hasValidCells
            },
            _isLastValidCell: function(cellPosition) {
                var checkingPosition = {
                        columnIndex: cellPosition.columnIndex + 1,
                        rowIndex: cellPosition.rowIndex
                    },
                    visibleColumnsCount = this.getController("columns").getVisibleColumns().length,
                    isCheckingCellValid = this._isCellByPositionValid(checkingPosition);
                if (!this._isLastRow(cellPosition.rowIndex) || isCheckingCellValid)
                    return false;
                else if (cellPosition.columnIndex === visibleColumnsCount - 1)
                    return true;
                return this._isLastValidCell(checkingPosition)
            },
            _isCellInRow: function(columnIndex, includeCommandCells) {
                var visibleColumnsCount = this.getController("columns").getVisibleColumns().length;
                return includeCommandCells ? columnIndex >= 0 && columnIndex <= visibleColumnsCount - 1 : columnIndex > 0 && columnIndex < visibleColumnsCount - 1
            },
            _resetFocusedCell: function(that) {
                var $cell = that._getFocusedCell();
                $cell && $cell.attr("tabindex", null);
                that._isNeedFocus = false;
                that._isNeedScroll = false
            },
            _getCellElementFromTarget: function(target) {
                return $(target).closest("." + DATAGRID_ROW_CLASS + "> td")
            },
            init: function() {
                var that = this;
                if (that.option("useKeyboard")) {
                    that._dataController = that.getController("data");
                    that._selectionController = that.getController("selection");
                    that._editingController = that.getController("editing");
                    that._headerPanel = that.getView("headerPanel");
                    that._columnsController = that.getController("columns");
                    that.getController("editorFactory").focused.add(function($element) {
                        that.setupFocusedView();
                        if (that._isNeedScroll)
                            if ($element.is(":visible") && that._focusedView && that._focusedView.getScrollable) {
                                that._scrollToElement($element);
                                that._isNeedScroll = false
                            }
                    });
                    that._focusedCellPosition = {
                        columnIndex: 0,
                        rowIndex: 0
                    };
                    that._dataController.changed.add(function(change) {
                        if (that._focusedCellPosition && change && change.changeType === "prepend")
                            that._focusedCellPosition.rowIndex += change.items.length
                    });
                    that._initFocusedViews();
                    that._documentClickHandler = that.createAction(function(e) {
                        if (!$(e.jQueryEvent.target).closest("." + DATAGRID_ROWS_VIEW_CLASS).length)
                            that._resetFocusedCell(that)
                    });
                    that.createAction("onKeyDown");
                    $(document).on(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), that._documentClickHandler)
                }
            },
            _scrollToElement: function($element, offset) {
                this._focusedView.getScrollable().scrollToElement($element, offset)
            },
            focus: function($element) {
                var focusView = this._getFocusedViewByElement($element);
                if (focusView) {
                    this._focusView(focusView.view, focusView.viewIndex);
                    this._isNeedFocus = true;
                    this._isNeedScroll = true;
                    this._focus($element);
                    this._isHeaderView(focusView.view.name) && this._focusInteractiveElement($element)
                }
            },
            getFocusedView: function() {
                return this._focusedView
            },
            _getFocusedViewByElement: function($element) {
                var condition = function(view) {
                        return $element.closest(view._$element).length
                    };
                return this._getFocusedViewByCondition(condition)
            },
            _getFocusedViewByCondition: function(conditionFunction) {
                var focusView;
                $.each(this._focusedViews, function(index, view) {
                    if (conditionFunction(view)) {
                        focusView = {
                            viewIndex: index,
                            view: view
                        };
                        return false
                    }
                });
                return focusView
            },
            _isHeaderView: function(viewName) {
                return viewName === "columnHeadersView"
            },
            focusViewByName: function(viewName) {
                var view = this._getFocusedViewByName(viewName);
                this._focusView(view.view, view.viewIndex)
            },
            setupFocusedView: function() {
                if (!commonUtils.isDefined(this._focusedView))
                    this.focusViewByName("rowsView")
            },
            _getFocusedViewByName: function(viewName) {
                var condition = function(view) {
                        return view.name === viewName
                    };
                return this._getFocusedViewByCondition(condition)
            },
            optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"useKeyboard":
                        args.handled = true;
                        break;
                    default:
                        that.callBase(args)
                }
            },
            dispose: function() {
                this.callBase();
                this._focusedView = null;
                this._focusedViews = null;
                this._keyDownProcessor && this._keyDownProcessor.dispose();
                $(document).off(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler)
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_GROUP_ROW_CLASS: DATAGRID_GROUP_ROW_CLASS,
            DATAGRID_ROW_CLASS: DATAGRID_ROW_CLASS
        });
        dataGrid.registerModule("keyboardNavigation", {
            defaultOptions: function() {
                return {useKeyboard: true}
            },
            controllers: {keyboardNavigation: dataGrid.KeyboardNavigationController},
            extenders: {
                views: {rowsView: {_renderCore: function(change) {
                            this.callBase(change);
                            this.element().attr("tabindex", this.option("useKeyboard") ? 0 : null);
                            if (change && change.changeType === "update")
                                this.getController("keyboardNavigation")._isNeedFocus = true
                        }}},
                controllers: {editing: {
                        editCell: function(rowIndex, columnIndex) {
                            var isCellEditing = this.callBase(rowIndex, columnIndex),
                                keyboardNavigationController = this.getController("keyboardNavigation");
                            if (isCellEditing)
                                keyboardNavigationController.setupFocusedView();
                            return isCellEditing
                        },
                        getFocusedCellInRow: function(rowIndex) {
                            var keyboardNavigationController = this.getController("keyboardNavigation"),
                                $cell = this.callBase(rowIndex);
                            if (this.option("useKeyboard") && keyboardNavigationController._focusedCellPosition.rowIndex === rowIndex)
                                $cell = keyboardNavigationController._getFocusedCell() || $cell;
                            return $cell
                        }
                    }}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.errorHandling.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_ERROR_ROW_CLASS = "dx-error-row",
            DATAGRID_ERROR_MESSAGE_CLASS = "dx-error-message",
            DATAGRID_ERROR_CLOSEBUTTON_CLASS = "dx-closebutton",
            DATAGRID_ACTION_CLASS = "dx-datagrid-action";
        dataGrid.ErrorHandlingController = dataGrid.ViewController.inherit({
            init: function() {
                var that = this;
                that._columnHeadersView = that.getView("columnHeadersView");
                that._rowsView = that.getView("rowsView")
            },
            _createErrorRow: function(message, $tableElements) {
                var that = this,
                    $errorRow = $("<tr />").addClass(DATAGRID_ERROR_ROW_CLASS),
                    $errorMessage = $("<div/>").addClass(DATAGRID_ERROR_MESSAGE_CLASS).text(message),
                    $closeButton = $("<div/>").addClass(DATAGRID_ERROR_CLOSEBUTTON_CLASS).addClass(DATAGRID_ACTION_CLASS);
                $closeButton.on("dxclick", that.createAction(function(args) {
                    var e = args.jQueryEvent,
                        $errorRow,
                        errorRowIndex = $(e.currentTarget).closest("." + DATAGRID_ERROR_ROW_CLASS).index();
                    e.stopPropagation();
                    $.each($tableElements, function(_, tableElement) {
                        $errorRow = $(tableElement).find("tbody > tr").eq(errorRowIndex);
                        that.removeErrorRow($errorRow)
                    })
                }));
                $("<td/>").attr({
                    colspan: that._columnHeadersView.getColumnCount(),
                    role: "presentation"
                }).prepend($closeButton).append($errorMessage).appendTo($errorRow);
                return $errorRow
            },
            renderErrorRow: function(message, rowIndex) {
                var that = this,
                    $row,
                    $errorRow,
                    rowElements,
                    viewElement = rowIndex >= 0 ? that._rowsView : that._columnHeadersView,
                    $tableElements = viewElement.getTableElements();
                $.each($tableElements, function(_, tableElement) {
                    $errorRow = that._createErrorRow(message, $tableElements);
                    rowElements = $(tableElement).find("tr");
                    if (rowIndex >= 0) {
                        $row = viewElement._getRowElements($(tableElement)).eq(rowIndex);
                        that.removeErrorRow(rowElements.eq($row.index() + 1));
                        $errorRow.insertAfter($row)
                    }
                    else {
                        that.removeErrorRow(rowElements.last());
                        $(tableElement).append($errorRow)
                    }
                })
            },
            removeErrorRow: function($row) {
                $row.hasClass(DATAGRID_ERROR_ROW_CLASS) && $row.remove()
            },
            optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"errorRowEnabled":
                        args.handled = true;
                        break;
                    default:
                        that.callBase(args)
                }
            }
        });
        dataGrid.registerModule("errorHandling", {
            defaultOptions: function() {
                return {errorRowEnabled: true}
            },
            controllers: {errorHandling: dataGrid.ErrorHandlingController},
            extenders: {controllers: {data: {init: function() {
                            var that = this,
                                errorHandlingController = that.getController("errorHandling");
                            that.callBase();
                            that.dataErrorOccurred.add(function(error) {
                                var message = error && error.message || error;
                                if (that.option("errorRowEnabled"))
                                    errorHandlingController.renderErrorRow(message)
                            })
                        }}}}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.summaryModule.js */
    (function($, DX) {
        var ui = DX.ui,
            errors = DevExpress.require("/ui/ui.errors"),
            commonUtils = DX.require("/utils/utils.common"),
            dataGrid = ui.dxDataGrid,
            normalizeSortingInfo = DX.data.utils.normalizeSortingInfo;
        var DATAGRID_TOTAL_FOOTER_CLASS = "dx-datagrid-total-footer",
            DATAGRID_SUMMARY_ITEM_CLASS = "dx-datagrid-summary-item",
            DATAGRID_TEXT_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_GROUP_FOOTER_CLASS = "dx-datagrid-group-footer",
            DATAGRID_GROUP_TEXT_CONTENT_CLASS = "dx-datagrid-group-text-content",
            DATAGRID_GROUP_FOOTER_ROW_TYPE = "groupFooter";
        var renderSummaryCell = function($cell, options) {
                var i,
                    column = options.column,
                    summaryItems = options.summaryItems,
                    summaryItem,
                    $summaryItems = [];
                if (!column.command && summaryItems) {
                    for (i = 0; i < summaryItems.length; i++) {
                        summaryItem = summaryItems[i];
                        $summaryItems.push($("<div>").css("text-align", summaryItem.alignment || column.alignment).addClass(DATAGRID_SUMMARY_ITEM_CLASS).addClass(DATAGRID_TEXT_CONTENT_CLASS).addClass(summaryItem.cssClass).toggleClass(DATAGRID_GROUP_TEXT_CONTENT_CLASS, options.rowType === "group").text(dataGrid.getSummaryText(summaryItem, options.summaryTexts)))
                    }
                    $cell.append($summaryItems)
                }
            },
            getSummaryCellOptions = function(that, options) {
                var summaryTexts = that.option("summary.texts");
                return {
                        totalItem: options.row,
                        summaryItems: options.row.summaryCells[options.columnIndex],
                        summaryTexts: summaryTexts
                    }
            };
        var getGroupAggregates = function(data) {
                return data.summary || data.aggregates || []
            };
        dataGrid.FooterView = dataGrid.ColumnsView.inherit(function() {
            return {
                    _getRows: function() {
                        return this._dataController.footerItems()
                    },
                    _getCellOptions: function(options) {
                        return $.extend(this.callBase(options), getSummaryCellOptions(this, options))
                    },
                    _renderCellContent: function($cell, options) {
                        renderSummaryCell($cell, options);
                        this.callBase($cell, options)
                    },
                    _renderCore: function() {
                        var totalItem = this._dataController.footerItems()[0];
                        this.element().empty().addClass(DATAGRID_TOTAL_FOOTER_CLASS);
                        if (totalItem && totalItem.summaryCells && totalItem.summaryCells.length)
                            this._setTableElement(this._renderTable())
                    },
                    _renderTable: function() {
                        var $table = this.callBase.apply(this, arguments),
                            $content = this.element();
                        this.wrapTableInScrollContainer($table).appendTo($content);
                        return $table
                    },
                    _rowClick: function(e) {
                        var item = this._dataController.footerItems()[e.rowIndex] || {};
                        this.executeAction("onRowClick", $.extend({}, e, item))
                    },
                    _columnOptionChanged: function(e) {
                        var optionNames = e.optionNames;
                        if (e.changeTypes.grouping)
                            return;
                        if (optionNames.width || optionNames.visibleWidth)
                            this.callBase(e)
                    },
                    _handleDataChanged: function(e) {
                        if (e.changeType === "refresh")
                            this.render()
                    },
                    getHeight: function() {
                        var $element = this.element();
                        return $element ? $element.outerHeight() : 0
                    },
                    isVisible: function() {
                        return !!this._dataController.footerItems().length
                    }
                }
        }());
        var SummaryDataSourceAdapterExtender = function() {
                return {
                        init: function() {
                            this.callBase.apply(this, arguments);
                            this._totalAggregates = []
                        },
                        summary: function(summary) {
                            if (!arguments.length)
                                return this._summary;
                            this._summary = summary
                        },
                        totalAggregates: function() {
                            return this._totalAggregates
                        }
                    }
            }();
        var SummaryDataSourceAdapterClientExtender = function() {
                var calculateAggregates = function(that, summary, data, groupLevel) {
                        var calculator;
                        if (summary) {
                            calculator = new DX.data.AggregateCalculator({
                                totalAggregates: summary.totalAggregates,
                                groupAggregates: summary.groupAggregates,
                                data: data,
                                groupLevel: groupLevel
                            });
                            calculator.calculate()
                        }
                        that._totalAggregates = calculator ? calculator.totalAggregates() : []
                    };
                var sortGroupsBySummaryCore = function(items, groups, sortByGroups) {
                        if (!items || !groups.length)
                            return items;
                        var group = groups[0],
                            sorts = sortByGroups[0],
                            query;
                        if (group && sorts && sorts.length) {
                            query = DX.data.query(items);
                            $.each(sorts, function(index) {
                                if (index === 0)
                                    query = query.sortBy(this.selector, this.desc);
                                else
                                    query = query.thenBy(this.selector, this.desc)
                            });
                            query.enumerate().done(function(sortedItems) {
                                items = sortedItems
                            })
                        }
                        groups = groups.slice(1);
                        sortByGroups = sortByGroups.slice(1);
                        if (groups.length && sortByGroups.length)
                            $.each(items, function() {
                                this.items = sortGroupsBySummaryCore(this.items, groups, sortByGroups)
                            });
                        return items
                    };
                var sortGroupsBySummary = function(data, group, summary) {
                        var sortByGroups = summary && summary.sortByGroups && summary.sortByGroups();
                        if (sortByGroups && sortByGroups.length)
                            return sortGroupsBySummaryCore(data, group, sortByGroups);
                        return data
                    };
                return {
                        _handleDataLoadingCore: function(options) {
                            var summary = this.summary();
                            if (summary)
                                if (options.remoteOperations.summary) {
                                    options.storeLoadOptions.groupSummary = summary.groupAggregates;
                                    options.storeLoadOptions.totalSummary = summary.totalAggregates
                                }
                                else if (summary.totalAggregates.length || summary.groupAggregates.length && options.storeLoadOptions.group)
                                    options.remoteOperations.paging = false;
                            this.callBase(options)
                        },
                        _handleDataLoadedCore: function(options) {
                            var that = this,
                                groups = normalizeSortingInfo(options.loadOptions.group || []),
                                summary = that.summary(),
                                remoteOperations = options.remoteOperations || {};
                            if (remoteOperations.summary)
                                that._totalAggregates = options.extra && options.extra.summary || that._totalAggregates;
                            else if (!remoteOperations.paging) {
                                calculateAggregates(that, summary, options.data, groups.length);
                                options.data = sortGroupsBySummary(options.data, groups, summary);
                                options.totalAggregates = that._totalAggregates
                            }
                            that.callBase(options)
                        }
                    }
            }();
        dataGrid.DataSourceAdapter = dataGrid.DataSourceAdapter.inherit(SummaryDataSourceAdapterExtender).inherit(SummaryDataSourceAdapterClientExtender);
        dataGrid.renderSummaryCell = renderSummaryCell;
        $.extend(dataGrid.__internals, {
            DATAGRID_TOTAL_FOOTER_CLASS: DATAGRID_TOTAL_FOOTER_CLASS,
            DATAGRID_SUMMARY_ITEM_CLASS: DATAGRID_SUMMARY_ITEM_CLASS,
            DATAGRID_GROUP_FOOTER_CLASS: DATAGRID_GROUP_FOOTER_CLASS
        });
        dataGrid.registerModule("summary", {
            defaultOptions: function() {
                return {
                        summary: {
                            groupItems: undefined,
                            totalItems: undefined,
                            calculateCustomSummary: undefined,
                            texts: {
                                sum: Globalize.localize("dxDataGrid-summarySum"),
                                sumOtherColumn: Globalize.localize("dxDataGrid-summarySumOtherColumn"),
                                min: Globalize.localize("dxDataGrid-summaryMin"),
                                minOtherColumn: Globalize.localize("dxDataGrid-summaryMinOtherColumn"),
                                max: Globalize.localize("dxDataGrid-summaryMax"),
                                maxOtherColumn: Globalize.localize("dxDataGrid-summaryMaxOtherColumn"),
                                avg: Globalize.localize("dxDataGrid-summaryAvg"),
                                avgOtherColumn: Globalize.localize("dxDataGrid-summaryAvgOtherColumn"),
                                count: Globalize.localize("dxDataGrid-summaryCount")
                            }
                        },
                        sortByGroupSummaryInfo: undefined
                    }
            },
            views: {footerView: dataGrid.FooterView},
            extenders: {
                controllers: {data: function() {
                        return {
                                _isDataColumn: function(column) {
                                    return column && (!commonUtils.isDefined(column.groupIndex) || column.showWhenGrouped)
                                },
                                _isGroupFooterVisible: function() {
                                    var groupItems = this.option("summary.groupItems") || [],
                                        groupItem,
                                        column,
                                        i;
                                    for (i = 0; i < groupItems.length; i++) {
                                        groupItem = groupItems[i];
                                        column = this._columnsController.columnOption(groupItem.column);
                                        if (groupItem.showInGroupFooter && this._isDataColumn(column))
                                            return true
                                    }
                                    return false
                                },
                                _processGroupItems: function(items, groupCount, options) {
                                    var result = this.callBase.apply(this, arguments);
                                    if (options) {
                                        if (options.isGroupFooterVisible === undefined)
                                            options.isGroupFooterVisible = this._isGroupFooterVisible();
                                        if (options.data && options.data.items && options.isGroupFooterVisible)
                                            result.push({
                                                rowType: DATAGRID_GROUP_FOOTER_ROW_TYPE,
                                                data: options.data,
                                                groupIndex: options.path.length - 1,
                                                values: []
                                            })
                                    }
                                    return result
                                },
                                _processGroupItem: function(groupItem, options) {
                                    var that = this;
                                    if (!options.summaryGroupItems)
                                        options.summaryGroupItems = that.option("summary.groupItems") || [];
                                    if (groupItem.rowType === "group") {
                                        var groupColumnIndex = -1,
                                            afterGroupColumnIndex = -1;
                                        $.each(options.visibleColumns, function(visibleIndex) {
                                            var prevColumn = options.visibleColumns[visibleIndex - 1];
                                            if (groupItem.groupIndex === this.groupIndex)
                                                groupColumnIndex = this.index;
                                            if (visibleIndex > 0 && prevColumn.command === "expand" && this.command !== "expand")
                                                afterGroupColumnIndex = this.index
                                        });
                                        groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, getGroupAggregates(groupItem.data), options.visibleColumns, function(summaryItem, column) {
                                            if (summaryItem.showInGroupFooter)
                                                return -1;
                                            if (summaryItem.alignByColumn && column && !commonUtils.isDefined(column.groupIndex) && column.index !== afterGroupColumnIndex)
                                                return column.index;
                                            else
                                                return groupColumnIndex
                                        })
                                    }
                                    if (groupItem.rowType === DATAGRID_GROUP_FOOTER_ROW_TYPE)
                                        groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, getGroupAggregates(groupItem.data), options.visibleColumns, function(summaryItem, column) {
                                            return summaryItem.showInGroupFooter && that._isDataColumn(column) ? column.index : -1
                                        });
                                    return groupItem
                                },
                                _calculateSummaryCells: function(summaryItems, aggregates, visibleColumns, calculateTargetColumnIndex) {
                                    var that = this,
                                        summaryCells = [],
                                        summaryCellsByColumns = {};
                                    $.each(summaryItems, function(summaryIndex, summaryItem) {
                                        var column = that._columnsController.columnOption(summaryItem.column),
                                            showInColumn = summaryItem.showInColumn && that._columnsController.columnOption(summaryItem.showInColumn) || column,
                                            columnIndex = calculateTargetColumnIndex(summaryItem, showInColumn),
                                            aggregate;
                                        if (columnIndex >= 0) {
                                            if (!summaryCellsByColumns[columnIndex])
                                                summaryCellsByColumns[columnIndex] = [];
                                            aggregate = aggregates[summaryIndex];
                                            if (aggregate === aggregate)
                                                summaryCellsByColumns[columnIndex].push($.extend({}, summaryItem, {
                                                    value: aggregate,
                                                    valueFormat: !commonUtils.isDefined(summaryItem.valueFormat) ? dataGrid.getFormatByDataType(column && column.dataType) : summaryItem.valueFormat,
                                                    columnCaption: column && column.index !== columnIndex ? column.caption : undefined
                                                }))
                                        }
                                    });
                                    if (!$.isEmptyObject(summaryCellsByColumns))
                                        $.each(visibleColumns, function() {
                                            summaryCells.push(summaryCellsByColumns[this.index] || [])
                                        });
                                    return summaryCells
                                },
                                _getSummaryCells: function(summaryTotalItems, totalAggregates) {
                                    var that = this,
                                        columnsController = that._columnsController;
                                    return that._calculateSummaryCells(summaryTotalItems, totalAggregates, columnsController.getVisibleColumns(), function(summaryItem, column) {
                                            return that._isDataColumn(column) ? column.index : -1
                                        })
                                },
                                _updateItemsCore: function(change) {
                                    var that = this,
                                        summaryCells,
                                        totalAggregates,
                                        dataSource = that._dataSource,
                                        summaryTotalItems = that.option("summary.totalItems");
                                    that.callBase(change);
                                    that._footerItems = [];
                                    if (dataSource && summaryTotalItems && summaryTotalItems.length) {
                                        totalAggregates = dataSource.totalAggregates();
                                        summaryCells = this._getSummaryCells(summaryTotalItems, totalAggregates);
                                        if (summaryCells.length)
                                            that._footerItems.push({
                                                rowType: "totalFooter",
                                                summaryCells: summaryCells
                                            })
                                    }
                                },
                                _getAggregates: function(summaryItems, remoteOperations) {
                                    var that = this,
                                        columnsController = that.getController("columns"),
                                        calculateCustomSummary = that.option("summary.calculateCustomSummary");
                                    return $.map(summaryItems || [], function(summaryItem) {
                                            var column = columnsController.columnOption(summaryItem.column),
                                                calculateCellValue = column && column.calculateCellValue ? $.proxy(column, "calculateCellValue") : DX.data.utils.compileGetter(column ? column.dataField : summaryItem.column),
                                                aggregator = summaryItem.summaryType || "count",
                                                selector = summaryItem.column,
                                                options;
                                            if (remoteOperations && remoteOperations.summary)
                                                return {
                                                        selector: summaryItem.column,
                                                        summaryType: summaryItem.summaryType
                                                    };
                                            else {
                                                if (aggregator === "avg" || aggregator === "sum")
                                                    selector = function(data) {
                                                        return Number(calculateCellValue(data))
                                                    };
                                                else
                                                    selector = calculateCellValue;
                                                if (aggregator === "custom") {
                                                    if (!calculateCustomSummary) {
                                                        errors.log("E1026");
                                                        calculateCustomSummary = function(){}
                                                    }
                                                    options = {
                                                        component: that.component,
                                                        name: summaryItem.name
                                                    };
                                                    calculateCustomSummary(options);
                                                    options.summaryProcess = "calculate";
                                                    aggregator = {
                                                        seed: function() {
                                                            options.summaryProcess = "start";
                                                            options.totalValue = undefined;
                                                            delete options.value;
                                                            calculateCustomSummary(options);
                                                            return options.totalValue
                                                        },
                                                        step: function(totalValue, value) {
                                                            options.summaryProcess = "calculate";
                                                            options.totalValue = totalValue;
                                                            options.value = value;
                                                            calculateCustomSummary(options);
                                                            return options.totalValue
                                                        },
                                                        finalize: function(totalValue) {
                                                            options.summaryProcess = "finalize";
                                                            options.totalValue = totalValue;
                                                            delete options.value;
                                                            calculateCustomSummary(options);
                                                            return options.totalValue
                                                        }
                                                    }
                                                }
                                                return {
                                                        selector: selector,
                                                        aggregator: aggregator
                                                    }
                                            }
                                        })
                                },
                                _addSortInfo: function(sortByGroups, groupColumn, selector, sortOrder) {
                                    var groupIndex;
                                    if (groupColumn) {
                                        groupIndex = groupColumn.groupIndex;
                                        sortOrder = sortOrder || groupColumn.sortOrder;
                                        if (commonUtils.isDefined(groupIndex)) {
                                            sortByGroups[groupIndex] = sortByGroups[groupIndex] || [];
                                            sortByGroups[groupIndex].push({
                                                selector: selector,
                                                desc: sortOrder === "desc"
                                            })
                                        }
                                    }
                                },
                                _findSummaryItem: function(summaryItems, name) {
                                    var summaryItemIndex = -1;
                                    var getFullName = function(summaryItem) {
                                            var summaryType = summaryItem.summaryType,
                                                column = summaryItem.column;
                                            return summaryType && column && summaryType + "_" + column
                                        };
                                    if (commonUtils.isDefined(name))
                                        $.each(summaryItems || [], function(index) {
                                            if (this.name === name || index === name || this.summaryType === name || this.column === name || getFullName(this) === name) {
                                                summaryItemIndex = index;
                                                return false
                                            }
                                        });
                                    return summaryItemIndex
                                },
                                _getSummarySortByGroups: function(sortByGroupSummaryInfo, groupSummaryItems) {
                                    var that = this,
                                        columnsController = that._columnsController,
                                        groupColumns = columnsController.getGroupColumns(),
                                        sortByGroups = [];
                                    if (!groupSummaryItems || !groupSummaryItems.length)
                                        return;
                                    $.each(sortByGroupSummaryInfo || [], function() {
                                        var sortOrder = this.sortOrder,
                                            groupColumn = this.groupColumn,
                                            summaryItemIndex = that._findSummaryItem(groupSummaryItems, this.summaryItem);
                                        if (summaryItemIndex < 0)
                                            return;
                                        var selector = function(data) {
                                                return getGroupAggregates(data)[summaryItemIndex]
                                            };
                                        if (commonUtils.isDefined(groupColumn)) {
                                            groupColumn = columnsController.columnOption(groupColumn);
                                            that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder)
                                        }
                                        else
                                            $.each(groupColumns, function(groupIndex, groupColumn) {
                                                that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder)
                                            })
                                    });
                                    return sortByGroups
                                },
                                _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
                                    var summary = this._getSummaryOptions(remoteOperations),
                                        dataSourceAdapter = this.callBase(dataSource, remoteOperations);
                                    dataSourceAdapter.summary(summary);
                                    return dataSourceAdapter
                                },
                                _getSummaryOptions: function(remoteOperations) {
                                    var that = this,
                                        groupSummaryItems = that.option("summary.groupItems"),
                                        totalSummaryItems = that.option("summary.totalItems"),
                                        sortByGroupSummaryInfo = that.option("sortByGroupSummaryInfo"),
                                        groupAggregates = that._getAggregates(groupSummaryItems, remoteOperations),
                                        totalAggregates = that._getAggregates(totalSummaryItems, remoteOperations),
                                        sortByGroups = function() {
                                            return that._getSummarySortByGroups(sortByGroupSummaryInfo, groupSummaryItems)
                                        };
                                    if (groupAggregates.length || totalAggregates.length)
                                        return {
                                                groupAggregates: groupAggregates,
                                                totalAggregates: totalAggregates,
                                                sortByGroups: sortByGroups
                                            }
                                },
                                publicMethods: function() {
                                    var methods = this.callBase();
                                    methods.push("getTotalSummaryValue");
                                    return methods
                                },
                                getTotalSummaryValue: function(summaryItemName) {
                                    var summaryItemIndex = this._findSummaryItem(this.option("summary.totalItems"), summaryItemName),
                                        aggregates = this._dataSource.totalAggregates();
                                    if (aggregates.length && summaryItemIndex > -1)
                                        return aggregates[summaryItemIndex]
                                },
                                optionChanged: function(args) {
                                    if (args.name === "summary" || args.name === "sortByGroupSummaryInfo")
                                        args.name = "dataSource";
                                    this.callBase(args)
                                },
                                init: function() {
                                    this._footerItems = [];
                                    this.callBase()
                                },
                                footerItems: function() {
                                    return this._footerItems
                                }
                            }
                    }()},
                views: {rowsView: function() {
                        return {
                                _createRow: function(row) {
                                    var $row = this.callBase(row);
                                    row && $row.addClass(row.rowType === DATAGRID_GROUP_FOOTER_ROW_TYPE ? DATAGRID_GROUP_FOOTER_CLASS : "");
                                    return $row
                                },
                                _renderCells: function($row, options) {
                                    this.callBase.apply(this, arguments);
                                    if (options.row.rowType === "group" && options.row.summaryCells && options.row.summaryCells.length)
                                        this._renderGroupSummaryCells($row, options)
                                },
                                _hasAlignByColumnSummaryItems: function(columnIndex, options) {
                                    return !commonUtils.isDefined(options.columns[columnIndex].groupIndex) && options.row.summaryCells[columnIndex].length
                                },
                                _getAlignByColumnCellCount: function(groupCellColSpan, options) {
                                    var alignByColumnCellCount = 0,
                                        columnIndex;
                                    for (var i = 1; i < groupCellColSpan; i++) {
                                        columnIndex = options.row.summaryCells.length - i;
                                        alignByColumnCellCount = this._hasAlignByColumnSummaryItems(columnIndex, options) ? i : alignByColumnCellCount
                                    }
                                    return alignByColumnCellCount
                                },
                                _renderGroupSummaryCells: function($row, options) {
                                    var $groupCell = $row.children().last(),
                                        groupCellColSpan = Number($groupCell.attr("colspan")) || 1,
                                        alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);
                                    this._renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount)
                                },
                                _renderGroupSummaryCellsCore: function($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
                                    if (alignByColumnCellCount > 0) {
                                        $groupCell.attr("colspan", groupCellColSpan - alignByColumnCellCount);
                                        for (var i = 0; i < alignByColumnCellCount; i++) {
                                            var columnIndex = options.columns.length - alignByColumnCellCount + i;
                                            this._renderCell($groupCell.parent(), $.extend({
                                                column: options.columns[columnIndex],
                                                columnIndex: columnIndex
                                            }, options))
                                        }
                                    }
                                },
                                _getColumnTemplate: function(options) {
                                    if (!options.column.command && !commonUtils.isDefined(options.column.groupIndex) && options.summaryItems && options.summaryItems.length)
                                        return renderSummaryCell;
                                    else
                                        return this.callBase(options)
                                },
                                _getCellOptions: function(options) {
                                    var that = this,
                                        parameters = that.callBase(options);
                                    if (options.row.summaryCells)
                                        return $.extend(parameters, getSummaryCellOptions(that, options));
                                    else
                                        return parameters
                                }
                            }
                    }()}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.fixedColumns.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            commonUtils = DX.require("/utils/utils.common"),
            wheelEvent = DX.require("/ui/events/ui.events.wheel"),
            dataGrid = ui.dxDataGrid;
        var DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
            DATAGRID_FIRST_CELL_CLASS = "dx-first-cell",
            DATAGRID_HOVER_STATE_CLASS = "dx-state-hover",
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            DATAGRID_CONTENT_FIXED_CLASS = "dx-datagrid-content-fixed",
            DATAGRID_FIXED_COL_CLASS = "dx-col-fixed",
            DATAGRID_POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target",
            DATAGRID_POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
            getTransparentColumnIndex = function(fixedColumns) {
                var transparentColumnIndex = -1;
                $.each(fixedColumns, function(index, column) {
                    if (column.command === "transparent") {
                        transparentColumnIndex = index;
                        return false
                    }
                });
                return transparentColumnIndex
            };
        var baseFixedColumns = {
                init: function() {
                    this.callBase();
                    this._isFixedTableRendering = false;
                    this._isFixedColumns = false
                },
                _createCol: function(column) {
                    return this.callBase(column).toggleClass(DATAGRID_FIXED_COL_CLASS, this._isFixedTableRendering && (column.fixed || column.command && column.command !== "transparent"))
                },
                _createCell: function(column) {
                    var $cell = this.callBase(column);
                    if (column.colspan)
                        $cell.attr("colspan", column.colspan);
                    if (column.command === "transparent")
                        $cell.addClass(DATAGRID_POINTER_EVENTS_NONE_CLASS);
                    return $cell
                },
                _renderTable: function(options) {
                    var that = this,
                        $fixedTable,
                        $table,
                        fixedColumns = that._columnsController.getFixedColumns();
                    that._isFixedColumns = !!fixedColumns.length;
                    $table = that.callBase(options);
                    if (that._isFixedColumns) {
                        that._isFixedTableRendering = true;
                        that._fixedTableElement = $fixedTable = that._createTable(fixedColumns);
                        $fixedTable.addClass(DATAGRID_POINTER_EVENTS_NONE_CLASS);
                        that._renderRows($fixedTable, $.extend({}, options, {columns: fixedColumns}));
                        that.wrapTableInScrollContainer(that._fixedTableElement).appendTo(that.element()).addClass(DATAGRID_CONTENT_FIXED_CLASS + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS);
                        that._isFixedTableRendering = false
                    }
                    else {
                        that._fixedTableElement && that._fixedTableElement.remove();
                        that._fixedTableElement = null
                    }
                    return $table
                },
                _renderCellContent: function($cell, options) {
                    var that = this,
                        trasparentColumnIndex,
                        column = options.column;
                    if (!that._isFixedTableRendering && that._isFixedColumns && (options.rowType !== "group" || !commonUtils.isDefined(column.groupIndex))) {
                        if (column.fixed || column.command) {
                            $cell.html("&nbsp;").addClass(column.cssClass);
                            return
                        }
                        if (options.rowType === "filter") {
                            that.callBase($cell, options);
                            trasparentColumnIndex = getTransparentColumnIndex(that._columnsController.getFixedColumns());
                            $cell.toggleClass(DATAGRID_FIRST_CELL_CLASS, options.columnIndex === trasparentColumnIndex);
                            return
                        }
                    }
                    if (column.command !== "transparent")
                        that.callBase($cell, options)
                },
                getCellElements: function(rowIndex) {
                    var that = this,
                        fixedColumns,
                        fixedColumnIndex = 0,
                        fixedCellElements,
                        cellElements = that.callBase(rowIndex);
                    if (that._fixedTableElement && cellElements) {
                        fixedColumns = that._columnsController.getFixedColumns(),
                        fixedCellElements = that._fixedTableElement.find(".dx-row").eq(rowIndex).children("td");
                        $.each(fixedColumns, function(index, column) {
                            if (column.command === "transparent") {
                                if (fixedCellElements.eq(index).hasClass(DATAGRID_MASTER_DETAIL_CELL_CLASS))
                                    cellElements[fixedColumnIndex] = fixedCellElements.get(index);
                                fixedColumnIndex += column.colspan
                            }
                            else {
                                cellElements[fixedColumnIndex] = fixedCellElements.get(index);
                                fixedColumnIndex++
                            }
                        })
                    }
                    return cellElements
                },
                getColumnWidths: function() {
                    var that = this,
                        i,
                        fixedColumnIndex = 0,
                        widths,
                        result = that.callBase(),
                        fixedColumns = that._columnsController.getFixedColumns();
                    if (that._fixedTableElement && result.length) {
                        widths = dataGrid.getWidths(that._fixedTableElement);
                        for (i = 0; i < fixedColumns.length; i++)
                            if (fixedColumns[i].command === "transparent")
                                fixedColumnIndex += fixedColumns[i].colspan;
                            else {
                                if (result[fixedColumnIndex] < widths[i])
                                    result[fixedColumnIndex] = widths[i];
                                fixedColumnIndex++
                            }
                    }
                    return result
                },
                _getTableElement: function() {
                    var tableElement = this._isFixedTableRendering ? this._fixedTableElement : this.callBase();
                    return tableElement
                },
                _setTableElement: function(tableElement) {
                    if (this._isFixedTableRendering)
                        this._fixedTableElement = tableElement;
                    else
                        this.callBase(tableElement)
                },
                getColumns: function($tableElement) {
                    $tableElement = $tableElement || this._getTableElement();
                    if (this._isFixedTableRendering || $tableElement && $tableElement.closest("table").parent("." + DATAGRID_CONTENT_FIXED_CLASS).length)
                        return this._columnsController.getFixedColumns();
                    return this.callBase($tableElement)
                },
                getRowIndex: function($row) {
                    var $fixedTable = this._fixedTableElement;
                    if ($fixedTable && $fixedTable.find($row).length)
                        return this._getRowElements($fixedTable).index($row);
                    return this.callBase($row)
                },
                getTableElements: function() {
                    var result = this.callBase.apply(this, arguments);
                    if (this._fixedTableElement)
                        result = result.add(this._fixedTableElement);
                    return result
                },
                getFixedColumns: function() {
                    return this._columnsController.getFixedColumns()
                },
                getFixedColumnsOffset: function() {
                    var offset = {
                            left: 0,
                            right: 0
                        },
                        $transparentColumn,
                        positionTransparentColumn;
                    if (this._fixedTableElement) {
                        $transparentColumn = this.getTransparentColumnElement();
                        positionTransparentColumn = $transparentColumn.position();
                        offset = {
                            left: positionTransparentColumn.left,
                            right: this.element().outerWidth(true) - ($transparentColumn.outerWidth(true) + positionTransparentColumn.left)
                        }
                    }
                    return offset
                },
                getTransparentColumnElement: function() {
                    return this._fixedTableElement && this._fixedTableElement.find("." + DATAGRID_POINTER_EVENTS_NONE_CLASS).first()
                },
                getFixedTableElement: function() {
                    return this._fixedTableElement
                },
                isFixedColumns: function() {
                    return this._isFixedColumns
                },
                _resizeCore: function() {
                    this.callBase();
                    this.synchronizeRows()
                },
                setColumnWidths: function(widths) {
                    this.callBase(widths);
                    this.synchronizeRows()
                },
                _getClientHeight: function(element) {
                    var boundingClientRectElement = element.getBoundingClientRect && element.getBoundingClientRect();
                    return boundingClientRectElement && boundingClientRectElement.height ? boundingClientRectElement.height : element.clientHeight
                },
                synchronizeRows: function() {
                    var that = this,
                        rowHeight,
                        fixedRowHeight,
                        rowHeights = [],
                        fixedRowHeights = [],
                        rowIndex,
                        heightTable,
                        heightFixedTable,
                        $rowElements,
                        $fixedRowElements;
                    if (that._isFixedColumns && that._tableElement && that._fixedTableElement) {
                        heightTable = that._getClientHeight(that._tableElement.get(0));
                        heightFixedTable = that._getClientHeight(that._fixedTableElement.get(0));
                        $rowElements = that._getRowElements(that._tableElement);
                        $fixedRowElements = that._getRowElements(that._fixedTableElement);
                        if (heightTable !== heightFixedTable) {
                            $rowElements.css("height", "");
                            $fixedRowElements.css("height", "");
                            for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
                                rowHeights.push(that._getClientHeight($rowElements.get(rowIndex)));
                                fixedRowHeights.push(that._getClientHeight($fixedRowElements.get(rowIndex)))
                            }
                            for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
                                rowHeight = rowHeights[rowIndex];
                                fixedRowHeight = fixedRowHeights[rowIndex];
                                if (rowHeight > fixedRowHeight)
                                    $fixedRowElements.eq(rowIndex).css("height", rowHeight);
                                else if (rowHeight < fixedRowHeight)
                                    $rowElements.eq(rowIndex).css("height", fixedRowHeight)
                            }
                        }
                    }
                }
            };
        var ColumnHeadersViewFixedColumnsExtender = $.extend({}, baseFixedColumns, {
                getContextMenuItems: function($targetElement) {
                    var that = this,
                        $cell,
                        column,
                        onItemClick,
                        columnFixingOptions = that.option("columnFixing"),
                        items = that.callBase($targetElement);
                    if ($targetElement.closest("." + DATAGRID_HEADER_ROW_CLASS).length) {
                        $cell = $targetElement.closest("td");
                        column = $cell.length && that.getColumns($targetElement)[$cell[0].cellIndex];
                        if (column.allowFixing) {
                            onItemClick = function(params) {
                                switch (params.itemData.value) {
                                    case"none":
                                        that._columnsController.columnOption(column.index, "fixed", false);
                                        break;
                                    case"left":
                                        that._columnsController.columnOption(column.index, {
                                            fixed: true,
                                            fixedPosition: "left"
                                        });
                                        break;
                                    case"right":
                                        that._columnsController.columnOption(column.index, {
                                            fixed: true,
                                            fixedPosition: "right"
                                        });
                                        break
                                }
                            };
                            items.push({
                                text: columnFixingOptions.texts.fix,
                                beginGroup: true,
                                items: [{
                                        text: columnFixingOptions.texts.leftPosition,
                                        value: "left",
                                        disabled: column.fixed && (!column.fixedPosition || column.fixedPosition === "left"),
                                        onItemClick: onItemClick
                                    }, {
                                        text: columnFixingOptions.texts.rightPosition,
                                        value: "right",
                                        disabled: column.fixed && column.fixedPosition === "right",
                                        onItemClick: onItemClick
                                    }]
                            }, {
                                text: columnFixingOptions.texts.unfix,
                                value: "none",
                                disabled: !column.fixed,
                                onItemClick: onItemClick
                            })
                        }
                    }
                    return items
                },
                setScrollerSpacing: function(width) {
                    var that = this,
                        rtlEnabled = that.option("rtlEnabled");
                    that.callBase(width);
                    that.element().children("." + DATAGRID_CONTENT_FIXED_CLASS).css(rtlEnabled ? {paddingLeft: width} : {paddingRight: width})
                },
                getFixedColumnElements: function() {
                    return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(0).children()
                }
            });
        var RowsViewFixedColumnsExtender = $.extend({}, baseFixedColumns, {
                _detachHoverEvents: function() {
                    this._fixedTableElement && this._fixedTableElement.off("mouseover mouseout", ".dx-data-row");
                    this._tableElement && this._tableElement.off("mouseover mouseout", ".dx-data-row")
                },
                _attachHoverEvents: function() {
                    var that = this,
                        attachHoverEvent = function($table) {
                            $table.on("mouseover mouseout", ".dx-data-row", that.createAction(function(args) {
                                var event = args.jQueryEvent,
                                    rowIndex = that.getRowIndex($(event.target).closest(".dx-row")),
                                    isHover = event.type === "mouseover";
                                that._tableElement && that._getRowElements(that._tableElement).eq(rowIndex).toggleClass(DATAGRID_HOVER_STATE_CLASS, isHover);
                                that._fixedTableElement && that._getRowElements(that._fixedTableElement).eq(rowIndex).toggleClass(DATAGRID_HOVER_STATE_CLASS, isHover)
                            }))
                        };
                    if (that._fixedTableElement && that._tableElement) {
                        attachHoverEvent(that._fixedTableElement);
                        attachHoverEvent(that._tableElement)
                    }
                },
                _renderTable: function(options) {
                    var that = this,
                        $content,
                        $table,
                        $fixedTable,
                        fixedColumns = that._columnsController.getFixedColumns();
                    that._isFixedColumns = !!fixedColumns.length;
                    $table = that.callBase(options);
                    if (that._isFixedColumns) {
                        that._isFixedTableRendering = true;
                        $fixedTable = that._createTable(fixedColumns);
                        $fixedTable.addClass(DATAGRID_POINTER_EVENTS_NONE_CLASS);
                        that._fixedTableElement = that._fixedTableElement || $fixedTable;
                        that._renderRows($fixedTable, $.extend({}, options, {columns: fixedColumns}));
                        $content = that._findContentElement();
                        that._updateContent($content, options.change, $fixedTable);
                        that._isFixedTableRendering = false
                    }
                    else {
                        that._fixedTableElement && that._fixedTableElement.remove();
                        that._fixedTableElement = null
                    }
                    return $table
                },
                _findContentElement: function() {
                    var that = this,
                        $content,
                        scrollable,
                        scrollTop,
                        element = that.element();
                    if (element && that._isFixedTableRendering) {
                        $content = element.children("." + DATAGRID_CONTENT_CLASS);
                        if (!$content.length) {
                            scrollable = that.getScrollable();
                            $content = $("<div/>").addClass(DATAGRID_CONTENT_CLASS).on("scroll", function(e) {
                                scrollTop = $(e.target).scrollTop();
                                if (scrollTop) {
                                    $(e.target).scrollTop(0);
                                    scrollable.scrollTo({y: that._scrollTop + scrollTop})
                                }
                            }).on(wheelEvent.name, function(e) {
                                if (scrollable) {
                                    scrollTop = scrollable.scrollTop();
                                    scrollable.scrollTo({y: scrollTop - e.delta});
                                    if (scrollable.scrollTop() > 0 && scrollable.scrollTop() + scrollable.clientHeight() < scrollable.scrollHeight() + that.getScrollbarWidth())
                                        return false
                                }
                            }).appendTo(element)
                        }
                        return $content
                    }
                    return that.callBase()
                },
                _updateBottomLoading: function() {
                    if (!this._isFixedTableRendering)
                        this.callBase()
                },
                _updateScrollable: function() {
                    this.callBase();
                    this._updateFixedTablePosition(-this._scrollTop)
                },
                _renderContent: function(contentElement, tableElement) {
                    if (this._isFixedTableRendering)
                        return contentElement.empty().addClass(DATAGRID_CONTENT_CLASS + " " + DATAGRID_CONTENT_FIXED_CLASS + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS).append(tableElement);
                    return this.callBase(contentElement, tableElement)
                },
                _getGroupCellOptions: function(options) {
                    if (this._isFixedTableRendering)
                        return this.callBase($.extend({}, options, {columns: this._columnsController.getVisibleColumns()}));
                    return this.callBase(options)
                },
                _renderGroupSummaryCells: function($row, options) {
                    if (this._isFixedTableRendering)
                        this.callBase($row, $.extend({}, options, {columns: this._columnsController.getVisibleColumns()}));
                    else
                        this.callBase($row, options)
                },
                _hasAlignByColumnSummaryItems: function(columnIndex, options) {
                    var result = this.callBase.apply(this, arguments);
                    return result && Boolean(options.columns[columnIndex].fixed) === Boolean(options.isFixed)
                },
                _renderGroupSummaryCellsCore: function($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
                    if (this._isFixedTableRendering) {
                        if (alignByColumnCellCount > 0)
                            $groupCell.css("visibility", "hidden");
                        options.isFixed = true;
                        alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);
                        options.isFixed = false
                    }
                    this.callBase($groupCell, options, groupCellColSpan, alignByColumnCellCount)
                },
                _renderCore: function(change) {
                    this._detachHoverEvents();
                    this.callBase(change);
                    if (this.option("hoverStateEnabled") && this._isFixedColumns)
                        this._attachHoverEvents()
                },
                optionChanged: function(args) {
                    var that = this;
                    that.callBase(args);
                    if (args.name === "hoverStateEnabled" && that._isFixedColumns)
                        args.value ? this._attachHoverEvents() : this._detachHoverEvents()
                },
                getCellIndex: function($cell) {
                    var $fixedTable = this._fixedTableElement,
                        columns,
                        cellIndex = 0;
                    if ($fixedTable && $fixedTable.find($cell).length) {
                        columns = this._columnsController.getFixedColumns();
                        $.each(columns, function(index, column) {
                            if (index === $cell[0].cellIndex)
                                return false;
                            if (column.colspan) {
                                cellIndex += column.colspan;
                                return
                            }
                            cellIndex++
                        });
                        return cellIndex
                    }
                    return this.callBase($cell)
                },
                _updateFixedTablePosition: function(scrollTop) {
                    if (this._fixedTableElement && this._tableElement)
                        this._fixedTableElement.css("top", scrollTop + this._tableElement.position().top)
                },
                setScrollerSpacing: function() {
                    var that = this,
                        vWidth,
                        hWidth,
                        styles;
                    var $fixedContent = that.element().children("." + DATAGRID_CONTENT_FIXED_CLASS);
                    if ($fixedContent.length) {
                        vWidth = that.getScrollbarWidth();
                        hWidth = that.getScrollbarWidth(true);
                        styles = that.option("rtlEnabled") ? {marginLeft: vWidth} : {marginRight: vWidth};
                        styles.marginBottom = hWidth;
                        $fixedContent.css(styles)
                    }
                },
                _handleScroll: function(e) {
                    this._updateFixedTablePosition(-e.scrollOffset.top);
                    this.callBase(e)
                },
                _updateContentPosition: function() {
                    var isUpdated = this.callBase();
                    if (isUpdated)
                        this._updateFixedTablePosition(-this._scrollTop);
                    return isUpdated
                }
            });
        var FooterViewFixedColumnsExtender = baseFixedColumns;
        dataGrid.registerModule("fixedColumns", {
            defaultOptions: function() {
                return {columnFixing: {
                            enabled: false,
                            texts: {
                                fix: Globalize.localize("dxDataGrid-columnFixingFix"),
                                unfix: Globalize.localize("dxDataGrid-columnFixingUnfix"),
                                leftPosition: Globalize.localize("dxDataGrid-columnFixingLeftPosition"),
                                rightPosition: Globalize.localize("dxDataGrid-columnFixingRightPosition")
                            }
                        }}
            },
            extenders: {
                views: {
                    columnHeadersView: ColumnHeadersViewFixedColumnsExtender,
                    rowsView: RowsViewFixedColumnsExtender,
                    footerView: FooterViewFixedColumnsExtender
                },
                controllers: function() {
                    var normalizeColumnIndicesByPoints = function(columns, pointsByColumns) {
                            var transparentColumnIndex = getTransparentColumnIndex(columns);
                            if (transparentColumnIndex >= 0)
                                $.each(pointsByColumns, function(_, point) {
                                    if (point.index > transparentColumnIndex) {
                                        point.columnIndex += columns[transparentColumnIndex].colspan - 1;
                                        point.index += columns[transparentColumnIndex].colspan - 1
                                    }
                                });
                            return pointsByColumns
                        };
                    return {
                            draggingHeader: {
                                _generatePointsByColumns: function(options) {
                                    var pointsByColumns,
                                        targetDraggingPanel = options.targetDraggingPanel;
                                    if (targetDraggingPanel && targetDraggingPanel.getName() === "headers" && targetDraggingPanel.isFixedColumns())
                                        if (options.sourceColumn.fixed) {
                                            options.columnElements = targetDraggingPanel.getFixedColumnElements();
                                            options.columns = targetDraggingPanel.getFixedColumns();
                                            pointsByColumns = this.callBase(options);
                                            return normalizeColumnIndicesByPoints(options.columns, pointsByColumns)
                                        }
                                    return this.callBase(options)
                                },
                                _pointCreated: function(point, columns, location, sourceColumn) {
                                    var result = this.callBase.apply(this, arguments),
                                        $transparentColumn = this._columnHeadersView.getTransparentColumnElement(),
                                        boundingRect;
                                    if (!result && location === "headers" && $transparentColumn) {
                                        boundingRect = $transparentColumn.get(0).getBoundingClientRect();
                                        if (sourceColumn && sourceColumn.fixed)
                                            return sourceColumn.fixedPosition === "right" ? point.x < boundingRect.right : point.x > boundingRect.left;
                                        else
                                            return point.x < boundingRect.left || point.x > boundingRect.right
                                    }
                                    return result
                                }
                            },
                            columnsResizer: {
                                _generatePointsByColumns: function() {
                                    var that = this,
                                        columns = that._columnsController ? that._columnsController.getFixedColumns() : [],
                                        cells = that._columnHeadersView.getFixedColumnElements(),
                                        pointsByFixedColumns = [];
                                    that.callBase();
                                    if (cells && cells.length > 0) {
                                        pointsByFixedColumns = dataGrid.getPointsByColumns(cells, function(point) {
                                            return that._pointCreated(point, cells.length, columns)
                                        });
                                        that._pointsByFixedColumns = normalizeColumnIndicesByPoints(columns, pointsByFixedColumns)
                                    }
                                },
                                _pointCreated: function(point, cellsLength, columns) {
                                    var currentColumn,
                                        nextColumn;
                                    if (point.index > 0 && point.index < cellsLength) {
                                        currentColumn = columns[point.columnIndex - 1] || {};
                                        nextColumn = columns[point.columnIndex] || {};
                                        if (currentColumn.fixed || nextColumn.fixed) {
                                            point.columnIndex -= 1;
                                            return !((currentColumn.allowResizing || currentColumn.command === "transparent") && (nextColumn.allowResizing || nextColumn.command === "transparent"))
                                        }
                                    }
                                    return this.callBase.apply(this, arguments)
                                },
                                _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
                                    var $transparentColumn = this._columnHeadersView.getTransparentColumnElement(),
                                        boundingRect;
                                    if ($transparentColumn) {
                                        boundingRect = $transparentColumn.get(0).getBoundingClientRect();
                                        if (currentX <= boundingRect.left || currentX >= boundingRect.right)
                                            return this.callBase(this._pointsByFixedColumns, currentX, deltaX)
                                    }
                                    return this.callBase(pointsByColumns, currentX, deltaX)
                                }
                            },
                            keyboardNavigation: {_scrollToElement: function($element) {
                                    var focusedView = this.getFocusedView();
                                    this.callBase($element, focusedView && focusedView.getFixedColumnsOffset())
                                }}
                        }
                }()
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.exportController.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            Class = DevExpress.require("/class"),
            commonUtils = DX.require("/utils/utils.common"),
            CheckBox = DX.require("/ui/widgets/ui.checkBox"),
            DATAGRID_CHECKBOX_SIZE = "dx-datagrid-checkbox-size",
            DATAGRID_EXPORT_MENU_CLASS = "dx-datagrid-export-menu",
            DATAGRID_EXPORT_BUTTON_CLASS = "dx-datagrid-export-button",
            DATAGRID_EXPORT_ICON = "export-to",
            DATAGRID_EXPORT_EXCEL_ICON = "exportxlsx",
            DATAGRID_EXPORT_EXCEL_BUTTON_ICON = "export-excel-button";
        dataGrid.DataProvider = Class.inherit({
            _getGroupValue: function(item) {
                var groupColumn = this._options.groupColumns[item.groupIndex],
                    value = dataGrid.getDisplayValue(groupColumn, item.values[item.groupIndex], item.data),
                    result = groupColumn.caption + ": " + dataGrid.formatValue(value, groupColumn),
                    visibleIndex;
                visibleIndex = this._options.getVisibleIndex(groupColumn.index);
                if (item.summaryCells && item.summaryCells.length && item.summaryCells[visibleIndex].length)
                    result += " " + dataGrid.getGroupRowSummaryText(item.summaryCells[visibleIndex], this._options.summaryTexts);
                return result
            },
            _correctCellIndex: function(cellIndex) {
                var startIndex = this._options.startValueIndex,
                    endIndex = this._options.endValueIndex;
                return cellIndex <= endIndex ? startIndex + cellIndex : null
            },
            ctor: function(options) {
                this._options = options
            },
            getColumns: function() {
                return this._options.columns
            },
            getRowsCount: function() {
                return this._options.items.length
            },
            isGroupRow: function(rowIndex) {
                return rowIndex < this._options.items.length && this._options.items[rowIndex].rowType === "group"
            },
            getGroupLevel: function(rowIndex) {
                var item = this._options.items[rowIndex],
                    groupIndex = item.groupIndex;
                if (item.isTotalSummary)
                    return 0;
                return commonUtils.isDefined(groupIndex) ? groupIndex : this._options.groupColumns.length
            },
            getCellType: function(rowIndex, cellIndex) {
                if (cellIndex < this._options.columns.length) {
                    var item = this._options.items.length && this._options.items[rowIndex],
                        column = this._options.columns[cellIndex];
                    if (item && item.rowType === "data")
                        if (isFinite(item.values[this._correctCellIndex(cellIndex)]) && !commonUtils.isDefined(column.customizeText))
                            return commonUtils.isDefined(column.lookup) ? column.lookup.dataType : column.dataType;
                    return "string"
                }
            },
            ready: function() {
                var options = this._options;
                return $.when(options.items).done(function(items) {
                        options.items = items
                    })
            },
            getCellValue: function(rowIndex, cellIndex) {
                var column,
                    value,
                    i,
                    summaryItems,
                    correctedCellIndex = this._correctCellIndex(cellIndex),
                    itemValues,
                    item = this._options.items.length && this._options.items[rowIndex];
                if (item) {
                    itemValues = item.values;
                    switch (item.rowType) {
                        case"summaryFooter":
                            if (correctedCellIndex < itemValues.length) {
                                value = itemValues[correctedCellIndex];
                                if (commonUtils.isDefined(value))
                                    return dataGrid.getSummaryText(value, this._options.summaryTexts)
                            }
                            break;
                        case"group":
                            if (cellIndex < 1)
                                return this._getGroupValue(item);
                            else {
                                summaryItems = item.values[correctedCellIndex];
                                if (commonUtils.isArray(summaryItems)) {
                                    value = "";
                                    for (i = 0; i < summaryItems.length; i++)
                                        value += (i > 0 ? " \n " : "") + dataGrid.getSummaryText(summaryItems[i], this._options.summaryTexts);
                                    return value
                                }
                            }
                            break;
                        default:
                            column = this._options.columns[cellIndex];
                            if (column) {
                                value = dataGrid.getDisplayValue(column, itemValues[correctedCellIndex], item.data);
                                return !isFinite(value) || column.customizeText ? dataGrid.formatValue(value, column) : value
                            }
                    }
                }
            },
            isHeadersVisible: function() {
                return this._options.isHeadersVisible
            },
            isTotalCell: function(rowIndex, cellIndex) {
                var items = this._options.items,
                    item = items[rowIndex],
                    correctCellIndex = this._correctCellIndex(cellIndex),
                    isSummaryAlignByColumn = item.summaryCells && item.summaryCells[correctCellIndex] && item.summaryCells[correctCellIndex].length > 0 && item.summaryCells[correctCellIndex][0].alignByColumn;
                return item && item.rowType === "summaryFooter" || isSummaryAlignByColumn
            }
        });
        dataGrid.ExportController = dataGrid.ViewController.inherit({
            _getColumns: function() {
                var result = [],
                    visibleColumns = this._columnsController.getVisibleColumns(),
                    columnWidths = this._headersView && this._headersView.isVisible() ? this._headersView.getColumnWidths() : this._rowsView.getColumnWidths(),
                    column,
                    i;
                for (i = 0; i < visibleColumns.length; i++) {
                    column = visibleColumns[i];
                    if (!commonUtils.isDefined(column.command))
                        result.push($.extend({}, column, {width: columnWidths[i]}))
                }
                return result
            },
            _getFooterSummaryItems: function(summaryCells, isTotal) {
                var result = [],
                    estimatedItemsCount = 1,
                    values,
                    itemslength,
                    summaryCell,
                    j,
                    i = 0;
                do {
                    values = [];
                    for (j = 0; j < summaryCells.length; j++) {
                        summaryCell = summaryCells[j];
                        itemslength = summaryCell.length;
                        if (estimatedItemsCount < itemslength)
                            estimatedItemsCount = itemslength;
                        values.push(summaryCell[i])
                    }
                    result.push({
                        values: values,
                        rowType: "summaryFooter",
                        isTotalSummary: isTotal
                    })
                } while (i++ < estimatedItemsCount - 1);
                return result
            },
            _hasSummaryGroupFooters: function() {
                var i,
                    groupItems = this.option("summary.groupItems");
                if (commonUtils.isDefined(groupItems))
                    for (i = 0; i < groupItems.length; i++)
                        if (groupItems[i].showInGroupFooter)
                            return true;
                return false
            },
            _getItemsWithSummaryGroupFooters: function(sourceItems) {
                var item,
                    result = [],
                    beforeGroupFooterItems = [],
                    groupFooterItems = [],
                    i;
                for (i = 0; i < sourceItems.length; i++) {
                    item = sourceItems[i];
                    if (item.rowType === "groupFooter") {
                        groupFooterItems = this._getFooterSummaryItems(item.summaryCells);
                        result = result.concat(beforeGroupFooterItems, groupFooterItems);
                        beforeGroupFooterItems = []
                    }
                    else
                        beforeGroupFooterItems.push(item)
                }
                return result.length ? result : beforeGroupFooterItems
            },
            _updateGroupValuesWithSummaryByColumn: function(sourceItems) {
                var item,
                    summaryCells,
                    summaryItem,
                    summaryValues = [],
                    groupColumnCount,
                    k,
                    j,
                    i;
                for (i = 0; i < sourceItems.length; i++) {
                    item = sourceItems[i];
                    summaryCells = item.summaryCells;
                    if (item.rowType === "group" && summaryCells && summaryCells.length > 1) {
                        groupColumnCount = item.values.length;
                        for (j = 1; j < summaryCells.length; j++)
                            for (k = 0; k < summaryCells[j].length; k++) {
                                summaryItem = summaryCells[j][k];
                                if (summaryItem && summaryItem.alignByColumn) {
                                    if (!commonUtils.isArray(summaryValues[j - groupColumnCount]))
                                        summaryValues[j - groupColumnCount] = [];
                                    summaryValues[j - groupColumnCount].push(summaryItem)
                                }
                            }
                        if (summaryValues.length > 0) {
                            $.merge(item.values, summaryValues);
                            summaryValues = []
                        }
                    }
                }
            },
            _getAllItems: function(data) {
                var that = this,
                    d = $.Deferred(),
                    dataController = this.getController("data"),
                    footerItems = dataController.footerItems(),
                    totalItem = footerItems.length && footerItems[0],
                    summaryTotalItems = that.option("summary.totalItems"),
                    summaryCells,
                    summaryItems;
                dataController.loadAll(data).done(function(sourceItems, totalAggregates) {
                    that._updateGroupValuesWithSummaryByColumn(sourceItems);
                    if (that._hasSummaryGroupFooters())
                        sourceItems = that._getItemsWithSummaryGroupFooters(sourceItems);
                    summaryCells = totalItem && totalItem.summaryCells;
                    if (commonUtils.isDefined(totalAggregates) && summaryTotalItems)
                        summaryCells = dataController._getSummaryCells(summaryTotalItems, totalAggregates);
                    summaryItems = totalItem && that._getFooterSummaryItems(summaryCells, true);
                    if (summaryItems)
                        sourceItems = sourceItems.concat(summaryItems);
                    d.resolve(sourceItems)
                }).fail(d.reject);
                return d
            },
            _getSelectedItems: function() {
                var selectionController = this.getController("selection"),
                    selectedRowData = selectionController.getSelectedRowsData();
                return this._getAllItems(selectedRowData)
            },
            _getStartEndValueIndexces: function(visibleColumns) {
                var i,
                    startIndex,
                    endIndex,
                    visibleColumnslength = visibleColumns.length;
                for (i = 0; i < visibleColumnslength; i++)
                    if (!commonUtils.isDefined(visibleColumns[i].command)) {
                        startIndex = i;
                        break
                    }
                for (i = visibleColumnslength - 1; i >= 0; i--)
                    if (!commonUtils.isDefined(visibleColumns[i].command)) {
                        endIndex = i;
                        break
                    }
                return {
                        startIndex: startIndex,
                        endIndex: endIndex
                    }
            },
            init: function() {
                this._columnsController = this.getController("columns");
                this._rowsView = this.getView("rowsView");
                this._headersView = this.getView("columnHeadersView");
                this.createAction("onExporting", {excludeValidators: ["disabled", "readOnly"]});
                this.createAction("onExported", {excludeValidators: ["disabled", "readOnly"]});
                this._clientExporter = new DX.dxClientExporter({
                    exportingAction: this.getAction("onExporting"),
                    exportedAction: this.getAction("onExported")
                })
            },
            optionChanged: function(args) {
                this.callBase(args);
                if (args.name === "onExporting")
                    this._clientExporter.option("exportingAction", this.getAction(args.name));
                if (args.name === "onExported")
                    this._clientExporter.option("exportedAction", this.getAction(args.name))
            },
            callbackNames: function() {
                return ["selectionOnlyChanged"]
            },
            getExportFormat: function() {
                return ["EXCEL"]
            },
            getDataProvider: function() {
                var groupColumns = this._columnsController.getGroupColumns(),
                    startEndIndexces = this._getStartEndValueIndexces(this._columnsController.getVisibleColumns());
                return new dataGrid.DataProvider({
                        columns: this._getColumns(),
                        groupColumns: groupColumns,
                        items: !!this._selectionOnly ? this._getSelectedItems() : this._getAllItems(),
                        getVisibleIndex: $.proxy(this._columnsController.getVisibleIndex, this._columnsController),
                        startValueIndex: startEndIndexces.startIndex,
                        endValueIndex: startEndIndexces.endIndex,
                        isHeadersVisible: this.option("showColumnHeaders"),
                        summaryTexts: this.option("summary.texts")
                    })
            },
            exportToExcel: function(selectionOnly) {
                this._selectionOnly = selectionOnly;
                var excelWrapTextEnabled = this.option("export.excelWrapTextEnabled");
                commonUtils.isDefined(this._clientExporter) && this._clientExporter.exportTo({
                    fileName: this.option("export.fileName"),
                    proxyUrl: this.option("export.proxyUrl"),
                    format: "EXCEL",
                    wrapTextEnabled: commonUtils.isDefined(excelWrapTextEnabled) ? excelWrapTextEnabled : !!this.option("wordWrapEnabled"),
                    autoFilterEnabled: !!this.option("export.excelFilterEnabled"),
                    component: this.component
                })
            },
            publicMethods: function() {
                return ["getDataProvider", "getExportFormat", "exportToExcel"]
            },
            selectionOnly: function(value) {
                if (commonUtils.isDefined(value)) {
                    this._isSelectedRows = value;
                    this.selectionOnlyChanged.fire()
                }
                else
                    return this._isSelectedRows
            }
        });
        dataGrid.registerModule("export", {
            defaultOptions: function() {
                return {"export": {
                            enabled: false,
                            fileName: "DataGrid",
                            excelFilterEnabled: false,
                            excelWrapTextEnabled: undefined,
                            proxyUrl: undefined,
                            allowExportSelectedData: false,
                            texts: {
                                exportTo: Globalize.localize("dxDataGrid-exportTo"),
                                exportToExcel: Globalize.localize("dxDataGrid-exportToExcel"),
                                excelFormat: Globalize.localize("dxDataGrid-excelFormat"),
                                selectedRows: Globalize.localize("dxDataGrid-selectedRows")
                            }
                        }}
            },
            controllers: {"export": dataGrid.ExportController},
            extenders: {
                controllers: {editing: {
                        callbackNames: function() {
                            var callbackList = this.callBase();
                            return commonUtils.isDefined(callbackList) ? callbackList.push("editingChanged") : ["editingChanged"]
                        },
                        _updateEditButtons: function() {
                            this.callBase();
                            this.editingChanged.fire(this.hasChanges())
                        }
                    }},
                views: {headerPanel: {
                        _isExportButtonVisible: function() {
                            return this.option("export.enabled")
                        },
                        _getButtonOptions: function() {
                            var that = this,
                                texts = that.option("export.texts");
                            return that.option("export.allowExportSelectedData") ? {
                                    hint: texts.exportTo,
                                    icon: DATAGRID_EXPORT_ICON,
                                    onClick: null
                                } : {
                                    hint: texts.exportToExcel,
                                    icon: DATAGRID_EXPORT_EXCEL_BUTTON_ICON,
                                    onClick: function() {
                                        that._exportController.exportToExcel()
                                    }
                                }
                        },
                        _renderExportButton: function() {
                            var that = this;
                            if (that.option("export.enabled"))
                                if (!that._$exportButton) {
                                    that._$exportButton = $("<div>").addClass(DATAGRID_EXPORT_BUTTON_CLASS).appendTo(that.element());
                                    that._exportButton = that._createComponent(that._$exportButton, "dxButton", that._getButtonOptions())
                                }
                                else {
                                    that._exportButton.option(that._getButtonOptions());
                                    that._$exportButton.show()
                                }
                            else
                                that._$exportButton && that._$exportButton.hide()
                        },
                        _renderExportMenu: function() {
                            var that = this,
                                texts = that.option("export.texts"),
                                menuItems = [{
                                        text: texts.excelFormat,
                                        icon: DATAGRID_EXPORT_EXCEL_ICON
                                    }];
                            commonUtils.isDefined(that._exportContextMenu) && that._exportContextMenu.element().remove();
                            if (that.option("export.enabled") && that.option("export.allowExportSelectedData")) {
                                menuItems.push({
                                    value: "selectionOnly",
                                    template: function() {
                                        var $selectionOnlyEditor = that._createComponent($("<div>").addClass(DATAGRID_CHECKBOX_SIZE), CheckBox, {
                                                text: texts.selectedRows,
                                                value: !!that._exportController.selectionOnly(),
                                                onValueChanged: function(e) {
                                                    that._exportController.selectionOnly(e.value)
                                                }
                                            }).element();
                                        return $selectionOnlyEditor
                                    },
                                    beginGroup: true,
                                    closeMenuOnClick: false
                                });
                                that._exportContextMenu = that._createComponent($("<div>").appendTo(that.component.element()), "dxContextMenu", {
                                    alternativeInvocationMode: {
                                        enabled: true,
                                        invokingElement: that._$exportButton
                                    },
                                    items: menuItems,
                                    cssClass: DATAGRID_EXPORT_MENU_CLASS,
                                    onItemClick: function(e) {
                                        if (e.itemData.text && e.itemData.text.indexOf("Excel") > -1)
                                            that._exportController.exportToExcel(that._exportController.selectionOnly())
                                    },
                                    target: this._$exportButton,
                                    position: {
                                        at: "left bottom",
                                        my: "left top",
                                        offset: "0 3",
                                        collision: "fit",
                                        boundary: that._$parent,
                                        boundaryOffset: "1 1"
                                    }
                                })
                            }
                        },
                        _renderCore: function() {
                            this.callBase();
                            this._renderExportButton();
                            this._renderExportMenu()
                        },
                        optionChanged: function(args) {
                            this.callBase(args);
                            if (args.name === "export") {
                                args.handled = true;
                                this._invalidate()
                            }
                        },
                        init: function() {
                            var that = this;
                            this.callBase();
                            this._exportController = this.getController("export");
                            this._editingController = this.getController("editing");
                            this._editingController.editingChanged.add(function(hasChanges) {
                                if (commonUtils.isDefined(that._exportButton))
                                    that._exportButton.option("disabled", hasChanges)
                            })
                        },
                        isVisible: function() {
                            return this.callBase() || this._isExportButtonVisible()
                        }
                    }}
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_EXPORT_MENU_CLASS: DATAGRID_EXPORT_MENU_CLASS,
            DATAGRID_EXPORT_BUTTON_CLASS: DATAGRID_EXPORT_BUTTON_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.gridView.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common");
        var DATAGRID_CLASS = "dx-datagrid",
            DATAGRID_HIDDEN_CLASS = "dx-hidden",
            DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_BORDERS_CLASS = "dx-datagrid-borders",
            DATAGRID_TABLE_FIXED_CLASS = "dx-datagrid-table-fixed",
            DATAGRID_COLUMN_HEADERS_HIDDEN = "dx-datagrid-headers-hidden",
            DATAGRID_IMPORTANT_MARGIN_CLASS = "dx-datagrid-important-margin",
            EMPTY_GRID_ROWS_HEIGHT = 100,
            LOADPANEL_MARGIN = 50,
            VIEW_NAMES = ["columnsSeparatorView", "blockSeparatorView", "trackerView", "headerPanel", "columnHeadersView", "rowsView", "footerView", "columnChooserView", "pagerView", "draggingHeaderView", "contextMenuView", "errorView", "headerFilterView"];
        var isPercentWidth = function(width) {
                return commonUtils.isString(width) && width.slice(-1) === "%"
            };
        var mergeArraysByMaxValue = function(values1, values2) {
                var result = [],
                    i;
                if (values1 && values2 && values1.length && values1.length === values2.length)
                    for (i = 0; i < values1.length; i++)
                        result.push(values1[i] > values2[i] ? values1[i] : values2[i]);
                else if (values1)
                    result = values1;
                return result
            };
        dataGrid.ResizingController = dataGrid.ViewController.inherit({
            _initPostRenderHandlers: function() {
                var that = this;
                if (!that._refreshSizesHandler) {
                    that._refreshSizesHandler = function(e) {
                        that._dataController.changed.remove(that._refreshSizesHandler);
                        if (that._columnsController.columnsChanged.firing) {
                            (window.setImmediate || setTimeout)($.proxy(that._refreshSizesHandler, that, e));
                            return
                        }
                        var changeType = e && e.changeType;
                        if (!e || changeType === "refresh" || changeType === "prepend" || changeType === "append" || changeType === "append")
                            that.resize();
                        else if (changeType === "update")
                            that._rowsView.synchronizeRows && that._rowsView.synchronizeRows();
                        if (changeType && changeType !== "updateSelection")
                            that.component._fireContentReadyAction()
                    };
                    that._dataController.changed.add(function() {
                        that._dataController.changed.add(that._refreshSizesHandler)
                    })
                }
            },
            _getBestFitWidths: function() {
                var that = this,
                    rowsColumnWidths = that._rowsView.getColumnWidths(),
                    headerColumnWidths = that._columnHeadersView && that._columnHeadersView.getColumnWidths(),
                    footerColumnWidths = that._footerView && that._footerView.getColumnWidths(),
                    resultWidths;
                resultWidths = mergeArraysByMaxValue(rowsColumnWidths, headerColumnWidths);
                resultWidths = mergeArraysByMaxValue(resultWidths, footerColumnWidths);
                return resultWidths
            },
            _setVisibleWidths: function(visibleColumns, widths) {
                var columnsController = this._columnsController;
                columnsController.beginUpdate();
                $.each(visibleColumns, function(index, column) {
                    var columnId = column.command ? "command:" + column.command : column.index;
                    columnsController.columnOption(columnId, "visibleWidth", widths[index])
                });
                columnsController.endUpdate()
            },
            _toggleBestFitMode: function(isBestFit) {
                var $element = this.component.element();
                $element.find("." + DATAGRID_TABLE_CLASS).toggleClass(DATAGRID_TABLE_FIXED_CLASS, !isBestFit);
                $element.find("input").toggleClass(DATAGRID_HIDDEN_CLASS, isBestFit);
                $element.find(".dx-group-cell").toggleClass(DATAGRID_HIDDEN_CLASS, isBestFit);
                $element.find(".dx-header-row .dx-datagrid-text-content").css("max-width", "")
            },
            _synchronizeColumns: function() {
                var that = this,
                    columnsController = that._columnsController,
                    visibleColumns = columnsController.getVisibleColumns(),
                    columnAutoWidth = that.option("columnAutoWidth"),
                    needBestFit = columnAutoWidth,
                    lastWidthReseted = false,
                    resultWidths = [],
                    normalizeWidthsByExpandColumns = function() {
                        var expandColumnWidth;
                        $.each(visibleColumns, function(index, column) {
                            if (column.command === "expand")
                                expandColumnWidth = resultWidths[index]
                        });
                        $.each(visibleColumns, function(index, column) {
                            if (column.command === "expand" && expandColumnWidth)
                                resultWidths[index] = expandColumnWidth
                        })
                    };
                !needBestFit && $.each(visibleColumns, function(index, column) {
                    if (column.width === "auto") {
                        needBestFit = true;
                        return false
                    }
                });
                that._setVisibleWidths(visibleColumns, []);
                if (needBestFit) {
                    that._toggleBestFitMode(true);
                    resultWidths = that._getBestFitWidths();
                    $.each(visibleColumns, function(index, column) {
                        var columnId = column.command ? "command:" + column.command : column.index;
                        columnsController.columnOption(columnId, "bestFitWidth", resultWidths[index], true)
                    })
                }
                $.each(visibleColumns, function(index) {
                    if (this.width !== "auto")
                        if (this.width)
                            resultWidths[index] = this.width;
                        else if (!columnAutoWidth)
                            resultWidths[index] = undefined
                });
                lastWidthReseted = that._correctColumnWidths(resultWidths, visibleColumns);
                if (columnAutoWidth) {
                    normalizeWidthsByExpandColumns();
                    that._processStretch(resultWidths, visibleColumns)
                }
                if (needBestFit)
                    that._toggleBestFitMode(false);
                if (needBestFit || lastWidthReseted)
                    that._setVisibleWidths(visibleColumns, resultWidths)
            },
            _correctColumnWidths: function(resultWidths, visibleColumns) {
                var that = this,
                    hasPercentWidth = false,
                    hasAutoWidth = false,
                    lastWidthReseted = false,
                    $element = that.component.element(),
                    hasWidth = that._hasWidth,
                    lastColumnIndex;
                $.each(visibleColumns, function(index) {
                    if (this.width !== "auto")
                        if (this.width)
                            resultWidths[index] = this.width;
                        else
                            hasAutoWidth = true;
                    if (isPercentWidth(this.width))
                        hasPercentWidth = true
                });
                if ($element && that._maxWidth) {
                    delete that._maxWidth;
                    $element.css("max-width", "")
                }
                if (!hasAutoWidth && resultWidths.length) {
                    var contentWidth = that._rowsView.contentWidth();
                    var totalWidth = that._getTotalWidth(resultWidths, contentWidth);
                    if (totalWidth <= contentWidth) {
                        lastColumnIndex = resultWidths.length - 1;
                        while (lastColumnIndex >= 0 && visibleColumns[lastColumnIndex] && visibleColumns[lastColumnIndex].command)
                            lastColumnIndex--;
                        if (lastColumnIndex >= 0) {
                            resultWidths[lastColumnIndex] = "auto";
                            lastWidthReseted = true;
                            if (!hasWidth && !hasPercentWidth) {
                                that._maxWidth = totalWidth;
                                $element.css("max-width", that._maxWidth)
                            }
                        }
                    }
                }
                return lastWidthReseted
            },
            _processStretch: function(resultSizes, visibleColumns) {
                var groupSize = this._rowsView.contentWidth(),
                    tableSize = this._getTotalWidth(resultSizes, groupSize),
                    unusedIndexes = {length: 0},
                    diff,
                    diffElement,
                    onePixelElementsCount,
                    i;
                if (!resultSizes.length)
                    return;
                $.each(visibleColumns, function(index) {
                    if (this.width) {
                        unusedIndexes[index] = true;
                        unusedIndexes.length++
                    }
                });
                diff = groupSize - tableSize;
                diffElement = Math.floor(diff / (resultSizes.length - unusedIndexes.length));
                onePixelElementsCount = diff - diffElement * (resultSizes.length - unusedIndexes.length);
                if (diff >= 0)
                    for (i = 0; i < resultSizes.length; i++) {
                        if (unusedIndexes[i])
                            continue;
                        resultSizes[i] += diffElement;
                        if (onePixelElementsCount) {
                            resultSizes[i]++;
                            onePixelElementsCount--
                        }
                    }
            },
            _getTotalWidth: function(widths, groupWidth) {
                var result = 0,
                    width,
                    i;
                for (i = 0; i < widths.length; i++) {
                    width = widths[i];
                    if (width)
                        result += isPercentWidth(width) ? parseInt(width) * groupWidth / 100 : parseInt(width)
                }
                return Math.round(result)
            },
            updateSize: function($rootElement) {
                var that = this,
                    $groupElement,
                    width;
                if (that._hasHeight === undefined && $rootElement && $rootElement.closest(document).length) {
                    $groupElement = $rootElement.children("." + DATAGRID_CLASS);
                    if ($groupElement.length)
                        $groupElement.detach();
                    that._hasHeight = !!$rootElement.height();
                    width = $rootElement.width();
                    $rootElement.addClass(DATAGRID_IMPORTANT_MARGIN_CLASS);
                    that._hasWidth = $rootElement.width() === width;
                    $rootElement.removeClass(DATAGRID_IMPORTANT_MARGIN_CLASS);
                    if ($groupElement.length)
                        $groupElement.appendTo($rootElement)
                }
            },
            publicMethods: function() {
                return ["resize", "updateDimensions"]
            },
            resize: function() {
                !this.component._requireResize && this.updateDimensions()
            },
            updateDimensions: function() {
                var that = this,
                    dataController = that._dataController,
                    $rootElement = that.component.element(),
                    rootElementHeight = $rootElement && ($rootElement.get(0).clientHeight || $rootElement.height()),
                    loadPanelOptions = that.option("loadPanel"),
                    height = that.option("height"),
                    rowsViewHeight,
                    editorFactory = that.getController("editorFactory"),
                    $testDiv;
                that._initPostRenderHandlers();
                that.updateSize($rootElement);
                if (height && that._hasHeight ^ height !== "auto") {
                    $testDiv = $("<div>").height(height).appendTo($rootElement);
                    that._hasHeight = !!$testDiv.height();
                    $testDiv.remove()
                }
                if (that._hasHeight && rootElementHeight > 0 && that.option("scrolling")) {
                    rowsViewHeight = rootElementHeight;
                    $.each(that.getViews(), function() {
                        if (this.isVisible() && this.getHeight)
                            rowsViewHeight -= this.getHeight()
                    })
                }
                else if (!that._hasHeight && dataController.items().length === 0)
                    rowsViewHeight = loadPanelOptions && loadPanelOptions.visible ? loadPanelOptions.height + LOADPANEL_MARGIN : EMPTY_GRID_ROWS_HEIGHT;
                else
                    rowsViewHeight = "auto";
                that._rowsView.height(rowsViewHeight);
                if (!dataController.isLoaded())
                    return;
                that._columnHeadersView.setScrollerSpacing(that._rowsView.getScrollbarWidth());
                that._rowsView.setScrollerSpacing();
                that._synchronizeColumns();
                $.each(VIEW_NAMES, function(index, viewName) {
                    var view = that.getView(viewName);
                    if (view)
                        view.resize()
                });
                editorFactory && editorFactory.resize()
            },
            optionChanged: function(args) {
                switch (args.name) {
                    case"width":
                    case"height":
                        this.component._renderDimensions();
                        this.resize();
                    default:
                        this.callBase(args)
                }
            },
            init: function() {
                var that = this;
                that._dataController = that.getController("data");
                that._columnsController = that.getController("columns");
                that._columnHeadersView = that.getView("columnHeadersView");
                that._footerView = that.getView("footerView");
                that._rowsView = that.getView("rowsView")
            }
        });
        dataGrid.SynchronizeScrollingController = dataGrid.ViewController.inherit({
            _scrollChangedHandler: function(views, pos, viewName) {
                for (var j = 0; j < views.length; j++)
                    if (views[j].name !== viewName)
                        views[j].scrollTo({
                            left: pos.left,
                            top: pos.top
                        })
            },
            init: function() {
                var view,
                    views = [this.getView("columnHeadersView"), this.getView("footerView"), this.getView("rowsView")],
                    i;
                for (i = 0; i < views.length; i++) {
                    view = views[i];
                    if (view)
                        view.scrollChanged.add($.proxy(this._scrollChangedHandler, this, views))
                }
            }
        });
        dataGrid.GridView = dataGrid.View.inherit({
            _endUpdateCore: function() {
                if (this.component._requireResize) {
                    this.component._requireResize = false;
                    this._resizingController.resize()
                }
            },
            init: function() {
                var that = this;
                that._resizingController = this.getController("resizing");
                that._dataController = that.getController("data")
            },
            getView: function(name) {
                return this.component._views[name]
            },
            element: function() {
                return this._groupElement
            },
            optionChanged: function(args) {
                var that = this;
                if (commonUtils.isDefined(that._groupElement) && args.name === "showBorders") {
                    that._groupElement.toggleClass(DATAGRID_BORDERS_CLASS, !!args.value);
                    args.handled = true
                }
                else
                    that.callBase(args)
            },
            render: function($rootElement) {
                var that = this,
                    groupElement = that._groupElement || $("<div />").addClass(DATAGRID_CLASS).toggleClass(DATAGRID_BORDERS_CLASS, !!that.option("showBorders"));
                that.component.setAria({
                    role: "application",
                    label: Globalize.localize("dxDataGrid-ariaDataGrid")
                }, $rootElement);
                that._rootElement = $rootElement || that._rootElement;
                that._groupElement = groupElement;
                $.each(VIEW_NAMES, function(index, viewName) {
                    var view = that.getView(viewName);
                    if (view)
                        view.render(groupElement)
                });
                that.update()
            },
            update: function() {
                var that = this,
                    $rootElement = that._rootElement,
                    $groupElement = that._groupElement,
                    resizingController = that.getController("resizing");
                if ($rootElement && $groupElement) {
                    if (!$groupElement.parent().length) {
                        resizingController.updateSize($rootElement);
                        $groupElement.appendTo($rootElement);
                        that.getView("columnHeadersView").renderDelayedTemplates();
                        that.getView("rowsView").renderDelayedTemplates()
                    }
                    resizingController.resize();
                    if (that._dataController.isLoaded())
                        that.component._fireContentReadyAction()
                }
            }
        });
        dataGrid.registerModule("gridView", {
            defaultOptions: function() {
                return {showBorders: false}
            },
            controllers: {
                resizing: dataGrid.ResizingController,
                synchronizeScrolling: dataGrid.SynchronizeScrollingController
            },
            views: {gridView: dataGrid.GridView}
        });
        $.extend(dataGrid.__internals, {
            viewNames: VIEW_NAMES,
            DATAGRID_CLASS: DATAGRID_CLASS,
            DATAGRID_COLUMN_HEADERS_HIDDEN: DATAGRID_COLUMN_HEADERS_HIDDEN,
            DATAGRID_BORDERS_CLASS: DATAGRID_BORDERS_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.js */
    (function($, DX) {
        var ui = DX.ui,
            stringUtils = DX.require("/utils/utils.string"),
            commonUtils = DX.require("/utils/utils.common"),
            wheelEvent = DX.require("/ui/events/ui.events.wheel"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            DATA_AREA_CELL_CLASS_NAME = "dx-area-data-cell",
            ROW_AREA_CELL_CLASS_NAME = "dx-area-row-cell",
            COLUMN_AREA_CELL_CLASS_NAME = "dx-area-column-cell",
            DESCRIPTION_AREA_CELL_CLASS_NAME = "dx-area-description-cell",
            BORDERS_CLASS_NAME = "dx-pivotgrid-border";
        function mergeArraysByMaxValue(values1, values2) {
            var result = [],
                i;
            for (i = 0; i < values1.length; i++)
                result.push(Math.max(values1[i] || 0, values2[i] || 0));
            return result
        }
        function getArraySum(array) {
            var sum = 0;
            $.each(array, function(_, value) {
                sum += value || 0
            });
            return sum
        }
        function adjustSizeArray(sizeArray, space) {
            var delta = space / sizeArray.length;
            for (var i = 0; i < sizeArray.length; i++)
                sizeArray[i] -= delta
        }
        function getAreaScrollable(area) {
            return area.groupElement().data('dxScrollable')
        }
        function subscribeToScrollEvent(area, handler) {
            var scrollable = getAreaScrollable(area);
            if (scrollable)
                scrollable.on('scroll', handler).on("stop", handler)
        }
        function setScrollPos(area, pos) {
            var scrollable;
            if (area) {
                scrollable = getAreaScrollable(area);
                if (scrollable) {
                    scrollable.scrollTo(pos);
                    scrollable.update()
                }
            }
        }
        var scrollBarInfoCache = {};
        function getScrollBarInfo(rootElement, useNativeScrolling) {
            if (scrollBarInfoCache[useNativeScrolling])
                return scrollBarInfoCache[useNativeScrolling];
            var scrollBarWidth = 0,
                scrollBarUseNative,
                options = {};
            var container = $('<div>').css({
                    position: 'absolute',
                    visibility: 'hidden',
                    width: 100,
                    height: 100
                }).appendTo(rootElement);
            var content = $('<p>').css({
                    width: '100%',
                    height: 200
                }).appendTo(container);
            if (useNativeScrolling !== 'auto') {
                options.useNative = !!useNativeScrolling;
                options.useSimulatedScrollbar = !useNativeScrolling
            }
            container.dxScrollable(options);
            scrollBarUseNative = container.dxScrollable('instance').option('useNative');
            scrollBarWidth = scrollBarUseNative ? container.width() - content.width() : 0;
            container.remove();
            scrollBarInfoCache[useNativeScrolling] = {
                scrollBarWidth: scrollBarWidth,
                scrollBarUseNative: scrollBarUseNative
            };
            return scrollBarInfoCache[useNativeScrolling]
        }
        registerComponent("dxPivotGrid", ui, Widget.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        scrolling: {
                            timeout: 30,
                            mode: "standard",
                            useNative: "auto",
                            removeInvisiblePages: true
                        },
                        encodeHtml: true,
                        dataSource: null,
                        activeStateEnabled: false,
                        fieldChooser: {
                            minWidth: 250,
                            minHeight: 250,
                            enabled: true,
                            layout: 0,
                            title: Globalize.localize("dxPivotGrid-fieldChooserTitle"),
                            width: 600,
                            height: 600
                        },
                        onContextMenuPreparing: null,
                        allowSorting: false,
                        allowSortingBySummary: false,
                        allowFiltering: false,
                        allowExpandAll: false,
                        "export": {
                            enabled: false,
                            fileName: "PivotGrid",
                            proxyUrl: undefined
                        },
                        showRowTotals: true,
                        showRowGrandTotals: true,
                        showColumnTotals: true,
                        showColumnGrandTotals: true,
                        hideEmptySummaryCells: true,
                        showTotalsPrior: "none",
                        loadPanel: {
                            enabled: true,
                            text: Globalize.localize("Loading"),
                            width: 200,
                            height: 70,
                            showIndicator: true,
                            indicatorSrc: "",
                            showPane: true
                        },
                        texts: {
                            grandTotal: Globalize.localize("dxPivotGrid-grandTotal"),
                            total: Globalize.localize("dxPivotGrid-total"),
                            noData: Globalize.localize("dxDataGrid-noDataText"),
                            showFieldChooser: Globalize.localize("dxPivotGrid-showFieldChooser"),
                            expandAll: Globalize.localize("dxPivotGrid-expandAll"),
                            collapseAll: Globalize.localize("dxPivotGrid-collapseAll"),
                            sortColumnBySummary: Globalize.localize("dxPivotGrid-sortColumnBySummary"),
                            sortRowBySummary: Globalize.localize("dxPivotGrid-sortRowBySummary"),
                            removeAllSorting: Globalize.localize("dxPivotGrid-removeAllSorting"),
                            exportToExcel: Globalize.localize("dxDataGrid-exportToExcel")
                        },
                        onCellClick: null,
                        onCellPrepared: null,
                        showBorders: false,
                        stateStoring: {
                            enabled: false,
                            storageKey: null,
                            type: "localStorage",
                            customLoad: null,
                            customSave: null,
                            savingTimeout: 2000
                        },
                        onExpandValueChanging: null,
                        renderCellCountLimit: 20000,
                        onExporting: null,
                        onExported: null
                    })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {useNativeScrolling: {
                        since: "15.2",
                        alias: "scrolling.useNative"
                    }})
            },
            _getDataControllerOptions: function() {
                var that = this;
                return {
                        component: that,
                        dataSource: that.option('dataSource'),
                        texts: that.option('texts'),
                        showRowTotals: that.option('showRowTotals'),
                        showRowGrandTotals: that.option('showRowGrandTotals'),
                        showColumnTotals: that.option('showColumnTotals'),
                        showTotalsPrior: that.option('showTotalsPrior'),
                        showColumnGrandTotals: that.option('showColumnGrandTotals'),
                        hideEmptySummaryCells: that.option("hideEmptySummaryCells"),
                        onFieldsPrepared: function(fields) {
                            $.each(fields, function(index, field) {
                                $.each(["allowSorting", "allowSortingBySummary", "allowFiltering", "allowExpandAll"], function(_, optionName) {
                                    if (field[optionName] === undefined)
                                        field[optionName] = that.option(optionName)
                                })
                            })
                        }
                    }
            },
            _initDataController: function() {
                var that = this;
                if (that._dataController)
                    that._dataController.dispose();
                that._dataController = new pivotGrid.DataController(that._getDataControllerOptions());
                that._dataController.changed.add(function() {
                    that._render()
                });
                that._dataController.scrollChanged.add(function(options) {
                    that._scrollLeft = options.left;
                    that._scrollTop = options.top
                });
                that._dataController.loadingChanged.add(function() {
                    that._updateLoading()
                });
                var expandValueChanging = that.option('onExpandValueChanging');
                if (expandValueChanging)
                    that._dataController.expandValueChanging.add(function(e) {
                        expandValueChanging(e)
                    })
            },
            _init: function() {
                var that = this;
                that.callBase();
                that._initDataController();
                that._scrollLeft = that._scrollTop = null;
                that._initActions();
                that._clientExporter = new DX.dxClientExporter({
                    exportingAction: that._actions.exportingAction,
                    exportedAction: that._actions.exportedAction
                })
            },
            _initActions: function() {
                this._actions = {
                    onContextMenuPreparing: this._createActionByOption("onContextMenuPreparing"),
                    onCellClick: this._createActionByOption("onCellClick"),
                    exportingAction: this._createActionByOption("onExporting"),
                    exportedAction: this._createActionByOption("onExported")
                }
            },
            _trigger: function(eventName, eventArg) {
                this._actions[eventName](eventArg)
            },
            _optionValuesEqual: function(name, oldValue, newValue) {
                if (name === "dataSource" && newValue instanceof DX.data.PivotGridDataSource && oldValue instanceof DX.data.PivotGridDataSource)
                    return newValue === oldValue;
                return this.callBase.apply(this, arguments)
            },
            _optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"dataSource":
                    case"allowSorting":
                    case"allowFiltering":
                    case"scrolling":
                    case"stateStoring":
                        that._initDataController();
                        that._fieldChooserPopup.hide();
                        that._invalidate();
                        break;
                    case"texts":
                    case"showTotalsPrior":
                    case"showRowTotals":
                    case"showRowGrandTotals":
                    case"showColumnTotals":
                    case"showColumnGrandTotals":
                    case"showColumnGrandTotals":
                    case"hideEmptySummaryCells":
                        that._dataController.updateViewOptions(that._getDataControllerOptions());
                        break;
                    case"useNativeScrolling":
                    case"encodeHtml":
                    case"renderCellCountLimit":
                        that._invalidate();
                        break;
                    case"rtlEnabled":
                        that.callBase(args);
                        that._renderFieldChooser();
                        that._renderContextMenu();
                        that._renderLoadPanel(that._dataArea.groupElement());
                        that._invalidate();
                        break;
                    case"export":
                        that._renderDescriptionArea();
                        break;
                    case"onExpandValueChanging":
                    case"onCellPrepared":
                    case"allowSortingBySummary":
                    case"allowExpandAll":
                        break;
                    case"onCellClick":
                    case"onContextMenuPreparing":
                        that._actions[args.name] = that._createActionByOption(args.name);
                        break;
                    case"fieldChooser":
                        that._renderFieldChooser();
                        that._renderDescriptionArea();
                        break;
                    case"loadPanel":
                        that._renderLoadPanel(that._dataArea.groupElement());
                        that._invalidate();
                        break;
                    case"showBorders":
                        that._tableElement().toggleClass(BORDERS_CLASS_NAME, args.value);
                        that.updateDimensions();
                        break;
                    case"onExporting":
                        that._clientExporter.option("exportingAction", that._actions.exportingAction);
                        break;
                    case"onExported":
                        that._clientExporter.option("exportedAction", that._actions.exportedAction);
                        break;
                    default:
                        that.callBase(args)
                }
            },
            _updateScrollPosition: function(columnsArea, rowsArea, dataArea) {
                var that = this,
                    scrollTop,
                    scrollLeft,
                    dataAreaScrollable,
                    scrolled = that._scrollTop || that._scrollLeft;
                if (rowsArea && !rowsArea.hasScroll())
                    that._scrollTop = null;
                if (columnsArea && !columnsArea.hasScroll())
                    that._scrollLeft = null;
                if (that._scrollTop !== null || that._scrollLeft !== null || scrolled) {
                    scrollTop = that._scrollTop || 0;
                    scrollLeft = that._scrollLeft || 0;
                    setScrollPos(dataArea, {
                        x: scrollLeft,
                        y: scrollTop
                    });
                    setScrollPos(columnsArea, scrollLeft);
                    setScrollPos(rowsArea, scrollTop)
                }
                else if (dataArea) {
                    dataAreaScrollable = getAreaScrollable(dataArea);
                    dataAreaScrollable && dataAreaScrollable.update()
                }
            },
            _subscribeToEvents: function(columnsArea, rowsArea, dataArea) {
                var that = this;
                subscribeToScrollEvent(dataArea, function(e) {
                    var scrollOffset = e.scrollOffset;
                    if ((that._scrollLeft || 0) !== (scrollOffset.left || 0) || (that._scrollTop || 0) !== (scrollOffset.top || 0)) {
                        that._scrollLeft = e.scrollOffset.left;
                        that._scrollTop = e.scrollOffset.top;
                        that._updateScrollPosition(columnsArea, rowsArea, null);
                        if (that.option("scrolling.mode") === "virtual")
                            that._dataController.setViewportPosition(that._scrollLeft, that._scrollTop)
                    }
                });
                rowsArea.groupElement().off(wheelEvent.name).on(wheelEvent.name, function(e) {
                    var scrollable = dataArea.groupElement().data("dxScrollable");
                    scrollable && scrollable.scrollTo({y: that._scrollTop - Math.floor(e.delta)})
                })
            },
            _clean: $.noop,
            _needDelayResizing: function() {
                var cells = this._dataController.getCellsInfo(),
                    cellsCount = cells.length * (cells.length ? cells[0].length : 0);
                return cellsCount > this.option("renderCellCountLimit")
            },
            _renderFieldChooser: function() {
                var that = this,
                    container = that._pivotGridContainer,
                    fieldChooserOptions = that.option("fieldChooser") || {};
                var popupOptions = {
                        visible: false,
                        shading: false,
                        title: fieldChooserOptions.title,
                        width: fieldChooserOptions.width,
                        height: fieldChooserOptions.height,
                        showCloseButton: true,
                        onShown: function(e) {
                            var popup = e.component,
                                $content = e.component.content();
                            that._createComponent($content, "dxPivotGridFieldChooser", {
                                layout: fieldChooserOptions.layout,
                                texts: fieldChooserOptions.texts || {},
                                dataSource: that.getDataSource(),
                                width: undefined,
                                height: undefined
                            });
                            that._createComponent($content.parent(), "dxResizable", {
                                handles: that.option('rtlEnabled') ? "left bottom" : "right bottom",
                                onResize: function(e) {
                                    popup._setContentHeight();
                                    $content.dxPivotGridFieldChooser("updateDimensions")
                                },
                                minWidth: fieldChooserOptions.minWidth,
                                minHeight: fieldChooserOptions.minHeight
                            })
                        }
                    };
                if (that._fieldChooserPopup)
                    that._fieldChooserPopup.option(popupOptions);
                else
                    that._fieldChooserPopup = that._createComponent($('<div>').addClass('dx-fieldchooser-popup').appendTo(container), "dxPopup", popupOptions)
            },
            _renderContextMenu: function() {
                var that = this,
                    $container = that._pivotGridContainer;
                if (that._contextMenu)
                    that._contextMenu.element().remove();
                that._contextMenu = that._createComponent($("<div>").appendTo($container), "dxContextMenu", {
                    onPositioning: function(actionArgs) {
                        var event = actionArgs.jQueryEvent,
                            cellElement = event.target.cellIndex >= 0 ? event.target : $(event.target).closest('td').get(0),
                            cellArgs,
                            items;
                        if (cellElement) {
                            cellArgs = that._createCellArgs(cellElement, event);
                            items = that._getContextMenuItems(cellArgs);
                            if (items) {
                                actionArgs.component.option('items', items);
                                return
                            }
                        }
                        actionArgs.canceled = true
                    },
                    onItemClick: function(params) {
                        params.itemData.onItemClick && params.itemData.onItemClick(params)
                    },
                    cssClass: pivotGrid.cssClassNames.pivotGrid,
                    target: that.element()
                })
            },
            _getContextMenuItems: function(e) {
                var that = this,
                    items = [];
                if (e.area === "row" || e.area === "column") {
                    var areaFields = e[e.area + "Fields"],
                        oppositeAreaFields = e[e.area === "column" ? "rowFields" : "columnFields"],
                        field = e.cell.path && areaFields[e.cell.path.length - 1],
                        dataSource = that.getDataSource();
                    if (field && field.allowExpandAll && e.cell.path.length < e[e.area + "Fields"].length && e.cell.type === "D") {
                        items.push({
                            beginGroup: true,
                            icon: "none",
                            text: that.option("texts.expandAll"),
                            onItemClick: function() {
                                dataSource.expandAll(field.index)
                            }
                        });
                        items.push({
                            text: that.option("texts.collapseAll"),
                            icon: "none",
                            onItemClick: function() {
                                dataSource.collapseAll(field.index)
                            }
                        })
                    }
                    if (e.cell.isLast) {
                        var sortingBySummaryItemCount = 0;
                        $.each(oppositeAreaFields, function(index, field) {
                            if (field.allowSortingBySummary)
                                $.each(e.dataFields, function(dataIndex, dataField) {
                                    if (commonUtils.isDefined(e.cell.dataIndex) && e.cell.dataIndex !== dataIndex)
                                        return;
                                    var showDataFieldCaption = !commonUtils.isDefined(e.cell.dataIndex) && e.dataFields.length > 1,
                                        textFormat = that.option(e.area === "column" ? "texts.sortColumnBySummary" : "texts.sortRowBySummary"),
                                        checked = pivotGrid.findField(e.dataFields, field.sortBySummaryField) === dataIndex && (e.cell.path || []).join("/") === (field.sortBySummaryPath || []).join("/"),
                                        text = stringUtils.format(textFormat, showDataFieldCaption ? field.caption + " - " + dataField.caption : field.caption);
                                    items.push({
                                        beginGroup: sortingBySummaryItemCount === 0,
                                        icon: checked ? field.sortOrder === "desc" ? "desc" : "asc" : "none",
                                        text: text,
                                        onItemClick: function() {
                                            dataSource.field(field.index, {
                                                sortBySummaryField: dataField.caption || dataField.dataField,
                                                sortBySummaryPath: e.cell.path,
                                                sortOrder: field.sortOrder === "desc" ? "asc" : "desc"
                                            });
                                            dataSource.load()
                                        }
                                    });
                                    sortingBySummaryItemCount++
                                })
                        });
                        $.each(oppositeAreaFields, function(index, field) {
                            if (field.allowSortingBySummary && commonUtils.isDefined(field.sortBySummaryField)) {
                                items.push({
                                    beginGroup: sortingBySummaryItemCount === 0,
                                    icon: "none",
                                    text: that.option("texts.removeAllSorting"),
                                    onItemClick: function() {
                                        $.each(oppositeAreaFields, function(index, field) {
                                            dataSource.field(field.index, {
                                                sortBySummaryField: undefined,
                                                sortBySummaryPath: undefined,
                                                sortOrder: undefined
                                            })
                                        });
                                        dataSource.load()
                                    }
                                });
                                return false
                            }
                        })
                    }
                }
                if (that.option("fieldChooser.enabled"))
                    items.push({
                        beginGroup: true,
                        icon: "field-chooser",
                        text: that.option("texts.showFieldChooser"),
                        onItemClick: function() {
                            that._fieldChooserPopup.show()
                        }
                    });
                e.items = items;
                if (that.option("export.enabled"))
                    items.push({
                        beginGroup: true,
                        icon: "exportxlsx",
                        text: that.option("texts.exportToExcel"),
                        onItemClick: function() {
                            that.exportToExcel()
                        }
                    });
                that._trigger("onContextMenuPreparing", e);
                items = e.items;
                if (items && items.length)
                    return items
            },
            _createCellArgs: function(cellElement, jQueryEvent) {
                var that = this,
                    $cellElement = $(cellElement),
                    columnIndex = cellElement.cellIndex,
                    rowIndex = cellElement.parentElement.rowIndex,
                    $table = $cellElement.closest('table'),
                    dataSource = that.getDataSource(),
                    data = $table.data("data"),
                    cell = data && data[rowIndex] && data[rowIndex][columnIndex],
                    args = {
                        area: $table.data("area"),
                        rowFields: dataSource.getAreaFields("row"),
                        columnFields: dataSource.getAreaFields("column"),
                        dataFields: dataSource.getAreaFields("data"),
                        rowIndex: rowIndex,
                        columnIndex: columnIndex,
                        cellElement: $cellElement,
                        cell: cell,
                        jQueryEvent: jQueryEvent
                    };
                return args
            },
            _handleCellClick: function(e) {
                var that = this,
                    args = that._createCellArgs(e.currentTarget, e);
                if (!args.area && (args.rowIndex || args.columnIndex))
                    return;
                that._trigger("onCellClick", args)
            },
            _getNoDataText: function() {
                return this.option("texts.noData")
            },
            _updateNoDataText: DX.ui.dxDataGrid.RowsView.prototype._updateNoDataText,
            _renderLoadPanel: DX.ui.dxDataGrid.RowsView.prototype._renderLoadPanel,
            _updateLoading: function() {
                var that = this;
                that._loadPanel && that._loadPanel.option("visible", that._dataController.isLoading())
            },
            _renderDescriptionArea: function() {
                var that = this;
                var $descriptionCell = that.element().find("." + DESCRIPTION_AREA_CELL_CLASS_NAME);
                $descriptionCell.empty();
                if (that.option("fieldChooser.enabled"))
                    that._createComponent($("<div>").appendTo($descriptionCell).addClass("dx-pivotgrid-field-chooser-button"), "dxButton", {
                        icon: "column-chooser",
                        onClick: function() {
                            that.getFieldChooserPopup().show()
                        }
                    });
                if (that.option("export.enabled"))
                    that._createComponent($("<div>").appendTo($descriptionCell).addClass("dx-pivotgrid-export-button"), "dxButton", {
                        icon: "exportxlsx",
                        onClick: function() {
                            that.exportToExcel()
                        }
                    })
            },
            _renderContentImpl: function() {
                var that = this,
                    columnsAreaElement,
                    rowsAreaElement,
                    dataAreaElement,
                    tableElement,
                    dataArea = that._dataArea || new pivotGrid.DataArea(that),
                    rowsArea = (that._rowsArea || new pivotGrid.VerticalHeadersArea(that)).setDataController(that._dataController),
                    columnsArea = (that._columnsArea || new pivotGrid.HorizontalHeadersArea(that)).setDataController(that._dataController),
                    scrollBarInfo = getScrollBarInfo(that.element(), that.option("scrolling.useNative")),
                    isFirstDrawing = !that._pivotGridContainer;
                that._scrollBarWidth = scrollBarInfo.scrollBarWidth;
                that._scrollBarUseNative = scrollBarInfo.scrollBarUseNative;
                if (isFirstDrawing) {
                    that.element().addClass(pivotGrid.cssClassNames.pivotGrid).addClass(pivotGrid.cssClassNames.rowLines);
                    that._pivotGridContainer = $('<div>');
                    that._renderFieldChooser();
                    that._renderContextMenu();
                    columnsAreaElement = $('<td>').addClass(COLUMN_AREA_CELL_CLASS_NAME);
                    rowsAreaElement = $('<td>').addClass(ROW_AREA_CELL_CLASS_NAME);
                    dataAreaElement = $('<td>').addClass(DATA_AREA_CELL_CLASS_NAME);
                    tableElement = $('<table>').css({width: "100%"}).toggleClass(BORDERS_CLASS_NAME, !!that.option("showBorders"));
                    $('<tr>').append($('<td>').addClass(DESCRIPTION_AREA_CELL_CLASS_NAME)).append(columnsAreaElement).appendTo(tableElement);
                    $('<tr>').addClass(pivotGrid.cssClassNames.bottomAraesRow).append(rowsAreaElement).append(dataAreaElement).appendTo(tableElement);
                    tableElement.appendTo(that._pivotGridContainer);
                    that._pivotGridContainer.appendTo(that.element());
                    tableElement.on(eventUtils.addNamespace("dxclick", "dxPivotGrid"), 'td', $.proxy(that, "_handleCellClick"))
                }
                else
                    tableElement = that._tableElement();
                that._rowsArea = rowsArea;
                that._columnsArea = columnsArea;
                that._dataArea = dataArea;
                columnsArea.render(columnsAreaElement, that._dataController.getColumnsInfo());
                rowsArea.render(rowsAreaElement, that._dataController.getRowsInfo());
                dataArea.render(dataAreaElement, that._dataController.getCellsInfo());
                dataArea.tableElement().prepend(columnsArea.headElement());
                var updateHandler = function() {
                        that.updateDimensions();
                        that._subscribeToEvents(columnsArea, rowsArea, dataArea)
                    };
                that._pivotGridContainer.detach();
                that._hasHeight = that.element().height() > 0;
                that._pivotGridContainer.appendTo(that.element());
                if (isFirstDrawing) {
                    that._renderLoadPanel(dataArea.groupElement());
                    that._renderDescriptionArea();
                    rowsArea.processScroll();
                    columnsArea.processScroll()
                }
                that._needDelayResizing() && isFirstDrawing ? setTimeout(updateHandler) : updateHandler()
            },
            _fireContentReadyAction: function() {
                if (!this._dataController.isLoading())
                    this.callBase()
            },
            getScrollPath: function(area) {
                var that = this;
                if (area === 'column')
                    return that._columnsArea.getScrollPath(that._scrollLeft);
                else
                    return that._rowsArea.getScrollPath(that._scrollTop)
            },
            getDataSource: function() {
                return this._dataController.getDataSource()
            },
            getFieldChooserPopup: function() {
                return this._fieldChooserPopup
            },
            hasScroll: function(area) {
                var that = this;
                if (area === 'column')
                    return that._columnsArea.hasScroll();
                else
                    return that._rowsArea.hasScroll()
            },
            _dimensionChanged: function() {
                this.updateDimensions()
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this.updateDimensions()
            },
            _dispose: function() {
                var that = this;
                that.callBase.apply(that, arguments);
                if (that._dataController)
                    that._dataController.dispose()
            },
            _tableElement: function() {
                return this.element().find('table').first()
            },
            resize: function() {
                this.updateDimensions()
            },
            isReady: function() {
                return this.callBase() && !this._dataController.isLoading()
            },
            updateDimensions: function() {
                var that = this,
                    groupWidth,
                    groupHeight,
                    tableElement = that._tableElement(),
                    rowsArea = that._rowsArea,
                    columnsArea = that._columnsArea,
                    dataArea = that._dataArea,
                    dataAreaHeights,
                    rowsAreaHeights,
                    resultHeights,
                    resultWidths,
                    rowsAreaColumnWidths,
                    bordersWidth,
                    totalWidth = 0,
                    totalHeight = 0,
                    rowsAreaWidth = 0,
                    hasRowsScroll,
                    hasColumnsScroll,
                    loadPanelOptions = that.option("loadPanel") || {},
                    minHeight,
                    scrollBarWidth = that._scrollBarWidth || 0,
                    dataAreaCell = tableElement.find("." + DATA_AREA_CELL_CLASS_NAME),
                    rowAreaCell = tableElement.find("." + ROW_AREA_CELL_CLASS_NAME),
                    columnAreaCell = tableElement.find("." + COLUMN_AREA_CELL_CLASS_NAME),
                    descriptionCell = tableElement.find("." + DESCRIPTION_AREA_CELL_CLASS_NAME),
                    elementWidth,
                    columnsAreaHeight,
                    descriptionCellHeight,
                    columnsAreaRowHeights,
                    columnsAreaRowCount;
                if (!dataArea.headElement().length) {
                    dataArea.tableElement().prepend(columnsArea.headElement());
                    dataArea.resetColumnsWidth()
                }
                dataArea.reset();
                rowsArea.reset();
                columnsArea.reset();
                resultWidths = dataArea.getColumnsWidth();
                rowsAreaHeights = rowsArea.getRowsHeight();
                dataAreaHeights = dataArea.getRowsHeight();
                descriptionCellHeight = descriptionCell.outerHeight();
                columnsAreaRowCount = that._dataController.getColumnsInfo().length;
                resultHeights = mergeArraysByMaxValue(rowsAreaHeights, dataAreaHeights.slice(columnsAreaRowCount));
                columnsAreaRowHeights = dataAreaHeights.slice(0, columnsAreaRowCount);
                columnsAreaHeight = getArraySum(columnsAreaRowHeights);
                rowsAreaColumnWidths = rowsArea.getColumnsWidth();
                if (that._hasHeight) {
                    bordersWidth = columnAreaCell.outerHeight() - columnAreaCell.height() + dataAreaCell.outerHeight() - dataAreaCell.height() + tableElement.outerHeight() - tableElement.height();
                    groupHeight = that.element().height() - (Math.max(dataArea.headElement().height(), columnAreaCell.height()) + bordersWidth)
                }
                totalWidth = dataArea.tableElement().width();
                totalHeight = getArraySum(resultHeights);
                rowsAreaWidth = getArraySum(rowsAreaColumnWidths);
                elementWidth = that.element().width();
                bordersWidth = rowAreaCell.outerWidth() - rowAreaCell.width() + dataAreaCell.outerWidth() - dataAreaCell.width() + tableElement.outerWidth() - tableElement.width();
                groupWidth = elementWidth - rowsAreaWidth - bordersWidth;
                hasRowsScroll = totalHeight - groupHeight >= 1;
                hasColumnsScroll = totalWidth - groupWidth >= 1;
                if (!hasRowsScroll)
                    groupHeight = totalHeight + (hasColumnsScroll ? scrollBarWidth : 0);
                columnsArea.tableElement().append(dataArea.headElement());
                if (resultHeights.length === 1 && loadPanelOptions.enabled && loadPanelOptions.height) {
                    minHeight = loadPanelOptions.height + 50;
                    if (resultHeights[0] < minHeight) {
                        resultHeights[0] = minHeight;
                        if (groupHeight < minHeight)
                            groupHeight = minHeight
                    }
                }
                if (!hasColumnsScroll && hasRowsScroll && scrollBarWidth)
                    adjustSizeArray(resultWidths, scrollBarWidth);
                if (descriptionCellHeight > columnsAreaHeight) {
                    adjustSizeArray(columnsAreaRowHeights, columnsAreaHeight - descriptionCellHeight);
                    columnsArea.setRowsHeight(columnsAreaRowHeights)
                }
                columnsArea.groupWidth(groupWidth);
                columnsArea.processScrollBarSpacing(hasRowsScroll ? scrollBarWidth : 0);
                columnsArea.setColumnsWidth(resultWidths);
                rowsArea.groupHeight(groupHeight);
                rowsArea.processScrollBarSpacing(hasColumnsScroll ? scrollBarWidth : 0);
                rowsArea.setColumnsWidth(rowsAreaColumnWidths);
                rowsArea.setRowsHeight(resultHeights);
                dataArea.setColumnsWidth(resultWidths);
                dataArea.setRowsHeight(resultHeights);
                dataArea.groupWidth(groupWidth);
                dataArea.groupHeight(groupHeight);
                dataAreaCell.toggleClass("dx-bottom-border", !(hasRowsScroll || scrollBarWidth));
                rowAreaCell.toggleClass("dx-bottom-border", !(hasRowsScroll && !scrollBarWidth));
                if (!that._hasHeight && elementWidth !== that.element().width()) {
                    var diff = elementWidth - that.element().width();
                    if (!hasColumnsScroll) {
                        adjustSizeArray(resultWidths, diff);
                        columnsArea.setColumnsWidth(resultWidths);
                        dataArea.setColumnsWidth(resultWidths)
                    }
                    dataArea.groupWidth(groupWidth - diff);
                    columnsArea.groupWidth(groupWidth - diff)
                }
                if (that.option("scrolling.mode") === "virtual" && !that._dataController.isLoading()) {
                    var virtualContentParams = that._dataController.calculateVirtualContentParams({
                            contentWidth: totalWidth,
                            contentHeight: totalHeight,
                            rowCount: resultHeights.length,
                            columnCount: resultWidths.length,
                            viewportWidth: groupWidth,
                            viewportHeight: groupHeight
                        });
                    dataArea.setVirtualContentParams({
                        top: virtualContentParams.contentTop,
                        left: virtualContentParams.contentLeft,
                        width: virtualContentParams.width,
                        height: virtualContentParams.height
                    });
                    rowsArea.setVirtualContentParams({
                        top: virtualContentParams.contentTop,
                        width: rowsAreaWidth,
                        height: virtualContentParams.height
                    });
                    columnsArea.setVirtualContentParams({
                        left: virtualContentParams.contentLeft,
                        width: virtualContentParams.width,
                        height: columnsArea.groupElement().height()
                    });
                    hasRowsScroll = groupHeight < virtualContentParams.height;
                    hasColumnsScroll = groupWidth < virtualContentParams.width
                }
                dataArea.processScroll(scrollBarWidth, hasRowsScroll, hasColumnsScroll, that._scrollBarUseNative);
                that._updateLoading();
                that._updateNoDataText(dataArea.groupElement());
                that._updateScrollPosition(columnsArea, rowsArea, dataArea);
                that._testResultWidths = resultWidths;
                that._testResultHeights = resultHeights
            },
            applyPartialDataSource: function(area, path, dataSource) {
                this._dataController.applyPartialDataSource(area, path, dataSource)
            }
        }));
        var pivotGrid = $.extend(ui.dxPivotGrid, {
                cssClassNames: {
                    pivotGrid: 'dx-pivotgrid',
                    rowLines: 'dx-row-lines',
                    area: 'dx-pivotgrid-area',
                    areaData: 'dx-pivotgrid-area-data',
                    splitter: 'dx-pivotgrid-splitter',
                    splitterButton: 'dx-button',
                    splitterButtonDisable: 'dx-button-disable',
                    splitterExpand: 'dx-expand',
                    splitterCollapse: 'dx-collapse',
                    bottomAraesRow: 'dx-bottom-row',
                    verticalScroll: 'dx-vertical-scroll',
                    headersVertical: 'dx-pivotgrid-vertical-headers',
                    headersHorizontal: 'dx-pivotgrid-horizontal-headers',
                    headersVerticalLastCell: 'dx-last-cell',
                    headersVerticalExpandBorder: 'dx-expand-border',
                    headersExpandCollapseImage: 'dx-expand',
                    headersExpanded: 'dx-pivotgrid-expanded',
                    headersCollapsed: 'dx-pivotgrid-collapsed',
                    bottomBorder: 'dx-pivotgrid-bottom-border',
                    total: 'dx-total',
                    grandTotal: 'dx-grandtotal',
                    rowTotal: 'dx-row-total'
                },
                mergeArraysByMaxValue: mergeArraysByMaxValue
            })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.dataSource.js */
    (function($, DX) {
        var pivotGrid = DX.ui.dxPivotGrid,
            commonUtils = DX.require("/utils/utils.common"),
            isDefined = commonUtils.isDefined,
            each = $.each,
            Class = DevExpress.require("/class"),
            EventsMixin = DX.require("/eventsMixin"),
            inflector = DX.require("/utils/utils.inflector"),
            normalizeIndexes = DX.require("/utils/utils.array").normalizeIndexes,
            formatHelper = DX.require("/utils/utils.formatHelper"),
            DESCRIPTION_NAME_BY_AREA = {
                row: "rows",
                column: "columns",
                data: "values",
                filter: "filters"
            };
        function findField(fields, id) {
            var i,
                field;
            if (fields && commonUtils.isDefined(id))
                for (i = 0; i < fields.length; i++) {
                    field = fields[i];
                    if (field.name === id || field.caption === id || field.dataField === id || field.index === id)
                        return i
                }
            return -1
        }
        function foreachTree(items, callback, parentAtFirst, members) {
            members = members || [];
            items = items || [];
            var item,
                i;
            for (i = 0; i < items.length; i++) {
                item = items[i];
                members.unshift(item);
                if (parentAtFirst && callback(members, i) === false)
                    return;
                if (item.children)
                    foreachTree(item.children, callback, parentAtFirst, members);
                if (!parentAtFirst && callback(members, i) === false)
                    return;
                members.shift();
                if (items[i] !== item)
                    i--
            }
        }
        function createPath(items) {
            var result = [],
                i;
            for (i = items.length - 1; i >= 0; i--)
                result.push(items[i].key || items[i].value);
            return result
        }
        function formatValue(value, options) {
            var formatObject = {
                    value: value,
                    valueText: formatHelper.format(value, options.format, options.precision) || ''
                };
            return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText
        }
        function foreachDataLevel(data, callback, index, childrenField) {
            var item,
                i;
            index = index || 0;
            childrenField = childrenField || "children";
            if (data.length)
                callback(data, index);
            for (i = 0; i < data.length; i++) {
                item = data[i];
                if (item[childrenField] && item[childrenField].length)
                    foreachDataLevel(item[childrenField], callback, index + 1, childrenField)
            }
        }
        function getCompareFunction(valueSelector) {
            return function(a, b) {
                    var result = 0;
                    if (valueSelector(a) > valueSelector(b))
                        result = 1;
                    else if (valueSelector(a) < valueSelector(b))
                        result = -1;
                    return result
                }
        }
        function areExpressionsUsed(descriptions) {
            var expressionsUsed = false;
            each(descriptions.values, function(_, field) {
                if (field.summaryDisplayMode || field.calculateSummaryValue || field.runningTotal) {
                    expressionsUsed = true;
                    return false
                }
            });
            return expressionsUsed
        }
        DX.data.PivotGridDataSource = pivotGrid.DataSource = Class.inherit(function() {
            var findHeaderItem = function(headerItems, path) {
                    if (headerItems._cacheByPath)
                        return headerItems._cacheByPath[path.join(".")] || null
                };
            var getHeaderItemsLastIndex = function(headerItems, grandTotalIndex) {
                    var i,
                        lastIndex = -1,
                        headerItem;
                    if (headerItems)
                        for (i = 0; i < headerItems.length; i++) {
                            headerItem = headerItems[i];
                            lastIndex = Math.max(lastIndex, headerItem.index);
                            if (headerItem.children)
                                lastIndex = Math.max(lastIndex, getHeaderItemsLastIndex(headerItem.children));
                            else if (headerItem.collapsedChildren)
                                lastIndex = Math.max(lastIndex, getHeaderItemsLastIndex(headerItem.collapsedChildren))
                        }
                    if (isDefined(grandTotalIndex))
                        lastIndex = Math.max(lastIndex, grandTotalIndex);
                    return lastIndex
                };
            var updateHeaderItemChildren = function(headerItems, headerItem, children, grandTotalIndex) {
                    var applyingHeaderItemsCount = getHeaderItemsLastIndex(children) + 1,
                        emptyIndex = getHeaderItemsLastIndex(headerItems, grandTotalIndex) + 1,
                        index,
                        applyingItemIndexesToCurrent = [];
                    for (index = 0; index < applyingHeaderItemsCount; index++)
                        applyingItemIndexesToCurrent[index] = emptyIndex++;
                    headerItem.children = children;
                    foreachTree(headerItem.children, function(items) {
                        items[0].index = applyingItemIndexesToCurrent[items[0].index]
                    });
                    return applyingItemIndexesToCurrent
                };
            var updateHeaderItems = function(headerItems, newHeaderItems) {
                    var applyingItemIndexesToCurrent = [];
                    foreachTree(headerItems, function(items) {
                        delete items[0].collapsedChildren
                    });
                    foreachTree(newHeaderItems, function(items) {
                        var headerItem = findHeaderItem(headerItems, createPath(items));
                        if (headerItem)
                            applyingItemIndexesToCurrent[items[0].index] = headerItem.index
                    });
                    return applyingItemIndexesToCurrent
                };
            var updateDataSourceCells = function(dataSource, newDataSourceCells, newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent) {
                    var newRowIndex,
                        newColumnIndex,
                        newRowCells,
                        newCell,
                        rowIndex,
                        columnIndex,
                        dataSourceCells = dataSource.values;
                    if (newDataSourceCells)
                        for (newRowIndex = 0; newRowIndex <= newDataSourceCells.length; newRowIndex++) {
                            newRowCells = newDataSourceCells[newRowIndex];
                            rowIndex = newRowItemIndexesToCurrent[newRowIndex];
                            if (!isDefined(rowIndex))
                                rowIndex = dataSource.grandTotalRowIndex;
                            if (newRowCells && isDefined(rowIndex)) {
                                if (!dataSourceCells[rowIndex])
                                    dataSourceCells[rowIndex] = [];
                                for (newColumnIndex = 0; newColumnIndex <= newRowCells.length; newColumnIndex++) {
                                    newCell = newRowCells[newColumnIndex];
                                    columnIndex = newColumnItemIndexesToCurrent[newColumnIndex];
                                    if (!isDefined(columnIndex))
                                        columnIndex = dataSource.grandTotalColumnIndex;
                                    if (isDefined(newCell) && isDefined(columnIndex))
                                        dataSourceCells[rowIndex][columnIndex] = newCell
                                }
                            }
                        }
                };
            function createStore(dataSourceOptions) {
                var store,
                    storeOptions;
                if ($.isPlainObject(dataSourceOptions) && dataSourceOptions.load)
                    store = new pivotGrid.LocalStore(dataSourceOptions);
                else {
                    if (dataSourceOptions && !dataSourceOptions.store)
                        dataSourceOptions = {store: dataSourceOptions};
                    storeOptions = dataSourceOptions.store;
                    if (storeOptions.type === "xmla")
                        store = new pivotGrid.XmlaStore(storeOptions);
                    else if ($.isPlainObject(storeOptions) && storeOptions.type || storeOptions instanceof DX.data.Store || $.isArray(storeOptions))
                        store = new pivotGrid.LocalStore(dataSourceOptions);
                    else if (storeOptions instanceof Class)
                        store = storeOptions
                }
                return store
            }
            function getExpandedPaths(dataSource, loadOptions, dimentionName) {
                var result = [],
                    fields = loadOptions[dimentionName];
                foreachTree(dataSource[dimentionName], function(items) {
                    var item = items[0],
                        path = createPath(items);
                    if (item.children && fields[path.length - 1] && !fields[path.length - 1].expanded)
                        path.length < fields.length && result.push(path.slice())
                }, true);
                return result
            }
            function setStateProperties(field, srcField) {
                $.each(["area", "areaIndex", "sortOrder", "filterType", "filterValues", "sortBy", "sortBySummaryField", "sortBySummaryPath", "expanded"], function(_, name) {
                    field[name] = srcField[name]
                });
                return field
            }
            function getFieldsState(fields) {
                var result = [];
                $.each(fields, function(_, field) {
                    result.push(setStateProperties({}, field))
                });
                return result
            }
            function setFieldsState(stateFields, fields) {
                stateFields = stateFields || [];
                $.each(fields, function(index, field) {
                    setStateProperties(field, stateFields[index] || {})
                });
                return fields
            }
            function getFieldsByGroup(fields, grouppingField) {
                return $.map(fields, function(field) {
                        if (field.groupName === grouppingField.groupName && commonUtils.isNumber(field.groupIndex) && field.visible !== false)
                            return $.extend(field, {
                                    areaIndex: grouppingField.areaIndex,
                                    area: grouppingField.area,
                                    dataField: field.dataField || grouppingField.dataField,
                                    dataType: field.dataType || grouppingField.dataType,
                                    sortBy: field.sortBy || grouppingField.sortBy,
                                    sortOrder: field.sortOrder || grouppingField.sortOrder,
                                    sortBySummaryField: field.sortBySummaryField || grouppingField.sortBySummaryField,
                                    sortBySummaryPath: field.sortBySummaryPath || grouppingField.sortBySummaryPath,
                                    visible: field.visible || grouppingField.visible
                                });
                        return null
                    }).sort(function(a, b) {
                        return a.groupIndex - b.groupIndex
                    })
            }
            function sortFieldsByAreaIndex(fields) {
                fields.sort(function(field1, field2) {
                    return field1.areaIndex - field2.areaIndex
                })
            }
            function isAreaField(field, area) {
                return field.area === area && !isDefined(field.groupIndex) && field.visible !== false
            }
            function createDescriptions(currentField) {
                var that = this,
                    fields = that.fields(),
                    descriptions = {
                        rows: [],
                        columns: [],
                        values: [],
                        filters: []
                    };
                each(["row", "column", "data", "filter"], function(_, areaName) {
                    var areaFields = [];
                    $.each(fields, function(index, field) {
                        if (isAreaField(field, areaName))
                            areaFields.push(field)
                    });
                    normalizeIndexes(areaFields, 'areaIndex', currentField)
                });
                each(fields || [], function(_, field) {
                    var descriptionName = DESCRIPTION_NAME_BY_AREA[field.area],
                        dimension = descriptions[descriptionName],
                        groupName = field.groupName;
                    if (groupName && !commonUtils.isNumber(field.groupIndex))
                        field.levels = getFieldsByGroup(fields, field);
                    if (!dimension || groupName && commonUtils.isNumber(field.groupIndex) || field.visible === false)
                        return;
                    if (field.levels && dimension !== descriptions.filters) {
                        dimension.push.apply(dimension, field.levels);
                        if (field.filterValues && field.filterValues.length)
                            descriptions.filters.push(field)
                    }
                    else
                        dimension.push(field)
                });
                each(descriptions, function(_, fields) {
                    sortFieldsByAreaIndex(fields)
                });
                return descriptions
            }
            function getFieldId(field) {
                return (field.dataField || field.groupName || '') + (field.groupInterval ? field.groupName || '' : "NOGROUP") + (field.groupInterval || '')
            }
            function mergeFields(fields, storeFields, retrieveFieldsOptionValue) {
                var result = [],
                    fieldsDictionary = {},
                    removedFields = {},
                    mergedGroups = [],
                    dataTypes = getFieldsDataType(fields);
                if (storeFields) {
                    each(storeFields, function(_, field) {
                        fieldsDictionary[getFieldId(field)] = field
                    });
                    each(fields, function(_, field) {
                        var fieldKey = getFieldId(field),
                            storeField = fieldsDictionary[fieldKey] || removedFields[fieldKey],
                            mergedField;
                        if (storeField)
                            mergedField = $.extend({}, storeField, field);
                        else
                            fieldsDictionary[fieldKey] = mergedField = field;
                        $.extend(mergedField, {dataType: dataTypes[field.dataField]});
                        delete fieldsDictionary[fieldKey];
                        removedFields[fieldKey] = storeField;
                        result.push(mergedField)
                    });
                    if (retrieveFieldsOptionValue)
                        each(fieldsDictionary, function(_, field) {
                            result.push(field)
                        })
                }
                else
                    result = fields;
                result.push.apply(result, mergedGroups);
                return result
            }
            function createCaption(field) {
                var caption = field.dataField || field.groupName || "",
                    summaryType = (field.summaryType || "").toLowerCase();
                if (commonUtils.isString(field.groupInterval))
                    caption += "_" + field.groupInterval;
                if (summaryType && summaryType !== "custom") {
                    summaryType = summaryType.replace(/^./, summaryType[0].toUpperCase());
                    if (caption.length)
                        summaryType = " (" + summaryType + ")"
                }
                else
                    summaryType = "";
                return inflector.titleize(caption) + summaryType
            }
            function getFieldsDataType(fields) {
                var result = {};
                each(fields, function(_, field) {
                    result[field.dataField] = result[field.dataField] || field.dataType
                });
                return result
            }
            function getFields(that) {
                var result = $.Deferred(),
                    store = that._store,
                    storeFields = store && store.getFields(getFieldsDataType(that._fields)),
                    mergedFields;
                $.when(storeFields).done(function(storeFields) {
                    that._storeFields = storeFields;
                    mergedFields = mergeFields(that._fields, storeFields, that._retrieveFields);
                    result.resolve(mergedFields)
                }).fail(function() {
                    result.resolve(that._fields)
                });
                return result
            }
            function getSliceIndex(items, path) {
                var index = null,
                    pathValue = (path || []).join(".");
                if (pathValue.length)
                    foreachTree(items, function(items) {
                        var item = items[0],
                            itemPath = createPath(items).join("."),
                            textPath = $.map(items, function(item) {
                                return item.text
                            }).reverse().join(".");
                        if (pathValue === itemPath || item.key && textPath === pathValue) {
                            index = items[0].index;
                            return false
                        }
                    });
                return index
            }
            function getFieldSummaryValueSelector(field, dataSource, loadOptions, dimensionName) {
                var values = dataSource.values,
                    sortBySummaryFieldIndex = findField(loadOptions.values, field.sortBySummaryField),
                    areRows = dimensionName === "rows",
                    sortByDimension = areRows ? dataSource.columns : dataSource.rows,
                    grandTotalIndex = areRows ? dataSource.grandTotalRowIndex : dataSource.grandTotalColumnIndex,
                    sortBySummaryPath = field.sortBySummaryPath || [],
                    sliceIndex = sortBySummaryPath.length ? getSliceIndex(sortByDimension, sortBySummaryPath) : grandTotalIndex;
                if (values && values.length && sortBySummaryFieldIndex >= 0 && isDefined(sliceIndex))
                    return function(field) {
                            var rowIndex = areRows ? field.index : sliceIndex,
                                columnIndex = areRows ? sliceIndex : field.index;
                            return ((values[rowIndex] || [[]])[columnIndex] || [])[sortBySummaryFieldIndex] || null
                        }
            }
            function getSortingMethod(field, dataSource, loadOptions, dimensionName, getAscOrder) {
                var sortOrder = getAscOrder ? "asc" : field.sortOrder,
                    sortBy = getAscOrder ? "value" : field.sortBy === "displayText" ? "text" : "value",
                    defaultCompare = field.sortingMethod || getCompareFunction(function(item) {
                        return item[sortBy]
                    }),
                    summaryValueSelector = !getAscOrder && getFieldSummaryValueSelector(field, dataSource, loadOptions, dimensionName),
                    summaryCompare = summaryValueSelector && getCompareFunction(summaryValueSelector),
                    sortingMethod = function(a, b) {
                        var result = summaryCompare && summaryCompare(a, b) || 0;
                        if (result === 0)
                            result = defaultCompare(a, b);
                        return sortOrder === "desc" ? -result : result
                    };
                return sortingMethod
            }
            function sortDimension(dataSource, loadOptions, dimensionName, getAscOrder) {
                var fields = loadOptions[dimensionName] || [],
                    baseIndex = loadOptions.headerName === dimensionName ? loadOptions.path.length : 0,
                    sortingMetodByLevel = [];
                foreachDataLevel(dataSource[dimensionName], function(item, index) {
                    var field = fields[index] || {},
                        sortingMethod = sortingMetodByLevel[index] = sortingMetodByLevel[index] || getSortingMethod(field, dataSource, loadOptions, dimensionName, getAscOrder);
                    item.sort(sortingMethod)
                }, baseIndex)
            }
            function sort(loadOptions, dataSource, getAscOrder) {
                sortDimension(dataSource, loadOptions, "rows", getAscOrder);
                sortDimension(dataSource, loadOptions, "columns", getAscOrder)
            }
            function formatHeaderItems(data, loadOptions, headerName) {
                foreachTree(data[headerName], function(items) {
                    var item = items[0];
                    item.text = item.text || formatValue(item.value, loadOptions[headerName][createPath(items).length - 1])
                })
            }
            function formatHeaders(loadOptions, data) {
                formatHeaderItems(data, loadOptions, "columns");
                formatHeaderItems(data, loadOptions, "rows")
            }
            function updateCache(headerItems) {
                var cacheByPath = {};
                foreachTree(headerItems, function(items) {
                    var path = createPath(items).join(".");
                    cacheByPath[path] = items[0]
                });
                headerItems._cacheByPath = cacheByPath
            }
            pivotGrid._sort = sort;
            return {
                    ctor: function(options) {
                        options = options || {};
                        var that = this,
                            store = createStore(options);
                        that._store = store;
                        that._loadedData = {
                            rows: [],
                            columns: [],
                            values: []
                        };
                        that._data = $.extend(true, {}, that._loadedData);
                        that._loadingCount = 0;
                        each(["changed", "loadError", "loadingChanged", "fieldsPrepared", "expandValueChanging"], $.proxy(function(_, eventName) {
                            var optionName = "on" + eventName[0].toUpperCase() + eventName.slice(1);
                            if (options.hasOwnProperty(optionName))
                                this.on(eventName, options[optionName])
                        }, this));
                        that._retrieveFields = isDefined(options.retrieveFields) ? options.retrieveFields : true;
                        that._fields = options.fields || [];
                        that._descriptions = options.descriptions ? $.extend(that._createDescriptions(), options.descriptions) : undefined;
                        if (!store) {
                            $.extend(true, that._loadedData, options.store || options);
                            that._data = $.extend(true, {}, that._loadedData)
                        }
                    },
                    getData: function() {
                        return this._data
                    },
                    getAreaFields: function(area, collectGroups) {
                        var areaFields = [],
                            descriptions;
                        if (collectGroups || area === "data") {
                            each(this._fields, function() {
                                if (isAreaField(this, area))
                                    areaFields.push(this)
                            });
                            sortFieldsByAreaIndex(areaFields)
                        }
                        else {
                            descriptions = this._descriptions || {};
                            areaFields = descriptions[DESCRIPTION_NAME_BY_AREA[area]] || []
                        }
                        return areaFields
                    },
                    fields: function(fields) {
                        var that = this;
                        if (fields) {
                            that._fields = mergeFields(fields, that._storeFields, that._retrieveFields);
                            that._fieldsPrepared(that._fields)
                        }
                        return that._fields
                    },
                    field: function(id, options) {
                        var that = this,
                            fields = that._fields,
                            field = fields && fields[commonUtils.isNumber(id) ? id : findField(fields, id)],
                            levels;
                        if (field && options) {
                            each(options, function(optionName, optionValue) {
                                field[optionName] = optionValue;
                                if (optionName === "sortOrder") {
                                    levels = field.levels || [];
                                    for (var i = 0; i < levels.length; i++)
                                        levels[i][optionName] = optionValue
                                }
                            });
                            that._descriptions = that._createDescriptions(field)
                        }
                        return field
                    },
                    getFieldValues: function(index) {
                        var that = this,
                            field = this._fields && this._fields[index],
                            store = this.store(),
                            loadFields = [],
                            loadOptions = {
                                columns: loadFields,
                                rows: [],
                                values: this.getAreaFields("data"),
                                filters: []
                            },
                            d = $.Deferred();
                        if (field && store) {
                            each(field.levels || [field], function() {
                                loadFields.push($.extend({}, this, {
                                    expanded: true,
                                    filterValues: null,
                                    sortOrder: 'asc',
                                    sortBySummaryField: null
                                }))
                            });
                            store.load(loadOptions).done(function(data) {
                                formatHeaders(loadOptions, data);
                                that._sort(loadOptions, data);
                                d.resolve(data.columns)
                            }).fail(d)
                        }
                        else
                            d.reject();
                        return d
                    },
                    reload: function() {
                        return this.load({reload: true})
                    },
                    filter: function() {
                        var store = this._store;
                        return store.filter.apply(store, arguments)
                    },
                    load: function(options) {
                        var that = this,
                            d = $.Deferred();
                        options = options || {};
                        that._changeLoadingCount(1);
                        d.fail(function(e) {
                            that.fireEvent("loadError", [e])
                        }).always(function() {
                            that._changeLoadingCount(-1)
                        });
                        function loadTask() {
                            that._delayedLoadTask = undefined;
                            if (!that._descriptions)
                                $.when(getFields(that)).done(function(fields) {
                                    that._fieldsPrepared(fields);
                                    that._loadCore(options, d)
                                }).fail(d.reject).fail(that._loadErrorHandler);
                            else
                                that._loadCore(options, d)
                        }
                        if (that.store())
                            that._delayedLoadTask = commonUtils.executeAsync(loadTask);
                        else
                            loadTask();
                        return d
                    },
                    createDrillDownDataSource: function(params) {
                        function createCustomStoreMethod(methodName) {
                            return function(options) {
                                    var d;
                                    if (arrayStore)
                                        d = arrayStore[methodName](options);
                                    else {
                                        d = $.Deferred();
                                        $.when(items).done(function(data) {
                                            arrayStore = new DevExpress.data.ArrayStore(data);
                                            arrayStore[methodName](options).done(d.resolve).fail(d.reject)
                                        }).fail(d.reject)
                                    }
                                    return d
                                }
                        }
                        var items = this._store.getDrillDownItems(this._descriptions, params),
                            arrayStore,
                            dataSource = new DevExpress.data.DataSource({
                                load: createCustomStoreMethod("load"),
                                totalCount: createCustomStoreMethod("totalCount"),
                                key: this._store.key()
                            });
                        return dataSource
                    },
                    _createDescriptions: createDescriptions,
                    _fieldsPrepared: function(fields) {
                        var that = this;
                        that._fields = fields;
                        each(fields, function(index, field) {
                            field.index = index;
                            if (!isDefined(field.caption))
                                field.caption = createCaption(field)
                        });
                        that.fireEvent("fieldsPrepared", [fields]);
                        that._descriptions = that._createDescriptions()
                    },
                    isLoading: function() {
                        return this._loadingCount > 0
                    },
                    state: function(state) {
                        var that = this;
                        if (state) {
                            state = $.extend({}, state);
                            if (!that._descriptions) {
                                that._changeLoadingCount(1);
                                $.when(getFields(that)).done(function(fields) {
                                    that._fields = setFieldsState(state.fields, fields);
                                    that._fieldsPrepared(fields);
                                    that.load(state)
                                }).always(function() {
                                    that._changeLoadingCount(-1)
                                })
                            }
                            else {
                                that._fields = setFieldsState(state.fields, that._fields);
                                that.load(state)
                            }
                        }
                        else
                            return {
                                    fields: getFieldsState(that._fields),
                                    columnExpandedPaths: getExpandedPaths(that._loadedData, that._descriptions, "columns"),
                                    rowExpandedPaths: getExpandedPaths(that._loadedData, that._descriptions, "rows")
                                }
                    },
                    _changeLoadingCount: function(increment) {
                        var oldLoading = this.isLoading(),
                            newLoading;
                        this._loadingCount += increment;
                        newLoading = this.isLoading();
                        if (oldLoading ^ newLoading)
                            this.fireEvent("loadingChanged", [newLoading])
                    },
                    _loadCore: function(options, deferred) {
                        var that = this,
                            store = this._store,
                            descriptions = this._descriptions,
                            headerName = DESCRIPTION_NAME_BY_AREA[options.area];
                        options = options || {};
                        if (store) {
                            $.extend(options, descriptions);
                            options.columnExpandedPaths = options.columnExpandedPaths || getExpandedPaths(this._loadedData, options, "columns");
                            options.rowExpandedPaths = options.rowExpandedPaths || getExpandedPaths(this._loadedData, options, "rows");
                            if (headerName)
                                options.headerName = headerName;
                            $.when(store.load(options)).done(function(data) {
                                if (options.path)
                                    that.applyPartialDataSource(options.area, options.path, data, deferred);
                                else {
                                    $.extend(that._loadedData, data);
                                    that._update(deferred)
                                }
                                deferred.resolve(that._data)
                            }).fail(deferred.reject)
                        }
                        else {
                            that._update(deferred);
                            deferred.resolve(that._data)
                        }
                    },
                    _sort: function(descriptions, data, getAscOrder) {
                        var store = this._store;
                        if (store)
                            sort(descriptions, data, getAscOrder)
                    },
                    _update: function(deferred) {
                        var that = this,
                            descriptions = that._descriptions,
                            loadedData = that._loadedData,
                            expressionsUsed = areExpressionsUsed(descriptions);
                        formatHeaders(descriptions, loadedData);
                        updateCache(loadedData.rows);
                        updateCache(loadedData.columns);
                        if (expressionsUsed) {
                            that._sort(descriptions, loadedData, expressionsUsed);
                            pivotGrid.applyDisplaySummaryMode(descriptions, loadedData)
                        }
                        that._sort(descriptions, loadedData);
                        that._data = loadedData;
                        $.when(deferred).done(function() {
                            that.fireEvent("changed");
                            if (commonUtils.isDefined(that._data.grandTotalRowIndex))
                                loadedData.grandTotalRowIndex = that._data.grandTotalRowIndex;
                            if (commonUtils.isDefined(that._data.grandTotalColumnIndex))
                                loadedData.grandTotalColumnIndex = that._data.grandTotalColumnIndex
                        })
                    },
                    store: function() {
                        return this._store
                    },
                    collapseHeaderItem: function(area, path) {
                        var that = this,
                            headerItems = area === 'column' ? that._loadedData.columns : that._loadedData.rows,
                            headerItem = findHeaderItem(headerItems, path),
                            field = that.getAreaFields(area)[path.length - 1];
                        if (headerItem && headerItem.children) {
                            that.fireEvent("expandValueChanging", [{
                                    area: area,
                                    path: path,
                                    expanded: false
                                }]);
                            if (field)
                                field.expanded = false;
                            headerItem.collapsedChildren = headerItem.children;
                            delete headerItem.children;
                            that._update();
                            return true
                        }
                        return false
                    },
                    collapseAll: function(id) {
                        var dataChanged = false,
                            field = this.field(id) || {},
                            areaOffset = $.inArray(field, this.getAreaFields(field.area));
                        field.expanded = false;
                        foreachTree(this._loadedData[field.area + "s"], function(items) {
                            var item = items[0],
                                path = createPath(items);
                            if (item && item.children && areaOffset === path.length - 1) {
                                item.collapsedChildren = item.children;
                                delete item.children;
                                dataChanged = true
                            }
                        }, true);
                        dataChanged && this._update()
                    },
                    expandAll: function(id) {
                        var field = this.field(id);
                        if (field && field.area) {
                            field.expanded = true;
                            this.load()
                        }
                    },
                    expandHeaderItem: function(area, path) {
                        var that = this,
                            hasCache,
                            headerItems = area === 'column' ? that._loadedData.columns : that._loadedData.rows,
                            headerItem = findHeaderItem(headerItems, path),
                            options;
                        if (headerItem && !headerItem.children) {
                            hasCache = !!headerItem.collapsedChildren;
                            options = {
                                area: area,
                                path: path,
                                expanded: true,
                                needExpandData: !hasCache
                            };
                            that.fireEvent("expandValueChanging", [options]);
                            if (hasCache) {
                                headerItem.children = headerItem.collapsedChildren;
                                delete headerItem.collapsedChildren;
                                that._update()
                            }
                            else
                                that.load(options);
                            return hasCache
                        }
                        return false
                    },
                    applyPartialDataSource: function(area, path, dataSource, deferred) {
                        var that = this,
                            loadedData = that._loadedData,
                            headerItems = area === 'column' ? loadedData.columns : loadedData.rows,
                            headerItem,
                            newRowItemIndexesToCurrent,
                            newColumnItemIndexesToCurrent;
                        if (dataSource && dataSource.values) {
                            dataSource.rows = dataSource.rows || [];
                            dataSource.columns = dataSource.columns || [];
                            headerItem = findHeaderItem(headerItems, path);
                            if (headerItem) {
                                if (area === 'column') {
                                    newColumnItemIndexesToCurrent = updateHeaderItemChildren(headerItems, headerItem, dataSource.columns, loadedData.grandTotalColumnIndex);
                                    newRowItemIndexesToCurrent = updateHeaderItems(loadedData.rows, dataSource.rows)
                                }
                                else {
                                    newRowItemIndexesToCurrent = updateHeaderItemChildren(headerItems, headerItem, dataSource.rows, loadedData.grandTotalRowIndex);
                                    newColumnItemIndexesToCurrent = updateHeaderItems(loadedData.columns, dataSource.columns)
                                }
                                updateDataSourceCells(loadedData, dataSource.values, newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent);
                                that._update(deferred)
                            }
                        }
                    },
                    dispose: function() {
                        var that = this,
                            delayedLoadTask = that._delayedLoadTask;
                        this._disposeEvents();
                        if (delayedLoadTask)
                            delayedLoadTask.abort();
                        this._isDisposed = true
                    },
                    isDisposed: function() {
                        return !!this._isDisposed
                    }
                }
        }()).include(EventsMixin);
        pivotGrid.foreachTree = foreachTree;
        pivotGrid.createPath = createPath;
        pivotGrid.foreachDataLevel = foreachDataLevel;
        pivotGrid.getCompareFunction = getCompareFunction;
        pivotGrid.findField = findField;
        pivotGrid.formatValue = formatValue
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.dataController.js */
    (function($, DX) {
        var pivotGrid = DX.ui.dxPivotGrid,
            stringUtils = DX.require("/utils/utils.string"),
            commonUtils = DX.require("/utils/utils.common"),
            Class = DevExpress.require("/class"),
            createPath = pivotGrid.createPath,
            foreachTree = pivotGrid.foreachTree,
            formatValue = pivotGrid.formatValue,
            math = Math,
            dxDataGrid = DX.ui.dxDataGrid,
            GRAND_TOTAL_TYPE = "GT",
            TOTAL_TYPE = "T",
            DATA_TYPE = "D";
        pivotGrid.proxyMethod = function(instance, methodName, defaultResult) {
            if (!instance[methodName])
                instance[methodName] = function() {
                    var dataSource = this._dataSource;
                    return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult
                }
        };
        pivotGrid.DataController = Class.inherit(function() {
            function getHeaderItemText(item, description, options) {
                var text = item.text;
                if (commonUtils.isDefined(item.displayText))
                    text = item.displayText;
                else if (commonUtils.isDefined(item.caption))
                    text = item.caption;
                else if (item.type === GRAND_TOTAL_TYPE)
                    text = options.texts.grandTotal;
                if (item.isAdditionalTotal)
                    text = stringUtils.format(options.texts.total || '', text);
                return text
            }
            var createHeaderInfo = function() {
                    var getHeaderItemsDepth = function(headerItems) {
                            var depth = 0;
                            foreachTree(headerItems, function(items) {
                                depth = math.max(depth, items.length)
                            });
                            return depth
                        };
                    var createInfoItem = function(headerItem, breadth, isHorizontal) {
                            var infoItem = {
                                    type: headerItem.type,
                                    text: headerItem.text
                                };
                            if (headerItem.path)
                                infoItem.path = headerItem.path;
                            if (headerItem.width)
                                infoItem.width = headerItem.width;
                            if (headerItem.isLast)
                                infoItem.isLast = true;
                            if (headerItem.sorted)
                                infoItem.sorted = true;
                            if (headerItem.isMetric)
                                infoItem.dataIndex = headerItem.dataIndex;
                            if (commonUtils.isDefined(headerItem.expanded))
                                infoItem.expanded = headerItem.expanded;
                            if (breadth > 1)
                                infoItem[isHorizontal ? 'colspan' : 'rowspan'] = breadth;
                            if (headerItem.depthSize && headerItem.depthSize > 1)
                                infoItem[isHorizontal ? 'rowspan' : 'colspan'] = headerItem.depthSize;
                            if (headerItem.index >= 0)
                                infoItem.dataSourceIndex = headerItem.index;
                            return infoItem
                        };
                    var addInfoItem = function(info, options) {
                            var itemInfo,
                                breadth = options.lastIndex - options.index || 1,
                                addInfoItemCore = function(info, infoItem, itemIndex, depthIndex, isHorizontal) {
                                    var index = isHorizontal ? depthIndex : itemIndex;
                                    while (!info[index])
                                        info.push([]);
                                    if (isHorizontal)
                                        info[index].push(infoItem);
                                    else
                                        info[index].unshift(infoItem)
                                };
                            itemInfo = createInfoItem(options.headerItem, breadth, options.isHorizontal);
                            addInfoItemCore(info, itemInfo, options.index, options.depth, options.isHorizontal);
                            if (!options.headerItem.children || options.headerItem.children.length === 0)
                                return options.lastIndex + 1;
                            return options.lastIndex
                        };
                    var isItemSorted = function(items, sortBySummaryPath) {
                            var path,
                                item = items[0],
                                stringValuesUsed = commonUtils.isString(sortBySummaryPath[0]),
                                headerItem = item.dataIndex >= 0 ? items[1] : item;
                            if (stringValuesUsed && sortBySummaryPath[0].indexOf("&[") !== -1 && headerItem.key || !headerItem.key)
                                path = createPath(items);
                            else
                                path = $.map(items, function(item) {
                                    return item.dataIndex >= 0 ? item.value : item.text
                                }).reverse();
                            if (item.type === GRAND_TOTAL_TYPE)
                                path = path.slice(1);
                            return path.join("/") === sortBySummaryPath.join("/")
                        };
                    var getViewHeaderItems = function(headerItems, headerDescriptions, cellDescriptions, depthSize, options) {
                            var cellDescriptionsCount = cellDescriptions.length,
                                viewHeaderItems = options.showData ? createViewHeaderItems(headerItems, headerDescriptions) : [];
                            if (options.showGrandTotals !== false)
                                viewHeaderItems[!options.showTotalsPrior ? "push" : "unshift"]({
                                    type: GRAND_TOTAL_TYPE,
                                    isEmpty: options.isEmptyGrandTotal
                                });
                            if (options.showTotals !== false)
                                addAdditionalTotalHeaderItems(viewHeaderItems, headerDescriptions, options.showTotalsPrior);
                            foreachTree(viewHeaderItems, function(items) {
                                var item = items[0];
                                if (!item.children || item.children.length === 0)
                                    item.depthSize = depthSize - items.length + 1
                            });
                            if (cellDescriptionsCount > 1)
                                addMetricHeaderItems(viewHeaderItems, cellDescriptions, options.hiddenGrandTotals, options.hiddenTotals);
                            !options.showEmpty && removeHiddenItems(viewHeaderItems);
                            var columnIndex = 0;
                            foreachTree(viewHeaderItems, function(items) {
                                var item = items[0],
                                    field = headerDescriptions[items.length - 1] || {};
                                if (item.type === DATA_TYPE)
                                    item.width = field.width;
                                item.isLast = !item.children || !item.children.length;
                                if (item.isLast) {
                                    $.each(options.sortBySummaryPaths, function(index, sortBySummaryPath) {
                                        if (!commonUtils.isDefined(item.dataIndex)) {
                                            sortBySummaryPath = sortBySummaryPath.slice(0);
                                            sortBySummaryPath.pop()
                                        }
                                        if (isItemSorted(items, sortBySummaryPath)) {
                                            item.sorted = true;
                                            return false
                                        }
                                    });
                                    columnIndex++
                                }
                                item.text = getHeaderItemText(item, field, options)
                            });
                            if (!viewHeaderItems.length)
                                viewHeaderItems.push({});
                            return viewHeaderItems
                        };
                    function createHeaderItem(childrenStack, depth, index) {
                        var parent = childrenStack[depth] = childrenStack[depth] || [],
                            node = parent[index] = {};
                        if (childrenStack[depth + 1]) {
                            node.children = childrenStack[depth + 1];
                            childrenStack.length = depth + 1
                        }
                        return node
                    }
                    function createViewHeaderItems(headerItems, headerDescriptions) {
                        var headerDescriptionsCount = headerDescriptions && headerDescriptions.length || 0,
                            childrenStack = [],
                            headerItem;
                        foreachTree(headerItems, function(items, index) {
                            var item = items[0],
                                path = createPath(items);
                            headerItem = createHeaderItem(childrenStack, path.length, index);
                            headerItem.type = DATA_TYPE;
                            headerItem.value = item.value;
                            headerItem.path = path;
                            headerItem.text = item.text;
                            headerItem.index = item.index;
                            headerItem.displayText = item.displayText;
                            headerItem.key = item.key;
                            headerItem.isEmpty = item.isEmpty;
                            if (path.length < headerDescriptionsCount && (!item.children || item.children.length !== 0))
                                headerItem.expanded = !!item.children
                        });
                        return createHeaderItem(childrenStack, 0, 0).children || []
                    }
                    var addMetricHeaderItems = function(headerItems, cellDescriptions, hiddenGrandTotals, hiddenTotals) {
                            foreachTree(headerItems, function(items) {
                                var item = items[0],
                                    i;
                                if (!item.children || item.children.length === 0) {
                                    item.children = [];
                                    for (i = 0; i < cellDescriptions.length; i++) {
                                        if (cellDescriptions.length)
                                            if (item.type === GRAND_TOTAL_TYPE && $.inArray(i, hiddenGrandTotals) !== -1 || item.type !== GRAND_TOTAL_TYPE && $.inArray(i, hiddenTotals) !== -1)
                                                continue;
                                        item.children.push({
                                            caption: cellDescriptions[i].caption,
                                            path: item.path,
                                            type: item.type,
                                            value: i,
                                            index: item.index,
                                            dataIndex: i,
                                            isMetric: true,
                                            isEmpty: item.isEmpty && item.isEmpty[i]
                                        })
                                    }
                                }
                            })
                        };
                    var addAdditionalTotalHeaderItems = function(headerItems, headerDescriptions, showTotalsPrior) {
                            foreachTree(headerItems, function(items, index) {
                                var item = items[0],
                                    parentChildren = (items[1] ? items[1].children : headerItems) || [],
                                    dataField = headerDescriptions[items.length - 1];
                                if (item.type === DATA_TYPE && item.expanded && dataField.showTotals !== false) {
                                    index !== -1 && parentChildren.splice(showTotalsPrior ? index : index + 1, 0, $.extend({}, item, {
                                        children: null,
                                        type: TOTAL_TYPE,
                                        expanded: showTotalsPrior ? true : null,
                                        isAdditionalTotal: true
                                    }));
                                    if (showTotalsPrior)
                                        item.expanded = null
                                }
                            })
                        };
                    var removeEmptyParent = function(items, index) {
                            var parent = items[index + 1];
                            if (!items[index].children.length && parent && parent.children) {
                                parent.children.splice($.inArray(items[index], parent.children), 1);
                                removeEmptyParent(items, index + 1)
                            }
                        };
                    var removeHiddenItems = function(headerItems) {
                            foreachTree([{children: headerItems}], function(items, index) {
                                var item = items[0],
                                    parentChildren = (items[1] ? items[1].children : headerItems) || [];
                                if (item && !item.children && (item.isEmpty && item.isEmpty.length ? item.isEmpty[0] : item.isEmpty)) {
                                    parentChildren.splice(index, 1);
                                    removeEmptyParent(items, 1)
                                }
                            })
                        };
                    var fillHeaderInfo = function(info, viewHeaderItems, depthSize, isHorizontal) {
                            var lastIndex = 0,
                                index,
                                depth,
                                indexesByDepth = [0];
                            foreachTree(viewHeaderItems, function(items) {
                                var headerItem = items[0];
                                depth = headerItem.isMetric ? depthSize : items.length - 1;
                                while (indexesByDepth.length - 1 < depth)
                                    indexesByDepth.push(indexesByDepth[indexesByDepth.length - 1]);
                                index = indexesByDepth[depth] || 0;
                                lastIndex = addInfoItem(info, {
                                    headerItem: headerItem,
                                    index: index,
                                    lastIndex: lastIndex,
                                    depth: depth,
                                    isHorizontal: isHorizontal
                                });
                                indexesByDepth.length = depth;
                                indexesByDepth.push(lastIndex)
                            })
                        };
                    return function(headerItems, headerDescriptions, cellDescriptions, isHorizontal, options) {
                            var info = [],
                                viewHeaderItems,
                                depthSize = getHeaderItemsDepth(headerItems) || 1;
                            viewHeaderItems = getViewHeaderItems(headerItems, headerDescriptions, cellDescriptions, depthSize, options);
                            fillHeaderInfo(info, viewHeaderItems, depthSize, isHorizontal);
                            return info
                        }
                }();
            function createSortPaths(headerFields, dataFields) {
                var sortBySummaryPaths = [];
                $.each(headerFields, function(index, headerField) {
                    var fieldIndex = pivotGrid.findField(dataFields, headerField.sortBySummaryField);
                    if (fieldIndex >= 0)
                        sortBySummaryPaths.push((headerField.sortBySummaryPath || []).concat([fieldIndex]))
                });
                return sortBySummaryPaths
            }
            function foreachRowInfo(rowsInfo, callback) {
                var columnOffset = 0,
                    columnOffsetResetIndexes = [];
                for (var i = 0; i < rowsInfo.length; i++)
                    for (var j = 0; j < rowsInfo[i].length; j++) {
                        var rowSpanOffset = rowsInfo[i][j].rowspan > 1 ? rowsInfo[i][j].rowspan : 0,
                            visibleIndex = i + rowSpanOffset;
                        if (columnOffsetResetIndexes[i]) {
                            columnOffset -= columnOffsetResetIndexes[i];
                            columnOffsetResetIndexes[i] = 0
                        }
                        if (callback(rowsInfo[i][j], visibleIndex, i, j, columnOffset) === false)
                            break;
                        columnOffsetResetIndexes[i + (rowsInfo[i][j].rowspan || 1)] = columnOffsetResetIndexes[i + (rowsInfo[i][j].rowspan || 1)] || 0;
                        columnOffsetResetIndexes[i + (rowsInfo[i][j].rowspan || 1)]++;
                        columnOffset++
                    }
            }
            function foreachColumnInfo(info, callback) {
                var offsets = [];
                function getOffset(offsets, rowIndex, index) {
                    var sum = 0;
                    $.each(offsets[rowIndex], function(i, value) {
                        value = value || 0;
                        if (i <= index) {
                            sum += value;
                            index += value
                        }
                        else
                            return false
                    });
                    return sum
                }
                for (var rowIndex = 0; rowIndex < info.length; rowIndex++) {
                    var row = info[rowIndex],
                        colSpanOffset = 0;
                    offsets[rowIndex] = offsets[rowIndex] || [];
                    for (var colIndex = 0; colIndex < row.length; colIndex++) {
                        var cell = row[colIndex],
                            visibleIndex = colIndex + colSpanOffset;
                        visibleIndex += getOffset(offsets, rowIndex, visibleIndex);
                        if (cell.rowspan)
                            for (var i = rowIndex + 1; i < rowIndex + cell.rowspan; i++) {
                                offsets[i] = offsets[i] || [];
                                offsets[i][visibleIndex] = cell.colspan || 1
                            }
                        colSpanOffset += (cell.colspan || 1) - 1;
                        if (callback(cell, visibleIndex, rowIndex, colIndex) === false)
                            break
                    }
                }
            }
            function createCellsInfo(rowsInfo, columnsInfo, data, dataFields) {
                var info = [],
                    dataSourceCells = data.values;
                dataSourceCells.length && foreachRowInfo(rowsInfo, function(rowInfo, rowIndex) {
                    var row = info[rowIndex] = [],
                        dataRow = dataSourceCells[rowInfo.dataSourceIndex >= 0 ? rowInfo.dataSourceIndex : data.grandTotalRowIndex] || [];
                    rowInfo.isLast && foreachColumnInfo(columnsInfo, function(columnInfo, columnIndex) {
                        var dataIndex = columnInfo.dataIndex || 0,
                            dataField = dataFields[dataIndex];
                        if (columnInfo.isLast && dataField) {
                            var cell = dataRow[columnInfo.dataSourceIndex >= 0 ? columnInfo.dataSourceIndex : data.grandTotalColumnIndex],
                                cellValue;
                            if (!$.isArray(cell))
                                cell = [cell];
                            cellValue = cell[dataIndex];
                            row[columnIndex] = {
                                text: formatValue(cellValue, dataField),
                                value: cellValue,
                                format: dataField.format,
                                precision: dataField.precision,
                                dataType: dataField.dataType,
                                columnType: columnInfo.type,
                                rowType: rowInfo.type,
                                rowPath: rowInfo.path || [],
                                columnPath: columnInfo.path || [],
                                dataIndex: dataIndex
                            };
                            if (dataField.width)
                                row[columnIndex].width = dataField.width
                        }
                    })
                });
                return info
            }
            function getHeaderIndexedItems(headerItems, maxDepth, options) {
                var visibleIndex = 0,
                    indexedItems = [];
                foreachTree(headerItems, function(items) {
                    var headerItem = items[0],
                        path = createPath(items);
                    if (headerItem.children && options.showTotals === false)
                        return;
                    var indexedItem = $.extend(true, {}, headerItem, {
                            visibleIndex: visibleIndex++,
                            path: path
                        });
                    if (commonUtils.isDefined(indexedItem.index))
                        indexedItems[indexedItem.index] = indexedItem;
                    else
                        indexedItems.push(indexedItem)
                });
                return indexedItems
            }
            function createScollController(dataController, component, dataAdapter) {
                if (component && component.option("scrolling.mode") === "virtual")
                    return new dxDataGrid.VirtualScrollController(component, $.extend({
                            hasKnownLastPage: function() {
                                return true
                            },
                            pageCount: function() {
                                return math.ceil(this.totalItemsCount() / this.pageSize())
                            },
                            updateLoading: function(){},
                            itemsCount: function() {
                                if (this.pageIndex() < this.pageCount() - 1)
                                    return this.pageSize();
                                else
                                    this.totalItemsCount() % this.pageSize()
                            },
                            items: function() {
                                return []
                            },
                            viewportItems: function(items) {
                                return []
                            },
                            onChanged: function(e){},
                            isLoading: function() {
                                return dataController.isLoading()
                            }
                        }, dataAdapter))
            }
            function getHiddenTotals(dataFields) {
                var result = [];
                $.each(dataFields, function(index, field) {
                    if (field.showTotals === false)
                        result.push(index)
                });
                return result
            }
            function getHiddenGrandTotalsTotals(dataFields) {
                var result = [];
                $.each(dataFields, function(index, field) {
                    if (field.showGrandTotals === false)
                        result.push(index)
                });
                return result
            }
            var members = {
                    ctor: function(options) {
                        var that = this;
                        options = that._options = options || {};
                        that._dataSource = that._createDataSource(options);
                        that._rowsScrollController = createScollController(that, options.component, {
                            totalItemsCount: function() {
                                return that.totalRowCount()
                            },
                            pageIndex: function(index) {
                                return that.rowPageIndex(index)
                            },
                            pageSize: function() {
                                return that.rowPageSize()
                            },
                            load: function() {
                                if (that._rowsScrollController.pageIndex() >= this.pageCount())
                                    that._rowsScrollController.pageIndex(this.pageCount() - 1);
                                return that._rowsScrollController.handleDataChanged(function() {
                                        that.changed && that.changed.fire()
                                    })
                            }
                        });
                        that._columnsScrollController = createScollController(that, options.component, {
                            totalItemsCount: function() {
                                return that.totalColumnCount()
                            },
                            pageIndex: function(index) {
                                return that.columnPageIndex(index)
                            },
                            pageSize: function() {
                                return that.columnPageSize()
                            },
                            load: function() {
                                if (that._columnsScrollController.pageIndex() >= this.pageCount())
                                    that._columnsScrollController.pageIndex(this.pageCount() - 1);
                                return that._columnsScrollController.handleDataChanged(function() {
                                        that.changed && that.changed.fire()
                                    })
                            }
                        });
                        that._stateStoringController = new dxDataGrid.StateStoringController(options.component).init();
                        that._columnsInfo = [];
                        that._rowsInfo = [];
                        that._cellsInfo = [];
                        that.expandValueChanging = $.Callbacks();
                        that.loadingChanged = $.Callbacks();
                        that.scrollChanged = $.Callbacks();
                        that.load();
                        that._update();
                        that.changed = $.Callbacks()
                    },
                    load: function() {
                        var that = this,
                            stateStoringController = this._stateStoringController;
                        if (stateStoringController.isEnabled() && !stateStoringController.isLoaded())
                            stateStoringController.load().always(function(state) {
                                if (state)
                                    that._dataSource.state(state);
                                else
                                    that._dataSource.load()
                            });
                        else
                            that._dataSource.load()
                    },
                    calculateVirtualContentParams: function(contentParams) {
                        var that = this,
                            rowsScrollController = that._rowsScrollController,
                            columnsScrollController = that._columnsScrollController,
                            rowViewportItemSize = contentParams.contentHeight / contentParams.rowCount,
                            columnViewportItemSize = contentParams.contentWidth / contentParams.columnCount,
                            oldColumnViewportItemSize,
                            oldRowViewportItemSize,
                            newLeftPosition,
                            newTopPosition;
                        if (rowsScrollController && columnsScrollController) {
                            oldColumnViewportItemSize = columnsScrollController.viewportItemSize();
                            oldRowViewportItemSize = rowsScrollController.viewportItemSize();
                            rowsScrollController.viewportItemSize(rowViewportItemSize);
                            columnsScrollController.viewportItemSize(columnViewportItemSize);
                            rowsScrollController.viewportSize(contentParams.viewportHeight / rowsScrollController.viewportItemSize());
                            rowsScrollController.setContentSize(contentParams.contentHeight);
                            columnsScrollController.viewportSize(contentParams.viewportWidth / columnsScrollController.viewportItemSize());
                            columnsScrollController.setContentSize(contentParams.contentWidth);
                            columnsScrollController.loadIfNeed();
                            rowsScrollController.loadIfNeed();
                            newLeftPosition = columnsScrollController.getViewportPosition() * columnViewportItemSize / oldColumnViewportItemSize;
                            newTopPosition = rowsScrollController.getViewportPosition() * rowViewportItemSize / oldRowViewportItemSize;
                            that.setViewportPosition(newLeftPosition, newTopPosition);
                            that.scrollChanged.fire({
                                left: newLeftPosition,
                                top: newTopPosition
                            });
                            return {
                                    contentTop: rowsScrollController.getContentOffset(),
                                    contentLeft: columnsScrollController.getContentOffset(),
                                    width: columnsScrollController.getVirtualContentSize(),
                                    height: rowsScrollController.getVirtualContentSize()
                                }
                        }
                    },
                    setViewportPosition: function(left, top) {
                        this._rowsScrollController.setViewportPosition(top || 0);
                        this._columnsScrollController.setViewportPosition(left || 0)
                    },
                    updateViewOptions: function(options) {
                        $.extend(this._options, options);
                        this._update()
                    },
                    _handleChanged: function() {
                        this._update()
                    },
                    _handleExpandValueChanging: function(e) {
                        this.expandValueChanging.fire(e)
                    },
                    _handleLoadingChanged: function(e) {
                        this.loadingChanged.fire(e)
                    },
                    _handleFieldsPrepared: function(e) {
                        this._options.onFieldsPrepared && this._options.onFieldsPrepared(e)
                    },
                    _createDataSource: function(options) {
                        var that = this,
                            dataSourceOptions = options.dataSource,
                            dataSource;
                        that._isSharedDataSource = dataSourceOptions instanceof pivotGrid.DataSource;
                        if (that._isSharedDataSource)
                            dataSource = dataSourceOptions;
                        else
                            dataSource = new pivotGrid.DataSource(dataSourceOptions);
                        that._changedHandler = $.proxy(that, "_handleChanged");
                        that._expandValueChangingHandler = $.proxy(that, "_handleExpandValueChanging");
                        that._loadingChangedHandler = $.proxy(that, "_handleLoadingChanged");
                        that._fieldsPreparedHandler = $.proxy(that, "_handleFieldsPrepared");
                        dataSource.on("changed", that._changedHandler);
                        dataSource.on("expandValueChanging", that._expandValueChangingHandler);
                        dataSource.on("loadingChanged", that._loadingChangedHandler);
                        dataSource.on("fieldsPrepared", that._fieldsPreparedHandler);
                        return dataSource
                    },
                    getDataSource: function() {
                        return this._dataSource
                    },
                    isLoading: function() {
                        return this._dataSource.isLoading()
                    },
                    isEmpty: function() {
                        var dataFields = this._dataSource.getAreaFields("data"),
                            data = this._dataSource.getData();
                        return !dataFields.length || !data.values.length
                    },
                    _update: function() {
                        var that = this,
                            dataSource = that._dataSource,
                            options = that._options,
                            columnFields = dataSource.getAreaFields("column"),
                            rowFields = dataSource.getAreaFields("row"),
                            dataFields = dataSource.getAreaFields("data"),
                            data = dataSource.getData(),
                            rowOptions = {
                                isEmptyGrandTotal: data.isEmptyGrandTotalRow,
                                texts: options.texts || {},
                                hiddenTotals: getHiddenTotals(dataFields),
                                hiddenGrandTotals: [],
                                showTotals: options.showRowTotals,
                                showData: dataFields.length > 0 ? getHiddenTotals(dataFields).length !== dataFields.length : true,
                                showGrandTotals: options.showRowGrandTotals !== false && (dataFields.length > 0 ? getHiddenGrandTotalsTotals(dataFields).length !== dataFields.length : true),
                                sortBySummaryPaths: createSortPaths(columnFields, dataFields),
                                showTotalsPrior: options.showTotalsPrior === "rows" || options.showTotalsPrior === "both",
                                showEmpty: !options.hideEmptySummaryCells,
                                fields: rowFields
                            },
                            columnOptions = {
                                isEmptyGrandTotal: data.isEmptyGrandTotalColumn,
                                texts: options.texts || {},
                                hiddenTotals: getHiddenTotals(dataFields),
                                showData: dataFields.length > 0 ? getHiddenTotals(dataFields).length !== dataFields.length : true,
                                hiddenGrandTotals: getHiddenGrandTotalsTotals(dataFields),
                                showTotals: options.showColumnTotals,
                                showTotalsPrior: options.showTotalsPrior === "columns" || options.showTotalsPrior === "both",
                                showGrandTotals: options.showColumnGrandTotals !== false && (dataFields.length > 0 ? getHiddenGrandTotalsTotals(dataFields).length !== dataFields.length : true),
                                sortBySummaryPaths: createSortPaths(rowFields, dataFields),
                                showEmpty: !options.hideEmptySummaryCells,
                                fields: columnFields
                            };
                        if (!commonUtils.isDefined(data.grandTotalRowIndex))
                            data.grandTotalRowIndex = getHeaderIndexedItems(data.rows, rowFields.length - 1, rowOptions).length;
                        if (!commonUtils.isDefined(data.grandTotalColumnIndex))
                            data.grandTotalColumnIndex = getHeaderIndexedItems(data.columns, columnFields.length - 1, columnOptions).length;
                        that._columnsInfo = createHeaderInfo(data.columns, columnFields, dataFields, true, columnOptions);
                        that._rowsInfo = createHeaderInfo(data.rows, rowFields, [], false, rowOptions);
                        if (that._rowsScrollController && that._columnsScrollController && that.changed) {
                            that._rowsScrollController.reset();
                            that._columnsScrollController.reset();
                            that._rowsScrollController.load();
                            that._columnsScrollController.load()
                        }
                        else
                            that.changed && that.changed.fire();
                        if (that._stateStoringController.isEnabled() && !that._dataSource.isLoading()) {
                            that._stateStoringController.state(that._dataSource.state());
                            that._stateStoringController.save()
                        }
                    },
                    getRowsInfo: function(getAllData) {
                        var that = this,
                            rowsInfo = that._rowsInfo,
                            scrollController = that._rowsScrollController,
                            rowspan,
                            i;
                        if (scrollController && !getAllData) {
                            var startIndex = scrollController.beginPageIndex() * that.rowPageSize(),
                                endIndex = scrollController.endPageIndex() * that.rowPageSize() + that.rowPageSize(),
                                newRowsInfo = [],
                                maxDepth = 1;
                            foreachRowInfo(rowsInfo, function(rowInfo, visibleIndex, rowIndex, _, columnIndex) {
                                var isVisible = visibleIndex >= startIndex && rowIndex < endIndex,
                                    index = rowIndex < startIndex ? 0 : rowIndex - startIndex,
                                    cell = rowInfo;
                                if (isVisible) {
                                    newRowsInfo[index] = newRowsInfo[index] || [];
                                    rowspan = rowIndex < startIndex ? rowInfo.rowspan - (startIndex - rowIndex) || 1 : rowInfo.rowspan;
                                    if (startIndex + index + rowspan > endIndex)
                                        rowspan = endIndex - (index + startIndex) || 1;
                                    if (rowspan !== rowInfo.rowspan)
                                        cell = $.extend({}, cell, {rowspan: rowspan});
                                    newRowsInfo[index].push(cell);
                                    maxDepth = math.max(maxDepth, columnIndex + 1)
                                }
                                else if (i > endIndex)
                                    return false
                            });
                            foreachRowInfo(newRowsInfo, function(rowInfo, visibleIndex, rowIndex, columnIndex, realColumnIndex) {
                                var colspan = rowInfo.colspan || 1;
                                if (realColumnIndex + colspan > maxDepth)
                                    newRowsInfo[rowIndex][columnIndex] = $.extend({}, rowInfo, {colspan: maxDepth - realColumnIndex || 1})
                            });
                            return newRowsInfo
                        }
                        return rowsInfo
                    },
                    getColumnsInfo: function(getAllData) {
                        var that = this,
                            info = that._columnsInfo,
                            scrollController = that._columnsScrollController;
                        if (scrollController && !getAllData) {
                            var startIndex = scrollController.beginPageIndex() * that.columnPageSize(),
                                endIndex = scrollController.endPageIndex() * that.columnPageSize() + that.columnPageSize(),
                                newInfo = [];
                            foreachColumnInfo(info, function(columnInfo, visibleIndex, rowIndex) {
                                var cell = columnInfo,
                                    colspan,
                                    isVisible = visibleIndex + (cell.colspan - 1 || 0) >= startIndex && visibleIndex < endIndex;
                                newInfo[rowIndex] = newInfo[rowIndex] || [];
                                if (isVisible) {
                                    if (visibleIndex < startIndex) {
                                        colspan = cell.colspan - (startIndex - visibleIndex);
                                        visibleIndex = startIndex
                                    }
                                    else
                                        colspan = cell.colspan;
                                    if (visibleIndex + colspan > endIndex)
                                        colspan = endIndex - visibleIndex;
                                    if (colspan !== cell.colspan)
                                        cell = $.extend({}, cell, {colspan: colspan});
                                    newInfo[rowIndex].push(cell)
                                }
                                else if (visibleIndex > endIndex)
                                    return false
                            });
                            info = newInfo
                        }
                        return info
                    },
                    totalRowCount: function() {
                        return this._rowsInfo.length
                    },
                    rowPageIndex: function(index) {
                        if (index !== undefined)
                            this._rowPageIndex = index;
                        return this._rowPageIndex || 0
                    },
                    totalColumnCount: function() {
                        var count = 0;
                        if (this._columnsInfo && this._columnsInfo.length)
                            for (var i = 0; i < this._columnsInfo[0].length; i++)
                                count += this._columnsInfo[0][i].colspan || 1;
                        return count
                    },
                    rowPageSize: function(size) {
                        if (size !== undefined)
                            this._rowPageSize = size;
                        return this._rowPageSize || 20
                    },
                    columnPageSize: function(size) {
                        if (size !== undefined)
                            this._columnPageSize = size;
                        return this._columnPageSize || 20
                    },
                    columnPageIndex: function(index) {
                        if (index !== undefined)
                            this._columnPageIndex = index;
                        return this._columnPageIndex || 0
                    },
                    getCellsInfo: function(getAllData) {
                        var rowsInfo = this.getRowsInfo(getAllData),
                            columnsInfo = this.getColumnsInfo(getAllData),
                            data = this._dataSource.getData();
                        return createCellsInfo(rowsInfo, columnsInfo, data, this._dataSource.getAreaFields("data"))
                    },
                    dispose: function() {
                        var that = this;
                        if (that._isSharedDataSource) {
                            that._dataSource.off("changed", that._changedHandler);
                            that._dataSource.off("expandValueChanging", that._expandValueChangingHandler);
                            that._dataSource.off("loadingChanged", that._loadingChangedHandler)
                        }
                        else
                            that._dataSource.dispose();
                        that._columnsScrollController && that._columnsScrollController.dispose();
                        that._rowsScrollController && that._rowsScrollController.dispose();
                        that._stateStoringController.dispose();
                        that.expandValueChanging.empty();
                        that.changed.empty();
                        that.loadingChanged.empty();
                        that.scrollChanged.empty()
                    }
                };
            pivotGrid.proxyMethod(members, "applyPartialDataSource");
            pivotGrid.proxyMethod(members, "collapseHeaderItem");
            pivotGrid.proxyMethod(members, "expandHeaderItem");
            pivotGrid.proxyMethod(members, "getData");
            return members
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.store.xmla.js */
    (function($, DX) {
        var Class = DevExpress.require("/class"),
            errors = DX.require("/data/data.errors"),
            commonUtils = DX.require("/utils/utils.common");
        DX.data.XmlaStore = DX.ui.dxPivotGrid.XmlaStore = Class.inherit(function() {
            var discover = '<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"><Body><Discover xmlns="urn:schemas-microsoft-com:xml-analysis"><RequestType>{2}</RequestType><Restrictions><RestrictionList><CATALOG_NAME>{0}</CATALOG_NAME><CUBE_NAME>{1}</CUBE_NAME></RestrictionList></Restrictions><Properties><PropertyList><Catalog>{0}</Catalog></PropertyList></Properties></Discover></Body></Envelope>',
                execute = '<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"><Body><Execute xmlns="urn:schemas-microsoft-com:xml-analysis"><Command><Statement>{0}</Statement></Command><Properties><PropertyList><Catalog>{1}</Catalog><ShowHiddenCubes>True</ShowHiddenCubes><SspropInitAppName>Microsoft SQL Server Management Studio</SspropInitAppName><Timeout>3600</Timeout></PropertyList></Properties></Execute></Body></Envelope>',
                mdx = "SELECT {2} FROM {0} {1} CELL PROPERTIES VALUE, FORMAT_STRING, LANGUAGE, BACK_COLOR, FORE_COLOR, FONT_FLAGS",
                mdxFilterSelect = "(SELECT {0} FROM {1})",
                mdxWith = "{0} {1} as {2}",
                mdxSlice = "WHERE ({0})",
                mdxNonEmpty = "NonEmpty({0}, {1})",
                mdxAxis = "{0} DIMENSION PROPERTIES PARENT_UNIQUE_NAME,HIERARCHY_UNIQUE_NAME, MEMBER_VALUE ON {1}",
                mdxCrossJoin = "CrossJoin({0})",
                mdxSet = "{{0}}",
                stringFormat = DX.require("/utils/utils.string").format,
                each = $.each,
                MEASURE_DEMENSION_KEY = "DX_MEASURES",
                MD_DIMTYPE_MEASURE = "2";
            DX.ui.dxPivotGrid.sendRequest = function(options) {
                return $.ajax(options)
            };
            function execXMLA(requestOptions, data) {
                var deferred = $.Deferred(),
                    beforeSend = requestOptions.beforeSend,
                    ajaxSettings = {
                        url: requestOptions.url,
                        dataType: "text",
                        data: data,
                        headers: {'Content-Type': 'text/xml'},
                        xhrFields: {},
                        method: "POST"
                    };
                if (commonUtils.isFunction(beforeSend))
                    beforeSend(ajaxSettings);
                DX.ui.dxPivotGrid.sendRequest(ajaxSettings).fail(function() {
                    deferred.reject(arguments)
                }).done(function(text) {
                    var xml;
                    try {
                        xml = $.parseXML(text)
                    }
                    catch(e) {
                        deferred.reject({
                            statusText: e.message,
                            stack: e.stack,
                            responseText: text
                        })
                    }
                    deferred.resolve(xml)
                });
                return deferred
            }
            function mdxDescendants(level, levelMember, nextLevel) {
                levelMember = levelMember ? "." + levelMember : "";
                return "Descendants({" + level + levelMember + "}, " + nextLevel + ", SELF_AND_BEFORE)"
            }
            function getAllMember(dimention) {
                return (dimention.hierarchyName || dimention.dataField) + ".[All]"
            }
            function getAllMembers(field) {
                return field.dataField + ".allMembers"
            }
            function crossJoinElements(elements) {
                var elementsString = elements.join(",");
                return elements.length > 1 ? stringFormat(mdxCrossJoin, elementsString) : elementsString
            }
            function generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName) {
                var crossJoinArgs = [],
                    dimensions = options[axisName],
                    dataField,
                    allMember,
                    fields = [],
                    hierarchyName,
                    arg,
                    prevDimension,
                    prevHierarchyName,
                    isLastDimesionInGroup,
                    isFirstDimesionInGroup,
                    expandAllIndex,
                    field,
                    member,
                    i;
                for (i = expandIndex; i <= expandLevel; i++) {
                    field = dimensions[i];
                    dataField = field.dataField;
                    prevHierarchyName = dimensions[i - 1] && dimensions[i - 1].hierarchyName;
                    hierarchyName = field.hierarchyName;
                    isLastDimesionInGroup = !hierarchyName || !dimensions[i + 1] || dimensions[i + 1].hierarchyName !== hierarchyName;
                    expandAllIndex = path.length + expandAllCount + expandIndex;
                    arg = null;
                    fields.push(field);
                    if (i < path.length) {
                        if (isLastDimesionInGroup)
                            arg = "(" + dataField + "." + preparePathValue(path[i]) + ")"
                    }
                    else if (i <= expandAllIndex)
                        if (i === 0 && expandAllCount === 0) {
                            allMember = getAllMember(dimensions[expandIndex]);
                            if (!hierarchyName)
                                arg = getAllMembers(dimensions[expandIndex]);
                            else
                                arg = allMember + "," + dimensions[expandIndex].dataField
                        }
                        else if (hierarchyName) {
                            member = preparePathValue(slicePath[slicePath.length - 1]);
                            if (isLastDimesionInGroup || i === expandAllIndex)
                                if (prevHierarchyName === hierarchyName) {
                                    if (slicePath.length)
                                        prevDimension = dimensions[slicePath.length - 1];
                                    if (!prevDimension || prevDimension.hierarchyName !== hierarchyName) {
                                        prevDimension = dimensions[i - 1];
                                        member = ""
                                    }
                                    arg = mdxDescendants(prevDimension.dataField, member, dataField)
                                }
                                else
                                    arg = getAllMembers(field)
                        }
                        else
                            arg = getAllMembers(field);
                    else {
                        isFirstDimesionInGroup = !hierarchyName || prevHierarchyName !== hierarchyName;
                        if (isFirstDimesionInGroup)
                            arg = "(" + getAllMember(field) + ")"
                    }
                    if (arg) {
                        arg = stringFormat(mdxSet, arg);
                        crossJoinArgs.push(arg)
                    }
                }
                return crossJoinElements(crossJoinArgs)
            }
            function fillCrossJoins(crossJoins, path, expandLevel, expandIndex, slicePath, options, axisName) {
                var expandAllCount = -1,
                    dimensions = options[axisName],
                    dimestionIndex;
                do {
                    expandAllCount++;
                    dimestionIndex = path.length + expandAllCount + expandIndex;
                    crossJoins.push(generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName))
                } while (dimensions[dimestionIndex] && dimensions[dimestionIndex + 1] && dimensions[dimestionIndex].expanded)
            }
            function declare(expression, withArray, name, type) {
                name = name || "[DX_Set_" + withArray.length + "]";
                type = type || "set";
                withArray.push(stringFormat(mdxWith, type, name, expression));
                return name
            }
            function generateAxisMdx(options, axisName, cells, withArray, parseOptions) {
                var dimensions = options[axisName],
                    crossJoins = [],
                    path = [],
                    expandedPaths = [],
                    expandIndex = 0,
                    expandLevel = 0,
                    result = [],
                    cellsString = stringFormat(mdxSet, cells.join(","));
                if (dimensions && dimensions.length) {
                    if (options.headerName === axisName) {
                        path = options.path;
                        expandLevel = expandIndex = path.length
                    }
                    else {
                        expandedPaths = (axisName === "columns" ? options.columnExpandedPaths : options.rowExpandedPaths) || expandedPaths;
                        each(expandedPaths, function(_, path) {
                            expandLevel = Math.max(expandLevel, path.length)
                        })
                    }
                    while (dimensions[expandLevel + 1] && dimensions[expandLevel].expanded)
                        expandLevel++;
                    fillCrossJoins(crossJoins, [], expandLevel, expandIndex, path, options, axisName);
                    each(expandedPaths, function(_, expandedPath) {
                        fillCrossJoins(crossJoins, expandedPath, expandLevel, expandIndex, expandedPath, options, axisName)
                    });
                    for (var i = expandLevel; i >= path.length; i--)
                        if (dimensions[i].hierarchyName) {
                            parseOptions.visibleLevels[dimensions[i].hierarchyName] = parseOptions.visibleLevels[dimensions[i].hierarchyName] || [];
                            parseOptions.visibleLevels[dimensions[i].hierarchyName].push(dimensions[i].dataField)
                        }
                }
                crossJoins.length && result.push(stringFormat(mdxNonEmpty, declare(stringFormat(mdxSet, crossJoins.join(",")), withArray, "[" + "DX_" + axisName + "]"), cellsString));
                if (axisName === "columns" && cells.length)
                    result.push(cellsString);
                return stringFormat(mdxAxis, crossJoinElements(result), axisName)
            }
            function generateAxisFieldsFilter(fields) {
                var filterMembers = [];
                each(fields, function(_, field) {
                    var dataField = field.dataField,
                        filterExpression = [],
                        filterValues = field.filterValues || [],
                        filterStringExpression;
                    if (field.hierarchyName && commonUtils.isNumber(field.groupIndex))
                        return;
                    each(filterValues, function(_, filterValue) {
                        var filterMdx = dataField + "." + preparePathValue(commonUtils.isArray(filterValue) ? filterValue[filterValue.length - 1] : filterValue);
                        if (field.filterType === "exclude") {
                            filterExpression.push(filterMdx + ".parent");
                            filterMdx = "Descendants(" + filterMdx + ")"
                        }
                        filterExpression.push(filterMdx)
                    });
                    if (filterValues.length) {
                        filterStringExpression = stringFormat(mdxSet, filterExpression.join(","));
                        if (field.filterType === "exclude")
                            filterStringExpression = "Except(" + getAllMembers(field) + "," + filterStringExpression + ")";
                        filterMembers.push(filterStringExpression)
                    }
                });
                return filterMembers.length ? crossJoinElements(filterMembers) : ""
            }
            function generateFrom(columnsFilter, rowsFilter, filter, cubeName) {
                var from = "[" + cubeName + "]";
                each([columnsFilter, rowsFilter, filter], function(_, filter) {
                    if (filter)
                        from = stringFormat(mdxFilterSelect, filter + "on 0", from)
                });
                return from
            }
            function generateMdxCore(axisStrings, withArray, columns, rows, filters, slice, cubeName) {
                var mdxString = "",
                    withString = (withArray.length ? "with " + withArray.join(" ") : "") + " ";
                if (axisStrings.length)
                    mdxString = withString + stringFormat(mdx, generateFrom(generateAxisFieldsFilter(columns), generateAxisFieldsFilter(rows), generateAxisFieldsFilter(filters || []), cubeName), slice.length ? stringFormat(mdxSlice, slice.join(",")) : "", axisStrings.join(","));
                return mdxString
            }
            function prepareDataFields(withArray, valueFields) {
                return $.map(valueFields, function(cell) {
                        if (commonUtils.isString(cell.expression))
                            declare(cell.expression, withArray, cell.dataField, "member");
                        return cell.dataField
                    })
            }
            function generateMDX(options, cubeName, parseOptions) {
                var columns = options.columns || [],
                    rows = options.rows || [],
                    values = options.values && options.values.length ? options.values : [{dataField: '[Measures]'}],
                    slice = [],
                    withArray = [],
                    axisStrings = [],
                    dataFields = prepareDataFields(withArray, values);
                parseOptions.measureCount = values.length;
                parseOptions.visibleLevels = {};
                if (options.headerName && options.path)
                    each(options.path, function(index, value) {
                        var dimention = options[options.headerName][index];
                        if (!dimention.hierarchyName || dimention.hierarchyName !== options[options.headerName][index + 1].hierarchyName)
                            slice.push(dimention.dataField + "." + preparePathValue(value))
                    });
                if (columns.length || dataFields.length)
                    axisStrings.push(generateAxisMdx(options, "columns", dataFields, withArray, parseOptions));
                if (rows.length)
                    axisStrings.push(generateAxisMdx(options, "rows", dataFields, withArray, parseOptions));
                return generateMdxCore(axisStrings, withArray, columns, rows, options.filters, slice, cubeName)
            }
            function createDrillDownAxisSlice(slice, fields, path) {
                each(path, function(index, value) {
                    var field = fields[index];
                    if (field.hierarchyName && (fields[index + 1] || {}).hierarchyName === field.hierarchyName)
                        return;
                    slice.push(field.dataField + "." + preparePathValue(value))
                })
            }
            function generateDrillDownMDX(options, cubeName, params) {
                var columns = options.columns || [],
                    rows = options.rows || [],
                    values = options.values && options.values.length ? options.values : [{dataField: '[Measures]'}],
                    slice = [],
                    withArray = [],
                    axisStrings = [],
                    dataFields = prepareDataFields(withArray, values),
                    maxRowCount = params.maxRowCount,
                    customColumns = params.customColumns || [],
                    customColumnsString = customColumns.length > 0 ? " return " + customColumns.join(",") : "",
                    coreMDX;
                createDrillDownAxisSlice(slice, columns, params.columnPath || []);
                createDrillDownAxisSlice(slice, rows, params.rowPath || []);
                if (columns.length || columns.length || dataFields.length)
                    axisStrings.push([(dataFields[params.dataIndex] || dataFields[0]) + " on 0"]);
                coreMDX = generateMdxCore(axisStrings, withArray, columns, rows, options.filters, slice, cubeName);
                return coreMDX ? "drillthrough" + (maxRowCount > 0 ? " maxrows " + maxRowCount : "") + coreMDX + customColumnsString : coreMDX
            }
            function getNumber(str) {
                return parseInt(str, 10)
            }
            function parseValue(valueText) {
                return $.isNumeric(valueText) ? parseFloat(valueText) : valueText
            }
            function getFirstChild(node, tagName) {
                return (node.getElementsByTagName(tagName) || [])[0]
            }
            function getFirstChildText(node, childTagName) {
                return getNodeText(getFirstChild(node, childTagName))
            }
            function parseAxes(xml) {
                var axes = [];
                each(xml.getElementsByTagName("Axis"), function(_, axisElement) {
                    var name = axisElement.getAttribute("name"),
                        axis = [],
                        index = 0;
                    if (name.indexOf("Axis") === 0 && commonUtils.isNumber(getNumber(name.substr(4)))) {
                        axes.push(axis);
                        each(axisElement.getElementsByTagName("Tuple"), function(_, tupleElement) {
                            var tupleMembers = tupleElement.childNodes,
                                tuple,
                                levelSum = 0,
                                members = [],
                                level,
                                membersCount = tupleMembers.length - 1,
                                isAxisWithMeasure = axes.length === 1,
                                i;
                            if (isAxisWithMeasure)
                                membersCount--;
                            axis.push(members);
                            for (i = membersCount; i >= 0; i--) {
                                tuple = tupleMembers[i];
                                level = getNumber(getFirstChildText(tuple, "LNum"));
                                members[i] = {
                                    caption: getFirstChildText(tuple, "Caption"),
                                    value: parseValue(getFirstChildText(tuple, "MEMBER_VALUE")),
                                    level: level,
                                    index: index++,
                                    hasValue: !levelSum && (!!level || i === 0),
                                    name: getFirstChildText(tuple, "UName"),
                                    hierarchyName: tupleMembers[i].getAttribute("Hierarchy"),
                                    parentName: getFirstChildText(tuple, "PARENT_UNIQUE_NAME"),
                                    levelName: getFirstChildText(tuple, "LName")
                                };
                                levelSum += level
                            }
                        })
                    }
                });
                while (axes.length < 2)
                    axes.push([[{level: 0}]]);
                return axes
            }
            function getNodeText(node) {
                return node && node && (node.textContent || node.text || node.innerHTML) || ""
            }
            function parseCells(xml, axes, measureCount) {
                var cells = [],
                    cell = [],
                    index = 0,
                    measureIndex,
                    cellsOriginal = [],
                    cellElements = xml.getElementsByTagName("Cell"),
                    row;
                for (var i = 0; i < cellElements.length; i++) {
                    var xmlCell = cellElements[i],
                        valueElement = xmlCell.getElementsByTagName("Value")[0],
                        value = parseFloat(getNodeText(valueElement));
                    cellsOriginal[getNumber(xmlCell.getAttribute("CellOrdinal"))] = {value: isNaN(value) ? null : value}
                }
                each(axes[1], function() {
                    row = [];
                    cells.push(row);
                    each(axes[0], function() {
                        measureIndex = index % measureCount;
                        if (measureIndex === 0) {
                            cell = [];
                            row.push(cell)
                        }
                        cell.push(cellsOriginal[index] ? cellsOriginal[index].value : null);
                        index++
                    })
                });
                return cells
            }
            function preparePathValue(pathValue) {
                if (pathValue)
                    return commonUtils.isString(pathValue) && pathValue.indexOf("&[") !== -1 ? pathValue : "[" + pathValue + "]"
            }
            function getItem(hash, name, member, index) {
                var item = hash[name];
                if (!item) {
                    item = {};
                    hash[name] = item
                }
                if (!item.value && member) {
                    item.text = member.caption;
                    item.value = member.value;
                    item.key = name ? name.slice(name.indexOf('&[')) : '';
                    item.levelName = member.levelName;
                    item.hierarchyName = member.hierarchyName;
                    item.parentName = member.parentName;
                    item.index = index;
                    item.level = member.level
                }
                return item
            }
            function getVisibleChildren(item, visibleLevels) {
                var result = [],
                    children = item.children && (item.children.length ? item.children : $.map(item.children.grandTotalHash || [], function(e) {
                        return e.children
                    })),
                    firstChild = children && children[0];
                if (firstChild && (visibleLevels[firstChild.hierarchyName] && $.inArray(firstChild.levelName, visibleLevels[firstChild.hierarchyName]) !== -1 || !visibleLevels[firstChild.hierarchyName] || firstChild.level === 0)) {
                    var newChildren = $.map(children, function(child) {
                            return child.hierarchyName === firstChild.hierarchyName ? child : null
                        });
                    newChildren.grandTotalHash = children.grandTotalHash;
                    return newChildren
                }
                else if (firstChild)
                    for (var i = 0; i < children.length; i++)
                        if (children[i].hierarchyName === firstChild.hierarchyName)
                            result.push.apply(result, getVisibleChildren(children[i], visibleLevels));
                return result
            }
            function processMember(dataIndex, member, parentItem) {
                var currentItem,
                    children = parentItem.children = parentItem.children || [],
                    hash = children.hash = children.hash || {},
                    grandTotalHash = children.grandTotalHash = children.grandTotalHash || {};
                if (member.parentName) {
                    parentItem = getItem(hash, member.parentName);
                    children = parentItem.children = parentItem.children || []
                }
                currentItem = getItem(hash, member.name, member, dataIndex);
                if (member.hasValue && !currentItem.added) {
                    currentItem.index = dataIndex;
                    currentItem.added = true;
                    children.push(currentItem)
                }
                if ((!parentItem.value || !parentItem.parentName) && member.parentName)
                    grandTotalHash[member.parentName] = parentItem;
                else if (grandTotalHash[parentItem.name])
                    delete grandTotalHash[member.parentName];
                return currentItem
            }
            function getGrandTotalIndex(parentItem, visibleLevels) {
                var grandTotalIndex;
                if (parentItem.children.length === 1 && parentItem.children[0].parentName === "") {
                    grandTotalIndex = parentItem.children[0].index;
                    var grandTotalHash = parentItem.children.grandTotalHash;
                    parentItem.children = parentItem.children[0].children || [];
                    parentItem.children.grandTotalHash = grandTotalHash;
                    parentItem.children = getVisibleChildren(parentItem, visibleLevels)
                }
                else if (parentItem.children.length === 0)
                    grandTotalIndex = 0;
                return grandTotalIndex
            }
            function fillDataSourceAxes(dataSourceAxis, axisTuples, measureCount, visibleLevels) {
                var grandTotalIndex,
                    result = [];
                each(axisTuples, function(tupleIndex, members) {
                    var parentItem = {children: result},
                        dataIndex = commonUtils.isDefined(measureCount) ? Math.floor(tupleIndex / measureCount) : tupleIndex;
                    each(members, function(_, member) {
                        parentItem = processMember(dataIndex, member, parentItem)
                    })
                });
                var parentItem = {children: result};
                parentItem.children = getVisibleChildren(parentItem, visibleLevels);
                grandTotalIndex = getGrandTotalIndex(parentItem, visibleLevels);
                DX.ui.dxPivotGrid.foreachTree(parentItem.children, function(items) {
                    var item = items[0],
                        children = getVisibleChildren(item, visibleLevels);
                    if (children.length)
                        item.children = children;
                    else
                        delete item.children;
                    delete item.levelName;
                    delete item.hierarchyName;
                    delete item.added;
                    delete item.parentName;
                    delete item.level
                }, true);
                each(parentItem.children || [], function(_, e) {
                    dataSourceAxis.push(e)
                });
                return grandTotalIndex
            }
            function checkError(xml) {
                var errorElement = $(xml).find("Error"),
                    description,
                    error;
                if (errorElement.length) {
                    description = errorElement.attr("Description");
                    error = new errors.Error("E4000", description);
                    errors.log("E4000", description);
                    return error
                }
                return null
            }
            function parseResult(xml, parseOptions) {
                var dataSource = {
                        columns: [],
                        rows: []
                    },
                    axes,
                    measureCount = parseOptions.measureCount;
                axes = parseAxes(xml);
                dataSource.grandTotalColumnIndex = fillDataSourceAxes(dataSource.columns, axes[0], measureCount, parseOptions.visibleLevels);
                dataSource.grandTotalRowIndex = fillDataSourceAxes(dataSource.rows, axes[1], undefined, parseOptions.visibleLevels);
                dataSource.values = parseCells(xml, axes, measureCount);
                return dataSource
            }
            function parseDiscoverRowSet(xml, schema, dimensions) {
                var result = [],
                    isMeasure = schema === "MEASURE",
                    displayFolderField = isMeasure ? "MEASUREGROUP_NAME" : schema + "_DISPLAY_FOLDER";
                each(xml.getElementsByTagName("row"), function(_, row) {
                    var hierarchyName = schema === "LEVEL" ? getFirstChildText(row, "HIERARCHY_UNIQUE_NAME") : undefined,
                        levelNumber = getFirstChildText(row, "LEVEL_NUMBER");
                    if ((levelNumber !== "0" || getFirstChildText(row, schema + "_IS_VISIBLE") !== "true") && getFirstChildText(row, "DIMENSION_TYPE") !== MD_DIMTYPE_MEASURE) {
                        var dimension = isMeasure ? MEASURE_DEMENSION_KEY : getFirstChildText(row, "DIMENSION_UNIQUE_NAME"),
                            dataField = getFirstChildText(row, schema + "_UNIQUE_NAME");
                        result.push({
                            dimension: dimensions.names[dimension] || dimension,
                            groupIndex: levelNumber ? getNumber(levelNumber) - 1 : undefined,
                            dataField: dataField,
                            caption: getFirstChildText(row, schema + "_CAPTION"),
                            hierarchyName: hierarchyName,
                            groupName: hierarchyName,
                            displayFolder: getFirstChildText(row, displayFolderField),
                            isMeasure: isMeasure,
                            isDefault: !!dimensions.defaultHierarhies[dataField]
                        })
                    }
                });
                return result
            }
            function parseDimensionsDiscoverRowSet(xml) {
                var result = {
                        names: {},
                        defaultHierarhies: {}
                    };
                each($(xml).find("row"), function() {
                    var $row = $(this),
                        type = $row.children("DIMENSION_TYPE").text(),
                        dimensionName = type === MD_DIMTYPE_MEASURE ? MEASURE_DEMENSION_KEY : $row.children("DIMENSION_UNIQUE_NAME").text();
                    result.names[dimensionName] = $row.children("DIMENSION_CAPTION").text();
                    result.defaultHierarhies[$row.children("DEFAULT_HIERARCHY").text()] = true
                });
                return result
            }
            function parseStringWithUnicodeSymbols(str) {
                str = str.replace(/_x(....)_/g, function(whole, group1) {
                    return String.fromCharCode(parseInt(group1, 16))
                });
                var stringArray = str.match(/\[.+?\]/gi);
                if (stringArray && stringArray.length)
                    str = stringArray[stringArray.length - 1];
                return str.replace(/\[/gi, "").replace(/\]/gi, "").replace(/\$/gi, "").replace(/\./gi, " ")
            }
            function parseDrillDownRowset(xml) {
                var rows = xml.getElementsByTagName("row"),
                    result = [],
                    columnNames = {};
                for (var i = 0; i < rows.length; i++) {
                    var children = rows[i].childNodes,
                        item = {};
                    for (var j = 0; j < children.length; j++) {
                        var tagName = children[j].tagName,
                            name = columnNames[tagName] = columnNames[tagName] || parseStringWithUnicodeSymbols(tagName);
                        item[name] = getNodeText(children[j])
                    }
                    result.push(item)
                }
                return result
            }
            function sendQuery(storeOptions, mdxString) {
                mdxString = $("<div>").text(mdxString).html();
                return execXMLA(storeOptions, stringFormat(execute, mdxString, storeOptions.catalog))
            }
            return {
                    ctor: function(options) {
                        this._options = options
                    },
                    getFields: function() {
                        var options = this._options,
                            catalog = options.catalog,
                            cube = options.cube,
                            dimensionsRequest = execXMLA(options, stringFormat(discover, catalog, cube, "MDSCHEMA_DIMENSIONS")),
                            measuresRequest = execXMLA(options, stringFormat(discover, catalog, cube, "MDSCHEMA_MEASURES")),
                            hierarchiesRequest = execXMLA(options, stringFormat(discover, catalog, cube, "MDSCHEMA_HIERARCHIES")),
                            levelsRequest = execXMLA(options, stringFormat(discover, catalog, cube, "MDSCHEMA_LEVELS")),
                            result = $.Deferred();
                        $.when(dimensionsRequest, measuresRequest, hierarchiesRequest, levelsRequest).done(function(dimensionsResponse, measuresResponse, hierarhiesResponse, levelsResponse) {
                            var dimensions = parseDimensionsDiscoverRowSet(dimensionsResponse),
                                hierarchies = parseDiscoverRowSet(hierarhiesResponse, "HIERARCHY", dimensions),
                                levels = parseDiscoverRowSet(levelsResponse, "LEVEL", dimensions),
                                fields = parseDiscoverRowSet(measuresResponse, "MEASURE", dimensions).concat(hierarchies),
                                levelsByHierarchy = {};
                            each(levels, function(_, level) {
                                levelsByHierarchy[level.hierarchyName] = levelsByHierarchy[level.hierarchyName] || [];
                                levelsByHierarchy[level.hierarchyName].push(level)
                            });
                            each(hierarchies, function(_, hierarchy) {
                                if (levelsByHierarchy[hierarchy.dataField] && levelsByHierarchy[hierarchy.dataField].length > 1) {
                                    hierarchy.groupName = hierarchy.hierarchyName = hierarchy.dataField;
                                    fields.push.apply(fields, levelsByHierarchy[hierarchy.hierarchyName])
                                }
                            });
                            result.resolve(fields)
                        }).fail(result.reject);
                        return result
                    },
                    load: function(options) {
                        var result = $.Deferred(),
                            storeOptions = this._options,
                            parseOptions = {},
                            mdxString = generateMDX(options, storeOptions.cube, parseOptions);
                        if (mdxString)
                            $.when(sendQuery(storeOptions, mdxString)).done(function(executeXml) {
                                var error = checkError(executeXml);
                                if (!error)
                                    result.resolve(parseResult(executeXml, parseOptions));
                                else
                                    result.reject(error)
                            }).fail(result.reject);
                        else
                            result.resolve({
                                columns: [],
                                rows: [],
                                values: [],
                                grandTotalColumnIndex: 0,
                                grandTotalRowIndex: 0
                            });
                        return result
                    },
                    supportSorting: function() {
                        return true
                    },
                    getDrillDownItems: function(options, params) {
                        var result = $.Deferred(),
                            storeOptions = this._options,
                            mdxString = generateDrillDownMDX(options, storeOptions.cube, params);
                        if (mdxString)
                            $.when(sendQuery(storeOptions, mdxString)).done(function(executeXml) {
                                var error = checkError(executeXml);
                                if (!error)
                                    result.resolve(parseDrillDownRowset(executeXml));
                                else
                                    result.reject(error)
                            }).fail(result.reject);
                        else
                            result.resolve([]);
                        return result
                    },
                    key: $.noop,
                    filter: $.noop
                }
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.store.local.js */
    (function($, DX) {
        var dataUtils = DX.data.utils,
            pivotGrid = DX.ui.dxPivotGrid,
            Class = DevExpress.require("/class"),
            formatHelper = DX.require("/utils/utils.formatHelper"),
            commonUtils = DX.require("/utils/utils.common");
        pivotGrid.LocalStore = Class.inherit(function() {
            var DATE_INTERVAL_SELECTORS = {
                    year: function(date) {
                        return date && date.getFullYear()
                    },
                    quarter: function(date) {
                        return date && Math.floor(date.getMonth() / 3) + 1
                    },
                    month: function(date) {
                        return date && date.getMonth() + 1
                    },
                    day: function(date) {
                        return date && date.getDate()
                    },
                    dayOfWeek: function(date) {
                        return date && date.getDay()
                    }
                };
            var DATE_INTERVAL_FORMATS = {
                    month: {
                        format: 'month',
                        dateType: 'full'
                    },
                    quarter: {
                        format: 'quarter',
                        dateType: 'full'
                    },
                    dayOfWeek: {
                        format: 'dayOfWeek',
                        dateType: 'full'
                    }
                };
            function prepareFields(fields) {
                $.each(fields || [], function() {
                    var fieldSelector,
                        intervalSelector,
                        dataField = this.dataField,
                        groupInteval,
                        levels = this.levels;
                    if (!this.selector) {
                        if (!dataField)
                            fieldSelector = function(data) {
                                return data
                            };
                        else
                            fieldSelector = dataField.indexOf(".") !== -1 ? dataUtils.compileGetter(dataField) : function(data) {
                                return data[dataField]
                            };
                        if (levels) {
                            prepareFields(levels);
                            this.selector = function(data) {
                                var value = [];
                                $.each(levels, function(_, field) {
                                    value.push(field.selector(data))
                                });
                                return value
                            }
                        }
                        else if (this.dataType === 'date') {
                            intervalSelector = DATE_INTERVAL_SELECTORS[this.groupInterval];
                            this.selector = function(data) {
                                var value = fieldSelector(data);
                                if (value && !(value instanceof Date))
                                    value = new Date(value);
                                return intervalSelector ? intervalSelector(value) : value
                            };
                            this.format = this.format || DATE_INTERVAL_FORMATS[this.groupInterval]
                        }
                        else if (this.dataType === 'number') {
                            groupInteval = commonUtils.isNumber(this.groupInterval) && this.groupInterval > 0 && this.groupInterval;
                            if (groupInteval)
                                this.customizeText = this.customizeText || function(formatObject) {
                                    var secondValue = formatObject.value + groupInteval,
                                        secondValueText = formatHelper.format(secondValue, this.format, this.precision);
                                    return formatObject.valueText && secondValueText ? formatObject.valueText + " - " + secondValueText : ""
                                };
                            this.selector = function(data) {
                                var value = fieldSelector(data);
                                if (commonUtils.isString(value))
                                    value = Number(value);
                                return groupInteval ? Math.floor(value / groupInteval) * groupInteval : value
                            }
                        }
                        else
                            this.selector = fieldSelector
                    }
                })
            }
            var addHierarchyItem = function(value, hierarchyItems, pathHash, childrenHash) {
                    var hierarchyItem = childrenHash[pathHash];
                    if (!hierarchyItem) {
                        hierarchyItem = {
                            value: value,
                            index: childrenHash.length++
                        };
                        childrenHash[pathHash] = hierarchyItem;
                        hierarchyItems.push(hierarchyItem)
                    }
                    return hierarchyItem
                };
            function fillHierarchyItemIndexesCore(indexes, options, children, expandIndex, pathHash) {
                var dimension = options.dimensions[expandIndex],
                    expandedPathsHash = options.expandedPathsHash,
                    dimensionValue,
                    hierarchyItem;
                if (dimension) {
                    dimensionValue = dimension.selector(options.data);
                    pathHash = pathHash ? pathHash + "." + dimensionValue : dimensionValue;
                    hierarchyItem = addHierarchyItem(dimensionValue, children, pathHash, options.childrenHash);
                    indexes.push(hierarchyItem.index);
                    if (expandedPathsHash && expandedPathsHash[pathHash] || dimension.expanded) {
                        if (!hierarchyItem.children)
                            hierarchyItem.children = [];
                        fillHierarchyItemIndexesCore(indexes, options, hierarchyItem.children, expandIndex + 1, pathHash)
                    }
                }
            }
            function generateHierarchyItems(data, loadOptions, headers, headerName) {
                var result = [0],
                    expandIndex = loadOptions.headerName === headerName ? loadOptions.path.length : 0,
                    expandedPaths = headerName === "rows" ? loadOptions.rowExpandedPaths : loadOptions.columnExpandedPaths,
                    options = {
                        data: data,
                        childrenHash: headers[headerName + "Hash"],
                        dimensions: loadOptions[headerName],
                        expandedPathsHash: loadOptions.headerName !== headerName && expandedPaths && expandedPaths.hash
                    };
                fillHierarchyItemIndexesCore(result, options, headers[headerName], expandIndex);
                return result
            }
            function generateAggregationCells(data, cells, headers, options) {
                var cellSet = [],
                    x,
                    y,
                    rowIndex,
                    columnIndex;
                var rowIndexes = generateHierarchyItems(data, options, headers, "rows");
                var columnIndexes = generateHierarchyItems(data, options, headers, "columns");
                for (y = 0; y < rowIndexes.length; y++) {
                    rowIndex = rowIndexes[y];
                    cells[rowIndex] = cells[rowIndex] || [];
                    for (x = 0; x < columnIndexes.length; x++) {
                        columnIndex = columnIndexes[x];
                        cellSet.push(cells[rowIndex][columnIndex] = cells[rowIndex][columnIndex] || [])
                    }
                }
                return cellSet
            }
            function fillHashExpandedPath(expandedPaths) {
                if (expandedPaths) {
                    expandedPaths.hash = {};
                    $.each(expandedPaths, function() {
                        expandedPaths.hash[this.join(".")] = true
                    })
                }
            }
            function prepareLoadOption(options) {
                options.rows = options.rows || [];
                options.columns = options.columns || [];
                options.filters = options.filters || [];
                fillHashExpandedPath(options.columnExpandedPaths);
                fillHashExpandedPath(options.rowExpandedPaths);
                prepareFields(options.columns);
                prepareFields(options.rows);
                prepareFields(options.values);
                prepareFields(options.filters)
            }
            function getAggregator(field) {
                if (field.summaryType === "custom") {
                    field.calculateCustomSummary = field.calculateCustomSummary || $.noop;
                    return {
                            seed: function() {
                                var options = {
                                        summaryProcess: "start",
                                        totalValue: undefined
                                    };
                                field.calculateCustomSummary(options);
                                return options
                            },
                            step: function(options, value) {
                                options.summaryProcess = "calculate";
                                options.value = value;
                                field.calculateCustomSummary(options);
                                return options
                            },
                            finalize: function(options) {
                                options.summaryProcess = "finalize";
                                delete options.value;
                                field.calculateCustomSummary(options);
                                return options.totalValue
                            }
                        }
                }
                return dataUtils.aggregators[field.summaryType] || dataUtils.aggregators.count
            }
            function aggregationStep(measures, aggregationCells, data) {
                for (var aggregatorIndex = 0; aggregatorIndex < measures.length; aggregatorIndex++) {
                    var cellField = measures[aggregatorIndex];
                    var cellValue = cellField.selector(data);
                    var aggregator = getAggregator(cellField);
                    for (var cellSetIndex = 0; cellSetIndex < aggregationCells.length; cellSetIndex++) {
                        var cell = aggregationCells[cellSetIndex];
                        if (cell.length <= aggregatorIndex)
                            cell[aggregatorIndex] = commonUtils.isFunction(aggregator.seed) ? aggregator.seed() : aggregator.seed;
                        if (cell[aggregatorIndex] === undefined)
                            cell[aggregatorIndex] = cellValue;
                        else if (commonUtils.isDefined(cellValue))
                            cell[aggregatorIndex] = aggregator.step(cell[aggregatorIndex], cellValue)
                    }
                }
            }
            function aggregationFinalize(measures, cells) {
                $.each(measures, function(aggregatorIndex, cellField) {
                    var aggregator = getAggregator(cellField);
                    if (aggregator.finalize)
                        $.each(cells, function(_, row) {
                            $.each(row, function(_, cell) {
                                if (cell)
                                    cell[aggregatorIndex] = aggregator.finalize(cell[aggregatorIndex])
                            })
                        })
                })
            }
            function areValuesEqual(filterValue, fieldValue) {
                if (commonUtils.isArray(filterValue)) {
                    fieldValue = fieldValue || [];
                    for (var i = 0; i < filterValue.length; i++)
                        if (filterValue[i] !== fieldValue[i])
                            return false;
                    return true
                }
                else
                    return filterValue === fieldValue
            }
            function createDimensionFilters(dimention) {
                var filters = [];
                $.each(dimention, function(_, field) {
                    var filterValues = field.filterValues || [],
                        groupName = field.groupName,
                        filter;
                    if (groupName && commonUtils.isNumber(field.groupIndex))
                        return;
                    filter = function(dataItem) {
                        var value = field.selector(dataItem),
                            result = false;
                        for (var i = 0; i < filterValues.length; i++)
                            if (areValuesEqual(filterValues[i], value)) {
                                result = true;
                                break
                            }
                        return field.filterType === "exclude" ? !result : result
                    };
                    filterValues.length && filters.push(filter)
                });
                return filters
            }
            function createFilter(options) {
                var filters = createDimensionFilters(options.rows).concat(createDimensionFilters(options.columns)).concat(createDimensionFilters(options.filters)),
                    expandedDimensions = options[options.headerName],
                    path = options.path;
                if (expandedDimensions)
                    filters.push(function(dataItem) {
                        var expandValue;
                        for (var i = 0; i < path.length; i++) {
                            expandValue = expandedDimensions[i].selector(dataItem);
                            if (expandValue !== path[i])
                                return false
                        }
                        return true
                    });
                return function(dataItem) {
                        for (var i = 0; i < filters.length; i++)
                            if (!filters[i](dataItem))
                                return false;
                        return true
                    }
            }
            function loadCore(items, options) {
                var headers = {
                        columns: [],
                        rows: [],
                        columnsHash: {length: 1},
                        rowsHash: {length: 1}
                    },
                    values = [[[]]],
                    aggregationCells,
                    filter,
                    data,
                    i;
                prepareLoadOption(options);
                filter = createFilter(options);
                for (i = 0; i < items.length; i++) {
                    data = items[i];
                    if (filter(data)) {
                        aggregationCells = generateAggregationCells(data, values, headers, options);
                        aggregationStep(options.values, aggregationCells, data)
                    }
                }
                aggregationFinalize(options.values, values);
                return {
                        rows: headers.rows,
                        columns: headers.columns,
                        values: values,
                        grandTotalRowIndex: 0,
                        grandTotalColumnIndex: 0
                    }
            }
            function createGroupFields(item) {
                return $.map(["year", "quarter", "month"], function(value, index) {
                        return $.extend({}, item, {
                                groupInterval: value,
                                groupIndex: index
                            })
                    })
            }
            function parseFields(dataSource, fieldsList, path, fieldsDataType) {
                var result = [];
                $.each(fieldsList || [], function(field, value) {
                    var dataIndex = 1,
                        currentPath = path.length ? path + "." + field : field,
                        dataType = fieldsDataType[currentPath],
                        getter = dataUtils.compileGetter(currentPath),
                        items;
                    while (!commonUtils.isDefined(value) && dataSource[dataIndex]) {
                        value = getter(dataSource[dataIndex]);
                        dataIndex++
                    }
                    if (!dataType && commonUtils.isDefined(value))
                        dataType = $.type(value);
                    items = [{
                            dataField: currentPath,
                            dataType: dataType,
                            groupName: dataType === "date" ? field : undefined,
                            groupInterval: undefined,
                            displayFolder: path
                        }];
                    if (dataType === "date")
                        items = items.concat(createGroupFields(items[0]));
                    else if (dataType === "object")
                        items = parseFields(dataSource, value, currentPath, fieldsDataType);
                    result.push.apply(result, items)
                });
                return result
            }
            function discover(items, fieldsDataType) {
                fieldsDataType = fieldsDataType || {};
                return parseFields(items, items[0], "", fieldsDataType)
            }
            function loadDataSource(dataSource, reload) {
                var d = $.Deferred();
                if (!dataSource.isLoaded() || reload) {
                    var loadDeferred = reload ? dataSource.load() : dataSource.reload();
                    $.when(loadDeferred).always(function() {
                        loadDataSource(dataSource).done(d.resolve).fail(d.reject)
                    })
                }
                else
                    d.resolve(dataSource.items());
                return d
            }
            function getFilterPathFields(fields, path) {
                var result = [];
                path = path || [];
                for (var i = 0; i < path.length; i++)
                    result.push($.extend({}, fields[i], {
                        groupIndex: null,
                        groupName: null,
                        filterType: "include",
                        filterValues: [path[i]]
                    }));
                return result
            }
            return {
                    ctor: function(options) {
                        options = $.extend(dataUtils.normalizeDataSourceOptions(options), {
                            paginate: false,
                            onChanged: null
                        });
                        this._dataSource = new DX.data.DataSource(options)
                    },
                    getFields: function(fieldsDataType) {
                        var that = this,
                            dataSource = that._dataSource,
                            d = $.Deferred();
                        loadDataSource(dataSource).done(function(data) {
                            d.resolve(discover(data, fieldsDataType))
                        }).fail(d.reject);
                        return d
                    },
                    key: function() {
                        return this._dataSource.key()
                    },
                    load: function(options) {
                        var that = this,
                            dataSource = that._dataSource,
                            d = $.Deferred();
                        loadDataSource(dataSource, options.reload).done(function(data) {
                            var parsedData = loadCore(data, options);
                            d.resolve(parsedData)
                        }).fail(d.reject);
                        return d
                    },
                    filter: function() {
                        var dataSource = this._dataSource;
                        return dataSource.filter.apply(dataSource, arguments)
                    },
                    supportSorting: function() {
                        return false
                    },
                    getDrillDownItems: function(loadOptions, params) {
                        loadOptions = loadOptions || {};
                        params = params || {};
                        prepareLoadOption(loadOptions);
                        var drillDownItems = [],
                            items = this._dataSource.items(),
                            item,
                            maxRowCount = params.maxRowCount,
                            customColumns = params.customColumns,
                            filter = createFilter(loadOptions),
                            pathFilter = createFilter({
                                rows: getFilterPathFields(loadOptions.rows, params.rowPath),
                                columns: getFilterPathFields(loadOptions.columns, params.columnPath),
                                filters: []
                            });
                        for (var i = 0; i < items.length; i++) {
                            if (pathFilter(items[i]) && filter(items[i])) {
                                if (customColumns) {
                                    item = {};
                                    for (var j = 0; j < customColumns.length; j++)
                                        item[customColumns[j]] = items[i][customColumns[j]]
                                }
                                else
                                    item = items[i];
                                drillDownItems.push(item)
                            }
                            if (maxRowCount > 0 && drillDownItems.length === maxRowCount)
                                break
                        }
                        return drillDownItems
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.areaItem.js */
    (function($, DX) {
        var pivotGrid = DX.ui.dxPivotGrid,
            Class = DevExpress.require("/class"),
            commonUtils = DX.require("/utils/utils.common");
        var getRealElementWidth = function(element) {
                var width = 0,
                    clientRect;
                if (element.getBoundingClientRect) {
                    clientRect = element.getBoundingClientRect();
                    width = clientRect.width;
                    if (!width)
                        width = clientRect.right - clientRect.left
                }
                if (width > 0)
                    return width;
                else
                    return element.offsetWidth
            };
        pivotGrid.getRealElementWidth = getRealElementWidth;
        pivotGrid.AreaItem = Class.inherit({
            _getRowElement: function(index) {
                var that = this;
                if (that._tableElement && that._tableElement.length > 0)
                    return that._tableElement[0].rows[index];
                return null
            },
            _createGroupElement: function() {
                return $('<div>')
            },
            _createTableElement: function() {
                return $('<table>')
            },
            _renderTableContent: function(tableElement, data) {
                var that = this,
                    rowElements = tableElement.find("tr"),
                    areaName = that._getAreaName(),
                    onCellPrepared = that.option("onCellPrepared"),
                    rowElement,
                    cellElement,
                    row,
                    cell,
                    rowIndex,
                    columnIndex;
                tableElement.data("area", areaName);
                tableElement.data("data", data);
                if (onCellPrepared)
                    for (rowIndex = 0; rowIndex < data.length; rowIndex++) {
                        row = data[rowIndex];
                        rowElement = rowElements.eq(rowIndex);
                        for (columnIndex = 0; columnIndex < row.length; columnIndex++) {
                            cell = row[columnIndex];
                            cellElement = rowElement.children().eq(columnIndex);
                            onCellPrepared({
                                area: areaName,
                                rowIndex: rowIndex,
                                columnIndex: columnIndex,
                                cellElement: cellElement,
                                cell: cell
                            })
                        }
                    }
            },
            _getRowHeight: function(index) {
                var row = this._getRowElement(index),
                    clientRect,
                    height = 0;
                if (row && row.lastChild) {
                    if (row.getBoundingClientRect) {
                        clientRect = row.getBoundingClientRect();
                        height = clientRect.height
                    }
                    if (height > 0)
                        return height;
                    else
                        return row.offsetHeight
                }
                return 0
            },
            _setRowHeight: function(index, value) {
                var row = this._getRowElement(index);
                if (row)
                    row.style.height = value + 'px'
            },
            ctor: function(component) {
                this.component = component
            },
            option: function() {
                return this.component.option.apply(this.component, arguments)
            },
            getRowsLength: function() {
                var that = this;
                if (that._tableElement && that._tableElement.length > 0)
                    return that._tableElement[0].rows.length;
                return 0
            },
            getRowsHeight: function() {
                var that = this,
                    result = [],
                    rowsLength = that.getRowsLength(),
                    i;
                for (i = 0; i < rowsLength; i++)
                    result.push(that._getRowHeight(i));
                return result
            },
            setRowsHeight: function(values) {
                var that = this,
                    totalHeight = 0,
                    valuesLength = values.length,
                    i;
                for (i = 0; i < valuesLength; i++) {
                    totalHeight += values[i];
                    that._setRowHeight(i, values[i])
                }
                this._tableHeight = totalHeight;
                this._tableElement[0].style.height = totalHeight + 'px'
            },
            getColumnsWidth: function() {
                var rowsLength = this.getRowsLength(),
                    rowIndex,
                    row,
                    i,
                    columnIndex,
                    processedCells = [],
                    result = [],
                    fillCells = function(cells, rowIndex, columnIndex, rowSpan, colSpan) {
                        var rowOffset,
                            columnOffset;
                        for (rowOffset = 0; rowOffset < rowSpan; rowOffset++)
                            for (columnOffset = 0; columnOffset < colSpan; columnOffset++) {
                                cells[rowIndex + rowOffset] = cells[rowIndex + rowOffset] || [];
                                cells[rowIndex + rowOffset][columnIndex + columnOffset] = true
                            }
                    };
                if (rowsLength)
                    for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
                        processedCells[rowIndex] = processedCells[rowIndex] || [];
                        row = this._getRowElement(rowIndex);
                        for (i = 0; i < row.cells.length; i++) {
                            for (columnIndex = 0; processedCells[rowIndex][columnIndex]; columnIndex++);;
                            fillCells(processedCells, rowIndex, columnIndex, row.cells[i].rowSpan, row.cells[i].colSpan);
                            if (row.cells[i].colSpan === 1)
                                result[columnIndex] = result[columnIndex] || getRealElementWidth(row.cells[i])
                        }
                    }
                return result
            },
            setColumnsWidth: function(values) {
                var i,
                    totalWidth = 0,
                    tableElement = this._tableElement[0],
                    colgroupElementHTML = '';
                for (i = 0; i < values.length; i++) {
                    totalWidth += values[i];
                    colgroupElementHTML += '<col style="width: ' + values[i] + 'px"/>'
                }
                this._colgroupElement.html(colgroupElementHTML);
                this._tableWidth = totalWidth;
                tableElement.style.width = totalWidth + 'px';
                tableElement.style.tableLayout = 'fixed'
            },
            resetColumnsWidth: function() {
                this._colgroupElement.find('col').width('auto');
                this._tableElement.css({
                    width: '',
                    tableLayout: ''
                })
            },
            groupWidth: function(value) {
                if (value === undefined)
                    return this._groupElement.width();
                else if (value >= 0) {
                    this._groupWidth = value;
                    return this._groupElement[0].style.width = value + 'px'
                }
                else
                    return this._groupElement[0].style.width = value
            },
            groupHeight: function(value) {
                if (value === undefined)
                    return this._groupElement.height();
                else if (value >= 0) {
                    this._groupHeight = value;
                    this._groupElement[0].style.height = value + 'px'
                }
                else
                    this._groupElement[0].style.height = value
            },
            groupElement: function() {
                return this._groupElement
            },
            tableElement: function() {
                return this._tableElement
            },
            element: function() {
                return this._rootElement
            },
            headElement: function() {
                return this._tableElement.find('thead')
            },
            setVirtualContentParams: function(params) {
                this._virtualContent.css({
                    width: params.width,
                    height: params.height
                });
                this.groupElement().addClass("dx-virtual-mode")
            },
            disableVirtualMode: function() {
                this.groupElement().removeClass("dx-virtual-mode")
            },
            _renderVirtualContent: function() {
                var that = this;
                if (!that._virtualContent && that.option("scrolling.mode") === "virtual")
                    that._virtualContent = $("<div>").addClass("dx-virtual-content").insertAfter(that._tableElement)
            },
            reset: function() {
                var that = this,
                    tableElement = that._tableElement[0];
                that.disableVirtualMode();
                that.groupWidth("100%");
                that.groupHeight("auto");
                that.resetColumnsWidth();
                if (tableElement) {
                    for (var i = 0; i < tableElement.rows.length; i++)
                        tableElement.rows[i].style.height = "";
                    tableElement.style.height = "";
                    tableElement.style.width = "100%"
                }
            },
            render: function(rootElement, data) {
                var that = this,
                    tableElement = that._createTableElement();
                if (commonUtils.isDefined(that._tableElement)) {
                    try {
                        that._tableElement[0].innerHTML = ''
                    }
                    catch(e) {
                        that._tableElement.empty()
                    }
                    that._tableElement.attr('style', '');
                    that._colgroupElement = $('<colgroup>').appendTo(that._tableElement);
                    that._renderTableContent(that._tableElement, data)
                }
                else {
                    that._groupElement = that._createGroupElement();
                    that._tableElement = tableElement;
                    that._colgroupElement = $('<colgroup>').appendTo(that._tableElement);
                    that._tableElement.appendTo(that._groupElement);
                    that._groupElement.appendTo(rootElement);
                    that._rootElement = rootElement;
                    that._renderTableContent(that._tableElement, data)
                }
                that._renderVirtualContent()
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.headersArea.js */
    (function($, DX) {
        var ui = DX.ui,
            pivotGrid = ui.dxPivotGrid,
            commonUtils = DX.require("/utils/utils.common"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        function getCellPath(tableElement, cell) {
            if (cell) {
                var data = tableElement.data().data,
                    rowIndex = cell.parentNode.rowIndex,
                    cellIndex = cell.cellIndex;
                return data[rowIndex] && data[rowIndex][cellIndex] && data[rowIndex][cellIndex].path
            }
        }
        pivotGrid.HorizontalHeadersArea = pivotGrid.AreaItem.inherit({
            _getAreaName: function() {
                return "column"
            },
            _getAreaClassName: function() {
                return pivotGrid.cssClassNames.headersHorizontal
            },
            _textCellRender: function(rootElement, value) {
                var $span = $('<span>');
                if (!value)
                    $span.html("&nbsp");
                else
                    this.option("encodeHtml") ? $span.text(value) : $span.html(value);
                $span.appendTo(rootElement)
            },
            _createGroupElement: function() {
                return $('<div>').addClass(this._getAreaClassName()).addClass(pivotGrid.cssClassNames.area)
            },
            _createTableElement: function() {
                return $('<table>')
            },
            _createRow: function() {
                return $('<tr>')
            },
            _createCell: function(cell) {
                var that = this,
                    cellElement = $('<td>').attr({
                        colspan: cell.colspan,
                        rowspan: cell.rowspan
                    });
                if (commonUtils.isDefined(cell.expanded)) {
                    cellElement.addClass(cell.expanded ? pivotGrid.cssClassNames.headersExpanded : pivotGrid.cssClassNames.headersCollapsed).on(eventUtils.addNamespace("dxclick", this._getEventsNamespace()), function(e) {
                        setTimeout(function() {
                            var area = that._getAreaName();
                            if (cell.expanded)
                                that._dataSource.collapseHeaderItem(area, cell.path);
                            else
                                that._dataSource.expandHeaderItem(area, cell.path)
                        })
                    });
                    $('<span>').addClass(pivotGrid.cssClassNames.headersExpandCollapseImage).appendTo(cellElement)
                }
                return cellElement
            },
            _applyCustomStyles: function(options) {
                if (options.cellIndex === options.cellsCount - 1)
                    options.cellElement.css(options.rtlEnabled ? 'border-left' : 'border-right', '0px');
                if (options.cell.rowspan === options.rowsCount - options.rowIndex || options.rowIndex + 1 === options.rowsCount)
                    options.cellElement.css('border-bottom-width', '0px');
                options.cellElement.toggleClass(pivotGrid.cssClassNames.rowTotal, options.cell.type === 'T' || options.cell.type === 'GT').toggleClass(pivotGrid.cssClassNames.total, options.cell.type === 'T').toggleClass(pivotGrid.cssClassNames.grandTotal, options.cell.type === 'GT');
                if (options.cell.width)
                    options.cellElement.css("min-width", options.cell.width);
                if (options.cell.sorted)
                    $('<span>').addClass("dx-icon-sorted").appendTo(options.cellElement)
            },
            _renderTableContent: function(tableElement, data) {
                var that = this,
                    rowsCount = data.length,
                    row,
                    cell,
                    i,
                    j,
                    rowElement,
                    cellElement,
                    rtlEnabled = that.option("rtlEnabled"),
                    theadElement = $('<thead>').addClass(this._getAreaClassName());
                tableElement.width('auto');
                for (i = 0; i < rowsCount; i++) {
                    row = data[i];
                    rowElement = that._createRow();
                    for (j = 0; j < row.length; j++) {
                        cell = row[j];
                        cellElement = that._createCell(cell);
                        that._textCellRender(cellElement, cell.text);
                        that._applyCustomStyles({
                            cellElement: cellElement,
                            cell: cell,
                            cellsCount: row.length,
                            cellIndex: j,
                            rowElement: rowElement,
                            rowIndex: i,
                            rowsCount: rowsCount,
                            rtlEnabled: rtlEnabled
                        });
                        rowElement.append(cellElement)
                    }
                    theadElement.append(rowElement)
                }
                tableElement.append(theadElement);
                that.callBase.apply(that, arguments)
            },
            _getEventsNamespace: function() {
                return 'dxHeadersArea'
            },
            setVirtualContentParams: function(params) {
                this.callBase(params);
                this.tableElement().css({
                    left: params.left,
                    top: 0
                });
                this._virtualContentWidth = params.width
            },
            hasScroll: function() {
                var tableWidth = this._virtualContent ? this._virtualContentWidth : this._tableWidth;
                if (this._groupWidth && tableWidth)
                    return tableWidth - this._groupWidth >= 1;
                return false
            },
            processScroll: function() {
                if (!this._groupElement.data('dxScrollable')) {
                    this._groupElement.dxScrollable({
                        useNative: true,
                        useSimulatedScrollbar: false,
                        showScrollbar: false,
                        bounceEnabled: false,
                        direction: "horizontal"
                    });
                    this._groupElement.find('.dx-scrollable-container').css('overflow', 'hidden')
                }
            },
            processScrollBarSpacing: function(scrollBarWidth) {
                var that = this;
                if (that._groupWidth)
                    that.groupWidth(that._groupWidth - scrollBarWidth);
                if (that._scrollBarWidth)
                    that._groupElement.next().remove();
                that._groupElement.toggleClass(pivotGrid.cssClassNames.verticalScroll, scrollBarWidth > 0);
                that._groupElement.css('float', 'left').width(that._groupHeight);
                that._scrollBarWidth = scrollBarWidth
            },
            ctor: function(component) {
                this.callBase(component);
                this._scrollBarWidth = 0
            },
            getScrollPath: function(offset) {
                var tableElement = this.tableElement(),
                    cell;
                offset -= parseInt(tableElement[0].style.left, 10) || 0;
                $.each(tableElement.find("td"), function(_, td) {
                    if (td.colSpan === 1 && td.offsetLeft < offset && td.offsetWidth + td.offsetLeft > offset) {
                        cell = td;
                        return false
                    }
                });
                return getCellPath(tableElement, cell)
            },
            setDataController: function(dataController) {
                this._dataSource = dataController;
                return this
            }
        });
        pivotGrid.VerticalHeadersArea = pivotGrid.HorizontalHeadersArea.inherit({
            _getAreaClassName: function() {
                return pivotGrid.cssClassNames.headersVertical
            },
            _applyCustomStyles: function(options) {
                var cellElement = options.cellElement;
                this.callBase(options);
                cellElement.addClass(options.cellIndex === options.cellsCount - 1 ? pivotGrid.cssClassNames.headersVerticalLastCell : null);
                if (options.rowIndex === options.rowsCount - 1)
                    cellElement.css('border-bottom', '0px');
                if (options.rowIndex !== 0 && options.cell.expanded)
                    options.rowElement.addClass(pivotGrid.cssClassNames.headersVerticalExpandBorder)
            },
            _getAreaName: function() {
                return "row"
            },
            _getEventsNamespace: function() {
                return 'dxVerticalHeadersArea'
            },
            setVirtualContentParams: function(params) {
                this.callBase(params);
                this.tableElement().css({
                    top: params.top,
                    left: 0
                });
                this._virtualContentHeight = params.height
            },
            hasScroll: function() {
                var tableHeight = this._virtualContent ? this._virtualContentHeight : this._tableHeight;
                if (this._groupHeight && tableHeight)
                    return tableHeight - this._groupHeight >= 1;
                return false
            },
            processScroll: function() {
                if (!this._groupElement.data('dxScrollable')) {
                    this._groupElement.dxScrollable({
                        useNative: true,
                        useSimulatedScrollbar: false,
                        showScrollbar: false,
                        bounceEnabled: false,
                        direction: "vertical"
                    });
                    this._groupElement.find('.dx-scrollable-container').css('overflow', 'hidden')
                }
            },
            processScrollBarSpacing: function(scrollBarWidth) {
                var that = this;
                if (that._groupHeight)
                    that.groupHeight(that._groupHeight - scrollBarWidth);
                if (that._scrollBarWidth)
                    that._groupElement.next().remove();
                if (scrollBarWidth)
                    that._groupElement.after($('<div>').width('100%').height(scrollBarWidth - 1));
                that._scrollBarWidth = scrollBarWidth
            },
            getScrollPath: function(offset) {
                var tableElement = this.tableElement(),
                    cell;
                offset -= parseInt(tableElement[0].style.top, 10) || 0;
                $.each(tableElement.find("tr"), function(_, tr) {
                    var td = tr.childNodes[tr.childNodes.length - 1];
                    if (td && td.rowSpan === 1 && td.offsetTop < offset && td.offsetHeight + td.offsetTop > offset) {
                        cell = td;
                        return false
                    }
                });
                return getCellPath(tableElement, cell)
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.dataArea.js */
    (function($, DX) {
        var pivotGrid = DX.ui.dxPivotGrid;
        pivotGrid.DataArea = pivotGrid.AreaItem.inherit({
            _getAreaName: function() {
                return "data"
            },
            _createGroupElement: function() {
                return $('<div>').addClass(pivotGrid.cssClassNames.area).addClass(pivotGrid.cssClassNames.areaData)
            },
            _renderTableContent: function(tableElement, data) {
                var i,
                    j,
                    row,
                    cell,
                    cellText,
                    tableContentHTML = '',
                    style,
                    encodeHtml = this.option("encodeHtml"),
                    classNames;
                for (i = 0; i < data.length; i++) {
                    tableContentHTML += '<tr>';
                    row = data[i];
                    for (j = 0; j < row.length; j++) {
                        cell = row[j];
                        classNames = [];
                        style = '';
                        if (i === data.length - 1)
                            style = 'border-bottom: 0px';
                        if (cell) {
                            if (cell.rowType === 'T' || cell.columnType === 'T')
                                classNames.push(pivotGrid.cssClassNames.total);
                            if (cell.rowType === 'GT' || cell.columnType === 'GT')
                                classNames.push(pivotGrid.cssClassNames.grandTotal);
                            if (cell.rowType === 'T' || cell.rowType === 'GT')
                                classNames.push(pivotGrid.cssClassNames.rowTotal);
                            cellText = cell.text || '';
                            if (encodeHtml && (cellText.indexOf("<") !== -1 || cellText.indexOf(">") !== -1))
                                cellText = $("<div>").text(cellText).html();
                            if (cell.width) {
                                if (style)
                                    style += '; ';
                                style += 'min-width: ' + cell.width + 'px'
                            }
                        }
                        else
                            cellText = '';
                        tableContentHTML += '<td class="' + classNames.join(' ') + '" style="' + style + '">' + cellText + '</td>'
                    }
                    tableContentHTML += '</tr>'
                }
                tableElement.append(tableContentHTML);
                this.callBase.apply(this, arguments)
            },
            _processScrollCore: function(hasRowsScroll, hasColumnsScroll, useNativeScrolling) {
                var that = this,
                    groupElement = that._groupElement,
                    options = {
                        useNative: !!useNativeScrolling,
                        useSimulatedScrollbar: !useNativeScrolling,
                        direction: "both",
                        bounceEnabled: false
                    };
                if (hasColumnsScroll && !hasRowsScroll)
                    options.direction = "horizontal";
                else if (!hasColumnsScroll)
                    options.direction = "vertical";
                groupElement.dxScrollable(options)
            },
            processScroll: function(scrollBarWidth, hasRowsScroll, hasColumnsScroll, useNativeScrolling) {
                var that = this,
                    groupElement = that._groupElement;
                groupElement.css('border-top-width', 0);
                that._processScrollCore(hasRowsScroll, hasColumnsScroll, useNativeScrolling)
            },
            setVirtualContentParams: function(params) {
                this.callBase(params);
                this.tableElement().css({
                    top: params.top,
                    left: params.left
                })
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.fieldChooser.js */
    (function($, DX) {
        var ui = DX.ui,
            iconUtils = DX.require("/utils/utils.icon"),
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget"),
            pivotGrid = ui.dxPivotGrid,
            dataGrid = ui.dxDataGrid,
            inArray = $.inArray,
            each = $.each,
            DIV = "<div>";
        var ColumnsView = dataGrid.ColumnsView.inherit(dataGrid.sortingMixin).inherit(dataGrid.headerFilterMixin);
        var HeaderFilterView = dataGrid.HeaderFilterView;
        var FIELDCHOOSER_CLASS = "dx-pivotgridfieldchooser",
            FIELDCHOOSER_CONTAINER_CLASS = "dx-pivotgridfieldchooser-container";
        var processItems = function(groupItems, field) {
                var filterValues = [],
                    isTree = !!field.groupName;
                if (field.filterValues)
                    each(field.filterValues, function(_, filterValue) {
                        filterValues.push(commonUtils.isArray(filterValue) ? filterValue.join("/") : filterValue)
                    });
                pivotGrid.foreachTree(groupItems, function(items) {
                    var item = items[0],
                        path = pivotGrid.createPath(items),
                        preparedFilterValueByText = isTree ? $.map(items, function(item) {
                            return item.text
                        }).reverse().join("/") : item.text,
                        preparedFilterValue;
                    item.value = isTree ? path.slice(0) : item.key || item.value;
                    preparedFilterValue = isTree ? path.join("/") : item.value;
                    if ((item.key && inArray(preparedFilterValueByText, filterValues) > -1 || inArray(preparedFilterValue, filterValues) > -1) ^ field.filterType === "exclude")
                        item.selected = true;
                    if (item.children) {
                        item.items = item.children;
                        item.children = null
                    }
                })
            };
        function getDimensionFields(item, fields) {
            var result = [];
            if (item.items)
                for (var i = 0; i < item.items.length; i++)
                    result.push.apply(result, getDimensionFields(item.items[i], fields));
            else if (commonUtils.isDefined(item.index))
                result.push(fields[item.index]);
            return result
        }
        function getFirstItem(item, condition) {
            if (item.items)
                for (var i = 0; i < item.items.length; i++) {
                    var childrenItem = getFirstItem(item.items[i], condition);
                    if (childrenItem)
                        return childrenItem
                }
            if (condition(item))
                return item
        }
        var compareOrder = [function(a, b) {
                    var aValue = -!!a.isMeasure,
                        bValue = +!!b.isMeasure;
                    return aValue + bValue
                }, function(a, b) {
                    var aValue = -!!(a.items && a.items.length),
                        bValue = +!!(b.items && b.items.length);
                    return aValue + bValue
                }, function(a, b) {
                    var aValue = +!!(a.field && a.field.levels && a.field.levels.length),
                        bValue = -!!(b.field && b.field.levels && b.field.levels.length);
                    return aValue + bValue
                }, pivotGrid.getCompareFunction(function(item) {
                    return item.text
                })];
        function compareItems(a, b) {
            var result = 0,
                i = 0;
            while (!result && compareOrder[i])
                result = compareOrder[i++](a, b);
            return result
        }
        function getScrollable(container) {
            return container.find(".dx-scrollable").dxScrollable("instance")
        }
        registerComponent("dxPivotGridFieldChooser", ui, Widget.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        height: 400,
                        layout: 0,
                        dataSource: null,
                        texts: {
                            columnFields: Globalize.localize("dxPivotGrid-columnFields"),
                            rowFields: Globalize.localize("dxPivotGrid-rowFields"),
                            dataFields: Globalize.localize("dxPivotGrid-dataFields"),
                            filterFields: Globalize.localize("dxPivotGrid-filterFields"),
                            allFields: Globalize.localize("dxPivotGrid-allFields")
                        },
                        headerFilter: {
                            width: 252,
                            height: 300,
                            texts: {
                                emptyValue: Globalize.localize("dxDataGrid-headerFilterEmptyValue"),
                                ok: Globalize.localize("dxDataGrid-headerFilterOK"),
                                cancel: Globalize.localize("dxDataGrid-headerFilterCancel")
                            }
                        }
                    })
            },
            _refreshDataSource: function() {
                var that = this;
                that._expandedPaths = [];
                that._changedHandler = that._changedHandler || function() {
                    each(that._dataChangedHandlers, function(_, func) {
                        func()
                    })
                };
                if (that._dataSource) {
                    that._dataSource.off("changed", that._changedHandler);
                    that._dataSource = undefined
                }
                var dataSource = this.option("dataSource");
                if (dataSource && dataSource.fields && dataSource.load)
                    that._dataSource = dataSource;
                that._dataSource && that._dataSource.on("changed", that._changedHandler)
            },
            _init: function() {
                this.callBase();
                this._columnsView = new ColumnsView(this);
                this._headerFilterView = new HeaderFilterView(this);
                this._subscribeToEvents();
                this._refreshDataSource();
                this._dataChangedHandlers = []
            },
            _subscribeToEvents: function() {
                var that = this;
                that.element().on("dxclick", ".dx-area-field.dx-area-box", function(e) {
                    var field = $.extend(true, {}, $(e.currentTarget).data("field")),
                        isHeaderFilter = $(e.target).hasClass("dx-header-filter");
                    if (isHeaderFilter)
                        that._headerFilterView.showHeaderFilterMenu($(e.currentTarget), {
                            type: field.groupName ? 'tree' : 'list',
                            dataSource: {
                                load: function(options) {
                                    var userData = options.userData;
                                    if (userData.store)
                                        return userData.store.load(options);
                                    else {
                                        var d = $.Deferred();
                                        that._dataSource.getFieldValues(field.index).done(function(data) {
                                            userData.store = new DX.data.ArrayStore(data);
                                            userData.store.load(options).done(d.resolve).fail(d.reject)
                                        }).fail(d.reject);
                                        return d
                                    }
                                },
                                postProcess: function(data) {
                                    processItems(data, field);
                                    return data
                                }
                            },
                            filterValues: field.filterValues,
                            filterType: field.filterType,
                            apply: function() {
                                that._dataSource.field(field.index, {
                                    filterValues: this.filterValues,
                                    filterType: this.filterType
                                });
                                that._dataSource.load()
                            }
                        });
                    else if (field.allowSorting && field.area !== "data") {
                        that._dataSource.field(field.index, {sortOrder: field.sortOrder === "desc" ? "asc" : "desc"});
                        that._dataSource.load()
                    }
                })
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {dataSource: true})
            },
            _optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"dataSource":
                        that._refreshDataSource();
                        that._invalidate();
                        break;
                    case"layout":
                    case"texts":
                    case"headerFilter":
                        that._invalidate();
                        break;
                    default:
                        that.callBase(args)
                }
            },
            _clean: function() {
                this.element().children("." + FIELDCHOOSER_CONTAINER_CLASS).remove()
            },
            _renderContentImpl: function() {
                var that = this,
                    element = this.element(),
                    $col1,
                    $col2;
                element.addClass(FIELDCHOOSER_CLASS);
                that._dataChangedHandlers = [];
                that._renderSortable(element);
                that._headerFilterView.render(element);
                var $container = $(DIV).addClass(FIELDCHOOSER_CONTAINER_CLASS).appendTo(element);
                if (this.option("layout") === 0) {
                    $col1 = $(DIV).addClass("dx-col").appendTo($container);
                    $col2 = $(DIV).addClass("dx-col").appendTo($container);
                    this._renderArea($col1, "all");
                    this._renderArea($col1, "filter");
                    this._renderArea($col2, "row");
                    this._renderArea($col2, "column");
                    this._renderArea($col2, "data")
                }
                else if (this.option("layout") === 1) {
                    $col1 = $(DIV).addClass("dx-col").appendTo($container);
                    $col2 = $(DIV).addClass("dx-col").appendTo($container);
                    this._renderArea($col1, "all");
                    this._renderArea($col2, "filter");
                    this._renderArea($col2, "row");
                    this._renderArea($col2, "column");
                    this._renderArea($col2, "data")
                }
                else {
                    this._renderArea($container, "all");
                    $col1 = $(DIV).addClass("dx-col").appendTo($container);
                    $col2 = $(DIV).addClass("dx-col").appendTo($container);
                    this._renderArea($col1, "filter");
                    this._renderArea($col1, "row");
                    this._renderArea($col2, "column");
                    this._renderArea($col2, "data")
                }
                this.updateDimensions()
            },
            _renderSortable: function(element) {
                var that = this;
                that._createComponent(element, "dxSortable", {
                    itemSelector: ".dx-area-field",
                    itemContainerSelector: ".dx-area-field-container",
                    groupSelector: ".dx-area-fields",
                    itemRender: function($sourceItem, target) {
                        var $item;
                        if ($sourceItem.hasClass("dx-area-box")) {
                            $item = $sourceItem.clone();
                            $item.insertBefore($sourceItem)
                        }
                        else
                            $item = $(DIV).addClass("dx-area-field").addClass("dx-area-box").text($sourceItem.text());
                        if (target === "drag")
                            $item.width(element.find(".dx-area-field-container").first().width());
                        return $item
                    },
                    onDragging: function(e) {
                        var field = e.sourceElement.data("field"),
                            targetGroup = e.targetGroup;
                        e.cancel = false;
                        if (field.isMeasure === true) {
                            if (targetGroup === "column" || targetGroup === "row" || targetGroup === "filter")
                                e.cancel = true
                        }
                        else if (field.isMeasure === false && targetGroup === "data")
                            e.cancel = true
                    },
                    onChanged: function(e) {
                        var dataSource = that._dataSource,
                            field = e.sourceElement.data("field");
                        e.removeSourceElement = !!e.sourceGroup;
                        if (field) {
                            dataSource.field(field.index, {
                                area: e.targetGroup,
                                areaIndex: e.targetIndex
                            });
                            dataSource.load()
                        }
                    }
                })
            },
            _createTreeItems: function(fields, groupFieldNames, path) {
                var that = this,
                    isMeasure,
                    resultItems = [],
                    groupedItems = [],
                    groupFieldName = groupFieldNames[0],
                    fieldsByGroup = {};
                if (!groupFieldName)
                    each(fields, function(index, field) {
                        var icon;
                        if (field.isMeasure === true)
                            icon = "measure";
                        if (field.isMeasure === false)
                            icon = field.groupName ? "hierarchy" : "dimension";
                        resultItems.push({
                            index: field.index,
                            field: field,
                            key: field.dataField,
                            selected: commonUtils.isDefined(field.area),
                            text: field.caption || field.dataField,
                            icon: icon,
                            isMeasure: field.isMeasure,
                            isDefault: field.isDefault
                        })
                    });
                else {
                    each(fields, function(index, field) {
                        var groupName = field[groupFieldName] || "";
                        fieldsByGroup[groupName] = fieldsByGroup[groupName] || [];
                        fieldsByGroup[groupName].push(field);
                        if (isMeasure === undefined)
                            isMeasure = true;
                        isMeasure = isMeasure && field.isMeasure === true
                    });
                    each(fieldsByGroup, function(groupName, fields) {
                        var currentPath = path ? path + '.' + groupName : groupName;
                        var items = that._createTreeItems(fields, groupFieldNames.slice(1), currentPath);
                        if (groupName)
                            groupedItems.push({
                                key: groupName,
                                text: groupName,
                                path: currentPath,
                                isMeasure: items.isMeasure,
                                expanded: inArray(currentPath, that._expandedPaths) >= 0,
                                items: items
                            });
                        else
                            resultItems = items
                    });
                    resultItems = groupedItems.concat(resultItems);
                    resultItems.isMeasure = isMeasure
                }
                return resultItems
            },
            _createFieldsDataSource: function(dataSource) {
                var fields = dataSource && dataSource.fields() || [],
                    treeItems;
                fields = $.map(fields, function(field) {
                    return field.visible === false || commonUtils.isDefined(field.groupIndex) ? null : field
                });
                treeItems = this._createTreeItems(fields, ["dimension", "displayFolder"]);
                pivotGrid.foreachDataLevel(treeItems, function(items) {
                    items.sort(compareItems)
                }, 0, "items");
                return treeItems
            },
            _renderFieldsTreeView: function(container) {
                var that = this,
                    dataSource = that._dataSource,
                    treeView = that._createComponent(container, "dxTreeView", {
                        dataSource: that._createFieldsDataSource(dataSource),
                        showCheckBoxesMode: 'normal',
                        itemTemplate: function(itemData, itemIndex, itemElement) {
                            if (itemData.icon)
                                iconUtils.getImageContainer(itemData.icon).appendTo(itemElement);
                            $('<span>').toggleClass("dx-area-field", !itemData.items).data("field", itemData.field).text(itemData.text).appendTo(itemElement)
                        },
                        onItemCollapsed: function(e) {
                            var index = inArray(e.itemData.path, that._expandedPaths);
                            if (index >= 0)
                                that._expandedPaths.splice(index, 1)
                        },
                        onItemExpanded: function(e) {
                            var index = inArray(e.itemData.path, that._expandedPaths);
                            if (index < 0)
                                that._expandedPaths.push(e.itemData.path)
                        },
                        onItemSelected: function(e) {
                            var data = e.itemData,
                                field,
                                fields,
                                needSelectDefaultItem = true,
                                area;
                            if (data.items) {
                                if (data.selected) {
                                    treeView.unselectItem(data);
                                    return
                                }
                                fields = getDimensionFields(data, dataSource.fields());
                                for (var i = 0; i < fields.length; i++)
                                    if (fields[i].area) {
                                        needSelectDefaultItem = false;
                                        break
                                    }
                                if (needSelectDefaultItem) {
                                    var item = getFirstItem(data, function(item) {
                                            return item.isDefault
                                        }) || getFirstItem(data, function(item) {
                                            return commonUtils.isDefined(item.index)
                                        });
                                    item && treeView.selectItem(item);
                                    return
                                }
                            }
                            else {
                                field = dataSource.fields()[data.index];
                                if (data.selected)
                                    area = field.isMeasure ? "data" : "column";
                                if (field)
                                    fields = [field]
                            }
                            each(fields, function(_, field) {
                                dataSource.field(field.index, {
                                    area: area,
                                    areaIndex: undefined
                                })
                            });
                            dataSource.load()
                        }
                    }),
                    dataChanged = function() {
                        var scrollable = getScrollable(container),
                            scrollTop = scrollable ? scrollable.scrollTop() : 0;
                        treeView.option({dataSource: that._createFieldsDataSource(dataSource)});
                        scrollable = getScrollable(container);
                        if (scrollable) {
                            scrollable.scrollTo({y: scrollTop});
                            scrollable.update()
                        }
                    };
                that._dataChangedHandlers.push(dataChanged)
            },
            _renderField: function(field) {
                var that = this,
                    $fieldContent = $(DIV).addClass("dx-area-field-content").text(field.caption || field.dataField),
                    $fieldElement = $(DIV).addClass("dx-area-field").addClass("dx-area-box").data("field", field).append($fieldContent);
                if (field.area !== "data") {
                    if (field.allowSorting)
                        that._columnsView._applyColumnState({
                            name: 'sort',
                            rootElement: $fieldElement,
                            column: {
                                alignment: that.option("rtlEnabled") ? 'right' : 'left',
                                sortOrder: field.sortOrder === 'desc' ? 'desc' : 'asc'
                            },
                            showColumnLines: true
                        });
                    that._columnsView._applyColumnState({
                        name: 'headerFilter',
                        rootElement: $fieldElement,
                        column: {
                            alignment: that.option("rtlEnabled") ? 'right' : 'left',
                            filterValues: field.filterValues,
                            allowFiltering: field.allowFiltering
                        },
                        showColumnLines: true
                    })
                }
                return $fieldElement
            },
            _renderAreaFields: function($container, area) {
                var that = this,
                    dataSource = that._dataSource,
                    fields = dataSource ? dataSource.getAreaFields(area, true) : [];
                $container.empty();
                each(fields, function() {
                    that._renderField(this).appendTo($container)
                })
            },
            _renderArea: function(container, area) {
                var that = this,
                    $areaContainer = $(DIV).addClass("dx-area").appendTo(container),
                    caption = that.option("texts." + area + "Fields"),
                    $fieldsContainer,
                    $fieldsContent,
                    render;
                $("<span>").addClass("dx-area-icon").addClass("dx-area-icon-" + area).appendTo($areaContainer);
                $("<span>").html("&nbsp;").appendTo($areaContainer);
                $("<span>").addClass("dx-area-caption").text(caption).appendTo($areaContainer);
                $fieldsContainer = $(DIV).addClass("dx-area-fields").height(0).appendTo($areaContainer);
                if (area !== "all") {
                    $fieldsContent = $(DIV).addClass("dx-area-field-container").appendTo($fieldsContainer);
                    render = function() {
                        that._renderAreaFields($fieldsContent, area)
                    };
                    that._dataChangedHandlers.push(render);
                    render();
                    $fieldsContainer.attr("group", area).dxScrollable()
                }
                else {
                    $fieldsContainer.addClass("dx-treeview-border-visible");
                    that._renderFieldsTreeView($fieldsContainer)
                }
            },
            updateDimensions: function() {
                var $element = this.element(),
                    $container = $element.children(".dx-pivotgridfieldchooser-container"),
                    $cols = $element.find(".dx-col"),
                    $areaElements = $element.find(".dx-area-fields"),
                    $scrollableElements = $element.find(".dx-area .dx-scrollable"),
                    areaHeight;
                $areaElements.height(0);
                if (this.option("layout") === 0) {
                    areaHeight = Math.floor(($element.height() - $container.height()) / 3);
                    $areaElements.height(areaHeight);
                    $areaElements.eq(0).height($cols.eq(1).height() - $cols.eq(0).height() + areaHeight)
                }
                else if (this.option("layout") === 1) {
                    areaHeight = Math.floor(($element.height() - $container.height()) / 4);
                    $areaElements.height(areaHeight);
                    $areaElements.eq(0).height($cols.eq(1).height() - $cols.eq(0).height() + areaHeight)
                }
                else {
                    areaHeight = Math.floor(($element.height() - $container.height()) / 4);
                    $areaElements.height(areaHeight);
                    $areaElements.eq(0).height(areaHeight * 2)
                }
                $scrollableElements.dxScrollable("update")
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.export.js */
    (function($, DX) {
        var ui = DX.ui,
            Class = DevExpress.require("/class"),
            utils = DevExpress.require("/utils/utils.common"),
            pivotGrid = DX.ui.dxPivotGrid,
            emptyCell = {
                text: '',
                value: undefined,
                colspan: 1,
                rowspan: 1
            };
        pivotGrid.include({
            exportToExcel: function() {
                this._clientExporter && this._clientExporter.exportTo({
                    fileName: this.option("export.fileName"),
                    proxyUrl: this.option("export.proxyUrl"),
                    format: "EXCEL",
                    component: this
                })
            },
            _getLength: function(items) {
                var cellIndex,
                    cellCount = 0;
                for (cellIndex in items[0])
                    cellCount += items[0][cellIndex].colspan ? items[0][cellIndex].colspan : 1;
                return cellCount
            },
            _defaultSetter: function(value) {
                value = parseInt(value, 10);
                return !value ? 1 : value
            },
            _makeRowOffset: function(resultItems) {
                var offset = 0,
                    rowIndex = resultItems.length - 1,
                    row = resultItems[rowIndex],
                    cellIndex = row.length;
                $.each(resultItems, function(rowIndex) {
                    if (this[cellIndex] && this[cellIndex].rowspan + rowIndex > resultItems.length - 1)
                        offset = Math.max.apply(this, [this[cellIndex].colspan, offset])
                });
                for (var i = 0; i < offset; i++)
                    row.push(this._cloneItem(resultItems[resultItems.length - 2][cellIndex && cellIndex - 1 || 0]));
                if (offset > 0)
                    this._makeRowOffset(resultItems)
            },
            _cloneItem: function(item) {
                return $.extend({}, item, emptyCell)
            },
            _prepareItems: function(cols, items) {
                var i,
                    row,
                    cellIndex,
                    rowIndex,
                    resultItems = [];
                for (rowIndex in items) {
                    row = [];
                    resultItems.push(row);
                    do {
                        this._makeRowOffset(resultItems);
                        cellIndex = row.length;
                        row.push(items[rowIndex].shift());
                        if (row[row.length - 1]) {
                            row[row.length - 1].colspan = this._defaultSetter(row[row.length - 1].colspan);
                            row[row.length - 1].rowspan = this._defaultSetter(row[row.length - 1].rowspan)
                        }
                        else
                            row[row.length - 1] = $({}, emptyCell);
                        for (i = 1; i < row[cellIndex].colspan; i++)
                            row.push(this._cloneItem(row[row.length - 1]))
                    } while (items[rowIndex].length);
                    while (row.length < cols)
                        row.push(this._cloneItem(row[row.length - 1]))
                }
                return resultItems
            },
            _getAllItems: function(columnsInfo, rowsInfoItems, cellsInfo) {
                var cellIndex,
                    rowIndex,
                    sourceItems = columnsInfo.concat(cellsInfo),
                    rowsLength = this._getLength(rowsInfoItems),
                    colsLength = this._getLength(columnsInfo),
                    headerRowsCount = columnsInfo.length;
                for (rowIndex = 0; rowIndex < rowsInfoItems.length; rowIndex++)
                    for (cellIndex = rowsInfoItems[rowIndex].length - 1; cellIndex >= 0; cellIndex--) {
                        if (!utils.isDefined(sourceItems[rowIndex + headerRowsCount]))
                            sourceItems[rowIndex + headerRowsCount] = [];
                        sourceItems[rowIndex + headerRowsCount].splice(0, 0, $.extend({}, rowsInfoItems[rowIndex][cellIndex]))
                    }
                sourceItems[0].splice(0, 0, $.extend({}, emptyCell, {
                    alignment: this._options.rtlEnabled ? "right" : "left",
                    colspan: rowsLength,
                    rowspan: headerRowsCount
                }));
                return this._prepareItems(rowsLength + colsLength, sourceItems)
            },
            getDataProvider: function() {
                var columnsInfo = $.extend(true, [], this._dataController.getColumnsInfo(true)),
                    rowsInfoItems = $.extend(true, [], this._dataController.getRowsInfo(true)),
                    cellsInfo = this._dataController.getCellsInfo(true);
                return new ui.dxPivotGrid.DataProvider({
                        columns: columnsInfo,
                        groupColumns: null,
                        items: this._getAllItems(columnsInfo, rowsInfoItems, cellsInfo),
                        getVisibleIndex: 0
                    })
            }
        });
        pivotGrid.DataProvider = Class.inherit({
            _getCellParam: function(rowIndex, cellIndex, param) {
                var items = this._options.items,
                    item = items[rowIndex] && items[rowIndex][cellIndex];
                return item && item[param]
            },
            ctor: function(options) {
                this._options = options
            },
            ready: function() {
                var options = this._options;
                return $.when(options.items).done(function(items) {
                        var cellItem,
                            headerSize = items[0][0].rowspan,
                            columns = items[headerSize - 1];
                        for (var columnIndex in columns) {
                            columns[columnIndex].width = 100;
                            columns[columnIndex].alignment = columns[columnIndex].alignment || "center";
                            cellItem = options.items[headerSize + 1] && options.items[headerSize + 1][columnIndex];
                            if (cellItem) {
                                columns[columnIndex].dataType = cellItem.dataType || "string";
                                columns[columnIndex].format = cellItem.format;
                                columns[columnIndex].precision = cellItem.precision
                            }
                            else
                                columns[columnIndex].dataType = "string"
                        }
                        options.columns = columns;
                        options.items = items
                    })
            },
            getColumns: function() {
                return this._options.columns
            },
            getRowsCount: function() {
                return this._options.items.length
            },
            isGroupRow: function() {
                return false
            },
            isHeadersVisible: function() {
                return false
            },
            isTotalCell: function() {
                return false
            },
            getGroupLevel: function() {
                return 0
            },
            getCellMergin: function(rowIndex, cellIndex) {
                var items = this._options.items,
                    item = items[rowIndex] && items[rowIndex][cellIndex];
                return item ? {
                        colspan: item.colspan - 1,
                        rowspan: item.rowspan - 1
                    } : {
                        colspan: 0,
                        rowspan: 0
                    }
            },
            getFrozenArea: function() {
                var items = this._options.items;
                return {
                        x: items[0][0].colspan,
                        y: items[0][0].rowspan
                    }
            },
            getCellType: function(rowIndex, cellIndex) {
                var column = this._options.columns[cellIndex],
                    dataType = column && column.dataType;
                return dataType || "string"
            },
            getCellValue: function(rowIndex, cellIndex) {
                return this._getCellParam(rowIndex, cellIndex, "value", "")
            },
            getCellText: function(rowIndex, cellIndex) {
                return this._getCellParam(rowIndex, cellIndex, "text")
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.summaryDisplayModes.js */
    (function($, DX, NULL) {
        var pivotGrid = DX.ui.dxPivotGrid,
            foreachTree = pivotGrid.foreachTree,
            commonUtils = DX.require("/utils/utils.common"),
            isDefined = commonUtils.isDefined,
            findField = pivotGrid.findField,
            COLUMN = "column",
            ROW = "row",
            percentOfGrandTotal = function(e, dimension) {
                var parent = e.grandTotal(dimension);
                if (isDefined(e.value()))
                    return e.value() / parent.value();
                return NULL
            },
            percentOfParent = function(e, dimension) {
                var parent = e.parent(dimension),
                    parentValue = parent ? parent.value() : e.value();
                if (isDefined(e.value()))
                    return e.value() / parentValue;
                return NULL
            },
            createAbsoluteVariationExp = function(allowGrossGroup) {
                return function(e) {
                        var prevCell = e.prev(COLUMN, allowGrossGroup),
                            prevValue = prevCell && prevCell.value();
                        if (isDefined(prevValue) && isDefined(e.value()))
                            return e.value() - prevValue;
                        return NULL
                    }
            },
            createPercentVariationExp = function(allowGrossGroup) {
                var absoluteExp = createAbsoluteVariationExp(allowGrossGroup);
                return function(e) {
                        var absVar = absoluteExp(e);
                        return absVar !== NULL ? absVar / e.value() : NULL
                    }
            },
            summaryDictionary = {
                percentOfColumnTotal: function(e) {
                    return percentOfParent(e, ROW)
                },
                percentOfRowTotal: function(e) {
                    return percentOfParent(e, COLUMN)
                },
                percentOfColumnGrandTotal: function(e) {
                    return percentOfGrandTotal(e, ROW)
                },
                percentOfRowGrandTotal: function(e) {
                    return percentOfGrandTotal(e, COLUMN)
                },
                percentOfGrandTotal: function(e) {
                    return percentOfGrandTotal(e)
                }
            },
            createRunningTotalExpr = function(getValue, allowGrossGroupCalculation, direction) {
                return function(e) {
                        var prevCell = e.prev(direction === COLUMN ? ROW : COLUMN, allowGrossGroupCalculation),
                            value = getValue(e);
                        return (prevCell && prevCell.value(true) || 0) + (value || 0)
                    }
            },
            defaultExpr = function(e) {
                return e.value()
            };
        function getFieldPos(descriptions, field) {
            var fieldIndex,
                allFields,
                fieldParams = {index: -1};
            if (!commonUtils.isObject(field)) {
                allFields = descriptions.columns.concat(descriptions.rows).concat(descriptions.values);
                fieldIndex = findField(allFields, field);
                field = allFields[fieldIndex]
            }
            if (field) {
                fieldParams.area = field.area;
                fieldParams.index = $.inArray(field, descriptions[field.area === "data" ? "values" : field.area + "s"])
            }
            return fieldParams
        }
        function getPathFieldName(dimension) {
            return dimension === ROW ? "_rowPath" : "_columnPath"
        }
        var SummaryCell = function(columnPath, rowPath, data, descriptions, fieldIndex) {
                this._columnPath = columnPath;
                this._rowPath = rowPath;
                this._fieldIndex = fieldIndex;
                this._data = data;
                this._descriptions = descriptions;
                var cell = data.values && data.values[rowPath[0].index] && data.values[rowPath[0].index][columnPath[0].index];
                if (cell) {
                    cell.orginalCell = cell.orginalCell || cell.slice();
                    this._cell = cell
                }
            };
        SummaryCell.prototype = $.extend(SummaryCell.prototype, {
            _getPath: function(dimension) {
                return this[getPathFieldName(dimension)]
            },
            _getDimension: function(dimension) {
                dimension = dimension === ROW ? "rows" : "columns";
                return this._descriptions[dimension]
            },
            _getData: function(dimension) {
                dimension = dimension === ROW ? "rows" : "columns";
                return this._data[dimension]
            },
            _createCell: function(config) {
                var that = this;
                return new SummaryCell(config._columnPath || that._columnPath, config._rowPath || that._rowPath, that._data, that._descriptions, that._fieldIndex)
            },
            parent: function(direction) {
                var path = this._getPath(direction).slice(),
                    config = {};
                path.shift();
                if (path.length) {
                    config[getPathFieldName(direction)] = path;
                    return this._createCell(config)
                }
                return NULL
            },
            children: function(direction) {
                var path = this._getPath(direction).slice(),
                    item = path[0],
                    result = [],
                    cellConfig = {};
                if (item.children)
                    for (var i = 0; i < item.children.length; i++) {
                        cellConfig[getPathFieldName(direction)] = [item.children[i]].concat(path.slice());
                        result.push(this._createCell(cellConfig))
                    }
                return result
            },
            grandTotal: function(direction) {
                var config = {},
                    rowPath = this._rowPath,
                    columnPath = this._columnPath,
                    dimensionPath = this._getPath(direction),
                    pathFieldName = getPathFieldName(direction);
                if (!direction) {
                    config._rowPath = [rowPath[rowPath.length - 1]];
                    config._columnPath = [columnPath[columnPath.length - 1]]
                }
                else
                    config[pathFieldName] = [dimensionPath[dimensionPath.length - 1]];
                return this._createCell(config)
            },
            next: function(direction, allowGrossGroup) {
                var currentPath = this._getPath(direction),
                    item = currentPath[0],
                    parent = this.parent(direction),
                    siblings,
                    index;
                if (parent) {
                    index = $.inArray(item, currentPath[1].children);
                    siblings = parent.children(direction);
                    if (siblings[index + 1])
                        return siblings[index + 1]
                }
                if (allowGrossGroup && parent) {
                    do {
                        parent = parent.next(direction, allowGrossGroup);
                        siblings = parent ? parent.children(direction) : []
                    } while (parent && !siblings.length);
                    return siblings[0] || NULL
                }
                return NULL
            },
            prev: function(direction, allowGrossGroup) {
                var currentPath = this._getPath(direction),
                    item = currentPath[0],
                    parent = this.parent(direction),
                    siblings,
                    index;
                if (parent) {
                    index = $.inArray(item, currentPath[1].children);
                    siblings = parent.children(direction);
                    if (siblings[index - 1])
                        return siblings[index - 1]
                }
                if (allowGrossGroup && parent) {
                    do {
                        parent = parent.prev(direction, allowGrossGroup);
                        siblings = parent ? parent.children(direction) : []
                    } while (parent && !siblings.length);
                    return siblings[siblings.length - 1] || NULL
                }
                return NULL
            },
            cell: function() {
                return this._cell
            },
            field: function(area) {
                var path = this._getPath(area),
                    descriptions = this._getDimension(area),
                    field = descriptions[path.length - 2];
                return field || NULL
            },
            child: function(direction, fieldValue) {
                var children = this.children(direction),
                    childLevelField;
                for (var i = 0; i < children.length; i++) {
                    childLevelField = childLevelField || children[i].field(direction);
                    if (children[i].value(childLevelField) === fieldValue)
                        return children[i]
                }
                return NULL
            },
            slice: function(field, value) {
                var that = this,
                    config = {},
                    fieldPos = getFieldPos(this._descriptions, field),
                    area = fieldPos.area,
                    fieldIndex = fieldPos.index,
                    childItems,
                    path,
                    currentValue,
                    level,
                    sliceCell = NULL,
                    newPath = [];
                if (area === ROW || area === COLUMN) {
                    path = this._getPath(area).slice();
                    level = fieldIndex !== -1 && path.length - 2 - fieldIndex;
                    if (path[level]) {
                        newPath[path.length - 1] = path[path.length - 1];
                        for (var i = level; i >= 0; i--) {
                            if (path[i + 1]) {
                                childItems = path[i + 1].children || [];
                                currentValue = i === level ? value : path[i].value;
                                path[i] = undefined;
                                for (var childIndex = 0; childIndex < childItems.length; childIndex++)
                                    if (childItems[childIndex].value === currentValue) {
                                        path[i] = childItems[childIndex];
                                        break
                                    }
                            }
                            if (path[i] === undefined)
                                return sliceCell
                        }
                        config[getPathFieldName(area)] = path;
                        sliceCell = that._createCell(config)
                    }
                }
                return sliceCell
            },
            value: function() {
                var cell = this._cell,
                    fieldIndex = this._fieldIndex,
                    args = arguments,
                    fistArgIsBoolean = args[0] === true || args[0] === false,
                    path,
                    field = !fistArgIsBoolean ? args[0] : NULL,
                    needCalculatedValue = fistArgIsBoolean && args[0] || args[1],
                    level;
                if (field) {
                    var fieldPos = getFieldPos(this._descriptions, field);
                    fieldIndex = fieldPos.index;
                    if (fieldPos.area !== "data") {
                        path = this._getPath(fieldPos.area);
                        level = fieldIndex !== -1 && path.length - 2 - fieldIndex;
                        return path[level] && path[level].value
                    }
                }
                if (cell && cell.orginalCell)
                    return needCalculatedValue ? cell[fieldIndex] : cell.orginalCell[fieldIndex];
                return NULL
            }
        });
        function getExpression(field) {
            var summaryDisplayMode = field.summaryDisplayMode,
                crossGroupCalculation = field.allowCrossGroupCalculation,
                expression = NULL;
            if (commonUtils.isFunction(field.calculateSummaryValue))
                expression = field.calculateSummaryValue;
            else if (summaryDisplayMode) {
                if (summaryDisplayMode === "absoluteVariation")
                    expression = createAbsoluteVariationExp(crossGroupCalculation);
                else if (summaryDisplayMode === "percentVariation")
                    expression = createPercentVariationExp(crossGroupCalculation);
                else
                    expression = summaryDictionary[summaryDisplayMode];
                if (expression && summaryDisplayMode.indexOf("percent") !== -1)
                    field.format = field.format || "percent"
            }
            if (field.runningTotal) {
                expression = expression || defaultExpr;
                return createRunningTotalExpr(expression, crossGroupCalculation, field.runningTotal)
            }
            return expression
        }
        pivotGrid.applyDisplaySummaryMode = function(descriptions, data) {
            var expressions = [],
                columnElements = [{
                        index: data.grandTotalColumnIndex,
                        children: data.columns
                    }],
                rowElements = [{
                        index: data.grandTotalRowIndex,
                        children: data.rows
                    }],
                valueFields = descriptions.values;
            foreachTree(rowElements, function(rowPath) {
                var rowItem = rowPath[0];
                rowItem.isEmpty = true;
                foreachTree(columnElements, function(columnPath) {
                    var columnItem = columnPath[0],
                        expression,
                        expressionArg,
                        cell,
                        field;
                    columnItem.isEmpty = columnItem.isEmpty || [];
                    for (var i = 0; i < valueFields.length; i++) {
                        field = valueFields[i];
                        expression = expressions[i] = expressions[i] || getExpression(field);
                        if (expression) {
                            expressionArg = new SummaryCell(columnPath, rowPath, data, descriptions, i);
                            cell = expressionArg.cell();
                            if (cell) {
                                var value = cell[i] = expression(expressionArg);
                                if (columnItem.isEmpty[i] === undefined)
                                    columnItem.isEmpty[i] = true;
                                if (value === null || value === undefined)
                                    columnItem.isEmpty[i] = columnItem.isEmpty[i] && true;
                                else {
                                    columnItem.isEmpty[i] = false;
                                    rowItem.isEmpty = false
                                }
                            }
                        }
                    }
                }, false)
            }, false);
            data.isEmptyGrandTotalRow = rowElements[0].isEmpty;
            data.isEmptyGrandTotalColumn = columnElements[0].isEmpty
        };
        pivotGrid.Cell = SummaryCell;
        pivotGrid.summaryDictionary = summaryDictionary;
        pivotGrid.getExpression = getExpression
    })(jQuery, DevExpress, null);
    /*! Module widgets-web, file ui.scheduler.publisherMixin.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.publisherMixin", ["jquery"], function($) {
        var publisherMixin = {notifyObserver: function(subject, args) {
                    var observer = this.option("observer");
                    if (observer)
                        observer.fire(subject, args)
                }};
        return publisherMixin
    });
    /*! Module widgets-web, file ui.scheduler.appointmentTooltip.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointmentTooltip", ["jquery", "/ui/ui.tooltip", "/ui/widgets/ui.button", "/ui/templates/ui.template.function", "/ui/templates/ui.template.dynamic", "/ui/templates/ui.template.move"], function($, tooltip, Button, FunctionTempalte, DynamicTemplate, MoveTemplate) {
        var APPOINTMENT_TOOLTIP_CLASS = "dx-scheduler-appointment-tooltip",
            APPOINTMENT_TOOLTIP_TITLE_CLASS = "dx-scheduler-appointment-tooltip-title",
            APPOINTMENT_TOOLTIP_DATE_CLASS = "dx-scheduler-appointment-tooltip-date",
            APPOINTMENT_TOOLTIP_BUTTONS_CLASS = "dx-scheduler-appointment-tooltip-buttons";
        var appointmentTooltip = {
                show: function(appointmentData, singleAppointmentData, $appointment, instance) {
                    this.instance = instance;
                    var isAllDay = instance.appointmentTakesAllDay(appointmentData);
                    this._initDynamicTemplate(appointmentData, singleAppointmentData);
                    var template = instance._getTemplateByOption("appointmentTooltipTemplate");
                    this.hide();
                    this._$tooltip = $("<div>").appendTo(instance.element());
                    this._tooltip = instance._createComponent(this._$tooltip, "dxTooltip", {
                        _templates: instance.option("_templates"),
                        templateProvider: instance.option("templateProvider"),
                        visible: true,
                        target: $appointment,
                        rtlEnabled: instance.option("rtlEnabled"),
                        contentTemplate: new DynamicTemplate(function(container) {
                            return new MoveTemplate(template.render(appointmentData, container))
                        }),
                        position: {
                            my: "bottom",
                            at: "top",
                            of: $appointment,
                            boundary: isAllDay ? instance.element() : instance.getWorkSpaceScrollableContainer(),
                            collision: "fit flipfit"
                        }
                    })
                },
                hide: function() {
                    if (!this._$tooltip)
                        return;
                    this._$tooltip.remove();
                    delete this._$tooltip;
                    delete this._tooltip;
                    tooltip.hide()
                },
                _initDynamicTemplate: function(appointmentData, singleAppointmentData) {
                    var that = this;
                    this.instance._dynamicTemplates["appointmentTooltip"] = new FunctionTempalte(function(data, index, $container) {
                        var $tooltip = that._tooltipContent(appointmentData, singleAppointmentData);
                        $tooltip.addClass($container.attr("class"));
                        $container.replaceWith($tooltip);
                        return $container
                    })
                },
                _tooltipContent: function(appointmentData, singleAppointmentData) {
                    var $tooltip = $("<div>").addClass(APPOINTMENT_TOOLTIP_CLASS);
                    var isAllDay = this.instance.appointmentTakesAllDay(appointmentData);
                    $("<div>").text(appointmentData.text).addClass(APPOINTMENT_TOOLTIP_TITLE_CLASS).appendTo($tooltip);
                    $("<div>").addClass(APPOINTMENT_TOOLTIP_DATE_CLASS).text(this._formatTooltipDate(appointmentData.startDate, appointmentData.endDate, isAllDay)).appendTo($tooltip);
                    var $buttons = $("<div>").addClass(APPOINTMENT_TOOLTIP_BUTTONS_CLASS).appendTo($tooltip);
                    if (this.instance._editing.allowDeleting)
                        this._getDeleteButton(appointmentData, singleAppointmentData).appendTo($buttons);
                    this._getOpenButton(appointmentData, singleAppointmentData).appendTo($buttons);
                    return $tooltip
                },
                _formatTooltipDate: function(startDate, endDate, isAllDay) {
                    var formatType = this.instance.option("currentView") === "month" ? "DATETIME" : "TIME",
                        formattedString = "";
                    if (isAllDay)
                        formatType = "DATE";
                    this.instance.fire("formatDates", {
                        startDate: startDate,
                        endDate: endDate,
                        formatType: formatType,
                        callback: function(result) {
                            formattedString = result
                        }
                    });
                    return formattedString
                },
                _getDeleteButton: function(appointmentData, singleAppointmentData) {
                    var that = this;
                    return new Button($("<div>"), {
                            icon: "trash",
                            onClick: function() {
                                that.instance._checkRecurringAppointment(appointmentData, singleAppointmentData, singleAppointmentData.startDate, function() {
                                    that.instance.deleteAppointment(appointmentData)
                                }, true);
                                that.hide()
                            }
                        }).element()
                },
                _getOpenButton: function(appointmentData, singleAppointmentData) {
                    var that = this,
                        allowUpdating = that.instance._editing.allowUpdating;
                    return new Button($("<div>"), {
                            icon: allowUpdating ? "edit" : "",
                            text: Globalize.localize("dxScheduler-openAppointment"),
                            onClick: function() {
                                that.instance._checkRecurringAppointment(appointmentData, singleAppointmentData, singleAppointmentData.startDate, function() {
                                    that.instance.showAppointmentPopup(appointmentData)
                                }, false, true)
                            }
                        }).element()
                }
            };
        return appointmentTooltip
    });
    /*! Module widgets-web, file ui.scheduler.appointmentModel.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointmentModel", ["jquery", "/class", "/utils/utils.recurrence", "/utils/utils.date", "/utils/utils.common"], function($, Class, recurrenceUtils, dateUtils, commonUtils) {
        var AppointmentModel = Class.inherit({
                _resourceFilter: function(itemData, resources) {
                    var result = true;
                    for (var i = 0, len = resources.length; i < len; i++) {
                        var resourceField = resources[i].field,
                            resourceData = resources[i].data;
                        if (itemData.hasOwnProperty(resourceField))
                            if (!$.isArray(itemData[resourceField])) {
                                if ($.inArray(itemData[resourceField], resourceData) === -1) {
                                    result = false;
                                    break
                                }
                            }
                            else {
                                result = false;
                                for (var j = 0, itemDataCount = itemData[resourceField].length; j < itemDataCount; j++)
                                    if ($.inArray(itemData[resourceField][j], resourceData) > -1) {
                                        result = true;
                                        break
                                    }
                            }
                        else {
                            result = false;
                            break
                        }
                    }
                    return result
                },
                ctor: function(dataSource) {
                    this.setDataSource(dataSource)
                },
                setDataSource: function(dataSource) {
                    this._dataSource = dataSource
                },
                filterByDate: function(min, max, startDayHour, endDayHour, excludeAllDayAppointments) {
                    if (!this._dataSource)
                        return;
                    var filter = this._prepareDateFilter(min, max, startDayHour, endDayHour, excludeAllDayAppointments);
                    this._dataSource.filter(filter)
                },
                _prepareDateFilter: function(min, max, startDayHour, endDayHour, excludeAllDayAppointments) {
                    var ds = this._dataSource,
                        that = this;
                    return function(itemData) {
                            if ($.isFunction(ds._mapFunc))
                                itemData = ds._mapFunc(itemData);
                            var startDate = dateUtils.makeDate(itemData.startDate),
                                endDate = that._getEndDate(startDate, itemData.endDate),
                                rule = itemData.recurrenceRule,
                                isAllDay = itemData.allDay,
                                appointmentTakesAllDay = that.appointmentTakesAllDay(startDate, endDate, startDayHour, endDayHour),
                                recurrenceException = itemData.recurrenceException;
                            var stripDateTime = function(date) {
                                    date = new Date(date);
                                    dateUtils.correctDateWithUnitBeginning(date, "day");
                                    return date
                                };
                            if (excludeAllDayAppointments && (isAllDay || appointmentTakesAllDay))
                                return false;
                            var isRecurrenceRuleValid = recurrenceUtils.getRecurrenceRule(rule).isValid;
                            var result = endDate > min && startDate <= max && !isRecurrenceRuleValid || dateUtils.dateInRange(startDate, stripDateTime(min), max) && isAllDay || recurrenceUtils.dateInRecurrenceRange(rule, startDate, min, max, recurrenceException);
                            if (result && startDayHour)
                                result = startDate.getHours() >= startDayHour || endDate.getHours() >= startDayHour || isAllDay;
                            if (result && endDayHour)
                                result = startDate.getHours() <= endDayHour || isAllDay;
                            return result
                        }
                },
                _getEndDate: function(startDate, endDate) {
                    if (!commonUtils.isDefined(endDate))
                        endDate = new Date(startDate.getTime() + 0.5 * 3600000);
                    return dateUtils.makeDate(endDate)
                },
                appointmentTakesAllDay: function(startDate, endDate, startDayHour, endDayHour) {
                    startDate = new Date(startDate);
                    endDate = new Date(endDate);
                    var etalonDayDurationInHours = endDayHour - startDayHour,
                        appointmentDurationInHours = (endDate.getTime() - startDate.getTime()) / 3600000;
                    return appointmentDurationInHours >= etalonDayDurationInHours
                },
                filterByResources: function(resources) {
                    if (!this._dataSource)
                        return;
                    var filter = this._prepareResourcesFilter(resources);
                    this._dataSource.filter(filter)
                },
                _prepareResourcesFilter: function(resources) {
                    return $.proxy(function(itemData) {
                            return this._resourceFilter(itemData, resources)
                        }, this)
                },
                _getStoreKey: function(target) {
                    var store = this._dataSource.store();
                    return store.keyOf(target)
                },
                filterByDateAndResources: function(options) {
                    if (!this._dataSource)
                        return;
                    this._dataSource.filter($.proxy(function(itemData) {
                        var dateFilter = this._prepareDateFilter(options.min, options.max, options.startDayHour, options.endDayHour, options.excludeAllDayAppointments),
                            resourceFilter = this._prepareResourcesFilter(options.resources);
                        return dateFilter(itemData) && resourceFilter(itemData)
                    }, this))
                },
                add: function(data) {
                    return this._dataSource.store().insert(data).done($.proxy(function() {
                            this._dataSource.load()
                        }, this))
                },
                update: function(target, data) {
                    var key = this._getStoreKey(target);
                    return this._dataSource.store().update(key, data).done($.proxy(function() {
                            this._dataSource.load()
                        }, this))
                },
                remove: function(target) {
                    var key = this._getStoreKey(target);
                    return this._dataSource.store().remove(key).done($.proxy(function() {
                            this._dataSource.load()
                        }, this))
                }
            });
        return AppointmentModel
    });
    /*! Module widgets-web, file ui.scheduler.resourceManager.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.resourceManager", ["jquery", "/class", "/utils/utils.array", "/utils/utils.common"], function($, Class, arrayUtils, commonUtils) {
        var dataUtils = DevExpress.data.utils;
        var DEFAULT_VALUE_EXPR = "id",
            DEFAULT_DISPLAY_EXPR = "text";
        var ResourceManager = Class.inherit({
                _wrapDataSource: function(dataSource) {
                    if (dataSource instanceof DevExpress.data.DataSource)
                        return dataSource;
                    return new DevExpress.data.DataSource({
                            store: new DevExpress.data.ArrayStore(dataSource),
                            pageSize: 0
                        })
                },
                _mapResourceData: function(resource, data) {
                    var valueGetter = dataUtils.compileGetter(resource.valueExpr || DEFAULT_VALUE_EXPR),
                        displayGetter = dataUtils.compileGetter(resource.displayExpr || DEFAULT_DISPLAY_EXPR);
                    return $.map(data, function(item) {
                            return {
                                    id: valueGetter(item),
                                    text: displayGetter(item)
                                }
                        })
                },
                _isMultipleResource: function(resourceField) {
                    var result = false;
                    $.each(this.getResources(), function(_, resource) {
                        if (resource.field === resourceField) {
                            result = resource.allowMultiple;
                            return false
                        }
                    });
                    return result
                },
                ctor: function(resources) {
                    this.setResources(resources)
                },
                setResources: function(resources) {
                    this._resources = resources;
                    this._resourceFields = $.map(resources || [], function(resource) {
                        return resource.field
                    })
                },
                getResources: function() {
                    return this._resources || []
                },
                getEditors: function() {
                    var result = [];
                    $.each(this.getResources(), function(i, resource) {
                        result.push({
                            editorOptions: {
                                dataSource: resource.dataSource,
                                displayExpr: resource.displayExpr || DEFAULT_DISPLAY_EXPR,
                                valueExpr: resource.valueExpr || DEFAULT_VALUE_EXPR
                            },
                            dataField: resource.field,
                            editorType: resource.allowMultiple ? "dxTagBox" : "dxSelectBox",
                            label: {text: resource.label || resource.field}
                        })
                    });
                    return result
                },
                getResourceDataByValue: function(field, value) {
                    var result = $.Deferred(),
                        that = this;
                    $.each(this.getResources(), function(_, resource) {
                        if (resource.field === field) {
                            var dataSource = that._wrapDataSource(resource.dataSource);
                            dataSource.filter(resource.valueExpr || DEFAULT_VALUE_EXPR, value);
                            dataSource.load().done(function(data) {
                                result.resolve(data[0])
                            }).fail(function() {
                                result.reject()
                            });
                            return false
                        }
                    });
                    return result.promise()
                },
                getResourcesFromItem: function(itemData, wrapOnlyMultipleResources) {
                    var that = this,
                        result = null;
                    if (!commonUtils.isDefined(wrapOnlyMultipleResources))
                        wrapOnlyMultipleResources = false;
                    $.each(itemData, function(name) {
                        if ($.inArray(name, that._resourceFields) > -1) {
                            if (!result)
                                result = {};
                            if (!wrapOnlyMultipleResources || wrapOnlyMultipleResources && that._isMultipleResource(name))
                                result[name] = arrayUtils.wrapToArray(itemData[name]);
                            else
                                result[name] = itemData[name]
                        }
                    });
                    return result
                },
                getResourcesValueByFields: function(groups) {
                    var result = $.Deferred(),
                        that = this,
                        deferreds = [];
                    $.each(this.getResourcesByFields(groups), function(i, resource) {
                        var deferred = $.Deferred();
                        that._wrapDataSource(resource.dataSource).load().done(function(data) {
                            deferred.resolve({
                                name: resource.field,
                                items: that._mapResourceData(resource, data)
                            });
                            deferreds.push(deferred)
                        }).fail(function() {
                            deferred.reject()
                        })
                    });
                    $.when.apply(null, deferreds).done(function() {
                        result.resolve(Array.prototype.slice.call(arguments))
                    }).fail(function() {
                        result.reject()
                    });
                    return result.promise()
                },
                getResourceColor: function(field, value) {
                    var result = $.Deferred(),
                        color;
                    this.getResourceDataByValue(field, value).done(function(data) {
                        if (data)
                            color = data.color;
                        result.resolve(color)
                    }).fail(function() {
                        result.reject()
                    });
                    return result.promise()
                },
                getResourcesByFields: function(fields) {
                    return $.grep(this.getResources(), function(resource) {
                            return $.inArray(resource.field, fields) > -1
                        })
                },
                getResourceForPainting: function(groups) {
                    var resources = this.getResources(),
                        result;
                    $.each(resources, function(index, resource) {
                        if (resource.useColorAsDefault || resource.mainColor) {
                            result = resource;
                            return false
                        }
                    });
                    if (!result) {
                        if ($.isArray(groups) && groups.length)
                            resources = this.getResourcesByFields(groups);
                        result = resources[resources.length - 1]
                    }
                    return result
                }
            });
        return ResourceManager
    });
    /*! Module widgets-web, file ui.scheduler.recurrenceEditor.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.reccurenceEditor", ["jquery", "/class", "/utils/utils.recurrence", "/utils/utils.dom", "/utils/utils.common", "/componentRegistrator", "/ui/ui.editor", "/ui/widgets/ui.checkBox", "/ui/widgets/ui.radioGroup", "/ui/widgets/ui.switch", "/ui/widgets/ui.numberBox", "/ui/widgets/ui.selectBox", "/ui/widgets/date/ui.dateBox", "/ui/widgets/scheduler/ui.scheduler.publisherMixin"], function($, Class, recurrenceUtils, domUtils, commonUtils, registerComponent, Editor, CheckBox, RadioGroup, Switch, NumberBox, SelectBox, DateBox, publisherMixin) {
        var RECURRENCE_EDITOR = "dx-recurrence-editor",
            LABEL_POSTFIX = "-label",
            RECURRENCE_EDITOR_CONTAINER = "dx-recurrence-editor-container",
            SWITCH_EDITOR = "dx-recurrence-switch",
            SWITCH_REPEAT_END_EDITOR = "dx-recurrence-switch-repeat-end",
            FREQUENCY_EDITOR = "dx-recurrence-radiogroup-freq",
            INTERVAL_EDITOR = "dx-recurrence-numberbox-interval",
            INTERVAL_EDITOR_FIELD = "dx-recurrence-interval-field",
            REPEAT_END_EDITOR = "dx-recurrence-repeat-end",
            REPEAT_END_EDITOR_FIELD = "dx-recurrence-repeat-end-field",
            REPEAT_END_EDITOR_CONTAINER = "dx-recurrence-repeat-end-container",
            REPEAT_TYPE_EDITOR = "dx-recurrence-radiogroup-repeat-type",
            REPEAT_COUNT_EDITOR = "dx-recurrence-numberbox-repeat-count",
            REPEAT_UNTIL_DATE_EDITOR = "dx-recurrence-datebox-until-date",
            REPEAT_ON_EDITOR = "dx-recurrence-repeat-on",
            REPEAT_ON_WEEK_EDITOR = "dx-recurrence-repeat-on-week",
            DAY_OF_WEEK = "dx-recurrence-checkbox-day-of-week",
            REPEAT_ON_MONTH_EDITOR = "dx-recurrence-repeat-on-month",
            DAY_OF_MONTH = "dx-recurrence-numberbox-day-of-month",
            REPEAT_ON_YEAR_EDITOR = "dx-recurrence-repeat-on-year",
            MONTH_OF_YEAR = "dx-recurrence-selectbox-month-of-year",
            FIELD_CLASS = "dx-field",
            FIELD_LABEL_CLASS = "dx-field-label",
            FIELD_VALUE_CLASS = "dx-field-value",
            frequencies = [{
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceDaily")
                    },
                    value: "DAILY"
                }, {
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceWeekly")
                    },
                    value: "WEEKLY"
                }, {
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceMonthly")
                    },
                    value: "MONTHLY"
                }, {
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceYearly")
                    },
                    value: "YEARLY"
                }],
            repeatEndTypes = [{
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceRepeatCount")
                    },
                    value: "count"
                }, {
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceRepeatOnDate")
                    },
                    value: "until"
                }];
        var RecurrenceRule = Class.inherit({
                ctor: function(recurrence) {
                    this._recurrenceRule = recurrenceUtils.getRecurrenceRule(recurrence).rule
                },
                makeRules: function(string) {
                    var that = this;
                    that._recurrenceRule = recurrenceUtils.getRecurrenceRule(string).rule
                },
                makeRule: function(field, value) {
                    if (!value) {
                        delete this._recurrenceRule[field];
                        return
                    }
                    if (commonUtils.isDefined(field)) {
                        if (field === "until")
                            delete this._recurrenceRule.count;
                        if (field === "count")
                            delete this._recurrenceRule.until;
                        this._recurrenceRule[field] = value
                    }
                },
                repeatableRule: function() {
                    var rules = this._recurrenceRule;
                    if ("count" in rules)
                        return "count";
                    if ("until" in rules)
                        return "until";
                    return null
                },
                recurrenceString: function() {
                    return recurrenceUtils.getRecurrenceString(this._recurrenceRule)
                },
                rules: function() {
                    return this._recurrenceRule
                },
                daysFromByDayRule: function() {
                    return recurrenceUtils.daysFromByDayRule(this._recurrenceRule)
                }
            });
        var SchedulerRecurrenceEditor = Editor.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            value: null,
                            onValueChanged: null,
                            startDate: new Date
                        })
                },
                _createComponent: function(element, name, config) {
                    config = config || {};
                    this._extendConfig(config, {readOnly: this.option("readOnly")});
                    return this.callBase(element, name, config)
                },
                _init: function() {
                    this.callBase();
                    this._recurrenceRule = new RecurrenceRule(this.option("value"))
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(RECURRENCE_EDITOR);
                    this._renderSwitch();
                    this._$container = $("<div>").addClass(RECURRENCE_EDITOR_CONTAINER).appendTo(this.element());
                    this._renderEditors();
                    this._renderContainerVisibility(!!this.option("value"))
                },
                _renderSwitch: function() {
                    var $switchEditor = $("<div>").addClass(SWITCH_EDITOR);
                    this._switchEditor = this._createComponent($switchEditor, Switch, {
                        value: !!this.option("value"),
                        onValueChanged: $.proxy(this._switchValueChangeHandler, this)
                    });
                    this.element().append($switchEditor)
                },
                _switchValueChangeHandler: function(args) {
                    var value = args.value;
                    this._renderContainerVisibility(value);
                    if (!this.option("value") && value)
                        this._handleDefaults();
                    else if (!value) {
                        this._recurrenceRule.makeRules("");
                        this.option("value", undefined)
                    }
                },
                _renderContainerVisibility: function(value) {
                    if (value) {
                        this._$container.show();
                        this.notifyObserver("recurrenceEditorVisibylityChanged", {visible: true});
                        domUtils.triggerShownEvent(this._$container)
                    }
                    else {
                        this._$container.hide();
                        this.notifyObserver("recurrenceEditorVisibylityChanged", {visible: false})
                    }
                },
                _handleDefaults: function() {
                    this._recurrenceRule.makeRule("freq", "DAILY");
                    this.option("value", this._recurrenceRule.recurrenceString())
                },
                _renderEditors: function() {
                    this._renderFreqEditor();
                    this._renderIntervalEditor();
                    this._renderRepeatOnEditor();
                    this._renderRepeatEndSwitch();
                    this._renderRepeatEndEditor();
                    this._renderRepeatEndVisibility(!!this._recurrenceRule.repeatableRule())
                },
                _renderFreqEditor: function() {
                    var freq = this._recurrenceRule.rules().freq || "DAILY";
                    var $freqEditor = $("<div>").addClass(FREQUENCY_EDITOR).addClass(FIELD_VALUE_CLASS);
                    this._freqEditor = this._createComponent($freqEditor, RadioGroup, {
                        field: "freq",
                        items: frequencies,
                        value: freq,
                        valueExpr: "value",
                        displayExpr: "text",
                        layout: "horizontal",
                        onValueChanged: $.proxy(this._valueChangedHandler, this)
                    });
                    var $field = $("<div>").addClass(FIELD_CLASS).append($freqEditor);
                    this._$container.append($field)
                },
                _renderIntervalEditor: function() {
                    var freq = this._recurrenceRule.rules().freq || "DAILY";
                    var $intervalEditor = $("<div>").addClass(INTERVAL_EDITOR).addClass(FIELD_VALUE_CLASS);
                    var $intervalEditorLabel = $("<div>").text(Globalize.localize("dxScheduler-recurrenceEvery") + ":").addClass(INTERVAL_EDITOR + LABEL_POSTFIX).addClass(FIELD_LABEL_CLASS);
                    this._$intervalTypeLabel = $("<div>").text(Globalize.localize("dxScheduler-recurrenceRepeat" + freq.charAt(0).toUpperCase() + freq.substr(1).toLowerCase())).addClass(REPEAT_TYPE_EDITOR + LABEL_POSTFIX);
                    var interval = this._recurrenceRule.rules().interval || 1;
                    this._intervalEditor = this._createComponent($intervalEditor, NumberBox, {
                        field: "interval",
                        min: 1,
                        value: interval,
                        showSpinButtons: true,
                        useTouchSpinButtons: false,
                        onValueChanged: $.proxy(this._valueChangedHandler, this)
                    });
                    var $field = $("<div>").addClass(FIELD_CLASS).addClass(INTERVAL_EDITOR_FIELD).append($intervalEditorLabel, $intervalEditor, this._$intervalTypeLabel);
                    this._$container.append($field);
                    this._setAriaDescribedBy(this._intervalEditor, $intervalEditorLabel)
                },
                _renderRepeatOnEditor: function() {
                    var freq = this._recurrenceRule.rules().freq;
                    if (!commonUtils.isDefined(this._$repeatOnEditor))
                        this._$repeatOnEditor = $("<div>").addClass(REPEAT_ON_EDITOR).addClass(FIELD_CLASS).appendTo(this._$container);
                    if (!freq || freq === "DAILY") {
                        this._clearRepeatOnEditor();
                        this._clearRepeatOnLabel();
                        return
                    }
                    if (!commonUtils.isDefined(this._$repeatOnLabel))
                        this._renderRepeatOnLabel(this._$repeatOnEditor);
                    if (freq === "WEEKLY" && !this._$repeatOnWeek) {
                        this._renderRepeatOnWeekEditor();
                        return
                    }
                    if (freq === "MONTHLY" && !this._$repeatOnMonth) {
                        this._renderRepeatOnMonthEditor();
                        return
                    }
                    if (freq === "YEARLY" && !this._$repeatOnYear) {
                        this._renderRepeatOnYearEditor();
                        return
                    }
                },
                _renderRepeatOnLabel: function($element) {
                    this._$repeatOnLabel = $("<div>").text(Globalize.localize("dxScheduler-recurrenceOn") + ":").addClass(REPEAT_ON_EDITOR + LABEL_POSTFIX).addClass(FIELD_LABEL_CLASS);
                    $element.append(this._$repeatOnLabel)
                },
                _clearRepeatOnEditor: function() {
                    if (commonUtils.isDefined(this._$repeatOnWeek)) {
                        this._$repeatOnWeek.detach();
                        this._$repeatOnWeek.remove();
                        delete this._$repeatOnWeek
                    }
                    if (commonUtils.isDefined(this._$repeatOnMonth)) {
                        this._$repeatOnMonth.detach();
                        this._$repeatOnMonth.remove();
                        delete this._$repeatOnMonth
                    }
                    if (commonUtils.isDefined(this._$repeatOnYear)) {
                        this._$repeatOnYear.detach();
                        this._$repeatOnYear.remove();
                        delete this._$repeatOnYear
                    }
                },
                _clearRepeatOnEditorValues: function() {
                    this._recurrenceRule.makeRule("bymonth", "");
                    this._recurrenceRule.makeRule("bymonthday", "");
                    this._recurrenceRule.makeRule("byday", "")
                },
                _clearRepeatOnLabel: function() {
                    if (commonUtils.isDefined(this._$repeatOnLabel)) {
                        this._$repeatOnLabel.detach();
                        this._$repeatOnLabel.remove();
                        delete this._$repeatOnLabel
                    }
                },
                _renderRepeatOnWeekEditor: function() {
                    this._clearRepeatOnEditor();
                    this._$repeatOnWeek = $("<div>").addClass(REPEAT_ON_WEEK_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo(this._$repeatOnEditor);
                    var days = Globalize.culture().calendar.days.namesShort,
                        daysFromRules = this._daysOfWeekByRules();
                    this._daysOfWeek = [];
                    for (var i = 0; i < 7; i++) {
                        var checkBoxText = days[i].toUpperCase();
                        var $day = $("<div>").addClass(DAY_OF_WEEK),
                            day = this._createComponent($day, CheckBox, {
                                text: checkBoxText,
                                value: $.inArray(checkBoxText, daysFromRules) > -1 ? true : false,
                                onValueChanged: $.proxy(this._repeatByDayValueChangeHandler, this)
                            });
                        this._daysOfWeek[i] = day;
                        this._$repeatOnWeek.append($day)
                    }
                },
                _daysOfWeekByRules: function() {
                    var days = Globalize.culture().calendar.days.namesShort;
                    var daysByRule = this._recurrenceRule.daysFromByDayRule();
                    if (!daysByRule.length)
                        daysByRule = [days[this.option("startDate").getDay()].toUpperCase()];
                    return daysByRule
                },
                _repeatByDayValueChangeHandler: function() {
                    var byDayRule = "";
                    $.each(this._daysOfWeek, function(index, day) {
                        if (day.option("value")) {
                            var dayName = day.option("text");
                            if (!byDayRule)
                                byDayRule = dayName;
                            else
                                byDayRule = byDayRule + "," + dayName
                        }
                    });
                    this._recurrenceRule.makeRule("byday", byDayRule);
                    this.option("value", this._recurrenceRule.recurrenceString())
                },
                _renderRepeatOnMonthEditor: function() {
                    this._clearRepeatOnEditor();
                    this._$repeatOnMonth = $("<div>").addClass(REPEAT_ON_MONTH_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo(this._$repeatOnEditor);
                    this._renderDayOfMonthEditor(this._$repeatOnMonth)
                },
                _renderRepeatOnYearEditor: function() {
                    this._clearRepeatOnEditor();
                    this._$repeatOnYear = $("<div>").addClass(REPEAT_ON_YEAR_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo(this._$repeatOnEditor);
                    var months = [],
                        monthsNames = Globalize.culture().calendar.months.names;
                    for (var i = 0; i < 12; i++)
                        months[i] = {
                            value: String(i + 1),
                            text: monthsNames[i]
                        };
                    var bymonth = this._monthOfYearByRules();
                    var $monthOfYear = $("<div>").addClass(MONTH_OF_YEAR).appendTo(this._$repeatOnYear);
                    var monthChanged = function(args) {
                            this._valueChangedHandler.call(this, args);
                            var monthValue = parseInt(args.component.option("value"));
                            if (this._dayEditor && monthValue) {
                                var maxAllowedDay = new Date((new Date).getFullYear(), parseInt(monthValue), 0).getDate();
                                if (monthValue === 2)
                                    maxAllowedDay = 29;
                                this._dayEditor.option("max", maxAllowedDay)
                            }
                        };
                    this._monthEditor = this._createComponent($monthOfYear, SelectBox, {
                        field: "bymonth",
                        items: months,
                        value: bymonth,
                        displayExpr: "text",
                        valueExpr: "value",
                        onValueChanged: $.proxy(monthChanged, this)
                    });
                    this._renderDayOfMonthEditor(this._$repeatOnYear)
                },
                _monthOfYearByRules: function() {
                    var monthByRule = this._recurrenceRule.rules().bymonth;
                    if (!monthByRule)
                        monthByRule = this.option("startDate").getMonth();
                    return monthByRule
                },
                _renderDayOfMonthEditor: function($element) {
                    var bymonthday = this._dayOfMonthByRules();
                    var $dayEditor = $("<div>").addClass(DAY_OF_MONTH);
                    this._dayEditor = this._createComponent($dayEditor, NumberBox, {
                        field: "bymonthday",
                        min: 1,
                        max: 31,
                        showSpinButtons: true,
                        useTouchSpinButtons: false,
                        value: bymonthday,
                        onValueChanged: $.proxy(this._valueChangedHandler, this)
                    });
                    $element.append($dayEditor)
                },
                _dayOfMonthByRules: function() {
                    var dayByRule = this._recurrenceRule.rules().bymonthday;
                    if (!dayByRule)
                        dayByRule = this.option("startDate").getDate();
                    return dayByRule
                },
                _setAriaDescribedBy: function(editor, $label) {
                    var labelId = "label-" + new DevExpress.data.Guid;
                    editor.setAria("describedby", labelId);
                    editor.setAria("id", labelId, $label)
                },
                _renderRepeatEndSwitch: function() {
                    var that = this;
                    var $switchEndEditor = $("<div>").addClass(SWITCH_REPEAT_END_EDITOR).addClass(FIELD_VALUE_CLASS),
                        $switchEndLabel = $("<div>").text(Globalize.localize("dxScheduler-recurrenceEnd") + ":").addClass(INTERVAL_EDITOR + LABEL_POSTFIX).addClass(FIELD_LABEL_CLASS);
                    this._switchEndEditor = this._createComponent($switchEndEditor, Switch, {
                        value: that._recurrenceRule.repeatableRule() ? true : false,
                        onValueChanged: $.proxy(this._repeatEndSwitchValueChangeHandler, this)
                    });
                    $("<div>").addClass(FIELD_CLASS).addClass(REPEAT_END_EDITOR_FIELD).append($switchEndLabel, $switchEndEditor).appendTo(this._$container);
                    this._setAriaDescribedBy(this._switchEndEditor, $switchEndLabel)
                },
                _repeatEndSwitchValueChangeHandler: function(args) {
                    var value = args.value;
                    this._renderRepeatEndVisibility(value);
                    if (!this._recurrenceRule.rules().count && !this._recurrenceRule.rules().until && value)
                        this._handleRepeatEndDefaults();
                    else if (!value) {
                        this._recurrenceRule.makeRule("count", "");
                        this._recurrenceRule.makeRule("until", "");
                        this.option("value", this._recurrenceRule.recurrenceString())
                    }
                },
                _renderRepeatEndVisibility: function(value) {
                    if (!value)
                        this._$repeatEndEditor.hide();
                    else
                        this._$repeatEndEditor.show()
                },
                _handleRepeatEndDefaults: function() {
                    this._recurrenceRule.makeRule("count", 1);
                    this.option("value", this._recurrenceRule.recurrenceString())
                },
                _renderRepeatEndEditor: function(rule) {
                    rule = commonUtils.isDefined(rule) ? rule : this._recurrenceRule.repeatableRule();
                    if (!rule)
                        rule = "count";
                    if (!commonUtils.isDefined(this._$repeatEndEditor)) {
                        this._$repeatEndEditor = $("<div>").addClass(REPEAT_END_EDITOR_CONTAINER).addClass(FIELD_CLASS).appendTo(this._$container);
                        this._renderRepeatEndTypeEditor()
                    }
                },
                _renderRepeatEndTypeEditor: function() {
                    var repeatType = this._recurrenceRule.repeatableRule() || "count",
                        that = this;
                    this._$repeatTypeEditor = $("<div>").addClass(REPEAT_TYPE_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo(this._$repeatEndEditor);
                    this._repeatTypeEditor = this._createComponent(this._$repeatTypeEditor, RadioGroup, {
                        items: repeatEndTypes,
                        value: repeatType,
                        displayExpr: "text",
                        valueExpr: "value",
                        itemTemplate: function(itemData) {
                            if (itemData.value === "count")
                                return that._renderRepeatCountEditor();
                            else
                                return that._renderRepeatUntilEditor()
                        },
                        layout: "vertical",
                        onValueChanged: $.proxy(this._repeatTypeValueChangedHandler, this)
                    });
                    this._disableRepeatEndParts(repeatType)
                },
                _repeatTypeValueChangedHandler: function(args) {
                    var value = args.value;
                    this._disableRepeatEndParts(value);
                    if (value === "until")
                        this._recurrenceRule.makeRule(value, this._repeatUntilDate.option("value"));
                    else if (value === "count")
                        this._recurrenceRule.makeRule(value, this._repeatCountEditor.option("value"));
                    this.option("value", this._recurrenceRule.recurrenceString())
                },
                _disableRepeatEndParts: function(value) {
                    if (value === "until") {
                        this._repeatCountEditor.option("disabled", true);
                        this._repeatUntilDate.option("disabled", false)
                    }
                    else if (value === "count") {
                        this._repeatCountEditor.option("disabled", false);
                        this._repeatUntilDate.option("disabled", true)
                    }
                },
                _renderRepeatCountEditor: function() {
                    var repeatCount = this._recurrenceRule.rules().count || 1,
                        $editorTemplate = $("<div>");
                    $("<div>").text(Globalize.localize("dxScheduler-recurrenceAfter") + ":").addClass(REPEAT_END_EDITOR + LABEL_POSTFIX).appendTo($editorTemplate);
                    this._$repeatCountEditor = $("<div>").addClass(REPEAT_COUNT_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo($editorTemplate);
                    $("<div>").text(Globalize.localize("dxScheduler-recurrenceRepeatCount")).addClass(REPEAT_END_EDITOR + LABEL_POSTFIX).appendTo($editorTemplate);
                    this._repeatCountEditor = this._createComponent(this._$repeatCountEditor, NumberBox, {
                        field: "count",
                        min: 1,
                        showSpinButtons: true,
                        useTouchSpinButtons: false,
                        value: repeatCount,
                        onValueChanged: $.proxy(this._repeatCountValueChangeHandler, this)
                    });
                    return $editorTemplate
                },
                _repeatCountValueChangeHandler: function(args) {
                    if (this._recurrenceRule.repeatableRule() !== "count")
                        return;
                    var value = args.value;
                    this._recurrenceRule.makeRule("count", value);
                    this.option("value", this._recurrenceRule.recurrenceString())
                },
                _renderRepeatUntilEditor: function() {
                    var repeatUntil = this._recurrenceRule.rules().until || new Date,
                        $editorTemplate = $("<div>");
                    $("<div>").text(Globalize.localize("dxScheduler-recurrenceOn") + ":").addClass(REPEAT_END_EDITOR + LABEL_POSTFIX).appendTo($editorTemplate);
                    this._$repeatDateEditor = $("<div>").addClass(REPEAT_UNTIL_DATE_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo($editorTemplate);
                    this._repeatUntilDate = this._createComponent(this._$repeatDateEditor, DateBox, {
                        field: "until",
                        value: repeatUntil,
                        format: "date",
                        onValueChanged: $.proxy(this._repeatUntilValueChangeHandler, this)
                    });
                    return $editorTemplate
                },
                _repeatUntilValueChangeHandler: function(args) {
                    if (this._recurrenceRule.repeatableRule() !== "until")
                        return;
                    this._recurrenceRule.makeRule("until", args.value);
                    this.option("value", this._recurrenceRule.recurrenceString())
                },
                _valueChangedHandler: function(args) {
                    var value = args.component.option("value"),
                        field = args.component.option("field");
                    if (field === "freq")
                        this._clearRepeatOnEditorValues();
                    this._recurrenceRule.makeRule(field, value);
                    this._makeRepeatOnRule(field, value);
                    this.option("value", this._recurrenceRule.recurrenceString())
                },
                _makeRepeatOnRule: function(field, value) {
                    if (field !== "freq" || value === "DAILY")
                        return;
                    if (value === "WEEKLY")
                        this._recurrenceRule.makeRule("byday", this._daysOfWeekByRules());
                    if (value === "MONTHLY")
                        this._recurrenceRule.makeRule("bymonthday", this._dayOfMonthByRules());
                    if (value === "YEARLY") {
                        this._recurrenceRule.makeRule("bymonthday", this._dayOfMonthByRules());
                        this._recurrenceRule.makeRule("bymonth", this._monthOfYearByRules())
                    }
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"value":
                            this._recurrenceRule.makeRules(args.value);
                            this._switchEditor.option("value", !!args.value);
                            this._switchEndEditor.option("value", !!this._recurrenceRule.repeatableRule());
                            this._repeatTypeEditor.option("value", this._recurrenceRule.repeatableRule() || "count");
                            this._renderRepeatEndEditor();
                            this._renderRepeatOnEditor();
                            this._changeEditorsValues(this._recurrenceRule.rules());
                            this.callBase(args);
                            break;
                        case"startDate":
                            this._clearRepeatOnEditor();
                            this._renderRepeatOnEditor();
                            this._makeRepeatOnRule("freq", this._recurrenceRule.rules().freq);
                            this.option("value", this._recurrenceRule.recurrenceString());
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _changeEditorsValues: function(rules) {
                    this._freqEditor.option("value", rules.freq);
                    this._changeRepeatTypeLabel();
                    this._intervalEditor.option("value", rules.interval);
                    this._changeRepeatCountValue();
                    this._changeRepeatUntilValue();
                    this._changeCheckBoxesValue();
                    this._changeDayOfMonthValue();
                    this._changeMonthOfYearValue()
                },
                _changeRepeatTypeLabel: function() {
                    var $labels = this.element().find("." + REPEAT_TYPE_EDITOR + LABEL_POSTFIX);
                    if (!$labels.length)
                        return;
                    var freq = this._recurrenceRule.rules().freq || "DAILY";
                    $.each($labels, function(_, $label) {
                        $($label).text(Globalize.localize("dxScheduler-recurrenceRepeat" + freq.charAt(0).toUpperCase() + freq.substr(1).toLowerCase()))
                    })
                },
                _changeRepeatCountValue: function() {
                    if (!this._$repeatCountEditor)
                        return;
                    var count = this._recurrenceRule.rules().count || 1;
                    this._repeatCountEditor.option("value", count)
                },
                _changeRepeatUntilValue: function() {
                    if (!this._$repeatDateEditor)
                        return;
                    var date = this._recurrenceRule.rules().until || new Date;
                    this._repeatUntilDate.option("value", date)
                },
                _changeCheckBoxesValue: function() {
                    if (!this._$repeatOnWeek)
                        return;
                    var daysByRule = this._daysOfWeekByRules();
                    $.each(this._daysOfWeek, function(index, day) {
                        day.option("value", $.inArray(day.option("text"), daysByRule) > -1)
                    })
                },
                _changeDayOfMonthValue: function() {
                    if (!this._$repeatOnMonth && !this._$repeatOnYear)
                        return;
                    var day = this._dayOfMonthByRules() || 1;
                    this._dayEditor.option("value", day)
                },
                _changeMonthOfYearValue: function() {
                    if (!this._$repeatOnYear)
                        return;
                    var month = this._monthOfYearByRules() || 1;
                    this._monthEditor.option("value", month)
                },
                setAria: function() {
                    if (this._switchEditor)
                        this._switchEditor.setAria(arguments[0], arguments[1])
                }
            }).include(publisherMixin);
        registerComponent("dxSchedulerRecurrenceEditor", {}, SchedulerRecurrenceEditor);
        return SchedulerRecurrenceEditor
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.reccurenceEditor"]);
    /*! Module widgets-web, file ui.scheduler.navigator.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.navigator", ["jquery", "/ui/ui.errors", "/utils/utils.date", "/componentRegistrator", "/devices", "/ui/ui.widget", "/ui/widgets/ui.button", "/ui/widgets/date/ui.calendar", "/ui/widgets/scheduler/ui.scheduler.publisherMixin"], function($, errors, dateUtils, registerComponent, devices, Widget, Button, Calendar, publisherMixin) {
        var ELEMENT_CLASS = "dx-scheduler-navigator",
            CALENDAR_CLASS = "dx-scheduler-navigator-calendar",
            NEXT_BUTTON_CLASS = "dx-scheduler-navigator-next",
            CAPTION_BUTTON_CLASS = "dx-scheduler-navigator-caption",
            PREVIOUS_BUTTON_CLASS = "dx-scheduler-navigator-previous";
        var getWeekCaption = function(date, shift) {
                var firstWeekDate = dateUtils.getFirstWeekDate(date, shift ? this.option("firstDayOfWeek") || 1 : this.option("firstDayOfWeek")),
                    format = this.option("_useShortDateFormat") ? "d MMM yyyy" : "d MMMM yyyy",
                    lastWeekDate = new Date(firstWeekDate);
                shift = shift || 6;
                lastWeekDate = new Date(lastWeekDate.setDate(lastWeekDate.getDate() + shift));
                return Globalize.format(firstWeekDate, " d") + "-" + Globalize.format(lastWeekDate, format)
            };
        var CONFIG = {
                day: {
                    duration: 1,
                    setter: "setDate",
                    getter: "getDate",
                    getCaption: function(date) {
                        return Globalize.format(date, "d MMMM yyyy")
                    }
                },
                week: {
                    duration: 7,
                    setter: "setDate",
                    getter: "getDate",
                    getCaption: getWeekCaption
                },
                workWeek: {
                    duration: 7,
                    setter: "setDate",
                    getter: "getDate",
                    getCaption: function(date) {
                        return getWeekCaption.call(this, date, 4)
                    }
                },
                month: {
                    duration: 1,
                    setter: "setMonth",
                    getter: "getMonth",
                    getCaption: function(date) {
                        return Globalize.format(date, "MMMM yyyy")
                    }
                }
            };
        var SchedulerNavigator = Widget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            date: new Date,
                            step: "day",
                            min: undefined,
                            max: undefined,
                            firstDayOfWeek: undefined,
                            _useShortDateFormat: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return !devices.real().generic || devices.isSimulator()
                                },
                                options: {_useShortDateFormat: true}
                            }])
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"step":
                        case"date":
                            this._updateButtonsState();
                            this._renderCaption();
                            this._setCalendarOption("value", this.option("date"));
                            break;
                        case"min":
                        case"max":
                            this._updateButtonsState();
                            this._setCalendarOption(args.name, args.value);
                            break;
                        case"firstDayOfWeek":
                            this._setCalendarOption(args.name, args.value);
                            break;
                        case"tabIndex":
                        case"focusStateEnabled":
                            this._next.option(args.name, args.value);
                            this._caption.option(args.name, args.value);
                            this._prev.option(args.name, args.value);
                            this._setCalendarOption(args.name, args.value);
                            this.callBase(args);
                            break;
                        case"_useShortDateFormat":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _init: function() {
                    this.callBase();
                    this.element().addClass(ELEMENT_CLASS);
                    this._initButtons()
                },
                _initButtons: function() {
                    var $next = $("<div>").addClass(NEXT_BUTTON_CLASS);
                    this._next = this._createComponent($next, Button, {
                        icon: "chevronnext",
                        onClick: $.proxy(this._updateCurrentDate, this, 1),
                        focusStateEnabled: this.option("focusStateEnabled"),
                        tabIndex: this.option("tabIndex"),
                        _templates: {}
                    });
                    var $caption = $("<div>").addClass(CAPTION_BUTTON_CLASS);
                    this._caption = this._createComponent($caption, Button, {
                        focusStateEnabled: this.option("focusStateEnabled"),
                        tabIndex: this.option("tabIndex"),
                        _templates: {}
                    });
                    var $prev = $("<div>").addClass(PREVIOUS_BUTTON_CLASS);
                    this._prev = this._createComponent($prev, Button, {
                        icon: "chevronprev",
                        onClick: $.proxy(this._updateCurrentDate, this, -1),
                        focusStateEnabled: this.option("focusStateEnabled"),
                        tabIndex: this.option("tabIndex"),
                        _templates: {}
                    });
                    this.setAria("label", "Next period", $next);
                    this.setAria("label", "Previous period", $prev);
                    this._updateButtonsState();
                    this.element().append($prev, $caption, $next)
                },
                _updateButtonsState: function() {
                    var stepConfig = this._getConfig(),
                        date = this.option("date"),
                        min = this.option("min"),
                        max = this.option("max");
                    this._prev.option("disabled", min && date[stepConfig.getter]() === min[stepConfig.getter]());
                    this._next.option("disabled", max && date[stepConfig.getter]() === max[stepConfig.getter]())
                },
                _updateCurrentDate: function(direction) {
                    var stepConfig = this._getConfig(),
                        offset = stepConfig.duration * direction,
                        date = new Date(this.option("date"));
                    date[stepConfig.setter](date[stepConfig.getter]() + offset);
                    date = dateUtils.normalizeDate(date, this.option("min"), this.option("max"));
                    this.notifyObserver("updateCurrentDate", date)
                },
                _renderFocusTarget: $.noop,
                _render: function() {
                    this.callBase();
                    this._renderPopover();
                    this._renderCaption();
                    this._renderCaptionKeys()
                },
                _renderPopover: function() {
                    this._popover = this._createComponent("<div>", "dxPopover", {
                        target: this._caption.element(),
                        onContentReady: $.proxy(this._popoverContentReadyHandler, this)
                    });
                    this._popover.element().appendTo(this.element())
                },
                _popoverContentReadyHandler: function() {
                    this._calendar = this._createComponent($("<div>"), Calendar, this._calendarOptions());
                    this._calendar.element().addClass(CALENDAR_CLASS);
                    this._popover.content().append(this._calendar.element())
                },
                _calendarOptions: function() {
                    return {
                            min: this.option("min"),
                            max: this.option("max"),
                            firstDayOfWeek: this.option("firstDayOfWeek"),
                            value: this.option("date"),
                            focusStateEnabled: this.option("focusStateEnabled"),
                            onValueChanged: $.proxy(function(e) {
                                this.notifyObserver("updateCurrentDate", e.value);
                                this._popover.hide()
                            }, this),
                            _keyboardProcessor: this._calendarKeyboardProcessor
                        }
                },
                _renderCaption: function() {
                    var date = this.option("date"),
                        caption = this._getConfig().getCaption.call(this, date);
                    this._caption.option({
                        text: caption,
                        onClick: $.proxy(function() {
                            this._popover.toggle()
                        }, this)
                    })
                },
                _renderCaptionKeys: function() {
                    if (!this.option("focusStateEnabled") || this.option("disabled"))
                        return;
                    this._calendarKeyboardProcessor = this._caption._keyboardProcessor.attachChildProcessor();
                    this._setCalendarOption("_keyboardProcessor", this._calendarKeyboardProcessor);
                    var keyboardHandler = $.proxy(function(e) {
                            if (this._popover.content().is(":hidden"))
                                this._popover.show();
                            else
                                return true
                        }, this);
                    this._caption.registerKeyHandler("enter", keyboardHandler);
                    this._caption.registerKeyHandler("space", keyboardHandler)
                },
                _setCalendarOption: function(name, value) {
                    if (this._calendar)
                        this._calendar.option(name, value)
                },
                _getConfig: function() {
                    var step = this.option("step"),
                        config = CONFIG[step];
                    if (!config)
                        throw errors.Error("E1033", step);
                    return config
                }
            }).include(publisherMixin);
        registerComponent("dxSchedulerNavigator", {}, SchedulerNavigator);
        return SchedulerNavigator
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.navigator"]);
    /*! Module widgets-web, file ui.scheduler.header.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.header", ["jquery", "/utils/utils.common", "/utils/utils.inflector", "/componentRegistrator", "/ui/ui.widget", "/ui/widgets/scheduler/ui.scheduler.publisherMixin", "/ui/widgets/scheduler/ui.scheduler.navigator"], function($, commonUtils, inflector, registerComponent, Widget, publisherMixin, SchedulerNavigator) {
        var camelize = inflector.camelize;
        var COMPONENT_CLASS = "dx-scheduler-header",
            VIEW_SWITCHER_CLASS = "dx-scheduler-view-switcher",
            VIEW_SWITCHER_LABEL_CLASS = "dx-scheduler-view-switcher-label";
        var STEP_MAP = {
                day: "day",
                week: "week",
                workWeek: "workWeek",
                month: "month",
                timelineDay: "day",
                timelineWeek: "week",
                timelineWorkWeek: "workWeek",
                timelineMonth: "month"
            };
        var SchedulerHeader = Widget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            views: [],
                            currentView: "day",
                            firstDayOfWeek: undefined,
                            currentDate: new Date,
                            min: undefined,
                            max: undefined,
                            useDropDownViewSwitcher: false
                        })
                },
                _optionChanged: function(args) {
                    var value = args.value;
                    switch (args.name) {
                        case"views":
                            this._viewSwitcher.option("items", value);
                            break;
                        case"currentView":
                            this._viewSwitcher.option("selectedItem", value);
                            this._navigator.option("step", STEP_MAP[value]);
                            this._changeViewSwitcherLabelText();
                            break;
                        case"currentDate":
                            this._navigator.option("date", value);
                            break;
                        case"min":
                        case"max":
                        case"firstDayOfWeek":
                            this._navigator.option(args.name, value);
                            break;
                        case"tabIndex":
                        case"focusStateEnabled":
                            this._viewSwitcher.option(args.name, value);
                            this._navigator.option(args.name, value);
                            this.callBase(args);
                            break;
                        case"useDropDownViewSwitcher":
                            this._refreshViewSwitcher();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _init: function() {
                    this.callBase();
                    this.element().addClass(COMPONENT_CLASS)
                },
                _render: function() {
                    this.callBase();
                    this._renderNavigator();
                    this._renderViewSwitcher()
                },
                _renderNavigator: function() {
                    this._navigator = this._createComponent("<div>", SchedulerNavigator, {
                        min: this.option("min"),
                        max: this.option("max"),
                        date: this.option("currentDate"),
                        step: STEP_MAP[this.option("currentView")],
                        firstDayOfWeek: this.option("firstDayOfWeek"),
                        tabIndex: this.option("tabIndex"),
                        focusStateEnabled: this.option("focusStateEnabled"),
                        observer: this.option("observer")
                    });
                    this._navigator.element().appendTo(this.element())
                },
                _renderViewSwitcher: function() {
                    var $viewSwitcher = $("<div>").addClass(VIEW_SWITCHER_CLASS).appendTo(this.element());
                    if (!this.option("useDropDownViewSwitcher"))
                        this._renderViewSwitcherTabs($viewSwitcher);
                    else
                        this._renderViewSwitcherDropDownMenu($viewSwitcher)
                },
                _renderViewSwitcherTabs: function($element) {
                    this._viewSwitcher = this._createComponent($element, "dxTabs", {
                        selectionRequired: true,
                        scrollingEnabled: false,
                        onSelectionChanged: $.proxy(this._updateCurrentView, this),
                        items: this.option("views"),
                        itemTemplate: function(item) {
                            return $("<span>").addClass("dx-tab-text").text(Globalize.localize("dxScheduler-switcher" + camelize(item, true)))
                        },
                        selectedItem: this.option("currentView"),
                        tabIndex: this.option("tabIndex"),
                        focusStateEnabled: this.option("focusStateEnabled")
                    })
                },
                _refreshViewSwitcher: function() {
                    this._viewSwitcher._dispose();
                    this._viewSwitcher.element().remove();
                    delete this._viewSwitcher;
                    this._removeViewSwitcherLabel();
                    this._renderViewSwitcher()
                },
                _removeViewSwitcherLabel: function() {
                    if (commonUtils.isDefined(this._$viewSwitcherLabel)) {
                        this._$viewSwitcherLabel.detach();
                        this._$viewSwitcherLabel.remove();
                        delete this._$viewSwitcherLabel
                    }
                },
                _renderViewSwitcherDropDownMenu: function($element) {
                    this._$viewSwitcherLabel = $("<div>").addClass(VIEW_SWITCHER_LABEL_CLASS).appendTo(this.element());
                    this._changeViewSwitcherLabelText();
                    this._viewSwitcher = this._createComponent($element, "dxDropDownMenu", {
                        onItemClick: $.proxy(this._updateCurrentView, this),
                        items: this.option("views"),
                        itemTemplate: function(item) {
                            return $("<span>").addClass("dx-dropdownmenu-item-text").text(Globalize.localize("dxScheduler-switcher" + camelize(item, true)))
                        }
                    })
                },
                _changeViewSwitcherLabelText: function() {
                    if (!commonUtils.isDefined(this._$viewSwitcherLabel))
                        return;
                    var currentViewText = Globalize.localize("dxScheduler-switcher" + camelize(this.option("currentView"), true));
                    this._$viewSwitcherLabel.text(currentViewText)
                },
                _updateCurrentView: function(e) {
                    var selectedItem = e.itemData || e.component.option("selectedItem");
                    this.notifyObserver("currentViewUpdated", selectedItem)
                },
                _renderFocusTarget: $.noop
            }).include(publisherMixin);
        registerComponent("dxSchedulerHeader", {}, SchedulerHeader);
        return SchedulerHeader
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.header"]);
    /*! Module widgets-web, file ui.scheduler.workSpace.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.workSpace", ["jquery", "/ui/uiNamespace", "/utils/utils.date", "/ui/ui.widget", "/utils/utils.common", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.publisherMixin", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer"], function($, ui, dateUtils, Widget, commonUtils, registerComponent, publisherMixin, eventUtils, pointerEvents) {
        var abstract = Widget.abstract;
        var COMPONENT_CLASS = "dx-scheduler-work-space",
            GROUPED_WORKSPACE_CLASS = "dx-scheduler-work-space-grouped",
            WORKSPACE_WITH_BOTH_SCROLLS_CLASS = "dx-scheduler-work-space-both-scrollbar",
            TIME_PANEL_CLASS = "dx-scheduler-time-panel",
            TIME_PANEL_CELL_CLASS = "dx-scheduler-time-panel-cell",
            TIME_PANEL_ROW_CLASS = "dx-scheduler-time-panel-row",
            ALL_DAY_PANEL_CLASS = "dx-scheduler-all-day-panel",
            ALL_DAY_TABLE_CLASS = "dx-scheduler-all-day-table",
            FIXED_CONTAINER_CLASS = "dx-scheduler-fixed-appointments",
            ALL_DAY_CONTAINER_CLASS = "dx-scheduler-all-day-appointments",
            ALL_DAY_TITLE_CLASS = "dx-scheduler-all-day-title",
            ALL_DAY_TITLE_HIDDEN_CLASS = "dx-scheduler-all-day-title-hidden",
            ALL_DAY_TABLE_CELL_CLASS = "dx-scheduler-all-day-table-cell",
            ALL_DAY_TABLE_ROW_CLASS = "dx-scheduler-all-day-table-row",
            WORKSPACE_WITH_ALL_DAY_CLASS = "dx-scheduler-work-space-all-day",
            WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS = "dx-scheduler-work-space-all-day-collapsed",
            HEADER_PANEL_CLASS = "dx-scheduler-header-panel",
            HEADER_PANEL_CELL_CLASS = "dx-scheduler-header-panel-cell",
            HEADER_ROW_CLASS = "dx-scheduler-header-row",
            GROUP_ROW_CLASS = "dx-scheduler-group-row",
            GROUP_HEADER_CLASS = "dx-scheduler-group-header",
            DATE_TABLE_CLASS = "dx-scheduler-date-table",
            DATE_TABLE_CELL_CLASS = "dx-scheduler-date-table-cell",
            DATE_TABLE_ROW_CLASS = "dx-scheduler-date-table-row",
            DATE_TABLE_CURRENT_DATE_CLASS = "dx-scheduler-date-table-current-date",
            DATE_TABLE_OTHER_MONTH_DATE_CLASS = "dx-scheduler-date-table-other-month",
            DATE_TABLE_DROPPABLE_CELL_CLASS = "dx-scheduler-date-table-droppable-cell",
            SCHEDULER_HEADER_SCROLLABLE_CLASS = "dx-scheduler-header-scrollable",
            SCHEDULER_SIDEBAR_SCROLLABLE_CLASS = "dx-scheduler-sidebar-scrollable",
            SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS = "dx-scheduler-date-table-scrollable",
            SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME = eventUtils.addNamespace(pointerEvents.down, "dxSchedulerWorkSpace"),
            SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME = eventUtils.addNamespace("dxdragenter", "dxSchedulerDateTable"),
            SCHEDULER_CELL_DXDROP_EVENT_NAME = eventUtils.addNamespace("dxdrop", "dxSchedulerDateTable"),
            SCHEDULER_CELL_DXCLICK_EVENT_NAME = eventUtils.addNamespace("dxclick", "dxSchedulerDateTable"),
            CELL_DATA = "dxCellData";
        var SchedulerWorkSpace = Widget.inherit({
                _supportedKeys: function() {
                    var isRTL = this.option("rtlEnabled");
                    var click = function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (this._$focusedCell && this._$focusedCell.length)
                                this._showAddAppointmentPopup(this._$focusedCell)
                        };
                    return $.extend(this.callBase(), {
                            enter: click,
                            space: click,
                            downArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                var cellIndex = this._getFocusedCell().index(),
                                    $row = this._getFocusedCell().parent(),
                                    $cell = $row.next().children().eq(cellIndex);
                                this._moveToCell($cell)
                            },
                            upArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                var cellIndex = this._getFocusedCell().index(),
                                    $row = this._getFocusedCell().parent(),
                                    $cell = $row.prev().children().eq(cellIndex);
                                this._moveToCell($cell)
                            },
                            rightArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                var $cell = isRTL ? this._getFocusedCell().prev() : this._getFocusedCell().next();
                                this._moveToCell($cell)
                            },
                            leftArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                var $cell = isRTL ? this._getFocusedCell().next() : this._getFocusedCell().prev();
                                this._moveToCell($cell)
                            }
                        })
                },
                _getFocusedCell: function() {
                    return this._$focusedCell || this._$dateTable.find("." + DATE_TABLE_CELL_CLASS).eq(0)
                },
                _setFocusedCell: function($cell) {
                    if (!$cell.length)
                        return;
                    this._releaseFocusedCell();
                    this._toggleFocusClass(true, $cell);
                    if (commonUtils.isDefined(this._$focusedCell))
                        this.setAria("label", undefined, this._$focusedCell);
                    this._$focusedCell = $cell;
                    this.setAria("label", "Add appointment", this._$focusedCell)
                },
                _moveToCell: function($cell) {
                    this._setFocusedCell($cell);
                    this._dateTableScrollable.scrollToElement($cell)
                },
                _releaseFocusedCell: function() {
                    if (commonUtils.isDefined(this._$focusedCell))
                        this._toggleFocusClass(false, this._$focusedCell)
                },
                _focusTarget: function() {
                    return this.element()
                },
                _focusInHandler: function(e) {
                    if ($(e.target).is(this._focusTarget()) && this._isCellClick !== false) {
                        delete this._isCellClick;
                        this.callBase.apply(this, arguments);
                        var $cell = this._getFocusedCell();
                        this._setFocusedCell($cell)
                    }
                },
                _focusOutHandler: function(e) {
                    this.callBase.apply(this, arguments);
                    this._releaseFocusedCell()
                },
                _activeStateUnit: "." + DATE_TABLE_CELL_CLASS + ", ." + ALL_DAY_TABLE_CELL_CLASS,
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            currentDate: new Date,
                            firstDayOfWeek: undefined,
                            startDayHour: 0,
                            endDayHour: 24,
                            hoursInterval: 0.5,
                            activeStateEnabled: true,
                            hoverStateEnabled: true,
                            groups: [],
                            showAllDayPanel: true,
                            allDayExpanded: false,
                            onCellClick: null,
                            horizontalScrollingEnabled: false
                        })
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"startDayHour":
                        case"endDayHour":
                        case"hoursInterval":
                        case"firstDayOfWeek":
                        case"currentDate":
                        case"groups":
                            this._cleanView();
                            this._toggleGroupedClass();
                            this._renderView();
                            break;
                        case"showAllDayPanel":
                            this._toggleAllDayVisibility();
                            break;
                        case"allDayExpanded":
                            this._changeAllDayVisibility();
                            this.notifyObserver("allDayPanelToggled");
                            this._attachTablesEvents();
                            break;
                        case"onCellClick":
                            this._createCellClickAction();
                            break;
                        case"horizontalScrollingEnabled":
                            this._toggleHorizontalScrollClass();
                            break;
                        case"width":
                            this.callBase(args);
                            this._dimensionChanged();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _init: function() {
                    this.callBase();
                    this._toggleHorizontalScrollClass();
                    this.element().addClass(COMPONENT_CLASS).addClass(this._getElementClass());
                    this._createWorkSpaceUnits();
                    this._createDateTableScrollable();
                    this._createWorkSpaceElements()
                },
                _createWorkSpaceElements: function() {
                    if (this.option("horizontalScrollingEnabled"))
                        this._createWorkSpaceScrollableElements();
                    else
                        this._createWorkSpaceStaticElements()
                },
                _toggleHorizontalScrollClass: function() {
                    this.element().toggleClass(WORKSPACE_WITH_BOTH_SCROLLS_CLASS, this.option("horizontalScrollingEnabled"))
                },
                _createWorkSpaceUnits: function() {
                    this._$headerPanel = $("<table>").addClass(HEADER_PANEL_CLASS);
                    this._$thead = $("<thead>").appendTo(this._$headerPanel);
                    this._$fixedContainer = $("<div>").addClass(FIXED_CONTAINER_CLASS);
                    this._$allDayContainer = $("<div>").addClass(ALL_DAY_CONTAINER_CLASS);
                    this._$allDayTitle = $("<div>").addClass(ALL_DAY_TITLE_CLASS).text(Globalize.localize("dxScheduler-allDay")).appendTo(this.element());
                    this._$allDayTable = $("<table>").addClass(ALL_DAY_TABLE_CLASS);
                    this._$allDayPanel = $("<div>").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);
                    this._$timePanel = $("<table>").addClass(TIME_PANEL_CLASS);
                    this._$dateTable = $("<table>").addClass(DATE_TABLE_CLASS)
                },
                _createWorkSpaceStaticElements: function() {
                    this._dateTableScrollable.content().append(this._$timePanel, this._$dateTable);
                    this.element().append(this._$fixedContainer, this._$headerPanel, this._$allDayContainer, this._$allDayPanel, this._dateTableScrollable.element())
                },
                _createWorkSpaceScrollableElements: function() {
                    this.element().append(this._$fixedContainer);
                    this._createHeaderScrollable();
                    this._createSidebarScrollable();
                    this.element().append(this._dateTableScrollable.element());
                    this._headerScrollable.content().append(this._$headerPanel, this._$allDayContainer, this._$allDayPanel);
                    this._dateTableScrollable.content().append(this._$dateTable);
                    this._sidebarScrollable.content().append(this._$timePanel)
                },
                _createDateTableScrollable: function() {
                    var $dateTableScrollable = $("<div />").addClass(SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS),
                        scrollableConfig = this._createDateTableConfig();
                    this._dateTableScrollable = this._createComponent($dateTableScrollable, "dxScrollable", scrollableConfig)
                },
                _createDateTableConfig: function() {
                    var config = {
                            useKeyboard: false,
                            useNative: false,
                            bounceEnabled: false
                        };
                    if (this.option("horizontalScrollingEnabled")) {
                        config.direction = "both";
                        config.onScroll = $.proxy(function(e) {
                            this._sidebarScrollable.scrollTo({top: e.scrollOffset.top});
                            this._headerScrollable.scrollTo({left: e.scrollOffset.left})
                        }, this);
                        config.onEnd = $.proxy(function(e) {
                            this.notifyObserver("updateResizableArea", {})
                        }, this)
                    }
                    return config
                },
                _createHeaderScrollable: function() {
                    var $headerScrollable = $("<div />").addClass(SCHEDULER_HEADER_SCROLLABLE_CLASS).appendTo(this.element());
                    this._headerScrollable = this._createComponent($headerScrollable, "dxScrollable", {
                        useKeyboard: false,
                        showScrollbar: false,
                        direction: "horizontal",
                        useNative: false,
                        bounceEnabled: false,
                        onScroll: $.proxy(function(e) {
                            this._dateTableScrollable.scrollTo({left: e.scrollOffset.left})
                        }, this)
                    })
                },
                _createSidebarScrollable: function() {
                    var $timePanelScrollable = $("<div />").addClass(SCHEDULER_SIDEBAR_SCROLLABLE_CLASS).appendTo(this.element());
                    this._sidebarScrollable = this._createComponent($timePanelScrollable, "dxScrollable", {
                        useKeyboard: false,
                        showScrollbar: false,
                        direction: "vertical",
                        useNative: false,
                        bounceEnabled: false,
                        onScroll: $.proxy(function(e) {
                            this._dateTableScrollable.scrollTo({top: e.scrollOffset.top})
                        }, this)
                    })
                },
                _visibilityChanged: function(visible) {
                    if (visible && this.option("horizontalScrollingEnabled"))
                        this._setTablesWidth()
                },
                _setTablesWidth: function() {
                    var cellWidth = 75,
                        minWidth = this._getWorkSpaceMinWidth(),
                        $headerCells = this._$headerPanel.find("tr").last().find("th");
                    var width = cellWidth * $headerCells.length;
                    if (width < minWidth)
                        width = minWidth;
                    this._$headerPanel.width(width);
                    this._$dateTable.width(width);
                    this._$allDayTable.width(width)
                },
                _getWorkSpaceMinWidth: function() {
                    var minWidth = this._getWorkSpaceWidth(),
                        workspaceContainerWidth = this.element().outerWidth() - this.getTimePanelWidth();
                    if (minWidth < workspaceContainerWidth)
                        minWidth = workspaceContainerWidth;
                    return minWidth
                },
                _dimensionChanged: function(e) {
                    if (this.option("horizontalScrollingEnabled"))
                        this._setTablesWidth()
                },
                _getElementClass: $.noop,
                _getRowCount: $.noop,
                _getCellCount: $.noop,
                _render: function() {
                    this.callBase();
                    this._toggleGroupedClass();
                    this._renderView();
                    this._attachEvents()
                },
                _toggleGroupedClass: function() {
                    this.element().toggleClass(GROUPED_WORKSPACE_CLASS, this.option("groups").length > 0)
                },
                _renderView: function() {
                    this._setFirstViewDate();
                    this._renderGroupHeader();
                    this._renderDateHeader();
                    this._renderAllDayPanel();
                    this._renderTimePanel();
                    this._renderDateTable()
                },
                _setFirstViewDate: function() {
                    this._firstViewDate = dateUtils.getFirstWeekDate(this.option("currentDate"), this._firstDayOfWeek());
                    if (commonUtils.isDefined(this.option("startDayHour")))
                        this._firstViewDate.setHours(this.option("startDayHour"))
                },
                _firstDayOfWeek: function() {
                    return this.option("firstDayOfWeek")
                },
                _attachEvents: function() {
                    var that = this,
                        pointerDownAction = this._createAction(function(e) {
                            that._pointerDownHandler(e.jQueryEvent)
                        });
                    this._createCellClickAction();
                    var cellSelector = "." + DATE_TABLE_CELL_CLASS + ",." + ALL_DAY_TABLE_CELL_CLASS;
                    this.element().off(SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME).off(SCHEDULER_CELL_DXCLICK_EVENT_NAME).on(SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME, function(e) {
                        if (eventUtils.isMouseEvent(e) && e.which > 1) {
                            e.preventDefault();
                            return
                        }
                        pointerDownAction({jQueryEvent: e})
                    }).on(SCHEDULER_CELL_DXCLICK_EVENT_NAME, cellSelector, function(e) {
                        var $cell = $(e.target);
                        that._cellClickAction({
                            jQueryEvent: e,
                            cellElement: $cell,
                            cellData: that.getCellData($cell)
                        })
                    })
                },
                _createCellClickAction: function() {
                    var that = this;
                    this._cellClickAction = this._createActionByOption("onCellClick", {afterExecute: function(e) {
                            that._clickHandler(e.args[0].jQueryEvent)
                        }})
                },
                _clickHandler: function(e) {
                    var $target = $(e.target);
                    if (this._showPopup && this._hasFocusClass($target)) {
                        delete this._showPopup;
                        this._showAddAppointmentPopup($target)
                    }
                },
                _pointerDownHandler: function(e) {
                    var $target = $(e.target);
                    if (!$target.hasClass(DATE_TABLE_CELL_CLASS) && !$target.hasClass(ALL_DAY_TABLE_CELL_CLASS)) {
                        this._isCellClick = false;
                        return
                    }
                    this._isCellClick = true;
                    if (this._hasFocusClass($target))
                        this._showPopup = true;
                    else
                        this._setFocusedCell($target)
                },
                _showAddAppointmentPopup: function($cell) {
                    var cellData = this.getCellData($cell),
                        args = $.extend(cellData, cellData.groups);
                    delete args.groups;
                    this.notifyObserver("showAddAppointmentPopup", args)
                },
                _getGroupHeaderContainer: function() {
                    return this._$thead
                },
                _getDateHeaderContainer: function() {
                    return this._$thead
                },
                _renderGroupHeader: function() {
                    var $container = this._getGroupHeaderContainer();
                    var groupCount = this._getGroupCount();
                    if (groupCount) {
                        var groupRows = this._makeGroupRows(this.option("groups"));
                        this._attachGroupCountAttr(groupRows.length);
                        $container.append(groupRows)
                    }
                },
                _attachGroupCountAttr: function(groupRowCount) {
                    this.element().attr("dx-group-row-count", groupRowCount)
                },
                _makeGroupRows: function(groups) {
                    var repeatCount = 1,
                        groupCount = groups.length,
                        cellCount = this._getCellCount() || 1,
                        rows = [];
                    for (var i = 0; i < groupCount; i++) {
                        if (i > 0)
                            repeatCount = groups[i - 1].items.length * repeatCount;
                        var cells = this._makeGroupRowCells(groups[i].items, repeatCount);
                        rows.push($("<tr>").addClass(GROUP_ROW_CLASS).append(cells))
                    }
                    var maxCellCount = rows[groupCount - 1].find("th").length;
                    for (var j = 0; j < groupCount; j++) {
                        var $cell = rows[j].find("th"),
                            colspan = maxCellCount / $cell.length * cellCount;
                        if (colspan > 1)
                            $cell.attr("colspan", colspan)
                    }
                    return rows
                },
                _makeGroupRowCells: function(items, repeatCount) {
                    var cells = [],
                        itemCount = items.length;
                    for (var i = 0; i < repeatCount; i++)
                        for (var j = 0; j < itemCount; j++)
                            cells.push($("<th>").addClass(GROUP_HEADER_CLASS).text(items[j].text));
                    return cells
                },
                _renderDateHeader: function() {
                    var $container = this._getDateHeaderContainer(),
                        $headerRow = $("<tr>").addClass(HEADER_ROW_CLASS),
                        count = this._getCellCount(),
                        repeatCount = this._calculateHeaderCellRepeatCount();
                    for (var j = 0; j < repeatCount; j++)
                        for (var i = 0; i < count; i++) {
                            var text = this._getHeaderText(i),
                                $cell = $("<th>").text(text).addClass(HEADER_PANEL_CELL_CLASS).attr("title", text);
                            $headerRow.append($cell)
                        }
                    $container.append($headerRow);
                    return $headerRow
                },
                _calculateHeaderCellRepeatCount: function() {
                    return this._getGroupCount() || 1
                },
                _renderAllDayPanel: function() {
                    var cellCount = this._getCellCount() * (this._getGroupCount() || 1);
                    this._renderTableBody({
                        container: this._$allDayTable,
                        rowCount: 1,
                        cellCount: cellCount,
                        cellClass: ALL_DAY_TABLE_CELL_CLASS,
                        rowClass: ALL_DAY_TABLE_ROW_CLASS,
                        dataGenerator: $.proxy(this._setAllDayCellData, this)
                    });
                    this._toggleAllDayVisibility()
                },
                _setAllDayCellData: function($cell, rowIndex, cellIndex) {
                    var startDate = this._getDateByCellIndexes(rowIndex, cellIndex);
                    dateUtils.correctDateWithUnitBeginning(startDate, "day");
                    var data = {
                            startDate: startDate,
                            endDate: new Date(startDate.getTime() + 24 * 60 * 60000),
                            allDay: true
                        };
                    var groups = this._getCellGroups(this._getGroupIndex(rowIndex, cellIndex));
                    if (groups.length)
                        data.groups = {};
                    for (var i = 0; i < groups.length; i++)
                        data.groups[groups[i].name] = groups[i].id;
                    $cell.data(CELL_DATA, data)
                },
                _toggleAllDayVisibility: function() {
                    var showAllDayPanel = this.option("showAllDayPanel");
                    this._$allDayPanel.toggle(showAllDayPanel);
                    this._$allDayTitle.toggleClass(ALL_DAY_TITLE_HIDDEN_CLASS, !showAllDayPanel);
                    this.element().toggleClass(WORKSPACE_WITH_ALL_DAY_CLASS, showAllDayPanel);
                    this._changeAllDayVisibility()
                },
                _changeAllDayVisibility: function() {
                    this.element().toggleClass(WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS, !this.option("allDayExpanded") && this.option("showAllDayPanel"))
                },
                _renderTimePanel: function() {
                    var rowCount = 0.5 * this._getCellCountInDay();
                    this._renderTableBody({
                        container: this._$timePanel,
                        rowCount: rowCount,
                        cellCount: 1,
                        cellClass: TIME_PANEL_CELL_CLASS,
                        rowClass: TIME_PANEL_ROW_CLASS,
                        dataGenerator: $.proxy(this._setTimePanelText, this)
                    })
                },
                _getCellCountInDay: function() {
                    return Math.ceil(this._calculateDayDuration() / this.option("hoursInterval"))
                },
                _calculateDayDuration: function() {
                    return this.option("endDayHour") - this.option("startDayHour")
                },
                _setTimePanelText: function($td, i) {
                    $td.text(this._getTimeText(i))
                },
                _getTimeText: function(i) {
                    var startDayHour = this.option("startDayHour"),
                        cellDuration = 3600000 * this.option("hoursInterval") * 2,
                        date = new Date(new Date(1970, 0).getTime() + cellDuration * i + startDayHour * 3600000);
                    return Globalize.format(date, "t")
                },
                _renderDateTable: function() {
                    var groupCount = this._getGroupCount() || 1;
                    this._renderTableBody({
                        container: this._$dateTable,
                        rowCount: this._getTotalRowCount(groupCount),
                        cellCount: this._getTotalCellCount(groupCount),
                        cellClass: DATE_TABLE_CELL_CLASS,
                        rowClass: DATE_TABLE_ROW_CLASS,
                        dataGenerator: $.proxy(this._setCellData, this)
                    });
                    this._attachTablesEvents()
                },
                _getTotalCellCount: function(groupCount) {
                    return this._getCellCount() * groupCount
                },
                _getTotalRowCount: function(groupCount) {
                    return this._getRowCount()
                },
                _setCellData: function($cell, rowIndex, cellIndex) {
                    var startDate = this._getDateByCellIndexes(rowIndex, cellIndex),
                        endDate = this._calculateEndDate(startDate),
                        data = {
                            startDate: startDate,
                            endDate: endDate,
                            allDay: this._getTableAllDay()
                        };
                    $cell.toggleClass(DATE_TABLE_CURRENT_DATE_CLASS, this._isCurrentDate(startDate)).toggleClass(DATE_TABLE_OTHER_MONTH_DATE_CLASS, this._isOtherMonth(startDate));
                    var groups = this._getCellGroups(this._getGroupIndex(rowIndex, cellIndex));
                    if (groups.length)
                        data.groups = {};
                    for (var i = 0; i < groups.length; i++)
                        data.groups[groups[i].name] = groups[i].id;
                    $cell.data(CELL_DATA, data)
                },
                _getGroupIndex: function(rowIndex, cellIndex) {
                    return Math.floor(cellIndex / this._getCellCount())
                },
                _getTableAllDay: function() {
                    return false
                },
                _isCurrentDate: function(cellDate) {
                    var today = new Date;
                    return dateUtils.sameMonthAndYear(cellDate, today) && cellDate.getDate() === today.getDate()
                },
                _isOtherMonth: function(cellDate) {
                    return cellDate.getMonth() !== this.option("currentDate").getMonth()
                },
                _calculateEndDate: function(startDate) {
                    return new Date(startDate.getTime() + this._getInterval())
                },
                _getGroupCount: function() {
                    var groups = this.option("groups"),
                        result = 0;
                    for (var i = 0, len = groups.length; i < len; i++)
                        if (!i)
                            result = groups[i].items.length;
                        else
                            result *= groups[i].items.length;
                    return result
                },
                _getPathToLeaf: function(leafIndex) {
                    var tree = this._createGroupTree(this.option("groups")[0], 0);
                    function findLeafByIndex(data, index) {
                        for (var i = 0; i < data.length; i++)
                            if (data[i].leafIndex === index)
                                return data[i];
                            else {
                                var leaf = findLeafByIndex(data[i].children, index);
                                if (leaf)
                                    return leaf
                            }
                    }
                    function makeBranch(leaf, result) {
                        result = result || [];
                        result.push(leaf.value);
                        if (leaf.parent)
                            makeBranch(leaf.parent, result);
                        return result
                    }
                    var leaf = findLeafByIndex(tree, leafIndex);
                    return makeBranch(leaf).reverse()
                },
                _getCellGroups: function(groupIndex) {
                    var result = [];
                    if (this._getGroupCount()) {
                        var groups = this.option("groups");
                        if (groupIndex < 0)
                            return;
                        var path = this._getPathToLeaf(groupIndex);
                        for (var i = 0; i < groups.length; i++)
                            result.push({
                                name: groups[i].name,
                                id: path[i]
                            })
                    }
                    return result
                },
                _attachTablesEvents: function() {
                    this._attachTableEvents(this._getDateTable());
                    this._attachTableEvents(this._getAllDayTable())
                },
                _attachTableEvents: function($table) {
                    var that = this,
                        cellHeight,
                        cellWidth;
                    $table.off(SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME).off(SCHEDULER_CELL_DXDROP_EVENT_NAME).on(SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME, "td", {itemSizeFunc: function($element) {
                            if (!cellHeight)
                                cellHeight = $element.height();
                            if (!cellWidth)
                                cellWidth = $element.width();
                            return {
                                    width: cellWidth,
                                    height: cellHeight
                                }
                        }}, function(e) {
                        if (that._$currentTableTarget)
                            that._$currentTableTarget.removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);
                        that._$currentTableTarget = $(e.target);
                        that._$currentTableTarget.addClass(DATE_TABLE_DROPPABLE_CELL_CLASS)
                    }).on(SCHEDULER_CELL_DXDROP_EVENT_NAME, "td", function(e) {
                        $(e.target).removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);
                        cellHeight = 0;
                        cellWidth = 0
                    })
                },
                _getDateTables: function() {
                    return this._$dateTable.add(this._$allDayTable)
                },
                _getDateTable: function() {
                    return this._$dateTable
                },
                _getAllDayTable: function() {
                    return this._$allDayTable
                },
                _getInterval: function() {
                    return this.option("hoursInterval") * 3600000
                },
                _getHeaderText: function(headerIndex) {
                    return Globalize.format(this._getDateByIndex(headerIndex), this._getFormat())
                },
                _getDateByIndex: abstract,
                _getFormat: abstract,
                _getCellText: function(rowIndex, cellIndex) {
                    return ""
                },
                _calculateCellIndex: function(rowIndex, cellIndex) {
                    cellIndex = cellIndex % this._getCellCount();
                    var virtualRowCount = this._getVirtualSlotCount();
                    return (this._getRowCount() + virtualRowCount) * cellIndex + rowIndex
                },
                _getVirtualSlotCount: function() {
                    return this.option("startDayHour") / this.option("hoursInterval") + this._getEndDayHours() / this.option("hoursInterval")
                },
                _getEndDayHours: function() {
                    return 24 - this.option("endDayHour")
                },
                _getEndDayMilliseconds: function() {
                    return this._getEndDayHours() * 3600000
                },
                _renderTableBody: function(options) {
                    var rows = [];
                    for (var i = 0; i < options.rowCount; i++) {
                        var $row = $("<tr>");
                        if (options.rowClass)
                            $row.addClass(options.rowClass);
                        for (var j = 0; j < options.cellCount; j++) {
                            var $td = $("<td>").text(this._getCellText(i, j));
                            if (options.cellClass)
                                $td.addClass(options.cellClass);
                            if ($.isFunction(options.dataGenerator))
                                options.dataGenerator($td, i, j);
                            $row.append($td)
                        }
                        rows.push($row)
                    }
                    options.container.append($("<tbody>").append(rows))
                },
                _cleanView: function() {
                    this._$thead.empty();
                    this._$dateTable.empty();
                    this._$timePanel.empty();
                    this._$allDayTable.empty()
                },
                getWorkArea: function() {
                    return this._dateTableScrollable.content()
                },
                getScrollable: function() {
                    return this._dateTableScrollable
                },
                getScrollableScrollTop: function() {
                    return this._dateTableScrollable.scrollTop()
                },
                getScrollableScrollLeft: function() {
                    return this._dateTableScrollable.scrollLeft()
                },
                getScrollableContainer: function() {
                    return this._dateTableScrollable._container()
                },
                getHeaderPanelHeight: function() {
                    return this._$headerPanel.outerHeight(true)
                },
                getTimePanelWidth: function() {
                    return this._$timePanel.outerWidth()
                },
                _getCellCoordinatesByIndex: function(index) {
                    var cellIndex = Math.floor(index / this._getRowCount()),
                        rowIndex = index - this._getRowCount() * cellIndex;
                    return {
                            cellIndex: cellIndex,
                            rowIndex: rowIndex
                        }
                },
                _createGroupTree: function(group, groupIndex) {
                    var leafIndex = 0;
                    function make(group, groupIndex, result, parent) {
                        result = result || [];
                        for (var i = 0; i < group.items.length; i++) {
                            var resultItem = {
                                    name: group.name,
                                    value: group.items[i].id,
                                    children: [],
                                    parent: parent ? parent : null
                                };
                            result.push(resultItem);
                            var nextGroupIndex = groupIndex + 1;
                            if (this.option("groups")[nextGroupIndex])
                                make.call(this, this.option("groups")[nextGroupIndex], nextGroupIndex, resultItem.children, resultItem);
                            if (!resultItem.children.length) {
                                resultItem.leafIndex = leafIndex;
                                leafIndex++
                            }
                        }
                        return result
                    }
                    return make.call(this, group, groupIndex)
                },
                _hasGroupItem: function(groups, groupName, itemValue) {
                    var group = groups[groupName];
                    if (group)
                        if ($.inArray(itemValue, group) > -1)
                            return true;
                    return false
                },
                _grep: function(tree, groups, result) {
                    result = result || [];
                    for (var i = 0; i < tree.length; i++) {
                        if (!this._hasGroupItem(groups, tree[i].name, tree[i].value))
                            continue;
                        if (commonUtils.isDefined(tree[i].leafIndex))
                            result.push(tree[i].leafIndex);
                        if (tree[i].children)
                            this._grep(tree[i].children, groups, result)
                    }
                    return result
                },
                _getDateByCellIndexes: function(rowIndex, cellIndex) {
                    var millisecondsOffset = this._getInterval() * this._calculateCellIndex(rowIndex, cellIndex);
                    return new Date(this.getFirstViewDate().getTime() + millisecondsOffset)
                },
                _getCellTimeOffset: function(dateTimeStamp) {
                    var timeInterval = this._getInterval(),
                        timeOffset = dateTimeStamp % timeInterval;
                    return timeOffset ? timeOffset / timeInterval : 0
                },
                _getIntervalBetween: function(currentDate, firstViewDate, allDay) {
                    var startDayHour = this.option("startDayHour"),
                        firstViewDateTime = firstViewDate.getTime();
                    if (allDay)
                        firstViewDateTime = firstViewDateTime - startDayHour * 60 * 60 * 1000;
                    var result = currentDate.getTime() - firstViewDateTime,
                        days = Math.floor(result / (24 * 60 * 60 * 1000));
                    if (!allDay)
                        result = result - days * startDayHour * 3600000 - days * this._getEndDayMilliseconds();
                    return result
                },
                _getGroupIndexes: function(groups) {
                    var indexes = [];
                    if (groups && this.option("groups").length) {
                        var tree = this._createGroupTree(this.option("groups")[0], 0);
                        indexes = this._grep(tree, groups)
                    }
                    return indexes
                },
                _updateIndex: function(index) {
                    return index * this._getRowCount()
                },
                _getDroppableCell: function() {
                    return this._getDateTables().find("." + DATE_TABLE_DROPPABLE_CELL_CLASS)
                },
                _getWorkSpaceWidth: function() {
                    if (this.option("horizontalScrollingEnabled"))
                        return this._$dateTable.outerWidth();
                    return this.element().outerWidth() - this.getTimePanelWidth()
                },
                _getCellPositionByIndex: function(index, groupIndex, dateTimeStamp) {
                    var cellCoordinates = this._getCellCoordinatesByIndex(index),
                        $cell = this._getCellByCoordinates(cellCoordinates, groupIndex);
                    return this._getCellPosition($cell, dateTimeStamp)
                },
                _getCellPosition: function($cell, dateTimeStamp) {
                    var isRtl = this.option("rtlEnabled"),
                        position = $cell.position();
                    position.top += $cell.height() * this._getCellTimeOffset(dateTimeStamp);
                    if (isRtl)
                        position.left += $cell.outerWidth();
                    return position
                },
                _getCellByCoordinates: function(cellCoordinates, groupIndex) {
                    return this._$dateTable.find("tr").eq(cellCoordinates.rowIndex).find("td").eq(cellCoordinates.cellIndex + groupIndex * this._getCellCount())
                },
                _getCells: function(allDay) {
                    var cellClass = allDay ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS;
                    return this.element().find("." + cellClass)
                },
                _getScrollCoordinates: function(hours, minutes) {
                    var currentDate = new Date(this.option("currentDate")),
                        startDayHour = this.option("startDayHour"),
                        endDayHour = this.option("endDayHour");
                    if (hours < startDayHour)
                        hours = startDayHour;
                    if (hours >= endDayHour)
                        hours = endDayHour - 1;
                    currentDate.setHours(hours);
                    currentDate.setMinutes(minutes);
                    return this.getCoordinatesByDate(currentDate)
                },
                supportAllDayRow: function() {
                    return true
                },
                getCellData: function($cell) {
                    return $.extend(true, {}, $cell.data(CELL_DATA))
                },
                getCoordinatesByDate: function(date, groupIndex, allDay) {
                    var timeInterval = allDay ? 24 * 60 * 60 * 1000 : this._getInterval(),
                        dateTimeStamp = this._getIntervalBetween(date, this.getFirstViewDate(), allDay);
                    groupIndex = groupIndex || 0;
                    var index = Math.floor(dateTimeStamp / timeInterval);
                    if (allDay)
                        index = this._updateIndex(index);
                    if (index < 0)
                        index = 0;
                    return this._getCellPositionByIndex(index, groupIndex, dateTimeStamp)
                },
                getCoordinatesByDateInGroup: function(date, groups, allDay) {
                    var indexes = this._getGroupIndexes(groups),
                        result = [];
                    if (indexes.length)
                        for (var i = 0; i < indexes.length; i++)
                            result.push(this.getCoordinatesByDate(date, indexes[i], allDay));
                    else
                        result.push(this.getCoordinatesByDate(date, 0, allDay));
                    return result
                },
                getDroppableCellIndex: function() {
                    var $droppableCell = this._getDroppableCell(),
                        $row = $droppableCell.parent(),
                        rowIndex = $row.index();
                    return rowIndex * $row.find("td").length + $droppableCell.index()
                },
                getDataByDroppableCell: function() {
                    var cellData = this.getCellData(this._getDroppableCell());
                    return {
                            date: cellData.startDate,
                            allDay: cellData.allDay,
                            groups: cellData.groups
                        }
                },
                getDateRange: function() {
                    return [this.getFirstViewDate(), this.getLastViewDate()]
                },
                getCellWidth: function() {
                    return this._getCells().first().outerWidth()
                },
                getCellHeight: function() {
                    return this._getCells().first().outerHeight()
                },
                getAllDayHeight: function() {
                    return this.option("showAllDayPanel") ? this._getCells(true).first().outerHeight() : 0
                },
                getMaxAllowedPosition: function() {
                    var result = [],
                        isRtl = this.option("rtlEnabled");
                    this._$dateTable.find("tr").first().find("td:nth-child(" + this._getCellCount() + "n)").each(function(_, cell) {
                        var maxPosition = $(cell).position().left;
                        if (!isRtl)
                            maxPosition += $(cell).outerWidth();
                        result.push(Math.floor(maxPosition))
                    });
                    return result
                },
                getFixedContainer: function() {
                    return this._$fixedContainer
                },
                getAllDayContainer: function() {
                    return this._$allDayContainer
                },
                getCellIndexByCoordinates: function(coordinates, allDay) {
                    var cellCount = this._getTotalCellCount(this._getGroupCount() || 1),
                        timePanelWidth = this.getTimePanelWidth(),
                        cellWidth = Math.floor(this._getWorkSpaceWidth() / cellCount),
                        leftOffset = this.option("rtlEnabled") || this.option("horizontalScrollingEnabled") ? 0 : timePanelWidth,
                        topIndex = Math.floor(coordinates.top / (allDay ? this.getAllDayHeight() : this.getCellHeight())),
                        leftIndex = Math.floor((coordinates.left + 5 - leftOffset) / cellWidth);
                    if (this.option("rtlEnabled"))
                        leftIndex = cellCount - leftIndex - 1;
                    return cellCount * topIndex + leftIndex
                },
                getFirstViewDate: function() {
                    return this._firstViewDate
                },
                getLastViewDate: function() {
                    var dateOfLastViewCell = this._getDateByCellIndexes(this._getRowCount() - 1, this._getCellCount() - 1);
                    return new Date(dateOfLastViewCell.getTime() + this._getInterval() - 60000)
                },
                getGroupBounds: function(coordinates) {
                    var cellIndex = this.getCellIndexByCoordinates(coordinates),
                        cellCount = this._getCellCount(),
                        groupIndex = Math.floor(cellIndex / cellCount),
                        $cells = this._getCells(),
                        cellWidth = this.getCellWidth(),
                        startCellIndex = groupIndex * cellCount,
                        startOffset = $cells.eq(startCellIndex).offset().left,
                        endOffset = $cells.eq(startCellIndex + cellCount - 1).offset().left + cellWidth;
                    var result = {
                            left: startOffset,
                            right: endOffset
                        };
                    if (this.option("rtlEnabled")) {
                        result.left = endOffset - cellWidth;
                        result.right = startOffset + cellWidth
                    }
                    return result
                },
                getCellDataByCoordinates: function(coordinates, allDay) {
                    var $cells = this._getCells(allDay),
                        cellIndex = this.getCellIndexByCoordinates(coordinates, allDay),
                        $cell = $cells.eq(cellIndex);
                    return this.getCellData($cell)
                },
                getVisibleBounds: function() {
                    var result = {},
                        $scrollable = this.getScrollable().element(),
                        cellHeight = this.getCellHeight(),
                        scrolledCellCount = this.getScrollableScrollTop() / cellHeight,
                        totalCellCount = scrolledCellCount + $scrollable.height() / cellHeight;
                    result.top = {
                        hours: Math.floor(scrolledCellCount / 2) + this.option("startDayHour"),
                        minutes: scrolledCellCount % 2 ? 30 : 0
                    };
                    result.bottom = {
                        hours: Math.floor(totalCellCount / 2) + this.option("startDayHour"),
                        minutes: Math.floor(totalCellCount) % 2 ? 30 : 0
                    };
                    return result
                },
                updateScrollPosition: function(date) {
                    var bounds = this.getVisibleBounds(),
                        startDateHour = date.getHours(),
                        startDateMinutes = date.getMinutes();
                    if (this.needUpdateScrollPosition(startDateHour, startDateMinutes, bounds))
                        this.scrollToTime(startDateHour, startDateMinutes)
                },
                needUpdateScrollPosition: function(hours, minutes, bounds) {
                    var isUpdateNeeded = false;
                    if (hours < bounds.top.hours || hours > bounds.bottom.hours)
                        isUpdateNeeded = true;
                    if (hours === bounds.top.hours && minutes < bounds.top.minutes)
                        isUpdateNeeded = true;
                    if (hours === bounds.bottom.hours && minutes > bounds.top.minutes)
                        isUpdateNeeded = true;
                    return isUpdateNeeded
                },
                getGroupWidth: function(groupIndex) {
                    var result = this._getCellCount() * this.getCellWidth(),
                        position = this.getMaxAllowedPosition(),
                        currentPosition = position[groupIndex];
                    if (position.length && currentPosition)
                        if (this.option("rtlEnabled"))
                            result = currentPosition - position[groupIndex + 1];
                        else if (groupIndex === 0)
                            result = currentPosition;
                        else
                            result = currentPosition - position[groupIndex - 1];
                    return result
                },
                scrollToTime: function(hours, minutes) {
                    var coordinates = this._getScrollCoordinates(hours, minutes),
                        scrollable = this.getScrollable();
                    scrollable.scrollBy(coordinates.top - scrollable.scrollTop())
                }
            }).include(publisherMixin);
        registerComponent("dxSchedulerWorkSpace", {}, SchedulerWorkSpace);
        return SchedulerWorkSpace
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.workSpace"]);
    /*! Module widgets-web, file ui.scheduler.workSpaceDay.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.workSpaceDay", ["jquery", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.workSpace", "/utils/utils.common"], function($, registerComponent, SchedulerWorkSpace, commonUtils) {
        var DAY_CLASS = "dx-scheduler-work-space-day";
        var SchedulerWorkSpaceDay = SchedulerWorkSpace.inherit({
                _getElementClass: function() {
                    return DAY_CLASS
                },
                _getRowCount: function() {
                    var day = this._calculateDayDuration();
                    return day / this.option("hoursInterval")
                },
                _getCellCount: function() {
                    return 1
                },
                _setFirstViewDate: function() {
                    this._firstViewDate = this.option("currentDate");
                    if (commonUtils.isDefined(this.option("startDayHour")))
                        this._firstViewDate.setHours(this.option("startDayHour"))
                },
                _getDateByIndex: function() {
                    return this._firstViewDate
                },
                _getFormat: function() {
                    return "D"
                },
                _renderDateHeader: $.noop
            });
        registerComponent("dxSchedulerWorkSpaceDay", {}, SchedulerWorkSpaceDay);
        return SchedulerWorkSpaceDay
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.workSpaceDay"]);
    /*! Module widgets-web, file ui.scheduler.workSpaceWeek.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.workSpaceWeek", ["jquery", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.workSpace"], function($, registerComponent, SchedulerWorkSpace) {
        var WEEK_CLASS = "dx-scheduler-work-space-week";
        var SchedulerWorkSpaceWeek = SchedulerWorkSpace.inherit({
                _getElementClass: function() {
                    return WEEK_CLASS
                },
                _getRowCount: function() {
                    var day = this._calculateDayDuration();
                    return day / this.option("hoursInterval")
                },
                _getCellCount: function() {
                    return 7
                },
                _getDateByIndex: function(headerIndex) {
                    var resultDate = new Date(this._firstViewDate);
                    resultDate.setDate(this._firstViewDate.getDate() + headerIndex);
                    return resultDate
                },
                _getFormat: function() {
                    return "ddd d"
                }
            });
        registerComponent("dxSchedulerWorkSpaceWeek", {}, SchedulerWorkSpaceWeek);
        return SchedulerWorkSpaceWeek
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.workSpaceWeek"]);
    /*! Module widgets-web, file ui.scheduler.workSpaceWorkWeek.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.workSpaceWorkWeek", ["jquery", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.workSpaceWeek"], function($, registerComponent, SchedulerWorkSpaceWeek) {
        var WORK_WEEK_CLASS = "dx-scheduler-work-space-work-week";
        var weekendCounter = 0;
        var SchedulerWorkSpaceWorkWeek = SchedulerWorkSpaceWeek.inherit({
                _getElementClass: function() {
                    return WORK_WEEK_CLASS
                },
                _getCellCount: function() {
                    return 5
                },
                _firstDayOfWeek: function() {
                    return this.option("firstDayOfWeek") || 1
                },
                _getDateByIndex: function(headerIndex) {
                    var resultDate = new Date(this._firstViewDate);
                    resultDate.setDate(this._firstViewDate.getDate() + headerIndex + weekendCounter);
                    var day = resultDate.getDay();
                    if (day % 6 === 0) {
                        weekendCounter = Math.floor(day / 6 + 1);
                        resultDate.setDate(resultDate.getDate() + weekendCounter)
                    }
                    return resultDate
                },
                _renderView: function() {
                    weekendCounter = 0;
                    this.callBase()
                }
            });
        registerComponent("dxSchedulerWorkSpaceWorkWeek", {}, SchedulerWorkSpaceWorkWeek);
        return SchedulerWorkSpaceWorkWeek
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.workSpaceWorkWeek"]);
    /*! Module widgets-web, file ui.scheduler.workSpaceMonth.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.workSpaceMonth", ["jquery", "/utils/utils.date", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.workSpace"], function($, dateUtils, registerComponent, SchedulerWorkSpace) {
        var MONTH_CLASS = "dx-scheduler-work-space-month";
        var DAYS_IN_WEEK = 7,
            DAY_IN_MILLISECONDS = 86400000;
        var SchedulerWorkSpaceMonth = SchedulerWorkSpace.inherit({
                _getElementClass: function() {
                    return MONTH_CLASS
                },
                _getRowCount: function() {
                    return 6
                },
                _getCellCount: function() {
                    return DAYS_IN_WEEK
                },
                _getDateByIndex: function(headerIndex) {
                    var resultDate = new Date(this._firstViewDate);
                    resultDate.setDate(this._firstViewDate.getDate() + headerIndex);
                    return resultDate
                },
                _getFormat: function() {
                    return "ddd"
                },
                _calculateCellIndex: function(rowIndex, cellIndex) {
                    cellIndex = cellIndex % this._getCellCount();
                    return rowIndex * this._getCellCount() + cellIndex
                },
                _getInterval: function() {
                    return DAY_IN_MILLISECONDS
                },
                _calculateEndDate: function(startDate) {
                    var startDateCopy = new Date(startDate);
                    return new Date(startDateCopy.setHours(this.option("endDayHour")))
                },
                _getIntervalBetween: function(currentDate, firstViewDate) {
                    return currentDate.getTime() - (firstViewDate.getTime() - this.option("startDayHour") * 3600000)
                },
                _getCellCoordinatesByIndex: function(index) {
                    var rowIndex = Math.floor(index / this._getCellCount()),
                        cellIndex = index - this._getCellCount() * rowIndex;
                    return {
                            rowIndex: rowIndex,
                            cellIndex: cellIndex
                        }
                },
                _renderTimePanel: $.noop,
                _renderAllDayPanel: $.noop,
                _getTableAllDay: $.noop,
                _toggleAllDayVisibility: $.noop,
                _changeAllDayVisibility: $.noop,
                _getCellTimeOffset: function() {
                    return 0
                },
                _setFirstViewDate: function() {
                    var firstMonthDate = dateUtils.getFirstMonthDate(this.option("currentDate"));
                    this._firstViewDate = dateUtils.getFirstWeekDate(firstMonthDate, this.option("firstDayOfWeek"));
                    if (this.option("startDayHour"))
                        this._firstViewDate.setHours(this.option("startDayHour"))
                },
                _getDate: function(week, day) {
                    var result = new Date(this._firstViewDate);
                    result.setDate(result.getDate() + week * DAYS_IN_WEEK + day);
                    return result
                },
                _getCellText: function(rowIndex, cellIndex) {
                    cellIndex = cellIndex % this._getCellCount();
                    var date = this._getDate(rowIndex, cellIndex);
                    return Globalize.format(date, "dd")
                },
                _updateIndex: function(index) {
                    return index
                },
                getTimePanelWidth: function() {
                    return 0
                },
                getCoordinatesByDates: function(startDate, endDate) {
                    var result = [],
                        date = new Date(startDate);
                    while (date <= endDate) {
                        result.push(this.getCoordinatesByDate(date));
                        date.setDate(date.getDate() + 7);
                        date = dateUtils.getFirstWeekDate(date, this.option("firstDayOfWeek"))
                    }
                    return result
                },
                getCellCountToLastViewDate: function(date) {
                    var firstDateTime = dateUtils.makeDate(date).getTime(),
                        lastDateTime = this.getLastViewDate().getTime(),
                        dayDurationInMs = this._calculateDayDuration() * 3600000;
                    return Math.ceil((lastDateTime - firstDateTime) / dayDurationInMs)
                },
                supportAllDayRow: function() {
                    return false
                },
                scrollToTime: $.noop
            });
        registerComponent("dxSchedulerWorkSpaceMonth", {}, SchedulerWorkSpaceMonth);
        return SchedulerWorkSpaceMonth
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.workSpaceMonth"]);
    /*! Module widgets-web, file ui.scheduler.timeline.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.timeline", ["jquery", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.workSpace"], function($, registerComponent, SchedulerWorkSpace) {
        var TIMELINE_CLASS = "dx-scheduler-timeline",
            GROUP_TABLE_CLASS = "dx-scheduler-group-table";
        var HORIZONTAL = "horizontal";
        var SchedulerTimeline = SchedulerWorkSpace.inherit({
                _init: function() {
                    this.callBase();
                    this.element().addClass(TIMELINE_CLASS);
                    this._$sidebarTable = $("<table>").addClass(GROUP_TABLE_CLASS)
                },
                _getRowCount: function() {
                    return 1
                },
                _getCellCount: function() {
                    return this._getCellCountInDay()
                },
                _getTotalCellCount: function(groupCount) {
                    return this._getCellCount()
                },
                _getTotalRowCount: function(groupCount) {
                    return this._getRowCount() * groupCount
                },
                _getDateByIndex: function(index) {
                    var resultDate = new Date(this._firstViewDate);
                    resultDate.setTime(this._firstViewDate.getTime() + this._calculateCellIndex(0, index) * this._getInterval());
                    return resultDate
                },
                _getFormat: function() {
                    return "t"
                },
                _createWorkSpaceElements: function() {
                    this._createWorkSpaceScrollableElements()
                },
                _createDateTableConfig: function() {
                    var that = this,
                        config = this.callBase(),
                        timelineConfig = {
                            direction: HORIZONTAL,
                            onScroll: function(e) {
                                that._headerScrollable.scrollTo({left: e.scrollOffset.left})
                            }
                        };
                    return $.extend(config, timelineConfig)
                },
                _renderTimePanel: $.noop,
                _renderAllDayPanel: $.noop,
                _getTableAllDay: function() {
                    return false
                },
                _toggleAllDayVisibility: $.noop,
                _changeAllDayVisibility: $.noop,
                _getCellPosition: function($cell, dateTimeStamp) {
                    var isRtl = this.option("rtlEnabled"),
                        position = $cell.position(),
                        cellOffset = $cell.width() * this._getCellTimeOffset(dateTimeStamp);
                    if (isRtl)
                        position.left += $cell.outerWidth() - cellOffset;
                    else
                        position.left += cellOffset;
                    return position
                },
                supportAllDayRow: function() {
                    return false
                },
                _getGroupHeaderContainer: function() {
                    return this._$sidebarTable
                },
                _renderView: function() {
                    this.callBase();
                    this._$sidebarTable.appendTo(this._sidebarScrollable.content())
                },
                _cleanView: function() {
                    this.callBase();
                    this._$sidebarTable.empty()
                },
                _makeGroupRows: function(groups) {
                    var repeatCount = 1,
                        arr = [],
                        i;
                    for (i = 0; i < groups.length; i++) {
                        if (i > 0)
                            repeatCount = groups[i - 1].items.length * repeatCount;
                        var cells = this._makeGroupRowCells(groups[i].items, repeatCount);
                        arr.push(cells)
                    }
                    var rows = [],
                        groupCount = arr.length,
                        maxCellCount = arr[groupCount - 1].length;
                    for (i = 0; i < maxCellCount; i++)
                        rows.push($("<tr>").addClass("dx-scheduler-group-row"));
                    for (i = groupCount - 1; i >= 0; i--) {
                        var currentColumnLength = arr[i].length,
                            rowspan = maxCellCount / currentColumnLength;
                        for (var j = 0; j < currentColumnLength; j++) {
                            var currentRowIndex = j * rowspan,
                                row = rows[currentRowIndex];
                            row.prepend(arr[i][j].attr("rowspan", rowspan))
                        }
                    }
                    return rows
                },
                _attachGroupCountAttr: function() {
                    this.element().attr("dx-group-column-count", this.option("groups").length)
                },
                _getCellCoordinatesByIndex: function(index) {
                    return {
                            cellIndex: index % this._getCellCount(),
                            rowIndex: 0
                        }
                },
                _getCellByCoordinates: function(cellCoordinates, groupIndex) {
                    return this._$dateTable.find("tr").eq(cellCoordinates.rowIndex + groupIndex).find("td").eq(cellCoordinates.cellIndex)
                },
                _calculateCellIndex: function(rowIndex, cellIndex) {
                    var dayIndex = Math.floor(cellIndex / this._getCellCountInDay()),
                        virtualCellCount = this._getVirtualSlotCount();
                    return cellIndex + dayIndex * virtualCellCount
                },
                _getGroupIndex: function(rowIndex, cellIndex) {
                    return rowIndex
                },
                _getWorkSpaceWidth: function() {
                    return this._$dateTable.outerWidth(true)
                },
                _calculateHeaderCellRepeatCount: function() {
                    return 1
                },
                getAllDayContainer: function() {
                    return null
                },
                getTimePanelWidth: function() {
                    return 0
                },
                getVisibleBounds: function() {
                    var result = {},
                        $scrollable = this.getScrollable().element(),
                        cellWidth = this.getCellWidth(),
                        scrolledCellCount = this.getScrollableScrollLeft() / cellWidth,
                        totalCellCount = scrolledCellCount + $scrollable.width() / cellWidth;
                    result.right = {
                        hours: Math.floor(scrolledCellCount / 2) + this.option("startDayHour"),
                        minutes: scrolledCellCount % 2 ? 30 : 0
                    };
                    result.left = {
                        hours: Math.floor(totalCellCount / 2) + this.option("startDayHour"),
                        minutes: Math.floor(totalCellCount) % 2 ? 30 : 0
                    };
                    return result
                },
                needUpdateScrollPosition: function(hours, minutes, bounds) {
                    var isUpdateNeeded = false;
                    if (hours < bounds.right.hours || hours > bounds.left.hours)
                        isUpdateNeeded = true;
                    if (hours === bounds.right.hours && minutes < bounds.right.minutes)
                        isUpdateNeeded = true;
                    if (hours === bounds.left.hours && minutes > bounds.right.minutes)
                        isUpdateNeeded = true;
                    return isUpdateNeeded
                },
                scrollToTime: function(hours, minutes) {
                    var coordinates = this._getScrollCoordinates(hours, minutes),
                        scrollable = this.getScrollable();
                    scrollable.scrollBy({
                        left: coordinates.left - scrollable.scrollLeft(),
                        top: 0
                    })
                }
            });
        registerComponent("dxSchedulerTimeline", {}, SchedulerTimeline);
        return SchedulerTimeline
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.timeline"]);
    /*! Module widgets-web, file ui.scheduler.timelineDay.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.timelineDay", ["jquery", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.timeline", "/utils/utils.common"], function($, registerComponent, SchedulerTimeline, commonUtils) {
        var TIMELINE_CLASS = "dx-scheduler-timeline-day";
        var SchedulerTimelineDay = SchedulerTimeline.inherit({
                _getElementClass: function() {
                    return TIMELINE_CLASS
                },
                _setFirstViewDate: function() {
                    this._firstViewDate = this.option("currentDate");
                    if (commonUtils.isDefined(this.option("startDayHour")))
                        this._firstViewDate.setHours(this.option("startDayHour"))
                }
            });
        registerComponent("dxSchedulerTimelineDay", {}, SchedulerTimelineDay);
        return SchedulerTimelineDay
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.timelineDay"]);
    /*! Module widgets-web, file ui.scheduler.timelineWeek.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.timelineWeek", ["jquery", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.timeline"], function($, registerComponent, SchedulerTimeline) {
        var TIMELINE_CLASS = "dx-scheduler-timeline-week",
            HEADER_PANEL_CELL_CLASS = "dx-scheduler-header-panel-cell",
            HEADER_ROW_CLASS = "dx-scheduler-header-row",
            CELL_WIDTH = 200;
        var SchedulerTimelineWeek = SchedulerTimeline.inherit({
                _getElementClass: function() {
                    return TIMELINE_CLASS
                },
                _getCellCount: function() {
                    return this.callBase() * this._getWeekDuration()
                },
                _renderDateHeader: function() {
                    var $headerRow = this.callBase(),
                        firstViewDate = new Date(this._firstViewDate),
                        $cells = [],
                        colspan = this._getCellCountInDay(),
                        headerCellWidth = colspan * CELL_WIDTH;
                    for (var i = 0; i < this._getWeekDuration(); i++) {
                        $cells.push($("<th />").addClass(HEADER_PANEL_CELL_CLASS).text(Globalize.format(firstViewDate, "ddd d")).attr("colspan", colspan).width(headerCellWidth));
                        firstViewDate.setDate(firstViewDate.getDate() + 1)
                    }
                    var $row = $("<tr />").addClass(HEADER_ROW_CLASS).append($cells);
                    $headerRow.before($row)
                },
                _getWeekDuration: function() {
                    return 7
                }
            });
        registerComponent("dxSchedulerTimelineWeek", {}, SchedulerTimelineWeek);
        return SchedulerTimelineWeek
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.timelineWeek"]);
    /*! Module widgets-web, file ui.scheduler.timelineWorkWeek.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.timelineWorkWeek", ["jquery", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.timelineWeek"], function($, registerComponent, SchedulerTimelineWeek) {
        var TIMELINE_CLASS = "dx-scheduler-timeline-work-week";
        var SchedulerTimelineWorkWeek = SchedulerTimelineWeek.inherit({
                _getElementClass: function() {
                    return TIMELINE_CLASS
                },
                _getWeekDuration: function() {
                    return 5
                }
            });
        registerComponent("dxSchedulerTimelineWorkWeek", {}, SchedulerTimelineWorkWeek);
        return SchedulerTimelineWorkWeek
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.timelineWorkWeek"]);
    /*! Module widgets-web, file ui.scheduler.appointments.strategy.base.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointments.strategy.base", ["jquery", "/class", "/ui/ui.errors", "/utils/utils.date"], function($, Class, errors, dateUtils) {
        var abstract = Class.abstract;
        var APPOINTMENT_DEFAULT_SIZE = 20,
            COMPACT_APPOINTMENT_DEFAULT_SIZE = 15,
            COMPACT_APPOINTMENT_DEFAULT_OFFSET = 3;
        var BaseRenderingStrategy = Class.inherit({
                ctor: function(instance) {
                    this.instance = instance
                },
                getAppointmentDefaultSize: function() {
                    return APPOINTMENT_DEFAULT_SIZE
                },
                resizableConfig: abstract,
                getHorizontalResizableHandles: function(skippedDirection) {
                    var rtlEnabled = this._isRtl();
                    if (!skippedDirection)
                        return "right left";
                    if (skippedDirection === "increase")
                        return rtlEnabled ? "right" : "left";
                    return rtlEnabled ? "left" : "right"
                },
                getDeltaTime: abstract,
                getAppointmentGeometry: function(coordinates) {
                    return this.applyCellBorder(coordinates)
                },
                createTaskPositionMap: function(items) {
                    var length = items.length;
                    if (!length)
                        return;
                    this.instance.notifyObserver("getCellDimensions", {callback: $.proxy(function(width, height, allDayHeight) {
                            this._defaultWidth = width;
                            this._defaultHeight = height;
                            this._allDayHeight = allDayHeight
                        }, this)});
                    this.instance.notifyObserver("getMaxAllowedPosition", {callback: $.proxy(function(result) {
                            if (result)
                                this._maxAllowedPosition = result
                        }, this)});
                    var map = [];
                    for (var i = 0; i < length; i++) {
                        var coordinates = this._getItemPosition(items[i]);
                        if (this._isRtl())
                            coordinates = this._correctRtlCoordinates(coordinates);
                        map.push(coordinates)
                    }
                    var positionArray = this._getSortedPositions(map),
                        resultPositions = this._getResultPositions(positionArray);
                    return this._getExtendedPositionMap(map, resultPositions)
                },
                applyCellBorder: function(config) {
                    var cellBorderSize = 1;
                    config.left += cellBorderSize;
                    config.top += cellBorderSize;
                    config.width -= cellBorderSize;
                    config.height -= cellBorderSize;
                    return config
                },
                _getDeltaWidth: function(args, initialSize) {
                    var cellWidth = this._defaultWidth || this.getAppointmentDefaultSize(),
                        initialWidth = initialSize.width;
                    return Math.round((args.width - initialWidth) / cellWidth)
                },
                _correctRtlCoordinates: function(coordinates) {
                    var width = coordinates[0].width || this._getAppointmentMaxWidth();
                    if (!coordinates[0].appointmentReduced)
                        coordinates[0].left -= width;
                    this._correctRtlCoordinatesParts(coordinates, width);
                    return coordinates
                },
                _correctRtlCoordinatesParts: $.noop,
                _getAppointmentMaxWidth: function() {
                    return this._defaultWidth
                },
                _getItemPosition: function(item) {
                    var height = this.calculateAppointmentHeight(item),
                        width = this.calculateAppointmentWidth(item),
                        sourceAppointmentWidth = width,
                        position = this._getAppointmentCoordinates(item),
                        allDay = this.isAllDay(item),
                        appointmentReduced = false,
                        multiWeekAppointmentParts = [],
                        result = [];
                    for (var j = 0; j < position.length; j++) {
                        if (allDay)
                            position[j].top = 0;
                        if ((this._needVerifyItemSize() || allDay) && this._maxAllowedPosition) {
                            var currentMaxAllowedPosition = this._getCurrentMaxAllowedPosition(j, item);
                            if (this.isAppointmentGreaterThan(currentMaxAllowedPosition, {
                                left: position[j].left,
                                width: sourceAppointmentWidth
                            })) {
                                appointmentReduced = {appointmentPart: "head"};
                                width = this._reduceMultiWeekAppointment(width, {
                                    left: position[j].left,
                                    right: currentMaxAllowedPosition
                                });
                                multiWeekAppointmentParts = this._getMultiWeekAppointmentParts({
                                    sourceAppointmentWidth: sourceAppointmentWidth,
                                    reducedWidth: width,
                                    height: height
                                }, position[j], allDay, item.startDate, j);
                                if (this._isRtl())
                                    position[j].left = this._maxAllowedPosition[j]
                            }
                        }
                        $.extend(position[j], {
                            height: height,
                            width: width,
                            allDay: allDay,
                            appointmentReduced: appointmentReduced
                        });
                        if (multiWeekAppointmentParts.length) {
                            multiWeekAppointmentParts.unshift(position[j]);
                            result = $.merge(result, multiWeekAppointmentParts)
                        }
                        else
                            result.push(position[j])
                    }
                    return result
                },
                _getAppointmentCoordinates: function(itemData) {
                    var startDate = dateUtils.makeDate(itemData.startDate),
                        coordinates = [{
                                top: 0,
                                left: 0
                            }];
                    this.instance.notifyObserver("needCoordinates", {
                        startDate: startDate,
                        appointmentData: itemData,
                        callback: function(value) {
                            coordinates = value
                        }
                    });
                    return coordinates
                },
                _needVerifyItemSize: function() {
                    return false
                },
                _isRtl: function() {
                    return this.instance.option("rtlEnabled")
                },
                _getCurrentMaxAllowedPosition: function(index, item) {
                    this.instance.notifyObserver("getItemGroupIndexes", {
                        item: item,
                        callback: function(indexes) {
                            if (indexes.length)
                                index = indexes[index]
                        }
                    });
                    return Math.floor(this._maxAllowedPosition[index])
                },
                _getMultiWeekAppointmentParts: function() {
                    return []
                },
                _reduceMultiWeekAppointment: function(sourceAppointmentWidth, bound) {
                    if (this._isRtl())
                        sourceAppointmentWidth = Math.floor(bound.left - bound.right);
                    else
                        sourceAppointmentWidth = bound.right - Math.floor(bound.left);
                    return sourceAppointmentWidth
                },
                calculateAppointmentHeight: function() {
                    return 0
                },
                calculateAppointmentWidth: function() {
                    return 0
                },
                isAppointmentGreaterThan: function(etalon, comparisonParameters) {
                    if (this._isRtl())
                        return comparisonParameters.left - comparisonParameters.width < etalon;
                    return comparisonParameters.left + comparisonParameters.width > etalon
                },
                isAllDay: function() {
                    return false
                },
                _getSortedPositions: function(arr) {
                    var result = [];
                    for (var i = 0, arrLength = arr.length; i < arrLength; i++)
                        for (var j = 0, itemLength = arr[i].length; j < itemLength; j++) {
                            var item = arr[i][j];
                            result.push({
                                i: i,
                                j: j,
                                top: item.top,
                                left: item.left,
                                isStart: true,
                                allDay: item.allDay
                            }, {
                                i: i,
                                j: j,
                                top: item.top + item.height,
                                left: item.left + item.width,
                                isStart: false,
                                allDay: item.allDay
                            })
                        }
                    result.sort($.proxy(this._sortCondition, this));
                    return result
                },
                _sortCondition: abstract,
                _rowCondition: function(a, b) {
                    var columnCondition = this._normalizeCondition(a.left, b.left),
                        rowCondition = this._normalizeCondition(a.top, b.top);
                    return columnCondition ? columnCondition : rowCondition ? rowCondition : a.isStart - b.isStart
                },
                _columnCondition: function(a, b) {
                    var columnCondition = this._normalizeCondition(a.left, b.left),
                        rowCondition = this._normalizeCondition(a.top, b.top);
                    return rowCondition ? rowCondition : columnCondition ? columnCondition : a.isStart - b.isStart
                },
                _normalizeCondition: function(first, second) {
                    var result = first - second;
                    return Math.abs(result) > 1.001 ? result : 0
                },
                _getResultPositions: function(sortedArray) {
                    var stack = [],
                        indexes = [],
                        result = [],
                        intersectPositions = [],
                        intersectPositionCount = 0,
                        sortedIndex = 0,
                        position;
                    for (var i = 0; i < sortedArray.length; i++) {
                        var current = sortedArray[i],
                            j;
                        if (current.isStart) {
                            position = undefined;
                            for (j = 0; j < indexes.length; j++)
                                if (!indexes[j]) {
                                    position = j;
                                    indexes[j] = true;
                                    break
                                }
                            if (position === undefined) {
                                position = indexes.length;
                                indexes.push(true);
                                for (j = 0; j < stack.length; j++)
                                    stack[j].count++
                            }
                            stack.push({
                                index: position,
                                count: indexes.length,
                                i: current.i,
                                j: current.j,
                                sortedIndex: sortedIndex++
                            });
                            if (intersectPositionCount < indexes.length)
                                intersectPositionCount = indexes.length
                        }
                        else {
                            var removeIndex = this._findIndexByKey(stack, "i", "j", current.i, current.j),
                                resultItem = stack[removeIndex];
                            stack.splice(removeIndex, 1);
                            indexes[resultItem.index] = false;
                            intersectPositions.push(resultItem);
                            if (!stack.length) {
                                indexes = [];
                                for (var k = 0; k < intersectPositions.length; k++)
                                    intersectPositions[k].count = intersectPositionCount;
                                intersectPositions = [];
                                intersectPositionCount = 0
                            }
                            result.push(resultItem)
                        }
                    }
                    return result.sort(function(a, b) {
                            var columnCondition = a.j - b.j,
                                rowCondition = a.i - b.i;
                            return rowCondition ? rowCondition : columnCondition
                        })
                },
                _findIndexByKey: function(arr, ikey, jkey, ivalue, jvalue) {
                    var result = 0;
                    for (var i = 0, len = arr.length; i < len; i++)
                        if (arr[i][ikey] === ivalue && arr[i][jkey] === jvalue) {
                            result = i;
                            break
                        }
                    return result
                },
                _getExtendedPositionMap: function(map, positions) {
                    var positionCounter = 0;
                    for (var i = 0, mapLength = map.length; i < mapLength; i++)
                        for (var j = 0, itemLength = map[i].length; j < itemLength; j++) {
                            map[i][j].index = positions[positionCounter].index;
                            map[i][j].sortedIndex = positions[positionCounter].sortedIndex;
                            map[i][j].count = positions[positionCounter++].count;
                            map[i][j].groupIndex = map[i][j].top + "-" + map[i][j].left
                        }
                    return map
                },
                _startDate: function(appointment, skipNormalize) {
                    var startDate = this.instance._getStartDate(appointment, skipNormalize);
                    if (isNaN(startDate.getTime()))
                        throw errors.Error("E1032", appointment.text);
                    return startDate
                },
                _endDate: function(appointment) {
                    var endDate = this.instance._getEndDate(appointment),
                        realStartDate = this._startDate(appointment, true),
                        viewStartDate = this._startDate(appointment);
                    if (!endDate || realStartDate >= endDate) {
                        endDate = new Date(realStartDate.getTime() + this.instance.option("appointmentDurationInMinutes") * 60000);
                        appointment.endDate = endDate
                    }
                    if (viewStartDate >= endDate) {
                        var duration = endDate.getTime() - realStartDate.getTime();
                        endDate = new Date(viewStartDate.getTime() + duration)
                    }
                    return endDate
                },
                _getMaxNeighborAppointmentCount: function() {
                    var outerAppointmentWidth = this.getCompactAppointmentDefaultSize() + this.getCompactAppointmentDefaultOffset();
                    return Math.floor(this.getCompactAppointmentGroupMaxWidth() / outerAppointmentWidth)
                },
                _markAppointmentAsVirtual: function(coordinates, isAllDay) {
                    var countFullWidthAppointmentInCell = 2;
                    if (coordinates.count - countFullWidthAppointmentInCell > this._getMaxNeighborAppointmentCount())
                        coordinates.virtual = {
                            top: coordinates.top,
                            left: coordinates.left,
                            groupIndex: coordinates.groupIndex,
                            isAllDay: isAllDay
                        }
                },
                getCompactAppointmentGroupMaxWidth: function() {
                    var widthInPercents = 75;
                    return widthInPercents * this.getDefaultCellWidth() / 100
                },
                getDefaultCellWidth: function() {
                    return this._defaultWidth
                },
                getCompactAppointmentDefaultSize: function() {
                    return COMPACT_APPOINTMENT_DEFAULT_SIZE
                },
                getCompactAppointmentDefaultOffset: function() {
                    return COMPACT_APPOINTMENT_DEFAULT_OFFSET
                }
            });
        return BaseRenderingStrategy
    });
    /*! Module widgets-web, file ui.scheduler.appointments.strategy.horizontal.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointments.strategy.horizontal", ["jquery", "/ui/widgets/scheduler/ui.scheduler.appointments.strategy.base"], function($, BaseAppointmentsStrategy) {
        var MAX_APPOINTMENT_HEIGHT = 100,
            BOTTOM_CELL_GAP = 20;
        var HorizontalRenderingStrategy = BaseAppointmentsStrategy.inherit({
                resizableConfig: function(appointmentData, skippedDirection) {
                    return {
                            minWidth: this._defaultWidth,
                            minHeight: 0,
                            step: this._defaultWidth,
                            handles: this.getHorizontalResizableHandles(skippedDirection)
                        }
                },
                _needVerifyItemSize: function() {
                    return true
                },
                calculateAppointmentWidth: function(appointment) {
                    var cellWidth = this._defaultWidth || this.getAppointmentDefaultSize(),
                        durationInHours = 0;
                    if (appointment.allDay)
                        durationInHours = this.instance.option("dayDuration") * 60 / this.instance.option("appointmentDurationInMinutes");
                    else {
                        var startDate = this._startDate(appointment),
                            endDate = this._endDate(appointment);
                        durationInHours = (endDate.getTime() - startDate.getTime()) / (this.instance.option("appointmentDurationInMinutes") * 60000)
                    }
                    return durationInHours * cellWidth
                },
                getAppointmentGeometry: function(coordinates) {
                    var result = this._customizeAppointmentGeometry(coordinates);
                    return this.callBase(result)
                },
                _customizeAppointmentGeometry: function(coordinates) {
                    var cellHeight = (this._defaultHeight || this.getAppointmentDefaultSize()) - BOTTOM_CELL_GAP,
                        height = cellHeight / coordinates.count;
                    if (height > MAX_APPOINTMENT_HEIGHT)
                        height = MAX_APPOINTMENT_HEIGHT;
                    var top = coordinates.top + coordinates.index * height;
                    return {
                            height: height,
                            width: coordinates.width,
                            top: top,
                            left: coordinates.left
                        }
                },
                _correctRtlCoordinatesParts: function(coordinates, width) {
                    for (var i = 1; i < coordinates.length; i++)
                        coordinates[i].left -= width;
                    return coordinates
                },
                _sortCondition: function(a, b) {
                    return this._columnCondition(a, b)
                },
                _getMaxAppointmentWidth: function(startDate) {
                    var result;
                    this.instance.notifyObserver("getMaxAppointmentWidth", {
                        date: startDate,
                        callback: function(width) {
                            result = width
                        }
                    });
                    return result
                },
                getDeltaTime: function(args, initialSize) {
                    var deltaWidth = this._getDeltaWidth(args, initialSize);
                    return this.instance.option("appointmentDurationInMinutes") * 60000 * deltaWidth
                },
                isAllDay: function(appointmentData) {
                    return appointmentData.allDay
                }
            });
        return HorizontalRenderingStrategy
    });
    /*! Module widgets-web, file ui.scheduler.appointments.strategy.horizontalMonth.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointments.strategy.horizontalMonth", ["jquery", "/ui/widgets/scheduler/ui.scheduler.appointments.strategy.horizontal", "/utils/utils.date"], function($, HorizontalAppointmentsStrategy, dateUtils) {
        var MONTH_APPOINTMENT_HEIGHT_RATIO = 0.6;
        var HorizontalMonthRenderingStrategy = HorizontalAppointmentsStrategy.inherit({
                _skipResizingForReducedAppointments: function(appointmentReduced) {
                    var result = true;
                    if (appointmentReduced.appointmentPart === "head")
                        result = {skipDirection: "increase"};
                    else if (appointmentReduced.appointmentPart === "tail")
                        result = {skipDirection: "decrease"};
                    return result
                },
                _getMultiWeekAppointmentParts: function(appointmentGeometry, appointmentSettings, allDay, startDate, groupIndex) {
                    var deltaWidth = appointmentGeometry.sourceAppointmentWidth - appointmentGeometry.reducedWidth,
                        height = appointmentGeometry.height,
                        fullWeekAppointmentWidth = this._getFullWeekAppointmentWidth(groupIndex),
                        maxAppointmentWidth = this._getMaxAppointmentWidth(startDate),
                        longPartCount = Math.floor(deltaWidth / fullWeekAppointmentWidth),
                        tailWidth = deltaWidth % fullWeekAppointmentWidth,
                        result = [],
                        totalWidth = appointmentGeometry.reducedWidth + tailWidth,
                        topOfLastPart = appointmentSettings.top,
                        left = this._calculateMultiWeekAppointmentLeftOffset(groupIndex);
                    for (var i = 0; i < longPartCount; i++) {
                        if (totalWidth > maxAppointmentWidth)
                            break;
                        topOfLastPart += this._defaultHeight;
                        result.push($.extend(true, {}, appointmentSettings, {
                            top: topOfLastPart,
                            left: left,
                            height: height,
                            width: fullWeekAppointmentWidth,
                            allDay: allDay,
                            appointmentReduced: {appointmentPart: "body"}
                        }));
                        totalWidth += fullWeekAppointmentWidth
                    }
                    if (tailWidth) {
                        if (this._isRtl())
                            left = left + (fullWeekAppointmentWidth - tailWidth);
                        result.push({
                            top: topOfLastPart + this._defaultHeight,
                            left: left,
                            height: height,
                            width: tailWidth,
                            allDay: allDay,
                            appointmentReduced: {appointmentPart: "tail"}
                        })
                    }
                    return result
                },
                _calculateMultiWeekAppointmentLeftOffset: function(groupIndex) {
                    var left = 0;
                    if (this._isRtl())
                        left = this._maxAllowedPosition[0];
                    if (groupIndex > 0) {
                        left = this._maxAllowedPosition[groupIndex - 1];
                        if (this._isRtl())
                            left = this._maxAllowedPosition[groupIndex]
                    }
                    return left
                },
                _correctRtlCoordinatesParts: $.noop,
                _getFullWeekAppointmentWidth: function(groupIndex) {
                    this.instance.notifyObserver("getFullWeekAppointmentWidth", {
                        groupIndex: groupIndex,
                        callback: $.proxy(function(width) {
                            this._maxFullWeekAppointmentWidth = width
                        }, this)
                    });
                    return this._maxFullWeekAppointmentWidth
                },
                _customizeAppointmentGeometry: function(coordinates) {
                    var maxHeight = this._defaultHeight || this.getAppointmentDefaultSize(),
                        index = coordinates.index,
                        height = MONTH_APPOINTMENT_HEIGHT_RATIO * maxHeight / 2,
                        top = (1 - MONTH_APPOINTMENT_HEIGHT_RATIO) * maxHeight + coordinates.top + index * height,
                        width = coordinates.width,
                        left = coordinates.left,
                        compactAppointmentDefaultSize,
                        compactAppointmentDefaultOffset;
                    if (index > 1) {
                        compactAppointmentDefaultSize = this.getCompactAppointmentDefaultSize();
                        compactAppointmentDefaultOffset = this.getCompactAppointmentDefaultOffset();
                        top = coordinates.top + compactAppointmentDefaultOffset;
                        left = coordinates.left + (index - 2) * (compactAppointmentDefaultSize + compactAppointmentDefaultOffset) + compactAppointmentDefaultOffset;
                        height = compactAppointmentDefaultSize,
                        width = compactAppointmentDefaultSize;
                        coordinates.skipResizing = true;
                        this._markAppointmentAsVirtual(coordinates)
                    }
                    return {
                            height: height,
                            width: width,
                            top: top,
                            left: left
                        }
                },
                getAppointmentGeometry: function(coordinates) {
                    if (coordinates.appointmentReduced)
                        coordinates.skipResizing = this._skipResizingForReducedAppointments(coordinates.appointmentReduced);
                    return this.callBase(coordinates)
                },
                calculateAppointmentWidth: function(appointment) {
                    var startDate = new Date(this._startDate(appointment)),
                        endDate = this._endDate(appointment),
                        cellWidth = this._defaultWidth || this.getAppointmentDefaultSize();
                    dateUtils.correctDateWithUnitBeginning(startDate, "day");
                    var durationInHours = (endDate.getTime() - startDate.getTime()) / 3600000;
                    var width = Math.ceil(durationInHours / 24) * cellWidth;
                    return width
                },
                getDeltaTime: function(args, initialSize) {
                    var deltaWidth = this._getDeltaWidth(args, initialSize);
                    return 24 * 60 * 60000 * deltaWidth
                },
                isAllDay: function() {
                    return false
                }
            });
        return HorizontalMonthRenderingStrategy
    });
    /*! Module widgets-web, file ui.scheduler.appointments.strategy.vertical.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointments.strategy.vertical", ["jquery", "/ui/widgets/scheduler/ui.scheduler.appointments.strategy.base", "/utils/utils.date"], function($, BaseAppointmentsStrategy, dateUtils) {
        var WEEK_APPOINTMENT_DEFAULT_OFFSET = 15;
        var VerticalRenderingStrategy = BaseAppointmentsStrategy.inherit({
                resizableConfig: function(appointmentData, skippedDirection) {
                    if (this.isAllDay(appointmentData))
                        return {
                                minWidth: this._defaultWidth,
                                minHeight: 0,
                                step: this._defaultWidth,
                                handles: this.getHorizontalResizableHandles(skippedDirection)
                            };
                    return {
                            minHeight: this._defaultHeight,
                            step: this._defaultHeight,
                            handles: "top bottom"
                        }
                },
                getDeltaTime: function(args, initialSize, appointment) {
                    var deltaTime = 0;
                    if (this.isAllDay(appointment))
                        deltaTime = this._getDeltaWidth(args, initialSize) * 24 * 60 * 60000;
                    else {
                        var deltaHeight = args.height - initialSize.height;
                        if (deltaHeight < 0)
                            deltaHeight = this._correctOnePxGap(deltaHeight);
                        deltaTime = 60000 * deltaHeight / this._defaultHeight * this.instance.option("appointmentDurationInMinutes")
                    }
                    return deltaTime
                },
                getAppointmentGeometry: function(coordinates) {
                    var result;
                    if (coordinates.allDay)
                        result = this._getAllDayAppointmentGeometry(coordinates);
                    else
                        result = this._getSimpleAppointmentGeometry(coordinates);
                    return this.callBase(result)
                },
                _correctOnePxGap: function(deltaHeight) {
                    if (Math.abs(deltaHeight) % this._defaultHeight)
                        deltaHeight--;
                    return deltaHeight
                },
                _getMinuteHeight: function() {
                    return this._defaultHeight / this.instance.option("appointmentDurationInMinutes")
                },
                _getAllDayAppointmentGeometry: function(coordinates) {
                    var maxHeight = this._allDayHeight || this.getAppointmentDefaultSize(),
                        index = coordinates.index,
                        count = coordinates.count,
                        height = maxHeight / (count > 3 ? 3 : count),
                        width = coordinates.width,
                        top = coordinates.top + index * height,
                        left = coordinates.left,
                        compactAppointmentDefaultSize = this.getCompactAppointmentDefaultSize();
                    if (!this.instance.option("allowResize") || !this.instance.option("allowAllDayResize"))
                        coordinates.skipResizing = true;
                    if (count > 3)
                        if (index > 1) {
                            top = coordinates.top;
                            left = coordinates.left + (index - 2) * compactAppointmentDefaultSize;
                            height = compactAppointmentDefaultSize,
                            width = compactAppointmentDefaultSize;
                            coordinates.skipResizing = true;
                            this._markAppointmentAsVirtual(coordinates, true)
                        }
                        else
                            top += height;
                    return {
                            height: height,
                            width: width,
                            top: top,
                            left: left
                        }
                },
                _getSimpleAppointmentGeometry: function(coordinates) {
                    var width = this._getAppointmentMaxWidth() / coordinates.count,
                        height = coordinates.height,
                        top = coordinates.top,
                        left = coordinates.left + coordinates.index * width;
                    return {
                            height: height,
                            width: width,
                            top: top,
                            left: left
                        }
                },
                isAllDay: function(appointmentData) {
                    var appointmentTakesAllDay = false;
                    this.instance.notifyObserver("appointmentTakesAllDay", {
                        startDate: appointmentData.startDate,
                        endDate: appointmentData.endDate,
                        callback: function(result) {
                            appointmentTakesAllDay = result
                        }
                    });
                    return appointmentData.allDay || appointmentTakesAllDay
                },
                _getAppointmentMaxWidth: function() {
                    return this._defaultWidth - WEEK_APPOINTMENT_DEFAULT_OFFSET || this.getAppointmentDefaultSize()
                },
                calculateAppointmentWidth: function(appointment) {
                    if (!this.isAllDay(appointment))
                        return 0;
                    var startDate = new Date(this._startDate(appointment)),
                        endDate = this._endDate(appointment),
                        cellWidth = this._defaultWidth || this.getAppointmentDefaultSize();
                    dateUtils.correctDateWithUnitBeginning(startDate, "day");
                    var durationInHours = (endDate.getTime() - startDate.getTime()) / 3600000;
                    var width = Math.ceil(durationInHours / 24) * cellWidth;
                    return width
                },
                calculateAppointmentHeight: function(appointment) {
                    if (this.isAllDay(appointment))
                        return 0;
                    var startDate = this._startDate(appointment),
                        endDate = this._endDate(appointment);
                    var durationInMinutes = (endDate.getTime() - startDate.getTime()) / 60000,
                        minHeight = this.getAppointmentDefaultSize();
                    var height = Math.round(durationInMinutes * this._getMinuteHeight());
                    if (height < minHeight)
                        height = minHeight;
                    return height
                },
                _sortCondition: function(a, b) {
                    var allDayCondition = a.allDay - b.allDay;
                    return allDayCondition ? allDayCondition : this._rowCondition(a, b)
                }
            });
        return VerticalRenderingStrategy
    });
    /*! Module widgets-web, file ui.scheduler.appointments.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointments", ["jquery", "/ui/uiNamespace", "/utils/utils.translator", "/utils/utils.array", "/utils/utils.recurrence", "/utils/utils.date", "/utils/utils.common", "/componentRegistrator", "/ui/ui.tooltip", "/ui/widgets/scheduler/ui.scheduler.publisherMixin", "/ui/widgets/scheduler/ui.scheduler.appointments.strategy.vertical", "/ui/widgets/scheduler/ui.scheduler.appointments.strategy.horizontal", "/ui/widgets/scheduler/ui.scheduler.appointments.strategy.horizontalMonth", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer"], function($, ui, translator, array, recurrenceUtils, dateUtils, commonUtils, registerComponent, tooltip, publisherMixin, VerticalAppointmentsStrategy, HorizontalAppointmentsStrategy, HorizontalMonthAppointmentsStrategy, eventUtils, pointerEvents) {
        var CollectionWidget = ui.CollectionWidget;
        var COMPONENT_CLASS = "dx-scheduler-scrollable-appointments",
            APPOINTMENT_ITEM_CLASS = "dx-scheduler-appointment",
            APPOINTMENT_ALL_DAY_ITEM_CLASS = "dx-scheduler-all-day-appointment",
            RECURRENCE_APPOINTMENT_CLASS = "dx-scheduler-appointment-recurrence",
            EMPTY_APPOINTMENT_CLASS = "dx-scheduler-appointment-empty",
            REDUCED_APPOINTMENT_CLASS = "dx-scheduler-appointment-reduced",
            REDUCED_APPOINTMENT_ICON = "dx-scheduler-appointment-reduced-icon",
            REDUCED_APPOINTMENT_PARTS_CLASSES = {
                head: "dx-scheduler-appointment-head",
                body: "dx-scheduler-appointment-body",
                tail: "dx-scheduler-appointment-tail"
            },
            REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME = eventUtils.addNamespace(pointerEvents.enter, "dxSchedulerAppointment"),
            REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME = eventUtils.addNamespace(pointerEvents.leave, "dxSchedulerAppointment"),
            DBLCLICK_EVENT_NAME = eventUtils.addNamespace("dxdblclick", "dxSchedulerAppointment"),
            EMPTY_APPOINTMENT_MAX_WIDTH = 40;
        var RENDERING_STRATEGIES = {
                horizontal: HorizontalAppointmentsStrategy,
                horizontalMonth: HorizontalMonthAppointmentsStrategy,
                vertical: VerticalAppointmentsStrategy
            };
        var SchedulerAppointments = CollectionWidget.inherit({
                _supportedKeys: function(e) {
                    var parent = this.callBase();
                    var tabHandler = function(e) {
                            var appointments = this._getAccessAppointments(),
                                focusedAppointment = appointments.filter(".dx-state-focused"),
                                index = focusedAppointment.attr("sortedIndex"),
                                lastIndex = appointments.length - 1;
                            if (index > 0 && e.shiftKey || index < lastIndex && !e.shiftKey) {
                                e.preventDefault();
                                e.shiftKey ? index-- : index++;
                                var $nextAppointment = this._getAppointmentByIndex(index);
                                this._resetTabIndex($nextAppointment);
                                $nextAppointment.focus()
                            }
                        };
                    return $.extend(parent, {
                            escape: $.proxy(function() {
                                this.moveAppointmentBack();
                                this._escPressed = true
                            }, this),
                            del: $.proxy(function(e) {
                                var data = this._getItemData(e.target);
                                this.notifyObserver("deleteAppointment", {
                                    data: data,
                                    target: e.target
                                });
                                this.notifyObserver("hideAppointmentTooltip")
                            }),
                            tab: tabHandler
                        })
                },
                _getAppointmentByIndex: function(index) {
                    var appointments = this._getAccessAppointments();
                    return appointments.filter("[sortedIndex =" + index + "]").eq(0)
                },
                _getAccessAppointments: function() {
                    return this._itemElements().filter(":visible").not(".dx-state-disabled")
                },
                _resetTabIndex: function($appointment) {
                    this._focusTarget().attr("tabindex", -1);
                    $appointment.attr("tabindex", this.option("tabIndex"))
                },
                _moveFocus: $.noop,
                _focusTarget: function() {
                    return this._itemElements()
                },
                _renderFocusTarget: function() {
                    var $appointment = this._getAppointmentByIndex(0);
                    this._resetTabIndex($appointment)
                },
                _focusInHandler: function(e) {
                    this.callBase.apply(this, arguments);
                    this._$currentAppointment = $(e.target);
                    this.option("focusedElement", $(e.target))
                },
                _focusOutHandler: function(e) {
                    var $appointment = this._getAppointmentByIndex(0);
                    this.option("focusedElement", $appointment);
                    this.callBase.apply(this, arguments)
                },
                _eventBindingTarget: function() {
                    return this._itemContainer()
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            noDataText: null,
                            activeStateEnabled: true,
                            hoverStateEnabled: true,
                            tabIndex: 0,
                            appointmentDurationInMinutes: 30,
                            fixedContainer: null,
                            allDayContainer: null,
                            renderingStrategy: "vertical",
                            allowDrag: true,
                            allowResize: true,
                            allowAllDayResize: true,
                            onAppointmentDblClick: null,
                            dayDuration: 24
                        })
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"renderingStrategy":
                            this._initRenderingStrategy();
                            break;
                        case"fixedContainer":
                        case"allDayContainer":
                        case"onAppointmentDblClick":
                            break;
                        case"allowDrag":
                        case"allowResize":
                        case"allowAllDayResize":
                        case"dayDuration":
                        case"appointmentDurationInMinutes":
                            this.repaint();
                            break;
                        case"focusedElement":
                            this._resetTabIndex($(args.value));
                            this.callBase(args);
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _itemClass: function() {
                    return APPOINTMENT_ITEM_CLASS
                },
                _itemContainer: function() {
                    var $container = this.callBase(),
                        $result = $container,
                        $allDayContainer = this.option("allDayContainer");
                    if ($allDayContainer)
                        $result = $container.add($allDayContainer);
                    return $result
                },
                _cleanItemContainer: function() {
                    this.callBase();
                    var $allDayContainer = this.option("allDayContainer");
                    if ($allDayContainer)
                        $allDayContainer.empty();
                    this._virtualAppointments = {}
                },
                _clean: function() {
                    this.callBase();
                    delete this._$currentAppointment;
                    delete this._initialSize;
                    delete this._initialCoordinates
                },
                _init: function() {
                    this.callBase();
                    this._initRenderingStrategy();
                    this.element().addClass(COMPONENT_CLASS);
                    this._preventSingleAppointmentClick = false
                },
                _initRenderingStrategy: function() {
                    var Strategy = RENDERING_STRATEGIES[this.option("renderingStrategy")];
                    this._renderingStrategy = new Strategy(this)
                },
                _executeItemRenderAction: function(index, itemData, itemElement) {
                    var action = this._getItemRenderAction();
                    if (action)
                        action({
                            appointmentElement: itemElement,
                            appointmentData: itemData
                        })
                },
                _getStartDate: function(appointment, skipNormalize) {
                    var startDate = dateUtils.makeDate(appointment.startDate);
                    !skipNormalize && this.notifyObserver("updateAppointmentStartDate", {
                        startDate: startDate,
                        callback: function(result) {
                            startDate = result
                        }
                    });
                    return startDate
                },
                _getEndDate: function(appointment) {
                    var result = appointment.endDate;
                    if (result)
                        return dateUtils.makeDate(result);
                    return result
                },
                _itemClickHandler: function(e) {
                    this.callBase(e, {}, {afterExecute: $.proxy(function(e) {
                            this._processItemClick(e.args[0].jQueryEvent)
                        }, this)})
                },
                _processItemClick: function(e) {
                    var $target = $(e.currentTarget),
                        data = this._getItemData($target);
                    if ($target.is(".dx-state-disabled, .dx-state-disabled *")) {
                        e.stopPropagation();
                        return
                    }
                    this._normalizeAppointmentDates(data);
                    if (e.type === "keydown" || eventUtils.isFakeClickEvent(e)) {
                        this.notifyObserver("showEditAppointmentPopup", {
                            data: data,
                            target: $target
                        });
                        return
                    }
                    this._appointmentClickTimeout = setTimeout($.proxy(function() {
                        if (!this._preventSingleAppointmentClick)
                            this.notifyObserver("showAppointmentTooltip", {
                                data: data,
                                target: $target
                            });
                        this._preventSingleAppointmentClick = false
                    }, this), 300)
                },
                _normalizeAppointmentDates: function(appointmentData) {
                    var startDate = dateUtils.makeDate(appointmentData.startDate),
                        endDate = dateUtils.makeDate(appointmentData.endDate);
                    appointmentData.startDate = startDate;
                    appointmentData.endDate = endDate
                },
                _extendActionArgs: function() {
                    var args = this.callBase.apply(this, arguments);
                    return {
                            appointmentData: args.itemData,
                            appointmentElement: args.itemElement
                        }
                },
                _render: function() {
                    this.callBase.apply(this, arguments);
                    this._attachAppointmentDblClick()
                },
                _attachAppointmentDblClick: function() {
                    var that = this,
                        itemSelector = that._itemSelector();
                    this._itemContainer().off(DBLCLICK_EVENT_NAME, itemSelector).on(DBLCLICK_EVENT_NAME, itemSelector, function(e) {
                        that._itemJQueryEventHandler(e, "onAppointmentDblClick", {}, {afterExecute: function(e) {
                                that._dblClickHandler(e.args[0].jQueryEvent)
                            }})
                    })
                },
                _dblClickHandler: function(e) {
                    var $targetAppointment = $(e.currentTarget),
                        appointmentData = this._getItemData($targetAppointment);
                    clearTimeout(this._appointmentClickTimeout);
                    this._preventSingleAppointmentClick = true;
                    this.notifyObserver("showEditAppointmentPopup", {
                        data: appointmentData,
                        target: $targetAppointment
                    })
                },
                _renderItems: function(items) {
                    if (this._isContainerInvisible())
                        return;
                    this._positionMap = this._renderingStrategy.createTaskPositionMap(items);
                    this.callBase(items)
                },
                _renderItem: function(index, itemData) {
                    var $allDayContainer = this.option("allDayContainer"),
                        $container = this.itemsContainer().not($allDayContainer);
                    if (this._renderingStrategy.isAllDay(itemData) && $allDayContainer)
                        $container = $allDayContainer;
                    this.callBase(index, itemData, $container)
                },
                _toggleAllDayClass: function($element, value) {
                    $element.toggleClass(APPOINTMENT_ALL_DAY_ITEM_CLASS, !!value)
                },
                _virtualAppointments: {},
                _postprocessRenderItem: function(args) {
                    var $appointment = args.itemElement,
                        itemData = args.itemData,
                        itemSettings = this._positionMap[args.itemIndex];
                    $appointment.attr("title", itemData.text);
                    this.setAria("role", "button", $appointment);
                    this._toggleAllDayClass($appointment, this._renderingStrategy.isAllDay(itemData));
                    var deferredColor = this._paintAppointment($appointment, 0);
                    recurrenceUtils.getRecurrenceRule(itemData.recurrenceRule).isValid && $appointment.addClass(RECURRENCE_APPOINTMENT_CLASS);
                    this._applyResourceDataAttr($appointment);
                    this._renderAppointmentClones($appointment, itemSettings);
                    this._renderAppointment($appointment, itemSettings[0]);
                    if (itemSettings[0].virtual)
                        deferredColor.done($.proxy(function(color) {
                            this._processVirtualAppointment(itemSettings[0], $appointment, itemData, color)
                        }, this))
                },
                _renderAppointment: function($appointment, settings) {
                    this._renderAppointmentGeometry($appointment, settings);
                    $appointment.attr("sortedIndex", settings.sortedIndex);
                    if (settings.sortedIndex === 0)
                        this._resetTabIndex($appointment);
                    this._renderDraggable($appointment);
                    if (!commonUtils.isDefined(settings.skipResizing) || commonUtils.isObject(settings.skipResizing))
                        this._renderResizable($appointment, settings);
                    if (settings.appointmentReduced)
                        this._renderReducedAppointment($appointment, settings.appointmentReduced.appointmentPart)
                },
                _processVirtualAppointment: function(appointmentSetting, $appointment, itemData, color) {
                    var virtualAppointment = appointmentSetting.virtual,
                        virtualGroupIndex = virtualAppointment.groupIndex;
                    if (!commonUtils.isDefined(this._virtualAppointments[virtualGroupIndex]))
                        this._virtualAppointments[virtualGroupIndex] = {
                            coordinates: {
                                top: virtualAppointment.top,
                                left: virtualAppointment.left
                            },
                            items: [],
                            isAllDay: virtualAppointment.isAllDay,
                            color: color
                        };
                    this._virtualAppointments[virtualGroupIndex].items.push(itemData);
                    $appointment.remove()
                },
                _renderContentImpl: function() {
                    this.callBase();
                    this._renderDropDownAppointments()
                },
                _renderDropDownAppointments: function() {
                    var buttonWidth = this._renderingStrategy.getCompactAppointmentGroupMaxWidth(),
                        rtlOffset = 0;
                    if (this.option("rtlEnabled"))
                        rtlOffset = this._calculateDropDownButtonRtlOffset(buttonWidth);
                    $.each(this._virtualAppointments, $.proxy(function(groupIndex, appointment) {
                        var virtualGroup = this._virtualAppointments[groupIndex],
                            virtualItems = virtualGroup.items,
                            virtualCoordinates = virtualGroup.coordinates,
                            $container = virtualGroup.isAllDay ? this.option("allDayContainer") : this.element(),
                            left = virtualCoordinates.left;
                        this.notifyObserver("renderDropDownAppointments", {
                            $container: $container,
                            coordinates: {
                                top: virtualCoordinates.top,
                                left: left + rtlOffset
                            },
                            items: virtualItems,
                            color: virtualGroup.color,
                            itemTemplate: this.option("itemTemplate"),
                            buttonWidth: buttonWidth
                        })
                    }, this))
                },
                _calculateDropDownButtonRtlOffset: function(dropDownWidth) {
                    return this._renderingStrategy.getDefaultCellWidth() - dropDownWidth
                },
                _renderAppointmentGeometry: function($appointment, coordinates) {
                    var geometry = this._renderingStrategy.getAppointmentGeometry(coordinates);
                    if (!this.option("allowResize"))
                        coordinates.skipResizing = true;
                    translator.move($appointment, {
                        top: geometry.top,
                        left: geometry.left
                    });
                    $appointment.css({
                        width: geometry.width,
                        height: geometry.height
                    });
                    if (geometry.width < EMPTY_APPOINTMENT_MAX_WIDTH)
                        $appointment.addClass(EMPTY_APPOINTMENT_CLASS)
                },
                _isContainerInvisible: function() {
                    var isContainerInvisible = false;
                    this.notifyObserver("checkContainerVisibility", {callback: function(result) {
                            isContainerInvisible = result
                        }});
                    return isContainerInvisible
                },
                _applyResourceDataAttr: function($appointment) {
                    this.notifyObserver("getResourcesFromItem", {
                        itemData: this._getItemData($appointment),
                        callback: function(resources) {
                            if (resources)
                                $.each(resources, function(name, values) {
                                    var attr = "data-" + name.toLowerCase() + "-";
                                    for (var i = 0; i < values.length; i++)
                                        $appointment.attr(attr + values[i], true)
                                })
                        }
                    })
                },
                _renderDraggable: function($appointment) {
                    if (!this.option("allowDrag"))
                        return;
                    var that = this,
                        appointmentData = that._getItemData($appointment),
                        isAllDay = this._renderingStrategy.isAllDay(appointmentData),
                        $fixedContainer = this.option("fixedContainer"),
                        draggableArea;
                    this.notifyObserver("getDraggableAppointmentArea", {callback: function(result) {
                            if (result)
                                draggableArea = result
                        }});
                    this._createComponent($appointment, "dxDraggable", {
                        onDragStart: function(e) {
                            that.notifyObserver("hideAppointmentTooltip");
                            that.notifyObserver("getDragEventTargetElements", {callback: function(result) {
                                    if (result)
                                        e.jQueryEvent.targetElements = result
                                }});
                            $fixedContainer.append($appointment);
                            that._$currentAppointment = $(e.element);
                            that._initialSize = {
                                width: e.width,
                                height: e.height
                            };
                            that._initialCoordinates = translator.locate(e.element)
                        },
                        onDrag: function(e) {
                            var coordinates = translator.locate(e.element);
                            that.notifyObserver("correctAppointmentCoordinates", {
                                coordinates: coordinates,
                                allDay: isAllDay,
                                callback: function(result) {
                                    if (result)
                                        coordinates = result
                                }
                            });
                            translator.move($appointment, coordinates)
                        },
                        onDragEnd: function(e) {
                            that.element().append($appointment);
                            if (this._escPressed) {
                                e.jQueryEvent.cancel = true;
                                return
                            }
                            that._dragEndHandler(e)
                        },
                        area: draggableArea,
                        boundOffset: that._calculateBoundOffset()
                    })
                },
                _updateDraggablesBoundOffsets: function() {
                    if (this.option("allowDrag"))
                        this.element().find("." + APPOINTMENT_ITEM_CLASS).each($.proxy(function(_, appointmentElement) {
                            var $appointment = $(appointmentElement),
                                appointmentData = this._getItemData($appointment);
                            if (!this._renderingStrategy.isAllDay(appointmentData))
                                $appointment.dxDraggable("instance").option("boundOffset", this._calculateBoundOffset())
                        }, this))
                },
                _calculateBoundOffset: function() {
                    var scheduler = this.option("observer");
                    return {top: scheduler ? -scheduler.getWorkSpaceAllDayHeight() : 0}
                },
                _renderResizable: function($appointment, itemSetting) {
                    var appointmentData = this._getItemData($appointment),
                        skippedResizableDirection = itemSetting.skipResizing ? itemSetting.skipResizing.skipDirection : null,
                        config = this._renderingStrategy.resizableConfig(appointmentData, skippedResizableDirection);
                    $.extend(config, {
                        area: this._calculateResizableArea(itemSetting, appointmentData),
                        onResizeStart: $.proxy(function(e) {
                            this._$currentAppointment = $(e.element);
                            this._initialSize = {
                                width: e.width,
                                height: e.height
                            };
                            this._initialCoordinates = translator.locate(e.element)
                        }, this),
                        onResizeEnd: $.proxy(function(e) {
                            if (this._escPressed) {
                                e.jQueryEvent.cancel = true;
                                return
                            }
                            this._resizeEndHandler(e)
                        }, this)
                    });
                    this._createComponent($appointment, "dxResizable", config)
                },
                _calculateResizableArea: function(itemSetting, appointmentData) {
                    var area = this.element().closest(".dx-scrollable-content"),
                        allDay = this._renderingStrategy.isAllDay(appointmentData);
                    this.notifyObserver("getResizableAppointmentArea", {
                        coordinates: {
                            left: itemSetting.left,
                            top: 0
                        },
                        allDay: allDay,
                        callback: function(result) {
                            if (result)
                                area = result
                        }
                    });
                    return area
                },
                _paintAppointment: function($appointment, resourceIndex) {
                    var res = $.Deferred();
                    this.notifyObserver("getAppointmentColor", {
                        itemData: this._getItemData($appointment),
                        resourceIndex: resourceIndex,
                        callback: function(d) {
                            d.done(function(color) {
                                if (color)
                                    $appointment.css("background-color", color);
                                res.resolve(color)
                            })
                        }
                    });
                    return res.promise()
                },
                _renderReducedAppointment: function($appointment, reducedAppointmentPart) {
                    $appointment.toggleClass(REDUCED_APPOINTMENT_CLASS, true).toggleClass(REDUCED_APPOINTMENT_PARTS_CLASSES[reducedAppointmentPart], true);
                    this._renderAppointmentReducedIcon($appointment)
                },
                _renderAppointmentReducedIcon: function($appointment) {
                    var $icon = $("<div>").addClass(REDUCED_APPOINTMENT_ICON).appendTo($appointment),
                        endDate = this._getEndDate(this._getItemData($appointment));
                    $icon.off(REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME).on(REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME, function() {
                        tooltip.show({
                            target: $icon,
                            content: Globalize.localize("dxScheduler-editorLabelEndDate") + ": " + Globalize.format(endDate, "d MMMM yyyy")
                        })
                    }).off(REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME).on(REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME, function() {
                        tooltip.hide()
                    })
                },
                _renderAppointmentClones: function($appointment, coordinates) {
                    var coordinateCount = coordinates.length,
                        state,
                        groupCount;
                    this.notifyObserver("getGroupCount", {callback: function(result) {
                            groupCount = result
                        }});
                    var countChunksInGroup = coordinateCount / groupCount;
                    if (coordinateCount > 1) {
                        var itemData = this._getItemData($appointment),
                            resourceForPainting = this._getResourceForPainting(),
                            resourceValuesCount = array.wrapToArray(itemData[resourceForPainting]).length;
                        for (var i = coordinateCount - 1; i > 0; i--) {
                            var $clone = $appointment.clone(true);
                            $appointment.after($clone);
                            translator.clearCache($clone);
                            this._renderAppointment($clone, coordinates[i]);
                            if (resourceForPainting)
                                state = this._paintClone($clone, resourceValuesCount, countChunksInGroup, state, coordinates[i]);
                            if (coordinates[i].virtual)
                                if (!resourceForPainting)
                                    this._processVirtualAppointment(coordinates[i], $clone, itemData)
                        }
                    }
                },
                _paintClone: function($clone, resourceValuesCount, countChunksInGroup, state, currentClone) {
                    if (!state)
                        state = {
                            processedChunksCount: 0,
                            currentResourceValueIndex: resourceValuesCount - 1
                        };
                    this._paintAppointment($clone, state.currentResourceValueIndex).done($.proxy(function(color) {
                        if (currentClone.virtual)
                            this._processVirtualAppointment(currentClone, $clone, this._getItemData($clone), color)
                    }, this));
                    state.processedChunksCount++;
                    if (state.processedChunksCount === countChunksInGroup) {
                        state.currentResourceValueIndex--;
                        if (state.currentResourceValueIndex < 0)
                            state.currentResourceValueIndex = resourceValuesCount - 1;
                        state.processedChunksCount = 0
                    }
                    return state
                },
                _getResourceForPainting: function() {
                    var resourceForPainting;
                    this.notifyObserver("getResourceForPainting", {callback: function(resource) {
                            if (resource)
                                resourceForPainting = resource.field
                        }});
                    return resourceForPainting
                },
                _getDateRange: function(e, startDate, endDate) {
                    var itemData = this._getItemData(e.element),
                        deltaTime = this._renderingStrategy.getDeltaTime(e, this._initialSize, itemData),
                        renderingStrategy = this.option("renderingStrategy"),
                        cond = false;
                    if (renderingStrategy !== "vertical" || this._renderingStrategy.isAllDay(itemData))
                        cond = this.option("rtlEnabled") ? e.handles.right : e.handles.left;
                    else
                        cond = e.handles.top;
                    var startTime = cond ? startDate.getTime() - deltaTime : startDate.getTime(),
                        endTime = cond ? endDate.getTime() : endDate.getTime() + deltaTime;
                    return [startTime, endTime]
                },
                _resizeEndHandler: function(e) {
                    var itemData = this._getItemData(e.element),
                        startDate = this._getStartDate(itemData),
                        endDate = this._getEndDate(itemData);
                    var dateRange = this._getDateRange(e, startDate, endDate);
                    var updatedDates = {};
                    updatedDates.startDate = new Date(dateRange[0]);
                    updatedDates.endDate = new Date(dateRange[1]);
                    var data = $.extend({}, itemData, updatedDates);
                    this.notifyObserver("updateAppointmentAfterResize", {
                        target: itemData,
                        data: data,
                        $appointment: e.element
                    })
                },
                _dragEndHandler: function(e) {
                    var itemData = this._getItemData(e.element),
                        coordinates = this._initialCoordinates;
                    this._normalizeAppointmentDates(itemData);
                    this.notifyObserver("updateAppointmentAfterDrag", {
                        data: itemData,
                        $appointment: e.element,
                        coordinates: coordinates
                    })
                },
                moveAppointmentBack: function() {
                    var $appointment = this._$currentAppointment,
                        size = this._initialSize,
                        coords = this._initialCoordinates;
                    if ($appointment) {
                        if (coords)
                            translator.move($appointment, coords);
                        if (size) {
                            $appointment.outerWidth(size.width);
                            $appointment.outerHeight(size.height)
                        }
                    }
                },
                focus: function() {
                    var $appointment = this._$currentAppointment;
                    if ($appointment) {
                        this.option("focusedElement", $appointment);
                        this.option("focusedElement").focus()
                    }
                }
            }).include(publisherMixin);
        registerComponent("dxSchedulerAppointments", {}, SchedulerAppointments);
        return SchedulerAppointments
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.appointments"]);
    /*! Module widgets-web, file ui.scheduler.appointments.dropDown.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointments.dropDown", ["jquery", "/class", "/utils/utils.translator", "/utils/utils.common", "/ui/widgets/ui.button"], function($, Class, translator, commonUtils, Button) {
        var DROPDOWN_APPOINTMENTS_CLASS = "dx-scheduler-dropdown-appointments",
            DROPDOWN_APPOINTMENTS_CONTENT_CLASS = "dx-scheduler-dropdown-appointments-content",
            DROPDOWN_APPOINTMENT_CLASS = "dx-scheduler-dropdown-appointment",
            DROPDOWN_APPOINTMENT_TITLE_CLASS = "dx-scheduler-dropdown-appointment-title",
            DROPDOWN_APPOINTMENT_DATE_CLASS = "dx-scheduler-dropdown-appointment-date",
            DROPDOWN_APPOINTMENT_REMOVE_BUTTON_CLASS = "dx-scheduler-dropdown-appointment-remove-button",
            DROPDOWN_APPOINTMENT_EDIT_BUTTON_CLASS = "dx-scheduler-dropdown-appointment-edit-button",
            DROPDOWN_APPOINTMENT_INFO_BLOCK_CLASS = "dx-scheduler-dropdown-appointment-info-block",
            DROPDOWN_APPOINTMENT_BUTTONS_BLOCK_CLASS = "dx-scheduler-dropdown-appointment-buttons-block";
        var dropDownAppointments = Class.inherit({
                render: function(options, instance) {
                    var coordinates = options.coordinates,
                        items = options.items;
                    this.instance = instance;
                    var $menu = $("<div>").addClass(DROPDOWN_APPOINTMENTS_CLASS).appendTo(options.$container);
                    this.instance._createComponent($menu, Button, {
                        template: this._createButtonTemplate(items.length),
                        width: options.buttonWidth,
                        onClick: $.proxy(function() {
                            this._createDropDownMenu($menu, items, options.itemTemplate, options.color, options.buttonWidth)
                        }, this)
                    });
                    if (options.color)
                        $menu.css("background-color", options.color);
                    this._applyInnerShadow($menu, options.buttonWidth);
                    translator.move($menu, {
                        top: coordinates.top,
                        left: coordinates.left
                    });
                    return $menu
                },
                repaintExisting: function($container) {
                    var appointmentnsSelector = ["", DROPDOWN_APPOINTMENTS_CLASS, "dx-dropdownmenu"].join(".");
                    $container.find(appointmentnsSelector).each(function() {
                        $(this).dxDropDownMenu("instance").repaint()
                    })
                },
                _createButtonTemplate: function(appointmentCount) {
                    return $("<div />").html([$("<span />").text(appointmentCount), $("<span />").text("...")]).addClass(DROPDOWN_APPOINTMENTS_CONTENT_CLASS)
                },
                _applyInnerShadow: function($element) {
                    $element.css("box-shadow", "inset " + $element.outerWidth() + "px 0 0 0 rgba(0, 0, 0, 0.3)")
                },
                _createDropDownMenu: function($element, items, itemTemplate, color, buttonWidth) {
                    if (!$element.data("dxDropDownMenu")) {
                        itemTemplate = $.proxy(function(appointmentData, index, appointmentElement) {
                            this._createDropDownAppointmentTemplate(appointmentData, index, appointmentElement, color)
                        }, this);
                        this.instance._createComponent($element, "dxDropDownMenu", {
                            buttonIcon: null,
                            usePopover: true,
                            popupHeight: 200,
                            items: items,
                            buttonTemplate: this._createButtonTemplate(items.length),
                            buttonWidth: buttonWidth,
                            onItemClick: function(args) {
                                args.component.open()
                            },
                            activeStateEnabled: false,
                            focusStateEnabled: false,
                            itemTemplate: itemTemplate
                        }).open()
                    }
                },
                _createDropDownAppointmentTemplate: function(appointmentData, index, appointmentElement, color) {
                    var dateString = "",
                        appointmentMarkup = [],
                        borderSide = "left",
                        $title,
                        $date,
                        $infoBlock;
                    appointmentElement.addClass(DROPDOWN_APPOINTMENT_CLASS);
                    if (this.instance.option("rtlEnabled"))
                        borderSide = "right";
                    if (color)
                        appointmentElement.css("border-" + borderSide + "-color", color);
                    this.instance.fire("normalizeAppointmentDates", {
                        appointmentData: appointmentData,
                        callback: function(result) {
                            appointmentData = result
                        }
                    });
                    this.instance.fire("formatDates", {
                        startDate: appointmentData.startDate,
                        endDate: appointmentData.endDate,
                        formatType: "DATETIME",
                        callback: function(result) {
                            dateString = result
                        }
                    });
                    $infoBlock = $("<div />").addClass(DROPDOWN_APPOINTMENT_INFO_BLOCK_CLASS);
                    $title = $("<div>").addClass(DROPDOWN_APPOINTMENT_TITLE_CLASS).text(appointmentData.text);
                    $date = $("<div>").addClass(DROPDOWN_APPOINTMENT_DATE_CLASS).text(dateString);
                    $infoBlock.append([$title, $date]);
                    appointmentMarkup.push($infoBlock);
                    appointmentMarkup.push(this._createButtons(appointmentData));
                    appointmentElement.append(appointmentMarkup)
                },
                _createButtons: function(appointmentData) {
                    var editing = this.instance.option("editing"),
                        allowDeleting = false,
                        allowUpdating = false;
                    if (!editing)
                        return "";
                    if (editing === true) {
                        allowDeleting = true;
                        allowUpdating = true
                    }
                    if (commonUtils.isObject(editing)) {
                        allowDeleting = editing.allowDeleting;
                        allowUpdating = editing.allowUpdating
                    }
                    var $container = $("<div />").addClass(DROPDOWN_APPOINTMENT_BUTTONS_BLOCK_CLASS),
                        $removeButton = $("<div>").addClass(DROPDOWN_APPOINTMENT_REMOVE_BUTTON_CLASS),
                        $editButton = $("<div>").addClass(DROPDOWN_APPOINTMENT_EDIT_BUTTON_CLASS);
                    if (allowDeleting) {
                        $container.append($removeButton);
                        this.instance._createComponent($removeButton, Button, {
                            icon: "trash",
                            height: 25,
                            width: 25,
                            onClick: $.proxy(function(e) {
                                e.jQueryEvent.stopPropagation();
                                this.instance.deleteAppointment(appointmentData)
                            }, this)
                        })
                    }
                    if (allowUpdating) {
                        $container.append($editButton);
                        this.instance._createComponent($editButton, Button, {
                            icon: "edit",
                            height: 25,
                            width: 25,
                            onClick: $.proxy(function(e) {
                                e.jQueryEvent.stopPropagation();
                                this.instance.fire("showEditAppointmentPopup", {data: appointmentData})
                            }, this)
                        })
                    }
                    return $container
                }
            });
        return dropDownAppointments
    });
    /*! Module widgets-web, file ui.scheduler.subscribes.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.subscribes", ["jquery", "/utils/utils.array", "/utils/utils.recurrence", "/utils/utils.date", "/utils/utils.translator"], function($, array, recurrenceUtils, dateUtils, translator) {
        var subscribes = {
                currentViewUpdated: function(currentView) {
                    this.option("currentView", currentView)
                },
                needCoordinates: function(options) {
                    var appointmentData = options.appointmentData,
                        startDate = options.startDate,
                        dateRange = this._workSpace.getDateRange(),
                        dates = recurrenceUtils.getDatesByRecurrence(appointmentData.recurrenceRule, startDate, dateRange[0], dateRange[1], appointmentData.recurrenceException);
                    if (!dates.length)
                        dates.push(startDate);
                    var itemResources = this._resourcesManager.getResourcesFromItem(appointmentData),
                        allDay = this.appointmentTakesAllDay(appointmentData) && this._workSpace.supportAllDayRow();
                    options.callback(this._getCoordinates(dates, itemResources, allDay))
                },
                showEditAppointmentPopup: function(options) {
                    var appointmentData = options.data,
                        $appointment = $(options.target),
                        singleAppointmentData = this._getSingleAppointmentData(appointmentData, $appointment, options),
                        that = this;
                    this._checkRecurringAppointment(appointmentData, singleAppointmentData, singleAppointmentData.startDate, function() {
                        that.showAppointmentPopup(appointmentData)
                    }, false, true)
                },
                showAppointmentTooltip: function(options) {
                    var appointmentData = options.data,
                        $appointment = $(options.target),
                        singleAppointmentData = this._getSingleAppointmentData(appointmentData, $appointment, options);
                    this.showAppointmentTooltip(appointmentData, singleAppointmentData, options.target)
                },
                hideAppointmentTooltip: function() {
                    this._hideTooltip()
                },
                showAddAppointmentPopup: function(appointmentData) {
                    this.showAppointmentPopup(appointmentData, true)
                },
                deleteAppointment: function(options) {
                    var appointmentData = options.data,
                        $appointment = $(options.target),
                        singleAppointmentData = this._getSingleAppointmentData(appointmentData, $appointment, options);
                    this._checkRecurringAppointment(appointmentData, singleAppointmentData, singleAppointmentData.startDate, $.proxy(function() {
                        this.deleteAppointment(appointmentData)
                    }, this), true)
                },
                updateAppointmentAfterResize: function(options) {
                    var targetAppointment = options.target,
                        $appointment = options.$appointment,
                        singleAppointment = this._getSingleAppointmentData(targetAppointment, $appointment, options);
                    this._checkRecurringAppointment(targetAppointment, singleAppointment, singleAppointment.startDate, $.proxy(function() {
                        this._updateAppointment(targetAppointment, options.data, function() {
                            this._appointments.moveAppointmentBack()
                        })
                    }, this))
                },
                updateAppointmentAfterDrag: function(options) {
                    var target = options.data,
                        updatedData = this._getUpdatedData(options),
                        newCellIndex = this._workSpace.getDroppableCellIndex(),
                        oldCellIndex = this._workSpace.getCellIndexByCoordinates(options.coordinates);
                    if (this.appointmentTakesAllDay(target) && !updatedData.allDay && this.option("currentView") !== "month")
                        updatedData.endDate = this._workSpace._calculateEndDate(updatedData.startDate);
                    var appointment = $.extend({}, target, updatedData);
                    var isAllDay = target.allDay || updatedData.allDay,
                        allowAllDay = this.option("currentView") !== "month" && isAllDay,
                        cellData = this._workSpace.getCellDataByCoordinates(options.coordinates, allowAllDay);
                    if (newCellIndex !== oldCellIndex || isAllDay)
                        this._checkRecurringAppointment(target, appointment, cellData.startDate, $.proxy(function() {
                            this._updateAppointment(target, appointment, function() {
                                this._appointments.moveAppointmentBack()
                            })
                        }, this));
                    else
                        this._appointments.moveAppointmentBack()
                },
                updateCurrentDate: function(date) {
                    this.option("currentDate", this._stripDateTime(dateUtils.makeDate(date)))
                },
                getAppointmentColor: function(options) {
                    var resourceForPainting = this._resourcesManager.getResourceForPainting(this.option("groups")),
                        response = $.Deferred().resolve().promise();
                    if (resourceForPainting) {
                        var field = resourceForPainting.field;
                        if (options.itemData[field]) {
                            var resourceValues = array.wrapToArray(options.itemData[field]),
                                resourceIndex = options.resourceIndex,
                                groups = this.option("groups");
                            if (!groups || !groups.length)
                                resourceIndex = 0;
                            response = this._resourcesManager.getResourceColor(field, resourceValues[resourceIndex])
                        }
                    }
                    options.callback(response)
                },
                getResourceForPainting: function(options) {
                    options.callback(this._resourcesManager.getResourceForPainting(this.option("groups")))
                },
                getResourcesFromItem: function(options) {
                    options.callback(this._resourcesManager.getResourcesFromItem(options.itemData))
                },
                getCellDimensions: function(options) {
                    if (this._workSpace)
                        options.callback(this._workSpace.getCellWidth(), this._workSpace.getCellHeight(), this._workSpace.getAllDayHeight())
                },
                getMaxAllowedPosition: function(options) {
                    if (this._workSpace)
                        options.callback(this._workSpace.getMaxAllowedPosition())
                },
                getItemGroupIndexes: function(options) {
                    var groups = this._resourcesManager.getResourcesFromItem(options.item),
                        indexes = this._workSpace._getGroupIndexes(groups);
                    options.callback(indexes)
                },
                appointmentTakesAllDay: function(options) {
                    options.callback(this.appointmentTakesAllDay({
                        startDate: options.startDate,
                        endDate: options.endDate
                    }))
                },
                checkContainerVisibility: function(options) {
                    options.callback(this.element().is(":hidden"))
                },
                getResizableAppointmentArea: function(options) {
                    var area;
                    if (this.option("groups") && this.option("groups").length && (options.allDay || this.option("currentView") === "month")) {
                        var groupBounds = this._workSpace.getGroupBounds(options.coordinates);
                        area = {
                            left: groupBounds.left,
                            right: groupBounds.right,
                            top: 0,
                            bottom: 0
                        }
                    }
                    options.callback(area)
                },
                getDraggableAppointmentArea: function(options) {
                    options.callback(this.getWorkSpaceScrollableContainer())
                },
                getDragEventTargetElements: function(options) {
                    options.callback(this.element)
                },
                correctAppointmentCoordinates: function(options) {
                    var updatedCoordinates,
                        isAllDay = options.allDay;
                    var scrollTop = !isAllDay ? this.getWorkSpaceScrollableScrollTop() : 0,
                        headerHeight = this.getWorkSpaceHeaderPanelHeight(),
                        scrollLeft = this.getWorkSpaceScrollableScrollLeft(),
                        tableHorizontalOffset = this.getWorkSpaceDateTableOffset(),
                        allDayPanelVerticalOffset = !isAllDay ? this.getWorkSpaceAllDayHeight() : 0;
                    updatedCoordinates = {
                        top: options.coordinates.top - scrollTop + allDayPanelVerticalOffset + headerHeight,
                        left: options.coordinates.left - scrollLeft - tableHorizontalOffset
                    };
                    options.callback(updatedCoordinates)
                },
                allDayPanelToggled: function() {
                    this._appointments._updateDraggablesBoundOffsets()
                },
                normalizeAppointmentDates: function(options) {
                    var appointmentData = options.appointmentData;
                    var startDate = dateUtils.makeDate(appointmentData.startDate),
                        endDate = dateUtils.makeDate(appointmentData.endDate);
                    appointmentData.startDate = startDate;
                    appointmentData.endDate = endDate;
                    options.callback(appointmentData)
                },
                formatDates: function(options) {
                    var startDate = options.startDate,
                        endDate = options.endDate,
                        formatType = options.formatType;
                    var formatTypes = {
                            DATETIME: function() {
                                var dateTimeFormat = "MMMM d h:mm tt",
                                    startDateString = Globalize.format(startDate, dateTimeFormat) + " - ";
                                var endDateString = startDate.getDate() === endDate.getDate() ? Globalize.format(endDate, "t") : Globalize.format(endDate, dateTimeFormat);
                                return startDateString + endDateString
                            },
                            TIME: function() {
                                return Globalize.format(startDate, "t") + " - " + Globalize.format(endDate, "t")
                            },
                            DATE: function() {
                                var dateTimeFormat = "d MMMM",
                                    startDateString = Globalize.format(startDate, dateTimeFormat),
                                    isDurationMoreThanDay = endDate.getTime() - startDate.getTime() > 24 * 3600000;
                                var endDateString = isDurationMoreThanDay || endDate.getDate() !== startDate.getDate() ? " - " + Globalize.format(endDate, dateTimeFormat) : "";
                                return startDateString + endDateString
                            }
                        };
                    options.callback(formatTypes[formatType]())
                },
                getFullWeekAppointmentWidth: function(options) {
                    var groupIndex = options.groupIndex,
                        groupWidth = this._workSpace.getGroupWidth(groupIndex);
                    options.callback(groupWidth)
                },
                getMaxAppointmentWidth: function(options) {
                    var cellCountToLastViewDate = this._workSpace.getCellCountToLastViewDate(options.date);
                    options.callback(cellCountToLastViewDate * this._workSpace.getCellWidth())
                },
                updateAppointmentStartDate: function(options) {
                    var firstViewDate = this._workSpace.getFirstViewDate(),
                        updatedStartDate = dateUtils.normalizeDate(options.startDate, firstViewDate);
                    options.callback(updatedStartDate)
                },
                renderDropDownAppointments: function(options) {
                    this._dropDownAppointments.render(options, this)
                },
                getGroupCount: function(options) {
                    var groupCount = this._workSpace._getGroupCount();
                    options.callback(groupCount)
                },
                updateResizableArea: function() {
                    var $allResizableElements = this.element().find(".dx-scheduler-appointment.dx-resizable");
                    var horizontalResizables = $.grep($allResizableElements, function(el) {
                            var $el = $(el),
                                resizableInst = $el.dxResizable("instance"),
                                area = resizableInst.option("area");
                            return $.inArray(resizableInst.option("handles"), ["right left", "left right"]) > -1 && $.isPlainObject(area)
                        });
                    $.each(horizontalResizables, $.proxy(function(_, el) {
                        var $el = $(el),
                            position = translator.locate($el),
                            appointmentData = this._appointments._getItemData($el);
                        var area = this._appointments._calculateResizableArea({left: position.left}, appointmentData);
                        $el.dxResizable("instance").option("area", area)
                    }, this))
                },
                recurrenceEditorVisibylityChanged: function(options) {
                    this.recurrenceEditorVisibylityChanged(options.visible)
                }
            };
        return subscribes
    });
    /*! Module widgets-web, file ui.scheduler.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler", ["jquery", "/ui/uiNamespace", "/utils/utils.translator", "/ui/ui.errors", "/ui/ui.dialog", "/utils/utils.recurrence", "/utils/utils.dom", "/utils/utils.date", "/utils/utils.common", "/devices", "/componentRegistrator", "/ui/ui.widget", "/ui/widgets/scheduler/ui.scheduler.subscribes", "/ui/templates/ui.template.function", "/ui/templates/ui.template.dynamic", "/ui/templates/ui.template.move", "/ui/widgets/scheduler/ui.scheduler.appointmentTooltip", "/ui/widgets/scheduler/ui.scheduler.reccurenceEditor", "/ui/widgets/scheduler/ui.scheduler.header", "/ui/widgets/scheduler/ui.scheduler.workSpaceDay", "/ui/widgets/scheduler/ui.scheduler.workSpaceWeek", "/ui/widgets/scheduler/ui.scheduler.workSpaceWorkWeek", "/ui/widgets/scheduler/ui.scheduler.workSpaceMonth", "/ui/widgets/scheduler/ui.scheduler.timelineDay", "/ui/widgets/scheduler/ui.scheduler.timelineWeek", "/ui/widgets/scheduler/ui.scheduler.timelineWorkWeek", "/ui/widgets/scheduler/ui.scheduler.resourceManager", "/ui/widgets/scheduler/ui.scheduler.appointmentModel", "/ui/widgets/scheduler/ui.scheduler.appointments", "/ui/widgets/scheduler/ui.scheduler.appointments.dropDown", "/ui/ui.dataHelper"], function($, ui, translator, errors, dialog, recurrenceUtils, domUtils, dateUtils, commonUtils, devices, registerComponent, Widget, subscribes, FunctionTemplate, DynamicTemplate, MoveTemplate, appointmentTooltip, SchedulerRecurrenceEditor, SchedulerHeader, SchedulerWorkSpaceDay, SchedulerWorkSpaceWeek, SchedulerWorkSpaceWorkWeek, SchedulerWorkSpaceMonth, SchedulerTimelineDay, SchedulerTimelineWeek, SchedulerTimelineWorkWeek, SchedulerResourceManager, SchedulerAppointmentModel, SchedulerAppointments, DropDownAppointments, DataHelperMixin) {
        var WIDGET_CLASS = "dx-scheduler",
            WIDGET_READONLY_CLASS = "dx-scheduler-readonly",
            APPOINTMENT_POPUP_CLASS = "dx-scheduler-appointment-popup",
            RECURRENCE_EDITOR_ITEM_CLASS = "dx-scheduler-recurrence-rule-item",
            RECURRENCE_EDITOR_OPENED_ITEM_CLASS = "dx-scheduler-recurrence-rule-item-opened",
            APPOINTEMENT_POPUP_WIDTH = 610;
        var VIEWS_CONFIG = {
                day: {
                    workSpace: SchedulerWorkSpaceDay,
                    renderingStrategy: "vertical"
                },
                week: {
                    workSpace: SchedulerWorkSpaceWeek,
                    renderingStrategy: "vertical"
                },
                workWeek: {
                    workSpace: SchedulerWorkSpaceWorkWeek,
                    renderingStrategy: "vertical"
                },
                month: {
                    workSpace: SchedulerWorkSpaceMonth,
                    renderingStrategy: "horizontalMonth"
                },
                timelineDay: {
                    workSpace: SchedulerTimelineDay,
                    renderingStrategy: "horizontal"
                },
                timelineWeek: {
                    workSpace: SchedulerTimelineWeek,
                    renderingStrategy: "horizontal"
                },
                timelineWorkWeek: {
                    workSpace: SchedulerTimelineWorkWeek,
                    renderingStrategy: "horizontal"
                }
            };
        var Scheduler = Widget.inherit({
                _stripDateTime: function(date) {
                    dateUtils.correctDateWithUnitBeginning(date, "day");
                    return date
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            views: ["day", "week"],
                            currentView: "day",
                            currentDate: this._stripDateTime(new Date),
                            min: undefined,
                            max: undefined,
                            firstDayOfWeek: undefined,
                            groups: [],
                            resources: [],
                            dataSource: null,
                            appointmentTemplate: "item",
                            startDayHour: 0,
                            endDayHour: 24,
                            editing: {
                                allowAdding: true,
                                allowDeleting: true,
                                allowDragging: true,
                                allowResizing: true,
                                allowUpdating: true
                            },
                            showAllDayPanel: true,
                            recurrenceEditMode: "dialog",
                            cellDuration: 30,
                            onAppointmentRendered: null,
                            onAppointmentClick: null,
                            onAppointmentDblClick: null,
                            onCellClick: null,
                            onAppointmentAdding: null,
                            onAppointmentAdded: null,
                            onAppointmentUpdating: null,
                            onAppointmentUpdated: null,
                            onAppointmentDeleting: null,
                            onAppointmentDeleted: null,
                            onAppointmentFormCreated: null,
                            appointmentTooltipTemplate: "appointmentTooltip",
                            appointmentPopupTemplate: "appointmentPopup",
                            horizontalScrollingEnabled: false,
                            useDropDownViewSwitcher: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }, {
                                device: function(device) {
                                    return !devices.current().generic
                                },
                                options: {
                                    useDropDownViewSwitcher: true,
                                    editing: {
                                        allowDragging: false,
                                        allowResizing: false
                                    }
                                }
                            }])
                },
                _optionChanged: function(args) {
                    var value = args.value,
                        name = args.name;
                    switch (args.name) {
                        case"firstDayOfWeek":
                            this._workSpace.option(name, value);
                            this._header.option(name, value);
                            break;
                        case"currentDate":
                            value = dateUtils.makeDate(value);
                            value = this._stripDateTime(value);
                            this._workSpace.option(name, value);
                            this._header.option(name, value);
                            this._appointments.option("dataSource", []);
                            this._filterAppointmentsByDate();
                            this._reloadDataSource().done($.proxy(function() {
                                this._workSpace.option("allDayExpanded", this._isAllDayExpanded());
                                this._appointments.option("dataSource", this._dataSource)
                            }, this));
                            break;
                        case"dataSource":
                            this._initDataSource();
                            this._appointmentModel.setDataSource(this._dataSource);
                            this._loadResources().done($.proxy(function(resources) {
                                this._filterAppointmentsByDateAndResources(resources);
                                this._workSpace.option("showAllDayPanel", this.option("showAllDayPanel"));
                                this._workSpace.option("allDayExpanded", this._isAllDayExpanded());
                                this._appointments.option(name, this._dataSource)
                            }, this));
                            break;
                        case"min":
                        case"max":
                            this._header.option(name, dateUtils.makeDate(value));
                            this._workSpace.option(name, dateUtils.makeDate(value));
                            break;
                        case"views":
                        case"useDropDownViewSwitcher":
                            this._header.option(name, value);
                            break;
                        case"currentView":
                            this._appointments.option("dataSource", []);
                            this._header.option(name, value);
                            this._loadResources().done($.proxy(function(resources) {
                                this._refreshWorkSpace(resources);
                                this._filterAppointmentsByDateAndResources(resources);
                                this._reloadDataSource().done($.proxy(function() {
                                    this._workSpace.option("allDayExpanded", this._isAllDayExpanded());
                                    this._appointments.option("renderingStrategy", this._getAppointmentsRenderingStrategy());
                                    this._appointments.option("allowAllDayResize", value !== "day");
                                    this._appointments.option("dataSource", this._dataSource)
                                }, this))
                            }, this));
                            break;
                        case"appointmentTemplate":
                            this._appointments.option("itemTemplate", value);
                            break;
                        case"groups":
                            this._loadResources().done($.proxy(function(resources) {
                                this._workSpace.option(name, resources);
                                this._filterAppointmentsByDateAndResources(resources);
                                this._reloadDataSource()
                            }, this));
                            break;
                        case"resources":
                            this._resourcesManager.setResources(value);
                            this._loadResources().done($.proxy(function(resources) {
                                this._workSpace.option("groups", resources);
                                this._filterAppointmentsByDateAndResources(resources);
                                this._reloadDataSource()
                            }, this));
                            break;
                        case"startDayHour":
                        case"endDayHour":
                            this._appointments.option("dataSource", []);
                            this._workSpace.option(name, value);
                            this._appointments.option("dayDuration", this._getDayDuration());
                            this._filterAppointmentsByDate();
                            this._reloadDataSource().done($.proxy(function() {
                                this._appointments.option("dataSource", this._dataSource)
                            }, this));
                            break;
                        case"onAppointmentAdding":
                        case"onAppointmentAdded":
                        case"onAppointmentUpdating":
                        case"onAppointmentUpdated":
                        case"onAppointmentDeleting":
                        case"onAppointmentDeleted":
                        case"onAppointmentFormCreated":
                            this._actions[name] = this._createActionByOption(name);
                            break;
                        case"onAppointmentRendered":
                            this._appointments.option("onItemRendered", this._getAppointmentRenderedAction());
                            break;
                        case"onAppointmentClick":
                            this._appointments.option("onItemClick", this._createActionByOption(name));
                            break;
                        case"onAppointmentDblClick":
                            this._appointments.option(name, this._createActionByOption(name));
                            break;
                        case"onCellClick":
                            this._workSpace.option(name, value);
                            break;
                        case"horizontalScrollingEnabled":
                            this._loadResources().done($.proxy(function(resources) {
                                this._refreshWorkSpace(resources);
                                this._appointments.repaint()
                            }, this));
                            break;
                        case"cellDuration":
                            this._checkCellDuration();
                            this._workSpace.option("hoursInterval", value / 60);
                            this._appointments.option("appointmentDurationInMinutes", value);
                            break;
                        case"tabIndex":
                        case"focusStateEnabled":
                            this._header.option(name, value);
                            this._workSpace.option(name, value);
                            this._appointments.option(name, value);
                            this.callBase(args);
                            break;
                        case"width":
                            this._header.option(name, value);
                            if (this.option("horizontalScrollingEnabled"))
                                this._workSpace.option("width", value);
                            this.callBase(args);
                            this._dimensionChanged();
                            break;
                        case"height":
                            this.callBase(args);
                            this._dimensionChanged();
                            break;
                        case"editing":
                            this._initEditing();
                            var editing = this._editing;
                            this._bringEditingModeToAppointments(editing);
                            if (this._appointmentForm)
                                this._appointmentForm.option("readOnly", this._isReadOnly());
                            this._hideTooltip();
                            break;
                        case"showAllDayPanel":
                            this._loadResources().done($.proxy(function(resources) {
                                this._filterAppointmentsByDateAndResources(resources);
                                this._workSpace.option("allDayExpanded", value);
                                this._workSpace.option(name, value);
                                this._reloadDataSource()
                            }, this));
                            break;
                        case"appointmentTooltipTemplate":
                        case"appointmentPopupTemplate":
                        case"recurrenceEditMode":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _bringEditingModeToAppointments: function(editing) {
                    this._appointments.option({
                        allowDrag: editing.allowDragging,
                        allowResize: editing.allowResizing,
                        allowAllDayResize: editing.allowResizing && this.option("currentView") !== "day"
                    });
                    this._dropDownAppointments.repaintExisting(this.element())
                },
                _isAllDayExpanded: function() {
                    return this.option("showAllDayPanel") && this._hasAllDayAppointments()
                },
                _hasAllDayAppointments: function() {
                    if (!this._dataSource)
                        return;
                    var that = this,
                        items = this._dataSource.items();
                    var result = false;
                    $.each(items, function(index, item) {
                        if (that.appointmentTakesAllDay(item)) {
                            result = true;
                            return false
                        }
                    });
                    return result
                },
                _filterAppointmentsByDate: function() {
                    var dateRange = this._workSpace.getDateRange();
                    this._appointmentModel.filterByDate(dateRange[0], dateRange[1], this.option("startDayHour"), this.option("endDayHour"), !this.option("showAllDayPanel"))
                },
                _filterAppointmentsByDateAndResources: function(resources) {
                    var dateRange = this._workSpace.getDateRange(),
                        that = this;
                    that._appointmentModel.filterByDateAndResources({
                        min: dateRange[0],
                        max: dateRange[1],
                        resources: that._prepareResourcesForFilter(resources),
                        startDayHour: that.option("startDayHour"),
                        endDayHour: that.option("endDayHour"),
                        excludeAllDayAppointments: !that.option("showAllDayPanel") && this._workSpace.supportAllDayRow()
                    })
                },
                _prepareResourcesForFilter: function(resources) {
                    return $.map(resources, function(resource) {
                            var resourceItems = resource.items,
                                data = [];
                            for (var i = 0, len = resourceItems.length; i < len; i++)
                                data.push(resourceItems[i].id);
                            return {
                                    field: resource.name,
                                    data: data
                                }
                        })
                },
                _loadResources: function() {
                    var groups = this.option("groups");
                    return this._resourcesManager.getResourcesValueByFields(groups)
                },
                _reloadDataSource: function() {
                    if (this._dataSource)
                        return this._dataSource.load();
                    return $.Deferred().resolve().promise()
                },
                _dimensionChanged: function() {
                    this._appointments && this._appointments.repaint()
                },
                _visibilityChanged: function(visible) {
                    visible && this._dimensionChanged()
                },
                _dataSourceOptions: function() {
                    return {paginate: false}
                },
                _init: function() {
                    this.callBase();
                    this._initDataSource();
                    this._proxiedCustomizeStoreLoadOptionsHandler = $.proxy(this._customizeStoreLoadOptionsHandler, this);
                    this._customizeStoreLoadOptions();
                    this.element().addClass(WIDGET_CLASS);
                    this._initEditing();
                    this._appointmentModel = new SchedulerAppointmentModel(this._dataSource);
                    this._resourcesManager = new SchedulerResourceManager(this.option("resources"));
                    this._initActions();
                    this._dropDownAppointments = new DropDownAppointments;
                    this._subscribes = subscribes;
                    this._checkCellDuration()
                },
                _checkCellDuration: function() {
                    if ($.inArray(this.option("cellDuration"), [5, 10, 15, 20, 30, 60]) < 0)
                        errors.log("W0007")
                },
                _initEditing: function() {
                    var editing = this.option("editing");
                    this._editing = {
                        allowAdding: !!editing,
                        allowUpdating: !!editing,
                        allowDeleting: !!editing,
                        allowResizing: !!editing,
                        allowDragging: !!editing
                    };
                    if (commonUtils.isObject(editing))
                        this._editing = $.extend(this._editing, editing);
                    this._editing.allowDragging = this._editing.allowDragging && this._editing.allowUpdating;
                    this._editing.allowResizing = this._editing.allowResizing && this._editing.allowUpdating;
                    this.element().toggleClass(WIDGET_READONLY_CLASS, this._isReadOnly())
                },
                _isReadOnly: function() {
                    var result = true,
                        editing = this._editing;
                    for (var prop in editing)
                        if (editing.hasOwnProperty(prop))
                            result = result && !editing[prop];
                    return result
                },
                _customizeStoreLoadOptions: function() {
                    this._dataSource && this._dataSource.on("customizeStoreLoadOptions", this._proxiedCustomizeStoreLoadOptionsHandler)
                },
                _dispose: function() {
                    this._dataSource && this._dataSource.off("customizeStoreLoadOptions", this._proxiedCustomizeStoreLoadOptionsHandler);
                    this.callBase()
                },
                _customizeStoreLoadOptionsHandler: function(options) {
                    options.storeLoadOptions.dxScheduler = {
                        startDate: this._workSpace.getFirstViewDate(),
                        endDate: this._workSpace.getLastViewDate(),
                        resources: this.option("resources")
                    }
                },
                _initActions: function() {
                    this._actions = {
                        onAppointmentAdding: this._createActionByOption("onAppointmentAdding"),
                        onAppointmentAdded: this._createActionByOption("onAppointmentAdded"),
                        onAppointmentUpdating: this._createActionByOption("onAppointmentUpdating"),
                        onAppointmentUpdated: this._createActionByOption("onAppointmentUpdated"),
                        onAppointmentDeleting: this._createActionByOption("onAppointmentDeleting"),
                        onAppointmentDeleted: this._createActionByOption("onAppointmentDeleted"),
                        onAppointmentFormCreated: this._createActionByOption("onAppointmentFormCreated")
                    }
                },
                _getAppointmentRenderedAction: function() {
                    return this._createActionByOption("onAppointmentRendered", {excludeValidators: ["designMode", "disabled", "readOnly"]})
                },
                _defaultAppointmentFormEditors: function(allDay) {
                    var that = this;
                    return [{
                                dataField: "text",
                                editorType: "dxTextBox",
                                label: {text: Globalize.localize("dxScheduler-editorLabelTitle")}
                            }, {
                                dataField: "allDay",
                                editorType: "dxSwitch",
                                label: {text: Globalize.localize("dxScheduler-allDay")},
                                editorOptions: {onValueChanged: function(args) {
                                        var value = args.value,
                                            startDateEditor = that._appointmentForm.getEditor("startDate"),
                                            endDateEditor = that._appointmentForm.getEditor("endDate"),
                                            startDate;
                                        if (startDateEditor && endDateEditor) {
                                            startDateEditor.option("format", value ? "date" : "datetime");
                                            endDateEditor.option("format", value ? "date" : "datetime");
                                            startDate = new Date(startDateEditor.option("value"));
                                            if (value) {
                                                startDateEditor.option("value", that._getAllDayStartDate(startDate));
                                                endDateEditor.option("value", that._getAllDayEndDate(startDate))
                                            }
                                            else if (startDateEditor.option("value")) {
                                                startDate.setHours(that.option("startDayHour"));
                                                startDateEditor.option("value", startDate);
                                                endDateEditor.option("value", that._workSpace._calculateEndDate(startDateEditor.option("value")))
                                            }
                                        }
                                    }}
                            }, {
                                dataField: "startDate",
                                editorType: "dxDateBox",
                                label: {text: Globalize.localize("dxScheduler-editorLabelStartDate")},
                                editorOptions: {
                                    format: allDay ? "date" : "datetime",
                                    onValueChanged: function(args) {
                                        var value = args.value,
                                            previousValue = args.previousValue,
                                            endDateEditor = that._appointmentForm.getEditor("endDate"),
                                            endValue = endDateEditor.option("value");
                                        that._validateAppointmentFormDate(args.component, value, previousValue);
                                        if (endValue <= value) {
                                            var duration = endValue.getTime() - previousValue.getTime();
                                            endDateEditor.option("value", new Date(value.getTime() + duration))
                                        }
                                    }
                                }
                            }, {
                                dataField: "endDate",
                                editorType: "dxDateBox",
                                label: {text: Globalize.localize("dxScheduler-editorLabelEndDate")},
                                editorOptions: {
                                    format: allDay ? "date" : "datetime",
                                    onValueChanged: function(args) {
                                        var value = args.value,
                                            previousValue = args.previousValue,
                                            startDateEditor = that._appointmentForm.getEditor("startDate"),
                                            startValue = startDateEditor.option("value");
                                        that._validateAppointmentFormDate(args.component, value, previousValue);
                                        if (value && startValue >= value) {
                                            var duration = previousValue.getTime() - startValue.getTime();
                                            startDateEditor.option("value", new Date(value.getTime() - duration))
                                        }
                                    }
                                }
                            }, {
                                dataField: "description",
                                editorType: "dxTextArea",
                                label: {text: Globalize.localize("dxScheduler-editorLabelDescription")}
                            }, {
                                dataField: "recurrenceRule",
                                editorType: "dxSchedulerRecurrenceEditor",
                                editorOptions: {observer: that},
                                cssClass: RECURRENCE_EDITOR_ITEM_CLASS,
                                label: {text: Globalize.localize("dxScheduler-editorLabelRecurrence")}
                            }]
                },
                _getAllDayStartDate: function(startDate) {
                    startDate.setHours(0);
                    startDate.setMinutes(0);
                    return startDate
                },
                _getAllDayEndDate: function(startDate) {
                    var endDate = new Date(startDate);
                    endDate.setDate(startDate.getDate() + 1);
                    return endDate
                },
                _validateAppointmentFormDate: function(editor, value, previousValue) {
                    var isCorrectDate = !!value;
                    if (!isCorrectDate)
                        editor.option("value", previousValue)
                },
                _renderFocusTarget: $.noop,
                _render: function() {
                    this.callBase();
                    this._renderHeader();
                    this._appointments = this._createComponent("<div>", SchedulerAppointments, this._appointmentsConfig());
                    this._loadResources().done($.proxy(function(resources) {
                        this._renderWorkSpace(resources);
                        var $fixedContainer = this._workSpace.getFixedContainer(),
                            $allDayContainer = this._workSpace.getAllDayContainer();
                        this._appointments.option({
                            fixedContainer: $fixedContainer,
                            allDayContainer: $allDayContainer
                        });
                        this._filterAppointmentsByDateAndResources(resources);
                        this._workSpace.option("allDayExpanded", this.option("showAllDayPanel"));
                        this._appointments.option("dataSource", this._dataSource)
                    }, this))
                },
                _renderHeader: function() {
                    this._header = this._createComponent("<div>", SchedulerHeader, this._headerConfig());
                    this.element().append(this._header.element())
                },
                _headerConfig: function() {
                    return {
                            observer: this,
                            min: dateUtils.makeDate(this.option("min")),
                            max: dateUtils.makeDate(this.option("max")),
                            views: this.option("views"),
                            firstDayOfWeek: this.option("firstDayOfWeek"),
                            currentView: this.option("currentView"),
                            currentDate: this._stripDateTime(dateUtils.makeDate(this.option("currentDate"))),
                            tabIndex: this.option("tabIndex"),
                            focusStateEnabled: this.option("focusStateEnabled"),
                            width: this.option("width"),
                            rtlEnabled: this.option("rtlEnabled"),
                            useDropDownViewSwitcher: this.option("useDropDownViewSwitcher")
                        }
                },
                _appointmentsConfig: function() {
                    var editing = this._editing,
                        that = this;
                    return {
                            observer: this,
                            renderingStrategy: this._getAppointmentsRenderingStrategy(),
                            itemTemplate: this._getTemplateByOption("appointmentTemplate"),
                            onItemRendered: this._getAppointmentRenderedAction(),
                            onItemClick: this._createActionByOption("onAppointmentClick"),
                            onAppointmentDblClick: this._createActionByOption("onAppointmentDblClick"),
                            tabIndex: this.option("tabIndex"),
                            focusStateEnabled: this.option("focusStateEnabled"),
                            appointmentDurationInMinutes: this.option("cellDuration"),
                            allowDrag: editing.allowDragging,
                            allowResize: editing.allowResizing,
                            allowAllDayResize: editing.allowResizing && this.option("currentView") !== "day",
                            rtlEnabled: this.option("rtlEnabled"),
                            onContentReady: function() {
                                that._workSpace && that._workSpace.option("allDayExpanded", that._isAllDayExpanded())
                            },
                            dayDuration: this._getDayDuration()
                        }
                },
                _getAppointmentsRenderingStrategy: function() {
                    return VIEWS_CONFIG[this.option("currentView")].renderingStrategy
                },
                _getDayDuration: function() {
                    return this.option("endDayHour") - this.option("startDayHour")
                },
                _renderWorkSpace: function(groups) {
                    this._workSpace = this._createComponent("<div>", VIEWS_CONFIG[this.option("currentView")].workSpace, this._workSpaceConfig(groups));
                    this._workSpace.getWorkArea().append(this._appointments.element());
                    this.element().append(this._workSpace.element());
                    domUtils.triggerShownEvent(this._workSpace.element())
                },
                _workSpaceConfig: function(groups) {
                    return {
                            observer: this,
                            min: dateUtils.makeDate(this.option("min")),
                            max: dateUtils.makeDate(this.option("max")),
                            currentDate: this._stripDateTime(dateUtils.makeDate(this.option("currentDate"))),
                            firstDayOfWeek: this.option("firstDayOfWeek"),
                            groups: groups,
                            startDayHour: this.option("startDayHour"),
                            endDayHour: this.option("endDayHour"),
                            tabIndex: this.option("tabIndex"),
                            focusStateEnabled: this.option("focusStateEnabled"),
                            hoursInterval: this.option("cellDuration") / 60,
                            showAllDayPanel: this.option("showAllDayPanel"),
                            allDayExpanded: this._isAllDayExpanded(),
                            onCellClick: this._createActionByOption("onCellClick"),
                            horizontalScrollingEnabled: this.option("horizontalScrollingEnabled")
                        }
                },
                _refreshWorkSpace: function(groups) {
                    this._appointments.element().detach();
                    this._workSpace._dispose();
                    this._workSpace.element().remove();
                    delete this._workSpace;
                    this._renderWorkSpace(groups);
                    this._appointments.option({
                        fixedContainer: this._workSpace.getFixedContainer(),
                        allDayContainer: this._workSpace.getAllDayContainer()
                    })
                },
                getWorkSpaceScrollable: function() {
                    return this._workSpace.getScrollable()
                },
                getWorkSpaceScrollableScrollTop: function() {
                    return this._workSpace.getScrollableScrollTop()
                },
                getWorkSpaceScrollableScrollLeft: function() {
                    return this._workSpace.getScrollableScrollLeft()
                },
                getWorkSpaceScrollableContainer: function() {
                    return this._workSpace.getScrollableContainer()
                },
                getWorkSpaceAllDayHeight: function() {
                    return this._workSpace.getAllDayHeight()
                },
                getWorkSpaceHeaderPanelHeight: function() {
                    return this._workSpace.getHeaderPanelHeight()
                },
                getWorkSpaceDateTableOffset: function() {
                    return !this.option("horizontalScrollingEnabled") || this.option("rtlEnabled") ? this._workSpace.getTimePanelWidth() : 0
                },
                getWorkSpace: function() {
                    return this._workSpace
                },
                getHeader: function() {
                    return this._header
                },
                _createPopup: function(appointmentData) {
                    if (this._$popup)
                        this._popup.element().remove();
                    this._$popup = $("<div>").addClass(APPOINTMENT_POPUP_CLASS).appendTo(this.element());
                    this._initDynamicPopupTemplate(appointmentData);
                    this._popup = this._createComponent(this._$popup, "dxPopup", this._popupConfig(appointmentData))
                },
                _popupContent: function(appointmentData) {
                    var $popupContent = this._popup.content();
                    this._createAppointmentForm(appointmentData, $popupContent);
                    return $popupContent
                },
                _createAppointmentForm: function(appointmentData, $content) {
                    var editors = this._defaultAppointmentFormEditors(appointmentData.allDay),
                        resources = this.option("resources");
                    if (resources && resources.length) {
                        this._resourcesManager.setResources(this.option("resources"));
                        editors = editors.concat(this._resourcesManager.getEditors())
                    }
                    this._appointmentForm = this._createComponent($content, "dxForm", {
                        items: editors,
                        readOnly: this._isReadOnly(),
                        showValidationSummary: true,
                        scrollingEnabled: true
                    });
                    $.each(this._resourcesManager.getResourcesFromItem(appointmentData, true) || {}, function(resourceName, resourceValue) {
                        appointmentData[resourceName] = resourceValue
                    });
                    this._appointmentForm.option("formData", $.extend(true, {}, appointmentData));
                    var recurrentEditor = this._appointmentForm.getEditor("recurrenceRule");
                    if (recurrentEditor)
                        recurrentEditor.option("startDate", dateUtils.makeDate(appointmentData.startDate));
                    this._actions["onAppointmentFormCreated"]({
                        form: this._appointmentForm,
                        appointmentData: appointmentData
                    })
                },
                _initDynamicPopupTemplate: function(appointmentData) {
                    var that = this;
                    this._dynamicTemplates["appointmentPopup"] = new FunctionTemplate(function(data, index, $container) {
                        var $popupContent = that._popupContent(appointmentData);
                        $container.append($popupContent);
                        return $container
                    })
                },
                _popupConfig: function(appointmentData) {
                    var template = this._getTemplateByOption("appointmentPopupTemplate");
                    return {
                            _templates: this.option("_templates"),
                            templateProvider: this.option("templateProvider"),
                            width: APPOINTEMENT_POPUP_WIDTH,
                            onHiding: $.proxy(function() {
                                this.focus()
                            }, this),
                            contentTemplate: new DynamicTemplate(function(container) {
                                return new MoveTemplate(template.render(appointmentData, container))
                            }),
                            defaultOptionsRules: [{
                                    device: function(device) {
                                        return !devices.current().generic
                                    },
                                    options: {fullScreen: true}
                                }]
                        }
                },
                _getPopupButtons: function() {
                    return [{
                                shortcut: "done",
                                location: "after",
                                onClick: $.proxy(this._doneButtonClickHandler, this)
                            }, {
                                shortcut: "cancel",
                                location: "after"
                            }]
                },
                _doneButtonClickHandler: function(args) {
                    var validation = this._appointmentForm.validate();
                    if (validation && !validation.isValid) {
                        args.cancel = true;
                        return
                    }
                    this._saveChanges(args);
                    this._workSpace.updateScrollPosition(this._appointmentForm.option("formData").startDate)
                },
                _saveChanges: function() {
                    var appointmentData = this._appointmentForm.option("formData"),
                        oldData = this._editAppointmentData,
                        recData = this._updatedRecAppointment;
                    if (appointmentData.hasOwnProperty("recurrenceRule") && appointmentData.recurrenceRule === undefined)
                        appointmentData.recurrenceRule = "";
                    if (oldData && !recData)
                        this.updateAppointment(oldData, appointmentData);
                    else {
                        recData && this.updateAppointment(oldData, recData);
                        delete this._updatedRecAppointment;
                        this.addAppointment(appointmentData)
                    }
                },
                _checkRecurringAppointment: function(targetAppointment, singleAppointment, exceptionDate, callback, isDeleted, isPopupEditing) {
                    delete this._updatedRecAppointment;
                    var recurrenceRule = targetAppointment.recurrenceRule;
                    if (!recurrenceUtils.getRecurrenceRule(recurrenceRule).isValid || !this._editing.allowUpdating) {
                        callback();
                        return
                    }
                    var editMode = this.option("recurrenceEditMode");
                    switch (editMode) {
                        case"series":
                            callback();
                            break;
                        case"occurrence":
                            this._singleAppointmentChangesHandler(targetAppointment, singleAppointment, exceptionDate, isDeleted, isPopupEditing);
                            break;
                        default:
                            this._showRecurrenceChangeConfirm(isDeleted).done($.proxy(function(result) {
                                result && callback();
                                !result && this._singleAppointmentChangesHandler(targetAppointment, singleAppointment, exceptionDate, isDeleted, isPopupEditing)
                            }, this)).fail($.proxy(function() {
                                this._appointments.moveAppointmentBack()
                            }, this))
                    }
                },
                _singleAppointmentChangesHandler: function(targetAppointment, singleAppointment, exceptionDate, isDeleted, isPopupEditing) {
                    delete singleAppointment.recurrenceRule;
                    delete singleAppointment.recurrenceException;
                    if (!isDeleted && !isPopupEditing)
                        this.addAppointment(singleAppointment);
                    var recurrenceException = this._getRecurrenceException(exceptionDate, targetAppointment),
                        updatedAppointment = $.extend({}, targetAppointment, {recurrenceException: recurrenceException});
                    if (isPopupEditing) {
                        this._updatedRecAppointment = updatedAppointment;
                        this.showAppointmentPopup(singleAppointment, true);
                        this._editAppointmentData = targetAppointment
                    }
                    else
                        this._updateAppointment(targetAppointment, updatedAppointment)
                },
                _getRecurrenceException: function(exceptionDate, targetAppointment) {
                    var exceptionByDate = this._getRecurrenceExceptionDate(exceptionDate, targetAppointment.startDate);
                    return targetAppointment.recurrenceException ? targetAppointment.recurrenceException + "," + exceptionByDate : exceptionByDate
                },
                _getRecurrenceExceptionDate: function(exceptionDate, targetStartDate) {
                    exceptionDate.setHours(targetStartDate.getHours());
                    exceptionDate.setMinutes(targetStartDate.getMinutes());
                    exceptionDate.setSeconds(targetStartDate.getSeconds());
                    return Globalize.format(exceptionDate, "yyyyMMddThhmmss")
                },
                _showRecurrenceChangeConfirm: function(isDeleted) {
                    var message = Globalize.localize(isDeleted ? "dxScheduler-confirmRecurrenceDeleteMessage" : "dxScheduler-confirmRecurrenceEditMessage"),
                        seriesText = Globalize.localize(isDeleted ? "dxScheduler-confirmRecurrenceDeleteSeries" : "dxScheduler-confirmRecurrenceEditSeries"),
                        occurrenceText = Globalize.localize(isDeleted ? "dxScheduler-confirmRecurrenceDeleteOccurrence" : "dxScheduler-confirmRecurrenceEditOccurrence");
                    return dialog.custom({
                            message: message,
                            showCloseButton: true,
                            showTitle: true,
                            buttons: [{
                                    text: seriesText,
                                    onClick: function() {
                                        return true
                                    }
                                }, {
                                    text: occurrenceText,
                                    onClick: function() {
                                        return false
                                    }
                                }]
                        }).show()
                },
                _getUpdatedData: function(options) {
                    var target = options.data,
                        data = this.getTargetCellData(),
                        targetStartDate = dateUtils.makeDate(target.startDate),
                        targetEndDate = dateUtils.makeDate(target.endDate),
                        date = data.date || targetStartDate,
                        groups = data.groups,
                        duration = targetEndDate.getTime() - targetStartDate.getTime();
                    var updatedData = {};
                    updatedData.allDay = data.allDay;
                    updatedData.startDate = date;
                    updatedData.endDate = new Date(date.getTime() + duration);
                    for (var name in groups)
                        if (groups.hasOwnProperty(name))
                            updatedData[name] = groups[name];
                    return updatedData
                },
                _getCoordinates: function(dates, resources, allDay) {
                    var result = [];
                    for (var i = 0; i < dates.length; i++)
                        result = result.concat(this._workSpace.getCoordinatesByDateInGroup(dates[i], resources, allDay));
                    return result
                },
                _getSingleAppointmentData: function(appointmentData, $appointment, options) {
                    var target = appointmentData,
                        updatedData = this._getUpdatedData(options),
                        appointment = $.extend({}, target, updatedData),
                        coordinates = translator.locate($appointment),
                        allowAllDay = this._workSpace.supportAllDayRow() && target.allDay,
                        cellData = this._workSpace.getCellDataByCoordinates(coordinates, allowAllDay),
                        appointmentDuration = appointment.endDate.getTime() - appointment.startDate.getTime();
                    appointment.startDate = cellData.startDate;
                    appointment.endDate = new Date(appointment.startDate.getTime() + appointmentDuration);
                    return appointment
                },
                subsribe: function(subject, action) {
                    this._subscribes[subject] = subscribes[subject] = action
                },
                fire: function(subject, args) {
                    var callback = this._subscribes[subject];
                    if (!$.isFunction(callback))
                        throw errors.Error("E1031", subject);
                    callback.call(this, args)
                },
                getTargetCellData: function() {
                    return this._workSpace.getDataByDroppableCell()
                },
                showAppointmentTooltip: function(appointmentData, singleAppointmentData, $appointment) {
                    appointmentTooltip.show(appointmentData, singleAppointmentData, $appointment, this)
                },
                _hideTooltip: function() {
                    appointmentTooltip.hide()
                },
                _updateAppointment: function(target, appointment, onUpdatePrevented) {
                    var updatingOptions = {
                            newData: appointment,
                            oldData: target,
                            cancel: false
                        };
                    this._actions["onAppointmentUpdating"](updatingOptions);
                    this._processActionResult(updatingOptions, function(canceled) {
                        if (!canceled) {
                            this._expandAllDayPanel(appointment);
                            this._appointmentModel.update(target, appointment).always($.proxy(function(e) {
                                this._executeActionWhenOperationIsCompleted(this._actions["onAppointmentUpdated"], appointment, e)
                            }, this))
                        }
                        else if ($.isFunction(onUpdatePrevented))
                            onUpdatePrevented.call(this)
                    })
                },
                _processActionResult: function(actionOptions, callback) {
                    $.when(actionOptions.cancel).then($.proxy(callback, this))
                },
                _expandAllDayPanel: function(appointment) {
                    if (!this._isAllDayExpanded() && this.appointmentTakesAllDay(appointment))
                        this._workSpace.option("allDayExpanded", true)
                },
                _executeActionWhenOperationIsCompleted: function(action, appointment, e) {
                    var options = {appointmentData: appointment},
                        isError = e && e.name === "Error";
                    if (isError)
                        options.error = e;
                    action(options)
                },
                _showAppointmentPopup: function(appointmentData, showButtons) {
                    this._createPopup(appointmentData);
                    var buttons = [],
                        showCloseButton = true;
                    if (!commonUtils.isDefined(showButtons) || showButtons) {
                        buttons = this._getPopupButtons();
                        showCloseButton = this._popup.initialOption("showCloseButton")
                    }
                    this._popup.option({
                        buttons: buttons,
                        showCloseButton: showCloseButton
                    });
                    this._popup.show()
                },
                getAppointmentPopup: function() {
                    return this._popup
                },
                getAppointmentDetailsForm: function() {
                    return this._appointmentForm
                },
                getAppointmentsInstance: function() {
                    return this._appointments
                },
                getAppointmentResourceData: function(field, value) {
                    return this._resourcesManager.getResourceDataByValue(field, value)
                },
                getActions: function() {
                    return this._actions
                },
                appointmentTakesAllDay: function(appointment) {
                    return appointment.allDay || this._appointmentModel.appointmentTakesAllDay(appointment.startDate, appointment.endDate, this.option("startDayHour"), this.option("endDayHour"))
                },
                recurrenceEditorVisibylityChanged: function(visible) {
                    if (this._appointmentForm)
                        this._appointmentForm.element().find("." + RECURRENCE_EDITOR_ITEM_CLASS).toggleClass(RECURRENCE_EDITOR_OPENED_ITEM_CLASS, visible)
                },
                showAppointmentPopup: function(appointmentData, createNewAppointment) {
                    var editing = this._editing;
                    if (createNewAppointment) {
                        delete this._editAppointmentData;
                        editing.allowAdding && this._showAppointmentPopup(appointmentData)
                    }
                    else {
                        this._editAppointmentData = appointmentData;
                        this._showAppointmentPopup(appointmentData, editing.allowUpdating)
                    }
                },
                scrollToTime: function(hours, minutes) {
                    this._workSpace.scrollToTime(hours, minutes)
                },
                addAppointment: function(appointment) {
                    if (!appointment.text)
                        appointment.text = "";
                    var addingOptions = {
                            appointmentData: appointment,
                            cancel: false
                        };
                    this._actions["onAppointmentAdding"](addingOptions);
                    this._processActionResult(addingOptions, function(canceled) {
                        if (!canceled) {
                            this._expandAllDayPanel(appointment);
                            this._appointmentModel.add(appointment).always($.proxy(function(e) {
                                this._executeActionWhenOperationIsCompleted(this._actions["onAppointmentAdded"], appointment, e)
                            }, this))
                        }
                    })
                },
                updateAppointment: function(target, appointment) {
                    this._updateAppointment(target, appointment)
                },
                deleteAppointment: function(appointment) {
                    var deletingOptions = {
                            appointmentData: appointment,
                            cancel: false
                        };
                    this._actions["onAppointmentDeleting"](deletingOptions);
                    this._processActionResult(deletingOptions, function(canceled) {
                        if (!canceled)
                            this._appointmentModel.remove(appointment).always($.proxy(function(e) {
                                this._executeActionWhenOperationIsCompleted(this._actions["onAppointmentDeleted"], appointment, e)
                            }, this))
                    })
                },
                focus: function() {
                    if (this._editAppointmentData)
                        this._appointments.focus();
                    else
                        this._workSpace.focus()
                }
            }).include(DataHelperMixin);
        registerComponent("dxScheduler", ui, Scheduler);
        return Scheduler
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler"]);
    /*! Module widgets-web, file clientExporter.js */
    (function(DX, $) {
        var Component = DX.require("/component"),
            commonUtils = DX.require("/utils/utils.common");
        DX.dxClientExporter = Component.inherit({
            _getDocumentCreator: function(exportableComponent, options) {
                if (options.format === "EXCEL")
                    return new DX.dxClientExporter.ExcelCreator(exportableComponent.getDataProvider(), $.extend({rtlEnabled: exportableComponent.option("rtlEnabled")}, options))
            },
            exportTo: function(options) {
                var that = this,
                    eventArgs,
                    exportingAction = this.option("exportingAction"),
                    exportedAction = this.option("exportedAction"),
                    data,
                    documentCreator,
                    exportableComponent = options.component;
                if (exportableComponent) {
                    eventArgs = {
                        fileName: options.fileName,
                        format: options.format,
                        cancel: false
                    };
                    commonUtils.isDefined(exportingAction) && exportingAction(eventArgs);
                    if (!eventArgs.cancel) {
                        documentCreator = that._getDocumentCreator(exportableComponent, options);
                        documentCreator.ready().done(function() {
                            data = documentCreator.getData(commonUtils.isFunction(window.Blob));
                            commonUtils.isDefined(exportedAction) && exportedAction();
                            DX.dxClientExporter.fileSaver.saveAs(eventArgs.fileName, options.format, data, options.proxyUrl)
                        })
                    }
                }
            }
        })
    })(DevExpress, jQuery);
    /*! Module widgets-web, file excelCreator.js */
    (function($, DX) {
        var stringUtils = DX.require("/utils/utils.string"),
            commonUtils = DX.require("/utils/utils.common"),
            defaultDateTimeFormat = DX.require("/utils/utils.formatHelper").defaultDateTimeFormat,
            Class = DX.require("/class"),
            exporter = DX.dxClientExporter,
            XML_TAG = "<?xml version=\"1.0\" encoding=\"utf-8\"?>",
            GROUP_SHEET_PR_XML = "<sheetPr><outlinePr summaryBelow=\"0\"/></sheetPr>",
            SINGLE_SHEET_PR_XML = "<sheetPr/>",
            BASE_STYLE_XML = "<fonts count=\"2\"><font><sz val=\"11\"/><color theme=\"1\"/><name val=\"Calibri\"/><family val=\"2\"/><scheme val=\"minor\"/></font><font><b/><sz val=\"11\"/><color theme=\"1\"/><name val=\"Calibri\"/><family val=\"2\"/><scheme val=\"minor\"/></font></fonts><fills count=\"1\"><fill><patternFill patternType=\"none\"/></fill></fills><borders count=\"1\"><border><left style=\"thin\"><color rgb=\"FFD3D3D3\"/></left><right style=\"thin\"><color rgb=\"FFD3D3D3\"/></right><top style=\"thin\"><color rgb=\"FFD3D3D3\"/></top><bottom style=\"thin\"><color rgb=\"FFD3D3D3\"/></bottom></border></borders><cellStyleXfs count=\"1\"><xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\"/></cellStyleXfs>",
            OPEN_XML_FORMAT_URL = "http://schemas.openxmlformats.org",
            RELATIONSHIP_PART_NAME = "rels",
            XL_FOLDER_NAME = "xl",
            WORKBOOK_FILE_NAME = "workbook.xml",
            CONTENTTYPES_FILE_NAME = "[Content_Types].xml",
            SHAREDSTRING_FILE_NAME = "sharedStrings.xml",
            STYLE_FILE_NAME = "styles.xml",
            WORKSHEETS_FOLDER = "worksheets",
            WORKSHEET_FILE_NAME = "sheet1.xml",
            UNSUPPORTED_DEFINED_DATE_FORMATS = ["quarter", "quarterAndYear", "millisecond"],
            DEFAULT_DATE_FORMAT = "shortDate",
            DEFINED_NUMBER_FORMTATS = {
                thousands: "#,##0{0},&quot;K&quot;",
                millions: "#,##0{0},,&quot;M&quot;",
                billions: "#,##0{0},,,&quot;B&quot;",
                trillions: "#,##0{0},,,,&quot;T&quot;",
                percent: "0{0}%",
                decimal: "#{0}",
                fixedPoint: "#,##0{0}",
                exponential: "0{0}E+00",
                currency: " "
            },
            EXCEL_START_TIME = Date.UTC(1899, 11, 30),
            DAYS_COUNT_BEFORE_29_FEB_1900 = 60,
            BOLD_STYLES_COUNT = 4,
            MAX_DIGIT_WIDTH_IN_PIXELS = 7,
            CUSTOM_FORMAT_START_INDEX = 165;
        exporter.excelFormatConverter = {
            _applyPrecision: function(format, precision) {
                var result,
                    i;
                if (precision > 0) {
                    result = format !== "decimal" ? "." : "";
                    for (i = 0; i < precision; i++)
                        result += "0";
                    return result
                }
                return ""
            },
            _getCurrencyFormat: function() {
                var currency = Globalize.cultures[Globalize.cultureSelector].numberFormat.currency,
                    i,
                    result,
                    symbol,
                    encodeSymbols;
                if (commonUtils.isArray(currency.pattern)) {
                    encodeSymbols = {
                        n: "#,##0{0}",
                        "'": "\\'",
                        "\\(": "\\(",
                        "\\)": "\\)",
                        " ": "\\ ",
                        "\"": "&quot;",
                        "\\$": currency.symbol
                    };
                    result = currency.pattern.slice();
                    for (symbol in encodeSymbols)
                        for (i = 0; i < result.length; i++)
                            result[i] = result[i].replace(new RegExp(symbol, "g"), encodeSymbols[symbol]);
                    return result.length === 2 ? result[1] + "_);" + result[0] : result[0]
                }
            },
            _convertDateFormat: function(format) {
                if (!defaultDateTimeFormat[format.toLowerCase()] || $.inArray(format, UNSUPPORTED_DEFINED_DATE_FORMATS) !== -1)
                    format = DEFAULT_DATE_FORMAT;
                var datePatterns = Globalize.cultures[Globalize.cultureSelector].calendar.patterns,
                    pattern = defaultDateTimeFormat[format.toLowerCase()];
                if (commonUtils.isDefined(datePatterns[pattern]))
                    pattern = datePatterns[pattern];
                return pattern.replace(/\//g, "\\/").replace(/ /g, "\\ ").replace(/,/g, "\\,").replace(/:/g, "\\:").replace(/tt/g, "AM/PM").replace(/N/g, "#\\,###")
            },
            _convertNumberFormat: function(format, precision) {
                var result,
                    excelFormat = format === "currency" ? this._getCurrencyFormat() : DEFINED_NUMBER_FORMTATS[format];
                if (excelFormat)
                    result = stringUtils.format(excelFormat, this._applyPrecision(format, precision));
                return result
            },
            convertFormat: function(format, precision, type) {
                if (commonUtils.isDefined(format))
                    if (type === "date")
                        return exporter.excelFormatConverter._convertDateFormat(format);
                    else if (DEFINED_NUMBER_FORMTATS[format])
                        return exporter.excelFormatConverter._convertNumberFormat(format, precision)
            }
        };
        exporter.ExcelCreator = Class.inherit({
            _getXMLTag: function(tagName, attributes, content) {
                var result = ["<"],
                    key;
                result.push(tagName);
                for (key in attributes) {
                    result.push(" ");
                    result.push(key);
                    result.push("=\"");
                    result.push(attributes[key]);
                    result.push("\"")
                }
                if (commonUtils.isDefined(content)) {
                    result.push(">");
                    result.push(content);
                    result.push("</");
                    result.push(tagName);
                    result.push(">")
                }
                else
                    result.push(" />");
                return result.join("")
            },
            _getDataProviderRowIndex: function(dpRowIndex) {
                return dpRowIndex - !!this._dataProvider.isHeadersVisible()
            },
            _getExcelRowIndex: function(exRowIndex) {
                return exRowIndex + !!this._dataProvider.isHeadersVisible()
            },
            _getCellIndex: function(rowIndex, cellIndex) {
                var sheetIndex = '',
                    max = 26,
                    charCode;
                if (this._maxIndex[0] < Number(rowIndex))
                    this._maxIndex[0] = Number(rowIndex);
                if (this._maxIndex[1] < Number(cellIndex))
                    this._maxIndex[1] = Number(cellIndex);
                do {
                    charCode = 65 + (cellIndex >= max ? cellIndex % max : Math.ceil(cellIndex));
                    sheetIndex = String.fromCharCode(charCode) + sheetIndex;
                    if (cellIndex >= max)
                        cellIndex = Math.floor(cellIndex / max) - 1;
                    else
                        break
                } while (true);
                sheetIndex += rowIndex;
                return sheetIndex
            },
            _getDataType: function(dataType) {
                var validTypes = {
                        boolean: "b",
                        date: "d",
                        number: "n",
                        string: "s"
                    };
                return commonUtils.isDefined(validTypes[dataType]) ? validTypes[dataType] : "s"
            },
            _appendFormat: function(format, precision, dataType) {
                format = exporter.excelFormatConverter.convertFormat(format, precision, dataType);
                if (format) {
                    if ($.inArray(format, this._styleFormat) === -1)
                        this._styleFormat.push(format);
                    return $.inArray(format, this._styleFormat) + 1
                }
            },
            _appendString: function(value) {
                if (commonUtils.isDefined(value)) {
                    value = String(value);
                    if (value.length) {
                        value = stringUtils.encodeHtml(value);
                        if ($.inArray(value, this._stringArray) === -1)
                            this._stringArray.push(value);
                        return $.inArray(value, this._stringArray)
                    }
                }
            },
            _getExcelDateValue: function(date) {
                var days,
                    totalTime;
                if (commonUtils.isDate(date)) {
                    days = Math.floor((Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - EXCEL_START_TIME) / (1000 * 60 * 60 * 24));
                    if (days < DAYS_COUNT_BEFORE_29_FEB_1900)
                        days--;
                    totalTime = (date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds()) / (24 * 3600);
                    return days + totalTime
                }
            },
            _prepareValue: function(rowIndex, cellIndex) {
                var value = this._dataProvider.getCellValue(rowIndex, cellIndex),
                    text = this._dataProvider.getCellText && this._dataProvider.getCellText(rowIndex, cellIndex),
                    type = this._getDataType(this._dataProvider.getCellType(rowIndex, cellIndex)) || "string",
                    formatID = this._styleArray[cellIndex + BOLD_STYLES_COUNT].formatID,
                    format = commonUtils.isNumber(formatID) ? this._styleFormat[formatID - 1] : null;
                if (!commonUtils.isDefined(value) && commonUtils.isDefined(text)) {
                    value = text;
                    type = "s";
                    format = null
                }
                if (type === "d" && !commonUtils.isDate(value))
                    type = "s";
                switch (type) {
                    case"s":
                        value = this._appendString(value);
                        break;
                    case"d":
                        value = this._getExcelDateValue(value, format);
                        type = "n";
                        break
                }
                return {
                        value: value,
                        type: type
                    }
            },
            _getHeadersArray: function() {
                var i,
                    columns = this._dataProvider.getColumns(),
                    result = [];
                for (i = 0; i !== columns.length; i++)
                    result.push({
                        style: 0,
                        type: "s",
                        value: this._appendString(columns[i].caption)
                    });
                return result
            },
            _getDataArray: function() {
                var rowIndex,
                    cellIndex,
                    cellsArray,
                    cellData,
                    result = [],
                    type,
                    styleID,
                    columns = this._dataProvider.getColumns();
                for (rowIndex = 0; rowIndex < this._dataProvider.getRowsCount(); rowIndex++) {
                    cellsArray = [];
                    for (cellIndex = 0; cellIndex !== columns.length; cellIndex++) {
                        cellData = this._prepareValue(rowIndex, cellIndex);
                        type = cellData.type;
                        if (!this._dataProvider.isGroupRow(rowIndex) && commonUtils.isDefined(this._styleArray[cellIndex + BOLD_STYLES_COUNT].formatID) && cellData.type !== "s")
                            type = "n";
                        styleID = cellIndex + BOLD_STYLES_COUNT;
                        if (this._dataProvider.isGroupRow(rowIndex))
                            styleID = BOLD_STYLES_COUNT - 1;
                        if (this._dataProvider.isTotalCell(rowIndex, cellIndex))
                            styleID = this._getBoldStyleID(columns[cellIndex].alignment);
                        cellsArray.push({
                            style: styleID,
                            value: cellData.value,
                            type: type
                        })
                    }
                    if (rowIndex && !this._needSheetPr && this._dataProvider.getGroupLevel(this._getDataProviderRowIndex(rowIndex)) > 0)
                        this._needSheetPr = true;
                    result.push(cellsArray)
                }
                return result
            },
            _getBoldStyleID: function(alignment) {
                for (var i = 0; i < BOLD_STYLES_COUNT - 1; i++)
                    if (this._styleArray[i].alignment === alignment)
                        return i
            },
            _culculateWidth: function(pixelsWidth) {
                pixelsWidth = parseInt(pixelsWidth, 10);
                if (!pixelsWidth || pixelsWidth < 5)
                    pixelsWidth = 100;
                return Math.min(255, Math.floor((pixelsWidth - 5) / MAX_DIGIT_WIDTH_IN_PIXELS * 100 + 0.5) / 100)
            },
            _prepareStyleData: function() {
                var i,
                    column,
                    wrapText = Number(!!this._options.wrapTextEnabled),
                    alignments = ["center", "left", "right"],
                    columns = this._dataProvider.getColumns();
                for (i = 0; i < alignments.length; i++)
                    this._styleArray.push({
                        bold: true,
                        alignment: alignments[i],
                        wrapText: 1
                    });
                this._styleArray.push({
                    bold: true,
                    alignment: commonUtils.getDefaultAlignment(this._rtlEnabled),
                    wrapText: 0
                });
                for (i = 0; i < columns.length; i++) {
                    column = columns[i];
                    this._styleArray.push({
                        alignment: commonUtils.isDefined(column.alignment) ? column.alignment : "left",
                        formatID: this._appendFormat(column.format, column.precision, column.dataType),
                        wrapText: wrapText
                    });
                    this._colsArray.push(this._culculateWidth(column.width))
                }
            },
            _prepareCellData: function() {
                if (this._dataProvider.isHeadersVisible())
                    this._cellsArray.push(this._getHeadersArray());
                this._cellsArray = this._cellsArray.concat(this._getDataArray())
            },
            _createXMLRelationships: function(xmlRelationships) {
                return this._getXMLTag("Relationships", {xmlns: OPEN_XML_FORMAT_URL + "/package/2006/relationships"}, xmlRelationships)
            },
            _createXMLRelationship: function(id, type, target) {
                return this._getXMLTag("Relationship", {
                        Id: "rId" + id,
                        Type: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships/" + type,
                        Target: target
                    })
            },
            _getWorkbookContent: function() {
                var content = "<bookViews><workbookView xWindow=\"0\" yWindow=\"0\" windowWidth=\"0\" windowHeight=\"0\"/></bookViews><sheets><sheet name=\"Sheet\" sheetId=\"1\" r:id=\"rId1\" /></sheets><definedNames><definedName name=\"_xlnm.Print_Titles\" localSheetId=\"0\">Sheet!$1:$1</definedName><definedName name=\"_xlnm._FilterDatabase\" hidden=\"0\" localSheetId=\"0\">Sheet!$A$1:$F$6332</definedName></definedNames>";
                return XML_TAG + this._getXMLTag("workbook", {
                        "xmlns:r": OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships",
                        xmlns: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
                    }, content)
            },
            _getContentTypesContent: function() {
                return XML_TAG + "<Types xmlns=\"" + OPEN_XML_FORMAT_URL + "/package/2006/content-types\"><Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\" /><Default Extension=\"xml\" ContentType=\"application/xml\" /><Override PartName=\"/xl/worksheets/sheet1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\" /><Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\" /><Override PartName=\"/xl/sharedStrings.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\" /><Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\" /></Types>"
            },
            _generateStylesXML: function() {
                var xlFolder = this._zip.folder(XL_FOLDER_NAME),
                    styleIndex,
                    style,
                    xmlStyles = [],
                    formatIndex,
                    XML = "";
                for (formatIndex in this._styleFormat)
                    this._styleFormat[formatIndex] = this._getXMLTag("numFmt", {
                        numFmtId: Number(formatIndex) + CUSTOM_FORMAT_START_INDEX,
                        formatCode: this._styleFormat[formatIndex]
                    });
                XML += this._getXMLTag("numFmts", {count: this._styleFormat.length}, this._styleFormat.join(""));
                XML += BASE_STYLE_XML;
                for (styleIndex in this._styleArray) {
                    style = this._styleArray[styleIndex];
                    xmlStyles.push(this._getXMLTag("xf", {
                        xfId: 0,
                        applyAlignment: 1,
                        fontId: Number(!!style.bold),
                        applyNumberFormat: commonUtils.isDefined(style.formatID) ? 1 : 0,
                        numFmtId: commonUtils.isDefined(style.formatID) ? Number(style.formatID) + CUSTOM_FORMAT_START_INDEX - 1 : 0
                    }, this._getXMLTag("alignment", {
                        horizontal: style.alignment,
                        vertical: "top",
                        wrapText: style.wrapText
                    })))
                }
                XML += this._getXMLTag("cellXfs", {count: xmlStyles.length}, xmlStyles.join(""));
                XML += this._getXMLTag("cellStyles", {count: 1}, this._getXMLTag("cellStyle", {
                    name: "Normal",
                    xfId: 0,
                    builtinId: 0
                }));
                XML = XML_TAG + this._getXMLTag("styleSheet", {xmlns: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"}, XML);
                xlFolder.file(STYLE_FILE_NAME, XML);
                this._styleArray = []
            },
            _generateStringsXML: function() {
                var xlFolder = this._zip.folder(XL_FOLDER_NAME),
                    stringIndex,
                    sharedStringXml = XML_TAG;
                for (stringIndex in this._stringArray)
                    this._stringArray[stringIndex] = this._getXMLTag("si", {}, this._getXMLTag("t", {}, this._stringArray[stringIndex]));
                sharedStringXml += this._getXMLTag("sst", {
                    xmlns: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main",
                    count: this._stringArray.length,
                    uniqueCount: this._stringArray.length
                }, this._stringArray.join(""));
                xlFolder.file(SHAREDSTRING_FILE_NAME, sharedStringXml);
                this._stringArray = []
            },
            _getPaneXML: function() {
                var attributes = {
                        activePane: "bottomLeft",
                        state: "frozen"
                    },
                    frozenArea = commonUtils.isDefined(this._dataProvider.getFrozenArea) ? this._dataProvider.getFrozenArea() : {
                        x: 0,
                        y: Number(this._dataProvider.isHeadersVisible())
                    };
                if (!(frozenArea.x || frozenArea.y))
                    return "";
                if (frozenArea.x)
                    attributes['xSplit'] = frozenArea.x;
                if (frozenArea.y)
                    attributes['ySplit'] = frozenArea.y;
                attributes['topLeftCell'] = this._getCellIndex(frozenArea.y + 1, frozenArea.x);
                return this._getXMLTag("pane", attributes)
            },
            _generateWorksheetXML: function() {
                var colIndex,
                    rowIndex,
                    cellData,
                    xmlCells,
                    maxCellIndex,
                    counter = 0,
                    xmlRows = [],
                    rSpans = "1:" + this._colsArray.length,
                    xmlResult = [["<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">", this._needSheetPr ? GROUP_SHEET_PR_XML : SINGLE_SHEET_PR_XML, "<dimension ref=\"A1:", this._getCellIndex(this._maxIndex[0], this._maxIndex[1]) + "\"/><sheetViews><sheetView " + (this._rtlEnabled ? "rightToLeft=\"1\" " : "") + "tabSelected=\"1\" workbookViewId=\"0\">" + this._getPaneXML() + "</sheetView></sheetViews><sheetFormatPr defaultRowHeight=\"15\" outlineLevelRow=\"", this._dataProvider.getRowsCount() > 0 ? this._dataProvider.getGroupLevel(0) : 0, "\" x14ac:dyDescent=\"0.25\"/>"].join("")];
                for (colIndex in this._colsArray)
                    this._colsArray[colIndex] = this._getXMLTag("col", {
                        width: this._colsArray[colIndex],
                        min: Number(colIndex) + 1,
                        max: Number(colIndex) + 1
                    });
                xmlResult.push(this._getXMLTag("cols", [], this._colsArray.join("")) + "<sheetData>");
                for (rowIndex in this._cellsArray) {
                    xmlCells = [];
                    for (colIndex in this._cellsArray[rowIndex]) {
                        rowIndex = Number(rowIndex);
                        cellData = this._cellsArray[rowIndex][colIndex];
                        xmlCells.push(this._getXMLTag("c", {
                            r: this._getCellIndex(rowIndex + 1, colIndex),
                            s: cellData.style,
                            t: cellData.type
                        }, commonUtils.isDefined(cellData.value) ? this._getXMLTag("v", {}, cellData.value) : null))
                    }
                    xmlRows.push(this._getXMLTag("row", {
                        r: Number(rowIndex) + 1,
                        spans: rSpans,
                        outlineLevel: !Number(rowIndex) ? 0 : this._dataProvider.getGroupLevel(this._getDataProviderRowIndex(rowIndex)),
                        "x14ac:dyDescent": "0.25"
                    }, xmlCells.join("")));
                    this._cellsArray[rowIndex] = null;
                    if (counter++ > 10000) {
                        xmlResult.push(xmlRows.join(""));
                        xmlRows = [];
                        counter = 0
                    }
                }
                xmlResult.push(xmlRows.join(""));
                xmlRows = [];
                maxCellIndex = this._getCellIndex(this._maxIndex[0], this._maxIndex[1]);
                xmlResult.push("</sheetData>" + this._generateMerginXML() + (this._options.autoFilterEnabled ? "<autoFilter ref=\"A1:" + maxCellIndex + "\" />" : "") + "<ignoredErrors><ignoredError sqref=\"A1:" + maxCellIndex + "\" numberStoredAsText=\"1\" /></ignoredErrors></worksheet>");
                this._zip.folder(XL_FOLDER_NAME).folder(WORKSHEETS_FOLDER).file(WORKSHEET_FILE_NAME, xmlResult.join(""));
                this._colsArray = [];
                this._cellsArray = [];
                xmlResult = []
            },
            _generateMerginXML: function() {
                var k,
                    l,
                    mergeCount = 0,
                    cellIndex,
                    rowIndex,
                    usedArea = [],
                    mergeArray = [],
                    mergeXML = '';
                if (!commonUtils.isDefined(this._dataProvider.getCellMergin))
                    return "";
                for (rowIndex = 0; rowIndex < this._dataProvider.getRowsCount(); rowIndex++)
                    for (cellIndex = 0; cellIndex !== this._dataProvider.getColumns().length; cellIndex++)
                        if (!commonUtils.isDefined(usedArea[rowIndex]) || !commonUtils.isDefined(usedArea[rowIndex][cellIndex])) {
                            var cellMerge = this._dataProvider.getCellMergin(rowIndex, cellIndex);
                            if (cellMerge.colspan || cellMerge.rowspan) {
                                mergeArray.push({
                                    start: this._getCellIndex(rowIndex + 1, cellIndex),
                                    end: this._getCellIndex(rowIndex + 1 + (cellMerge.rowspan || 0), cellIndex + (cellMerge.colspan || 0))
                                });
                                for (k = rowIndex; k <= rowIndex + cellMerge.rowspan || 0; k++)
                                    for (l = cellIndex; l <= cellIndex + cellMerge.colspan || 0; l++) {
                                        if (!commonUtils.isDefined(usedArea[k]))
                                            usedArea[k] = [];
                                        usedArea[k][l] = true
                                    }
                            }
                        }
                for (var mergeIndex in mergeArray) {
                    mergeCount++;
                    mergeXML += this._getXMLTag("mergeCell", {ref: mergeArray[mergeIndex].start + ":" + mergeArray[mergeIndex].end})
                }
                return mergeXML.length ? this._getXMLTag("mergeCells", {count: mergeCount}, mergeXML) : ""
            },
            _generateCommonXML: function() {
                var relsFileContent = XML_TAG + this._createXMLRelationships(this._createXMLRelationship(1, "officeDocument", "xl/" + WORKBOOK_FILE_NAME)),
                    xmlRelationships,
                    xlFolder = this._zip.folder(XL_FOLDER_NAME),
                    relsXML = XML_TAG;
                this._zip.folder("_" + RELATIONSHIP_PART_NAME).file("." + RELATIONSHIP_PART_NAME, relsFileContent);
                xmlRelationships = this._createXMLRelationship(1, "worksheet", "worksheets/" + WORKSHEET_FILE_NAME) + this._createXMLRelationship(2, "styles", STYLE_FILE_NAME) + this._createXMLRelationship(3, "sharedStrings", SHAREDSTRING_FILE_NAME);
                relsXML += this._createXMLRelationships(xmlRelationships);
                xlFolder.folder("_" + RELATIONSHIP_PART_NAME).file(WORKBOOK_FILE_NAME + ".rels", relsXML);
                xlFolder.file(WORKBOOK_FILE_NAME, this._getWorkbookContent());
                this._zip.file(CONTENTTYPES_FILE_NAME, this._getContentTypesContent())
            },
            _generateContent: function() {
                this._prepareStyleData();
                this._prepareCellData();
                this._generateWorkXML();
                this._generateCommonXML()
            },
            _generateWorkXML: function() {
                this._generateStylesXML();
                this._generateStringsXML();
                this._generateWorksheetXML()
            },
            ctor: function(dataProvider, options) {
                this._rtlEnabled = options && !!options.rtlEnabled;
                this._options = options;
                this._maxIndex = [1, 2];
                this._stringArray = [];
                this._styleArray = [];
                this._colsArray = [];
                this._cellsArray = [];
                this._styleFormat = [];
                this._needSheetPr = false;
                this._dataProvider = dataProvider;
                this._zip = new JSZip
            },
            ready: function() {
                return this._dataProvider.ready()
            },
            getData: function(isBlob) {
                this._generateContent();
                return this._zip.generate({
                        type: isBlob ? "blob" : "base64",
                        compression: "DEFLATE",
                        mimeType: exporter.MIME_TYPES["EXCEL"]
                    })
            }
        });
        exporter.__internals = {
            CONTENTTYPES_FILE_NAME: CONTENTTYPES_FILE_NAME,
            RELATIONSHIP_PART_NAME: RELATIONSHIP_PART_NAME,
            XL_FOLDER_NAME: XL_FOLDER_NAME,
            WORKBOOK_FILE_NAME: WORKBOOK_FILE_NAME,
            STYLE_FILE_NAME: STYLE_FILE_NAME,
            WORKSHEET_FILE_NAME: WORKSHEET_FILE_NAME,
            WORKSHEETS_FOLDER: WORKSHEETS_FOLDER,
            SHAREDSTRING_FILE_NAME: SHAREDSTRING_FILE_NAME,
            GROUP_SHEET_PR_XML: GROUP_SHEET_PR_XML,
            SINGLE_SHEET_PR_XML: SINGLE_SHEET_PR_XML
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file fileSaver.js */
    (function(DX, $) {
        var errors = DevExpress.require("/ui/ui.errors"),
            browser = DX.require("/utils/utils.browser"),
            commonUtils = DX.require("/utils/utils.common"),
            exporter = DX.dxClientExporter,
            FILE_EXTESIONS = {
                EXCEL: "xlsx",
                CSS: "css"
            };
        exporter.MIME_TYPES = {
            CSS: "text/css",
            EXCEL: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        };
        exporter.fileSaver = {
            _getDataUri: function(format, data) {
                return "data:" + exporter.MIME_TYPES[format] + ";base64," + data
            },
            _linkDownloader: function(fileName, href, callback) {
                var exportLinkElement = document.createElement('a'),
                    attributes = {
                        download: fileName,
                        href: href
                    };
                if (commonUtils.isDefined(callback))
                    attributes["onclick"] = callback;
                document.body.appendChild(exportLinkElement);
                $(exportLinkElement).css({display: "none"}).text("load").attr(attributes)[0].click();
                return exportLinkElement
            },
            _formDownloader: function(proxyUrl, fileName, contentType, data, callback) {
                var formAttributes = {
                        method: "post",
                        action: proxyUrl,
                        enctype: "multipart/form-data"
                    },
                    exportForm = $("<form>").css({display: "none"}).attr(formAttributes);
                if (commonUtils.isDefined(callback))
                    exportForm.submit(callback);
                exportForm.append("<input type=\"hidden\" name=\"fileName\" value=\"" + fileName + "\" />");
                exportForm.append("<input type=\"hidden\" name=\"contentType\" value=\"" + contentType + "\" />");
                exportForm.append("<input type=\"hidden\" name=\"data\" value=\"" + data + "\" />");
                exportForm.appendTo("body");
                exportForm.submit();
                if (exportForm.submit())
                    exportForm.remove();
                return exportForm
            },
            _saveByProxy: function(proxyUrl, fileName, format, data, callback) {
                return this._formDownloader(proxyUrl, fileName, exporter.MIME_TYPES[format], data, callback)
            },
            _winJSBlobSave: function(blob, fileName, format) {
                var savePicker = new Windows.Storage.Pickers.FileSavePicker;
                savePicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.documentsLibrary;
                savePicker.fileTypeChoices.insert(exporter.MIME_TYPES[format], ["." + FILE_EXTESIONS[format]]);
                savePicker.suggestedFileName = fileName;
                savePicker.pickSaveFileAsync().then(function(file) {
                    if (file)
                        file.openAsync(Windows.Storage.FileAccessMode.readWrite).then(function(outputStream) {
                            var inputStream = blob.msDetachStream();
                            Windows.Storage.Streams.RandomAccessStream.copyAsync(inputStream, outputStream).then(function() {
                                outputStream.flushAsync().done(function() {
                                    inputStream.close();
                                    outputStream.close()
                                })
                            })
                        })
                })
            },
            _saveBlobAs: function(fileName, format, data, linkClick) {
                this._blobSaved = false;
                if (commonUtils.isDefined(navigator.msSaveOrOpenBlob)) {
                    navigator.msSaveOrOpenBlob(data, fileName);
                    this._blobSaved = true
                }
                else if (commonUtils.isDefined(window.WinJS)) {
                    this._winJSBlobSave(data, fileName, format);
                    this._blobSaved = true
                }
                else {
                    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL;
                    linkClick = commonUtils.isDefined(linkClick) ? linkClick : function() {
                        var link = $('#dxExportLink');
                        URL.revokeObjectURL(link.attr('href'));
                        link.remove();
                        exporter.blobSaved = true
                    };
                    if (commonUtils.isDefined(URL))
                        return this._linkDownloader(fileName, URL.createObjectURL(data), linkClick)
                }
            },
            saveAs: function(fileName, format, data, proxyURL, linkClick) {
                fileName += "." + FILE_EXTESIONS[format];
                if (commonUtils.isFunction(window.Blob))
                    this._saveBlobAs(fileName, format, data);
                else if (commonUtils.isDefined(proxyURL) && !commonUtils.isDefined(navigator.userAgent.match(/iPad/i)))
                    this._saveByProxy(proxyURL, fileName, format, data);
                else {
                    if (!commonUtils.isDefined(navigator.userAgent.match(/iPad/i)))
                        errors.log("E1034");
                    if (browser.msie && parseInt(browser.version) < 10)
                        return;
                    this._linkDownloader(fileName, this._getDataUri(format, data), linkClick)
                }
            }
        }
    })(DevExpress, jQuery);
    DevExpress.MOD_WIDGETS_WEB = true
}
if (!window.DevExpress || !DevExpress.MOD_FRAMEWORK) {
    if (!window.DevExpress || !DevExpress.MOD_CORE)
        throw Error('Required module is not referenced: core');
    /*! Module framework, file framework.js */
    (function($, DX, undefined) {
        var KoTemplateProvider = DX.require("/integration/knockout/ko.templateProvider");
        var mergeWithReplace = function(targetArray, arrayToMerge, needReplaceFn) {
                var result = [];
                for (var i = 0, length = targetArray.length; i < length; i++)
                    if (!needReplaceFn(targetArray[i], arrayToMerge))
                        result.push(targetArray[i]);
                result.push.apply(result, arrayToMerge);
                return result
            };
        var prepareCommandToReplace = function(targetCommand, commandsToMerge) {
                var needToReplace = false;
                $.each(commandsToMerge, function(_, commandToMerge) {
                    var idEqual = targetCommand.option("id") === commandToMerge.option("id") && commandToMerge.option("id"),
                        behaviorEqual = targetCommand.option("behavior") === commandToMerge.option("behavior") && targetCommand.option("behavior");
                    needToReplace = idEqual || behaviorEqual;
                    if (behaviorEqual && commandToMerge.option("onExecute") === null)
                        commandToMerge.option("onExecute", targetCommand.option("onExecute"));
                    if (needToReplace) {
                        targetCommand.element().remove();
                        return false
                    }
                });
                return needToReplace
            };
        var mergeCommands = function(targetCommands, commandsToMerge) {
                return mergeWithReplace(targetCommands, commandsToMerge, prepareCommandToReplace)
            };
        var resolvePropertyValue = function(command, containerOptions, propertyName, defaultValue) {
                var containerOption = containerOptions ? containerOptions[propertyName] : undefined,
                    defaultOption = containerOption === undefined ? defaultValue : containerOption,
                    commandOption = command.option(propertyName);
                return commandOption === undefined || commandOption === defaultValue ? defaultOption : commandOption
            };
        var resolveTextValue = function(command, containerOptions) {
                var showText = resolvePropertyValue(command, containerOptions, "showText"),
                    hasIcon = !!command.option("icon"),
                    titleValue = resolvePropertyValue(command, containerOptions, "title", "");
                return showText || !hasIcon ? titleValue : ""
            };
        var resolveIconValue = function(command, containerOptions) {
                var showIcon = resolvePropertyValue(command, containerOptions, "showIcon"),
                    hasText = !!command.option("title"),
                    iconValue = resolvePropertyValue(command, containerOptions, "icon", "");
                return showIcon || !hasText ? iconValue : ""
            };
        DX.framework = {
            utils: {
                mergeCommands: mergeCommands,
                commandToContainer: {
                    resolveIconValue: resolveIconValue,
                    resolveTextValue: resolveTextValue,
                    resolvePropertyValue: resolvePropertyValue
                }
            },
            templateProvider: KoTemplateProvider
        }
    })(jQuery, DevExpress);
    /*! Module framework, file framework.errors.js */
    DevExpress.define("/framework/framework.errors", ["/utils/utils.error", "/errors"], function(errorUtils, errors) {
        return errorUtils(errors.ERROR_MESSAGES, {
                E3001: "Routing rule is not found for the '{0}' URI.",
                E3002: "The passed object cannot be formatted into a URI string by the application's router. An appropriate route should be registered.",
                E3003: "Unable to navigate. Application is being initialized.",
                E3004: "Cannot execute the command: {0}.",
                E3005: "The '{0}' command {1} is not registered in the application's command mapping. Go to http://dxpr.es/1bTjfj1 for more details.",
                E3006: "Unknown navigation target: '{0}'. Use the 'current', 'back' or 'blank' values.",
                E3007: "Error while restoring the application state. The state has been cleared. Refresh the page.",
                E3008: "Unable to go back.",
                E3009: "Unable to go forward.",
                E3010: "The command's 'id' option should be specified.\r\nProcessed markup: {0}\n",
                E3011: "Layout controller cannot be resolved. There are no appropriate layout controllers for the current context. Check browser console for details.",
                E3012: "Layout controller cannot be resolved. Two or more layout controllers suit the current context. Check browser console for details.",
                E3013: "The '{0}' template with the '{1}' name is not found. Make sure the case is correct in the specified view name and the template fits the current context.",
                E3014: "All the children of the dxView element should be either of the dxCommand or dxContent type.\r\nProcessed markup: {0}",
                E3015: "The 'exec' method should be called before the 'finalize' method.",
                E3016: "Unknown transition type '{0}'.",
                E3018: "Unable to parse options.\nMessage: {0};\nOptions value: {1}.",
                E3019: "View templates should be updated according to the 13.1 changes. Go to http://dxpr.es/15ikrJA for more details.",
                E3020: "Concurrent templates are found:\r\n{0}Target device:\r\n{1}.",
                E3021: "Remote template cannot be loaded.\r\nUrl:{0}\r\nError:{1}.",
                E3022: "Cannot initialize the HtmlApplication component.",
                E3023: "Navigation item is not found",
                E3024: "Layout controller is not initialized",
                W3001: "A view with the '{0}' key doesn't exist.",
                W3002: "A view with the '{0}' key has already been released.",
                W3003: "Layout resolving context:\n{0}\nAvailable layout controller registrations:\n{1}\n",
                W3004: "Layout resolving context:\n{0}\nConcurent layout controller registrations for the context:\n{1}\n",
                W3005: "Direct hash-based navigation is detected in a mobile application. Use data-bind=\"dxAction: url\" instead of href=\"#url\" to avoid navigation issues.\nFound markup:\n{0}\n"
            })
    });
    /*! Module framework, file framework.routing.js */
    (function($, DX) {
        var JSON_URI_PREFIX = encodeURIComponent("json:");
        var Class = DevExpress.require("/class");
        DX.framework.Route = Class.inherit({
            _trimSeparators: function(str) {
                return str.replace(/^[\/.]+|\/+$/g, "")
            },
            _escapeRe: function(str) {
                return str.replace(/\W/g, "\\$1")
            },
            _checkConstraint: function(param, constraint) {
                param = String(param);
                if (typeof constraint === "string")
                    constraint = new RegExp(constraint);
                var match = constraint.exec(param);
                if (!match || match[0] !== param)
                    return false;
                return true
            },
            _ensureReady: function() {
                var that = this;
                if (this._patternRe)
                    return false;
                this._pattern = this._trimSeparators(this._pattern);
                this._patternRe = "";
                this._params = [];
                this._segments = [];
                this._separators = [];
                this._pattern.replace(/[^\/]+/g, function(segment, index) {
                    that._segments.push(segment);
                    if (index)
                        that._separators.push(that._pattern.substr(index - 1, 1))
                });
                $.each(this._segments, function(index) {
                    var isStatic = true,
                        segment = this,
                        separator = index ? that._separators[index - 1] : "";
                    if (segment.charAt(0) === ":") {
                        isStatic = false;
                        segment = segment.substr(1);
                        that._params.push(segment);
                        that._patternRe += "(?:" + separator + "([^/]*))";
                        if (segment in that._defaults)
                            that._patternRe += "?"
                    }
                    else
                        that._patternRe += separator + that._escapeRe(segment)
                });
                this._patternRe = new RegExp("^" + this._patternRe + "$")
            },
            ctor: function(pattern, defaults, constraints) {
                this._pattern = pattern || "";
                this._defaults = defaults || {};
                this._constraints = constraints || {}
            },
            parse: function(uri) {
                var that = this;
                this._ensureReady();
                var matches = this._patternRe.exec(uri);
                if (!matches)
                    return false;
                var result = $.extend({}, this._defaults);
                $.each(this._params, function(i) {
                    var index = i + 1;
                    if (matches.length >= index && matches[index])
                        result[this] = that.parseSegment(matches[index])
                });
                $.each(this._constraints, function(key) {
                    if (!that._checkConstraint(result[key], that._constraints[key])) {
                        result = false;
                        return false
                    }
                });
                return result
            },
            format: function(routeValues) {
                var that = this,
                    query = "";
                this._ensureReady();
                var mergeValues = $.extend({}, this._defaults),
                    useStatic = 0,
                    ret = [],
                    dels = [],
                    unusedRouteValues = {};
                $.each(routeValues, function(paramName, paramValue) {
                    routeValues[paramName] = that.formatSegment(paramValue);
                    if (!(paramName in mergeValues))
                        unusedRouteValues[paramName] = true
                });
                $.each(this._segments, function(index, segment) {
                    ret[index] = index ? that._separators[index - 1] : '';
                    if (segment.charAt(0) === ':') {
                        var paramName = segment.substr(1);
                        if (!(paramName in routeValues) && !(paramName in that._defaults)) {
                            ret = null;
                            return false
                        }
                        if (paramName in that._constraints && !that._checkConstraint(routeValues[paramName], that._constraints[paramName])) {
                            ret = null;
                            return false
                        }
                        if (paramName in routeValues) {
                            if (routeValues[paramName] !== undefined) {
                                mergeValues[paramName] = routeValues[paramName];
                                ret[index] += routeValues[paramName];
                                useStatic = index
                            }
                            delete unusedRouteValues[paramName]
                        }
                        else if (paramName in mergeValues) {
                            ret[index] += mergeValues[paramName];
                            dels.push(index)
                        }
                    }
                    else {
                        ret[index] += segment;
                        useStatic = index
                    }
                });
                $.each(mergeValues, function(key, value) {
                    if (!!value && $.inArray(":" + key, that._segments) === -1 && routeValues[key] !== value) {
                        ret = null;
                        return false
                    }
                });
                var unusedCount = 0;
                if (!$.isEmptyObject(unusedRouteValues)) {
                    query = "?";
                    $.each(unusedRouteValues, function(key) {
                        query += key + "=" + routeValues[key] + "&";
                        unusedCount++
                    });
                    query = query.substr(0, query.length - 1)
                }
                if (ret === null)
                    return false;
                if (dels.length)
                    $.map(dels, function(i) {
                        if (i >= useStatic)
                            ret[i] = ''
                    });
                var path = ret.join('');
                path = path.replace(/\/+$/, "");
                return {
                        uri: path + query,
                        unusedCount: unusedCount
                    }
            },
            formatSegment: function(value) {
                if ($.isArray(value) || $.isPlainObject(value))
                    return JSON_URI_PREFIX + encodeURIComponent(JSON.stringify(value));
                return encodeURIComponent(value)
            },
            parseSegment: function(value) {
                if (value.substr(0, JSON_URI_PREFIX.length) === JSON_URI_PREFIX)
                    try {
                        return $.parseJSON(decodeURIComponent(value.substr(JSON_URI_PREFIX.length)))
                    }
                    catch(x) {}
                return decodeURIComponent(value)
            }
        });
        DX.framework.Router = Class.inherit({
            ctor: function() {
                this._registry = []
            },
            _trimSeparators: function(str) {
                return str.replace(/^[\/.]+|\/+$/g, "")
            },
            _createRoute: function(pattern, defaults, constraints) {
                return new DX.framework.Route(pattern, defaults, constraints)
            },
            register: function(pattern, defaults, constraints) {
                this._registry.push(this._createRoute(pattern, defaults, constraints))
            },
            _parseQuery: function(query) {
                var result = {},
                    values = query.split("&");
                $.each(values, function(index, value) {
                    var keyValuePair = value.split("=");
                    result[keyValuePair[0]] = decodeURIComponent(keyValuePair[1])
                });
                return result
            },
            parse: function(uri) {
                var that = this,
                    ret;
                uri = this._trimSeparators(uri);
                var parts = uri.split("?", 2),
                    path = parts[0],
                    query = parts[1];
                $.each(this._registry, function() {
                    var result = this.parse(path);
                    if (result !== false) {
                        ret = result;
                        if (query)
                            ret = $.extend(ret, that._parseQuery(query));
                        return false
                    }
                });
                return ret ? ret : false
            },
            format: function(obj) {
                var ret = false,
                    minUnusedCount = 99999;
                obj = obj || {};
                $.each(this._registry, function() {
                    var toFormat = $.extend(true, {}, obj);
                    var result = this.format(toFormat);
                    if (result !== false)
                        if (minUnusedCount > result.unusedCount) {
                            minUnusedCount = result.unusedCount;
                            ret = result.uri
                        }
                });
                return ret
            }
        });
        DX.framework.Route.__internals = {JSON_URI_PREFIX: JSON_URI_PREFIX}
    })(jQuery, DevExpress);
    /*! Module framework, file framework.command.js */
    (function($, DX) {
        var errors = DevExpress.require("/framework/framework.errors"),
            registerComponent = DX.require("/componentRegistrator"),
            DOMComponent = DX.require("/domComponent");
        var Command = DOMComponent.inherit({
                ctor: function(element, options) {
                    if ($.isPlainObject(element)) {
                        options = element;
                        element = $("<div />")
                    }
                    this.callBase(element, options)
                },
                _setDeprecatedOptions: function() {
                    this.callBase();
                    $.extend(this._deprecatedOptions, {iconSrc: {
                            since: "15.1",
                            alias: "icon"
                        }})
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            onExecute: null,
                            id: null,
                            title: "",
                            icon: "",
                            visible: true,
                            disabled: false,
                            renderStage: "onViewShown"
                        })
                },
                execute: function() {
                    var isDisabled = this._options.disabled;
                    if ($.isFunction(isDisabled))
                        isDisabled = !!isDisabled.apply(this, arguments);
                    if (isDisabled)
                        throw errors.Error("E3004", this._options.id);
                    this.fireEvent("beforeExecute", arguments);
                    this._createActionByOption("onExecute").apply(this, arguments);
                    this.fireEvent("afterExecute", arguments)
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass("dx-command")
                },
                _renderDisabledState: $.noop,
                _dispose: function() {
                    this.callBase();
                    this.element().removeData(this.NAME)
                }
            });
        registerComponent("dxCommand", DX.framework, Command)
    })(jQuery, DevExpress);
    /*! Module framework, file framework.commandMapping.js */
    (function($, DX) {
        var Class = DevExpress.require("/class"),
            errors = DevExpress.require("/framework/framework.errors");
        DX.framework.CommandMapping = Class.inherit({
            ctor: function() {
                this._commandMappings = {};
                this._containerDefaults = {}
            },
            setDefaults: function(containerId, defaults) {
                this._containerDefaults[containerId] = defaults;
                return this
            },
            mapCommands: function(containerId, commandMappings) {
                var that = this;
                $.each(commandMappings, function(index, commandMapping) {
                    if (typeof commandMapping === "string")
                        commandMapping = {id: commandMapping};
                    var commandId = commandMapping.id;
                    var mappings = that._commandMappings[containerId] || {};
                    mappings[commandId] = $.extend({
                        showIcon: true,
                        showText: true
                    }, that._containerDefaults[containerId] || {}, commandMapping);
                    that._commandMappings[containerId] = mappings
                });
                this._initExistingCommands();
                return this
            },
            unmapCommands: function(containerId, commandIds) {
                var that = this;
                $.each(commandIds, function(index, commandId) {
                    var mappings = that._commandMappings[containerId] || {};
                    if (mappings)
                        delete mappings[commandId]
                });
                this._initExistingCommands()
            },
            getCommandMappingForContainer: function(commandId, containerId) {
                return (this._commandMappings[containerId] || {})[commandId]
            },
            checkCommandsExist: function(commands) {
                var that = this,
                    result = $.grep(commands, function(commandName, index) {
                        return $.inArray(commandName, that._existingCommands) < 0 && $.inArray(commandName, commands) === index
                    });
                if (result.length !== 0)
                    throw errors.Error("E3005", result.join("', '"), result.length === 1 ? " is" : "s are");
            },
            load: function(config) {
                if (!config)
                    return;
                var that = this;
                $.each(config, function(name, container) {
                    that.setDefaults(name, container.defaults);
                    that.mapCommands(name, container.commands)
                });
                return this
            },
            _initExistingCommands: function() {
                var that = this;
                this._existingCommands = [];
                $.each(that._commandMappings, function(name, _commands) {
                    $.each(_commands, function(index, command) {
                        if ($.inArray(command.id, that._existingCommands) < 0)
                            that._existingCommands.push(command.id)
                    })
                })
            }
        });
        DX.framework.CommandMapping.defaultMapping = {
            "global-navigation": {
                defaults: {
                    showIcon: true,
                    showText: true
                },
                commands: []
            },
            "ios-header-toolbar": {
                defaults: {
                    showIcon: false,
                    showText: true,
                    location: "after"
                },
                commands: ["edit", "save", {
                        id: "back",
                        location: "before"
                    }, {
                        id: "cancel",
                        location: "before"
                    }, {
                        id: "create",
                        showIcon: true,
                        showText: false
                    }]
            },
            "ios-action-sheet": {
                defaults: {
                    showIcon: false,
                    showText: true
                },
                commands: []
            },
            "ios-view-footer": {
                defaults: {
                    showIcon: false,
                    showText: true
                },
                commands: [{
                        id: "delete",
                        type: "danger"
                    }]
            },
            "android-header-toolbar": {
                defaults: {
                    showIcon: true,
                    showText: false,
                    location: "after"
                },
                commands: [{
                        id: "back",
                        showIcon: false,
                        location: "before"
                    }, "create", {
                        id: "save",
                        showText: true,
                        showIcon: false,
                        location: "after"
                    }, {
                        id: "edit",
                        showText: false,
                        location: "after"
                    }, {
                        id: "cancel",
                        showText: false,
                        location: "before"
                    }, {
                        id: "delete",
                        showText: false,
                        location: "after"
                    }]
            },
            "android-simple-toolbar": {
                defaults: {
                    showIcon: true,
                    showText: false,
                    location: "after"
                },
                commands: [{
                        id: "back",
                        showIcon: false,
                        location: "before"
                    }, {id: "create"}, {
                        id: "save",
                        showText: true,
                        showIcon: false,
                        location: "after"
                    }, {
                        id: "edit",
                        showText: false,
                        location: "after"
                    }, {
                        id: "cancel",
                        showText: false,
                        location: "before"
                    }, {
                        id: "delete",
                        showText: false,
                        location: "after"
                    }]
            },
            "android-footer-toolbar": {
                defaults: {location: "after"},
                commands: [{
                        id: "create",
                        showText: false,
                        location: "center"
                    }, {
                        id: "edit",
                        showText: false,
                        location: "before"
                    }, {
                        id: "delete",
                        location: "menu"
                    }, {
                        id: "save",
                        showIcon: false,
                        location: "before"
                    }]
            },
            "generic-header-toolbar": {
                defaults: {
                    showIcon: false,
                    showText: true,
                    location: "after"
                },
                commands: ["edit", "save", {
                        id: "back",
                        location: "before"
                    }, {
                        id: "cancel",
                        location: "before"
                    }, {
                        id: "create",
                        showIcon: true,
                        showText: false
                    }]
            },
            "generic-view-footer": {
                defaults: {
                    showIcon: false,
                    showText: true
                },
                commands: [{
                        id: "delete",
                        type: "danger"
                    }]
            },
            "win8-appbar": {
                defaults: {location: "after"},
                commands: ["edit", "cancel", "save", "delete", {
                        id: "create",
                        location: "before"
                    }, {
                        id: "refresh",
                        location: "before"
                    }]
            },
            "win8-toolbar": {
                defaults: {
                    showText: false,
                    location: "before"
                },
                commands: [{id: "previousPage"}]
            },
            "win8-phone-appbar": {
                defaults: {location: "center"},
                commands: ["create", "edit", "cancel", "save", "refresh", {
                        id: "delete",
                        location: "menu"
                    }]
            },
            "win8-split-toolbar": {
                defaults: {
                    showIcon: true,
                    showText: false,
                    location: "after"
                },
                commands: [{
                        id: "back",
                        showIcon: false,
                        location: "before"
                    }, {id: "create"}, {
                        id: "save",
                        showText: true,
                        location: "before"
                    }, {
                        id: "edit",
                        showText: true,
                        location: "menu"
                    }, {
                        id: "cancel",
                        showText: true,
                        location: "menu"
                    }, {
                        id: "delete",
                        showText: true,
                        location: "menu"
                    }]
            },
            "win8-master-detail-toolbar": {
                defaults: {
                    showText: false,
                    location: "before"
                },
                commands: ["back"]
            },
            "desktop-toolbar": {
                defaults: {
                    showIcon: false,
                    showText: true,
                    location: "after"
                },
                commands: ["cancel", "create", "edit", "save", {
                        id: "delete",
                        type: "danger"
                    }]
            }
        }
    })(jQuery, DevExpress);
    /*! Module framework, file framework.viewCache.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            EventsMixin = DX.require("/eventsMixin");
        DX.framework.ViewCache = Class.inherit({
            ctor: function() {
                this._cache = {}
            },
            setView: function(key, viewInfo) {
                this._cache[key] = viewInfo
            },
            getView: function(key) {
                return this._cache[key]
            },
            removeView: function(key) {
                var result = this._cache[key];
                if (result) {
                    delete this._cache[key];
                    this.fireEvent("viewRemoved", [{viewInfo: result}])
                }
                return result
            },
            clear: function() {
                var that = this;
                $.each(this._cache, function(key) {
                    that.removeView(key)
                })
            },
            hasView: function(key) {
                return key in this._cache
            }
        }).include(EventsMixin);
        DX.framework.NullViewCache = DX.framework.ViewCache.inherit({setView: function(key, viewInfo) {
                this.callBase(key, viewInfo);
                this.removeView(key)
            }});
        DX.framework.ConditionalViewCacheDecorator = Class.inherit({
            ctor: function(options) {
                this._filter = options.filter;
                this._viewCache = options.viewCache;
                this.viewRemoved = this._viewCache.viewRemoved;
                this._events = this._viewCache._events
            },
            setView: function(key, viewInfo) {
                this._viewCache.setView(key, viewInfo);
                if (!this._filter(key, viewInfo))
                    this._viewCache.removeView(key)
            },
            getView: function(key) {
                return this._viewCache.getView(key)
            },
            removeView: function(key) {
                return this._viewCache.removeView(key)
            },
            clear: function() {
                return this._viewCache.clear()
            },
            hasView: function(key) {
                return this._viewCache.hasView(key)
            }
        }).include(EventsMixin);
        var DEFAULT_VIEW_CACHE_CAPACITY = 5;
        DX.framework.CapacityViewCacheDecorator = Class.inherit({
            ctor: function(options) {
                this._keys = [];
                this._size = options.size || DEFAULT_VIEW_CACHE_CAPACITY;
                this._viewCache = options.viewCache;
                this.viewRemoved = this._viewCache.viewRemoved;
                this._events = this._viewCache._events
            },
            setView: function(key, viewInfo) {
                if (!this.hasView(key)) {
                    if (this._keys.length === this._size)
                        this.removeView(this._keys[0]);
                    this._keys.push(key)
                }
                this._viewCache.setView(key, viewInfo)
            },
            getView: function(key) {
                var index = $.inArray(key, this._keys);
                if (index < 0)
                    return null;
                this._keys.push(key);
                this._keys.splice(index, 1);
                return this._viewCache.getView(key)
            },
            removeView: function(key) {
                var index = $.inArray(key, this._keys);
                if (index > -1)
                    this._keys.splice(index, 1);
                return this._viewCache.removeView(key)
            },
            clear: function() {
                this._keys = [];
                return this._viewCache.clear()
            },
            hasView: function(key) {
                return this._viewCache.hasView(key)
            }
        }).include(EventsMixin);
        DX.framework.HistoryDependentViewCacheDecorator = Class.inherit({
            ctor: function(options) {
                this._viewCache = options.viewCache || new DX.framework.ViewCache;
                this._navigationManager = options.navigationManager;
                this._navigationManager.on("itemRemoved", $.proxy(this._onNavigationItemRemoved, this));
                this.viewRemoved = this._viewCache.viewRemoved;
                this._events = this._viewCache._events
            },
            _onNavigationItemRemoved: function(item) {
                this.removeView(item.key)
            },
            setView: function(key, viewInfo) {
                this._viewCache.setView(key, viewInfo)
            },
            getView: function(key) {
                return this._viewCache.getView(key)
            },
            removeView: function(key) {
                return this._viewCache.removeView(key)
            },
            clear: function() {
                return this._viewCache.clear()
            },
            hasView: function(key) {
                return this._viewCache.hasView(key)
            }
        }).include(EventsMixin)
    })(jQuery, DevExpress);
    /*! Module framework, file framework.stateManager.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class");
        DX.framework.MemoryKeyValueStorage = Class.inherit({
            ctor: function() {
                this.storage = {}
            },
            getItem: function(key) {
                return this.storage[key]
            },
            setItem: function(key, value) {
                this.storage[key] = value
            },
            removeItem: function(key) {
                delete this.storage[key]
            }
        });
        DX.framework.StateManager = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this.storage = options.storage || new DX.framework.MemoryKeyValueStorage;
                this.stateSources = options.stateSources || []
            },
            addStateSource: function(stateSource) {
                this.stateSources.push(stateSource)
            },
            removeStateSource: function(stateSource) {
                var index = $.inArray(stateSource, this.stateSources);
                if (index > -1) {
                    this.stateSources.splice(index, 1);
                    stateSource.removeState(this.storage)
                }
            },
            saveState: function() {
                var that = this;
                $.each(this.stateSources, function(index, stateSource) {
                    stateSource.saveState(that.storage)
                })
            },
            restoreState: function() {
                var that = this;
                $.each(this.stateSources, function(index, stateSource) {
                    stateSource.restoreState(that.storage)
                })
            },
            clearState: function() {
                var that = this;
                $.each(this.stateSources, function(index, stateSource) {
                    stateSource.removeState(that.storage)
                })
            }
        })
    })(jQuery, DevExpress);
    /*! Module framework, file framework.browserAdapters.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            queue = DX.require("/utils/utils.queue");
        var ROOT_PAGE_URL = "__root__",
            BUGGY_ANDROID_BUFFER_PAGE_URL = "__buffer__";
        DX.framework.DefaultBrowserAdapter = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this._window = options.window || window;
                this.popState = $.Callbacks();
                $(this._window).on("hashchange", $.proxy(this._onHashChange, this));
                this._tasks = queue.create();
                this.canWorkInPureBrowser = true
            },
            replaceState: function(uri) {
                var that = this;
                return this._addTask(function() {
                        uri = that._normalizeUri(uri);
                        that._window.history.replaceState(null, null, "#" + uri);
                        that._currentTask.resolve()
                    })
            },
            pushState: function(uri) {
                var that = this;
                return this._addTask(function() {
                        uri = that._normalizeUri(uri);
                        that._window.history.pushState(null, null, "#" + uri);
                        that._currentTask.resolve()
                    })
            },
            createRootPage: function() {
                return this.replaceState(ROOT_PAGE_URL)
            },
            _onHashChange: function() {
                if (this._currentTask)
                    this._currentTask.resolve();
                this.popState.fire()
            },
            back: function() {
                var that = this;
                return this._addTask(function() {
                        that._window.history.back()
                    })
            },
            getHash: function() {
                return this._normalizeUri(this._window.location.hash)
            },
            isRootPage: function() {
                return this.getHash() === ROOT_PAGE_URL
            },
            _normalizeUri: function(uri) {
                return (uri || "").replace(/^#+/, "")
            },
            _addTask: function(task) {
                var that = this,
                    d = $.Deferred();
                this._tasks.add(function() {
                    that._currentTask = d;
                    task();
                    return d
                });
                return d.promise()
            }
        });
        DX.framework.OldBrowserAdapter = DX.framework.DefaultBrowserAdapter.inherit({
            ctor: function() {
                this._innerEventCount = 0;
                this.callBase.apply(this, arguments);
                this._skipNextEvent = false
            },
            replaceState: function(uri) {
                var that = this;
                uri = that._normalizeUri(uri);
                if (that.getHash() !== uri) {
                    that._addTask(function() {
                        that._skipNextEvent = true;
                        that._window.history.back()
                    });
                    return that._addTask(function() {
                            that._skipNextEvent = true;
                            that._window.location.hash = uri
                        })
                }
                return $.Deferred().resolve().promise()
            },
            pushState: function(uri) {
                var that = this;
                uri = this._normalizeUri(uri);
                if (this.getHash() !== uri)
                    return that._addTask(function() {
                            that._skipNextEvent = true;
                            that._window.location.hash = uri
                        });
                return $.Deferred().resolve().promise()
            },
            createRootPage: function() {
                return this.pushState(ROOT_PAGE_URL)
            },
            _onHashChange: function() {
                var currentTask = this._currentTask;
                this._currentTask = null;
                if (this._skipNextEvent)
                    this._skipNextEvent = false;
                else
                    this.popState.fire();
                if (currentTask)
                    currentTask.resolve()
            }
        });
        DX.framework.BuggyAndroidBrowserAdapter = DX.framework.OldBrowserAdapter.inherit({createRootPage: function() {
                this.pushState(BUGGY_ANDROID_BUFFER_PAGE_URL);
                return this.callBase()
            }});
        DX.framework.HistorylessBrowserAdapter = DX.framework.DefaultBrowserAdapter.inherit({
            ctor: function(options) {
                options = options || {};
                this._window = options.window || window;
                this.popState = $.Callbacks();
                $(this._window).on("dxback", $.proxy(this._onHashChange, this));
                this._currentHash = this._window.location.hash
            },
            replaceState: function(uri) {
                this._currentHash = this._normalizeUri(uri);
                return $.Deferred().resolve().promise()
            },
            pushState: function(uri) {
                return this.replaceState(uri)
            },
            createRootPage: function() {
                return this.replaceState(ROOT_PAGE_URL)
            },
            getHash: function() {
                return this._normalizeUri(this._currentHash)
            },
            back: function() {
                return this.replaceState(ROOT_PAGE_URL)
            },
            _onHashChange: function() {
                var promise = this.back();
                this.popState.fire();
                return promise
            }
        });
        DX.framework.BuggyCordovaWP81BrowserAdapter = DX.framework.DefaultBrowserAdapter.inherit({ctor: function(options) {
                this.callBase(options);
                this.canWorkInPureBrowser = false
            }})
    })(jQuery, DevExpress);
    /*! Module framework, file framework.navigationDevices.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            storageUtils = DX.require("/utils/utils.storage"),
            devices = DX.require("/devices");
        var SESSION_KEY = "dxPhoneJSApplication";
        DX.framework.HistoryBasedNavigationDevice = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this._browserAdapter = options.browserAdapter || this._createBrowserAdapter(options);
                this.uriChanged = $.Callbacks();
                this._browserAdapter.popState.add($.proxy(this._onPopState, this))
            },
            init: $.noop,
            getUri: function() {
                return this._browserAdapter.getHash()
            },
            setUri: function(uri, replaceCurrent) {
                if (replaceCurrent)
                    return this._browserAdapter.replaceState(uri);
                else if (uri !== this.getUri())
                    return this._browserAdapter.pushState(uri);
                else
                    return $.Deferred().resolve().promise()
            },
            back: function() {
                return this._browserAdapter.back()
            },
            _onPopState: function() {
                this.uriChanged.fire(this.getUri())
            },
            _isBuggyAndroid2: function() {
                var realDevice = devices.real();
                var version = realDevice.version;
                return realDevice.platform === "android" && version.length > 1 && (version[0] === 2 && version[1] < 4 || version[0] < 2)
            },
            _isBuggyAndroid4: function() {
                var realDevice = devices.real();
                var version = realDevice.version;
                return realDevice.platform === "android" && version.length > 1 && version[0] === 4 && version[1] === 0
            },
            _isWindowsPhone8: function() {
                var realDevice = devices.real();
                return realDevice.platform === "win" && realDevice.phone
            },
            _createBrowserAdapter: function(options) {
                var sourceWindow = options.window || window,
                    supportPushReplace = sourceWindow.history.replaceState && sourceWindow.history.pushState,
                    result;
                if (this._isWindowsPhone8())
                    result = new DX.framework.BuggyCordovaWP81BrowserAdapter(options);
                else if (sourceWindow !== sourceWindow.top)
                    result = new DX.framework.HistorylessBrowserAdapter(options);
                else if (this._isBuggyAndroid4())
                    result = new DX.framework.BuggyAndroidBrowserAdapter(options);
                else if (this._isBuggyAndroid2() || !supportPushReplace)
                    result = new DX.framework.OldBrowserAdapter(options);
                else
                    result = new DX.framework.DefaultBrowserAdapter(options);
                return result
            }
        });
        DX.framework.StackBasedNavigationDevice = DX.framework.HistoryBasedNavigationDevice.inherit({
            ctor: function(options) {
                this.callBase(options);
                this.backInitiated = $.Callbacks();
                this._rootStateHandler = null;
                $(window).on("unload", this._saveBrowserState)
            },
            init: function() {
                var that = this;
                if (that._browserAdapter.canWorkInPureBrowser)
                    return that._initRootPage().done(function() {
                            if (that._browserAdapter.isRootPage())
                                that._browserAdapter.pushState("")
                        });
                else
                    return $.Deferred().resolve().promise()
            },
            setUri: function(uri) {
                return this.callBase(uri, !this._browserAdapter.isRootPage())
            },
            _saveBrowserState: function() {
                var sessionStorage = storageUtils.sessionStorage();
                if (sessionStorage)
                    sessionStorage.setItem(SESSION_KEY, true)
            },
            _initRootPage: function() {
                var hash = this.getUri(),
                    sessionStorage = storageUtils.sessionStorage();
                if (!sessionStorage || sessionStorage.getItem(SESSION_KEY))
                    return $.Deferred().resolve().promise();
                sessionStorage.removeItem(SESSION_KEY);
                this._browserAdapter.createRootPage();
                return this._browserAdapter.pushState(hash)
            },
            _onPopState: function() {
                if (this._browserAdapter.isRootPage())
                    if (this._rootStateHandler)
                        this._rootStateHandler();
                    else
                        this.backInitiated.fire();
                else {
                    if (!this._rootStateHandler)
                        this._createRootStateHndler();
                    this.back()
                }
            },
            _createRootStateHndler: function() {
                var uri = this.getUri();
                this._rootStateHandler = function() {
                    this.uriChanged.fire(uri);
                    this._rootStateHandler = null
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module framework, file framework.navigationManager.js */
    (function($, DX, undefined) {
        var Class = DX.require("/class"),
            EventsMixin = DX.require("/eventsMixin"),
            errors = DX.require("/framework/framework.errors"),
            commonUtils = DX.require("/utils/utils.common"),
            hardwareBackButton = DX.require("/utils/utils.hardwareBack").processCallback,
            hideTopOverlay = DX.require("/utils/utils.topOverlay").hide;
        var NAVIGATION_TARGETS = {
                current: "current",
                blank: "blank",
                back: "back"
            },
            STORAGE_HISTORY_KEY = "__history";
        DX.framework.HistoryBasedNavigationManager = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this._currentItem = undefined;
                this._previousItem = undefined;
                this._createNavigationDevice(options)
            },
            _createNavigationDevice: function(options) {
                this._navigationDevice = options.navigationDevice || new DX.framework.HistoryBasedNavigationDevice;
                this._navigationDevice.uriChanged.add($.proxy(this._uriChangedHandler, this))
            },
            _uriChangedHandler: function(uri) {
                while (hideTopOverlay());
                this.navigate(uri)
            },
            _syncUriWithCurrentNavigationItem: function() {
                var currentUri = this._currentItem && this._currentItem.uri;
                this._navigationDevice.setUri(currentUri, true)
            },
            _cancelNavigation: function(args) {
                this._syncUriWithCurrentNavigationItem();
                this.fireEvent("navigationCanceled", [args])
            },
            _getDefaultOptions: function() {
                return {
                        direction: "none",
                        target: NAVIGATION_TARGETS.blank
                    }
            },
            _updateHistory: function(uri, options) {
                this._previousItem = this._currentItem;
                this._currentItem = {
                    uri: uri,
                    key: uri
                };
                this._navigationDevice.setUri(uri, options.target === NAVIGATION_TARGETS.current)
            },
            _setCurrentItem: function(item) {
                this._currentItem = item
            },
            navigate: function(uri, options) {
                options = options || {};
                var that = this,
                    isFirstNavigate = !that._currentItem,
                    currentItem = that._currentItem || {},
                    targetItem = options.item || {},
                    currentUri = currentItem.uri,
                    currentKey = currentItem.key,
                    targetKey = targetItem.key,
                    args;
                if (uri === undefined)
                    uri = that._navigationDevice.getUri();
                if (/^_back$/.test(uri)) {
                    that.back();
                    return
                }
                options = $.extend(that._getDefaultOptions(), options || {});
                if (isFirstNavigate)
                    options.target = NAVIGATION_TARGETS.current;
                args = {
                    currentUri: currentUri,
                    uri: uri,
                    cancel: false,
                    navigateWhen: [],
                    options: options
                };
                that.fireEvent("navigating", [args]);
                uri = args.uri;
                if (args.cancel || currentUri === uri && (targetKey === undefined || targetKey === currentKey) && !that._forceNavigate)
                    that._cancelNavigation(args);
                else {
                    that._forceNavigate = false;
                    $.when.apply($, args.navigateWhen).done(function() {
                        commonUtils.executeAsync(function() {
                            that._updateHistory(uri, options);
                            that.fireEvent("navigated", [{
                                    uri: uri,
                                    previousUri: currentUri,
                                    options: options,
                                    item: that._currentItem
                                }])
                        })
                    })
                }
            },
            back: function() {
                return this._navigationDevice.back()
            },
            previousItem: function() {
                return this._previousItem
            },
            currentItem: function(item) {
                if (arguments.length > 0) {
                    if (!item)
                        throw errors.Error("E3023");
                    this._setCurrentItem(item)
                }
                else
                    return this._currentItem
            },
            rootUri: function() {
                return this._currentItem && this._currentItem.uri
            },
            canBack: function() {
                return true
            },
            saveState: $.noop,
            restoreState: $.noop,
            removeState: $.noop
        }).include(EventsMixin);
        DX.framework.StackBasedNavigationManager = DX.framework.HistoryBasedNavigationManager.inherit({
            ctor: function(options) {
                options = options || {};
                this.callBase(options);
                this._createNavigationStacks(options);
                hardwareBackButton.add($.proxy(this._deviceBackInitiated, this));
                this._stateStorageKey = options.stateStorageKey || STORAGE_HISTORY_KEY
            },
            init: function() {
                return this._navigationDevice.init()
            },
            _createNavigationDevice: function(options) {
                if (!options.navigationDevice)
                    options.navigationDevice = new DX.framework.StackBasedNavigationDevice;
                this.callBase(options);
                this._navigationDevice.backInitiated.add($.proxy(this._deviceBackInitiated, this))
            },
            _uriChangedHandler: function(uri) {
                this.navigate(uri)
            },
            _createNavigationStacks: function(options) {
                this.navigationStacks = {};
                this._keepPositionInStack = options.keepPositionInStack;
                this.currentStack = new DX.framework.NavigationStack
            },
            _deviceBackInitiated: function() {
                if (!hideTopOverlay())
                    this.back({isHardwareButton: true});
                else
                    this._syncUriWithCurrentNavigationItem()
            },
            _getDefaultOptions: function() {
                return {target: NAVIGATION_TARGETS.blank}
            },
            _createNavigationStack: function() {
                var result = new DX.framework.NavigationStack;
                result.itemsRemoved.add($.proxy(this._removeItems, this));
                return result
            },
            _setCurrentItem: function(item) {
                this._setCurrentStack(item.stack);
                this.currentStack.currentItem(item);
                this.callBase(item);
                this._syncUriWithCurrentNavigationItem()
            },
            _setCurrentStack: function(stackOrStackKey) {
                var stack,
                    stackKey;
                if (typeof stackOrStackKey === "string") {
                    stackKey = stackOrStackKey;
                    if (!(stackKey in this.navigationStacks))
                        this.navigationStacks[stackKey] = this._createNavigationStack();
                    stack = this.navigationStacks[stackKey]
                }
                else {
                    stack = stackOrStackKey;
                    stackKey = $.map(this.navigationStacks, function(stack, key) {
                        if (stack === stackOrStackKey)
                            return key;
                        return null
                    })[0]
                }
                this.currentStack = stack;
                this.currentStackKey = stackKey
            },
            _getViewTargetStackKey: function(uri, isRoot) {
                var result;
                if (isRoot)
                    if (this.navigationStacks[uri] !== undefined)
                        result = uri;
                    else {
                        for (var stackKey in this.navigationStacks)
                            if (this.navigationStacks[stackKey].items[0].uri === uri) {
                                result = stackKey;
                                break
                            }
                        result = result || uri
                    }
                else
                    result = this.currentStackKey || uri;
                return result
            },
            _updateHistory: function(uri, options) {
                var isRoot = options.root,
                    forceIsRoot = isRoot,
                    forceToRoot = false,
                    previousStack = this.currentStack,
                    keepPositionInStack = options.keepPositionInStack !== undefined ? options.keepPositionInStack : this._keepPositionInStack;
                options.stack = options.stack || this._getViewTargetStackKey(uri, isRoot);
                this._setCurrentStack(options.stack);
                if (isRoot || !this.currentStack.items.length) {
                    forceToRoot = this.currentStack === previousStack;
                    forceIsRoot = true
                }
                if (isRoot && this.currentStack.items.length) {
                    if (!keepPositionInStack || forceToRoot) {
                        this.currentStack.currentIndex = 0;
                        if (this.currentItem().uri !== uri)
                            this.currentStack.navigate(uri, true)
                    }
                    options.direction = options.direction || "none"
                }
                else {
                    var prevIndex = this.currentStack.currentIndex,
                        prevItem = this.currentItem() || {};
                    switch (options.target) {
                        case NAVIGATION_TARGETS.blank:
                            this.currentStack.navigate(uri);
                            break;
                        case NAVIGATION_TARGETS.current:
                            this.currentStack.navigate(uri, true);
                            break;
                        case NAVIGATION_TARGETS.back:
                            if (this.currentStack.currentIndex > 0)
                                this.currentStack.back(uri);
                            else
                                this.currentStack.navigate(uri, true);
                            break;
                        default:
                            throw errors.Error("E3006", options.target);
                    }
                    if (options.direction === undefined) {
                        var indexDelta = this.currentStack.currentIndex - prevIndex;
                        if (indexDelta < 0)
                            options.direction = this.currentStack.currentItem().backDirection || "backward";
                        else if (indexDelta > 0 && this.currentStack.currentIndex > 0)
                            options.direction = "forward";
                        else
                            options.direction = "none"
                    }
                    prevItem.backDirection = options.direction === "forward" ? "backward" : "none"
                }
                options.root = forceIsRoot;
                this._currentItem = this.currentStack.currentItem();
                this._syncUriWithCurrentNavigationItem()
            },
            _removeItems: function(items) {
                var that = this;
                $.each(items, function(index, item) {
                    that.fireEvent("itemRemoved", [item])
                })
            },
            back: function(options) {
                options = options || {};
                var navigatingBackArgs = $.extend({cancel: false}, options);
                this.fireEvent("navigatingBack", [navigatingBackArgs]);
                if (navigatingBackArgs.cancel) {
                    this._syncUriWithCurrentNavigationItem();
                    return
                }
                var item = this.previousItem(navigatingBackArgs.stack);
                if (item)
                    this.navigate(item.uri, {
                        stack: navigatingBackArgs.stack,
                        target: NAVIGATION_TARGETS.back,
                        item: item
                    });
                else
                    this.callBase()
            },
            rootUri: function() {
                return this.currentStack.items.length ? this.currentStack.items[0].uri : this.callBase()
            },
            canBack: function(stackKey) {
                var stack = stackKey ? this.navigationStacks[stackKey] : this.currentStack;
                return stack.canBack()
            },
            saveState: function(storage) {
                if (this.currentStack.items.length) {
                    var state = {
                            navigationStacks: {},
                            currentStackKey: this.currentStackKey
                        };
                    $.each(this.navigationStacks, function(stackKey, stack) {
                        var stackState = {};
                        state.navigationStacks[stackKey] = stackState;
                        stackState.currentIndex = stack.currentIndex;
                        stackState.items = $.map(stack.items, function(item) {
                            return {
                                    key: item.key,
                                    uri: item.uri
                                }
                        })
                    });
                    var json = JSON.stringify(state);
                    storage.setItem(this._stateStorageKey, json)
                }
                else
                    this.removeState(storage)
            },
            restoreState: function(storage) {
                if (this.disableRestoreState)
                    return;
                var json = storage.getItem(this._stateStorageKey);
                if (json)
                    try {
                        var that = this,
                            state = JSON.parse(json);
                        $.each(state.navigationStacks, function(stackKey, stackState) {
                            var stack = that._createNavigationStack();
                            that.navigationStacks[stackKey] = stack;
                            stack.currentIndex = stackState.currentIndex;
                            stack.items = $.map(stackState.items, function(item) {
                                item.stack = stack;
                                return item
                            })
                        });
                        this.currentStackKey = state.currentStackKey;
                        this.currentStack = this.navigationStacks[this.currentStackKey];
                        this._currentItem = this.currentStack.currentItem();
                        this._navigationDevice.setUri(this.currentItem().uri);
                        this._forceNavigate = true
                    }
                    catch(e) {
                        this.removeState(storage);
                        throw errors.Error("E3007");
                    }
            },
            removeState: function(storage) {
                storage.removeItem(this._stateStorageKey)
            },
            currentIndex: function() {
                return this.currentStack.currentIndex
            },
            previousItem: function(stackKey) {
                var stack = this.navigationStacks[stackKey] || this.currentStack;
                return stack.previousItem()
            },
            getItemByIndex: function(index) {
                return this.currentStack.items[index]
            },
            clearHistory: function() {
                this.currentStack.clear()
            },
            itemByKey: function(itemKey) {
                var result;
                $.each(this.navigationStacks, function(stackKey, stack) {
                    var item = stack.itemByKey(itemKey);
                    if (item) {
                        result = item;
                        return false
                    }
                });
                return result
            },
            currentItem: function(itemOrItemKey) {
                var item;
                if (arguments.length > 0) {
                    if (typeof itemOrItemKey === "string")
                        item = this.itemByKey(itemOrItemKey);
                    else if ($.isPlainObject(itemOrItemKey))
                        item = itemOrItemKey;
                    this.callBase(item)
                }
                else
                    return this.callBase()
            }
        });
        DX.framework.NavigationStack = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this.itemsRemoved = $.Callbacks();
                this.clear()
            },
            currentItem: function(item) {
                if (item) {
                    for (var i = 0; i < this.items.length; i++)
                        if (item === this.items[i]) {
                            this.currentIndex = i;
                            break
                        }
                }
                else
                    return this.items[this.currentIndex]
            },
            previousItem: function() {
                return this.items.length > 1 ? this.items[this.currentIndex - 1] : undefined
            },
            canBack: function() {
                return this.currentIndex > 0
            },
            clear: function() {
                this._deleteItems(this.items);
                this.items = [];
                this.currentIndex = -1
            },
            back: function(uri) {
                this.currentIndex--;
                if (this.currentIndex < 0)
                    throw errors.Error("E3008");
                var currentItem = this.currentItem();
                if (currentItem.uri !== uri)
                    this._updateItem(this.currentIndex, uri)
            },
            forward: function() {
                this.currentIndex++;
                if (this.currentIndex >= this.items.length)
                    throw errors.Error("E3009");
            },
            navigate: function(uri, replaceCurrent) {
                if (this.currentIndex < this.items.length && this.currentIndex > -1 && this.items[this.currentIndex].uri === uri)
                    return;
                if (replaceCurrent && this.currentIndex > -1)
                    this.currentIndex--;
                if (this.currentIndex + 1 < this.items.length && this.items[this.currentIndex + 1].uri === uri)
                    this.currentIndex++;
                else {
                    var toDelete = this.items.splice(this.currentIndex + 1, this.items.length - this.currentIndex - 1);
                    this.items.push({stack: this});
                    this.currentIndex++;
                    this._updateItem(this.currentIndex, uri);
                    this._deleteItems(toDelete)
                }
                return this.currentItem()
            },
            itemByKey: function(key) {
                for (var i = 0; i < this.items.length; i++) {
                    var item = this.items[i];
                    if (item.key === key)
                        return item
                }
            },
            _updateItem: function(index, uri) {
                var item = this.items[index];
                item.uri = uri;
                item.key = this.items[0].uri + "_" + index + "_" + uri
            },
            _deleteItems: function(items) {
                if (items)
                    this.itemsRemoved.fire(items)
            }
        });
        DX.framework.HistoryBasedNavigationManager.NAVIGATION_TARGETS = NAVIGATION_TARGETS
    })(jQuery, DevExpress);
    /*! Module framework, file framework.actionExecutors.js */
    (function($, DX, undefined) {
        function prepareNavigateOptions(options, actionArguments) {
            if (actionArguments.args) {
                var sourceEventArguments = actionArguments.args[0];
                options.jQueryEvent = sourceEventArguments.jQueryEvent
            }
            if ((actionArguments.component || {}).NAME === "dxCommand")
                $.extend(options, actionArguments.component.option())
        }
        function preventDefaultLinkBehaviour(e) {
            if (!e)
                return;
            var $targetElement = $(e.target);
            if ($targetElement.attr('href'))
                e.preventDefault()
        }
        DX.framework.createActionExecutors = function(app) {
            return {
                    routing: {execute: function(e) {
                            var action = e.action,
                                options = {},
                                routeValues,
                                uri;
                            if ($.isPlainObject(action)) {
                                routeValues = action.routeValues;
                                if (routeValues && $.isPlainObject(routeValues))
                                    options = action.options;
                                else
                                    routeValues = action;
                                uri = app.router.format(routeValues);
                                prepareNavigateOptions(options, e);
                                preventDefaultLinkBehaviour(options.jQueryEvent);
                                app.navigate(uri, options);
                                e.handled = true
                            }
                        }},
                    hash: {execute: function(e) {
                            if (typeof e.action !== "string" || e.action.charAt(0) !== "#")
                                return;
                            var uriTemplate = e.action.substr(1),
                                args = e.args[0],
                                uri = uriTemplate;
                            var defaultEvaluate = function(expr) {
                                    var getter = DX.data.utils.compileGetter(expr),
                                        model = e.args[0].model;
                                    return getter(model)
                                };
                            var evaluate = args.evaluate || defaultEvaluate;
                            uri = uriTemplate.replace(/\{([^}]+)\}/g, function(entry, expr) {
                                expr = $.trim(expr);
                                if (expr.indexOf(",") > -1)
                                    expr = $.map(expr.split(","), $.trim);
                                var value = evaluate(expr);
                                if (value === undefined)
                                    value = "";
                                value = DX.framework.Route.prototype.formatSegment(value);
                                return value
                            });
                            var options = {};
                            prepareNavigateOptions(options, e);
                            preventDefaultLinkBehaviour(options.jQueryEvent);
                            app.navigate(uri, options);
                            e.handled = true
                        }}
                }
        }
    })(jQuery, DevExpress);
    /*! Module framework, file framework.application.js */
    (function($, DX) {
        var Class = DX.require("/class"),
            abstract = Class.abstract,
            EventsMixin = DX.require("/eventsMixin"),
            Action = DX.require("/action"),
            storageUtils = DX.require("/utils/utils.storage"),
            commonUtils = DX.require("/utils/utils.common"),
            errors = DX.require("/framework/framework.errors"),
            BACK_COMMAND_TITLE,
            INIT_IN_PROGRESS = "InProgress",
            INIT_COMPLETE = "Inited",
            frameworkNS = DX.framework;
        DX.framework.Application = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this._options = options;
                this.namespace = options.namespace || window;
                this._applicationMode = options.mode ? options.mode : "mobileApp";
                this.components = [];
                BACK_COMMAND_TITLE = DX.localization.localizeString("@Back");
                this.router = options.router || new DX.framework.Router;
                var navigationManagers = {
                        mobileApp: DX.framework.StackBasedNavigationManager,
                        webSite: DX.framework.HistoryBasedNavigationManager
                    };
                this.navigationManager = options.navigationManager || new navigationManagers[this._applicationMode]({keepPositionInStack: options.navigateToRootViewMode === "keepHistory"});
                this.navigationManager.on("navigating", $.proxy(this._onNavigating, this));
                this.navigationManager.on("navigatingBack", $.proxy(this._onNavigatingBack, this));
                this.navigationManager.on("navigated", $.proxy(this._onNavigated, this));
                this.navigationManager.on("navigationCanceled", $.proxy(this._onNavigationCanceled, this));
                this.stateManager = options.stateManager || new DX.framework.StateManager({storage: options.stateStorage || storageUtils.sessionStorage()});
                this.stateManager.addStateSource(this.navigationManager);
                this.viewCache = this._createViewCache(options);
                this.commandMapping = this._createCommandMapping(options.commandMapping);
                this.createNavigation(options.navigation);
                this._isNavigating = false;
                this._viewLinksHash = {};
                Action.registerExecutor(DX.framework.createActionExecutors(this));
                this.components.push(this.router);
                this.components.push(this.navigationManager)
            },
            _createViewCache: function(options) {
                var result;
                if (options.viewCache)
                    result = options.viewCache;
                else if (options.disableViewCache)
                    result = new DX.framework.NullViewCache;
                else
                    result = new DX.framework.CapacityViewCacheDecorator({
                        size: options.viewCacheSize,
                        viewCache: new DX.framework.ViewCache
                    });
                result.on("viewRemoved", $.proxy(function(e) {
                    this._releaseViewLink(e.viewInfo)
                }, this));
                return result
            },
            _createCommandMapping: function(commandMapping) {
                var result = commandMapping;
                if (!(commandMapping instanceof DX.framework.CommandMapping)) {
                    result = new DX.framework.CommandMapping;
                    result.load(DX.framework.CommandMapping.defaultMapping || {}).load(commandMapping || {})
                }
                return result
            },
            createNavigation: function(navigationConfig) {
                this.navigation = this._createNavigationCommands(navigationConfig);
                this._mapNavigationCommands(this.navigation, this.commandMapping)
            },
            _createNavigationCommands: function(commandConfig) {
                if (!commandConfig)
                    return [];
                var generatedIdCount = 0;
                return $.map(commandConfig, function(item) {
                        var command;
                        if (item instanceof frameworkNS.dxCommand)
                            command = item;
                        else
                            command = new frameworkNS.dxCommand($.extend({root: true}, item));
                        if (!command.option("id"))
                            command.option("id", "navigation_" + generatedIdCount++);
                        return command
                    })
            },
            _mapNavigationCommands: function(navigationCommands, commandMapping) {
                var navigationCommandIds = $.map(navigationCommands, function(command) {
                        return command.option("id")
                    });
                commandMapping.mapCommands("global-navigation", navigationCommandIds)
            },
            _callComponentMethod: function(methodName, args) {
                var tasks = [];
                $.each(this.components, function(index, component) {
                    if (component[methodName] && $.isFunction(component[methodName])) {
                        var result = component[methodName](args);
                        if (result && result.done)
                            tasks.push(result)
                    }
                });
                return $.when.apply($, tasks)
            },
            init: function() {
                var that = this;
                that._initState = INIT_IN_PROGRESS;
                return that._callComponentMethod("init").done(function() {
                        that._initState = INIT_COMPLETE;
                        that._processEvent("initialized")
                    }).fail(function(error) {
                        throw error || errors.Error("E3022");
                    })
            },
            _onNavigatingBack: function(args) {
                this._processEvent("navigatingBack", args)
            },
            _onNavigating: function(args) {
                var that = this;
                if (that._isNavigating) {
                    that._pendingNavigationArgs = args;
                    args.cancel = true;
                    return
                }
                else {
                    that._isNavigating = true;
                    delete that._pendingNavigationArgs
                }
                var routeData = this.router.parse(args.uri);
                if (!routeData)
                    throw errors.Error("E3001", args.uri);
                var uri = this.router.format(routeData);
                if (args.uri !== uri && uri) {
                    args.cancel = true;
                    args.cancelReason = "redirect";
                    commonUtils.executeAsync(function() {
                        that.navigate(uri, args.options)
                    })
                }
                else
                    that._processEvent("navigating", args)
            },
            _onNavigated: function(args) {
                var that = this,
                    direction = args.options.direction,
                    resultDeferred,
                    viewInfo = that._acquireViewInfo(args.item, args.options);
                if (!viewInfo.model) {
                    this._processEvent("beforeViewSetup", {viewInfo: viewInfo});
                    that._createViewModel(viewInfo);
                    that._createViewCommands(viewInfo);
                    this._processEvent("afterViewSetup", {viewInfo: viewInfo})
                }
                that._highlightCurrentNavigationCommand(viewInfo);
                resultDeferred = that._showView(viewInfo, direction).always(function() {
                    that._isNavigating = false;
                    var pendingArgs = that._pendingNavigationArgs;
                    if (pendingArgs)
                        commonUtils.executeAsync(function() {
                            that.navigate(pendingArgs.uri, pendingArgs.options)
                        })
                });
                return resultDeferred
            },
            _isViewReadyToShow: function(viewInfo) {
                return !!viewInfo.model
            },
            _onNavigationCanceled: function(args) {
                var that = this;
                if (!that._pendingNavigationArgs || that._pendingNavigationArgs.uri !== args.uri) {
                    var currentItem = that.navigationManager.currentItem();
                    if (currentItem)
                        commonUtils.executeAsync(function() {
                            var viewInfo = that._acquireViewInfo(currentItem, args.options);
                            that._highlightCurrentNavigationCommand(viewInfo, true)
                        });
                    that._isNavigating = false
                }
            },
            _disposeRemovedViews: function() {
                var that = this,
                    args;
                $.each(that._viewLinksHash, function(key, link) {
                    if (!link.linkCount) {
                        args = {viewInfo: link.viewInfo};
                        that._processEvent("viewDisposing", args, args.viewInfo.model);
                        that._disposeView(link.viewInfo);
                        that._processEvent("viewDisposed", args, args.viewInfo.model);
                        delete that._viewLinksHash[key]
                    }
                })
            },
            _onViewHidden: function(viewInfo) {
                var args = {viewInfo: viewInfo};
                this._processEvent("viewHidden", args, args.viewInfo.model)
            },
            _disposeView: function(viewInfo) {
                var commands = viewInfo.commands || [];
                $.each(commands, function(index, command) {
                    command._dispose()
                })
            },
            _acquireViewInfo: function(navigationItem, navigateOptions) {
                var routeData = this.router.parse(navigationItem.uri),
                    viewInfoKey = this._getViewInfoKey(navigationItem, routeData),
                    viewInfo = this.viewCache.getView(viewInfoKey);
                if (!viewInfo) {
                    viewInfo = this._createViewInfo(navigationItem, navigateOptions);
                    this._obtainViewLink(viewInfo);
                    this.viewCache.setView(viewInfoKey, viewInfo)
                }
                else
                    this._updateViewInfo(viewInfo, navigationItem, navigateOptions);
                return viewInfo
            },
            _getViewInfoKey: function(navigationItem, routeData) {
                var args = {
                        key: navigationItem.key,
                        navigationItem: navigationItem,
                        routeData: routeData
                    };
                this._processEvent("resolveViewCacheKey", args);
                return args.key
            },
            _processEvent: function(eventName, args, model) {
                this._callComponentMethod(eventName, args);
                this.fireEvent(eventName, args && [args]);
                var modelMethod = (model || {})[eventName];
                if (modelMethod)
                    modelMethod.call(model, args)
            },
            _updateViewInfo: function(viewInfo, navigationItem, navigateOptions) {
                var uri = navigationItem.uri,
                    routeData = this.router.parse(uri);
                viewInfo.viewName = routeData.view;
                viewInfo.routeData = routeData;
                viewInfo.uri = uri;
                viewInfo.navigateOptions = navigateOptions;
                viewInfo.canBack = this.canBack(navigateOptions.stack);
                viewInfo.previousViewInfo = this._getPreviousViewInfo(navigateOptions)
            },
            _createViewInfo: function(navigationItem, navigateOptions) {
                var uri = navigationItem.uri,
                    routeData = this.router.parse(uri),
                    viewInfo = {key: this._getViewInfoKey(navigationItem, routeData)};
                this._updateViewInfo(viewInfo, navigationItem, navigateOptions);
                return viewInfo
            },
            _createViewModel: function(viewInfo) {
                viewInfo.model = viewInfo.model || this._callViewCodeBehind(viewInfo)
            },
            _createViewCommands: function(viewInfo) {
                viewInfo.commands = viewInfo.model.commands || [];
                if (viewInfo.canBack && this._applicationMode !== "webSite")
                    this._appendBackCommand(viewInfo)
            },
            _callViewCodeBehind: function(viewInfo) {
                var setupFunc = $.noop,
                    routeData = viewInfo.routeData;
                if (routeData.view in this.namespace)
                    setupFunc = this.namespace[routeData.view];
                return setupFunc.call(this.namespace, routeData, viewInfo) || {}
            },
            _appendBackCommand: function(viewInfo) {
                var commands = viewInfo.commands,
                    that = this,
                    backTitle = BACK_COMMAND_TITLE;
                if (that._options.useViewTitleAsBackText)
                    backTitle = ((viewInfo.previousViewInfo || {}).model || {}).title || backTitle;
                var toMergeTo = [new DX.framework.dxCommand({
                            id: "back",
                            title: backTitle,
                            behavior: "back",
                            onExecute: function() {
                                that.back({stack: viewInfo.navigateOptions.stack})
                            },
                            icon: "arrowleft",
                            type: "back",
                            renderStage: that._options.useViewTitleAsBackText ? "onViewRendering" : "onViewShown"
                        })];
                var result = DX.framework.utils.mergeCommands(toMergeTo, commands);
                commands.length = 0;
                commands.push.apply(commands, result)
            },
            _showView: function(viewInfo, direction) {
                var that = this;
                var eventArgs = {
                        viewInfo: viewInfo,
                        direction: direction,
                        params: viewInfo.routeData
                    };
                DX.data.utils.processRequestResultLock.obtain();
                return that._showViewImpl(eventArgs.viewInfo, eventArgs.direction).done(function() {
                        commonUtils.executeAsync(function() {
                            DX.data.utils.processRequestResultLock.release();
                            that._processEvent("viewShown", eventArgs, viewInfo.model);
                            that._disposeRemovedViews()
                        })
                    })
            },
            _highlightCurrentNavigationCommand: function(viewInfo, forceUpdate) {
                var that = this,
                    selectedCommand,
                    currentNavigationItemId = viewInfo.model && viewInfo.model.currentNavigationItemId;
                if (currentNavigationItemId !== undefined)
                    $.each(this.navigation, function(index, command) {
                        if (command.option("id") === currentNavigationItemId) {
                            selectedCommand = command;
                            return false
                        }
                    });
                if (!selectedCommand)
                    $.each(this.navigation, function(index, command) {
                        var commandUri = command.option("onExecute");
                        if (commonUtils.isString(commandUri)) {
                            commandUri = commandUri.replace(/^#+/, "");
                            if (commandUri === that.navigationManager.rootUri()) {
                                selectedCommand = command;
                                return false
                            }
                        }
                    });
                $.each(this.navigation, function(index, command) {
                    if (forceUpdate && command === selectedCommand && command.option("highlighted"))
                        command.fireEvent("optionChanged", [{
                                name: "highlighted",
                                value: true,
                                previousValue: true
                            }]);
                    command.option("highlighted", command === selectedCommand)
                })
            },
            _showViewImpl: abstract,
            _obtainViewLink: function(viewInfo) {
                var key = viewInfo.key;
                if (!this._viewLinksHash[key])
                    this._viewLinksHash[key] = {
                        viewInfo: viewInfo,
                        linkCount: 1
                    };
                else
                    this._viewLinksHash[key].linkCount++
            },
            _releaseViewLink: function(viewInfo) {
                if (this._viewLinksHash[viewInfo.key] === undefined)
                    errors.log("W3001", viewInfo.key);
                if (this._viewLinksHash[viewInfo.key].linkCount === 0)
                    errors.log("W3002", viewInfo.key);
                this._viewLinksHash[viewInfo.key].linkCount--
            },
            navigate: function(uri, options) {
                var that = this;
                if ($.isPlainObject(uri)) {
                    uri = that.router.format(uri);
                    if (uri === false)
                        throw errors.Error("E3002");
                }
                if (!that._initState)
                    that.init().done(function() {
                        that.restoreState();
                        that.navigate(uri, options)
                    });
                else if (that._initState === INIT_COMPLETE) {
                    if (!that._isNavigating || uri)
                        that.navigationManager.navigate(uri, options)
                }
                else
                    throw errors.Error("E3003");
            },
            canBack: function(stackKey) {
                return this.navigationManager.canBack(stackKey)
            },
            _getPreviousViewInfo: function(navigateOptions) {
                var previousNavigationItem = this.navigationManager.previousItem(navigateOptions.stack),
                    result;
                if (previousNavigationItem) {
                    var routeData = this.router.parse(previousNavigationItem.uri);
                    result = this.viewCache.getView(this._getViewInfoKey(previousNavigationItem, routeData))
                }
                return result
            },
            back: function(options) {
                this.navigationManager.back(options)
            },
            saveState: function() {
                this.stateManager.saveState()
            },
            restoreState: function() {
                this.stateManager.restoreState()
            },
            clearState: function() {
                this.stateManager.clearState()
            }
        }).include(EventsMixin)
    })(jQuery, DevExpress);
    /*! Module framework, file framework.html.js */
    (function($, DX, undefined) {
        DX.framework.html = {
            layoutSets: {},
            animationSets: {
                "native": {
                    "view-content-change": [{animation: "slide"}, {
                            animation: "ios7-slide",
                            device: {platform: "ios"}
                        }, {
                            animation: "none",
                            device: {
                                deviceType: "desktop",
                                platform: "generic"
                            }
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "view-header-toolbar": [{animation: "ios7-toolbar"}, {
                            animation: "slide",
                            device: {grade: "B"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }]
                },
                "default": {
                    "layout-change": [{animation: "none"}, {
                            animation: "ios7-slide",
                            device: {platform: "ios"}
                        }, {
                            animation: "pop",
                            device: {platform: "android"}
                        }, {
                            animation: "openDoor",
                            device: {
                                deviceType: "phone",
                                platform: "win"
                            }
                        }],
                    "view-content-change": [{animation: "slide"}, {
                            animation: "ios7-slide",
                            device: {platform: "ios"}
                        }, {
                            animation: "fade",
                            device: {
                                deviceType: "desktop",
                                platform: "generic"
                            }
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "view-content-rendered": [{animation: "fade"}, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "view-header-toolbar": [{animation: "ios7-toolbar"}, {
                            animation: "slide",
                            device: {grade: "B"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "command-rendered": [{animation: "stagger-fade-drop"}, {
                            animation: "fade",
                            device: {grade: "B"}
                        }, {
                            animation: "fade",
                            device: {deviceType: "desktop"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "list-item-rendered": [{
                            animation: "stagger-3d-drop",
                            device: {grade: "A"}
                        }, {
                            animation: "fade",
                            device: {deviceType: "desktop"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "detail-item-rendered": [{
                            animation: "stagger-3d-drop",
                            device: {grade: "A"}
                        }, {
                            animation: "fade",
                            device: {deviceType: "desktop"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "edit-item-rendered": [{
                            animation: "stagger-3d-drop",
                            device: {grade: "A"}
                        }, {
                            animation: "fade",
                            device: {deviceType: "desktop"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }]
                },
                slide: {
                    "view-content-change": [{animation: "slide"}, {
                            animation: "ios7-slide",
                            device: {platform: "ios"}
                        }, {
                            animation: "fade",
                            device: {
                                deviceType: "desktop",
                                platform: "generic"
                            }
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "view-content-rendered": [{animation: "fade"}, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "view-header-toolbar": [{animation: "ios7-toolbar"}, {
                            animation: "slide",
                            device: {grade: "B"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "command-rendered": [{animation: "stagger-fade-drop"}, {
                            animation: "fade",
                            device: {grade: "B"}
                        }, {
                            animation: "fade",
                            device: {deviceType: "desktop"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "list-item-rendered": [{
                            animation: "stagger-fade-slide",
                            device: {grade: "A"}
                        }, {
                            animation: "fade",
                            device: {deviceType: "desktop"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "detail-item-rendered": [{
                            animation: "stagger-fade-slide",
                            device: {grade: "A"}
                        }, {
                            animation: "fade",
                            device: {deviceType: "desktop"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "edit-item-rendered": [{
                            animation: "stagger-fade-slide",
                            device: {grade: "A"}
                        }, {
                            animation: "fade",
                            device: {deviceType: "desktop"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }]
                },
                zoom: {
                    "view-content-change": [{animation: "slide"}, {
                            animation: "ios7-slide",
                            device: {platform: "ios"}
                        }, {
                            animation: "fade",
                            device: {
                                deviceType: "desktop",
                                platform: "generic"
                            }
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "view-content-rendered": [{animation: "fade"}, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "view-header-toolbar": [{animation: "ios7-toolbar"}, {
                            animation: "slide",
                            device: {grade: "B"}
                        }, {
                            animation: "fade",
                            device: {deviceType: "desktop"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "command-rendered": [{animation: "stagger-fade-zoom"}, {
                            animation: "fade",
                            device: {grade: "B"}
                        }, {
                            animation: "fade",
                            device: {deviceType: "desktop"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "list-item-rendered": [{
                            animation: "stagger-fade-zoom",
                            device: {grade: "A"}
                        }, {
                            animation: "fade",
                            device: {deviceType: "desktop"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "detail-item-rendered": [{
                            animation: "stagger-fade-zoom",
                            device: {grade: "A"}
                        }, {
                            animation: "fade",
                            device: {deviceType: "desktop"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }],
                    "edit-item-rendered": [{
                            animation: "stagger-fade-zoom",
                            device: {grade: "A"}
                        }, {
                            animation: "fade",
                            device: {deviceType: "desktop"}
                        }, {
                            animation: "none",
                            device: {grade: "C"}
                        }]
                }
            }
        }
    })(jQuery, DevExpress);
    /*! Module framework, file framework.markupComponent.js */
    (function($, DX, undefined) {
        var Class = DX.require("/class"),
            publicComponentUtils = DX.require("/utils/utils.publicComponent"),
            removeEvent = DX.require("/ui/events/ui.events.remove");
        var MarkupComponent = Class.inherit({
                ctor: function(element, options) {
                    this.NAME = this.constructor.publicName();
                    options = options || {};
                    this._$element = $(element).one(removeEvent.name, $.proxy(function() {
                        this._dispose()
                    }, this));
                    publicComponentUtils.attachInstanceToElement(this._$element, this.NAME, this);
                    if (options.fromCache)
                        this._options = options;
                    else {
                        this._options = {};
                        this._setDefaultOptions();
                        if (options)
                            this.option(options);
                        this._render()
                    }
                },
                _setDefaultOptions: $.noop,
                _render: $.noop,
                _dispose: $.noop,
                element: function() {
                    return this._$element
                },
                option: function(name, value) {
                    if (arguments.length === 0)
                        return this._options;
                    else if (arguments.length === 1)
                        if (typeof name === "string")
                            return this._options[name];
                        else {
                            value = name;
                            $.extend(this._options, value)
                        }
                    else
                        this._options[name] = value
                },
                instance: function() {
                    return this
                }
            });
        MarkupComponent.publicName = publicComponentUtils.getName;
        MarkupComponent.getInstance = function($element) {
            return publicComponentUtils.getInstanceByElement($element, this.publicName())
        };
        $.extend(DX.framework.html, {MarkupComponent: MarkupComponent})
    })(jQuery, DevExpress);
    /*! Module framework, file framework.widgetCommandAdapters.js */
    (function($, DX) {
        var Class = DevExpress.require("/class"),
            commandToContainer = DX.framework.utils.commandToContainer,
            DX_COMMAND_TO_WIDGET_ADAPTER = "dxCommandToWidgetAdapter";
        var WidgetItemWrapperBase = Class.inherit({
                ctor: function(command, containerOptions) {
                    this.command = command;
                    this.widgetItem = this._createWidgetItem(command, containerOptions)
                },
                _createWidgetItem: function(command, containerOptions) {
                    var itemOptions = $.extend({}, containerOptions, command.option()),
                        executeCommandCallback = function(e) {
                            command.execute(e)
                        },
                        result;
                    itemOptions.text = commandToContainer.resolveTextValue(command, containerOptions);
                    itemOptions.icon = commandToContainer.resolveIconValue(command, containerOptions);
                    itemOptions.type = commandToContainer.resolvePropertyValue(command, containerOptions, "type");
                    itemOptions.location = commandToContainer.resolvePropertyValue(command, containerOptions, "location");
                    result = this._createWidgetItemCore(itemOptions, executeCommandCallback);
                    result.command = command;
                    return result
                },
                _createWidgetItemCore: function(itemOptions, executeCommandCallback) {
                    return itemOptions
                },
                dispose: function() {
                    delete this.command;
                    delete this.widgetItem
                }
            });
        var WidgetAdapterBase = Class.inherit({
                ctor: function($widgetElement) {
                    this._commandToWidgetItemOptionNames = {};
                    this.$widgetElement = $widgetElement;
                    this.$widgetElement.data(DX_COMMAND_TO_WIDGET_ADAPTER, this);
                    this.widget = this._getWidgetByElement($widgetElement);
                    this._widgetWidgetContentReadyHandler = $.proxy(this._onWidgetContentReady, this);
                    this._widgetWidgetItemRenderedHandler = $.proxy(this._onWidgetItemRendered, this);
                    this._widgetDisposingHandler = $.proxy(this._onWidgetDisposing, this);
                    this.widget.on("itemRendered", this._widgetWidgetItemRenderedHandler);
                    this.widget.on("contentReady", this._widgetWidgetContentReadyHandler);
                    this.widget.on("disposing", this._widgetDisposingHandler);
                    this.itemWrappers = [];
                    this._transitionExecutor = new DX.TransitionExecutor
                },
                addCommand: function(command, containerOptions) {
                    var itemWrapper = this._createItemWrapper(command, containerOptions);
                    this.itemWrappers.push(itemWrapper);
                    this._addItemToWidget(itemWrapper);
                    this._commandChangedHandler = $.proxy(this._onCommandChanged, this);
                    itemWrapper.command.on("optionChanged", this._commandChangedHandler)
                },
                beginUpdate: function() {
                    this.widget.beginUpdate()
                },
                endUpdate: function() {
                    this.widget.endUpdate();
                    return this.animationDeferred
                },
                _onWidgetItemRendered: function(e) {
                    if (e.itemData.isJustAdded && e.itemData.command && e.itemData.command.option("visible") && this._commandRenderedAnimation) {
                        this._transitionExecutor.enter(e.itemElement, this._commandRenderedAnimation);
                        delete e.itemData.isJustAdded
                    }
                },
                _onWidgetContentReady: function(e) {
                    this.animationDeferred = this._transitionExecutor.start()
                },
                _onWidgetDisposing: function() {
                    this.dispose(true)
                },
                _setWidgetItemOption: function(optionName, optionValue, itemCommand) {
                    var items = this.widget.option("items"),
                        itemIndex = $.inArray(itemCommand, $.map(items, function(item) {
                            return item.command || {}
                        }));
                    if (itemIndex > -1) {
                        var optionPath = "items[" + itemIndex + "].";
                        if (optionName !== "visible" && optionName !== "location" && this.widget.option("items[" + itemIndex + "]").options)
                            optionPath += "options.";
                        optionPath += this._commandToWidgetItemOptionNames[optionName] || optionName;
                        this.widget.option(optionPath, optionValue)
                    }
                },
                _onCommandChanged: function(args) {
                    if (args.name === "highlighted")
                        return;
                    this._setWidgetItemOption(args.name, args.value, args.component)
                },
                _addItemToWidget: function(itemWrapper) {
                    var items = this.widget.option("items");
                    items.push(itemWrapper.widgetItem);
                    if (this.widget.element().is(":visible"))
                        itemWrapper.widgetItem.isJustAdded = true;
                    this.widget.option("items", items)
                },
                refresh: function() {
                    var items = this.widget.option("items");
                    this.widget.option("items", items)
                },
                clear: function(widgetDisposing) {
                    var that = this;
                    $.each(that.itemWrappers, function(index, itemWrapper) {
                        itemWrapper.command.off("optionChanged", that._commandChangedHandler);
                        itemWrapper.dispose()
                    });
                    this.itemWrappers.length = 0;
                    if (!widgetDisposing)
                        this._clearWidgetItems()
                },
                _clearWidgetItems: function() {
                    this.widget.option("items", [])
                },
                dispose: function(widgetDisposing) {
                    this.clear(widgetDisposing);
                    if (this.widget) {
                        this.widget.off("itemRendered", this._widgetWidgetItemRenderedHandler);
                        this.widget.off("contentReady", this._widgetContentReadyHandler);
                        this.widget.off("disposing", this._widgetDisposingHandler);
                        this.$widgetElement.removeData(DX_COMMAND_TO_WIDGET_ADAPTER);
                        delete this.widget;
                        delete this.$widgetElement
                    }
                }
            });
        var CommandToWidgetAdapter = Class.inherit({
                ctor: function(createAdapter) {
                    this.createAdapter = createAdapter
                },
                _getWidgetAdapter: function($container) {
                    var widgetAdapter = $container.data(DX_COMMAND_TO_WIDGET_ADAPTER);
                    if (!widgetAdapter)
                        widgetAdapter = this.createAdapter($container);
                    return widgetAdapter
                },
                addCommand: function($container, command, containerOptions) {
                    var widgetAdapter = this._getWidgetAdapter($container);
                    widgetAdapter.addCommand(command, containerOptions)
                },
                clearContainer: function($container) {
                    var widgetAdapter = this._getWidgetAdapter($container);
                    widgetAdapter.clear()
                },
                beginUpdate: function($container) {
                    var widgetAdapter = this._getWidgetAdapter($container);
                    widgetAdapter.beginUpdate()
                },
                endUpdate: function($container) {
                    var widgetAdapter = this._getWidgetAdapter($container);
                    return widgetAdapter.endUpdate()
                }
            });
        var dxToolbarItemWrapper = WidgetItemWrapperBase.inherit({_createWidgetItemCore: function(itemOptions, executeCommandCallback) {
                    var widgetItem;
                    itemOptions.onClick = executeCommandCallback;
                    if (itemOptions.location === "menu")
                        widgetItem = itemOptions;
                    else {
                        widgetItem = {
                            location: itemOptions.location,
                            visible: itemOptions.visible,
                            options: itemOptions,
                            widget: "button"
                        };
                        itemOptions.visible = true;
                        delete itemOptions.location
                    }
                    return widgetItem
                }});
        var dxToolbarAdapter = WidgetAdapterBase.inherit({
                ctor: function($widgetElement) {
                    this.callBase($widgetElement);
                    this._commandToWidgetItemOptionNames = {title: "text"};
                    this._commandRenderedAnimation = "command-rendered"
                },
                _getWidgetByElement: function($element) {
                    return $element.dxToolbar("instance")
                },
                _createItemWrapper: function(command, containerOptions) {
                    return new dxToolbarItemWrapper(command, containerOptions)
                },
                addCommand: function(command, containerOptions) {
                    this.widget.option("visible", true);
                    this.callBase(command, containerOptions)
                }
            });
        var dxListItemWrapper = WidgetItemWrapperBase.inherit({_createWidgetItemCore: function(itemOptions, executeCommandCallback) {
                    itemOptions.title = itemOptions.text;
                    itemOptions.onClick = executeCommandCallback;
                    return itemOptions
                }});
        var dxListAdapter = WidgetAdapterBase.inherit({
                _createItemWrapper: function(command, containerOptions) {
                    return new dxListItemWrapper(command, containerOptions)
                },
                _getWidgetByElement: function($element) {
                    return $element.dxList("instance")
                }
            });
        var dxNavBarItemWrapper = WidgetItemWrapperBase.inherit({});
        var dxNavBarAdapter = WidgetAdapterBase.inherit({
                ctor: function($widgetElement) {
                    this.callBase($widgetElement);
                    this._commandToWidgetItemOptionNames = {title: "text"};
                    this.widget.option("onItemClick", $.proxy(this._onNavBarItemClick, this))
                },
                _onNavBarItemClick: function(e) {
                    var items = this.widget.option("items");
                    for (var i = items.length; --i; )
                        items[i].command.option("highlighted", false);
                    e.itemData.command.execute(e)
                },
                _getWidgetByElement: function($element) {
                    return $element.dxNavBar("instance")
                },
                _createItemWrapper: function(command, containerOptions) {
                    return new dxNavBarItemWrapper(command, containerOptions)
                },
                addCommand: function(command, containerOptions) {
                    this.callBase(command, containerOptions);
                    this._updateSelectedIndex()
                },
                _onCommandChanged: function(args) {
                    var optionName = args.name,
                        newValue = args.value;
                    if (optionName === "highlighted" && newValue)
                        this._updateSelectedIndex();
                    this.callBase(args)
                },
                _updateSelectedIndex: function() {
                    var items = this.widget.option("items");
                    for (var i = 0, itemsCount = items.length; i < itemsCount; i++) {
                        var command = items[i].command;
                        if (command && command.option("highlighted")) {
                            this.widget.option("selectedIndex", i);
                            break
                        }
                    }
                }
            });
        var dxPivotItemWrapper = WidgetItemWrapperBase.inherit({_createWidgetItemCore: function(itemOptions, executeCommandCallback) {
                    itemOptions.title = itemOptions.text;
                    return itemOptions
                }});
        var dxPivotAdapter = WidgetAdapterBase.inherit({
                ctor: function($widgetElement) {
                    this.callBase($widgetElement);
                    this.widget.option("onSelectionChanged", $.proxy(this._onPivotSelectionChange, this))
                },
                _onPivotSelectionChange: function(e) {
                    if (e.addedItems.length && e.removedItems.length && e.addedItems[0] && e.addedItems[0].command)
                        e.addedItems[0].command.execute(e)
                },
                _getWidgetByElement: function($element) {
                    return $element.dxPivot("instance")
                },
                _createItemWrapper: function(command, containerOptions) {
                    return new dxPivotItemWrapper(command, containerOptions)
                },
                addCommand: function(command, containerOptions) {
                    this.callBase(command, containerOptions);
                    this._updateSelectedIndex()
                },
                _onCommandChanged: function(args) {
                    var optionName = args.name,
                        newValue = args.value;
                    if (optionName === "visible")
                        this._rerenderPivot();
                    else if (optionName === "highlighted" && newValue)
                        this._updateSelectedIndex();
                    this.callBase(args)
                },
                _addItemToWidget: function(itemWrapper) {
                    if (itemWrapper.command.option("visible"))
                        this.callBase(itemWrapper)
                },
                _updateSelectedIndex: function() {
                    var pivot = this.widget,
                        items = pivot.option("items") || [];
                    DX.fx.off = true;
                    for (var i = 0, itemsCount = items.length; i < itemsCount; i++) {
                        var command = items[i].command;
                        if (command && command.option("highlighted")) {
                            pivot.option("selectedIndex", i);
                            break
                        }
                    }
                    DX.fx.off = false
                },
                _rerenderPivot: function() {
                    var that = this;
                    that.widget.option("items", []);
                    $.each(that.itemWrappers, function(index, itemWrapper) {
                        if (itemWrapper.command.option("visible"))
                            that._addItemToWidget(itemWrapper)
                    });
                    that.refresh();
                    that._updateSelectedIndex()
                }
            });
        var dxSlideOutItemWrapper = WidgetItemWrapperBase.inherit({});
        var dxSlideOutAdapter = WidgetAdapterBase.inherit({
                ctor: function($widgetElement) {
                    this.callBase($widgetElement);
                    this._commandToWidgetItemOptionNames = {title: "text"};
                    this.widget.option("onItemClick", $.proxy(this._onSlideOutItemClick, this))
                },
                _onSlideOutItemClick: function(e) {
                    e.itemData.command.execute(e)
                },
                _getWidgetByElement: function($element) {
                    return $element.dxSlideOut("instance")
                },
                _createItemWrapper: function(command, containerOptions) {
                    return new dxSlideOutItemWrapper(command, containerOptions)
                },
                _updateSelectedIndex: function() {
                    var items = this.widget.option("items") || [];
                    for (var i = 0, itemsCount = items.length; i < itemsCount; i++) {
                        var command = items[i].command;
                        if (command && command.option("highlighted")) {
                            this.widget.option("selectedIndex", i);
                            break
                        }
                    }
                },
                addCommand: function(command, containerOptions) {
                    this.callBase(command, containerOptions);
                    this._updateSelectedIndex()
                },
                _onCommandChanged: function(args) {
                    var optionName = args.name,
                        newValue = args.value;
                    if (optionName === "highlighted" && newValue)
                        this._updateSelectedIndex();
                    this.callBase(args)
                }
            });
        var adapters = DX.framework.html.commandToDXWidgetAdapters = {};
        adapters.dxToolbar = new CommandToWidgetAdapter(function($widgetElement) {
            return new dxToolbarAdapter($widgetElement)
        });
        adapters.dxList = new CommandToWidgetAdapter(function($widgetElement) {
            return new dxListAdapter($widgetElement)
        });
        adapters.dxNavBar = new CommandToWidgetAdapter(function($widgetElement) {
            return new dxNavBarAdapter($widgetElement)
        });
        adapters.dxPivot = new CommandToWidgetAdapter(function($widgetElement) {
            return new dxPivotAdapter($widgetElement)
        });
        adapters.dxSlideOut = new CommandToWidgetAdapter(function($widgetElement) {
            return new dxSlideOutAdapter($widgetElement)
        });
        DX.framework.html.WidgetItemWrapperBase = WidgetItemWrapperBase;
        DX.framework.html.WidgetAdapterBase = WidgetAdapterBase
    })(jQuery, DevExpress);
    /*! Module framework, file framework.commandManager.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            errors = DevExpress.require("/framework/framework.errors"),
            registerComponent = DX.require("/componentRegistrator");
        var CommandContainer = DX.framework.html.MarkupComponent.inherit({
                ctor: function(element, options) {
                    if ($.isPlainObject(element)) {
                        options = element;
                        element = $("<div />")
                    }
                    this.callBase(element, options)
                },
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({id: null})
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass("dx-command-container")
                }
            });
        registerComponent("dxCommandContainer", DX.framework, CommandContainer);
        DX.framework.html.CommandManager = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this.defaultWidgetAdapter = options.defaultWidgetAdapter || this._getDefaultWidgetAdapter();
                this.commandMapping = options.commandMapping || new DX.framework.CommandMapping
            },
            _getDefaultWidgetAdapter: function() {
                return {
                        addCommand: $.noop,
                        clearContainer: $.noop
                    }
            },
            _getContainerAdapter: function($container) {
                var componentNames = $container.data("dxComponents"),
                    adapters = DX.framework.html.commandToDXWidgetAdapters;
                if (componentNames)
                    for (var index in componentNames) {
                        var widgetName = componentNames[index];
                        if (widgetName in adapters)
                            return adapters[widgetName]
                    }
                return this.defaultWidgetAdapter
            },
            findCommands: function($view) {
                var result = $.map($view.addBack().find(".dx-command"), function(element) {
                        return $(element).dxCommand("instance")
                    });
                return result
            },
            findCommandContainers: function($markup) {
                var result = $.map($markup.find(".dx-command-container"), function(element) {
                        return $(element).dxCommandContainer("instance")
                    });
                return result
            },
            _checkCommandId: function(id, command) {
                if (id === null)
                    throw errors.Error("E3010", command.element().get(0).outerHTML);
            },
            renderCommandsToContainers: function(commands, containers) {
                var that = this,
                    commandHash = {},
                    commandIds = [],
                    deferreds = [];
                $.each(commands, function(i, command) {
                    var id = command.option("id");
                    that._checkCommandId(id, command);
                    commandIds.push(id);
                    commandHash[id] = command
                });
                that.commandMapping.checkCommandsExist(commandIds);
                $.each(containers, function(k, container) {
                    var commandInfos = [];
                    $.each(commandHash, function(id, command) {
                        var commandId = id;
                        var commandOptions = that.commandMapping.getCommandMappingForContainer(commandId, container.option("id"));
                        if (commandOptions)
                            commandInfos.push({
                                command: command,
                                options: commandOptions
                            })
                    });
                    if (commandInfos.length) {
                        var deferred = that._attachCommandsToContainer(container.element(), commandInfos);
                        if (deferred)
                            deferreds.push(deferred)
                    }
                });
                return $.when.apply($, deferreds)
            },
            clearContainer: function(container) {
                var $container = container.element(),
                    adapter = this._getContainerAdapter($container);
                adapter.clearContainer($container)
            },
            _arrangeCommandsToContainers: function(commands, containers) {
                errors.log("W0002", "CommandManager", "_arrangeCommandsToContainers", "14.1", "Use the 'renderCommandsToContainers' method instead.");
                this.renderCommandsToContainers(commands, containers)
            },
            _attachCommandsToContainer: function($container, commandInfos) {
                var adapter = this._getContainerAdapter($container),
                    result;
                if (adapter.beginUpdate)
                    adapter.beginUpdate($container);
                $.each(commandInfos, function(index, commandInfo) {
                    adapter.addCommand($container, commandInfo.command, commandInfo.options)
                });
                if (adapter.endUpdate)
                    result = adapter.endUpdate($container);
                return result
            }
        })
    })(jQuery, DevExpress);
    /*! Module framework, file framework.layoutController.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            EventsMixin = DX.require("/eventsMixin"),
            errors = DevExpress.require("/framework/framework.errors"),
            commonUtils = DX.require("/utils/utils.common"),
            domUtils = DX.require("/utils/utils.dom"),
            HIDDEN_BAG_ID = "__hidden-bag",
            TRANSITION_SELECTOR = ".dx-transition:not(.dx-transition .dx-transition)",
            CONTENT_SELECTOR = ".dx-content",
            DEFAULT_COMMAND_RENDER_STAGE = "onViewShown",
            CONTENT_RENDERED_EVENT_NAME = "dxcontentrendered.layoutController",
            PENDING_RENDERING_SELECTOR = ".dx-pending-rendering",
            PENDING_RENDERING_MANUAL_SELECTOR = ".dx-pending-rendering-manual";
        var transitionSelector = function(transitionName) {
                return ".dx-transition-" + transitionName
            };
        DX.framework.html.DefaultLayoutController = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this.name = options.name || "";
                this._layoutModel = options.layoutModel || {};
                this._defaultPaneName = options.defaultPaneName || "content";
                this._transitionDuration = options.transitionDuration === undefined ? 400 : options.transitionDuration
            },
            init: function(options) {
                options = options || {};
                this._visibleViews = {};
                this._$viewPort = options.$viewPort || $("body");
                this._commandManager = options.commandManager;
                this._viewEngine = options.viewEngine;
                this.transitionExecutor = new DX.TransitionExecutor;
                this._prepareTemplates();
                this._$viewPort.append(this.element());
                this._hideElements(this.element());
                if (options.templateContext) {
                    this._templateContext = options.templateContext;
                    this._proxiedTemplateContextChangedHandler = $.proxy(this._templateContextChangedHandler, this)
                }
            },
            activate: function() {
                if (this._disabledState) {
                    this._disabledState = false;
                    this._notifyShowing();
                    return $.Deferred().resolve().promise()
                }
                var $rootElement = this.element();
                this._showElements($rootElement);
                this._attachRefreshViewRequiredHandler();
                return $.Deferred().resolve().promise()
            },
            deactivate: function() {
                this._disabledState = false;
                this._releaseVisibleViews();
                this._hideElements(this.element());
                this._detachRefreshViewRequiredHandler();
                return $.Deferred().resolve().promise()
            },
            disable: function() {
                this._disabledState = true;
                this._notifyHidden()
            },
            activeViewInfo: function() {
                return this._visibleViews[this._defaultPaneName]
            },
            _notifyShowing: function() {
                var that = this;
                $.each(this._visibleViews, function(index, viewInfo) {
                    that.fireEvent("viewShowing", [viewInfo])
                })
            },
            _notifyHidden: function() {
                var that = this;
                $.each(this._visibleViews, function(index, viewInfo) {
                    that.fireEvent("viewHidden", [viewInfo])
                })
            },
            _applyTemplate: function($elements, model) {
                $elements.each(function(i, element) {
                    DX.framework.templateProvider.applyTemplate(element, model)
                })
            },
            _releaseVisibleViews: function() {
                var that = this;
                $.each(this._visibleViews, function(index, viewInfo) {
                    that._hideView(viewInfo);
                    that._releaseView(viewInfo)
                });
                this._visibleViews = {}
            },
            _templateContextChangedHandler: function() {
                $.each(this._visibleViews, $.proxy(function(index, viewInfo) {
                    this.showView(viewInfo)
                }, this))
            },
            _attachRefreshViewRequiredHandler: function() {
                if (this._templateContext)
                    this._templateContext.on("optionChanged", this._proxiedTemplateContextChangedHandler)
            },
            _detachRefreshViewRequiredHandler: function() {
                if (this._templateContextChanged)
                    this._templateContext.off("optionChanged", this._proxiedTemplateContextChangedHandler)
            },
            _getPreviousViewInfo: function(viewInfo) {
                return this._visibleViews[this._getViewPaneName(viewInfo.viewTemplateInfo)]
            },
            _prepareTemplates: function() {
                var that = this;
                var $layoutTemplate = that._viewEngine.getLayoutTemplate(this._getLayoutTemplateName());
                that._$layoutTemplate = $layoutTemplate;
                that._$mainLayout = that._createEmptyLayout();
                that._showElements(that._$mainLayout);
                that._applyTemplate(that._$mainLayout, that._layoutModel);
                that._$navigationWidget = that._createNavigationWidget()
            },
            renderNavigation: function(navigationCommands) {
                this._clearNavigationWidget();
                this._renderNavigationImpl(navigationCommands)
            },
            _renderNavigationImpl: function(navigationCommands) {
                this._renderCommands(this._$mainLayout, navigationCommands)
            },
            _createNavigationWidget: function() {
                var containers = this._findCommandContainers(this._$mainLayout),
                    result;
                $.each(containers, function(k, container) {
                    if (container.option("id") === "global-navigation") {
                        result = container.element();
                        return false
                    }
                });
                return result
            },
            _clearNavigationWidget: function() {
                if (this._$navigationWidget)
                    this._commandManager.clearContainer(this._$navigationWidget.dxCommandContainer("instance"))
            },
            element: function() {
                return this._$mainLayout
            },
            _getViewFrame: function(viewInfo) {
                return this._$mainLayout
            },
            _getLayoutTemplateName: function() {
                return this.name
            },
            _applyModelToTransitionElements: function($markup, model) {
                var that = this;
                this._getTransitionElements($markup).each(function(i, item) {
                    that._applyTemplate($(item).children(), model)
                })
            },
            _createViewLayoutTemplate: function() {
                var that = this;
                var $viewLayoutTemplate = that._$layoutTemplate.clone();
                this._hideElements($viewLayoutTemplate);
                return $viewLayoutTemplate
            },
            _createEmptyLayout: function() {
                var that = this;
                var $result = that._$layoutTemplate.clone();
                this._hideElements($result);
                this._getTransitionElements($result).empty();
                $result.children(CONTENT_SELECTOR).remove();
                return $result
            },
            _getTransitionElements: function($markup) {
                return $markup.find(TRANSITION_SELECTOR).addBack(TRANSITION_SELECTOR)
            },
            showView: function(viewInfo, direction) {
                direction = direction || "forward";
                var that = this,
                    previousViewInfo = that._getPreviousViewInfo(viewInfo),
                    previousViewTemplateId = previousViewInfo === viewInfo ? previousViewInfo.currentViewTemplateId : undefined;
                this._defineCurrentViewTemplateId(viewInfo);
                if (previousViewTemplateId && previousViewTemplateId === viewInfo.currentViewTemplateId && viewInfo === previousViewInfo)
                    return $.Deferred().resolve().promise();
                that._ensureViewRendered(viewInfo);
                that.fireEvent("viewShowing", [viewInfo, direction]);
                return this._showViewImpl(viewInfo, direction, previousViewTemplateId).done(function() {
                        that._onViewShown(viewInfo)
                    })
            },
            disposeView: function(viewInfo) {
                this._clearRenderResult(viewInfo)
            },
            _clearRenderResult: function(viewInfo) {
                if (viewInfo.renderResult) {
                    viewInfo.renderResult.$markup.remove();
                    viewInfo.renderResult.$viewItems.remove();
                    delete viewInfo.renderResult
                }
            },
            _prepareViewTemplate: function($viewTemplate, viewInfo){},
            _renderViewImpl: function($viewTemplate, viewInfo) {
                var that = this,
                    allowedChildrenSelector = ".dx-command,.dx-content,script",
                    $layout = this._createViewLayoutTemplate(),
                    $viewItems,
                    isSimplifiedMarkup = true,
                    outOfContentItems = $();
                if ($viewTemplate.children(allowedChildrenSelector).length === 0)
                    this._viewEngine._wrapViewDefaultContent($viewTemplate);
                $viewItems = $viewTemplate.children();
                this._applyModelToTransitionElements($layout, viewInfo.model);
                this._viewEngine.applyLayout($viewTemplate, $layout);
                $viewItems.each(function(i, item) {
                    var $item = $(item);
                    that._applyTemplate($item, viewInfo.model);
                    if ($item.is(allowedChildrenSelector))
                        isSimplifiedMarkup = false;
                    else
                        outOfContentItems = outOfContentItems.add($item)
                });
                if (outOfContentItems.length && !isSimplifiedMarkup)
                    throw errors.Error("E3014", outOfContentItems[0].outerHTML);
                viewInfo.renderResult = viewInfo.renderResult || {};
                viewInfo.renderResult.$viewItems = $viewItems;
                viewInfo.renderResult.$markup = $layout
            },
            _renderCommands: function($markup, commands) {
                var commandContainers = this._findCommandContainers($markup);
                return this._commandManager.renderCommandsToContainers(commands, commandContainers)
            },
            _prepareViewCommands: function(viewInfo) {
                var $viewItems = viewInfo.renderResult.$viewItems,
                    viewCommands = this._commandManager.findCommands($viewItems),
                    commandsToRenderMap = {};
                viewInfo.commands = DX.framework.utils.mergeCommands(viewInfo.commands || [], viewCommands);
                viewInfo.commandsToRenderMap = commandsToRenderMap;
                $.each(viewInfo.commands, function(index, command) {
                    var renderStage = command.option("renderStage") || DEFAULT_COMMAND_RENDER_STAGE,
                        targetArray = commandsToRenderMap[renderStage] = commandsToRenderMap[renderStage] || [];
                    targetArray.push(command)
                })
            },
            _applyViewCommands: function(viewInfo, renderStage) {
                renderStage = renderStage || DEFAULT_COMMAND_RENDER_STAGE;
                var commandsToRender = viewInfo.commandsToRenderMap[renderStage],
                    $markup = viewInfo.renderResult.$markup,
                    result;
                if (commandsToRender) {
                    result = this._renderCommands($markup, commandsToRender);
                    delete viewInfo.commandsToRenderMap[renderStage]
                }
                else
                    result = $.Deferred().resolve().promise();
                return result
            },
            _findCommandContainers: function($markup) {
                return domUtils.createComponents($markup, ["dxCommandContainer"])
            },
            _defineCurrentViewTemplateId: function(viewInfo) {
                var viewTemplateInstance = viewInfo.$viewTemplate ? viewInfo.$viewTemplate.dxView("instance") : this._viewEngine.getViewTemplateInfo(viewInfo.viewName),
                    currentViewTemplateId = viewTemplateInstance.getId();
                viewInfo.currentViewTemplateId = currentViewTemplateId
            },
            _ensureViewRendered: function(viewInfo) {
                var $cachedMarkup = viewInfo.renderResult && viewInfo.renderResult.markupCache[viewInfo.currentViewTemplateId];
                if ($cachedMarkup)
                    viewInfo.renderResult.$markup = $cachedMarkup;
                else {
                    this._renderView(viewInfo);
                    viewInfo.renderResult.markupCache = viewInfo.renderResult.markupCache || {};
                    viewInfo.renderResult.markupCache[viewInfo.currentViewTemplateId] = viewInfo.renderResult.$markup
                }
            },
            _renderView: function(viewInfo) {
                var $viewTemplate = viewInfo.$viewTemplate || this._viewEngine.getViewTemplate(viewInfo.viewName);
                this._prepareViewTemplate($viewTemplate, viewInfo);
                this._renderViewImpl($viewTemplate, viewInfo);
                this._prepareViewCommands(viewInfo);
                this._applyViewCommands(viewInfo, "onViewRendering");
                this._appendViewToLayout(viewInfo);
                $viewTemplate.remove();
                this._onRenderComplete(viewInfo);
                this.fireEvent("viewRendered", [viewInfo])
            },
            _appendViewToLayout: function(viewInfo) {
                var that = this,
                    $viewFrame = that._getViewFrame(viewInfo),
                    $markup = viewInfo.renderResult.$markup,
                    $transitionContentElements = $(),
                    animationItems = [];
                $.each($markup.find(".dx-content-placeholder"), function(index, el) {
                    DX.framework.prepareTransition($(el), $(el).attr("data-dx-content-placeholder-name"))
                });
                $.each(that._getTransitionElements($viewFrame), function(index, transitionElement) {
                    var $transition = $(transitionElement),
                        $viewElement = $markup.find(transitionSelector($transition.attr("data-dx-transition-name"))).children(),
                        animationItem = {
                            $element: $viewElement,
                            animation: $transition.attr("data-dx-transition-type")
                        };
                    animationItems.push(animationItem);
                    $transition.append($viewElement);
                    that._showViewElements($viewElement);
                    domUtils.triggerShownEvent($viewElement);
                    $transitionContentElements = $transitionContentElements.add($viewElement)
                });
                that._$mainLayout.append(viewInfo.renderResult.$viewItems.filter(".dx-command"));
                $markup.remove();
                viewInfo.renderResult.$markup = $transitionContentElements;
                viewInfo.renderResult.animationItems = animationItems
            },
            _onRenderComplete: function(viewInfo){},
            _onViewShown: function(viewInfo) {
                $(document).trigger("dx.viewchanged")
            },
            _enter: function(animationItems, animationModifier) {
                var transitionExecutor = this.transitionExecutor;
                $.each(animationItems, function(index, item) {
                    transitionExecutor.enter(item.$element, item.animation, animationModifier)
                })
            },
            _leave: function(animationItems, animationModifier) {
                var transitionExecutor = this.transitionExecutor;
                $.each(animationItems, function(index, item) {
                    transitionExecutor.leave(item.$element, item.animation, animationModifier)
                })
            },
            _doTransition: function(oldViewInfo, newViewInfo, animationModifier) {
                if (oldViewInfo)
                    this._leave(oldViewInfo.renderResult.animationItems, animationModifier);
                this._enter(newViewInfo.renderResult.animationItems, animationModifier);
                this._showView(newViewInfo);
                return this.transitionExecutor.start()
            },
            _showViewImpl: function(viewInfo, direction, previousViewTemplateId) {
                var that = this,
                    result,
                    previousViewInfo = this._getPreviousViewInfo(viewInfo),
                    animationModifier = {direction: direction};
                if (previousViewInfo === viewInfo)
                    previousViewInfo = undefined;
                if (!previousViewInfo)
                    animationModifier.duration = 0;
                result = that._doTransition(previousViewInfo, viewInfo, animationModifier).then(function() {
                    return that._changeView(viewInfo, previousViewTemplateId)
                });
                return result
            },
            _releaseView: function(viewInfo) {
                this.fireEvent("viewReleased", [viewInfo])
            },
            _getReadyForRenderDeferredItems: function(viewInfo) {
                return $.Deferred().resolve().promise()
            },
            _changeView: function(viewInfo, previousViewTemplateId) {
                var that = this;
                if (previousViewTemplateId)
                    that._hideView(viewInfo, previousViewTemplateId);
                else {
                    var previousViewInfo = that._getPreviousViewInfo(viewInfo);
                    if (previousViewInfo && previousViewInfo !== viewInfo) {
                        that._hideView(previousViewInfo);
                        that._releaseView(previousViewInfo)
                    }
                    this._visibleViews[this._getViewPaneName(viewInfo.viewTemplateInfo)] = viewInfo
                }
                this._subscribeToDeferredItems(viewInfo);
                return this._getReadyForRenderDeferredItems(viewInfo).then(function() {
                        return that._applyViewCommands(viewInfo)
                    }).then(function() {
                        return that._renderDeferredItems(viewInfo.renderResult.$markup)
                    })
            },
            _subscribeToDeferredItems: function(viewInfo) {
                var that = this,
                    $markup = viewInfo.renderResult.$markup;
                $markup.find(PENDING_RENDERING_SELECTOR).add($markup.filter(PENDING_RENDERING_SELECTOR)).each(function() {
                    var eventData = {
                            viewInfo: viewInfo,
                            context: that
                        };
                    $(this).on(CONTENT_RENDERED_EVENT_NAME, eventData, that._onDeferredContentRendered)
                })
            },
            _onDeferredContentRendered: function(event) {
                var $element = $(event.target),
                    viewInfo = event.data.viewInfo,
                    that = event.data.context;
                $element.off(CONTENT_RENDERED_EVENT_NAME, that._onDeferredContentRendered);
                that._renderCommands($element, viewInfo.commands)
            },
            _renderDeferredItems: function($items) {
                var that = this,
                    result = $.Deferred();
                var $pendingItem = $items.find(PENDING_RENDERING_MANUAL_SELECTOR).add($items.filter(PENDING_RENDERING_MANUAL_SELECTOR)).first();
                if ($pendingItem.length) {
                    var render = $pendingItem.data("dx-render-delegate");
                    commonUtils.executeAsync(function() {
                        render().then(function() {
                            return that._renderDeferredItems($items)
                        }).then(function() {
                            result.resolve()
                        })
                    })
                }
                else
                    result.resolve();
                return result.promise()
            },
            _getViewPaneName: function(viewTemplateInfo) {
                return this._defaultPaneName
            },
            _hideElements: function($elements) {
                $elements.addClass("dx-fast-hidden")
            },
            _showElements: function($elements) {
                $elements.removeClass("dx-fast-hidden")
            },
            _hideViewElements: function($elements) {
                this._patchIDs($elements);
                this._disableInputs($elements);
                $elements.removeClass("dx-active-view").addClass("dx-inactive-view")
            },
            _hideView: function(viewInfo, templateId) {
                if (viewInfo.renderResult) {
                    var $markupToHide = templateId === undefined ? viewInfo.renderResult.$markup : viewInfo.renderResult.markupCache[templateId];
                    this._hideViewElements($markupToHide);
                    this.fireEvent("viewHidden", [viewInfo])
                }
            },
            _showViewElements: function($elements) {
                this._unpatchIDs($elements);
                this._enableInputs($elements);
                $elements.removeClass("dx-inactive-view").addClass("dx-active-view");
                this._skipAnimation($elements)
            },
            _showView: function(viewInfo) {
                if (viewInfo.renderResult)
                    this._showViewElements(viewInfo.renderResult.$markup)
            },
            _skipAnimation: function($elements) {
                $elements.addClass("dx-skip-animation");
                for (var i = 0; i < $elements.length; i++)
                    $elements.eq(i).css("transform");
                $elements.removeClass("dx-skip-animation")
            },
            _patchIDs: function($markup) {
                this._processIDs($markup, function(id) {
                    var result = id;
                    if (id.indexOf(HIDDEN_BAG_ID) === -1)
                        result = HIDDEN_BAG_ID + "-" + id;
                    return result
                })
            },
            _unpatchIDs: function($markup) {
                this._processIDs($markup, function(id) {
                    var result = id;
                    if (id.indexOf(HIDDEN_BAG_ID) === 0)
                        result = id.substr(HIDDEN_BAG_ID.length + 1);
                    return result
                })
            },
            _processIDs: function($markup, process) {
                var elementsWithIds = $markup.find("[id]");
                $.each(elementsWithIds, function(index, element) {
                    var $el = $(element),
                        id = $el.attr("id");
                    $el.attr("id", process(id))
                })
            },
            _enableInputs: function($markup) {
                var $inputs = $markup.find(":input[data-disabled=true]");
                $.each($inputs, function(index, input) {
                    $(input).removeAttr("disabled").removeAttr("data-disabled")
                })
            },
            _disableInputs: function($markup) {
                var $inputs = $markup.find(":input:not([disabled], [disabled=true])");
                $.each($inputs, function(index, input) {
                    $(input).attr({
                        disabled: true,
                        "data-disabled": true
                    })
                })
            }
        }).include(EventsMixin);
        var layoutSets = DX.framework.html.layoutSets;
        layoutSets["default"] = layoutSets["default"] || [];
        layoutSets["default"].push({controller: new DX.framework.html.DefaultLayoutController})
    })(jQuery, DevExpress);
    /*! Module framework, file framework.viewEngine.js */
    (function($, DX, undefined) {
        var Class = DevExpress.require("/class"),
            errors = DevExpress.require("/framework/framework.errors"),
            domUtils = DX.require("/utils/utils.dom"),
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            framework = DX.framework,
            MarkupComponent = DX.framework.html.MarkupComponent,
            MARKUP_TEMPLATE_MARKER = "MarkupTemplate:",
            _VIEW_ROLE = "dxView",
            _LAYOUT_ROLE = "dxLayout";
        registerComponent(_VIEW_ROLE, framework, MarkupComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    name: null,
                    title: null
                })
            },
            ctor: function() {
                this._id = domUtils.uniqueId();
                this.callBase.apply(this, arguments)
            },
            _render: function() {
                this.callBase();
                this.element().addClass("dx-view");
                this.element().attr("dx-data-template-id", this._id)
            },
            getId: function() {
                return this._id
            }
        }), framework);
        registerComponent(_LAYOUT_ROLE, framework, MarkupComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({name: null})
            },
            _render: function() {
                this.callBase();
                this.element().addClass("dx-layout")
            }
        }));
        registerComponent("dxViewPlaceholder", framework, MarkupComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({viewName: null})
            },
            _render: function() {
                this.callBase();
                this.element().addClass("dx-view-placeholder")
            }
        }));
        var setupTransitionElement = function($element, transitionType, transitionName, contentCssPosition) {
                if (contentCssPosition === "absolute")
                    $element.addClass("dx-transition-absolute");
                else
                    $element.addClass("dx-transition-static");
                $element.addClass("dx-transition").addClass("dx-transition-" + transitionName).addClass("dx-transition-" + transitionType).attr("data-dx-transition-type", transitionType).attr("data-dx-transition-name", transitionName)
            };
        var setupTransitionInnerElement = function($element) {
                $element.addClass("dx-transition-inner-wrapper")
            };
        registerComponent("dxTransition", framework, MarkupComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    name: null,
                    type: undefined,
                    animation: "slide"
                })
            },
            _render: function() {
                this.callBase();
                var element = this.element();
                setupTransitionElement(element, this.option("type") || this.option("animation"), this.option("name"), "absolute");
                element.wrapInner("<div/>");
                setupTransitionInnerElement(element.children());
                if (this.option("type"))
                    errors.log("W0003", "dxTransition", "type", "15.1", "Use the 'animation' property instead")
            },
            _clean: function() {
                this.callBase();
                this.element().empty()
            }
        }));
        DX.framework.prepareTransition = function($element, targetPlaceholderName) {
            if ($element.children(".dx-content").length === 0) {
                $element.wrapInner("<div>");
                $element.children().dxContent({targetPlaceholder: targetPlaceholderName})
            }
        };
        registerComponent("dxContentPlaceholder", framework, MarkupComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    name: null,
                    transition: undefined,
                    animation: "none",
                    contentCssPosition: "absolute"
                })
            },
            _render: function() {
                this.callBase();
                var $element = this.element();
                $element.addClass("dx-content-placeholder").addClass("dx-content-placeholder-" + this.option("name"));
                $element.attr("data-dx-content-placeholder-name", this.option("name"));
                setupTransitionElement($element, this.option("transition") || this.option("animation"), this.option("name"), this.option("contentCssPosition"));
                if (this.option("transition"))
                    errors.log("W0003", "dxContentPlaceholder", "transition", "15.1", "Use the 'animation' property instead")
            },
            prepareTransition: function() {
                DX.framework.prepareTransition(this.element(), this.option("name"))
            }
        }));
        registerComponent("dxContent", framework, MarkupComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({targetPlaceholder: null})
            },
            _optionChanged: function() {
                this._refresh()
            },
            _clean: function() {
                this.callBase();
                this.element().removeClass(this._currentClass)
            },
            _render: function() {
                this.callBase();
                var element = this.element();
                element.addClass("dx-content");
                this._currentClass = "dx-content-" + this.option("targetPlaceholder");
                element.attr("data-dx-target-placeholder-id", this.option("targetPlaceholder"));
                element.addClass(this._currentClass);
                setupTransitionInnerElement(element)
            }
        }));
        framework.html.ViewEngine = Class.inherit({
            ctor: function(options) {
                options = options || {};
                this.$root = options.$root;
                this.device = options.device || {};
                this.dataOptionsAttributeName = options.dataOptionsAttributeName || "data-options";
                this._templateMap = {};
                this._pendingViewContainer = null;
                this.markupLoaded = $.Callbacks();
                this._templateContext = options.templateContext;
                this._$skippedMarkup = $();
                if (options.templatesVersion !== undefined && options.templateCacheStorage) {
                    this._templateCacheEnabled = true;
                    this._templatesVersion = "v_" + options.templatesVersion;
                    this._templateCacheStorage = options.templateCacheStorage;
                    this._templateCacheKey = "dxTemplateCache_" + DevExpress.VERSION + "_" + JSON.stringify(this.device)
                }
            },
            _enumerateTemplates: function(processFn) {
                var that = this;
                $.each(that._templateMap, function(name, templatesByRoleMap) {
                    $.each(templatesByRoleMap, function(role, templates) {
                        $.each(templates, function(index, template) {
                            processFn(template)
                        })
                    })
                })
            },
            _findComponent: function(name, role) {
                var components = (this._templateMap[name] || {})[role] || [],
                    filter = this._templateContext && this._templateContext.option() || {};
                components = this._filterTemplates(filter, components);
                this._checkMatchedTemplates(components);
                return components[0]
            },
            _findTemplate: function(name, role) {
                var component = this._findComponent(name, role);
                if (!component)
                    throw errors.Error("E3013", role, name);
                var $template = component.element(),
                    $result;
                if (!component._isStaticComponentsCreated) {
                    domUtils.createComponents($template, ["dxContent", "dxContentPlaceholder", "dxTransition"]);
                    component._isStaticComponentsCreated = true
                }
                $result = $template.clone().removeClass("dx-hidden");
                return $result
            },
            _loadTemplatesFromMarkupCore: function($markup) {
                var that = this;
                if ($markup.find("[data-dx-role]").length)
                    throw errors.Error("E3019");
                that.markupLoaded.fire({markup: $markup});
                var components = domUtils.createComponents($markup, [_VIEW_ROLE, _LAYOUT_ROLE]);
                $.each(components, function(index, component) {
                    var $element = component.element();
                    $element.addClass("dx-hidden");
                    that._registerTemplateComponent(component);
                    component.element().detach()
                });
                var $skipped = $markup.filter("script");
                $skipped.appendTo(that.$root);
                that._$skippedMarkup = that._$skippedMarkup.add($skipped)
            },
            _registerTemplateComponent: function(component) {
                var role = component.NAME,
                    options = component.option(),
                    templateName = options.name,
                    componentsByRoleMap = this._templateMap[templateName] || {};
                componentsByRoleMap[role] = componentsByRoleMap[role] || [];
                componentsByRoleMap[role].push(component);
                this._templateMap[templateName] = componentsByRoleMap
            },
            _applyPartialViews: function($render) {
                var that = this;
                domUtils.createComponents($render, ["dxViewPlaceholder"]);
                $.each($render.find(".dx-view-placeholder"), function() {
                    var $partialPlaceholder = $(this);
                    if ($partialPlaceholder.children().length)
                        return;
                    var viewName = $partialPlaceholder.data("dxViewPlaceholder").option("viewName"),
                        $view = that._findTemplate(viewName, _VIEW_ROLE);
                    that._applyPartialViews($view);
                    $partialPlaceholder.append($view);
                    $view.removeClass("dx-hidden")
                })
            },
            _ajaxImpl: function() {
                return $.ajax.apply($, arguments)
            },
            _loadTemplatesFromURL: function(url) {
                var that = this,
                    options = this._getLoadOptions(),
                    deferred = $.Deferred();
                url = options.winPhonePrefix + url;
                this._ajaxImpl({
                    url: url,
                    isLocal: options.isLocal,
                    dataType: "html"
                }).done(function(data) {
                    that._loadTemplatesFromMarkupCore(domUtils.createMarkupFromString(data));
                    deferred.resolve()
                }).fail(function(jqXHR, textStatus, errorThrown) {
                    var error = errors.Error("E3021", url, errorThrown);
                    deferred.reject(error)
                });
                return deferred.promise()
            },
            _getLoadOptions: function() {
                if (location.protocol.indexOf("wmapp") >= 0)
                    return {
                            winPhonePrefix: location.protocol + "www/",
                            isLocal: true
                        };
                return {
                        winPhonePrefix: "",
                        isLocal: undefined
                    }
            },
            _loadExternalTemplates: function() {
                var tasks = [],
                    that = this;
                $("head").find("link[rel='dx-template']").each(function(index, link) {
                    var task = that._loadTemplatesFromURL($(link).attr("href"));
                    tasks.push(task)
                });
                return $.when.apply($, tasks)
            },
            _processTemplates: function() {
                var that = this;
                $.each(that._templateMap, function(name, templatesByRoleMap) {
                    $.each(templatesByRoleMap, function(role, templates) {
                        that._filterTemplatesByDevice(templates)
                    })
                });
                that._enumerateTemplates(function(template) {
                    that._applyPartialViews(template.element())
                })
            },
            _filterTemplatesByDevice: function(components) {
                var filteredComponents = this._filterTemplates(this.device, components);
                $.each(components, function(index, component) {
                    if ($.inArray(component, filteredComponents) < 0)
                        component.element().remove()
                });
                components.length = 0;
                components.push.apply(components, filteredComponents)
            },
            _filterTemplates: function(filter, components) {
                return commonUtils.findBestMatches(filter, components, function(component) {
                        return component.option()
                    })
            },
            _checkMatchedTemplates: function(bestMatches) {
                if (bestMatches.length > 1) {
                    var message = "";
                    $.each(bestMatches, function(index, match) {
                        message += match.element().attr("data-options") + "\r\n"
                    });
                    throw errors.Error("E3020", message, JSON.stringify(this.device));
                }
            },
            _wrapViewDefaultContent: function($viewTemplate) {
                $viewTemplate.wrapInner("<div class=\"dx-full-height\"></div>");
                $viewTemplate.children().eq(0).dxContent({targetPlaceholder: 'content'})
            },
            _initDefaultLayout: function() {
                this._$defaultLayoutTemplate = $("<div class=\"dx-full-height\" data-options=\"dxLayout : { name: 'default' } \"> \n" + "    <div class=\"dx-full-height\" data-options=\"dxContentPlaceholder : { name: 'content' } \" ></div> \n" + "</div>");
                domUtils.createComponents(this._$defaultLayoutTemplate)
            },
            _getDefaultLayoutTemplate: function() {
                return this._$defaultLayoutTemplate.clone()
            },
            applyLayout: function($view, $layout) {
                if ($layout === undefined || $layout.length === 0)
                    $layout = this._getDefaultLayoutTemplate();
                if ($view.children(".dx-content").length === 0)
                    this._wrapViewDefaultContent($view);
                var $toMerge = $().add($layout).add($view);
                var $placeholderContents = $toMerge.find(".dx-content");
                $.each($placeholderContents, function() {
                    var $placeholderContent = $(this);
                    var placeholderId = $placeholderContent.attr("data-dx-target-placeholder-id");
                    var $placeholder = $toMerge.find(".dx-content-placeholder-" + placeholderId);
                    $placeholder.empty();
                    $placeholder.append($placeholderContent)
                });
                $placeholderContents.filter(":not(.dx-content-placeholder .dx-content)").remove();
                return $layout
            },
            _loadTemplatesFromCache: function() {
                if (!this._templateCacheEnabled)
                    return;
                var cache;
                var fromJSONInterceptor = function(key, value) {
                        if (typeof value === "string" && value.indexOf(MARKUP_TEMPLATE_MARKER) === 0) {
                            var data = JSON.parse(value.substr(MARKUP_TEMPLATE_MARKER.length)),
                                type = data.type,
                                options = data.options,
                                $markup = $(data.markup);
                            options.fromCache = true;
                            return $markup[type](options)[type]("instance")
                        }
                        else if (key === "skippedMarkup")
                            return $("<div>").append($(value)).contents();
                        return value
                    };
                var toParse = this._templateCacheStorage.getItem(this._templateCacheKey);
                if (toParse)
                    try {
                        var cacheContainer = JSON.parse(toParse, fromJSONInterceptor);
                        cache = cacheContainer[this._templatesVersion]
                    }
                    catch(e) {
                        this._templateCacheStorage.removeItem(this._templateCacheKey)
                    }
                if (!cache)
                    return;
                this._templateMap = cache.templates;
                this.$root.append(cache.skippedMarkup);
                return true
            },
            _putTemplatesToCache: function() {
                if (!this._templateCacheEnabled)
                    return;
                var toJSONInterceptor = function(key, value) {
                        if (value && value.element)
                            return MARKUP_TEMPLATE_MARKER + JSON.stringify({
                                    markup: value.element().prop("outerHTML"),
                                    options: value.option(),
                                    type: value.NAME
                                });
                        else if (key === "skippedMarkup")
                            return $("<div>").append(value.clone()).html();
                        return value
                    };
                var cacheContainer = {};
                cacheContainer[this._templatesVersion] = {
                    templates: this._templateMap,
                    skippedMarkup: this._$skippedMarkup
                };
                this._templateCacheStorage.setItem(this._templateCacheKey, JSON.stringify(cacheContainer, toJSONInterceptor, 4))
            },
            init: function() {
                var that = this;
                this._initDefaultLayout();
                if (!this._loadTemplatesFromCache()) {
                    that._loadTemplatesFromMarkupCore(that.$root.children());
                    return this._loadExternalTemplates().done(function() {
                            that._processTemplates();
                            that._putTemplatesToCache()
                        })
                }
                else
                    return $.Deferred().resolve().promise()
            },
            getViewTemplate: function(viewName) {
                return this._findTemplate(viewName, _VIEW_ROLE)
            },
            getViewTemplateInfo: function(name) {
                return this._findComponent(name, _VIEW_ROLE)
            },
            getLayoutTemplate: function(layoutName) {
                if (!layoutName)
                    return this._getDefaultLayoutTemplate();
                return this._findTemplate(layoutName, _LAYOUT_ROLE)
            },
            getLayoutTemplateInfo: function(name) {
                return this._findComponent(name, _LAYOUT_ROLE)
            },
            loadTemplates: function(source) {
                var result;
                if (typeof source === "string")
                    result = this._loadTemplatesFromURL(source);
                else {
                    this._loadTemplatesFromMarkupCore(source);
                    result = $.Deferred().resolve().promise()
                }
                return result.done($.proxy(this._processTemplates, this))
            }
        })
    })(jQuery, DevExpress);
    /*! Module framework, file framework.htmlApplication.js */
    (function($, DX, undefined) {
        var Component = DX.require("/component"),
            errors = DX.require("/framework/framework.errors"),
            viewPort = DX.require("/utils/utils.viewPort").value,
            objectUtils = DX.require("/utils/utils.object"),
            domUtils = DX.require("/utils/utils.dom"),
            commonUtils = DX.require("/utils/utils.common"),
            devices = DX.require("/devices"),
            feedbackEvents = DX.require("/ui/events/ui.events.emitter.feedback"),
            frameworkNS = DX.framework,
            htmlNS = frameworkNS.html;
        var VIEW_PORT_CLASSNAME = "dx-viewport",
            LAYOUT_CHANGE_ANIMATION_NAME = "layout-change";
        htmlNS.HtmlApplication = frameworkNS.Application.inherit({
            ctor: function(options) {
                options = options || {};
                this.callBase(options);
                this._$root = $(options.rootNode || document.body);
                this._initViewport(options.viewPort);
                if (this._applicationMode === "mobileApp")
                    domUtils.initMobileViewport(options.viewPort);
                this.device = options.device || devices.current();
                this.commandManager = options.commandManager || new DX.framework.html.CommandManager({commandMapping: this.commandMapping});
                this._initTemplateContext();
                this.viewEngine = options.viewEngine || new htmlNS.ViewEngine({
                    $root: this._$root,
                    device: this.device,
                    templateCacheStorage: options.templateCacheStorage || window.localStorage,
                    templatesVersion: options.templatesVersion,
                    templateContext: this._templateContext
                });
                this.components.push(this.viewEngine);
                this._initMarkupFilters(this.viewEngine);
                this._layoutSet = options.layoutSet || DX.framework.html.layoutSets["default"];
                this._animationSet = options.animationSet || DX.framework.html.animationSets["default"];
                this._availableLayoutControllers = [];
                this._activeLayoutControllersStack = [];
                this.transitionExecutor = new DX.TransitionExecutor;
                this._initAnimations(this._animationSet)
            },
            _initAnimations: function(animationSet) {
                if (!animationSet)
                    return;
                $.each(animationSet, function(name, configs) {
                    $.each(configs, function(index, config) {
                        DX.animationPresets.registerPreset(name, config)
                    })
                });
                DX.animationPresets.applyChanges()
            },
            _localizeMarkup: function($markup) {
                DX.localization.localizeNode($markup)
            },
            _notifyIfBadMarkup: function($markup) {
                $markup.each(function() {
                    var html = $(this).html();
                    if (/href="#/.test(html))
                        errors.log("W3005", html)
                })
            },
            _initMarkupFilters: function(viewEngine) {
                var filters = [];
                filters.push(this._localizeMarkup);
                if (this._applicationMode === "mobileApp")
                    filters.push(this._notifyIfBadMarkup);
                if (viewEngine.markupLoaded)
                    viewEngine.markupLoaded.add(function(args) {
                        $.each(filters, function(_, filter) {
                            filter(args.markup)
                        })
                    })
            },
            _createViewCache: function(options) {
                var result = this.callBase(options);
                if (!options.viewCache)
                    result = new DX.framework.ConditionalViewCacheDecorator({
                        filter: function(key, viewInfo) {
                            return !viewInfo.viewTemplateInfo.disableCache
                        },
                        viewCache: result
                    });
                return result
            },
            _initViewport: function() {
                this._$viewPort = this._getViewPort();
                viewPort(this._$viewPort)
            },
            _getViewPort: function() {
                var $viewPort = $("." + VIEW_PORT_CLASSNAME);
                if (!$viewPort.length)
                    $viewPort = $("<div>").addClass(VIEW_PORT_CLASSNAME).appendTo(this._$root);
                return $viewPort
            },
            _initTemplateContext: function() {
                this._templateContext = new Component({orientation: devices.orientation()});
                devices.on("orientationChanged", $.proxy(function(args) {
                    this._templateContext.option("orientation", args.orientation)
                }, this))
            },
            _showViewImpl: function(viewInfo, direction) {
                var that = this,
                    deferred = $.Deferred(),
                    result = deferred.promise(),
                    layoutController = viewInfo.layoutController;
                that._obtainViewLink(viewInfo);
                layoutController.showView(viewInfo, direction).done(function() {
                    that._activateLayoutController(layoutController, that._getTargetNode(viewInfo), direction).done(function() {
                        deferred.resolve()
                    })
                });
                feedbackEvents.lock(result);
                return result
            },
            _resolveLayoutController: function(viewInfo) {
                var args = {
                        viewInfo: viewInfo,
                        layoutController: null,
                        availableLayoutControllers: this._availableLayoutControllers
                    };
                this._processEvent("resolveLayoutController", args, viewInfo.model);
                this._checkLayoutControllerIsInitialized(args.layoutController);
                return args.layoutController || this._resolveLayoutControllerImpl(viewInfo)
            },
            _checkLayoutControllerIsInitialized: function(layoutController) {
                if (layoutController) {
                    var isControllerInited = false;
                    $.each(this._layoutSet, function(_, controllerInfo) {
                        if (controllerInfo.controller === layoutController) {
                            isControllerInited = true;
                            return false
                        }
                    });
                    if (!isControllerInited)
                        throw errors.Error("E3024");
                }
            },
            _ensureOneLayoutControllerFound: function(target, matches) {
                var toJSONInterceptor = function(key, value) {
                        if (key === "controller")
                            return "[controller]: { name:" + value.name + " }";
                        return value
                    };
                if (!matches.length) {
                    errors.log("W3003", JSON.stringify(target, null, 4), JSON.stringify(this._availableLayoutControllers, toJSONInterceptor, 4));
                    throw errors.Error("E3011");
                }
                if (matches.length > 1) {
                    errors.log("W3004", JSON.stringify(target, null, 4), JSON.stringify(matches, toJSONInterceptor, 4));
                    throw errors.Error("E3012");
                }
            },
            _resolveLayoutControllerImpl: function(viewInfo) {
                var templateInfo = viewInfo.viewTemplateInfo || {},
                    navigateOptions = viewInfo.navigateOptions || {},
                    target = $.extend({
                        root: !viewInfo.canBack,
                        customResolveRequired: false,
                        pane: templateInfo.pane,
                        modal: navigateOptions.modal !== undefined ? navigateOptions.modal : templateInfo.modal || false
                    }, devices.current());
                var matches = commonUtils.findBestMatches(target, this._availableLayoutControllers);
                this._ensureOneLayoutControllerFound(target, matches);
                return matches[0].controller
            },
            _onNavigatingBack: function(args) {
                this.callBase.apply(this, arguments);
                if (!args.cancel && !this.canBack() && this._activeLayoutControllersStack.length > 1) {
                    var previousActiveLayoutController = this._activeLayoutControllersStack[this._activeLayoutControllersStack.length - 2],
                        previousViewInfo = previousActiveLayoutController.activeViewInfo();
                    args.cancel = true;
                    this._activateLayoutController(previousActiveLayoutController, undefined, "backward");
                    this.navigationManager.currentItem(previousViewInfo.key)
                }
            },
            _activeLayoutController: function() {
                return this._activeLayoutControllersStack.length ? this._activeLayoutControllersStack[this._activeLayoutControllersStack.length - 1] : undefined
            },
            _getTargetNode: function(viewInfo) {
                var jQueryEvent = (viewInfo.navigateOptions || {}).jQueryEvent;
                return jQueryEvent ? $(jQueryEvent.target) : undefined
            },
            _activateLayoutController: function(layoutController, targetNode, direction) {
                var that = this,
                    previousLayoutController = that._activeLayoutController();
                if (previousLayoutController === layoutController)
                    return $.Deferred().resolve().promise();
                return layoutController.activate(targetNode).then($.proxy(this._deactivatePreviousLayoutControllers, this, layoutController, direction)).then(function() {
                        that._activeLayoutControllersStack.push(layoutController)
                    })
            },
            _deactivatePreviousLayoutControllers: function(layoutController, direction) {
                var that = this,
                    tasks = [],
                    controllerToDeactivate = that._activeLayoutControllersStack.pop();
                if (!controllerToDeactivate)
                    return $.Deferred().resolve().promise();
                if (layoutController.isOverlay) {
                    that._activeLayoutControllersStack.push(controllerToDeactivate);
                    tasks.push(controllerToDeactivate.disable())
                }
                else {
                    var transitionDeferred = $.Deferred(),
                        skipAnimation = false;
                    var getControllerDeactivator = function(controllerToDeactivate, d) {
                            return function() {
                                    controllerToDeactivate.deactivate().done(function() {
                                        d.resolve()
                                    })
                                }
                        };
                    while (controllerToDeactivate && controllerToDeactivate !== layoutController) {
                        var d = $.Deferred();
                        if (controllerToDeactivate.isOverlay)
                            skipAnimation = true;
                        else
                            that.transitionExecutor.leave(controllerToDeactivate.element(), LAYOUT_CHANGE_ANIMATION_NAME, {direction: direction});
                        transitionDeferred.promise().done(getControllerDeactivator(controllerToDeactivate, d));
                        tasks.push(d.promise());
                        controllerToDeactivate = that._activeLayoutControllersStack.pop()
                    }
                    if (skipAnimation)
                        transitionDeferred.resolve();
                    else {
                        that.transitionExecutor.enter(layoutController.element(), LAYOUT_CHANGE_ANIMATION_NAME, {direction: direction});
                        that.transitionExecutor.start().done(function() {
                            transitionDeferred.resolve()
                        })
                    }
                }
                return $.when.apply($, tasks)
            },
            init: function() {
                var that = this,
                    result = this.callBase();
                result.done(function() {
                    that._initLayoutControllers();
                    that.renderNavigation()
                });
                return result
            },
            _disposeView: function(viewInfo) {
                if (viewInfo.layoutController.disposeView)
                    viewInfo.layoutController.disposeView(viewInfo);
                this.callBase(viewInfo)
            },
            viewPort: function() {
                return this._$viewPort
            },
            _createViewInfo: function(navigationItem, navigateOptions) {
                var viewInfo = this.callBase.apply(this, arguments),
                    templateInfo = this.getViewTemplateInfo(viewInfo.viewName);
                if (!templateInfo)
                    throw errors.Error("E3013", "dxView", viewInfo.viewName);
                viewInfo.viewTemplateInfo = templateInfo;
                viewInfo.layoutController = this._resolveLayoutController(viewInfo);
                return viewInfo
            },
            _createViewModel: function(viewInfo) {
                this.callBase(viewInfo);
                objectUtils.extendFromObject(viewInfo.model, viewInfo.viewTemplateInfo)
            },
            _initLayoutControllers: function() {
                var that = this;
                $.each(that._layoutSet, function(index, controllerInfo) {
                    var controller = controllerInfo.controller,
                        target = devices.current();
                    if (commonUtils.findBestMatches(target, [controllerInfo]).length) {
                        that._availableLayoutControllers.push(controllerInfo);
                        if (controller.init)
                            controller.init({
                                app: that,
                                $viewPort: that._$viewPort,
                                navigationManager: that.navigationManager,
                                viewEngine: that.viewEngine,
                                templateContext: that._templateContext,
                                commandManager: that.commandManager
                            });
                        if (controller.on) {
                            controller.on("viewReleased", function(viewInfo) {
                                that._onViewReleased(viewInfo)
                            });
                            controller.on("viewHidden", function(viewInfo) {
                                that._onViewHidden(viewInfo)
                            });
                            controller.on("viewRendered", function(viewInfo) {
                                that._processEvent("viewRendered", {viewInfo: viewInfo}, viewInfo.model)
                            });
                            controller.on("viewShowing", function(viewInfo, direction) {
                                that._processEvent("viewShowing", {
                                    viewInfo: viewInfo,
                                    direction: direction,
                                    params: viewInfo.routeData
                                }, viewInfo.model)
                            })
                        }
                    }
                })
            },
            _onViewReleased: function(viewInfo) {
                this._releaseViewLink(viewInfo)
            },
            renderNavigation: function() {
                var that = this;
                $.each(that._availableLayoutControllers, function(index, controllerInfo) {
                    var controller = controllerInfo.controller;
                    if (controller.renderNavigation)
                        controller.renderNavigation(that.navigation)
                })
            },
            getViewTemplate: function(viewName) {
                return this.viewEngine.getViewTemplate(viewName)
            },
            getViewTemplateInfo: function(viewName) {
                var viewComponent = this.viewEngine.getViewTemplateInfo(viewName);
                return viewComponent && viewComponent.option()
            },
            loadTemplates: function(source) {
                return this.viewEngine.loadTemplates(source)
            },
            templateContext: function() {
                return this._templateContext
            }
        })
    })(jQuery, DevExpress);
    DevExpress.MOD_FRAMEWORK = true
}
