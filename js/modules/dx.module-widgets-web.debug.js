/*! 
* DevExtreme (Web Widgets)
* Version: 15.1.8
* Build date: Oct 29, 2015
*
* Copyright (c) 2012 - 2015 Developer Express Inc. ALL RIGHTS RESERVED
* EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
*/

"use strict";
if (!DevExpress.MOD_WIDGETS_WEB) {
    if (!DevExpress.MOD_WIDGETS_BASE)
        throw Error('Required module is not referenced: widgets-base');
    /*! Module widgets-web, file ui.accordion.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            fx = DX.fx;
        var ACCORDION_CLASS = "dx-accordion",
            ACCORDION_WRAPPER_CLASS = "dx-accordion-wrapper",
            ACCORDION_ITEM_CLASS = "dx-accordion-item",
            ACCORDION_ITEM_OPENED_CLASS = "dx-accordion-item-opened",
            ACCORDION_ITEM_CLOSED_CLASS = "dx-accordion-item-closed",
            ACCORDION_ITEM_TITLE_CLASS = "dx-accordion-item-title",
            ACCORDION_ITEM_BODY_CLASS = "dx-accordion-item-body",
            ACCORDION_ITEM_DATA_KEY = "dxAccordionItemData",
            ACCORDION_ITEM_TITLE_DATA_KEY = "dxAccordionItemTitleData",
            ACCORDION_ITEM_CONTENT_DATA_KEY = "dxAccordionItemContentData";
        DX.registerComponent("dxAccordion", ui, ui.CollectionWidget.inherit({
            _activeStateUnit: "." + ACCORDION_ITEM_CLASS,
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    height: undefined,
                    itemTitleTemplate: "title",
                    onItemTitleClick: null,
                    onItemTitleHold: null,
                    selectedIndex: 0,
                    collapsible: false,
                    multiple: false,
                    animationDuration: 300,
                    deferRendering: true,
                    selectionByClick: true,
                    activeStateEnabled: true,
                    _itemAttributes: {role: "tab"}
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {
                                hoverStateEnabled: true,
                                focusStateEnabled: true
                            }
                        }])
            },
            _init: function() {
                this.callBase();
                this.option("selectionRequired", !this.option("collapsible"));
                this.option("selectionMode", this.option("multiple") ? "multi" : "single");
                var $element = this.element();
                $element.addClass(ACCORDION_CLASS);
                this._$container = $("<div>").addClass(ACCORDION_WRAPPER_CLASS);
                $element.append(this._$container)
            },
            _render: function() {
                this._deferredItems = [];
                this.callBase();
                this.setAria({
                    role: "tablist",
                    multiselectable: this.option("multiple")
                });
                this._attachItemTitleClickAction()
            },
            _itemDataKey: function() {
                return ACCORDION_ITEM_DATA_KEY
            },
            _itemClass: function() {
                return ACCORDION_ITEM_CLASS
            },
            _itemContainer: function() {
                return this._$container
            },
            _itemTitles: function() {
                return this._itemElements().find("." + ACCORDION_ITEM_TITLE_CLASS)
            },
            _itemContents: function() {
                return this._itemElements().find("." + ACCORDION_ITEM_BODY_CLASS)
            },
            _getItemData: function(target) {
                return $(target).parent().data(this._itemDataKey()) || this.callBase.apply(this, arguments)
            },
            _executeItemRenderAction: function(itemData, itemElement) {
                if (itemData.type)
                    return;
                this.callBase.apply(this, arguments)
            },
            _itemSelectHandler: function(e) {
                if ($(e.target).closest("." + ACCORDION_ITEM_BODY_CLASS).length)
                    return;
                this.callBase.apply(this, arguments)
            },
            _renderItemContent: function(index, itemData, $container) {
                $container = $container || this._itemContainer();
                var $itemTitle = this.callBase.apply(this, [index, $.extend({
                            type: "title",
                            titleTemplate: this._getTemplateByOption("itemTitleTemplate")
                        }, itemData), $container]);
                var $item = $itemTitle.parent();
                this._deferredItems.push($.Deferred());
                this._deferredItems[index].done($.proxy(this._renderItemBody, this, this.callBase, index, itemData, $item));
                if (!this.option("deferRendering"))
                    this._deferredItems[index].resolve()
            },
            _renderItemBody: function(baseRenderer, index, itemData, $item) {
                var $itemBody = $("<div>").appendTo($item);
                baseRenderer.apply(this, [index, $.extend({
                        type: "content",
                        template: this._getTemplateByOption("itemTemplate")
                    }, itemData), $itemBody])
            },
            _getItemTemplateName: function(itemData) {
                var templateProperty = this.option("itemTemplateProperty");
                if (itemData.type === "title")
                    templateProperty = "titleTemplate";
                return itemData && itemData[templateProperty] || this.option("itemTemplate")
            },
            _addItemContentClasses: function($container, itemData) {
                switch (itemData.type) {
                    case"title":
                        $container.addClass(ACCORDION_ITEM_TITLE_CLASS).data(ACCORDION_ITEM_TITLE_DATA_KEY, itemData);
                        break;
                    case"content":
                        $container.addClass(ACCORDION_ITEM_BODY_CLASS).data(ACCORDION_ITEM_CONTENT_DATA_KEY, itemData);
                        break;
                    default:
                        this.callBase.apply(this, arguments)
                }
            },
            _attachItemTitleClickAction: function() {
                var itemSelector = "." + ACCORDION_ITEM_TITLE_CLASS,
                    eventName = events.addNamespace("dxclick", this.NAME);
                this._itemContainer().off(eventName, itemSelector).on(eventName, itemSelector, $.proxy(this._itemTitleClickHandler, this))
            },
            _itemTitleClickHandler: function(e) {
                this._itemJQueryEventHandler(e, "onItemTitleClick")
            },
            _renderSelection: function(addedSelection, removedSelection) {
                this._itemElements().addClass(ACCORDION_ITEM_CLOSED_CLASS);
                this._updateItems(addedSelection, removedSelection, true)
            },
            _updateSelection: function(addedSelection, removedSelection) {
                this._updateItems(addedSelection, removedSelection, false)
            },
            _updateItems: function(addedSelection, removedSelection, skipAnimation) {
                var $items = this._itemElements(),
                    that = this;
                $.each(addedSelection, function(_, index) {
                    var $item = $items.eq(index);
                    if ($item.find("." + ACCORDION_ITEM_BODY_CLASS).length === 0)
                        that._deferredItems[index].resolve();
                    $item.addClass(ACCORDION_ITEM_OPENED_CLASS);
                    $item.removeClass(ACCORDION_ITEM_CLOSED_CLASS)
                });
                $.each(removedSelection, function(_, index) {
                    $items.eq(index).removeClass(ACCORDION_ITEM_OPENED_CLASS)
                });
                this._updateItemHeights(skipAnimation)
            },
            _updateItemHeights: function(skipAnimation) {
                var that = this,
                    itemHeight = this._splitFreeSpace(this._calculateFreeSpace());
                return $.when.apply($, $.map(this._itemElements(), function(item) {
                        return that._updateItemHeight($(item), itemHeight, skipAnimation)
                    }))
            },
            _updateItemHeight: function($item, itemHeight, skipAnimation) {
                var $title = $item.children("." + ACCORDION_ITEM_TITLE_CLASS);
                if (fx.isAnimating($item))
                    fx.stop($item);
                var startItemHeight = $item.outerHeight(),
                    finalItemHeight = $item.hasClass(ACCORDION_ITEM_OPENED_CLASS) ? itemHeight + $title.outerHeight() || $item.height("auto").outerHeight() : $title.outerHeight();
                return !skipAnimation ? this._animateItem($item, startItemHeight, finalItemHeight) : $item.css("height", finalItemHeight)
            },
            _animateItem: function(element, startHeight, endHeight) {
                return fx.animate(element, {
                        type: "slide",
                        from: {height: startHeight},
                        to: {height: endHeight},
                        duration: this.option("animationDuration"),
                        complete: $.proxy(function() {
                            if (this._deferredAnimate)
                                this._deferredAnimate.resolveWith(this);
                            this._itemElements().not("." + ACCORDION_ITEM_OPENED_CLASS).addClass(ACCORDION_ITEM_CLOSED_CLASS)
                        }, this)
                    })
            },
            _splitFreeSpace: function(freeSpace) {
                if (!freeSpace)
                    return freeSpace;
                return freeSpace / this.option("selectedItems").length
            },
            _calculateFreeSpace: function() {
                var height = this.option("height");
                if (height === undefined || height === "auto")
                    return;
                var $titles = this._itemTitles(),
                    itemsHeight = 0;
                $.each($titles, function(_, title) {
                    itemsHeight += $(title).outerHeight()
                });
                return this.element().height() - itemsHeight
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._dimensionChanged()
            },
            _dimensionChanged: function() {
                this._updateItemHeights(true)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"animationDuration":
                    case"onItemTitleClick":
                        break;
                    case"collapsible":
                        this.option("selectionRequired", !this.option("collapsible"));
                        break;
                    case"itemTitleTemplate":
                    case"onItemTitleHold":
                    case"height":
                    case"deferRendering":
                        this._invalidate();
                        break;
                    case"multiple":
                        this.option("selectionMode", args.value ? "multi" : "single");
                        break;
                    default:
                        this.callBase(args)
                }
            },
            expandItem: function(index) {
                this._deferredAnimate = $.Deferred();
                this.selectItem(index);
                return this._deferredAnimate.promise()
            },
            collapseItem: function(index) {
                this._deferredAnimate = $.Deferred();
                this.unselectItem(index);
                return this._deferredAnimate.promise()
            },
            updateDimensions: function() {
                return this._updateItemHeights(false)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pager.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            Class = DX.Class;
        var PAGES_LIMITER = 4,
            PAGER_CLASS = 'dx-pager',
            PAGER_PAGE_CLASS = 'dx-page',
            PAGER_PAGES_CLASS = 'dx-pages',
            PAGER_SELECTION_CLASS = 'dx-selection',
            PAGER_PAGE_SEPARATOR_CLASS = 'dx-separator',
            PAGER_PAGE_SIZES_CLASS = 'dx-page-sizes',
            PAGER_PAGE_SIZE_CLASS = 'dx-page-size',
            PAGER_NAVIGATE_BUTTON = 'dx-navigate-button',
            PAGER_PREV_BUTTON_CLASS = "dx-prev-button",
            PAGER_NEXT_BUTTON_CLASS = "dx-next-button",
            PAGER_INFO_CLASS = "dx-info",
            PAGER_BUTTON_DISABLE_CLASS = "dx-button-disable";
        var Page = Class.inherit({
                ctor: function(value, index) {
                    var that = this;
                    that.index = index;
                    that._$page = $('<div />').text(value).addClass(PAGER_PAGE_CLASS)
                },
                value: function(value) {
                    var that = this;
                    if (utils.isDefined(value))
                        that._$page.text(value);
                    else {
                        var text = that._$page.text();
                        if (utils.isNumber(text))
                            return parseInt(text);
                        else
                            return text
                    }
                },
                element: function() {
                    return this._$page
                },
                select: function(value) {
                    this._$page.toggleClass(PAGER_SELECTION_CLASS, value)
                },
                render: function(rootElement, rtlEnabled) {
                    rtlEnabled ? this._$page.prependTo(rootElement) : this._$page.appendTo(rootElement)
                }
            });
        DX.registerComponent("dxPager", ui, ui.Widget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    visible: true,
                    pageIndex: 1,
                    maxPagesCount: 10,
                    pageCount: 10,
                    pageSize: 5,
                    showPageSizes: true,
                    pageSizes: [5, 10],
                    hasKnownLastPage: true,
                    showNavigationButtons: false,
                    showInfo: false,
                    infoText: Globalize.localize("dxPager-infoText"),
                    rtlEnabled: false,
                    pageIndexChanged: $.noop,
                    pageSizeChanged: $.noop
                })
            },
            _toggleVisibility: function(value) {
                var $element = this.element();
                if ($element)
                    $element.css("display", value ? "" : "none")
            },
            _getPages: function(currentPage, count) {
                var pages = [],
                    showMoreButton = !this.option("hasKnownLastPage"),
                    firstValue,
                    i;
                this._testPagesCount = count;
                this._testShowMoreButton = showMoreButton;
                if (count > 0 || showMoreButton)
                    if (count <= this.option("maxPagesCount")) {
                        for (i = 1; i <= count; i++)
                            pages.push(new Page(i, i - 1));
                        if (showMoreButton)
                            pages.push(new Page('>', i - 1))
                    }
                    else {
                        pages.push(new Page(1, 0));
                        firstValue = currentPage ? currentPage.value() - currentPage.index : 1;
                        for (i = 1; i <= PAGES_LIMITER; i++)
                            pages.push(new Page(firstValue + i, i));
                        pages.push(new Page(count, PAGES_LIMITER + 1));
                        if (showMoreButton)
                            pages.push(new Page('>', PAGES_LIMITER + 1))
                    }
                return pages
            },
            _getPageByValue: function(value) {
                var that = this,
                    page,
                    i;
                for (i = 0; i < that._pages.length; i++) {
                    page = that._pages[i];
                    if (page.value() === value)
                        return page
                }
            },
            _processSelectedPage: function(maxPagesCount, pageIndex, pageCount) {
                var that = this,
                    isPageIndexValid = false,
                    selectedPageIndex;
                if (that._pages) {
                    $.each(that._pages, function(key, page) {
                        if (pageIndex === page.value())
                            isPageIndexValid = true
                    });
                    if (!isPageIndexValid)
                        that.selectedPage = null
                }
                if (utils.isDefined(that.selectedPage)) {
                    if (pageIndex === pageCount && pageCount > maxPagesCount && that.selectedPage.index !== PAGES_LIMITER + 1)
                        that.selectedPage.index = PAGES_LIMITER + 1
                }
                else if (pageIndex > PAGES_LIMITER && pageIndex < pageCount) {
                    selectedPageIndex = pageCount - PAGES_LIMITER < pageIndex ? PAGES_LIMITER - (pageCount - pageIndex) + 1 : 2;
                    that.selectedPage = new Page(pageIndex, selectedPageIndex)
                }
            },
            _selectPageByValue: function(value) {
                var that = this,
                    i,
                    page = that._getPageByValue(value),
                    pages = that._pages,
                    pagesLength = pages.length,
                    prevPage,
                    nextPage,
                    morePage;
                if (!utils.isDefined(page))
                    return;
                prevPage = that._pages[page.index - 1];
                nextPage = that._pages[page.index + 1];
                if (nextPage && nextPage.value() === '>') {
                    morePage = nextPage;
                    nextPage = undefined;
                    pagesLength--;
                    pages.pop()
                }
                if (that.selectedPage)
                    that.selectedPage.select(false);
                page.select(true);
                that.selectedPage = page;
                if (nextPage && nextPage.value() - value > 1)
                    if (page.index !== 0) {
                        prevPage.value(value + 1);
                        that._pages.splice(page.index, 1);
                        that._pages.splice(page.index - 1, 0, page);
                        that._pages[page.index].index = page.index;
                        page.index = page.index - 1;
                        for (i = page.index - 1; i > 0; i--)
                            that._pages[i].value(that._pages[i + 1].value() - 1)
                    }
                    else
                        for (i = 0; i < pagesLength - 1; i++)
                            that._pages[i].value(i + 1);
                if (prevPage && value - prevPage.value() > 1)
                    if (page.index !== pagesLength - 1) {
                        nextPage.value(value - 1);
                        that._pages.splice(page.index, 1);
                        that._pages.splice(page.index + 1, 0, page);
                        that._pages[page.index].index = page.index;
                        page.index = page.index + 1;
                        for (i = page.index + 1; i < pagesLength - 1; i++)
                            that._pages[i].value(that._pages[i - 1].value() + 1)
                    }
                    else
                        for (i = 1; i <= pagesLength - 2; i++)
                            that._pages[pagesLength - 1 - i].value(that._pages[pagesLength - 1].value() - i);
                if (morePage)
                    pages.push(morePage)
            },
            _nextPage: function(direction) {
                var pageIndex = this.selectedPage && this.selectedPage.value(),
                    pageCount = this.option("pageCount");
                if (utils.isDefined(pageIndex)) {
                    pageIndex = direction === "next" ? ++pageIndex : --pageIndex;
                    if (pageIndex > 0 && pageIndex <= pageCount)
                        this.option("pageIndex", pageIndex)
                }
            },
            _renderPages: function(pages) {
                var that = this,
                    $separator,
                    pageslength = pages.length,
                    clickPagesIndexAction = that._createAction(function(args) {
                        var e = args.jQueryEvent,
                            pageNumber = $(e.target).text(),
                            pageIndex = pageNumber === '>' ? that.option("pageCount") + 1 : Number(pageNumber);
                        that._testPageIndex = pageIndex;
                        that.option("pageIndex", pageIndex)
                    }),
                    page;
                if (pageslength > 1) {
                    that._pageClickHandler = function(e) {
                        clickPagesIndexAction({jQueryEvent: e})
                    };
                    that.$pagesChooser.on(events.addNamespace("dxclick", that.Name + "Pages"), '.' + PAGER_PAGE_CLASS, that._pageClickHandler)
                }
                for (var i = 0; i < pageslength; i++) {
                    page = pages[i];
                    page.render(that.$pagesChooser, that.option('rtlEnabled'));
                    that.setAria({
                        role: "button",
                        label: "Page " + page.value()
                    }, page.element());
                    if (pages[i + 1] && pages[i + 1].value() - page.value() > 1) {
                        $separator = $("<div>. . .</div>").addClass(PAGER_PAGE_SEPARATOR_CLASS);
                        that.option('rtlEnabled') ? $separator.prependTo(that.$pagesChooser) : $separator.appendTo(that.$pagesChooser)
                    }
                }
            },
            _renderPagesChooser: function() {
                var that = this,
                    $element = that.element();
                if (!$element)
                    return;
                if (that._pages.length === 0) {
                    that.selectedPage = null;
                    return
                }
                if (utils.isDefined(that.$pagesChooser))
                    that.$pagesChooser.empty();
                else
                    that.$pagesChooser = $('<div />').addClass(PAGER_PAGES_CLASS);
                that.$pagesChooser.css("visibility", that._pages.length === 1 ? "hidden" : "");
                that._renderInfo();
                that._renderNavigateButton("prev");
                that._renderPages(that._pages);
                that._renderNavigateButton("next");
                if (!utils.isDefined(that.$pagesChooser[0].parentElement))
                    that.$pagesChooser.appendTo($element)
            },
            _renderPagesSizeChooser: function() {
                var that = this,
                    i,
                    $pageSize,
                    currentPageSize = that.option("pageSize"),
                    pageSizes = that.option("pageSizes"),
                    showPageSizes = that.option("showPageSizes"),
                    pageSizeValue,
                    pagesSizesLength = pageSizes && pageSizes.length,
                    $element = that.element();
                if (!$element)
                    return;
                that._clickPagesSizeAction = that._createAction(function(args) {
                    var e = args.jQueryEvent;
                    pageSizeValue = parseInt($(e.target).text());
                    that._testPageSizeIndex = pageSizeValue;
                    that.option("pageSize", pageSizeValue)
                });
                if (utils.isDefined(that.pagesSizeChooserElement))
                    that.pagesSizeChooserElement.empty();
                else
                    that.pagesSizeChooserElement = $('<div />').addClass(PAGER_PAGE_SIZES_CLASS).on(events.addNamespace("dxclick", that.Name + "PageSize"), '.' + PAGER_PAGE_SIZE_CLASS, function(e) {
                        that._clickPagesSizeAction({jQueryEvent: e})
                    });
                if (!showPageSizes || !pagesSizesLength)
                    return;
                that._testCurrentPageSize = currentPageSize;
                for (i = 0; i < pagesSizesLength; i++) {
                    $pageSize = $('<div />').text(pageSizes[i]).addClass(PAGER_PAGE_SIZE_CLASS);
                    that.setAria({
                        role: "button",
                        label: "Display " + pageSizes[i] + " items on page"
                    }, $pageSize);
                    if (currentPageSize === pageSizes[i])
                        $pageSize.addClass(PAGER_SELECTION_CLASS);
                    that.pagesSizeChooserElement.append($pageSize)
                }
                if (!utils.isDefined(that.pagesSizeChooserElement[0].parentElement))
                    that.pagesSizeChooserElement.appendTo($element)
            },
            _renderInfo: function() {
                var infoText = this.option("infoText");
                if (this.option("showInfo") && utils.isDefined(infoText))
                    $("<div>").addClass(PAGER_INFO_CLASS).text(utils.stringFormat(infoText, this.selectedPage && this.selectedPage.value(), this.option("pageCount"))).appendTo(this.$pagesChooser)
            },
            _renderNavigateButton: function(direction) {
                var that = this,
                    currentPageIndex,
                    clickAction = that._createAction(function(e) {
                        that._nextPage(direction)
                    }),
                    $button,
                    enabled;
                if (that.option("showNavigationButtons")) {
                    currentPageIndex = that.option("pageIndex");
                    enabled = currentPageIndex > 1 && direction === "prev" || currentPageIndex < that.option("pageCount") && direction === "next";
                    $button = $("<div>").addClass(PAGER_NAVIGATE_BUTTON).addClass(!enabled ? PAGER_BUTTON_DISABLE_CLASS : "").on(events.addNamespace("dxclick", that.Name + "Pages"), function(e) {
                        clickAction({jQueryEvent: e})
                    });
                    that.setAria({
                        role: "button",
                        label: direction === "prev" ? "Previous page" : " Next page"
                    }, $button);
                    if (that.option("rtlEnabled")) {
                        $button.addClass(direction === "prev" ? PAGER_NEXT_BUTTON_CLASS : PAGER_PREV_BUTTON_CLASS);
                        $button.prependTo(this.$pagesChooser)
                    }
                    else {
                        $button.addClass(direction === "prev" ? PAGER_PREV_BUTTON_CLASS : PAGER_NEXT_BUTTON_CLASS);
                        $button.appendTo(this.$pagesChooser)
                    }
                }
            },
            _render: function() {
                this.callBase();
                this._update();
                this.element().addClass(PAGER_CLASS);
                this._toggleVisibility(this.option("visible"));
                this._renderPagesSizeChooser();
                this._renderPagesChooser()
            },
            _update: function() {
                var pageCount = this.option("pageCount"),
                    pageIndex = this.option("pageIndex");
                this._processSelectedPage(this.option("maxPagesCount"), pageIndex, pageCount);
                this._pages = this._getPages(this.selectedPage, pageCount);
                this._selectPageByValue(pageIndex)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"visible":
                        this._toggleVisibility(args.value);
                        break;
                    case"pageIndex":
                        var pageIndexChanged = this.option("pageIndexChanged");
                        if (pageIndexChanged)
                            pageIndexChanged(args.value);
                        this._update();
                        this._renderPagesChooser();
                        break;
                    case"maxPagesCount":
                    case"pageCount":
                    case"hasKnownLastPage":
                    case"showNavigationButtons":
                        this._update();
                        this._renderPagesChooser();
                        break;
                    case"pageSize":
                        var pageSizeChanged = this.option("pageSizeChanged");
                        if (pageSizeChanged)
                            pageSizeChanged(args.value);
                        this._renderPagesSizeChooser();
                        break;
                    case"pageSizes":
                        this._renderPagesSizeChooser();
                        break;
                    default:
                        this._invalidate()
                }
            },
            _clean: function() {
                this.$pagesChooser && this.$pagesChooser.off(events.addNamespace("dxclick", this.Name + "Pages"), '.' + PAGER_PAGE_CLASS, this._pageClickHandler)
            },
            getHeight: function() {
                return this.option("visible") ? this.element().outerHeight() : 0
            }
        }));
        ui.dxPager.__internals = {
            PAGER_CLASS: PAGER_CLASS,
            PAGER_PAGE_CLASS: PAGER_PAGE_CLASS,
            PAGER_PAGES_CLASS: PAGER_PAGES_CLASS,
            PAGER_SELECTION_CLASS: PAGER_SELECTION_CLASS,
            PAGER_PAGE_SEPARATOR_CLASS: PAGER_PAGE_SEPARATOR_CLASS,
            PAGER_PAGE_SIZES_CLASS: PAGER_PAGE_SIZES_CLASS,
            PAGER_PAGE_SIZE_CLASS: PAGER_PAGE_SIZE_CLASS,
            PAGER_NAVIGATE_BUTTON: PAGER_NAVIGATE_BUTTON,
            PAGER_PREV_BUTTON_CLASS: PAGER_PREV_BUTTON_CLASS,
            PAGER_NEXT_BUTTON_CLASS: PAGER_NEXT_BUTTON_CLASS,
            PAGER_INFO_CLASS: PAGER_INFO_CLASS,
            PAGER_BUTTON_DISABLE_CLASS: PAGER_BUTTON_DISABLE_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.menuBase.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils;
        var DX_MENU_CLASS = "dx-menu",
            DX_MENU_BASE_CLASS = "dx-menu-base",
            DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item",
            DX_MENU_SELECTED_ITEM_CLASS = DX_MENU_ITEM_CLASS + "-selected",
            DX_MENU_ITEM_WRAPPER_CLASS = DX_MENU_ITEM_CLASS + "-wrapper",
            DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
            DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded",
            DX_MENU_SEPARATOR_CLASS = DX_MENU_CLASS + "-separator",
            DX_MENU_ITEM_LAST_GROUP_ITEM = DX_MENU_CLASS + "-last-group-item",
            DX_ITEM_HAS_TEXT = DX_MENU_ITEM_CLASS + "-has-text",
            DX_ITEM_HAS_ICON = DX_MENU_ITEM_CLASS + "-has-icon",
            DX_ITEM_HAS_SUBMENU = DX_MENU_ITEM_CLASS + "-has-submenu",
            DX_MENU_ITEM_CLASS_SELECTOR = "." + DX_MENU_ITEM_CLASS,
            DX_ITEM_SELECTED_SELECTOR = "." + DX_MENU_SELECTED_ITEM_CLASS,
            SINGLE_SELECTION_MODE = "single",
            NONE_SELECTION_MODE = "none",
            FIRST_SUBMENU_LEVEL = 1,
            DEFAULT_SHOW_DELAY = 50,
            DEFAULT_HIDE_DELAY = 300;
        var dxMenuBase = ui.CollectionWidget.inherit({
                NAME: "dxMenuBase",
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        items: [],
                        cssClass: "",
                        activeStateEnabled: true,
                        showSubmenuMode: {
                            name: "onHover",
                            delay: {
                                show: 50,
                                hide: 300
                            }
                        },
                        animation: {
                            show: {
                                type: "fade",
                                from: 0,
                                to: 1,
                                duration: 100
                            },
                            hide: {
                                type: "fade",
                                from: 1,
                                to: 0,
                                duration: 100
                            }
                        },
                        selectionByClick: false,
                        selectionMode: "none",
                        focusOnSelectedItem: false,
                        _remoteSelectionSync: false,
                        hoverStateEnabled: true,
                        _itemAttributes: {role: "menuitem"}
                    })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return DX.devices.real().generic && !DX.devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }])
                },
                _activeStateUnit: DX_MENU_ITEM_CLASS_SELECTOR,
                _itemDataKey: function() {
                    return "dxMenuItemDataKey"
                },
                _itemClass: function() {
                    return DX_MENU_ITEM_CLASS
                },
                _setAriaSelected: $.noop,
                _selectedItemClass: function() {
                    return DX_MENU_SELECTED_ITEM_CLASS
                },
                _focusTarget: function() {
                    return this._itemContainer()
                },
                _eventBindingTarget: function() {
                    return this._itemContainer()
                },
                _supportedKeys: function() {
                    var selectItem = function(e) {
                            var $item = this.option("focusedElement");
                            if (!$item || !this._isSelectionEnabled())
                                return;
                            this.selectItem($item)
                        };
                    return $.extend(this.callBase(), {
                            space: selectItem,
                            pageUp: $.noop,
                            pageDown: $.noop
                        })
                },
                _isSelectionEnabled: function() {
                    return this._getSelectionMode() === SINGLE_SELECTION_MODE
                },
                _getSelectionMode: function() {
                    return this.option("selectionMode") === SINGLE_SELECTION_MODE ? SINGLE_SELECTION_MODE : NONE_SELECTION_MODE
                },
                _init: function() {
                    this.callBase();
                    this._initActions()
                },
                _initActions: $.noop,
                _render: function() {
                    var $element = this.element();
                    this.callBase(arguments);
                    this._addCustomCssClass($element);
                    this._itemContainer().addClass(DX_MENU_BASE_CLASS)
                },
                _getShowSubmenuMode: function() {
                    var modeName;
                    if (utils.isObject(this.option("showSubmenuMode")))
                        modeName = this._isDesktopDevice() ? this.option("showSubmenuMode").name : "onClick";
                    else
                        modeName = this._isDesktopDevice() ? this.option("showSubmenuMode") : "onClick";
                    return modeName
                },
                _isDesktopDevice: function() {
                    return DX.devices.real().deviceType === "desktop"
                },
                _initEditStrategy: function() {
                    var strategy = ui.CollectionWidget.MenuBaseEditStrategy;
                    this._editStrategy = new strategy(this)
                },
                _addCustomCssClass: function($element) {
                    $element.addClass(this.option("cssClass"))
                },
                _itemWrapperSelector: function() {
                    return "." + DX_MENU_ITEM_WRAPPER_CLASS
                },
                _hoverStartHandler: function(e) {
                    var that = this,
                        $itemElement = that._getItemElementByEventArgs(e);
                    if ($itemElement) {
                        if (that._isItemDisabled($itemElement))
                            return;
                        e.stopPropagation();
                        that.option("focusedElement", $itemElement);
                        if (that._getShowSubmenuMode() === "onHover") {
                            clearTimeout(this._showSubmenusTimeout);
                            this._showSubmenusTimeout = setTimeout($.proxy(that._showSubmenu, that, $itemElement), that._getSubmenuShowDelay())
                        }
                    }
                },
                _isItemDisabled: function($item) {
                    return $item.data(this._itemDataKey()).disabled
                },
                _showSubmenu: function($itemElement) {
                    clearTimeout(this._showSubmenusTimeout);
                    if (this._hasFocusClass($itemElement))
                        this._addExpandedClass($itemElement)
                },
                _addExpandedClass: function($itemElement) {
                    $itemElement.addClass(DX_MENU_ITEM_EXPANDED_CLASS)
                },
                _getSubmenuHideDelay: function() {
                    var delay = this.option("showSubmenuMode").delay;
                    if (delay)
                        return utils.isObject(delay) ? delay.hide : delay;
                    else
                        return DEFAULT_HIDE_DELAY
                },
                _getSubmenuShowDelay: function() {
                    var delay = this.option("showSubmenuMode").delay,
                        resultDelay;
                    if (delay)
                        resultDelay = utils.isObject(delay) ? delay.show : delay;
                    else
                        resultDelay = DEFAULT_SHOW_DELAY;
                    return resultDelay
                },
                _getItemElementByEventArgs: function(eventArgs) {
                    var $target = $(eventArgs.target);
                    if ($target.hasClass(this._itemClass()) || $target.get(0) === eventArgs.currentTarget)
                        return $target;
                    while (!$target.hasClass(this._itemClass())) {
                        $target = $target.parent();
                        if ($target.hasClass("dx-submenu"))
                            return null
                    }
                    return $target
                },
                _hoverEndHandler: $.noop,
                _hasSubmenu: function(item) {
                    return item.items && item.items.length > 0
                },
                _renderItems: function(items, submenuLevel, submenuContainer) {
                    submenuLevel = submenuLevel || FIRST_SUBMENU_LEVEL;
                    var that = this,
                        $itemsContainer;
                    if (items.length) {
                        $itemsContainer = this._renderContainer(submenuLevel, submenuContainer);
                        $.each(items, function(index, item) {
                            that._renderItem(index, item, $itemsContainer, submenuLevel)
                        })
                    }
                    this._setSelectionFromItems()
                },
                _renderContainer: function(submenuLevel) {
                    return this._createItemsContainer().addClass(DX_MENU_ITEMS_CONTAINER_CLASS)
                },
                _createItemsContainer: function() {
                    var $rootGroup = $("<div>").appendTo(this.element());
                    return $("<ul>").appendTo($rootGroup)
                },
                _renderItem: function(index, item, $itemsContainer, submenuLevel) {
                    var items = this.option("items"),
                        $itemWrapper = $("<li>"),
                        $item;
                    this._renderSeparator(item, index, $itemsContainer);
                    $itemWrapper.appendTo($itemsContainer).addClass(DX_MENU_ITEM_WRAPPER_CLASS);
                    if (items[index + 1] && items[index + 1].beginGroup)
                        $itemWrapper.addClass(DX_MENU_ITEM_LAST_GROUP_ITEM);
                    if (!utils.isObject(item))
                        item = {text: item};
                    if (!utils.isDefined(item.selected))
                        item.selected = false;
                    $item = this.callBase(index, item, $itemWrapper);
                    this._addContentClasses(item, $item);
                    if (this._hasSubmenu(item))
                        this._renderSubmenuItems(item, $item, submenuLevel)
                },
                _addContentClasses: function(item, $item) {
                    if (item.text)
                        $item.addClass(DX_ITEM_HAS_TEXT);
                    if (item.icon || item.iconSrc)
                        $item.addClass(DX_ITEM_HAS_ICON);
                    if (item.items && item.items.length > 0)
                        $item.addClass(DX_ITEM_HAS_SUBMENU)
                },
                _setSelectionFromItems: function() {
                    var selectedIndex = this.option("selectedIndex"),
                        searchSelectedFromItems = !selectedIndex || selectedIndex === -1;
                    if (this.option("_remoteSelectionSync") || !searchSelectedFromItems)
                        return;
                    $.each(this._editStrategy._getPlainItems(), function(index, item) {
                        if (item.selected && item.selectable !== false)
                            selectedIndex = index
                    });
                    if (selectedIndex >= 0)
                        this.option("selectedIndex", selectedIndex)
                },
                _renderSeparator: function(item, index, $itemsContainer) {
                    if (item.beginGroup && index > 0)
                        this._needSeparate = true;
                    if (item.visible !== false && this._needSeparate) {
                        $("<li>").appendTo($itemsContainer).addClass(DX_MENU_SEPARATOR_CLASS);
                        this._needSeparate = false
                    }
                },
                _renderSubmenuItems: function(item, $item) {
                    this.setAria("haspopup", "true", $item)
                },
                _itemClickHandler: function(e) {
                    var itemClickActionHandler = this._createAction($.proxy(this._updateSubmenuVisibilityOnClick, this));
                    this._itemJQueryEventHandler(e, "onItemClick", {}, {afterExecute: $.proxy(itemClickActionHandler, this)})
                },
                _updateSubmenuVisibilityOnClick: function(actionArgs) {
                    this._updateSelectedItemOnClick(actionArgs);
                    if (this._getShowSubmenuMode() === "onClick")
                        this._addExpandedClass(actionArgs.args[0].itemElement)
                },
                _updateSelectedItemOnClick: function(actionArgs) {
                    var args = actionArgs.args ? actionArgs.args[0] : actionArgs,
                        isSelectionByClickEnabled = this._isSelectionEnabled() && this.option("selectionByClick"),
                        $selectedItem,
                        selectedItemData;
                    if (isSelectionByClickEnabled && args.itemData.selectable !== false && !this._hasSubmenu(args.itemData)) {
                        $selectedItem = this._itemContainer().find(DX_ITEM_SELECTED_SELECTOR);
                        if ($selectedItem.length) {
                            selectedItemData = this._getItemData($selectedItem);
                            $selectedItem.removeClass(this._selectedItemClass());
                            if (selectedItemData) {
                                selectedItemData.selected = false;
                                this._clearSelectedItems()
                            }
                            if (!$selectedItem.is(args.itemElement))
                                this._setSelectedItems(args)
                        }
                        else
                            this._setSelectedItems(args)
                    }
                },
                _setSelectedItems: function(args) {
                    args.itemData.selected = true;
                    this.option("selectedItems", [args.itemData])
                },
                _syncSelectionOptions: function(byOption) {
                    var items = this._editStrategy._getPlainItems() || [],
                        selectedItems = this.option("selectedItems") || [],
                        selectedItem = this.option("selectedItem"),
                        selectedIndex = this.option("selectedIndex");
                    byOption = byOption || this._chooseSelectOption();
                    switch (byOption) {
                        case"selectedItems":
                            this._setOptionSilent("selectedItem", selectedItems[0]);
                            this._setOptionSilent("selectedIndex", $.inArray(selectedItems[0], items));
                            break;
                        case"selectedItem":
                            if (utils.isDefined(selectedItem)) {
                                this._setOptionSilent("selectedItems", [selectedItem]);
                                this._setOptionSilent("selectedIndex", $.inArray(selectedItem, items))
                            }
                            else {
                                this._setOptionSilent("selectedItems", []);
                                this._setOptionSilent("selectedIndex", -1)
                            }
                            break;
                        case"selectedIndex":
                            if (utils.isDefined(items[selectedIndex])) {
                                this._setOptionSilent("selectedItems", [items[selectedIndex]]);
                                this._setOptionSilent("selectedItem", items[selectedIndex])
                            }
                            else {
                                this._setOptionSilent("selectedItems", []);
                                this._setOptionSilent("selectedItem", null)
                            }
                            break
                    }
                },
                _getStringifiedArray: function(array) {
                    return $.map(array, function(item) {
                            return JSON.stringify(item)
                        })
                },
                _isOwnItem: function(item) {
                    var plainItems = this._editStrategy._getPlainItems();
                    return $.inArray(JSON.stringify(item), this._getStringifiedArray(plainItems)) >= 0
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"showSubmenuMode":
                            break;
                        case"_remoteSelectionSync":
                        case"cssClass":
                        case"position":
                        case"selectionByClick":
                        case"animation":
                            this._invalidate();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                selectItem: function(itemElement) {
                    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement),
                        itemData = this._getItemData(itemElement);
                    if (itemIndex === -1)
                        return;
                    var itemSelectionIndex = $.inArray(itemIndex, this._selectedItemIndices);
                    if (itemSelectionIndex !== -1)
                        return;
                    if (this.option("selectionMode") === "single" && itemData.selectable !== false) {
                        var items = this._editStrategy.fetchSelectedItems([itemIndex]);
                        items[0].selected = true;
                        this.option("selectedItems", items)
                    }
                },
                unselectItem: function(itemElement) {
                    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
                    if (itemIndex === -1)
                        return;
                    var itemSelectionIndex = $.inArray(itemIndex, this._selectedItemIndices);
                    if (itemSelectionIndex === -1)
                        return;
                    var items = this._editStrategy.fetchSelectedItems([itemSelectionIndex]);
                    items[0].selected = false;
                    this.option("selectedItems", [])
                }
            });
        ui.dxMenuBase = dxMenuBase
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.menuBase.edit.strategy.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        ui.CollectionWidget.MenuBaseEditStrategy = ui.CollectionWidget.PlainEditStrategy.inherit({
            _getPlainItems: function() {
                return $.map(this._collectionWidget.option("items"), function getMenuItems(item) {
                        return item.items ? [item].concat($.map(item.items, getMenuItems)) : item
                    })
            },
            _getStringifiedArray: function(array) {
                var that = this;
                return $.map(array, function(item) {
                        return that._stringifyItem(item)
                    })
            },
            _stringifyItem: function(item) {
                var that = this;
                return JSON.stringify(item, function(key, value) {
                        if (key === "template")
                            return that._getTemplateString(value);
                        return value
                    })
            },
            _getTemplateString: function(template) {
                var result;
                if (typeof template === "object")
                    result = $(template).text();
                else
                    result = template.toString();
                return result
            },
            selectedItemIndices: function() {
                var selectedIndices = [],
                    items = this._getStringifiedArray(this._getPlainItems()),
                    selectedItems = this._collectionWidget.option("selectedItems");
                $.each(selectedItems, function(_, selectedItem) {
                    var index = $.inArray(JSON.stringify(selectedItem), items);
                    if (index !== -1)
                        selectedIndices.push(index);
                    else
                        DX.log("W1002", selectedItem)
                });
                return selectedIndices
            },
            fetchSelectedItems: function(indices) {
                indices = indices || this._collectionWidget._selectedItemIndices;
                var items = this._getPlainItems(),
                    selectedItems = [];
                $.each(indices, function(_, index) {
                    selectedItems.push(items[index])
                });
                return selectedItems
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.contextMenu.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            fx = DX.fx;
        var DX_MENU_CLASS = "dx-menu",
            DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item",
            DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded",
            DX_MENU_PHONE_CLASS = "dx-menu-phone-overlay",
            DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
            DX_MENU_ITEM_WRAPPER_CLASS = DX_MENU_ITEM_CLASS + "-wrapper",
            DX_SUBMENU_CLASS = "dx-submenu",
            DX_CONTEXT_MENU_CLASS = "dx-context-menu",
            DX_HAS_CONTEXT_MENU_CLASS = "dx-has-context-menu",
            DX_STATE_DISABLED_CLASS = "dx-state-disabled",
            DX_SUBMENU_LEVEL_ID = "dxSubmenuLevel",
            FOCUS_UP = "up",
            FOCUS_DOWN = "down",
            FOCUS_LEFT = "left",
            FOCUS_RIGHT = "right",
            FOCUS_FIRST = "first",
            FOCUS_LAST = "last",
            ACTIONS = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioning", "onLeftFirstItem", "onLeftLastItem", "onCloseRootSubmenu", "onExpandLastSubmenu"],
            LOCAL_SUBMENU_DIRECTIONS = [FOCUS_UP, FOCUS_DOWN, FOCUS_FIRST, FOCUS_LAST];
        DX.registerComponent("dxContextMenu", ui, ui.dxMenuBase.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    alternativeInvocationMode: {
                        enabled: false,
                        invokingElement: null
                    },
                    position: {
                        at: "top left",
                        my: "top left"
                    },
                    onShowing: null,
                    onShown: null,
                    onHiding: null,
                    onHidden: null,
                    onPositioning: null,
                    submenuDirection: "auto",
                    visible: false,
                    target: window,
                    onLeftFirstItem: null,
                    onLeftLastItem: null,
                    onCloseRootSubmenu: null,
                    onExpandLastSubmenu: null
                })
            },
            _initActions: function() {
                this._actions = {};
                $.each(ACTIONS, $.proxy(function(index, action) {
                    this._actions[action] = this._createActionByOption(action) || $.noop
                }, this))
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {
                    animation: true,
                    position: true,
                    selectedItem: true
                })
            },
            _itemContainer: function() {
                return this._overlay.content()
            },
            _supportedKeys: function() {
                return $.extend(this.callBase(), {esc: this.hide})
            },
            _moveFocus: function(location) {
                var $items = this._getItemsByLocation(location),
                    $oldTarget = this._getActiveItem(true),
                    $newTarget,
                    $focusedItem = this.option("focusedElement");
                switch (location) {
                    case FOCUS_UP:
                        $newTarget = $focusedItem ? this._prevItem($items) : $items.last();
                        if ($oldTarget.is($items.first()))
                            this._actions.onLeftFirstItem($oldTarget);
                        break;
                    case FOCUS_DOWN:
                        $newTarget = $focusedItem ? this._nextItem($items) : $items.first();
                        if ($oldTarget.is($items.last()))
                            this._actions.onLeftLastItem($oldTarget);
                        break;
                    case FOCUS_RIGHT:
                        $newTarget = this.option("rtlEnabled") ? this._hideSubmenuHandler($items) : this._expandSubmenuHandler($items);
                        break;
                    case FOCUS_LEFT:
                        $newTarget = this.option("rtlEnabled") ? this._expandSubmenuHandler($items) : this._hideSubmenuHandler($items);
                        break;
                    case FOCUS_FIRST:
                        $newTarget = $items.first();
                        break;
                    case FOCUS_LAST:
                        $newTarget = $items.last();
                        break;
                    default:
                        return this.callBase(location)
                }
                if ($newTarget.length !== 0)
                    this.option("focusedElement", $newTarget)
            },
            _getItemsByLocation: function(location) {
                var $items,
                    $activeItem = this._getActiveItem(true),
                    expandedLocation = this.option("rtlEnabled") ? FOCUS_LEFT : FOCUS_RIGHT;
                if ($.inArray(location, LOCAL_SUBMENU_DIRECTIONS) >= 0)
                    $items = $activeItem.closest("." + DX_MENU_ITEMS_CONTAINER_CLASS).children().children();
                else {
                    $items = this._itemElements();
                    if (location !== expandedLocation)
                        $items = $items.filter(":visible")
                }
                return $items
            },
            _getAriaTarget: function() {
                return this.element()
            },
            _refreshActiveDescendant: function() {
                var $target = this._overlay.content(),
                    id = this.getFocusedItemId();
                if (!$target)
                    return this.callBase();
                this.setAria("activedescendant", "", $target);
                this.setAria("activedescendant", id, $target)
            },
            _hideSubmenuHandler: function($items) {
                var $curItem = this._getActiveItem(true),
                    $parentItem = $curItem.parents("." + DX_MENU_ITEM_EXPANDED_CLASS).first();
                if ($parentItem.length) {
                    this._hideSubmenusOnSameLevel($parentItem);
                    return $parentItem
                }
                this._actions.onCloseRootSubmenu($curItem);
                return $curItem
            },
            _expandSubmenuHandler: function($items) {
                var $curItem = this._getActiveItem(true),
                    $submenu = $curItem.children("." + DX_SUBMENU_CLASS);
                if ($submenu.length && !$curItem.hasClass(DX_STATE_DISABLED_CLASS)) {
                    if ($submenu.css("visibility") === "hidden")
                        this._showSubmenu($curItem);
                    return this._nextItem($items)
                }
                this._actions.onExpandLastSubmenu($curItem);
                return $curItem
            },
            _render: function() {
                this.element().addClass(DX_HAS_CONTEXT_MENU_CLASS);
                this.callBase();
                this.setAria("role", "menu")
            },
            _renderContentImpl: function() {
                this._renderContextMenuOverlay();
                this._detachShowContextMenuEvents(this.option("target"));
                this._attachShowContextMenuEvents();
                this._attachInvokeContextMenuEvents();
                this.callBase()
            },
            _renderContextMenuOverlay: function() {
                var overlayOptions = this._getOverlayOptions(),
                    $overlayElement = $("<div>"),
                    $overlayContent;
                this._overlay = this._createComponent($overlayElement.appendTo(this._$element), "dxOverlay", overlayOptions);
                $overlayContent = this._overlay.content();
                $overlayContent.addClass(DX_CONTEXT_MENU_CLASS);
                this._addCustomCssClass($overlayContent);
                this._addPlatformDependentClass($overlayContent);
                if (this._overlay.option("visible"))
                    this._show()
            },
            _addPlatformDependentClass: function($element) {
                if (DX.devices.current().phone)
                    $element.addClass(DX_MENU_PHONE_CLASS)
            },
            _detachShowContextMenuEvents: function(target) {
                var eventName = events.addNamespace("dxcontextmenu", this.NAME);
                $(target).off(eventName);
                this._overlay && this._overlay.content().off(eventName)
            },
            _attachShowContextMenuEvents: function() {
                var that = this,
                    eventName = events.addNamespace("dxcontextmenu", this.NAME),
                    contextMenuAction = this._createAction($.proxy(function(e) {
                        if (!that.option("alternativeInvocationMode").enabled)
                            that._show(e.jQueryEvent)
                    }, this));
                this._overlay && this._overlay.content().on(eventName, $.noop);
                $(this.option("target")).on(eventName, $.proxy(function(e) {
                    contextMenuAction({jQueryEvent: e})
                }, this))
            },
            _attachInvokeContextMenuEvents: function() {
                var that = this,
                    eventName = events.addNamespace("dxclick", this.NAME),
                    contextMenuAction = this._createAction($.proxy(function() {
                        that.toggle()
                    }, this));
                if (this.option("alternativeInvocationMode").enabled && this._getInvokeTarget())
                    $(this._getInvokeTarget()).off(eventName).on(eventName, $.proxy(function(e) {
                        contextMenuAction({jQueryEvent: e})
                    }, this))
            },
            _getInvokeTarget: function() {
                return this.option("alternativeInvocationMode").invokingElement
            },
            _hoverEndHandler: function(e) {
                e.stopPropagation()
            },
            _renderDimensions: $.noop,
            _renderContainer: function(submenuLevel, submenuContainer) {
                var $submenu = $("<div>"),
                    $itemsContainer = $("<ul>"),
                    $holder = submenuLevel === 1 ? this._itemContainer() : submenuContainer;
                $submenu.appendTo($holder).addClass(DX_SUBMENU_CLASS).data(DX_SUBMENU_LEVEL_ID, submenuLevel).css("visibility", submenuLevel === 1 ? "visible" : "hidden");
                $itemsContainer.appendTo($submenu).addClass(DX_MENU_ITEMS_CONTAINER_CLASS);
                if (submenuLevel === 1) {
                    if (this.option("width"))
                        $itemsContainer.css("min-width", this.option("width"));
                    if (this.option("height"))
                        $itemsContainer.css("min-height", this.option("height"))
                }
                return $itemsContainer
            },
            _renderSubmenuItems: function(item, $item, submenuLevel) {
                this._renderItems(item.items, ++submenuLevel, $item);
                this.callBase(item, $item)
            },
            _getOverlayOptions: function() {
                var position = this.option("position"),
                    overlayAnimation = this.option("animation"),
                    overlayOptions = {
                        focusStateEnabled: this.option("focusStateEnabled"),
                        animation: overlayAnimation,
                        closeOnOutsideClick: $.proxy(this._closeOnOutsideClickHandler, this),
                        closeOnTargetScroll: true,
                        deferRendering: false,
                        position: {
                            at: position.at,
                            my: position.my,
                            of: this.option("target"),
                            collision: "fit"
                        },
                        shading: false,
                        showTitle: false,
                        height: "auto",
                        width: "auto",
                        onShowing: $.proxy(this._overlayShowingActionHandler, this),
                        onShown: $.proxy(this._overlayShownActionHandler, this),
                        onHiding: $.proxy(this._overlayHidingActionHandler, this),
                        onHidden: $.proxy(this._overlayHiddenActionHandler, this),
                        onPositioned: $.proxy(this._overlayPositionedActionHandler, this),
                        onPositioning: $.proxy(this._overlayPositioningActionHandler, this)
                    };
                return overlayOptions
            },
            _overlayShowingActionHandler: function(arg) {
                this._actions.onShowing(arg);
                this._clearFocusedItem()
            },
            _overlayShownActionHandler: function(arg) {
                this._actions.onShown(arg);
                this._clearFocusedItem()
            },
            _clearFocusedItem: function() {
                this._removeFocusedItem();
                this.option("focusedElement", null)
            },
            _overlayHidingActionHandler: function(arg) {
                this._actions.onHiding(arg);
                if (!arg.cancel)
                    this._hideAllShownSubmenus()
            },
            _overlayHiddenActionHandler: function(arg) {
                this._actions.onHidden(arg);
                this._setOptionSilent("visible", false)
            },
            _overlayPositionedActionHandler: $.noop,
            _overlayPositioningActionHandler: $.noop,
            _closeOnOutsideClickHandler: function(e) {
                var $clickedItem,
                    $activeItemContainer,
                    $itemContainers,
                    $rootItem,
                    isRootItemClicked,
                    isInnerOverlayClicked,
                    isInvokeTarget = $(e.target).closest(this._getInvokeTarget());
                if (e.target === document)
                    return true;
                if (isInvokeTarget && isInvokeTarget.length)
                    return false;
                $activeItemContainer = this._getActiveItemsContainer(e.target);
                $itemContainers = this._getItemsContainers();
                $clickedItem = this._searchActiveItem(e.target);
                $rootItem = this.element().parents("." + DX_MENU_ITEM_CLASS);
                isRootItemClicked = $clickedItem[0] === $rootItem[0] && $clickedItem.length && $rootItem.length;
                isInnerOverlayClicked = this._isIncludeOverlay($activeItemContainer, $itemContainers) && $clickedItem.length;
                if (isInnerOverlayClicked || isRootItemClicked) {
                    if (this._getShowSubmenuMode() === "onClick")
                        this._hideAllShownChildSubmenus($clickedItem);
                    return false
                }
                return true
            },
            _getActiveItemsContainer: function(target) {
                return $(target).closest("." + DX_MENU_ITEMS_CONTAINER_CLASS)
            },
            _getItemsContainers: function() {
                return this._overlay._$content.find("." + DX_MENU_ITEMS_CONTAINER_CLASS)
            },
            _searchActiveItem: function(target) {
                return $(target).closest("." + DX_MENU_ITEM_CLASS).eq(0)
            },
            _isIncludeOverlay: function($activeOverlay, $allOverlays) {
                var isSame = false;
                $.each($allOverlays, function(index, $overlay) {
                    if ($activeOverlay.is($overlay) && !isSame)
                        isSame = true
                });
                return isSame
            },
            _hideAllShownChildSubmenus: function($clickedItem) {
                var that = this,
                    $submenuElements = $clickedItem.find("." + DX_SUBMENU_CLASS),
                    shownSubmenus = $.extend([], this._shownSubmenus),
                    $context;
                if ($submenuElements.length > 0)
                    $.each(shownSubmenus, function(index, $submenu) {
                        $context = that._searchActiveItem($submenu.context).parent();
                        if ($context.parent().is($clickedItem.parent().parent()) && !$context.is($clickedItem.parent()))
                            that._hideSubmenu($submenu)
                    })
            },
            _showSubmenu: function($item) {
                var isItemHasSubmenu = $item.children("." + DX_SUBMENU_CLASS).length,
                    isSubmenuVisible;
                this._hideSubmenusOnSameLevel($item);
                if (isItemHasSubmenu) {
                    this.callBase($item);
                    $item.closest("." + DX_MENU_ITEMS_CONTAINER_CLASS).find("." + DX_MENU_ITEM_EXPANDED_CLASS).removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                    isSubmenuVisible = this._isSubmenuVisible($item.children("." + DX_SUBMENU_CLASS));
                    if (!isSubmenuVisible) {
                        $item.addClass(DX_MENU_ITEM_EXPANDED_CLASS);
                        this._drawSubmenu($item)
                    }
                }
            },
            _hideSubmenusOnSameLevel: function($item) {
                var $expandedItems = $item.closest("." + DX_MENU_ITEMS_CONTAINER_CLASS).find("." + DX_MENU_ITEM_EXPANDED_CLASS);
                if ($expandedItems.length) {
                    $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                    this._hideSubmenu($expandedItems.find("." + DX_SUBMENU_CLASS))
                }
            },
            _hideSubmenuGroup: function($submenu) {
                if (this._isSubmenuVisible($submenu))
                    this._hideSubmenuCore($submenu)
            },
            _isSubmenuVisible: function($submenu) {
                return $submenu.css("visibility") === "visible"
            },
            _drawSubmenu: function($itemElement) {
                var animation = this.option("animation") ? this.option("animation").show : {},
                    $submenu = $itemElement.children("." + DX_SUBMENU_CLASS);
                if (this._overlay && this._overlay.option("visible")) {
                    if (!utils.isDefined(this._shownSubmenus))
                        this._shownSubmenus = [];
                    if ($.inArray($submenu, this._shownSubmenus))
                        this._shownSubmenus.push($submenu);
                    DX.position($submenu, this._getSubmenuPosition($itemElement));
                    animation && this._animate($submenu, animation);
                    $submenu.css("visibility", "visible")
                }
            },
            _animate: function($container, options) {
                fx.animate($container, options)
            },
            _getSubmenuPosition: function($rootItem) {
                var submenuDirection = this.option("submenuDirection").toLowerCase(),
                    $rootItemWrapper = $rootItem.parent("." + DX_MENU_ITEM_WRAPPER_CLASS),
                    position = {
                        collision: "flip",
                        of: $rootItemWrapper,
                        offset: {
                            h: 0,
                            v: -1
                        }
                    };
                switch (submenuDirection) {
                    case"left":
                        position.at = "left top";
                        position.my = "right top";
                        break;
                    case"right":
                        position.at = "right top";
                        position.my = "left top";
                        break;
                    default:
                        if (this.option("rtlEnabled")) {
                            position.at = "left top";
                            position.my = "right top"
                        }
                        else {
                            position.at = "right top";
                            position.my = "left top"
                        }
                        break
                }
                return position
            },
            _updateSubmenuVisibilityOnClick: function(actionArgs) {
                var $itemElement,
                    itemData,
                    $submenuElement,
                    notCloseMenuOnItemClick;
                if (actionArgs.args.length && actionArgs.args[0]) {
                    actionArgs.args[0].jQueryEvent.stopPropagation();
                    $itemElement = actionArgs.args[0].itemElement;
                    itemData = this._getItemData($itemElement);
                    notCloseMenuOnItemClick = itemData && itemData.closeMenuOnClick === false;
                    $submenuElement = $itemElement.children("." + DX_SUBMENU_CLASS);
                    if ($itemElement.context === $submenuElement.context && $submenuElement.css("visibility") === "visible")
                        return;
                    if (!itemData || itemData.disabled || notCloseMenuOnItemClick)
                        return;
                    this._updateSelectedItemOnClick(actionArgs);
                    if ($submenuElement.length === 0) {
                        var $prevSubmenu = $($itemElement.parents("." + DX_SUBMENU_CLASS)[0]);
                        this._hideSubmenu($prevSubmenu);
                        if (!actionArgs.canceled && this._overlay && this._overlay.option("visible"))
                            this.option("visible", false)
                    }
                    else {
                        if (this._shownSubmenus && this._shownSubmenus.length > 0)
                            if (this._shownSubmenus[0].is($submenuElement) || this._shownSubmenus[0].has($submenuElement).length === 1)
                                this._hideSubmenu($submenuElement);
                            else
                                this._hideAllShownSubmenus();
                        this._showSubmenu($itemElement)
                    }
                }
            },
            _hideSubmenu: function($curSubmenu) {
                var that = this,
                    shownSubmenus = $.extend([], that._shownSubmenus);
                $.each(shownSubmenus, function(index, $submenu) {
                    if ($curSubmenu.is($submenu) || $curSubmenu.has($submenu).length) {
                        $submenu.parent().removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                        that._hideSubmenuCore($submenu)
                    }
                })
            },
            _hideSubmenuCore: function($submenu) {
                var index = $.inArray($submenu, this._shownSubmenus),
                    animation = this.option("animation") ? this.option("animation").hide : null;
                if (index >= 0)
                    this._shownSubmenus.splice(index, 1);
                this._stopAnimate($submenu);
                animation && this._animate($submenu, animation);
                $submenu.css("visibility", "hidden")
            },
            _stopAnimate: function($container) {
                fx.stop($container, true)
            },
            _hideAllShownSubmenus: function() {
                var that = this,
                    shownSubmenus = $.extend([], that._shownSubmenus),
                    $expandedItems = this._overlay.content().find("." + DX_MENU_ITEM_EXPANDED_CLASS);
                $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                $.each(shownSubmenus, function(_, $submenu) {
                    that._hideSubmenuCore($submenu)
                })
            },
            _optionChanged: function(args) {
                if (this._cancelOptionChange)
                    return;
                if ($.inArray(args.name, ACTIONS) > -1) {
                    this._initActions();
                    return
                }
                switch (args.name) {
                    case"visible":
                        this._toggleVisibility(args.value);
                        break;
                    case"alternativeInvocationMode":
                        this._invalidate();
                        break;
                    case"items":
                        if (this._overlay.option("visible"))
                            this._overlay.hide();
                        this.callBase(args);
                        break;
                    case"position":
                    case"submenuDirection":
                        this._invalidate();
                        break;
                    case"target":
                        args.previousValue && this._detachShowContextMenuEvents($(args.previousValue));
                        this._invalidate();
                        break;
                    case"focusedElement":
                        this.callBase(args);
                        break;
                    default:
                        if (this._overlay)
                            if (this._overlay.option("visible"))
                                this._overlay.hide();
                        this.callBase(args)
                }
            },
            _toggleVisibility: function(showing) {
                showing ? this._show() : this._hide()
            },
            _show: function(jQEvent) {
                var canShowMenu = !(this._overlay && this._positionContextMenu(jQEvent)),
                    id = new DevExpress.data.Guid,
                    promise;
                if (canShowMenu && this._overlay) {
                    this.option("focusedElement", this._itemElements().first());
                    promise = this._overlay.show();
                    this._overlay.content().attr({
                        id: id,
                        role: "menu"
                    });
                    this.setAria("owns", id);
                    this._setOptionSilent("visible", true)
                }
                return promise || $.Deferred().reject().promise()
            },
            _positionContextMenu: function(jQEvent) {
                var position = this.option("position"),
                    positioningAction = this._createActionByOption("onPositioning", actionArgs),
                    actionArgs;
                if (jQEvent && jQEvent.preventDefault)
                    position = {
                        at: "top left",
                        my: "top left",
                        of: jQEvent
                    };
                if (!position.of)
                    position.of = this.option("target");
                actionArgs = {
                    position: position,
                    jQueryEvent: jQEvent
                };
                positioningAction(actionArgs);
                if (!actionArgs.canceled && this._overlay)
                    position && this._overlay.option("position", position);
                else
                    actionArgs.jQueryEvent.cancel = true;
                return actionArgs.canceled
            },
            _hide: function() {
                var promise;
                if (this._overlay) {
                    this._overlay.content().removeAttr("id");
                    promise = this._overlay.hide();
                    this._setOptionSilent("visible", false)
                }
                this.setAria("owns", undefined);
                return promise || $.Deferred().reject().promise()
            },
            _clean: function() {
                if (this._overlay) {
                    this._overlay.element().remove();
                    this._overlay = null
                }
                this._detachShowContextMenuEvents($(this.option("target")))
            },
            toggle: function(showing) {
                var visible = this.option("visible");
                showing = showing === undefined ? !visible : showing;
                return showing ? this._show() : this._hide()
            },
            show: function() {
                return this.toggle(true)
            },
            hide: function() {
                return this.toggle(false)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.menu.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events;
        var DX_MENU_CLASS = "dx-menu",
            DX_MENU_VERTICAL_CLASS = DX_MENU_CLASS + "-vertical",
            DX_MENU_HORIZONTAL_CLASS = DX_MENU_CLASS + "-horizontal",
            DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item",
            DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
            DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded",
            DX_CONTEXT_MENU_CLASS = "dx-context-menu",
            DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS = DX_CONTEXT_MENU_CLASS + "-container-border",
            DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS = "dx-context-menu-content-delimiter",
            DX_SUBMENU_CLASS = "dx-submenu",
            DX_STATE_DISABLED_CLASS = "dx-state-disabled",
            DX_STATE_FOCUSED_CLASS = "dx-state-focused",
            DX_STATE_HOVER_CLASS = "dx-state-hover",
            FOCUS_UP = "up",
            FOCUS_DOWN = "down",
            FOCUS_LEFT = "left",
            FOCUS_RIGHT = "right",
            SHOW_SUBMENU_OPERATION = "showSubmenu",
            NEXTITEM_OPERATION = "nextItem",
            PREVITEM_OPERATION = "prevItem",
            DEFAULT_SHOW_DELAY = 50,
            DEFAULT_HIDE_DELAY = 300,
            ACTIONS = ["onSubmenuShowing", "onSubmenuShown", "onSubmenuHiding", "onSubmenuHidden"],
            dxSubmenu = ui.dxContextMenu.inherit({
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({orientation: "horizontal"})
                },
                _renderContentImpl: function() {
                    this.callBase();
                    if (!this.option("_hideDelimiter"))
                        this._renderDelimiter()
                },
                _renderDelimiter: function() {
                    this.$contentDelimiter = $("<div>").appendTo(this._itemContainer()).addClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS)
                },
                _overlayPositionedActionHandler: function(arg) {
                    this._showDelimiter(arg)
                },
                _hoverEndHandler: function(e) {
                    this._toggleFocusClass(false, e.currentTarget)
                },
                _hoverStartHandler: function(e) {
                    this.callBase(e);
                    this._toggleFocusClass(true, e.currentTarget)
                },
                _showDelimiter: function(arg) {
                    var $submenu = this._itemContainer().children("." + DX_SUBMENU_CLASS).eq(0),
                        $rootItem = this.option("position").of,
                        position = {of: $submenu},
                        containerOffset,
                        rootOffset;
                    if (this.$contentDelimiter) {
                        containerOffset = arg.position;
                        rootOffset = $rootItem.offset();
                        this.$contentDelimiter.css("display", "block");
                        if (this.option("orientation") === "horizontal") {
                            this.$contentDelimiter.width($rootItem.width() < $submenu.width() ? $rootItem.width() - 2 : $submenu.width() - 2);
                            this.$contentDelimiter.height(2);
                            if (containerOffset.v.location > rootOffset.top)
                                if (Math.round(containerOffset.h.location) === Math.round(rootOffset.left)) {
                                    position.offset = "1 -1";
                                    position.at = "left top";
                                    position.my = "left top"
                                }
                                else {
                                    position.offset = "-1 -1";
                                    position.at = "right top";
                                    position.my = "right top"
                                }
                            else {
                                this.$contentDelimiter.height(5);
                                if (Math.round(containerOffset.h.location) === Math.round(rootOffset.left)) {
                                    position.offset = "1 4";
                                    position.at = "left bottom";
                                    position.my = "left bottom"
                                }
                                else {
                                    position.offset = "-1 2";
                                    position.at = "right bottom";
                                    position.my = "right bottom"
                                }
                            }
                        }
                        else if (this.option("orientation") === "vertical") {
                            this.$contentDelimiter.width(2);
                            this.$contentDelimiter.height($rootItem.height() < $submenu.height() ? $rootItem.height() - 2 : $submenu.height() - 2);
                            if (containerOffset.h.location > rootOffset.left)
                                if (Math.round(containerOffset.v.location) === Math.round(rootOffset.top)) {
                                    position.offset = "-1 1";
                                    position.at = "left top";
                                    position.my = "left top"
                                }
                                else {
                                    position.offset = "-1 -1";
                                    position.at = "left bottom";
                                    position.my = "left bottom"
                                }
                            else if (Math.round(containerOffset.v.location) === Math.round(rootOffset.top)) {
                                position.offset = "1 1";
                                position.at = "right top";
                                position.my = "right top"
                            }
                            else {
                                position.offset = "1 -1";
                                position.at = "right bottom";
                                position.my = "right bottom"
                            }
                        }
                        DX.position(this.$contentDelimiter, position)
                    }
                }
            });
        DX.registerComponent("dxMenu", ui, ui.dxMenuBase.inherit({
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    allowSelection: {
                        since: "14.2",
                        message: 'Use the "selectionMode" option instead'
                    },
                    submenuHiddenAction: {
                        since: "14.2",
                        alias: "onSubmenuHidden"
                    },
                    submenuHidingAction: {
                        since: "14.2",
                        alias: "onSubmenuHiding"
                    },
                    submenuShowingAction: {
                        since: "14.2",
                        alias: "onSubmenuShowing"
                    },
                    submenuShownAction: {
                        since: "14.2",
                        alias: "onSubmenuShown"
                    }
                })
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    orientation: "horizontal",
                    submenuDirection: "auto",
                    showFirstSubmenuMode: {
                        name: "onClick",
                        delay: {
                            show: 50,
                            hide: 300
                        }
                    },
                    hideSubmenuOnMouseLeave: false,
                    onSubmenuShowing: null,
                    onSubmenuShown: null,
                    onSubmenuHiding: null,
                    onSubmenuHidden: null
                })
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {
                    animation: true,
                    selectedItem: true
                })
            },
            _focusTarget: function() {
                return this.element()
            },
            _eventBindingTarget: function() {
                return this.element()
            },
            _getOrientation: function() {
                return this.option("orientation") === "vertical" ? "vertical" : "horizontal"
            },
            _isMenuHorizontal: function() {
                return this._getOrientation() === "horizontal"
            },
            _moveFocus: function(location) {
                var $items = this._itemElements().filter(":visible"),
                    isMenuHorizontal = this._isMenuHorizontal(),
                    argument,
                    $activeItem = this._getActiveItem(true),
                    operation,
                    navigationAction,
                    $newTarget;
                switch (location) {
                    case FOCUS_UP:
                        operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(PREVITEM_OPERATION);
                        argument = isMenuHorizontal ? $activeItem : $items;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    case FOCUS_DOWN:
                        operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(NEXTITEM_OPERATION);
                        argument = isMenuHorizontal ? $activeItem : $items;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    case FOCUS_RIGHT:
                        operation = isMenuHorizontal ? this._getItemsNavigationOperation(NEXTITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
                        argument = isMenuHorizontal ? $items : $activeItem;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    case FOCUS_LEFT:
                        operation = isMenuHorizontal ? this._getItemsNavigationOperation(PREVITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
                        argument = isMenuHorizontal ? $items : $activeItem;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    default:
                        return this.callBase(location)
                }
                if ($newTarget && $newTarget.length !== 0)
                    this.option("focusedElement", $newTarget)
            },
            _getItemsNavigationOperation: function(operation) {
                var navOperation = operation;
                if (this.option("rtlEnabled"))
                    navOperation = operation === PREVITEM_OPERATION ? NEXTITEM_OPERATION : PREVITEM_OPERATION;
                return navOperation
            },
            _getKeyboardNavigationAction: function(operation, argument) {
                var action = $.noop;
                switch (operation) {
                    case SHOW_SUBMENU_OPERATION:
                        if (!argument.hasClass(DX_STATE_DISABLED_CLASS))
                            action = $.proxy(this._showSubmenu, this, argument);
                        break;
                    case NEXTITEM_OPERATION:
                        action = $.proxy(this._nextItem, this, argument);
                        break;
                    case PREVITEM_OPERATION:
                        action = $.proxy(this._prevItem, this, argument);
                        break
                }
                return action
            },
            _init: function() {
                this.callBase();
                this._submenus = []
            },
            _initActions: function() {
                this._actions = {};
                $.each(ACTIONS, $.proxy(function(index, action) {
                    this._actions[action] = this._createActionByOption(action) || $.noop
                }, this))
            },
            _render: function() {
                this._visibleSubmenu = [];
                this.callBase();
                this.element().addClass(DX_MENU_CLASS);
                this.setAria("role", "menubar")
            },
            _getHideDelay: function() {
                var delay = this.option("showFirstSubmenuMode").delay;
                if (delay)
                    return utils.isObject(delay) ? delay.hide : delay;
                else
                    return DEFAULT_HIDE_DELAY
            },
            _getShowDelay: function() {
                var delay = this.option("showFirstSubmenuMode").delay,
                    resultDelay;
                if (delay)
                    resultDelay = utils.isObject(delay) ? delay.show : delay;
                else
                    resultDelay = DEFAULT_SHOW_DELAY;
                return resultDelay
            },
            _renderContainer: function() {
                var isVerticalMenu = this.option("orientation") === "vertical",
                    $rootGroup = $("<div>"),
                    $itemsContainer = $("<ul>");
                $rootGroup.appendTo(this.element()).addClass(isVerticalMenu ? DX_MENU_VERTICAL_CLASS : DX_MENU_HORIZONTAL_CLASS);
                $itemsContainer.appendTo($rootGroup).addClass(DX_MENU_ITEMS_CONTAINER_CLASS).css("min-height", this._getValueHeight($rootGroup));
                return $itemsContainer
            },
            _getValueHeight: function($root) {
                var $div = $("<div>").html("Jj").css({
                        width: "auto",
                        position: "fixed",
                        top: "-3000px",
                        left: "-3000px"
                    }).appendTo($root),
                    height = $div.height();
                $div.remove();
                return height
            },
            _renderSubmenuItems: function(item, $item) {
                var submenu = this._createSubmenu(item.items, $item);
                this._submenus.push(submenu);
                this._renderBorderElement($item);
                this.callBase(item, $item)
            },
            _createSubmenu: function(items, $rootItem) {
                var $submenuContainer = $("<div>").addClass(DX_CONTEXT_MENU_CLASS).appendTo($rootItem);
                var result = this._createComponent($submenuContainer, "dxSubmenu", $.extend(this._getSubmenuOptions(), {
                        items: items,
                        position: this.getSubmenuPosition($rootItem)
                    }));
                this._attachSubmenuHandlers($rootItem, result);
                return result
            },
            _getSubmenuOptions: function() {
                var $submenuTarget = $("<div>"),
                    isMenuHorizontal = this._isMenuHorizontal();
                return {
                        itemTemplate: this.option("itemTemplate"),
                        templateProvider: this.option("templateProvider"),
                        target: $submenuTarget,
                        orientation: this.option("orientation"),
                        selectionMode: this.option("selectionMode"),
                        selectionByClick: this.option("selectionByClick"),
                        cssClass: this.option("cssClass"),
                        hoverStateEnabled: this.option("hoverStateEnabled"),
                        activeStateEnabled: this.option("activeStateEnabled"),
                        focusStateEnabled: this.option("focusStateEnabled"),
                        animation: this.option("animation"),
                        showSubmenuMode: this.option("showSubmenuMode"),
                        onSelectionChanged: $.proxy(this._nestedItemOnSelectionChangedHandler, this),
                        onItemClick: $.proxy(this._nestedItemOnItemClickHandler, this),
                        onItemRendered: this.option("onItemRendered"),
                        onLeftFirstItem: isMenuHorizontal ? null : $.proxy(this._moveMainMenuFocus, this, PREVITEM_OPERATION),
                        onLeftLastItem: isMenuHorizontal ? null : $.proxy(this._moveMainMenuFocus, this, NEXTITEM_OPERATION),
                        onCloseRootSubmenu: isMenuHorizontal ? $.proxy(this._moveMainMenuFocus, this, PREVITEM_OPERATION) : null,
                        onExpandLastSubmenu: isMenuHorizontal ? $.proxy(this._moveMainMenuFocus, this, NEXTITEM_OPERATION) : null,
                        _remoteSelectionSync: true,
                        _hideDelimiter: this.option("_hideDelimiter")
                    }
            },
            _getShowFirstSubmenuMode: function() {
                var modeName;
                if (utils.isObject(this.option("showFirstSubmenuMode")))
                    modeName = this._isDesktopDevice() ? this.option("showFirstSubmenuMode").name : "onClick";
                else
                    modeName = this._isDesktopDevice() ? this.option("showFirstSubmenuMode") : "onClick";
                return modeName
            },
            _moveMainMenuFocus: function(direction) {
                var $expandedItem = this.element().find("." + DX_MENU_ITEM_EXPANDED_CLASS).first(),
                    $newItem;
                switch (direction) {
                    case PREVITEM_OPERATION:
                        $newItem = $expandedItem.parent().prev();
                        if (!$newItem.length)
                            $newItem = $expandedItem.parent().siblings().last();
                        $newItem = $newItem.children();
                        break;
                    case NEXTITEM_OPERATION:
                        $newItem = $expandedItem.parent().next();
                        if (!$newItem.length)
                            $newItem = $expandedItem.parent().siblings().first();
                        $newItem = $newItem.children();
                        break
                }
                this._visibleSubmenu.length && this._hideSubmenu(this._visibleSubmenu);
                this.focus();
                this.option("focusedElement", $newItem)
            },
            _nestedItemOnSelectionChangedHandler: function(args) {
                var selectedItems = args.addedItems,
                    submenu = args.element.dxSubmenu("instance"),
                    onSelectionChanged = this._createActionByOption("onSelectionChanged", {});
                onSelectionChanged(args);
                this._clearSelectionInSubmenus(selectedItems[0], submenu);
                this._clearRootSelection();
                this.option("selectedItems", selectedItems)
            },
            _clearSelectionInSubmenus: function(item, targetSubmenu) {
                var that = this,
                    cleanAllSubmenus = !arguments.length;
                $.each(this._submenus, function(index, submenu) {
                    var $submenu = submenu._itemContainer(),
                        isOtherItem = !$submenu.is(targetSubmenu && targetSubmenu._itemContainer()),
                        $selectedItem = $submenu.find("." + that._selectedItemClass());
                    if (isOtherItem && $selectedItem.length || cleanAllSubmenus) {
                        var selectedItemData;
                        $selectedItem.removeClass(that._selectedItemClass());
                        selectedItemData = that._getItemData($selectedItem);
                        if (selectedItemData)
                            selectedItemData.selected = false;
                        submenu._clearSelectedItems()
                    }
                })
            },
            _clearRootSelection: function() {
                var $prevSelectedItem = this.element().find("." + DX_MENU_ITEMS_CONTAINER_CLASS).first().children().children().filter("." + this._selectedItemClass());
                if ($prevSelectedItem.length) {
                    var prevSelectedItemData;
                    prevSelectedItemData = this._getItemData($prevSelectedItem);
                    prevSelectedItemData.selected = false;
                    $prevSelectedItem.removeClass(this._selectedItemClass())
                }
                this._clearSelectedItems()
            },
            _nestedItemOnItemClickHandler: function(arg) {
                var onItemClick = this._createActionByOption("onItemClick", {});
                onItemClick(arg)
            },
            _updateSelectedItemOnClick: function(actionArgs) {
                var selectedIndex = this.option("selectedIndex");
                this.callBase(actionArgs);
                if (selectedIndex !== this.option("selectedIndex"))
                    this._clearSelectionInSubmenus()
            },
            _attachSubmenuHandlers: function($rootItem, submenu) {
                var that = this,
                    $submenuOverlayContent = submenu._overlay.content(),
                    submenus = $submenuOverlayContent.find("." + DX_SUBMENU_CLASS),
                    submenuMouseLeaveName = events.addNamespace("dxhoverend", this.NAME + "_submenu");
                submenu.option({
                    onShowing: $.proxy(this._submenuOnShowingHandler, this, $rootItem, submenu),
                    onShown: $.proxy(this._submenuOnShownHandler, this, $rootItem, submenu),
                    onHiding: $.proxy(this._submenuOnHidingHandler, this, $rootItem, submenu),
                    onHidden: $.proxy(this._submenuOnHiddenHandler, this, $rootItem, submenu)
                });
                $.each(submenus, function(index, submenu) {
                    $(submenu).off(submenuMouseLeaveName).on(submenuMouseLeaveName, null, $.proxy(that._submenuMouseLeaveHandler, that, $rootItem))
                })
            },
            _submenuOnShowingHandler: function($rootItem, submenu) {
                var $border = $rootItem.children("." + DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS);
                this._actions.onSubmenuShowing({
                    rootItem: $rootItem,
                    submenu: submenu
                });
                if (this._options.width !== undefined)
                    if (this._options.rtlEnabled)
                        $border.css("width", this._$element.width() - $rootItem.position().right);
                    else
                        $border.css("width", this._$element.width() - $rootItem.position().left);
                $border.show();
                $rootItem.addClass(DX_MENU_ITEM_EXPANDED_CLASS)
            },
            _submenuOnShownHandler: function($rootItem, submenu) {
                this._actions.onSubmenuShown({
                    rootItem: $rootItem,
                    submenu: submenu
                })
            },
            _submenuOnHidingHandler: function($rootItem, submenu, eventArgs) {
                var $border = $rootItem.children("." + DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS),
                    args = eventArgs;
                args.rootItem = $rootItem;
                args.submenu = submenu;
                this._actions.onSubmenuHiding(args);
                eventArgs = args;
                if (!eventArgs.cancel) {
                    $border.hide();
                    $rootItem.removeClass(DX_MENU_ITEM_EXPANDED_CLASS)
                }
            },
            _submenuOnHiddenHandler: function($rootItem, submenu) {
                this._actions.onSubmenuHidden({
                    rootItem: $rootItem,
                    submenu: submenu
                })
            },
            _submenuMouseLeaveHandler: function($rootItem, eventArgs) {
                var that = this,
                    target = $(eventArgs.relatedTarget).parents("." + DX_CONTEXT_MENU_CLASS)[0],
                    contextmenu = this._getSubmenuElementByRootElement($rootItem).dxSubmenu("instance")._overlay.content()[0];
                if (this.option("hideSubmenuOnMouseLeave") && target !== contextmenu) {
                    clearTimeout(this._showSubmenuTimer);
                    clearTimeout(this._hideSubmenuTimer);
                    setTimeout($.proxy(this._hideSubmenuAfterTimeout, this), that._getHideDelay(), $rootItem)
                }
            },
            _hideSubmenuAfterTimeout: function($rootItem) {
                var $submenu = this._getSubmenuElementByRootElement($rootItem),
                    hasVisibleSubmenu = this._visibleSubmenu.length,
                    isRootItemHovered = $(this._visibleSubmenu.context).hasClass(DX_STATE_HOVER_CLASS);
                if (hasVisibleSubmenu && !this._getFocusedSubmenuItem(this._getSubmenuInstance(this._visibleSubmenu)).length && !isRootItemHovered)
                    $submenu.length && this._getSubmenuInstance($submenu).hide()
            },
            _getFocusedSubmenuItem: function($submenu) {
                return $submenu._overlay.content().find("." + DX_STATE_FOCUSED_CLASS)
            },
            _getSubmenuInstance: function($submenu) {
                return $submenu.data().dxSubmenu
            },
            _getSubmenuElementByRootElement: function($rootItem) {
                return $rootItem && $rootItem.children("." + DX_CONTEXT_MENU_CLASS)
            },
            _getSubmenuInstanceByRootElement: function($rootItem) {
                var $submenu = this._getSubmenuElementByRootElement($rootItem);
                return $submenu.length && this._getSubmenuInstance($submenu)
            },
            getSubmenuPosition: function($rootItem) {
                var isVerticalMenu = this.option("orientation").toLowerCase() === "vertical",
                    submenuDirection = this.option("submenuDirection").toLowerCase(),
                    rtlEnabled = this.option("rtlEnabled"),
                    submenuPosition = {
                        collision: "flip",
                        of: $rootItem
                    };
                switch (submenuDirection) {
                    case"leftortop":
                        submenuPosition.at = isVerticalMenu ? "left top" : "left top";
                        submenuPosition.my = isVerticalMenu ? "right top" : "left bottom";
                        break;
                    case"rightorbottom":
                        submenuPosition.at = isVerticalMenu ? "right top" : "left bottom";
                        submenuPosition.my = isVerticalMenu ? "left top" : "left top";
                        break;
                    default:
                        if (isVerticalMenu) {
                            submenuPosition.at = rtlEnabled ? "left top" : "right top";
                            submenuPosition.my = rtlEnabled ? "right top" : "left top"
                        }
                        else {
                            submenuPosition.at = rtlEnabled ? "right bottom" : "left bottom";
                            submenuPosition.my = rtlEnabled ? "right top" : "left top"
                        }
                        break
                }
                return submenuPosition
            },
            _renderBorderElement: function($item) {
                $("<div>").appendTo($item).addClass(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS).hide()
            },
            _hoverStartHandler: function(e) {
                var mouseMoveEventName = events.addNamespace("dxpointermove", this.NAME),
                    $item = this._getItemElementByEventArgs(e),
                    submenu = this._getSubmenuInstanceByRootElement($item),
                    isSelectionActive = utils.isDefined(e.buttons) && e.buttons === 1 || !utils.isDefined(e.buttons) && e.which === 1;
                if (this._isItemDisabled($item))
                    return;
                $item.off(mouseMoveEventName);
                if (this._getShowFirstSubmenuMode() === "onHover" && submenu && !isSelectionActive) {
                    clearTimeout(this._hideSubmenuTimer);
                    clearTimeout(this._showSubmenuTimer);
                    if (!submenu._overlay.option("visible")) {
                        $item.on(mouseMoveEventName, $.proxy(this._itemMouseMoveHandler, this));
                        this._showSubmenuTimer = this._getHideDelay()
                    }
                    if (!submenu.element().is(this._visibleSubmenu))
                        this._hideSubmenu(this._visibleSubmenu)
                }
            },
            _hoverEndHandler: function(eventArg) {
                var that = this,
                    $item = this._getItemElementByEventArgs(eventArg);
                if (this._isItemDisabled($item))
                    return;
                if ($(eventArg.relatedTarget).hasClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS))
                    return;
                if (this.option("hideSubmenuOnMouseLeave") && !$(eventArg.relatedTarget).hasClass(DX_MENU_ITEMS_CONTAINER_CLASS)) {
                    clearTimeout(this._showSubmenuTimer);
                    clearTimeout(this._hideSubmenuTimer);
                    this._hideSubmenuTimer = setTimeout(function() {
                        that._hideSubmenuAfterTimeout($item)
                    }, that._getHideDelay())
                }
            },
            _showSubmenu: function($itemElement) {
                var $submenu = this._getSubmenuElementByRootElement($itemElement);
                if (this._visibleSubmenu.length && !this._visibleSubmenu.is($submenu))
                    this._hideSubmenu(this._visibleSubmenu);
                $submenu.length && this._getSubmenuInstance($submenu).show();
                this._visibleSubmenu = $submenu;
                this._hoveredRootItem = $itemElement
            },
            _hideSubmenu: function($submenu) {
                $submenu.length && this._getSubmenuInstance($submenu).hide();
                if (this._visibleSubmenu.length && this._visibleSubmenu.is($submenu))
                    this._visibleSubmenu = [];
                this._hoveredRootItem = null
            },
            _itemMouseMoveHandler: function(e) {
                var that = this,
                    $item = $(e.currentTarget);
                if (this._showSubmenuTimer) {
                    clearTimeout(this._hideSubmenuTimer);
                    clearTimeout(this._showSubmenuTimer);
                    this._showSubmenuTimer = setTimeout(function() {
                        var submenu = that._getSubmenuInstanceByRootElement($item);
                        if (submenu && !submenu._overlay.option("visible"))
                            that._showSubmenu($item)
                    }, that._getShowDelay())
                }
            },
            _updateSubmenuVisibilityOnClick: function(actionArgs) {
                var $item,
                    item,
                    submenu,
                    args = actionArgs.args.length && actionArgs.args[0];
                if (args) {
                    args.jQueryEvent.stopPropagation();
                    item = args.itemData;
                    $item = args.itemElement;
                    if (item.disabled)
                        return;
                    submenu = this._getSubmenuInstanceByRootElement($item);
                    this._updateSelectedItemOnClick(actionArgs);
                    if (submenu)
                        if (submenu._overlay.option("visible")) {
                            if (this._getShowFirstSubmenuMode() === "onClick")
                                this._hideSubmenu(submenu.element())
                        }
                        else
                            this._showSubmenu($item);
                    else if (this._visibleSubmenu.length)
                        this._hideSubmenu(this._visibleSubmenu)
                }
            },
            _optionChanged: function(args) {
                if (this._cancelOptionChange)
                    return;
                this._hideShownSubmenuOnOptionChange(args.name);
                switch (args.name) {
                    case"selectedItems":
                        var item = args.value[0];
                        if (this._isItemInSubmenu(item)) {
                            this._syncSelectionOptions(args.name);
                            this._normalizeSelectedItems()
                        }
                        else
                            this.callBase(args);
                        break;
                    case"orientation":
                    case"submenuDirection":
                    case"hideSubmenuOnMouseLeave":
                    case"showFirstSubmenuMode":
                        this._invalidate();
                        break;
                    case"showSubmenuMode":
                        this._changeSubmenusOption(args.name, args.value);
                        break;
                    case"onSubmenuShowing":
                    case"onSubmenuShown":
                    case"onSubmenuHiding":
                    case"onSubmenuHidden":
                        this._initActions();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _hideShownSubmenuOnOptionChange: function(optionName) {
                if (optionName !== "focusedElement" && this._visibleSubmenu.length)
                    this._hideSubmenu(this._visibleSubmenu)
            },
            _changeSubmenusOption: function(name, value) {
                $.each(this._submenus, function(index, submenu) {
                    submenu.option(name, value)
                })
            },
            _isItemInSubmenu: function(item) {
                return $.inArray(JSON.stringify(item), this._getStringifiedArray(this.option("items"))) < 0
            },
            selectItem: function(itemElement) {
                var itemData = this._getItemData(itemElement);
                if (this._isItemInSubmenu(itemData))
                    $.each(this._submenus, function(index, submenu) {
                        if (submenu._isOwnItem(itemData))
                            submenu.selectItem(itemElement)
                    });
                else
                    this.callBase(itemElement)
            }
        }));
        DX.registerComponent("dxSubmenu", ui.dxMenu, dxSubmenu);
        ui.dxMenu.__internals = {}
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.treeView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            events = ui.events,
            dataUtils = DX.data.utils,
            utils = DX.utils;
        var WIDGET_CLASS = "dx-treeview",
            NODE_CONTAINER_CLASS = "dx-treeview-node-container",
            OPENED_NODE_CONTAINER_CLASS = "dx-treeview-node-container-opened",
            NODE_CLASS = "dx-treeview-node",
            ITEM_CLASS = "dx-treeview-item",
            ITEM_WITH_CHECKBOX_CLASS = "dx-treeview-item-with-checkbox",
            ITEM_DATA_KEY = "dx-treeview-item-data",
            IS_LEAF = "dx-treeview-node-is-leaf",
            TOGGLE_ITEM_VISIBILITY_CLASS = "dx-treeview-toggle-item-visibility",
            TOGGLE_ITEM_VISIBILITY_OPENED_CLASS = "dx-treeview-toggle-item-visibility-opened",
            SELECT_ALL_ITEM_CLASS = "dx-treeview-select-all-item",
            DISABLED_STATE_CLASS = "dx-state-disabled",
            SELECTED_ITEM_CLASS = "dx-state-selected",
            DATA_ITEM_ID = "data-item-id",
            DBLCLICK_EVENT_NAME = "dxdblclick";
        var scrollableContainerUpdatedOnInit = $.noop;
        DX.registerComponent("dxTreeView", ui, ui.CollectionWidget.inherit({
            _supportedKeys: function(e) {
                var click = function(e) {
                        var $itemElement = this.option("focusedElement");
                        if (!$itemElement)
                            return;
                        e.target = $itemElement;
                        e.currentTarget = $itemElement;
                        this._itemClickHandler(e, $itemElement.find(">." + ITEM_CLASS))
                    };
                var select = function(e) {
                        e.preventDefault();
                        this._changeCheckBoxState(this.option("focusedElement"))
                    };
                var toggleExpandedNestedItems = function(state, e) {
                        if (!this.option("expandAllEnabled"))
                            return;
                        e.preventDefault();
                        var $rootElement = this.option("focusedElement");
                        if (!$rootElement)
                            return;
                        var rootItem = this._getItemData($rootElement.find("." + ITEM_CLASS));
                        this._toggleExpandedNestedItems([rootItem], state)
                    };
                return $.extend(this.callBase(), {
                        enter: this.option("showCheckBoxes") ? select : click,
                        space: this.option("showCheckBoxes") ? select : click,
                        asterisk: $.proxy(toggleExpandedNestedItems, this, true),
                        minus: $.proxy(toggleExpandedNestedItems, this, false)
                    })
            },
            _changeCheckBoxState: function($element) {
                var $checkbox = $element.find("> .dx-checkbox");
                var checkboxInstance = $checkbox.dxCheckBox("instance"),
                    currentState = checkboxInstance.option("value");
                if (!checkboxInstance.option("disabled"))
                    this._updateItemSelection(!currentState, $element.find("." + ITEM_CLASS).get(0), true, $element)
            },
            _toggleExpandedNestedItems: function(items, state) {
                if (!items)
                    return;
                for (var i = 0, len = items.length; i < len; i++) {
                    var item = items[i];
                    this._toggleExpandedState(item, state);
                    this._toggleExpandedNestedItems(item.items, state)
                }
            },
            _getNodeElementById: function(id) {
                return this.element().find("[" + DATA_ITEM_ID + "='" + id + "']")
            },
            _activeStateUnit: "." + ITEM_CLASS,
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    animationEnabled: true,
                    dataStructure: "tree",
                    expandedItems: [],
                    expandAllEnabled: false,
                    keyExpr: "id",
                    displayExpr: "text",
                    selectedExpr: "selected",
                    expandedExpr: "expanded",
                    disabledExpr: "disabled",
                    itemsExpr: "items",
                    parentIdExpr: "parentId",
                    hasItemsExpr: "hasItems",
                    showCheckBoxes: false,
                    selectNodesRecursive: true,
                    selectAllEnabled: false,
                    selectAllText: Globalize.localize("dxList-selectAll"),
                    onItemSelected: null,
                    onItemExpanded: null,
                    onItemCollapsed: null,
                    scrollDirection: "vertical",
                    virtualModeEnabled: false,
                    rootValue: 0,
                    focusStateEnabled: false,
                    selectionMode: "multi"
                })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    selectedItems: {
                        since: "14.2",
                        message: "Use item.selected instead"
                    },
                    expandedItems: {
                        since: "14.2",
                        message: "Use item.expanded instead"
                    }
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {
                                hoverStateEnabled: true,
                                focusStateEnabled: true
                            }
                        }])
            },
            _initSelectedItems: $.noop,
            _syncSelectionOptions: $.noop,
            _fireSelectionChanged: function() {
                var selectionChangePromise = this._selectionChangePromise;
                $.when(selectionChangePromise).done($.proxy(function() {
                    this._createActionByOption("onSelectionChanged", {excludeValidators: ["disabled", "readOnly"]})()
                }, this))
            },
            _initExpressions: function() {
                this._compileKeyAccessors();
                this._compileDisplayAccessors();
                this._compileSelectedAccessors();
                this._compileExpandedAccessors();
                this._compileItemsAccessors();
                this._compileParentIdAccessors();
                this._compileDisabledAccessors();
                this._compileHasItemsAccessors()
            },
            _initDynamicTemplates: function() {
                var displayExpr = this.option("displayExpr");
                if (displayExpr !== "text" && displayExpr !== "html")
                    this._dynamicTemplates["item"] = new ui.DefaultTemplate($.proxy(function(itemData) {
                        var $itemContent = $("<div>"),
                            icon = itemData.icon || itemData.iconSrc;
                        if (icon)
                            utils.getImageContainer(icon).appendTo($itemContent);
                        $("<span>").text(this._displayGetter(itemData)).appendTo($itemContent);
                        return $itemContent
                    }, this));
                else
                    delete this._dynamicTemplates["item"]
            },
            _compileKeyAccessors: function() {
                this._keyGetter = dataUtils.compileGetter(this.option("keyExpr"));
                this._keySetter = dataUtils.compileSetter(this.option("keyExpr"))
            },
            _compileDisplayAccessors: function() {
                this._displayGetter = dataUtils.compileGetter(this.option("displayExpr"));
                this._displaySetter = dataUtils.compileSetter(this.option("displayExpr"))
            },
            _compileSelectedAccessors: function() {
                this._selectedGetter = dataUtils.compileGetter(this.option("selectedExpr"));
                this._selectedSetter = dataUtils.compileSetter(this.option("selectedExpr"))
            },
            _compileExpandedAccessors: function() {
                this._expandedGetter = dataUtils.compileGetter(this.option("expandedExpr"));
                this._expandedSetter = dataUtils.compileSetter(this.option("expandedExpr"))
            },
            _compileItemsAccessors: function() {
                this._itemsGetter = dataUtils.compileGetter(this.option("itemsExpr"));
                this._itemsSetter = dataUtils.compileSetter(this.option("itemsExpr"))
            },
            _compileParentIdAccessors: function() {
                this._parentIdGetter = dataUtils.compileGetter(this.option("parentIdExpr"));
                this._parentIdSetter = dataUtils.compileSetter(this.option("parentIdExpr"))
            },
            _compileDisabledAccessors: function() {
                this._disabledGetter = dataUtils.compileGetter(this.option("disabledExpr"));
                this._disabledSetter = dataUtils.compileSetter(this.option("disabledExpr"))
            },
            _compileHasItemsAccessors: function() {
                this._hasItemsGetter = dataUtils.compileGetter(this.option("hasItemsExpr"));
                this._hasItemsSetter = dataUtils.compileSetter(this.option("hasItemsExpr"))
            },
            _optionChanged: function(args) {
                var name = args.name,
                    value = args.value;
                switch (name) {
                    case"selectAllEnabled":
                        if (value) {
                            if (!this._$selectAllItem || !this._$selectAllItem.length)
                                this._renderSelectAllItem()
                        }
                        else if (this._$selectAllItem) {
                            this._$selectAllItem.remove();
                            delete this._$selectAllItem
                        }
                        break;
                    case"selectAllText":
                        if (this._$selectAllItem)
                            this._$selectAllItem.dxCheckBox("instance").option("text", value);
                        break;
                    case"scrollDirection":
                        this._scrollableContainer.option("direction", value);
                        break;
                    case"selectedItems":
                        if (this._$selectAllItem) {
                            var selectAllItem = this._$selectAllItem.dxCheckBox("instance"),
                                selectAllItemValue = selectAllItem.option("value");
                            if (selectAllItemValue && this._itemsCount === value.length)
                                return;
                            this._suppressUpdateSelectAllItemValue = true;
                            selectAllItem.option("value", this._calculateSelectAllItemValue());
                            this._suppressUpdateSelectAllItemValue = false
                        }
                        break;
                    case"items":
                        this._suppressDeprecatedWarnings();
                        delete this._$selectAllItem;
                        if (this.option("selectedItems").length)
                            this.option("selectedItems", []);
                        if (this.option("expandedItems").length)
                            this.option("expandedItems", []);
                        this.callBase(args);
                        this._resumeDeprecatedWarnings();
                        break;
                    case"keyExpr":
                    case"displayExpr":
                        if (!this._dynamicTemplates["item"])
                            this._initDynamicTemplates();
                        this._initExpressions();
                        this.repaint();
                        break;
                    case"itemsExpr":
                    case"selectedExpr":
                    case"expandedExpr":
                    case"parentIdExpr":
                    case"disabledExpr":
                    case"hasItemsExpr":
                        this._initExpressions();
                        this.repaint();
                        break;
                    case"dataStructure":
                    case"showCheckBoxes":
                    case"rootValue":
                        this.repaint();
                        break;
                    case"expandedItems":
                        var isFocused = this._hasFocusClass(this.element());
                        this.repaint();
                        if (isFocused) {
                            this.element().focus();
                            var key = this.option("focusedElement").attr(DATA_ITEM_ID);
                            var $node = this._getNodeElementById(key);
                            this.option("focusedElement", $node)
                        }
                        break;
                    case"selectNodesRecursive":
                    case"onItemSelected":
                    case"onItemExpanded":
                    case"onItemCollapsed":
                    case"expandAllEnabled":
                    case"animationEnabled":
                    case"virtualModeEnabled":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _nodes: [],
            _initDataSource: function() {
                this.callBase();
                if (this._isVirtualMode())
                    this._dataSource.filter(this.option("parentIdExpr"), this.option("rootValue"))
            },
            _dataSourceLoadErrorHandler: function() {
                this._renderEmptyMessage()
            },
            _init: function() {
                this._initExpressions();
                this.callBase();
                this._initDynamicTemplates()
            },
            _render: function() {
                if (this._isVirtualMode() && this._dataSource && !this._dataSource.items().length) {
                    this._initialized = false;
                    return
                }
                var that = this;
                this.element().addClass(WIDGET_CLASS);
                this._itemsCount = 0;
                this.element().off("dxpointerdown").on("dxpointerdown", function(e) {
                    var $target = $(e.target).closest(that._activeStateUnit);
                    if (!$target.length)
                        e.preventDefault()
                });
                this._makeNodes();
                this._setKeyForItems(this._nodes, 1);
                this.callBase();
                this.setAria("role", "tree")
            },
            _makeNodes: function() {
                this._nodes = this._getSmartItemsCopy(this.option("items"));
                if (this.option("dataStructure") === "plain")
                    this._nodes = this._createHierarchicalStructure(this._nodes)
            },
            _getSmartItemsCopy: function(items) {
                var that = this,
                    result = [];
                $.each(items, function(_, item) {
                    var itemCopy = $.extend(true, {}, item);
                    if (that._itemHasChildren(itemCopy)) {
                        var children = that._itemsGetter(itemCopy);
                        var childrenCopy = that._getSmartItemsCopy(children);
                        that._itemsSetter(itemCopy, childrenCopy)
                    }
                    result.push(itemCopy)
                });
                return result
            },
            _setKeyForItems: function(items, startKey) {
                var that = this;
                $.each(items, function(index, item) {
                    if (that._isPrimitiveValue(item))
                        item = that._makeObjectFromPrimitive(item);
                    if (utils.isDefined(that._keyGetter(item)))
                        return false;
                    that._keySetter(item, startKey);
                    startKey++;
                    if (that._itemHasChildren(item))
                        startKey = that._setKeyForItems(that._itemsGetter(item), startKey)
                });
                return startKey
            },
            _makePlainItems: function() {
                return this._makePlainList(this.option("items"), null, true)
            },
            _makePlainNodes: function() {
                return this._makePlainList(this._nodes, null, true)
            },
            _updateSelectionItemsOption: function() {
                var that = this,
                    selectedItems = [];
                $.each(that._plainItems, function(_, item) {
                    if (that._selectedGetter(item))
                        selectedItems.push(item)
                });
                return selectedItems
            },
            _renderContentImpl: function() {
                var items = this._nodes;
                if (items.length) {
                    this._makePlainStructures();
                    this._applyExpandedItemsFromOption();
                    this._applySelectedItemsFromOption(items);
                    var plainList = this._makePlainList(items, null);
                    if (this.option("selectNodesRecursive")) {
                        items = this._calculateChildrenSelectedState(items);
                        this._calculateParentSelectedState(plainList)
                    }
                    this._calculateParentExpandedState(plainList);
                    this._createParentFieldForEachItem(items);
                    this._suppressDeprecatedWarnings();
                    var selectedItems = this._updateSelectionItemsOption();
                    if (selectedItems.length)
                        this.option("selectedItems", selectedItems);
                    this._resumeDeprecatedWarnings();
                    this._renderScrollableContainer();
                    var $nodeContainer = this._renderNodeContainer();
                    this._scrollableContainer.content().append($nodeContainer);
                    this._renderItems($nodeContainer, items, true);
                    if (this.option("selectAllEnabled"))
                        this._renderSelectAllItem($nodeContainer)
                }
                this._renderEmptyMessage()
            },
            _makePlainStructures: function() {
                this._startIndex = 1;
                this._plainItems = this._makePlainItems();
                this._startIndex = 1;
                this._plainNodes = this._makePlainNodes()
            },
            _isVirtualMode: function() {
                return this.option("virtualModeEnabled") && this.option("dataSource")
            },
            _fireContentReadyAction: function() {
                this.callBase();
                if (this._scrollableContainer && this._scrollableContainer.content().height() > this.element().height()) {
                    this._scrollableContainer.update();
                    scrollableContainerUpdatedOnInit()
                }
            },
            _createHierarchicalStructure: function(items) {
                var result = [],
                    lookup = {},
                    itemCount = items.length,
                    i;
                for (i = 0; i < itemCount; i++) {
                    lookup[this._keyGetter(items[i])] = items[i];
                    this._itemsSetter(items[i], [])
                }
                for (i = 0; i < itemCount; i++) {
                    var parentId = this._parentIdGetter(items[i]),
                        node = this._createNode(items[i]);
                    if (parentId) {
                        var children = this._itemsGetter(lookup[parentId]);
                        children.push(node)
                    }
                    else
                        result.push(node)
                }
                return result
            },
            _createNode: function(itemData) {
                var node = {};
                this._keySetter(node, this._keyGetter(itemData));
                this._displaySetter(node, this._displayGetter(itemData));
                this._itemsSetter(node, this._itemsGetter(itemData));
                this._expandedSetter(node, this._expandedGetter(itemData));
                this._disabledSetter(node, this._disabledGetter(itemData));
                if (itemData.hasOwnProperty(this.option("selectedExpr")) && typeof this._selectedGetter(itemData) !== "undefined")
                    this._selectedSetter(node, this._selectedGetter(itemData));
                else
                    this._selectedSetter(node, false);
                return node
            },
            _createParentFieldForEachItem: function(items, parent) {
                var that = this;
                parent = parent ? $.extend(true, {}, parent) : null;
                $.each(items, function(_, item) {
                    that._itemsCount++;
                    if (utils.isDefined(parent) && that._itemsGetter(parent))
                        that._itemsSetter(parent, null);
                    if (that._isPrimitiveValue(item))
                        item = that._makeObjectFromPrimitive(item);
                    item.parent = parent;
                    that._plainNodes[that._keyGetter(item)].parent = parent;
                    if (that._itemHasChildren(item))
                        that._createParentFieldForEachItem(that._itemsGetter(item), item)
                })
            },
            _makeObjectFromPrimitive: function(item) {
                var key = item;
                item = {};
                this._keySetter(item, key);
                return item
            },
            _isPrimitiveValue: function(value) {
                return $.inArray($.type(value), ["object", "array", "function"]) === -1
            },
            _itemHasChildren: function(item) {
                var items = this._itemsGetter(item);
                return items && items.length
            },
            _renderScrollableContainer: function() {
                this._scrollableContainer = this._createComponent($("<div>").appendTo(this.element()), "dxScrollable", {
                    direction: this.option("scrollDirection"),
                    useKeyboard: false
                })
            },
            _renderNodeContainer: function($parent) {
                var $container = $("<ul>").addClass(NODE_CONTAINER_CLASS);
                this.setAria("role", "group", $container);
                if ($parent) {
                    var itemData = this._getItemData($parent.find("> ." + ITEM_CLASS));
                    if (this._expandedGetter(itemData))
                        $container.addClass(OPENED_NODE_CONTAINER_CLASS);
                    $container.appendTo($parent)
                }
                return $container
            },
            _renderAria: function($node, sourceItem) {
                var ariaExpanded = this._expandedGetter(sourceItem) || "false";
                if (this.option("dataStructure") === "tree")
                    ariaExpanded = this._itemsGetter(sourceItem) && ariaExpanded;
                this.setAria({
                    role: "treeitem",
                    label: this._displayGetter(sourceItem) || "",
                    expanded: ariaExpanded
                }, $node)
            },
            _renderItems: function($nodeContainer, items) {
                var that = this,
                    showCheckBoxes = that.option("showCheckBoxes");
                $.each(items, function(i, item) {
                    if (that._isPrimitiveValue(item))
                        item = that._makeObjectFromPrimitive(item);
                    var key = that._keyGetter(item);
                    var $node = $("<li>").addClass(NODE_CLASS).appendTo($nodeContainer).attr(DATA_ITEM_ID, key);
                    var sourceItem = that._getSourceItemByKey(key);
                    that._renderAria($node, sourceItem);
                    if (showCheckBoxes)
                        that._renderCheckBox($node, item);
                    var $item = that._renderItem.call(that, i, sourceItem, $node);
                    that._attachDblclickToItem($item);
                    if (that._hasItemsGetter(sourceItem) !== false) {
                        if (that._isVirtualMode()) {
                            that._renderToggleItemVisibilityIcon($node, item);
                            that._renderNodeContainer($node);
                            return
                        }
                        var nestedItems = that._itemsGetter(item);
                        if (nestedItems && $.isArray(nestedItems) && nestedItems.length) {
                            that._renderToggleItemVisibilityIcon($node, item);
                            var $nestedNodeContainer = that._renderNodeContainer($node);
                            if (that._expandedGetter(item)) {
                                that._renderItems($nestedNodeContainer, nestedItems, false);
                                $nestedNodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS)
                            }
                        }
                        else
                            that._addLeafClass($node)
                    }
                    else
                        that._addLeafClass($node)
                });
                this._renderFocusTarget()
            },
            _executeItemRenderAction: function(index, itemData, itemElement) {
                var node = this._getNodeByKey(this._getItemKey(itemData));
                this._getItemRenderAction()({
                    itemElement: itemElement,
                    itemIndex: index,
                    itemData: itemData,
                    node: node
                })
            },
            _addLeafClass: function($node) {
                $node.addClass(IS_LEAF)
            },
            _attachDblclickToItem: function($item) {
                var that = this,
                    eventName = events.addNamespace(DBLCLICK_EVENT_NAME, that.NAME);
                $item.off(eventName).on(eventName, function(e) {
                    var itemData = that._getItemData($item);
                    that._toggleExpandedState(itemData, undefined, e)
                })
            },
            _toggleExpandedState: function(itemData, state, e) {
                if (this._isVirtualMode()) {
                    var $node = this._getNodeElementById(this._getItemKey(itemData));
                    this._createLoadIndicator($node)
                }
                var currentState = this._expandedGetter(itemData);
                if (this._disabledGetter(itemData))
                    return;
                if (utils.isDefined(currentState) && currentState === state)
                    return;
                if (!utils.isDefined(state))
                    state = !currentState;
                this._updateExpandedState(itemData, state);
                this._updateExpandedItemsUI(itemData, state, e)
            },
            _createLoadIndicator: function($node) {
                var $icon = $node.find(">." + TOGGLE_ITEM_VISIBILITY_CLASS),
                    $nodeContainer = $node.find(" > ." + NODE_CONTAINER_CLASS);
                if (!$icon.hasClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS) && $nodeContainer.is(":empty")) {
                    this._createComponent("<div>", "dxLoadIndicator", {}).element().appendTo($node);
                    $icon.css("display", "none")
                }
            },
            _getSourceItemByKey: function(key) {
                return this._plainItems[key]
            },
            _getItemKey: function(itemData) {
                var result = this._keyGetter(itemData);
                if (!utils.isDefined(result))
                    result = this._getKeyForSourceItem(itemData);
                return result
            },
            _getKeyForSourceItem: function(itemData) {
                var result = null;
                $.each(this._plainItems, function(key, item) {
                    if (itemData === item) {
                        result = key;
                        return false
                    }
                });
                return result
            },
            _getNodeByKey: function(key) {
                return this._plainNodes[key]
            },
            _renderSelectAllItem: function($container) {
                $container = $container || this.element().find("." + NODE_CONTAINER_CLASS).first();
                this._$selectAllItem = $("<div>").addClass(SELECT_ALL_ITEM_CLASS);
                var value = this._calculateSelectAllItemValue();
                this._createComponent(this._$selectAllItem, "dxCheckBox", {
                    value: value,
                    text: this.option("selectAllText"),
                    onValueChanged: $.proxy(this._toggleSelectAll, this)
                });
                this._toggleSelectedClass(this._$selectAllItem, value);
                $container.before(this._$selectAllItem)
            },
            _calculateSelectAllItemValue: function() {
                this._suppressDeprecatedWarnings();
                var result = false,
                    selectedItemsCount = this.option("selectedItems").length;
                if (selectedItemsCount)
                    result = this._itemsCount === selectedItemsCount ? true : undefined;
                this._resumeDeprecatedWarnings();
                return result
            },
            _toggleSelectAll: function(args) {
                if (!this._suppressUpdateSelectAllItemValue) {
                    this._suppressDeprecatedWarnings();
                    this._updateAllItems(this._nodes, args.value);
                    if (!args.value)
                        this.option("selectedItems", []);
                    else {
                        var selectedItems = this._updateSelectionItemsOption();
                        this.option("selectedItems", selectedItems)
                    }
                    this._resumeDeprecatedWarnings();
                    this._fireSelectionChanged()
                }
            },
            _updateAllItems: function(nodes, value) {
                var that = this;
                $.each(nodes, function(_, node) {
                    var $node = that._getNodeElementById(that._keyGetter(node));
                    var itemData = that._getSourceItemByKey(that._keyGetter(node)),
                        currentState = that._selectedGetter(node);
                    if (currentState === value)
                        return true;
                    if ($node.length) {
                        $node.find("> .dx-checkbox").dxCheckBox("instance").option("value", value);
                        that._toggleSelectedClass($node, value)
                    }
                    that._commonSelectedSetter(itemData, node, value);
                    $node = null;
                    if (that._itemHasChildren(node))
                        that._updateAllItems(that._itemsGetter(node), value)
                })
            },
            _applySelectedItemsFromOption: function(items) {
                var that = this;
                this._suppressDeprecatedWarnings();
                $.each(this.option("selectedItems"), function(_, item) {
                    var currentItem = that._getItemFromArray(item, items);
                    if (currentItem) {
                        var currentNode = that._getNodeByKey(that._keyGetter(currentItem));
                        that._commonSelectedSetter(currentItem, currentNode, true)
                    }
                    var node = that._getNodeByKey(that._getItemKey(item));
                    that._commonSelectedSetter(item, node, true)
                });
                this._resumeDeprecatedWarnings()
            },
            _applyExpandedItemsFromOption: function() {
                var that = this;
                this._suppressDeprecatedWarnings();
                $.each(this.option("expandedItems"), function(_, item) {
                    var node = that._getNodeByKey(that._getItemKey(item));
                    that._commonExpandedSetter(item, node, true)
                });
                this._resumeDeprecatedWarnings()
            },
            _commonExpandedSetter: function(item, node, value) {
                this._expandedSetter(item, value);
                this._expandedSetter(node, value)
            },
            _commonSelectedSetter: function(item, node, value) {
                this._selectedSetter(item, value);
                this._selectedSetter(node, value)
            },
            _calculateChildrenSelectedState: function(items) {
                var that = this;
                $.each(items, function(_, item) {
                    if (that._selectedGetter(item))
                        if (that._itemHasChildren(item))
                            $.each(that._itemsGetter(item), function(_, child) {
                                var sourceItem = that._getSourceItemByKey(that._keyGetter(child));
                                that._commonSelectedSetter(sourceItem, child, true)
                            });
                    if (that._itemHasChildren(item))
                        that._itemsSetter(item, that._calculateChildrenSelectedState(that._itemsGetter(item)))
                });
                return items
            },
            _makePlainList: function(items, plainList, makeHash) {
                var that = this,
                    dataStructure = makeHash ? {} : [];
                plainList = plainList || dataStructure;
                $.each(items, function(_, item) {
                    if (makeHash) {
                        if (that._isPrimitiveValue(item))
                            item = that._makeObjectFromPrimitive(item);
                        var index = that._keyGetter(item);
                        if (!utils.isDefined(index))
                            index = that._startIndex;
                        plainList[index] = item;
                        that._startIndex++
                    }
                    else
                        plainList.push(item);
                    if (that._itemHasChildren(item))
                        that._makePlainList(that._itemsGetter(item), plainList, makeHash)
                });
                return plainList
            },
            _calculateParentSelectedState: function(list) {
                var listSize = list.length - 1,
                    that = this;
                function isSelected(child) {
                    return that._selectedGetter(child) === true
                }
                function isIntermediate(child) {
                    return child.hasOwnProperty(that.option("selectedExpr")) && typeof that._selectedGetter(child) === "undefined"
                }
                for (var i = listSize; i >= 0; i--) {
                    if (this._selectedGetter(list[i]))
                        continue;
                    var children = this._itemsGetter(list[i]);
                    if (children && children.length) {
                        var selectedChildren = $.grep(children, isSelected),
                            indeterminateChildren = $.grep(children, isIntermediate),
                            sourceItem = this._getSourceItemByKey(this._keyGetter(list[i])),
                            selected = false;
                        if (selectedChildren.length)
                            selected = selectedChildren.length === children.length ? true : undefined;
                        else if (indeterminateChildren.length)
                            selected = undefined;
                        that._commonSelectedSetter(list[i], sourceItem, selected)
                    }
                }
                return list
            },
            _calculateParentExpandedState: function(list) {
                var listSize = list.length - 1,
                    that = this;
                function isExpanded(child) {
                    return that._expandedGetter(child) === true
                }
                for (var i = listSize; i >= 0; i--) {
                    if (this._expandedGetter(list[i]))
                        continue;
                    var children = this._itemsGetter(list[i]);
                    if (children && children.length) {
                        var expandedChildren = $.grep(children, isExpanded);
                        if (expandedChildren.length) {
                            var sourceItem = this._getSourceItemByKey(this._keyGetter(list[i]));
                            this._commonExpandedSetter(list[i], sourceItem, true)
                        }
                    }
                }
            },
            _renderCheckBox: function($node, node) {
                var checkBoxValue = this._calculateCheckBoxValue(node);
                $node.addClass(ITEM_WITH_CHECKBOX_CLASS);
                this.setAria("selected", checkBoxValue, $node);
                var $checkbox = $("<div>").appendTo($node);
                this._createComponent($checkbox, "dxCheckBox", {
                    value: checkBoxValue,
                    onValueChanged: $.proxy(this._changeCheckboxValue, this),
                    focusStateEnabled: false,
                    disabled: this._disabledGetter(node)
                });
                if (checkBoxValue !== false)
                    this._toggleSelectedClass($node, checkBoxValue);
                this._attachCheckboxClick($checkbox, node)
            },
            _toggleSelectedClass: function($node, value) {
                $node.toggleClass(SELECTED_ITEM_CLASS, !!value)
            },
            _attachCheckboxClick: function($checkbox, node) {
                var eventName = events.addNamespace("dxclick", this.NAME),
                    key = this._keyGetter(node);
                var handleItemSelected = function(e) {
                        this._itemJQueryEventHandler(e, "onItemSelected", {node: this._getNodeByKey(key)})
                    };
                $checkbox.off(eventName).on(eventName, $.proxy(handleItemSelected, this))
            },
            _renderToggleItemVisibilityIcon: function($node, itemData) {
                var $icon = $("<div>").addClass(TOGGLE_ITEM_VISIBILITY_CLASS).appendTo($node);
                if (this._expandedGetter(itemData) && !this._isVirtualMode()) {
                    $icon.addClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS);
                    $node.parent().addClass(OPENED_NODE_CONTAINER_CLASS)
                }
                if (this._disabledGetter(itemData))
                    $icon.addClass(DISABLED_STATE_CLASS);
                this._renderToggleItemVisibilityIconClick($icon, itemData)
            },
            _renderToggleItemVisibilityIconClick: function($icon, itemData) {
                var eventName = events.addNamespace("dxclick", this.NAME),
                    that = this;
                $icon.off(eventName).on(eventName, function(e) {
                    var $item = $icon.parent().find(">." + ITEM_CLASS),
                        itemData = that._getItemData($item);
                    that._toggleExpandedState(itemData, undefined, e)
                })
            },
            _updateExpandedState: function(itemData, isExpanded) {
                this._suppressDeprecatedWarnings();
                var expandedItems = this.option("expandedItems"),
                    key = this._getItemKey(itemData),
                    node = this._getNodeByKey(key),
                    that = this;
                that._commonExpandedSetter(itemData, node, isExpanded);
                if (isExpanded) {
                    if (!that._getItemFromArray(itemData, expandedItems))
                        expandedItems.push(itemData)
                }
                else
                    $.each(expandedItems, function(i, item) {
                        if (that._keyGetter(item) === key) {
                            expandedItems.splice(i, 1);
                            return false
                        }
                    });
                this._resumeDeprecatedWarnings()
            },
            _updateExpandedItemsUI: function(itemData, state, e) {
                var $node = this._getNodeElementById(this._getItemKey(itemData)),
                    $icon = $node.find(">." + TOGGLE_ITEM_VISIBILITY_CLASS),
                    $nodeContainer = $node.find(" > ." + NODE_CONTAINER_CLASS);
                $icon.toggleClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS, state);
                if (state)
                    this._renderNestedItems($nodeContainer).done($.proxy(function(itemsLoaded) {
                        if (itemsLoaded) {
                            this.setAria("expanded", state, $node);
                            this._fireExpandedStateUpdatedEvt(state, itemData, e)
                        }
                        this._animateNodeContainer($nodeContainer, state)
                    }, this));
                else {
                    this.setAria("expanded", state, $node);
                    this._animateNodeContainer($nodeContainer, state);
                    this._fireExpandedStateUpdatedEvt(state, itemData, e)
                }
            },
            _animateNodeContainer: function($nodeContainer, state) {
                var nodeHeight = $nodeContainer.height();
                DX.fx.stop($nodeContainer, true);
                DX.fx.animate($nodeContainer, {
                    type: "custom",
                    duration: this.option("animationEnabled") ? 400 : 0,
                    from: {"max-height": state ? 0 : nodeHeight},
                    to: {"max-height": state ? nodeHeight : 0},
                    start: function() {
                        $nodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS)
                    },
                    complete: $.proxy(function() {
                        $nodeContainer.css("max-height", "none");
                        $nodeContainer.toggleClass(OPENED_NODE_CONTAINER_CLASS, state);
                        this._scrollableContainer.update()
                    }, this)
                })
            },
            _fireExpandedStateUpdatedEvt: function(isExpanded, itemData, e) {
                var optionName = isExpanded ? "onItemExpanded" : "onItemCollapsed",
                    itemKey = this._getItemKey(itemData),
                    node = this._getNodeByKey(itemKey),
                    target;
                var handler = this.option(optionName);
                if (handler)
                    if (utils.isDefined(e))
                        this._itemJQueryEventHandler(e, optionName, {node: node});
                    else {
                        target = this._itemElements().eq(itemKey - 1);
                        this._itemEventHandler(target, optionName, {
                            jQueryEvent: e,
                            node: node
                        })
                    }
            },
            _getParentById: function(nodes, id) {
                var parent;
                $.each(nodes, function(_, node) {
                    if (node.id === id)
                        parent = node;
                    return
                });
                return parent
            },
            _renderNestedItems: function($container) {
                if (!$container.is(":empty"))
                    return $.Deferred().resolve(true).promise();
                var itemElement = $container.parent().find(">." + ITEM_CLASS),
                    itemData = this._getItemData(itemElement),
                    itemKey = this._getItemKey(itemData),
                    node = this._getNodeByKey(itemKey),
                    d = $.Deferred();
                if (this._isVirtualMode())
                    this._renderVirtualNodes($container).done(function(items) {
                        d.resolve(items && items.length)
                    });
                else {
                    this._renderItems($container, this._itemsGetter(node), false);
                    d.resolve(true)
                }
                return d.promise()
            },
            _renderVirtualNodes: function($container) {
                var itemElement = $container.parent().find(">." + ITEM_CLASS),
                    itemData = this._getItemData(itemElement),
                    itemKey = this._getItemKey(itemData),
                    that = this;
                this._dataSource.filter([this.option("parentIdExpr"), itemKey]);
                return this._dataSource.load().done(function(data) {
                        var virtualItems = [];
                        $.each(data, function(_, item) {
                            virtualItems.push(that._createNode(item))
                        });
                        that._renderItems($container, virtualItems, false);
                        if (virtualItems.length && !that._selectedGetter(itemData)) {
                            var firstItemKey = that._keyGetter(virtualItems[0]),
                                $firstChild = that._getNodeElementById(firstItemKey);
                            that._updateParentsState(that._getNodeByKey(firstItemKey), $firstChild)
                        }
                        that._normalizeIconState(itemElement, virtualItems.length)
                    })
            },
            _normalizeIconState: function(itemElement, hasNewItems) {
                var $loadIndicator = itemElement.siblings(".dx-loadindicator"),
                    $icon = itemElement.siblings("." + TOGGLE_ITEM_VISIBILITY_CLASS);
                $loadIndicator.dxLoadIndicator("instance").option("visible", false);
                if (!hasNewItems) {
                    itemElement.siblings("." + TOGGLE_ITEM_VISIBILITY_CLASS).removeClass(TOGGLE_ITEM_VISIBILITY_CLASS);
                    itemElement.parent().addClass(IS_LEAF)
                }
                else
                    $icon.css("display", "block")
            },
            _dataSourceChangedHandler: function(newItems) {
                if (this._initialized && this._isVirtualMode()) {
                    this.option().items = this.option("items").concat(newItems);
                    this._updateNodesFields(newItems)
                }
                else
                    this.option("items", newItems)
            },
            _updateNodes: function() {
                this._makeNodes();
                this._makePlainStructures()
            },
            _calculateCheckBoxValue: function(itemData) {
                var result;
                if (this._isVirtualMode())
                    result = !!itemData.selected;
                else
                    result = itemData.hasOwnProperty(this.option("selectedExpr")) ? this._selectedGetter(itemData) : false;
                return result
            },
            _changeCheckboxValue: function(e) {
                if (this._isVirtualMode())
                    this._updateNodesFields();
                var $node = e.element.parent("." + NODE_CLASS),
                    itemData = this._getItemData($node.find("> ." + ITEM_CLASS)),
                    value = e.value,
                    key = this._getItemKey(itemData),
                    node = this._getNodeByKey(key);
                this._commonSelectedSetter(itemData, node, value);
                this._toggleSelectedClass($node, value);
                this.setAria("selected", value, $node);
                if (e.jQueryEvent && !this.option("selectNodesRecursive"))
                    this._fireSelectionChanged();
                if (!e.jQueryEvent || !this.option("selectNodesRecursive"))
                    return;
                this._updateParentsAndChildren(node, value, false, $node)
            },
            _updateNodesFields: function(newItems) {
                if (this._isVirtualMode()) {
                    var parentId = this._dataSource.filter() && this._dataSource.filter()[1];
                    if (parentId && parentId !== this.option("rootValue")) {
                        var parentNode = this._getNodeByKey(parentId),
                            selectNodesRecursive = this.option("selectNodesRecursive");
                        if (newItems && newItems.length)
                            this._itemsSetter(parentNode, newItems);
                        this._updateNodes();
                        if (newItems && this._selectedGetter(parentNode)) {
                            if (selectNodesRecursive)
                                $.each(newItems, $.proxy(function(_, item) {
                                    this._selectedSetter(item, true)
                                }, this))
                        }
                        else {
                            if (selectNodesRecursive)
                                this._calculateParentSelectedState(this._makePlainList(this._nodes, null));
                            this._createParentFieldForEachItem(this._nodes)
                        }
                    }
                }
            },
            _updateParentsAndChildren: function(node, childValue, suppressOnSelectionChanged, $node) {
                if (node.parent && node.parent !== null)
                    this._updateParentsState(node, $node);
                if (this._itemHasChildren(node))
                    this._updateChildrenState(this._itemsGetter(node), childValue, $node);
                this._suppressDeprecatedWarnings();
                var selectedItems = this._updateSelectionItemsOption();
                this.option("selectedItems", selectedItems);
                this._resumeDeprecatedWarnings();
                if (!suppressOnSelectionChanged)
                    this._fireSelectionChanged()
            },
            _getItemFromArray: function(itemData, data) {
                var result = null,
                    that = this,
                    key = that._keyGetter(itemData);
                $.each(data, function(_, item) {
                    if (key === that._keyGetter(item)) {
                        result = item;
                        return false
                    }
                });
                return result
            },
            _calculateSelectedItemsOption: function(value, itemData) {
                var key = this._getItemKey(itemData),
                    node = this._getNodeByKey(key);
                this._commonSelectedSetter(itemData, node, value)
            },
            _reduceSelectedItemsOption: function(selectedItems, itemData) {
                var that = this,
                    itemDataKey = that._keyGetter(itemData);
                $.each(selectedItems, function(index, item) {
                    if (itemDataKey === that._keyGetter(item))
                        return false
                })
            },
            _updateParentsState: function(node, $node) {
                var parentNode = this._getNodeByKey(this._keyGetter(node.parent)),
                    $parentNode,
                    that = this;
                $.each(this._itemsGetter(parentNode), function(_, item) {
                    if (that._keyGetter(node) === that._keyGetter(item))
                        that._selectedSetter(item, that._selectedGetter(node))
                });
                var nodesCount = this._itemsGetter(parentNode).length,
                    selectedNodesCount = this._getSelectedChildrenFromNode(parentNode),
                    intermediateNodesCount = this._getIntermediateChildrenFromNode(parentNode),
                    parentValue;
                if (selectedNodesCount === nodesCount)
                    parentValue = true;
                else if (!selectedNodesCount && !intermediateNodesCount)
                    parentValue = false;
                if ($node && this.option("showCheckBoxes")) {
                    $parentNode = $($node.parents("." + NODE_CLASS)[0]);
                    $parentNode.find("> .dx-checkbox").dxCheckBox("instance").option("value", parentValue);
                    this._toggleSelectedClass($parentNode, parentValue)
                }
                this._updateParentField(node, parentValue);
                this._selectedSetter(parentNode, parentValue);
                if (parentNode.parent)
                    this._updateParentsState(parentNode, $parentNode);
                this._calculateSelectedItemsOption(parentValue, this._getSourceItemByKey(this._keyGetter(node.parent)))
            },
            _getSelectedChildrenFromNode: function(node) {
                var items = this._itemsGetter(node),
                    that = this;
                if (items && items.length)
                    return $.grep(items, function(item) {
                            return that._selectedGetter(item) === true
                        }).length;
                return 0
            },
            _getIntermediateChildrenFromNode: function(node) {
                var items = this._itemsGetter(node),
                    that = this;
                if (items && items.length)
                    return $.grep(items, function(item) {
                            return item.hasOwnProperty(that.option("selectedExpr")) && that._selectedGetter(item) === undefined
                        }).length;
                return 0
            },
            _updateChildrenState: function(childNodes, value, $node) {
                var that = this;
                $.each(childNodes, function(_, childNode) {
                    var itemData = that._getSourceItemByKey(that._keyGetter(childNode));
                    that._updateParentField(childNode, value);
                    that._calculateSelectedItemsOption(value, itemData);
                    if (that._itemHasChildren(childNode))
                        that._updateChildrenState(that._itemsGetter(childNode), value)
                });
                if ($node) {
                    var $childrenContainer = $node.find("> ." + NODE_CONTAINER_CLASS);
                    $childrenContainer.find("." + NODE_CLASS).each(function(_, node) {
                        var $node = $(node);
                        $($node.find(".dx-checkbox")).dxCheckBox("instance").option("value", value);
                        that._toggleSelectedClass($node, value)
                    })
                }
            },
            _updateParentField: function(node, value) {
                if (node.parent)
                    this._selectedSetter(node.parent, value)
            },
            _itemEventHandlerImpl: function(initiator, action, actionArgs) {
                var $itemElement = $(initiator).closest("." + NODE_CLASS).find("> ." + ITEM_CLASS);
                return action($.extend(this._extendActionArgs($itemElement), actionArgs))
            },
            _itemContextMenuHandler: function(e) {
                this._createEventHandler("onItemContextMenu", e)
            },
            _itemHoldHandler: function(e) {
                this._createEventHandler("onItemHold", e)
            },
            _createEventHandler: function(eventName, e) {
                var itemData = this._getItemData(e.currentTarget),
                    node = this._getNodeByKey(this._getItemKey(itemData));
                this._itemJQueryEventHandler(e, eventName, {node: node})
            },
            _itemClass: function() {
                return ITEM_CLASS
            },
            _itemDataKey: function() {
                return ITEM_DATA_KEY
            },
            _selectionEnabled: function() {
                return true
            },
            _attachClickEvent: function() {
                var that = this,
                    itemSelector = that._itemSelector(),
                    eventName = events.addNamespace("dxclick", that.NAME),
                    pointerDownEvent = events.addNamespace("dxpointerdown", this.NAME);
                that._itemContainer().off(eventName, itemSelector).on(eventName, itemSelector, function(e) {
                    that._itemClickHandler(e, $(this))
                }).off(pointerDownEvent, itemSelector).on(pointerDownEvent, itemSelector, $.proxy(this._itemPointerDownHandler, this))
            },
            _itemClickHandler: function(e, $item) {
                var itemData = this._getItemData($item),
                    node = this._getNodeByKey(this._getItemKey(itemData));
                this._itemJQueryEventHandler(e, "onItemClick", {node: node})
            },
            _updateItemSelection: function(value, itemElement, suppressOnSelectionChanged, $node) {
                var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement,
                    key = this._getItemKey(itemData),
                    node = this._getNodeByKey(key);
                if (this._disabledGetter(itemData))
                    return;
                var currentState = this._selectedGetter(node);
                if (currentState === value)
                    return;
                if (!$node) {
                    var $tmpNode = this._getNodeElementById(key);
                    if ($tmpNode.length)
                        $node = $tmpNode
                }
                if ($node) {
                    $node.find("> .dx-checkbox").dxCheckBox("instance").option("value", value);
                    this._toggleSelectedClass($($node), value)
                }
                this._commonSelectedSetter(itemData, node, value);
                this._calculateSelectedItemsOption(value, node);
                if (this.option("selectNodesRecursive"))
                    this._updateParentsAndChildren(node, value, suppressOnSelectionChanged, $node);
                else {
                    this._suppressDeprecatedWarnings();
                    var selectedItems = this._updateSelectionItemsOption();
                    this.option("selectedItems", selectedItems);
                    this._resumeDeprecatedWarnings()
                }
                var handler = this.option("onItemSelected");
                if (handler)
                    handler.call(this, {
                        itemData: itemData,
                        node: node
                    })
            },
            _updateSelectionToFirstItem: function($items, startIndex) {
                var itemIndex = startIndex;
                while (itemIndex >= 0) {
                    var $item = $($items[itemIndex]);
                    this._updateItemSelection(true, $item.find("." + ITEM_CLASS).get(0), true, $item);
                    itemIndex--
                }
            },
            _updateSelectionToLastItem: function($items, startIndex) {
                var itemIndex = startIndex,
                    length = $items.length;
                while (itemIndex < length) {
                    var $item = $($items[itemIndex]);
                    this._updateItemSelection(true, $item.find("." + ITEM_CLASS).get(0), true, $item);
                    itemIndex++
                }
            },
            _enlargeExpandedItemsOption: function(itemData, expandedItems) {
                if (!this._getItemFromArray(itemData, expandedItems)) {
                    expandedItems.push(itemData);
                    this._expandedSetter(itemData, true)
                }
                if (itemData.parent)
                    this._enlargeExpandedItemsOption(itemData.parent, expandedItems);
                return expandedItems
            },
            _reduceExpandedItemsOption: function(node, expandedItems) {
                var that = this,
                    nodeKey = that._keyGetter(node);
                var sourceItem = that._getSourceItemByKey(nodeKey);
                that._commonExpandedSetter(sourceItem, node, false);
                $.each(expandedItems, function(i, item) {
                    if (that._keyGetter(item) === nodeKey) {
                        expandedItems.splice(i, 1);
                        if (that._itemHasChildren(node))
                            $.each(that._itemsGetter(node), function(_, child) {
                                var sourceItemChild = that._getSourceItemByKey(that._keyGetter(child));
                                that._commonExpandedSetter(sourceItemChild, child, false);
                                that._reduceExpandedItemsOption(child, expandedItems)
                            })
                    }
                });
                return expandedItems
            },
            _focusInHandler: function(e) {
                var currentTarget = e.currentTarget,
                    focusTargets = this._focusTarget();
                if ($.inArray(currentTarget, focusTargets) !== -1)
                    this._toggleFocusClass(true, currentTarget);
                if (!this.option("focusedElement")) {
                    var $activeItem = this._getActiveItem();
                    this.option("focusedElement", $activeItem.closest("." + NODE_CLASS))
                }
                else
                    this._setFocusedItem(this.option("focusedElement"))
            },
            _setFocusedItem: function($target) {
                if (!$target || !$target.length)
                    return;
                if (!$target.children().hasClass(DISABLED_STATE_CLASS))
                    this.callBase($target);
                this._scrollableContainer.scrollToElement($target.find("." + ITEM_CLASS).first())
            },
            _itemPointerDownHandler: function(e) {
                if (!this.option("focusStateEnabled"))
                    return;
                var $target = $(e.target).closest("." + NODE_CLASS);
                if ($target.hasClass(NODE_CLASS))
                    if ($target.hasClass(DISABLED_STATE_CLASS))
                        this.option("focusedElement", null);
                    else
                        this.option("focusedElement", $target)
            },
            _moveFocus: function(location, e) {
                var FOCUS_UP = "up",
                    FOCUS_DOWN = "down",
                    FOCUS_FIRST = "first",
                    FOCUS_LAST = "last",
                    FOCUS_LEFT = this.option("rtlEnabled") ? "right" : "left",
                    FOCUS_RIGHT = this.option("rtlEnabled") ? "left" : "right";
                this.element().find("." + NODE_CONTAINER_CLASS).each(function() {
                    DX.fx.stop(this, true)
                });
                var $items = this._nodeElements().not(function() {
                        return $(this).find(">." + ITEM_CLASS).hasClass(DISABLED_STATE_CLASS)
                    });
                if ($items && $items.length)
                    switch (location) {
                        case FOCUS_UP:
                            var $prevItem = this._prevItem($items);
                            this.option("focusedElement", $prevItem);
                            if (e.shiftKey && this.option("showCheckBoxes"))
                                this._updateItemSelection(true, $prevItem.find("." + ITEM_CLASS).get(0), true, $prevItem);
                            break;
                        case FOCUS_DOWN:
                            var $nextItem = this._nextItem($items);
                            this.option("focusedElement", $nextItem);
                            if (e.shiftKey && this.option("showCheckBoxes"))
                                this._updateItemSelection(true, $nextItem.find("." + ITEM_CLASS).get(0), true, $nextItem);
                            break;
                        case FOCUS_FIRST:
                            var $firstItem = $items.first();
                            if (e.shiftKey && this.option("showCheckBoxes"))
                                this._updateSelectionToFirstItem($items, $items.index(this._prevItem($items)));
                            this.option("focusedElement", $firstItem);
                            break;
                        case FOCUS_LAST:
                            var $lastItem = $items.last();
                            if (e.shiftKey && this.option("showCheckBoxes"))
                                this._updateSelectionToLastItem($items, $items.index(this._nextItem($items)));
                            this.option("focusedElement", $lastItem);
                            break;
                        case FOCUS_RIGHT:
                            this._expandFocusedContainer();
                            break;
                        case FOCUS_LEFT:
                            this._collapseFocusedContainer();
                            break;
                        default:
                            this.callBase.apply(this, arguments);
                            return
                    }
            },
            _nodeElements: function() {
                return this.element().find("." + NODE_CLASS).not(":hidden")
            },
            _expandFocusedContainer: function() {
                var $focusedItem = this.option("focusedElement");
                if (!$focusedItem || $focusedItem.hasClass(IS_LEAF))
                    return;
                var $node = $focusedItem.find("." + NODE_CONTAINER_CLASS).eq(0);
                if ($node.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
                    this.option("focusedElement", this._nextItem(this._nodeElements()));
                    return
                }
                var itemData = this._getItemData($focusedItem.find(">." + ITEM_CLASS));
                this._toggleExpandedState(itemData, true)
            },
            _collapseFocusedContainer: function() {
                var $focusedItem = this.option("focusedElement");
                if (!$focusedItem)
                    return;
                var nodeElement = $focusedItem.find("." + NODE_CONTAINER_CLASS).eq(0);
                if (!$focusedItem.hasClass(IS_LEAF) && nodeElement.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
                    var itemData = this._getItemData($focusedItem.find(">." + ITEM_CLASS));
                    this._toggleExpandedState(itemData, false)
                }
                else {
                    var parentElement = $focusedItem.parent("." + NODE_CONTAINER_CLASS);
                    var collapsedNode = parentElement.parent("." + NODE_CLASS).eq(0);
                    if (collapsedNode.length)
                        this.option("focusedElement", collapsedNode)
                }
            },
            updateDimensions: function() {
                var that = this,
                    deferred = $.Deferred();
                if (that._scrollableContainer)
                    that._scrollableContainer.update().done(function() {
                        deferred.resolveWith(that)
                    });
                else
                    deferred.resolveWith(that);
                return deferred.promise()
            },
            selectItem: function(itemElement) {
                this._updateItemSelection(true, itemElement)
            },
            unselectItem: function(itemElement) {
                this._updateItemSelection(false, itemElement)
            },
            expandItem: function(itemElement) {
                var itemData = this._getItemData($(itemElement));
                this._toggleExpandedState(itemData, true)
            },
            collapseItem: function(itemElement) {
                var itemData = this._getItemData($(itemElement));
                this._toggleExpandedState(itemData, false)
            },
            getNodes: function() {
                return this._nodes
            },
            selectAll: function() {
                this._toggleSelectAll({value: true})
            },
            unselectAll: function() {
                this._toggleSelectAll({value: false})
            }
        }));
        ui.dxTreeView.__internals = {
            WIDGET_CLASS: WIDGET_CLASS,
            NODE_CONTAINER_CLASS: NODE_CONTAINER_CLASS,
            OPENED_NODE_CONTAINER_CLASS: OPENED_NODE_CONTAINER_CLASS,
            ITEM_CLASS: ITEM_CLASS,
            NODE_CLASS: NODE_CLASS,
            ITEM_WITH_CHECKBOX_CLASS: ITEM_WITH_CHECKBOX_CLASS,
            ITEM_DATA_KEY: ITEM_DATA_KEY,
            IS_LEAF: IS_LEAF,
            TOGGLE_ITEM_VISIBILITY_CLASS: TOGGLE_ITEM_VISIBILITY_CLASS,
            TOGGLE_ITEM_VISIBILITY_OPENED_CLASS: TOGGLE_ITEM_VISIBILITY_OPENED_CLASS,
            SELECT_ALL_ITEM_CLASS: SELECT_ALL_ITEM_CLASS,
            scrollableContainerUpdatedOnInitAccessor: function(value) {
                if (value)
                    scrollableContainerUpdatedOnInit = value;
                return scrollableContainerUpdatedOnInit
            }
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.sortable.js */
    (function($, DX) {
        var ui = DX.ui,
            addNamespace = ui.events.addNamespace;
        var SORTABLE_NAMESPACE = "dxSortable",
            SORTABLE_CLASS = "dx-sortable";
        function elementHasPoint(element, x, y) {
            var $item = $(element),
                offset = $item.offset();
            if (x >= offset.left && x <= offset.left + $item.outerWidth(true))
                if (y >= offset.top && y <= offset.top + $item.outerHeight(true))
                    return true
        }
        function getItemsOffset($elements) {
            var result = [];
            $.each($elements, function() {
                var item = this;
                if ($(item).is(':visible'))
                    result.push({
                        pos: $(item).offset().top + $(item).outerHeight(true) / 2,
                        item: $(item)
                    })
            });
            return result
        }
        DX.registerComponent("dxSortable", ui, DX.DOMComponent.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    onChanged: null,
                    onDragging: null,
                    itemRender: null,
                    groupSelector: null,
                    itemSelector: ".dx-sort-item",
                    itemContainerSelector: ".dx-sortable",
                    sourceClass: "dx-drag-source",
                    dragClass: "dx-drag",
                    targetClass: "dx-drag-target"
                })
            },
            _renderItem: function($sourceItem, target) {
                var itemRender = this.option("itemRender"),
                    $item;
                if (itemRender)
                    $item = itemRender($sourceItem, target);
                else {
                    $item = $sourceItem.clone();
                    $item.css({
                        width: $sourceItem.width(),
                        height: $sourceItem.height()
                    })
                }
                return $item
            },
            _attachEventHandlers: function() {
                var that = this,
                    itemSelector = that.option("itemSelector"),
                    itemContainerSelector = that.option("itemContainerSelector"),
                    groupSelector = that.option("groupSelector"),
                    sourceClass = that.option("sourceClass"),
                    dragClass = that.option("dragClass"),
                    targetClass = that.option("targetClass"),
                    onDragging = that.option("onDragging"),
                    $sourceItem,
                    sourceIndex,
                    $targetItem,
                    $targetGroup,
                    startPosition,
                    $draggable,
                    $sourceGroup,
                    element = that.element(),
                    $groups,
                    i;
                element.off(addNamespace("dxdragstart dxdrag dxdragend dxdragenter dxdragleave dxdrop", SORTABLE_NAMESPACE)).on(addNamespace("dxdragstart", SORTABLE_NAMESPACE), itemSelector, function(e) {
                    $sourceItem = $(e.currentTarget);
                    startPosition = $sourceItem.offset();
                    startPosition.top -= element.offset().top;
                    startPosition.left -= element.offset().left;
                    sourceIndex = $sourceItem.index();
                    $groups = groupSelector ? element.find(groupSelector) : element;
                    $sourceGroup = $sourceItem.closest(groupSelector).attr("group");
                    $draggable = that._renderItem($sourceItem, 'drag').appendTo(element);
                    $targetItem = that._renderItem($sourceItem, 'target');
                    $draggable.addClass(dragClass);
                    $sourceItem.addClass(sourceClass);
                    $targetItem.addClass(targetClass)
                }).on(addNamespace("dxdrag", SORTABLE_NAMESPACE), function(e) {
                    var draggingArgs,
                        $item,
                        $itemContainer,
                        $items,
                        itemsOffset = [];
                    if (!$sourceItem)
                        return;
                    $draggable.css({
                        top: startPosition.top + e.offset.y,
                        left: startPosition.left + e.offset.x
                    });
                    $targetGroup && $targetGroup.removeClass(targetClass);
                    $targetGroup = undefined;
                    $.each($groups, function() {
                        if (elementHasPoint(this, e.pageX, e.pageY)) {
                            $targetGroup = $(this);
                            return false
                        }
                    });
                    if ($targetGroup) {
                        draggingArgs = {
                            sourceGroup: $sourceGroup,
                            sourceIndex: sourceIndex,
                            sourceElement: $sourceItem,
                            targetGroup: $targetGroup.attr("group"),
                            targetIndex: $targetItem.index()
                        };
                        onDragging && onDragging(draggingArgs)
                    }
                    if (draggingArgs && draggingArgs.cancel)
                        $targetGroup = undefined;
                    if ($targetGroup) {
                        $targetGroup.addClass(targetClass);
                        $itemContainer = $targetGroup.find(itemContainerSelector);
                        $items = $itemContainer.find(itemSelector);
                        itemsOffset = getItemsOffset($items);
                        for (i = 0; i < itemsOffset.length; i++)
                            if (e.pageY < itemsOffset[i].pos) {
                                $item = itemsOffset[i] && itemsOffset[i].item;
                                break
                            }
                        if ($item)
                            if (!$item.hasClass(sourceClass) && (!$item.prev().hasClass(sourceClass) || !$item.prev().is(":visible")))
                                $targetItem.insertBefore($item);
                            else
                                $targetItem.detach();
                        else if (!($items.last().is(":visible") && $items.last().hasClass(sourceClass)))
                            $targetItem.appendTo($itemContainer)
                    }
                    else
                        $targetItem.detach()
                }).on(addNamespace("dxdragend", SORTABLE_NAMESPACE), function() {
                    var onChanged = that.option("onChanged"),
                        changedArgs,
                        sourceGroup;
                    if ($sourceItem) {
                        if ($targetGroup) {
                            $targetGroup.removeClass(targetClass);
                            sourceGroup = $sourceItem.closest(groupSelector).attr("group");
                            changedArgs = {
                                sourceGroup: sourceGroup,
                                sourceIndex: sourceIndex,
                                sourceElement: $sourceItem,
                                targetGroup: $targetGroup.attr("group"),
                                targetIndex: $targetItem.index(),
                                removeSourceElement: true
                            };
                            if (sourceGroup !== changedArgs.targetGroup || $targetItem.parent().length) {
                                onChanged && onChanged(changedArgs);
                                if (changedArgs.removeSourceElement)
                                    $sourceItem.remove()
                            }
                        }
                        $sourceItem.removeClass(sourceClass);
                        $draggable.remove();
                        $sourceItem = null;
                        $targetItem.removeClass(targetClass);
                        $targetItem = null
                    }
                })
            },
            _init: function() {
                this.callBase();
                this._attachEventHandlers()
            },
            _render: function() {
                this.callBase();
                this.element().addClass(SORTABLE_CLASS)
            },
            _optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"onDragging":
                    case"onChanged":
                    case"itemRender":
                    case"groupSelector":
                    case"itemSelector":
                    case"itemContainerSelector":
                    case"sourceClass":
                    case"targetClass":
                    case"dragClass":
                        that._attachEventHandlers();
                        break;
                    default:
                        that.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils;
        var DATAGRID_ROW_SELECTOR = ".dx-row",
            DATAGRID_DEPRECATED_TEMPLATE_WARNING = "Specifying grid templates with the name of a jQuery selector is now deprecated. Instead, use the jQuery object that references this selector.";
        var ModuleItem = DX.Class.inherit({
                _endUpdateCore: function(){},
                ctor: function(component) {
                    var that = this;
                    that._updateLockCount = 0;
                    that.component = component;
                    that._actions = {};
                    that._actionConfigs = {};
                    $.each(this.callbackNames() || [], function(index, name) {
                        var flags = that.callbackFlags(name);
                        that[this] = $.Callbacks(flags)
                    })
                },
                init: function(){},
                callbackNames: function(){},
                callbackFlags: function(name){},
                publicMethods: function(){},
                beginUpdate: function() {
                    this._updateLockCount++
                },
                endUpdate: function() {
                    this._updateLockCount--;
                    if (!this._updateLockCount)
                        this._endUpdateCore()
                },
                option: function() {
                    return this.component.option.apply(this.component, arguments)
                },
                on: function() {
                    return this.component.on.apply(this.component, arguments)
                },
                off: function() {
                    return this.component.off.apply(this.component, arguments)
                },
                optionChanged: function(args) {
                    if (args.name in this._actions) {
                        this.createAction(args.name, this._actionConfigs[args.name]);
                        args.handled = true
                    }
                },
                getAction: function(actionName) {
                    return this._actions[actionName]
                },
                setAria: function() {
                    return this.component.setAria.apply(this.component, arguments)
                },
                _createComponent: function() {
                    return this.component._createComponent.apply(this.component, arguments)
                },
                getController: function(name) {
                    return this.component._controllers[name]
                },
                createAction: function(actionName, config) {
                    var action;
                    if (utils.isFunction(actionName)) {
                        action = this.component._createAction($.proxy(actionName, this), config);
                        return function(e) {
                                action({jQueryEvent: e})
                            }
                    }
                    else {
                        this._actions[actionName] = this.component._createActionByOption(actionName, config);
                        this._actionConfigs[actionName] = config
                    }
                },
                executeAction: function(actionName, options) {
                    var action = this._actions[actionName];
                    return action && action(options)
                },
                dispose: function() {
                    var that = this;
                    $.each(that.callbackNames() || [], function() {
                        that[this].empty()
                    })
                }
            });
        var Controller = ModuleItem;
        var ViewController = Controller.inherit({
                getView: function(name) {
                    return this.component._views[name]
                },
                getViews: function() {
                    return this.component._views
                }
            });
        var View = ModuleItem.inherit({
                _isReady: function() {
                    return this.component.isReady()
                },
                _endUpdateCore: function() {
                    this.callBase();
                    if (!this._isReady() && this._requireReady) {
                        this._requireRender = false;
                        this.component._requireResize = false
                    }
                    if (this._requireRender) {
                        this._requireRender = false;
                        this.render(this._$parent)
                    }
                },
                _invalidate: function(requireResize, requireReady) {
                    this._requireRender = true;
                    this.component._requireResize = this.component._requireResize || requireResize;
                    this._requireReady = this._requireReady || requireReady
                },
                _renderCore: function(options){},
                _resizeCore: function(){},
                _afterRender: function($root){},
                _parentElement: function() {
                    return this._$parent
                },
                ctor: function(component) {
                    this.callBase(component);
                    this.renderCompleted = $.Callbacks();
                    this.resizeCompleted = $.Callbacks()
                },
                element: function() {
                    return this._$element
                },
                isVisible: function() {
                    return true
                },
                getTemplate: function(name) {
                    return this.component._getTemplate(name)
                },
                render: function($parent, options) {
                    var $element = this._$element,
                        isVisible = this.isVisible();
                    this._requireReady = false;
                    if (!$element) {
                        $element = this._$element = $("<div />").appendTo($parent);
                        this._$parent = $parent
                    }
                    $element.toggle(isVisible);
                    if (isVisible) {
                        this._renderCore(options);
                        this._afterRender($parent);
                        this.renderCompleted.fire()
                    }
                },
                resize: function() {
                    this.isResizing = true;
                    this._resizeCore();
                    this.resizeCompleted.fire();
                    this.isResizing = false
                },
                focus: function() {
                    this.element().focus()
                }
            });
        var processModules = function(that, modules) {
                var controllerTypes = {},
                    viewTypes = {};
                $.each(modules, function() {
                    var controllers = this.controllers,
                        moduleName = this.name,
                        views = this.views;
                    controllers && $.each(controllers, function(name, type) {
                        if (controllerTypes[name])
                            throw DX.Error("E1001", moduleName, name);
                        else if (!(type && type.subclassOf && type.subclassOf(Controller))) {
                            type.subclassOf(Controller);
                            throw DX.Error("E1002", moduleName, name);
                        }
                        controllerTypes[name] = type
                    });
                    views && $.each(views, function(name, type) {
                        if (viewTypes[name])
                            throw DX.Error("E1003", moduleName, name);
                        else if (!(type && type.subclassOf && type.subclassOf(View)))
                            throw DX.Error("E1004", moduleName, name);
                        viewTypes[name] = type
                    })
                });
                $.each(modules, function() {
                    var extenders = this.extenders;
                    if (extenders) {
                        extenders.controllers && $.each(extenders.controllers, function(name, extender) {
                            if (controllerTypes[name])
                                controllerTypes[name] = controllerTypes[name].inherit(extender)
                        });
                        extenders.views && $.each(extenders.views, function(name, extender) {
                            if (viewTypes[name])
                                viewTypes[name] = viewTypes[name].inherit(extender)
                        })
                    }
                });
                var registerPublicMethods = function(that, name, moduleItem) {
                        var publicMethods = moduleItem.publicMethods();
                        if (publicMethods)
                            $.each(publicMethods, function(index, methodName) {
                                if (moduleItem[methodName])
                                    if (!that[methodName])
                                        that[methodName] = function() {
                                            return moduleItem[methodName].apply(moduleItem, arguments)
                                        };
                                    else
                                        throw DX.Error("E1005", methodName);
                                else
                                    throw DX.Error("E1006", name, methodName);
                            })
                    };
                var createModuleItems = function(moduleTypes) {
                        var moduleItems = {};
                        $.each(moduleTypes, function(name, moduleType) {
                            var moduleItem = new moduleType(that);
                            moduleItem.name = name;
                            registerPublicMethods(that, name, moduleItem);
                            moduleItems[name] = moduleItem
                        });
                        return moduleItems
                    };
                that._controllers = createModuleItems(controllerTypes);
                that._views = createModuleItems(viewTypes)
            };
        var callModuleItemsMethod = function(that, methodName, args) {
                args = args || [];
                if (that._controllers)
                    $.each(that._controllers, function() {
                        this[methodName] && this[methodName].apply(this, args)
                    });
                if (that._views)
                    $.each(that._views, function() {
                        this[methodName] && this[methodName].apply(this, args)
                    })
            };
        DX.registerComponent("dxDataGrid", ui, ui.Widget.inherit({
            _activeStateUnit: DATAGRID_ROW_SELECTOR,
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    rowClick: {
                        since: "14.2",
                        alias: "onRowClick"
                    },
                    cellClick: {
                        since: "14.2",
                        alias: "onCellClick"
                    },
                    cellHoverChanged: {
                        since: "14.2",
                        alias: "onCellHoverChanged"
                    },
                    cellPrepared: {
                        since: "14.2",
                        message: "The cellPrepared option is deprecated. Use the onCellPrepared option instead. For further information, see http://js.devexpress.com/Documentation/ApiReference/UI_Widgets/dxDataGrid/Configuration/?version=14_2#onCellPrepared"
                    },
                    rowPrepared: {
                        since: "14.2",
                        message: "The rowPrepared option is deprecated. Use the onRowPrepared option instead. For further information, see http://js.devexpress.com/Documentation/ApiReference/UI_Widgets/dxDataGrid/Configuration/?version=14_2#onRowPrepared"
                    },
                    selectionChanged: {
                        since: "14.2",
                        alias: "onSelectionChanged"
                    },
                    dataErrorOccurred: {
                        since: "14.2",
                        alias: "onDataErrorOccurred"
                    },
                    initNewRow: {
                        since: "14.2",
                        alias: "onInitNewRow"
                    },
                    rowInserting: {
                        since: "14.2",
                        alias: "onRowInserting"
                    },
                    rowInserted: {
                        since: "14.2",
                        alias: "onRowInserted"
                    },
                    editingStart: {
                        since: "14.2",
                        alias: "onEditingStart"
                    },
                    rowUpdating: {
                        since: "14.2",
                        alias: "onRowUpdating"
                    },
                    rowUpdated: {
                        since: "14.2",
                        alias: "onRowUpdated"
                    },
                    rowRemoving: {
                        since: "14.2",
                        alias: "onRowRemoving"
                    },
                    rowRemoved: {
                        since: "14.2",
                        alias: "onRowRemoved"
                    },
                    editorPreparing: {
                        since: "14.2",
                        message: "The editorPreparing option is deprecated. Use the onEditorPreparing option instead. For further information, see http://js.devexpress.com/Documentation/ApiReference/UI_Widgets/dxDataGrid/Configuration/?version=14_2#onEditorPreparing"
                    },
                    editorPrepared: {
                        since: "14.2",
                        message: "The editorPrepared option is deprecated. Use the onEditorPrepared option instead. For further information, see http://js.devexpress.com/Documentation/ApiReference/UI_Widgets/dxDataGrid/Configuration/?version=14_2#onEditorPrepared"
                    },
                    contentReadyAction: {
                        since: "14.2",
                        alias: "onContentReady"
                    }
                })
            },
            _setDefaultOptions: function() {
                var that = this;
                that.callBase();
                $.each(ui.dxDataGrid.modules, function() {
                    if ($.isFunction(this.defaultOptions))
                        that.option(this.defaultOptions())
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "ios"},
                            options: {showRowLines: true}
                        }, {
                            device: function() {
                                return DevExpress.browser.webkit
                            },
                            options: {loadPanel: {animation: {show: {
                                            easing: "cubic-bezier(1, 0, 1, 0)",
                                            duration: 500,
                                            from: {opacity: 0},
                                            to: {opacity: 1}
                                        }}}}
                        }])
            },
            _init: function() {
                var that = this;
                that.callBase();
                processModules(that, ui.dxDataGrid.modules);
                callModuleItemsMethod(that, "init")
            },
            _clean: $.noop,
            _optionChanged: function(args) {
                var that = this;
                callModuleItemsMethod(that, "optionChanged", [args]);
                if (!args.handled)
                    that.callBase(args)
            },
            _dimensionChanged: function() {
                this.updateDimensions()
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this.updateDimensions()
            },
            _renderContentImpl: function() {
                var that = this;
                that.getView("gridView").render(that.element())
            },
            _renderContent: function() {
                this._renderContentImpl()
            },
            _getTemplate: function(templateName) {
                var template = templateName;
                if (DX.utils.isString(template) && template[0] === "#") {
                    template = $(templateName);
                    DX.utils.logger.warn(DATAGRID_DEPRECATED_TEMPLATE_WARNING)
                }
                return this.callBase(template)
            },
            _dispose: function() {
                var that = this;
                that.callBase();
                callModuleItemsMethod(that, "dispose")
            },
            isReady: function() {
                return this.getController("data").isReady()
            },
            beginUpdate: function() {
                var that = this;
                that.callBase();
                callModuleItemsMethod(that, "beginUpdate")
            },
            endUpdate: function() {
                var that = this;
                callModuleItemsMethod(that, "endUpdate");
                that.callBase()
            },
            getController: function(name) {
                return this._controllers[name]
            },
            getView: function(name) {
                return this._views[name]
            },
            focus: function(element) {
                this.callBase();
                if (utils.isDefined(element))
                    this.getController("keyboardNavigation").focus(element)
            }
        }));
        var MAX_EQUAL_KEYS_LEVEL = 3;
        $.extend(ui.dxDataGrid, {
            __internals: {},
            modules: [],
            View: View,
            ViewController: ViewController,
            Controller: Controller,
            registerModule: function(name, module) {
                var modules = this.modules,
                    i;
                for (i = 0; i < modules.length; i++)
                    if (modules[i].name === name)
                        return;
                module.name = name;
                modules.push(module)
            },
            unregisterModule: function(name) {
                this.modules = $.grep(this.modules, function(module) {
                    return module.name !== name
                })
            },
            processModules: processModules,
            formatValue: function(value, options) {
                var valueText = DX.formatHelper.format(value, options.format, options.precision) || value && value.toString() || "",
                    formatObject = {
                        value: value,
                        valueText: options.getDisplayFormat ? options.getDisplayFormat(valueText) : valueText
                    };
                return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText
            },
            getDisplayValue: function(column, value) {
                return column.lookup ? column.lookup.calculateCellValue(value) : value
            },
            getGroupRowSummaryText: function(summaryItems, summaryTexts) {
                var result = "(",
                    i,
                    summaryItem;
                for (i = 0; i < summaryItems.length; i++) {
                    summaryItem = summaryItems[i];
                    result += (i > 0 ? ", " : "") + ui.dxDataGrid.getSummaryText(summaryItem, summaryTexts)
                }
                return result += ")"
            },
            getSummaryText: function(summaryItem, summaryTexts) {
                var displayFormat = summaryItem.displayFormat || summaryItem.columnCaption && summaryTexts[summaryItem.summaryType + "OtherColumn"] || summaryTexts[summaryItem.summaryType];
                return this.formatValue(summaryItem.value, {
                        format: summaryItem.valueFormat,
                        precision: summaryItem.precision,
                        getDisplayFormat: function(valueText) {
                            return displayFormat ? utils.stringFormat(displayFormat, valueText, summaryItem.columnCaption) : valueText
                        },
                        customizeText: summaryItem.customizeText
                    })
            },
            equalKeys: function(key1, key2, level) {
                var propertyName,
                    i;
                level = level || 0;
                if (level < MAX_EQUAL_KEYS_LEVEL)
                    if (utils.isObject(key1) && utils.isObject(key2)) {
                        for (propertyName in key1)
                            if (key1.hasOwnProperty(propertyName) && !ui.dxDataGrid.equalKeys(key1[propertyName], key2[propertyName], level + 1))
                                return false;
                        for (propertyName in key2)
                            if (!(propertyName in key1))
                                return false;
                        return true
                    }
                    else if (utils.isArray(key1) && utils.isArray(key2)) {
                        if (key1.length !== key2.length)
                            return false;
                        for (i = 0; i < key1.length; i++)
                            if (!ui.dxDataGrid.equalKeys(key1[i], key2[i], level + 1))
                                return false;
                        return true
                    }
                    else if (utils.isDate(key1) && utils.isDate(key2))
                        return key1.getTime() === key2.getTime();
                    else
                        return key1 === key2;
                return true
            },
            getIndexByKey: function(key, items) {
                var index = -1;
                $.each(items, function(i, item) {
                    if (ui.dxDataGrid.equalKeys(key, item.key)) {
                        index = i;
                        return false
                    }
                });
                return index
            },
            normalizeSortingInfo: function(sort) {
                sort = sort || [];
                var result,
                    i;
                result = DX.data.utils.normalizeSortingInfo(sort);
                for (i = 0; i < sort.length; i++)
                    if (sort && sort[i] && sort[i].isExpanded !== undefined)
                        result[i].isExpanded = sort[i].isExpanded;
                return result
            },
            getFormatByDataType: function(dataType) {
                switch (dataType) {
                    case"date":
                        return "shortDate"
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.stateStoring.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;
        var parseDates = function(state) {
                if (!state)
                    return;
                $.each(state, function(key, value) {
                    var date;
                    if ($.isPlainObject(value) || $.isArray(value))
                        parseDates(value);
                    else if (typeof value === "string") {
                        date = DATE_REGEX.exec(value);
                        if (date)
                            state[key] = new Date(Date.UTC(+date[1], +date[2] - 1, +date[3], +date[4], +date[5], +date[6]))
                    }
                })
            };
        dataGrid.StateStoringController = dataGrid.ViewController.inherit(function() {
            var getStorage = function(options) {
                    var storage = options.type === "sessionStorage" ? DX.utils.getSessionStorage() : localStorage;
                    if (!storage)
                        throw new Error("E1007");
                    return storage
                };
            var getUniqueStorageKey = function(options) {
                    return "dx_datagrid_" + (utils.isDefined(options.storageKey) ? options.storageKey : "storage")
                };
            var processLoadState = function(that) {
                    var columnsController = that.getController("columns"),
                        selectionController = that.getController("selection"),
                        exportController = that.getController("export"),
                        dataController = that.getController("data"),
                        pagerView = that.getView("pagerView");
                    if (columnsController)
                        columnsController.columnsChanged.add(function() {
                            $.extend(that._state, {columns: columnsController.getUserState()});
                            that.isEnabled() && that.save()
                        });
                    if (selectionController)
                        selectionController.selectionChanged.add(function(keys) {
                            $.extend(that._state, {selectedRowKeys: keys});
                            that.isEnabled() && that.save()
                        });
                    if (dataController) {
                        that._initialPageSize = that.option("paging.pageSize");
                        dataController.changed.add(function() {
                            $.extend(that._state, {
                                searchText: that.option("searchPanel.text"),
                                pageIndex: dataController.pageIndex(),
                                pageSize: dataController.pageSize(),
                                allowedPageSizes: pagerView ? pagerView.getPageSizes() : undefined
                            });
                            that.isEnabled() && that.save()
                        })
                    }
                    if (exportController)
                        exportController.selectionOnlyChanged.add(function() {
                            $.extend(that._state, {exportSelectionOnly: exportController.selectionOnly()});
                            that.isEnabled() && that.save()
                        })
                };
            var applyState = function(that, state) {
                    var allowedPageSizes = state.allowedPageSizes,
                        searchText = state.searchText,
                        selectedRowKeys = state.selectedRowKeys,
                        exportController = that.getController("export"),
                        columnsController = that.getController("columns"),
                        scrollingMode = that.option("scrolling.mode");
                    that.component.beginUpdate();
                    if (columnsController)
                        columnsController.setUserState(state.columns);
                    if (exportController)
                        exportController.selectionOnly(state.exportSelectionOnly);
                    that.option("selectedRowKeys", selectedRowKeys || []);
                    if (allowedPageSizes && that.option("pager.allowedPageSizes") === "auto")
                        that.option("pager").allowedPageSizes = allowedPageSizes;
                    that.option("searchPanel.text", searchText || "");
                    that.option("paging.pageSize", scrollingMode !== "virtual" && scrollingMode !== "infinite" && state.pageSize ? state.pageSize : that._initialPageSize);
                    that.option("paging.pageIndex", state.pageIndex || 0);
                    that.component.endUpdate()
                };
            return {
                    _loadState: function() {
                        var options = this.option("stateStoring");
                        if (options.type === "custom")
                            return options.customLoad && options.customLoad();
                        try {
                            return JSON.parse(getStorage(options).getItem(getUniqueStorageKey(options)))
                        }
                        catch(e) {
                            DX.utils.logger.error(e.message)
                        }
                    },
                    _saveState: function(state) {
                        var options = this.option("stateStoring");
                        if (options.type === "custom") {
                            options.customSave && options.customSave(state);
                            return
                        }
                        try {
                            getStorage(options).setItem(getUniqueStorageKey(options), JSON.stringify(state))
                        }
                        catch(e) {}
                    },
                    publicMethods: function() {
                        return ["state"]
                    },
                    isEnabled: function() {
                        return this.option("stateStoring.enabled")
                    },
                    init: function() {
                        var that = this;
                        that._state = {};
                        that._isLoaded = false;
                        that._isLoading = false;
                        that._windowUnloadHandler = function() {
                            if (that._savingTimeoutID !== undefined)
                                that._saveState(that.state())
                        },
                        $(window).on("unload", that._windowUnloadHandler);
                        processLoadState(that)
                    },
                    isLoaded: function() {
                        return this._isLoaded
                    },
                    isLoading: function() {
                        return this._isLoading
                    },
                    load: function() {
                        var that = this,
                            loadResult;
                        that._isLoading = true;
                        loadResult = that._loadState();
                        if (!loadResult || !$.isFunction(loadResult.done))
                            loadResult = $.Deferred().resolve(loadResult);
                        loadResult.done(function(state) {
                            that._isLoaded = true;
                            that._isLoading = false;
                            that.state(state)
                        });
                        return loadResult
                    },
                    state: function(state) {
                        var that = this;
                        if (!arguments.length)
                            return $.extend(true, {}, that._state);
                        else {
                            that._state = $.extend({}, state);
                            parseDates(that._state);
                            applyState(that, $.extend({}, state))
                        }
                    },
                    save: function() {
                        var that = this;
                        clearTimeout(that._savingTimeoutID);
                        that._savingTimeoutID = setTimeout(function() {
                            that._saveState(that.state());
                            that._savingTimeoutID = undefined
                        }, that.option("stateStoring.savingTimeout"))
                    },
                    optionChanged: function(args) {
                        var that = this;
                        switch (args.name) {
                            case"stateStoring":
                                if (that.isEnabled())
                                    that.load();
                                args.handled = true;
                                break;
                            default:
                                that.callBase(args)
                        }
                    },
                    dispose: function() {
                        clearTimeout(this._savingTimeoutID);
                        $(window).off("unload", this._windowUnloadHandler)
                    }
                }
        }());
        dataGrid.registerModule("stateStoring", {
            defaultOptions: function() {
                return {stateStoring: {
                            enabled: false,
                            storageKey: null,
                            type: "localStorage",
                            customLoad: null,
                            customSave: null,
                            savingTimeout: 2000
                        }}
            },
            controllers: {stateStoring: ui.dxDataGrid.StateStoringController},
            extenders: {controllers: {
                    columns: {getVisibleColumns: function() {
                            var visibleColumns = this.callBase(),
                                stateStoringController = this.getController("stateStoring");
                            return stateStoringController.isEnabled() && !stateStoringController.isLoaded() ? [] : visibleColumns
                        }},
                    data: {
                        _refreshDataSource: function() {
                            var that = this,
                                callBase = that.callBase,
                                stateStoringController = that.getController("stateStoring");
                            if (stateStoringController.isEnabled() && !stateStoringController.isLoaded()) {
                                clearTimeout(that._restoreStateTimeoutID);
                                that._restoreStateTimeoutID = setTimeout(function() {
                                    stateStoringController.load().always(function() {
                                        that._restoreStateTimeoutID = null;
                                        callBase.call(that)
                                    })
                                })
                            }
                            else if (!that._restoreStateTimeoutID)
                                callBase.call(that)
                        },
                        isLoading: function() {
                            var that = this,
                                stateStoringController = that.getController("stateStoring");
                            return this.callBase() || stateStoringController.isLoading()
                        },
                        dispose: function() {
                            clearTimeout(this._restoreStateTimeoutID);
                            this.callBase()
                        }
                    }
                }}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnsController.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            normalizeSortingInfo = dataGrid.normalizeSortingInfo,
            utils = DX.utils,
            normalizeIndexes = utils.normalizeIndexes,
            dataUtils = DX.data.utils,
            isDefined = utils.isDefined;
        var USER_STATE_FIELD_NAMES_15_1 = ["filterValues", "filterType", "fixed", "fixedPosition"],
            USER_STATE_FIELD_NAMES = ["visibleIndex", "dataField", "name", "dataType", "width", "visibleWidth", "visible", "sortOrder", "sortIndex", "groupIndex", "filterValue", "selectedFilterOperation"].concat(USER_STATE_FIELD_NAMES_15_1),
            DATAGRID_COMMAND_EXPAND_CLASS = "dx-command-expand";
        dataGrid.checkChanges = function(changes, changeNames) {
            var changesWithChangeNamesCount = 0,
                i;
            for (i = 0; i < changeNames.length; i++)
                if (changes[changeNames[i]])
                    changesWithChangeNamesCount++;
            return changes.length && changes.length === changesWithChangeNamesCount
        };
        var ColumnsController = dataGrid.Controller.inherit(function() {
                var DEFAULT_COLUMN_OPTIONS = {
                        visible: true,
                        showInColumnChooser: true
                    },
                    DATATYPE_OPERATIONS = {
                        number: ["=", "<>", "<", ">", "<=", ">="],
                        string: ["contains", "notcontains", "startswith", "endswith", "=", "<>"],
                        date: ["=", "<>", "<", ">", "<=", ">="]
                    },
                    GROUP_LOCATION = "group",
                    COLUMN_CHOOSER_LOCATION = "columnChooser";
                var convertNameToCaption = function(name) {
                        var captionList = [],
                            i,
                            char,
                            isPrevCharNewWord = false,
                            isNewWord = false;
                        for (i = 0; i < name.length; i++) {
                            char = name.charAt(i);
                            isNewWord = char === char.toUpperCase() || char in ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
                            if (char === "_" || char === ".") {
                                char = " ";
                                isNewWord = true
                            }
                            else if (i === 0) {
                                char = char.toUpperCase();
                                isNewWord = true
                            }
                            else if (!isPrevCharNewWord && isNewWord)
                                if (captionList.length > 0)
                                    captionList.push(" ");
                            captionList.push(char);
                            isPrevCharNewWord = isNewWord
                        }
                        return captionList.join("")
                    };
                var createColumn = function(that, columnOptions, userStateColumnOptions) {
                        var commonColumnOptions,
                            calculatedColumnOptions;
                        if (columnOptions) {
                            if (utils.isString(columnOptions))
                                columnOptions = {dataField: columnOptions};
                            if (columnOptions.command)
                                return $.extend(true, {}, columnOptions);
                            else {
                                commonColumnOptions = that.getCommonSettings();
                                if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField)
                                    columnOptions = $.extend({}, columnOptions, {dataField: userStateColumnOptions.dataField});
                                calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions);
                                return $.extend(true, {}, DEFAULT_COLUMN_OPTIONS, commonColumnOptions, calculatedColumnOptions, columnOptions, {selector: null})
                            }
                        }
                    };
                var createColumnsFromOptions = function(that, columnsOptions) {
                        var result = [];
                        if (columnsOptions)
                            $.each(columnsOptions, function(index, columnOptions) {
                                var userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[index]) && that._columnsUserState[index],
                                    column = createColumn(that, columnOptions, userStateColumnOptions);
                                if (column)
                                    result.push(column)
                            });
                        return result
                    };
                var getValueDataType = function(value) {
                        var dataType = $.type(value);
                        if (dataType !== "string" && dataType !== "boolean" && dataType !== "number" && dataType !== "date")
                            dataType = undefined;
                        return dataType
                    };
                var getSerializationFormat = function(dataType, value) {
                        switch (dataType) {
                            case"date":
                                if (utils.isNumber(value))
                                    return "number";
                                else if (utils.isString(value))
                                    return "yyyy/MM/dd";
                                break;
                            case"number":
                                if (utils.isString(value))
                                    return "string"
                        }
                    };
                var updateSerializers = function(options, dataType) {
                        if (!options.deserializeValue) {
                            if (dataType === "date") {
                                options.deserializeValue = function(value) {
                                    return utils.deserializeDate(value, this.serializationFormat)
                                };
                                options.serializeValue = function(value) {
                                    return utils.serializeDate(value, this.serializationFormat)
                                }
                            }
                            if (dataType === "number") {
                                options.deserializeValue = function(value) {
                                    return utils.isDefined(value) ? Number(value) : value
                                };
                                options.serializeValue = function(value) {
                                    return utils.isDefined(value) && this.serializationFormat === "string" ? value.toString() : value
                                }
                            }
                        }
                    };
                var getAlignmentByDataType = function(dataType, isRTL) {
                        switch (dataType) {
                            case"number":
                                return "right";
                            case"boolean":
                                return "center";
                            default:
                                return utils.getDefaultAlignment(isRTL)
                        }
                    };
                var getCustomizeTextByDataType = function(dataType) {
                        if (dataType === "boolean")
                            return function(e) {
                                    if (e.value === true)
                                        return this.trueText || "true";
                                    else if (e.value === false)
                                        return this.falseText || "false";
                                    else
                                        return e.valueText || ""
                                }
                    };
                var createColumnsFromDataSource = function(that, dataSource) {
                        var firstItems = getFirstItems(dataSource),
                            fieldName,
                            processedFields = {},
                            i,
                            result = [];
                        for (i = 0; i < firstItems.length; i++)
                            if (firstItems[i])
                                for (fieldName in firstItems[i])
                                    processedFields[fieldName] = true;
                        for (fieldName in processedFields)
                            if (fieldName.indexOf("__") !== 0) {
                                var column = createColumn(that, fieldName);
                                result.push(column)
                            }
                        return result
                    };
                var equalSortParameters = function(sortParameters1, sortParameters2) {
                        var i;
                        if ($.isArray(sortParameters1) && $.isArray(sortParameters2)) {
                            if (sortParameters1.length !== sortParameters2.length)
                                return false;
                            else
                                for (i = 0; i < sortParameters1.length; i++)
                                    if (sortParameters1[i].selector !== sortParameters2[i].selector || sortParameters1[i].desc !== sortParameters2[i].desc || Boolean(sortParameters1[i].isExpanded) !== Boolean(sortParameters2[i].isExpanded))
                                        return false;
                            return true
                        }
                        else
                            return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length)
                    };
                var getFirstItems = function(dataSource) {
                        var groupsCount,
                            items = [];
                        var getFirstItemsCore = function(items, groupsCount) {
                                var i,
                                    childItems;
                                if (!items || !groupsCount)
                                    return items;
                                for (i = 0; i < items.length; i++) {
                                    childItems = getFirstItemsCore(items[i].items || items[i].collapsedItems, groupsCount - 1);
                                    if (childItems && childItems.length)
                                        return childItems
                                }
                            };
                        if (dataSource && dataSource.items().length > 0) {
                            groupsCount = normalizeSortingInfo(dataSource.group()).length;
                            items = getFirstItemsCore(dataSource.items(), groupsCount) || []
                        }
                        return items
                    };
                var updateColumnIndexes = function(that) {
                        $.each(that._columns, function(index, column) {
                            column.index = index
                        });
                        $.each(that._commandColumns, function(index, column) {
                            column.index = -(index + 1)
                        })
                    };
                var updateColumnGroupIndexes = function(that, currentColumn) {
                        normalizeIndexes(that._columns, "groupIndex", currentColumn, function(column) {
                            var grouped = column.grouped;
                            delete column.grouped;
                            return grouped
                        })
                    };
                var updateColumnSortIndexes = function(that, currentColumn) {
                        $.each(that._columns, function(index, column) {
                            if (isDefined(column.sortIndex) && !isSortOrderValid(column.sortOrder))
                                delete column.sortIndex
                        });
                        normalizeIndexes(that._columns, "sortIndex", currentColumn, function(column) {
                            return !isDefined(column.groupIndex) && isSortOrderValid(column.sortOrder)
                        })
                    };
                var updateColumnVisibleIndexes = function(that, currentColumn) {
                        normalizeIndexes(that._columns, "visibleIndex", currentColumn)
                    };
                var getColumnIndexByVisibleIndex = function(that, visibleIndex, location) {
                        var columns = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getChooserColumns() : that.getVisibleColumns(),
                            column = columns[visibleIndex];
                        return column && isDefined(column.index) ? column.index : -1
                    };
                var moveColumnToGroup = function(that, column, groupIndex) {
                        var groupColumns = that.getGroupColumns(),
                            i;
                        if (groupIndex >= 0) {
                            for (i = 0; i < groupColumns.length; i++)
                                if (groupColumns[i].groupIndex >= groupIndex)
                                    groupColumns[i].groupIndex++
                        }
                        else {
                            groupIndex = 0;
                            for (i = 0; i < groupColumns.length; i++)
                                groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1)
                        }
                        column.groupIndex = groupIndex
                    };
                var checkUserStateColumn = function(column, userStateColumn) {
                        return column && userStateColumn && userStateColumn.name === column.name && (userStateColumn.dataField === column.dataField || column.name)
                    };
                var applyUserState = function(that) {
                        var columnsUserState = that._columnsUserState,
                            ignoreColumnOptionNames = that._ignoreColumnOptionNames || [],
                            columns = that._columns,
                            resultColumns = [],
                            column,
                            i;
                        function handleStateField(index, fieldName) {
                            if ($.inArray(fieldName, ignoreColumnOptionNames) >= 0)
                                return;
                            if (fieldName === "dataType")
                                column[fieldName] = column[fieldName] || columnsUserState[i][fieldName];
                            else if ($.inArray(fieldName, USER_STATE_FIELD_NAMES_15_1) >= 0) {
                                if (fieldName in columnsUserState[i])
                                    column[fieldName] = columnsUserState[i][fieldName]
                            }
                            else
                                column[fieldName] = columnsUserState[i][fieldName]
                        }
                        if (columnsUserState) {
                            if (columns.length !== columnsUserState.length)
                                return;
                            for (i = 0; i < columnsUserState.length; i++) {
                                column = isDefined(columnsUserState[i].initialIndex) ? columns[columnsUserState[i].initialIndex] : columns[i];
                                if (column && checkUserStateColumn(column, columnsUserState[i])) {
                                    column = $.extend({}, column);
                                    $.each(USER_STATE_FIELD_NAMES, handleStateField);
                                    resultColumns.push(column)
                                }
                                else
                                    return
                            }
                            assignColumns(that, resultColumns)
                        }
                    };
                var updateIndexes = function(that, column) {
                        updateColumnIndexes(that);
                        updateColumnGroupIndexes(that, column);
                        updateColumnSortIndexes(that, column);
                        updateColumnVisibleIndexes(that, column)
                    };
                var assignColumns = function(that, columns) {
                        that._columns = columns;
                        that._visibleColumns = undefined;
                        that.updateColumnDataTypes()
                    };
                var updateColumnChanges = function(that, changeType, optionName, columnIndex) {
                        var columnChanges = that._columnChanges || {
                                optionNames: {length: 0},
                                changeTypes: {length: 0},
                                columnIndex: columnIndex
                            };
                        optionName = optionName || "all";
                        var changeTypes = columnChanges.changeTypes;
                        if (changeType && !changeTypes[changeType]) {
                            changeTypes[changeType] = true;
                            changeTypes.length++
                        }
                        var optionNames = columnChanges.optionNames;
                        if (optionName && !optionNames[optionName]) {
                            optionNames[optionName] = true;
                            optionNames.length++
                        }
                        if (columnIndex === undefined || columnIndex !== columnChanges.columnIndex)
                            delete columnChanges.columnIndex;
                        that._columnChanges = columnChanges;
                        that._visibleColumns = undefined
                    };
                var fireColumnsChanged = function(that) {
                        var onColumnsChanging = that.option("onColumnsChanging"),
                            columnChanges = that._columnChanges;
                        if (that.isInitialized() && !that._updateLockCount && columnChanges) {
                            if (onColumnsChanging) {
                                that._updateLockCount++;
                                onColumnsChanging($.extend({component: that.component}, columnChanges));
                                that._updateLockCount--
                            }
                            that._columnChanges = undefined;
                            if (columnChanges.optionNames && columnChanges.optionNames.dataField)
                                that.reinit();
                            that.columnsChanged.firing = true;
                            that.columnsChanged.fire(columnChanges);
                            that.columnsChanged.firing = false
                        }
                    };
                var columnOptionCore = function(that, column, optionName, value, notFireEvent) {
                        var optionGetter = dataUtils.compileGetter(optionName),
                            changeType;
                        if (arguments.length === 3)
                            return optionGetter(column, {functionsAsIs: true});
                        if (optionGetter(column, {functionsAsIs: true}) !== value) {
                            if (optionName === "groupIndex")
                                changeType = "grouping";
                            else if (optionName === "sortIndex" || optionName === "sortOrder")
                                changeType = "sorting";
                            else
                                changeType = "columns";
                            dataUtils.compileSetter(optionName)(column, value, {functionsAsIs: true});
                            if (!notFireEvent)
                                updateColumnChanges(that, changeType, optionName, column.index)
                        }
                    };
                var isSortOrderValid = function(sortOrder) {
                        return sortOrder === "asc" || sortOrder === "desc"
                    };
                var addExpandColumn = function(that) {
                        that.addCommandColumn({
                            command: "expand",
                            width: "auto",
                            cssClass: DATAGRID_COMMAND_EXPAND_CLASS,
                            allowEditing: false,
                            allowGrouping: false,
                            allowSorting: false,
                            allowResizing: false,
                            allowReordering: false,
                            allowHiding: false
                        })
                    };
                return {
                        _endUpdateCore: function() {
                            fireColumnsChanged(this)
                        },
                        init: function() {
                            var that = this,
                                columns = that.option("columns");
                            that._commandColumns = that._commandColumns || [];
                            that._columns = that._columns || [];
                            addExpandColumn(that);
                            that._isColumnsFromOptions = !!columns;
                            if (that._isColumnsFromOptions) {
                                assignColumns(that, columns ? createColumnsFromOptions(that, columns) : []);
                                applyUserState(that)
                            }
                            else
                                assignColumns(that, that._columnsUserState ? createColumnsFromOptions(that, that._columnsUserState) : that._columns);
                            if (that._dataSourceApplied)
                                that.applyDataSource(that._dataSource, true);
                            else
                                updateIndexes(that)
                        },
                        callbackNames: function() {
                            return ["columnsChanged"]
                        },
                        optionChanged: function(args) {
                            switch (args.name) {
                                case"columns":
                                    args.handled = true;
                                    this._columnsUserState = null;
                                    this._ignoreColumnOptionNames = null;
                                    this.init();
                                    break;
                                case"commonColumnSettings":
                                case"columnAutoWidth":
                                case"allowColumnResizing":
                                case"allowColumnReordering":
                                case"columnFixing":
                                case"grouping":
                                case"groupPanel":
                                case"regenerateColumnsByVisibleItems":
                                case"customizeColumns":
                                case"editing":
                                    args.handled = true;
                                    this.reinit();
                                    break;
                                case"rtlEnabled":
                                    this.reinit();
                                    break;
                                default:
                                    this.callBase(args)
                            }
                        },
                        publicMethods: function() {
                            return ["addColumn", "columnOption", "columnCount", "clearSorting", "clearGrouping"]
                        },
                        applyDataSource: function(dataSource, forceApplying) {
                            var that = this,
                                isDataSourceLoaded = dataSource && dataSource.isLoaded();
                            that._dataSource = dataSource;
                            if (!that._dataSourceApplied || that._dataSourceColumnsCount === 0 || forceApplying || that.option("regenerateColumnsByVisibleItems"))
                                if (isDataSourceLoaded) {
                                    if (!that._isColumnsFromOptions) {
                                        assignColumns(that, createColumnsFromDataSource(that, dataSource));
                                        that._dataSourceColumnsCount = that._columns.length;
                                        applyUserState(that)
                                    }
                                    return that.updateColumns(dataSource, forceApplying)
                                }
                        },
                        reset: function() {
                            this._dataSourceApplied = false;
                            this._dataSourceColumnsCount = undefined;
                            this.reinit()
                        },
                        reinit: function() {
                            this._columnsUserState = this.getUserState();
                            this._ignoreColumnOptionNames = null;
                            this.init()
                        },
                        isInitialized: function() {
                            return !!this._columns.length
                        },
                        isDataSourceApplied: function() {
                            return this._dataSourceApplied
                        },
                        getCommonSettings: function() {
                            var commonColumnSettings = this.option("commonColumnSettings") || {},
                                groupingOptions = this.option("grouping") || {},
                                groupPanelOptions = this.option("groupPanel") || {};
                            return $.extend({
                                    allowFixing: this.option("columnFixing.enabled"),
                                    allowResizing: this.option("allowColumnResizing"),
                                    allowReordering: this.option("allowColumnReordering"),
                                    autoExpandGroup: groupingOptions.autoExpandAll,
                                    allowCollapsing: groupingOptions.allowCollapsing,
                                    allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible
                                }, commonColumnSettings)
                        },
                        isColumnOptionUsed: function(optionName) {
                            for (var i = 0; i < this._columns.length; i++)
                                if (this._columns[i][optionName])
                                    return true
                        },
                        isAllDataTypesDefined: function() {
                            var columns = this._columns,
                                i;
                            if (!columns.length)
                                return false;
                            for (i = 0; i < columns.length; i++)
                                if (!columns[i].dataType)
                                    return false;
                            return true
                        },
                        getColumns: function() {
                            return $.extend(true, [], this._columns)
                        },
                        getGroupColumns: function() {
                            var result = [];
                            $.each(this._columns, function() {
                                var column = this;
                                if (isDefined(column.groupIndex))
                                    result[column.groupIndex] = column
                            });
                            return result
                        },
                        getVisibleColumns: function() {
                            this._visibleColumns = this._visibleColumns || this._getVisibleColumnsCore();
                            return this._visibleColumns
                        },
                        getFixedColumns: function() {
                            var that = this,
                                result = [],
                                isColumnFixing = that._isColumnFixing(),
                                notFixedColumnCount = 0,
                                transparentColumnIndex,
                                visibleColumns;
                            if (isColumnFixing) {
                                visibleColumns = that.getVisibleColumns();
                                $.each(visibleColumns, function(index, column) {
                                    if (!column.command && !column.fixed) {
                                        notFixedColumnCount++;
                                        if (!isDefined(transparentColumnIndex))
                                            transparentColumnIndex = index
                                    }
                                });
                                if (notFixedColumnCount < visibleColumns.length) {
                                    result = visibleColumns.slice(0);
                                    result.splice(transparentColumnIndex, notFixedColumnCount, {
                                        command: "transparent",
                                        colspan: notFixedColumnCount
                                    })
                                }
                            }
                            return result
                        },
                        _isColumnFixing: function() {
                            var isColumnFixing = this.option("columnFixing.enabled");
                            !isColumnFixing && $.each(this._columns, function(_, column) {
                                if (column.fixed) {
                                    isColumnFixing = true;
                                    return false
                                }
                            });
                            return isColumnFixing
                        },
                        _getExpandColumnsCore: function() {
                            return this.getGroupColumns()
                        },
                        getExpandColumns: function() {
                            var expandColumns = this._getExpandColumnsCore(),
                                expandColumn;
                            if (expandColumns.length)
                                expandColumn = this.columnOption("command:expand");
                            expandColumns = $.map(expandColumns, function(column) {
                                return $.extend({}, column, {visibleWidth: "auto"}, expandColumn, {index: column.index})
                            });
                            return expandColumns
                        },
                        _getVisibleColumnsCore: function() {
                            var result = this.getExpandColumns(),
                                positiveIndexedColumns = [{}, {}, {}],
                                negativeIndexedColumns = {},
                                notGroupedColumnsCount = 0,
                                isFixedToEnd,
                                rtlEnabled = this.option("rtlEnabled"),
                                columns = this._columns.length ? this._commandColumns.concat(this._columns) : [];
                            $.each(columns, function() {
                                var column = this,
                                    visibleIndex = column.visibleIndex,
                                    indexedColumns;
                                if (column.visible && (!isDefined(column.groupIndex) || column.showWhenGrouped)) {
                                    column = $.extend(true, {}, column);
                                    if (visibleIndex < 0) {
                                        visibleIndex = -visibleIndex;
                                        indexedColumns = negativeIndexedColumns
                                    }
                                    else if (column.fixed || column.command) {
                                        isFixedToEnd = column.fixedPosition === "right";
                                        if (rtlEnabled)
                                            isFixedToEnd = !isFixedToEnd;
                                        if (isFixedToEnd || column.command)
                                            indexedColumns = positiveIndexedColumns[2];
                                        else
                                            indexedColumns = positiveIndexedColumns[0]
                                    }
                                    else
                                        indexedColumns = positiveIndexedColumns[1];
                                    indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];
                                    indexedColumns[visibleIndex].push(column);
                                    notGroupedColumnsCount++
                                }
                            });
                            utils.orderEach(negativeIndexedColumns, function(_, columns) {
                                result.unshift.apply(result, columns)
                            });
                            $.each(positiveIndexedColumns, function(index, positiveColumns) {
                                utils.orderEach(positiveColumns, function(_, columns) {
                                    result.push.apply(result, columns)
                                })
                            });
                            if (!notGroupedColumnsCount && this._columns.length)
                                result.push({command: "empty"});
                            return result
                        },
                        getHiddenColumns: function() {
                            var result = [];
                            $.each(this._columns, function(_, column) {
                                if (!column.visible)
                                    result.push(column)
                            });
                            return result
                        },
                        getChooserColumns: function() {
                            return $.grep(this.getHiddenColumns(), function(column) {
                                    return column.showInColumnChooser
                                })
                        },
                        allowMoveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                            var that = this,
                                columnIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation),
                                sourceColumn = that._columns[columnIndex];
                            if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {
                                if (sourceLocation === targetLocation) {
                                    if (sourceLocation === COLUMN_CHOOSER_LOCATION)
                                        return false;
                                    return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex
                                }
                                else if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION)
                                    return sourceColumn && sourceColumn.allowGrouping;
                                else if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION)
                                    return sourceColumn && sourceColumn.allowHiding;
                                return true
                            }
                            return false
                        },
                        moveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                            var that = this,
                                fromIndex,
                                toIndex,
                                targetGroupIndex,
                                isGroupMoving = sourceLocation === GROUP_LOCATION || targetLocation === GROUP_LOCATION,
                                column;
                            fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation);
                            toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation);
                            if (fromIndex >= 0) {
                                column = that._columns[fromIndex];
                                targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;
                                if (isDefined(column.groupIndex) && sourceLocation === GROUP_LOCATION) {
                                    if (targetGroupIndex > column.groupIndex)
                                        targetGroupIndex--;
                                    delete column.groupIndex;
                                    delete column.sortOrder;
                                    updateColumnGroupIndexes(that)
                                }
                                if (targetLocation === GROUP_LOCATION) {
                                    moveColumnToGroup(that, column, targetGroupIndex);
                                    updateColumnGroupIndexes(that)
                                }
                                else if (toVisibleIndex >= 0) {
                                    if (toIndex < 0)
                                        column.visibleIndex = undefined;
                                    else {
                                        var targetColumn = that._columns[toIndex];
                                        if (column.fixed ^ targetColumn.fixed)
                                            column.visibleIndex = undefined;
                                        else
                                            column.visibleIndex = targetColumn.visibleIndex
                                    }
                                    updateColumnVisibleIndexes(that, column)
                                }
                                column.visible = targetLocation !== COLUMN_CHOOSER_LOCATION;
                                updateColumnChanges(that, isGroupMoving ? "grouping" : "columns");
                                fireColumnsChanged(that)
                            }
                        },
                        changeSortOrder: function(columnIndex, sortOrder) {
                            var that = this,
                                sortingOptions = that.option("sorting"),
                                sortingMode = sortingOptions && sortingOptions.mode,
                                needResetSorting = sortingMode === "single" || !sortOrder,
                                allowSorting = sortingMode === "single" || sortingMode === "multiple",
                                column = that._columns[columnIndex],
                                nextSortOrder = function(column) {
                                    if (sortOrder === "ctrl") {
                                        if (!("sortOrder" in column && "sortIndex" in column))
                                            return false;
                                        delete column.sortOrder;
                                        delete column.sortIndex
                                    }
                                    else if (isDefined(column.groupIndex) || isDefined(column.sortIndex))
                                        column.sortOrder = column.sortOrder === "desc" ? "asc" : "desc";
                                    else
                                        column.sortOrder = "asc";
                                    return true
                                },
                                isSortingChanged = false;
                            if (allowSorting && column && column.allowSorting) {
                                if (needResetSorting && !isDefined(column.groupIndex))
                                    $.each(that._columns, function(index) {
                                        if (index !== columnIndex && this.sortOrder && !isDefined(this.groupIndex)) {
                                            delete this.sortOrder;
                                            delete this.sortIndex;
                                            isSortingChanged = true
                                        }
                                    });
                                if (isSortOrderValid(sortOrder)) {
                                    if (column.sortOrder !== sortOrder) {
                                        column.sortOrder = sortOrder;
                                        isSortingChanged = true
                                    }
                                }
                                else if (sortOrder === "none") {
                                    if (column.sortOrder) {
                                        delete column.sortIndex;
                                        delete column.sortOrder;
                                        isSortingChanged = true
                                    }
                                }
                                else
                                    isSortingChanged = nextSortOrder(column)
                            }
                            if (isSortingChanged) {
                                updateColumnSortIndexes(that);
                                updateColumnChanges(that, "sorting");
                                fireColumnsChanged(that)
                            }
                        },
                        getSortDataSourceParameters: function(useLocalSelector) {
                            var that = this,
                                sortColumns = [],
                                sort = [];
                            $.each(that._columns, function() {
                                if ((this.dataField || this.selector || this.calculateCellValue) && isDefined(this.sortIndex) && !isDefined(this.groupIndex))
                                    sortColumns[this.sortIndex] = this
                            });
                            $.each(sortColumns, function() {
                                var sortOrder = this && this.sortOrder;
                                if (isSortOrderValid(sortOrder))
                                    sort.push({
                                        selector: this.calculateSortValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,
                                        desc: this.sortOrder === "desc"
                                    })
                            });
                            return sort.length > 0 ? sort : null
                        },
                        getGroupDataSourceParameters: function(useLocalSelector) {
                            var group = [];
                            $.each(this.getGroupColumns(), function() {
                                var selector = this.calculateGroupValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;
                                if (selector)
                                    group.push({
                                        selector: selector,
                                        desc: this.sortOrder === "desc",
                                        isExpanded: !!this.autoExpandGroup
                                    })
                            });
                            return group.length > 0 ? group : null
                        },
                        refresh: function(updateNewLookupsOnly) {
                            var deferreds = [];
                            $.each(this._columns, function() {
                                var lookup = this.lookup;
                                if (lookup) {
                                    if (updateNewLookupsOnly && lookup.valueMap)
                                        return;
                                    if (lookup.update)
                                        deferreds.push(lookup.update())
                                }
                            });
                            return $.when.apply($, deferreds)
                        },
                        updateColumnDataTypes: function(dataSource) {
                            var firstItems = getFirstItems(dataSource),
                                rtlEnabled = this.option("rtlEnabled");
                            $.each(this._columns, function(index, column) {
                                var i,
                                    value,
                                    dataType,
                                    lookupDataType,
                                    valueDataType,
                                    lookup = column.lookup;
                                if (column.calculateCellValue && firstItems.length) {
                                    if (!column.dataType || lookup && !lookup.dataType) {
                                        for (i = 0; i < firstItems.length; i++) {
                                            value = column.calculateCellValue(firstItems[i]);
                                            valueDataType = column.dataType || getValueDataType(value);
                                            dataType = dataType || valueDataType;
                                            if (dataType && valueDataType && dataType !== valueDataType)
                                                dataType = "string";
                                            if (lookup) {
                                                valueDataType = lookup.dataType || getValueDataType(lookup.calculateCellValue(value));
                                                lookupDataType = lookupDataType || valueDataType;
                                                if (lookupDataType && valueDataType && lookupDataType !== valueDataType)
                                                    lookupDataType = "string"
                                            }
                                        }
                                        column.dataType = dataType;
                                        if (lookup)
                                            lookup.dataType = lookupDataType
                                    }
                                    if (!column.serializationFormat || lookup && !lookup.serializationFormat)
                                        for (i = 0; i < firstItems.length; i++) {
                                            value = column.calculateCellValue(firstItems[i], true);
                                            column.serializationFormat = column.serializationFormat || getSerializationFormat(column.dataType, value);
                                            if (lookup)
                                                lookup.serializationFormat = lookup.serializationFormat || getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value, true))
                                        }
                                }
                                column.selector = column.selector || function(data) {
                                    return column.calculateCellValue(data)
                                };
                                updateSerializers(column, column.dataType);
                                if (lookup)
                                    updateSerializers(lookup, lookup.dataType);
                                dataType = lookup ? lookup.dataType : column.dataType;
                                if (dataType) {
                                    column.alignment = column.alignment || getAlignmentByDataType(dataType, rtlEnabled);
                                    column.format = column.format || dataGrid.getFormatByDataType(dataType);
                                    column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);
                                    if (!isDefined(column.filterOperations))
                                        column.filterOperations = !lookup && DATATYPE_OPERATIONS[dataType] || [];
                                    column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || "=";
                                    column.defaultSelectedFilterOperation = column.selectedFilterOperation;
                                    column.showEditorAlways = isDefined(column.showEditorAlways) ? column.showEditorAlways : dataType === "boolean" && !column.cellTemplate
                                }
                            })
                        },
                        _customizeColumns: function(columns) {
                            var that = this,
                                customizeColumns = that.option("customizeColumns");
                            if (customizeColumns) {
                                customizeColumns(columns);
                                assignColumns(that, createColumnsFromOptions(that, columns))
                            }
                        },
                        updateColumns: function(dataSource, forceApplying) {
                            var that = this,
                                sortParameters,
                                groupParameters;
                            if (!forceApplying)
                                that.updateSortingGrouping(dataSource);
                            if (!dataSource || dataSource.isLoaded()) {
                                sortParameters = dataSource ? dataSource.sort() || [] : that.getSortDataSourceParameters();
                                groupParameters = dataSource ? dataSource.group() || [] : that.getGroupDataSourceParameters();
                                that._customizeColumns(that._columns);
                                updateIndexes(that);
                                return $.when(that.refresh(true)).always(function() {
                                        if (dataSource) {
                                            that.updateColumnDataTypes(dataSource);
                                            that._dataSourceApplied = true
                                        }
                                        if (!equalSortParameters(sortParameters, that.getSortDataSourceParameters()))
                                            updateColumnChanges(that, "sorting");
                                        if (!equalSortParameters(groupParameters, that.getGroupDataSourceParameters()))
                                            updateColumnChanges(that, "grouping");
                                        updateColumnChanges(that, "columns");
                                        fireColumnsChanged(that)
                                    })
                            }
                        },
                        updateSortingGrouping: function(dataSource, fromDataSource) {
                            var that = this,
                                sortParameters,
                                groupParameters,
                                columnsGroupParameters,
                                columnsSortParameters,
                                isColumnsChanged,
                                updateSortGroupParameterIndexes = function(columns, sortParameters, indexParameterName) {
                                    var i,
                                        selector,
                                        isExpanded;
                                    $.each(columns, function(index, column) {
                                        delete column[indexParameterName];
                                        if (sortParameters)
                                            for (i = 0; i < sortParameters.length; i++) {
                                                selector = sortParameters[i].selector;
                                                isExpanded = sortParameters[i].isExpanded;
                                                if (selector === column.dataField || selector === column.name || selector === column.selector || selector === column.calculateCellValue || selector === column.calculateGroupValue) {
                                                    column.sortOrder = column.sortOrder || (sortParameters[i].desc ? "desc" : "asc");
                                                    if (isExpanded !== undefined)
                                                        column.autoExpandGroup = isExpanded;
                                                    column[indexParameterName] = i;
                                                    break
                                                }
                                            }
                                    })
                                };
                            if (dataSource) {
                                sortParameters = normalizeSortingInfo(dataSource.sort());
                                groupParameters = normalizeSortingInfo(dataSource.group());
                                columnsGroupParameters = that.getGroupDataSourceParameters();
                                columnsSortParameters = that.getSortDataSourceParameters();
                                if (!that._columns.length) {
                                    $.each(groupParameters, function(index, group) {
                                        that._columns.push(group.selector)
                                    });
                                    $.each(sortParameters, function(index, sort) {
                                        that._columns.push(sort.selector)
                                    });
                                    assignColumns(that, createColumnsFromOptions(that, that._columns))
                                }
                                if ((fromDataSource || !columnsGroupParameters && !that._hasUserState) && !equalSortParameters(groupParameters, columnsGroupParameters)) {
                                    that.__groupingUpdated = true;
                                    updateSortGroupParameterIndexes(that._columns, groupParameters, "groupIndex");
                                    if (fromDataSource) {
                                        updateColumnChanges(that, "grouping");
                                        isColumnsChanged = true
                                    }
                                }
                                if ((fromDataSource || !columnsSortParameters && !that._hasUserState) && !equalSortParameters(sortParameters, columnsSortParameters)) {
                                    that.__sortingUpdated = true;
                                    updateSortGroupParameterIndexes(that._columns, sortParameters, "sortIndex");
                                    if (fromDataSource) {
                                        updateColumnChanges(that, "sorting");
                                        isColumnsChanged = true
                                    }
                                }
                                if (isColumnsChanged)
                                    fireColumnsChanged(that)
                            }
                        },
                        updateFilter: function(filter) {
                            var that = this;
                            if (!utils.isArray(filter))
                                return;
                            var column,
                                i;
                            if (utils.isString(filter[0])) {
                                column = that.columnOption(filter[0]);
                                if (column && column.calculateCellValue)
                                    filter[0] = $.proxy(column, "calculateCellValue")
                            }
                            for (i = 0; i < filter.length; i++)
                                that.updateFilter(filter[i])
                        },
                        columnCount: function() {
                            return this._columns.length
                        },
                        columnOption: function(identificator, option, value, notFireEvent) {
                            var that = this,
                                i,
                                identificatorOptionName = utils.isString(identificator) && identificator.substr(0, identificator.indexOf(":")),
                                columns = identificator < 0 || identificatorOptionName === "command" ? that._commandColumns : that._columns,
                                column;
                            if (identificator === undefined)
                                return;
                            if (identificatorOptionName)
                                identificator = identificator.substr(identificatorOptionName.length + 1);
                            for (i = 0; i < columns.length; i++)
                                if (identificatorOptionName) {
                                    if ("" + columns[i][identificatorOptionName] === identificator) {
                                        column = columns[i];
                                        break
                                    }
                                }
                                else if (columns[i].index === identificator || columns[i].name === identificator || columns[i].dataField === identificator || columns[i].caption === identificator) {
                                    column = columns[i];
                                    break
                                }
                            if (column) {
                                if (arguments.length === 1)
                                    return $.extend({}, column);
                                if (utils.isString(option))
                                    if (arguments.length === 2)
                                        return columnOptionCore(that, column, option);
                                    else
                                        columnOptionCore(that, column, option, value, notFireEvent);
                                else if (utils.isObject(option))
                                    $.each(option, function(optionName, value) {
                                        columnOptionCore(that, column, optionName, value, notFireEvent)
                                    });
                                updateIndexes(that, column);
                                fireColumnsChanged(that)
                            }
                        },
                        clearSorting: function() {
                            var that = this,
                                columnCount = this.columnCount(),
                                i;
                            that.beginUpdate();
                            for (i = 0; i < columnCount; i++)
                                that.columnOption(i, "sortOrder", undefined);
                            that.endUpdate()
                        },
                        clearGrouping: function() {
                            var that = this,
                                columnCount = this.columnCount(),
                                i;
                            that.beginUpdate();
                            for (i = 0; i < columnCount; i++)
                                that.columnOption(i, "groupIndex", undefined);
                            that.endUpdate()
                        },
                        getVisibleIndex: function(index) {
                            var i,
                                visibleColumns = this.getVisibleColumns();
                            for (i = 0; i < visibleColumns.length; i++)
                                if (visibleColumns[i].index === index)
                                    return i;
                            return -1
                        },
                        addColumn: function(options) {
                            var that = this,
                                column = createColumn(that, options);
                            that._columns.push(column);
                            updateIndexes(that, column);
                            that.updateColumns(that._dataSource)
                        },
                        addCommandColumn: function(options) {
                            var commandColumns = this._commandColumns,
                                i;
                            for (i = 0; i < commandColumns.length; i++)
                                if (commandColumns[i].command === options.command)
                                    return;
                            commandColumns.push(options)
                        },
                        getUserState: function() {
                            var columns = this._columns,
                                result = [],
                                i;
                            function handleStateField(index, value) {
                                if (columns[i][value] !== undefined)
                                    result[i][value] = columns[i][value]
                            }
                            for (i = 0; i < columns.length; i++) {
                                result[i] = {};
                                $.each(USER_STATE_FIELD_NAMES, handleStateField)
                            }
                            return result
                        },
                        setUserState: function(state) {
                            var that = this,
                                commonColumnSettings,
                                ignoreColumnOptionNames = that.option("stateStoring.ignoreColumnOptionNames");
                            if (!ignoreColumnOptionNames) {
                                ignoreColumnOptionNames = [];
                                commonColumnSettings = that.getCommonSettings();
                                if (!that.option("columnChooser.enabled"))
                                    ignoreColumnOptionNames.push("visible");
                                if (that.option("sorting.mode") === "none")
                                    ignoreColumnOptionNames.push("sortIndex", "sortOrder");
                                if (!commonColumnSettings.allowGrouping)
                                    ignoreColumnOptionNames.push("groupIndex");
                                if (!commonColumnSettings.allowFixing)
                                    ignoreColumnOptionNames.push("fixed", "fixedPosition");
                                if (!commonColumnSettings.allowResizing)
                                    ignoreColumnOptionNames.push("width", "visibleWidth");
                                if (!that.option("filterRow.visible"))
                                    ignoreColumnOptionNames.push("filterValue", "selectedFilterOperation");
                                if (!that.option("headerFilter.visible"))
                                    ignoreColumnOptionNames.push("filterValues", "filterType")
                            }
                            that._columnsUserState = state;
                            that._ignoreColumnOptionNames = ignoreColumnOptionNames;
                            that._hasUserState = !!state;
                            that.init()
                        },
                        _createCalculatedColumnOptions: function(columnOptions) {
                            var calculatedColumnOptions = {},
                                dataField = columnOptions.dataField,
                                getter;
                            if (dataField && utils.isString(dataField)) {
                                getter = dataUtils.compileGetter(dataField);
                                calculatedColumnOptions = {
                                    caption: convertNameToCaption(dataField),
                                    calculateCellValue: function(data, skipDeserialization) {
                                        var value = getter(data);
                                        return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value
                                    },
                                    setCellValue: function(data, value) {
                                        var path = this.dataField.split("."),
                                            dotCount = path.length - 1,
                                            name,
                                            i;
                                        if (this.serializeValue)
                                            value = this.serializeValue(value);
                                        for (i = 0; i < dotCount; i++) {
                                            name = path[i];
                                            data = data[name] = data[name] || {}
                                        }
                                        data[path[dotCount]] = value
                                    },
                                    parseValue: function(text) {
                                        var column = this,
                                            result,
                                            parsedValue;
                                        if (column.dataType === "number") {
                                            if (utils.isString(text)) {
                                                parsedValue = Globalize.parseFloat(text);
                                                if (utils.isNumber(parsedValue))
                                                    result = parsedValue
                                            }
                                            else if (utils.isDefined(text))
                                                result = Number(text)
                                        }
                                        else if (column.dataType === "boolean") {
                                            if (text === column.trueText)
                                                result = true;
                                            else if (text === column.falseText)
                                                result = false
                                        }
                                        else if (column.dataType === "date") {
                                            parsedValue = Globalize.parseDate(text);
                                            if (parsedValue)
                                                result = parsedValue
                                        }
                                        else
                                            result = text;
                                        return result
                                    }
                                }
                            }
                            else
                                $.extend(true, calculatedColumnOptions, {
                                    allowSorting: false,
                                    allowGrouping: false,
                                    calculateCellValue: function() {
                                        return null
                                    }
                                });
                            if (columnOptions.dataType)
                                calculatedColumnOptions.userDataType = columnOptions.dataType;
                            if (columnOptions.lookup)
                                calculatedColumnOptions.lookup = {
                                    calculateCellValue: function(value, skipDeserialization) {
                                        if (this.valueExpr)
                                            value = this.valueMap && this.valueMap[value];
                                        return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value
                                    },
                                    updateValueMap: function() {
                                        var calculateValue,
                                            calculateDisplayValue,
                                            item,
                                            i;
                                        this.valueMap = {};
                                        if (this.items) {
                                            calculateValue = dataUtils.compileGetter(this.valueExpr);
                                            calculateDisplayValue = dataUtils.compileGetter(this.displayExpr);
                                            for (i = 0; i < this.items.length; i++) {
                                                item = this.items[i];
                                                this.valueMap[calculateValue(item)] = calculateDisplayValue(item)
                                            }
                                        }
                                    },
                                    update: function() {
                                        var that = this,
                                            dataSource = that.dataSource,
                                            dataSourceOptions;
                                        if (dataSource)
                                            if (utils.isObject(dataSource) || utils.isArray(dataSource)) {
                                                if (that.valueExpr) {
                                                    dataSourceOptions = dataUtils.normalizeDataSourceOptions(dataSource);
                                                    dataSourceOptions.paginate = false;
                                                    dataSource = new DX.data.DataSource(dataSourceOptions);
                                                    return dataSource.load().done(function(data) {
                                                            that.items = data;
                                                            that.updateValueMap && that.updateValueMap()
                                                        })
                                                }
                                            }
                                            else
                                                DX.log("E1016");
                                        else
                                            that.updateValueMap && that.updateValueMap()
                                    }
                                };
                            calculatedColumnOptions.resizedCallbacks = $.Callbacks();
                            if (columnOptions.resized)
                                calculatedColumnOptions.resizedCallbacks.add($.proxy(columnOptions.resized, columnOptions));
                            return calculatedColumnOptions
                        }
                    }
            }());
        ui.dxDataGrid.ColumnsController = ColumnsController;
        dataGrid.registerModule("columns", {
            defaultOptions: function() {
                return {
                        commonColumnSettings: {
                            allowFiltering: true,
                            allowHiding: true,
                            allowSorting: true,
                            allowEditing: true,
                            encodeHtml: true,
                            trueText: Globalize.localize("dxDataGrid-trueText"),
                            falseText: Globalize.localize("dxDataGrid-falseText")
                        },
                        allowColumnReordering: false,
                        allowColumnResizing: false,
                        columns: undefined,
                        regenerateColumnsByVisibleItems: false,
                        customizeColumns: null
                    }
            },
            controllers: {columns: ColumnsController}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.selection.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            events = DX.ui.events,
            utils = DX.utils;
        var DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_ROW_SELECTION_CLASS = "dx-selection",
            DATAGRID_SELECT_CHECKBOX_CLASS = "dx-select-checkbox",
            DATAGRID_CHECKBOXES_HIDDEN_CLASS = "dx-select-checkboxes-hidden",
            DATAGRID_COMMAND_SELECT_CLASS = "dx-command-select",
            DATAGRID_SELECTION_DISABLED_CLASS = "dx-selection-disabled",
            DATAGRID_DATA_ROW_CLASS = "dx-data-row";
        $.extend(dataGrid.__internals, {
            DATAGRID_ROW_SELECTION_CLASS: DATAGRID_ROW_SELECTION_CLASS,
            DATAGRID_SELECTION_DISABLED_CLASS: DATAGRID_SELECTION_DISABLED_CLASS,
            DATAGRID_COMMAND_SELECT_CLASS: DATAGRID_COMMAND_SELECT_CLASS
        });
        var SHOW_CHECKBOXES_MODE = "selection.showCheckBoxesInMultipleMode";
        var SELECTION_MODE = "selection.mode";
        var isSelectable = function(selectionMode) {
                return selectionMode === "single" || selectionMode === "multiple"
            };
        dataGrid.SelectionController = dataGrid.Controller.inherit(function() {
            var indexOfSelectedItemKey = function(that, key, isSelectAll) {
                    var index,
                        selectedItemKeys = isSelectAll ? that._unselectedItemKeys : that._selectedItemKeys;
                    if (utils.isObject(key)) {
                        for (index = 0; index < selectedItemKeys.length; index++)
                            if (equalKeys(selectedItemKeys[index], key))
                                return index;
                        return -1
                    }
                    else
                        return $.inArray(key, selectedItemKeys)
                };
            var addSelectedItem = function(that, itemData) {
                    var key = that.getController("data").keyOf(itemData);
                    if (indexOfSelectedItemKey(that, key) === -1) {
                        that._selectedItemKeys.push(key);
                        that._addedItemKeys.push(key);
                        that._selectedItems.push(itemData)
                    }
                };
            var removeSelectedItem = function(that, key) {
                    var keyIndex = indexOfSelectedItemKey(that, key);
                    if (keyIndex >= 0) {
                        that._selectedItemKeys.splice(keyIndex, 1);
                        that._removedItemKeys.push(key);
                        that._selectedItems.splice(keyIndex, 1)
                    }
                };
            var clearSelectedItems = function(that) {
                    setSelectedItems(that, [], [])
                };
            var setSelectedItems = function(that, keys, items) {
                    var i,
                        oldSelectedItemKeys = that._selectedItemKeys;
                    that._selectedItemKeys = keys;
                    that._selectedItems = items;
                    that._unselectedItemKeys = [];
                    for (i = 0; i < oldSelectedItemKeys.length; i++)
                        if ($.inArray(oldSelectedItemKeys[i], keys) === -1)
                            that._removedItemKeys.push(oldSelectedItemKeys[i]);
                    for (i = 0; i < keys.length; i++)
                        if ($.inArray(keys[i], oldSelectedItemKeys) === -1)
                            that._addedItemKeys.push(keys[i])
                };
            var equalKeys = dataGrid.equalKeys;
            var resetItemSelectionWhenShiftKeyPressed = function(that) {
                    delete that._shiftFocusedItemIndex
                };
            var isDataItem = function(row) {
                    return row && row.rowType === "data" && !row.inserted
                };
            var changeItemSelectionWhenShiftKeyPressed = function(that, itemIndex, items) {
                    var isSelectedItemsChanged = false,
                        itemIndexStep,
                        index,
                        dataController = that.getController("data"),
                        isFocusedItemSelected = items[that._focusedItemIndex] && that.isRowSelected(dataController.keyOf(items[that._focusedItemIndex].data));
                    var addRemoveSelectedItem = function(that, data, isRemove) {
                            if (isRemove)
                                removeSelectedItem(that, dataController.keyOf(data));
                            else
                                addSelectedItem(that, data)
                        };
                    if (!utils.isDefined(that._shiftFocusedItemIndex))
                        that._shiftFocusedItemIndex = that._focusedItemIndex;
                    if (that._shiftFocusedItemIndex !== that._focusedItemIndex) {
                        itemIndexStep = that._focusedItemIndex < that._shiftFocusedItemIndex ? 1 : -1;
                        for (index = that._focusedItemIndex; index !== that._shiftFocusedItemIndex; index += itemIndexStep)
                            if (isDataItem(items[index])) {
                                addRemoveSelectedItem(that, items[index].data, true);
                                isSelectedItemsChanged = true
                            }
                    }
                    if (itemIndex !== that._shiftFocusedItemIndex) {
                        itemIndexStep = itemIndex < that._shiftFocusedItemIndex ? 1 : -1;
                        for (index = itemIndex; index !== that._shiftFocusedItemIndex; index += itemIndexStep)
                            if (isDataItem(items[index])) {
                                addRemoveSelectedItem(that, items[index].data, false);
                                isSelectedItemsChanged = true
                            }
                    }
                    if (isDataItem(items[that._focusedItemIndex]) && !isFocusedItemSelected) {
                        addRemoveSelectedItem(that, items[that._focusedItemIndex].data, false);
                        isSelectedItemsChanged = true
                    }
                    return isSelectedItemsChanged
                };
            var createSelectedItemsFilterCriteria = function(dataSource, selectedItemKeys, isSelectAll) {
                    var keyCriteria,
                        i,
                        key = dataSource && dataSource.key(),
                        criteria = [];
                    if (dataSource)
                        if (key)
                            $.each(selectedItemKeys, function(index, keyValue) {
                                if (criteria.length > 0)
                                    criteria.push(isSelectAll ? "and" : "or");
                                if ($.isArray(key)) {
                                    keyCriteria = [];
                                    for (i = 0; i < key.length; i++) {
                                        if (i > 0)
                                            keyCriteria.push(isSelectAll ? "or" : "and");
                                        keyCriteria.push([key[i], isSelectAll ? "<>" : "=", keyValue[key[i]]])
                                    }
                                    criteria.push(keyCriteria)
                                }
                                else
                                    criteria.push([key, isSelectAll ? "<>" : "=", keyValue])
                            });
                        else
                            criteria = function(item) {
                                var i;
                                for (i = 0; i < selectedItemKeys.length; i++)
                                    if (equalKeys(selectedItemKeys[i], item))
                                        return !isSelectAll;
                                return isSelectAll
                            };
                    if (criteria.length > 0 || $.isFunction(criteria))
                        return criteria
                };
            var updateSelectedItems = function(that) {
                    var changedItemIndexes = [],
                        dataController = that.getController("data"),
                        addedItemKeys,
                        removedItemKeys;
                    if (dataController) {
                        $.each(dataController.items(), function(index, row) {
                            if (isDataItem(row) && row.isSelected !== that.isRowSelected(row.key))
                                changedItemIndexes.push(index)
                        });
                        if (that.option(SHOW_CHECKBOXES_MODE) === "onClick")
                            if (that._selectedItemKeys.length > 1)
                                that.startSelectionWithCheckboxes();
                            else if (that._selectedItemKeys.length === 0 && changedItemIndexes.length)
                                that.stopSelectionWithCheckboxes();
                        if (changedItemIndexes.length)
                            dataController.updateItems({
                                changeType: "updateSelection",
                                itemIndexes: changedItemIndexes
                            });
                        addedItemKeys = that._addedItemKeys;
                        removedItemKeys = that._removedItemKeys;
                        if (addedItemKeys.length || removedItemKeys.length) {
                            that._selectedItemsInternalChange = true;
                            that.option("selectedRowKeys", that._selectedItemKeys.slice(0));
                            that._selectedItemsInternalChange = false;
                            that.selectionChanged.fire(that._selectedItemKeys);
                            that._addedItemKeys = [];
                            that._removedItemKeys = [];
                            that.executeAction("onSelectionChanged", {
                                selectedRowsData: that._selectedItems,
                                selectedRowKeys: that._selectedItemKeys,
                                currentSelectedRowKeys: addedItemKeys,
                                currentDeselectedRowKeys: removedItemKeys
                            })
                        }
                    }
                };
            var updateSelectColumn = function(that) {
                    var columnsController = that.getController("columns"),
                        isSelectColumnVisible = that.isSelectColumnVisible();
                    columnsController.addCommandColumn({
                        command: "select",
                        visible: isSelectColumnVisible,
                        visibleIndex: -1,
                        dataType: "boolean",
                        alignment: "center",
                        cssClass: DATAGRID_COMMAND_SELECT_CLASS,
                        width: "auto"
                    });
                    columnsController.columnOption("command:select", "visible", isSelectColumnVisible)
                };
            return {
                    init: function() {
                        var that = this;
                        that._isSelectionWithCheckboxes = false;
                        that._focusedItemIndex = -1;
                        that._selectedItemKeys = [];
                        that._unselectedItemKeys = [];
                        that._selectedItems = [];
                        that._addedItemKeys = [];
                        that._removedItemKeys = [];
                        updateSelectColumn(that);
                        that.createAction("onSelectionChanged", {excludeValidators: ["disabled", "readOnly"]})
                    },
                    callbackNames: function() {
                        return ["selectionChanged"]
                    },
                    optionChanged: function(args) {
                        var that = this;
                        that.callBase(args);
                        switch (args.name) {
                            case"selection":
                                that.init();
                                that.getController("columns").updateColumns();
                                args.handled = true;
                                break;
                            case"selectedRowKeys":
                                if (utils.isArray(args.value) && !that._selectedItemsInternalChange)
                                    that.selectRows(args.value);
                                args.handled = true;
                                break
                        }
                    },
                    publicMethods: function() {
                        return ["selectRows", "deselectRows", "selectRowsByIndexes", "getSelectedRowKeys", "getSelectedRowsData", "clearSelection", "selectAll", "startSelectionWithCheckboxes", "stopSelectionWithCheckboxes", "isRowSelected"]
                    },
                    isRowSelected: function(key) {
                        var index = indexOfSelectedItemKey(this, key);
                        return index !== -1
                    },
                    isSelectColumnVisible: function() {
                        var showCheckboxesMode = this.option(SHOW_CHECKBOXES_MODE);
                        return this.option(SELECTION_MODE) === "multiple" && (showCheckboxesMode === "always" || showCheckboxesMode === "onClick" || this._isSelectionWithCheckboxes)
                    },
                    isSelectAll: function() {
                        var dataController = this.getController("data"),
                            items = dataController.items(),
                            combinedFilter = dataController.getCombinedFilter(),
                            selectedItems = this.getSelectedRowsData(),
                            i;
                        if (combinedFilter)
                            DX.data.query(selectedItems).filter(combinedFilter).enumerate().done(function(items) {
                                selectedItems = items
                            });
                        if (!selectedItems.length) {
                            for (i = 0; i < items.length; i++)
                                if (items[i].selected)
                                    return;
                            return false
                        }
                        else if (selectedItems.length >= dataController.totalCount())
                            return true
                    },
                    selectAll: function() {
                        if (this.option(SHOW_CHECKBOXES_MODE) === "onClick")
                            this.startSelectionWithCheckboxes();
                        return this.selectedItemKeys([], true, false, true)
                    },
                    deselectAll: function() {
                        return this.selectedItemKeys([], true, true, true)
                    },
                    clearSelection: function() {
                        this.selectedItemKeys([])
                    },
                    refresh: function() {
                        return this.selectedItemKeys(this.option("selectedRowKeys") || [])
                    },
                    selectedItemKeys: function(value, preserve, isDeselect, isSelectAll) {
                        var that = this,
                            keys,
                            criteria,
                            isFunctionCriteria,
                            deferred,
                            dataController = that.getController("data"),
                            dataSource = dataController.dataSource(),
                            store = dataSource && dataSource.store(),
                            dataSourceFilter,
                            filter,
                            deselectItems = [],
                            loadOptions;
                        if (utils.isDefined(value)) {
                            if (store) {
                                keys = $.isArray(value) ? $.extend([], value) : [value];
                                if (keys.length || isSelectAll) {
                                    criteria = createSelectedItemsFilterCriteria(dataSource, keys, isSelectAll);
                                    isFunctionCriteria = $.isFunction(criteria);
                                    if (criteria || isSelectAll) {
                                        if (isSelectAll)
                                            dataSourceFilter = dataController.getCombinedFilter();
                                        if (criteria && !isFunctionCriteria && dataSourceFilter) {
                                            filter = [];
                                            filter.push(criteria);
                                            filter.push(dataSourceFilter)
                                        }
                                        else if (dataSourceFilter)
                                            filter = dataSourceFilter;
                                        else if (criteria && !isFunctionCriteria)
                                            filter = criteria;
                                        deferred = $.Deferred();
                                        if (isDeselect)
                                            new DX.data.ArrayStore(that._selectedItems).load({filter: filter}).done(function(items) {
                                                deselectItems = items
                                            });
                                        dataController.setSelectionLoading(true);
                                        loadOptions = {
                                            filter: filter,
                                            select: dataSource.select()
                                        };
                                        $.each(store._customLoadOptions() || [], function(_, optionName) {
                                            loadOptions[optionName] = dataSource.loadOptions()[optionName]
                                        });
                                        $.when(deselectItems.length ? deselectItems : store.load(loadOptions)).done(function(items) {
                                            new DX.data.ArrayStore(items).load({filter: criteria}).done(deferred.resolve)
                                        }).fail($.proxy(deferred.reject, deferred)).always(function() {
                                            dataController.setSelectionLoading(false)
                                        })
                                    }
                                }
                            }
                            deferred = deferred || $.Deferred().resolve([]);
                            deferred.done(function(items) {
                                var i,
                                    key,
                                    item,
                                    keys = [];
                                if (store && items.length > 0)
                                    for (i = 0; i < items.length; i++) {
                                        item = items[i];
                                        key = store.keyOf(item);
                                        if (preserve)
                                            if (isDeselect)
                                                removeSelectedItem(that, key);
                                            else
                                                addSelectedItem(that, item);
                                        else
                                            keys.push(key)
                                    }
                                if (!preserve)
                                    setSelectedItems(that, keys, items);
                                updateSelectedItems(that)
                            });
                            return deferred
                        }
                        else
                            return that._selectedItemKeys
                    },
                    getSelectedRowKeys: function() {
                        return this.selectedItemKeys()
                    },
                    selectRows: function(keys, preserve) {
                        return this.selectedItemKeys(keys, preserve)
                    },
                    deselectRows: function(keys) {
                        return this.selectedItemKeys(keys, true, true)
                    },
                    selectRowsByIndexes: function(indexes) {
                        var items = this.getController("data").items(),
                            keys = [];
                        if (!utils.isArray(indexes))
                            indexes = Array.prototype.slice.call(arguments, 0);
                        $.each(indexes, function() {
                            var item = items[this];
                            if (item && item.rowType === "data")
                                keys.push(item.key)
                        });
                        return this.selectRows(keys)
                    },
                    getSelectedRowsData: function() {
                        return this._selectedItems
                    },
                    changeItemSelection: function(itemIndex, keys) {
                        var that = this,
                            dataController = that.getController("data"),
                            items = dataController.items(),
                            item = items[itemIndex],
                            itemData = item && item.data,
                            selectionMode = that.option(SELECTION_MODE),
                            isSelectedItemsChanged,
                            isSelected,
                            itemKey;
                        if (isSelectable(selectionMode) && isDataItem(item)) {
                            itemKey = dataController.keyOf(itemData);
                            keys = keys || {};
                            if (that.isSelectionWithCheckboxes())
                                keys.control = true;
                            if (keys.shift && selectionMode === "multiple" && that._focusedItemIndex >= 0)
                                isSelectedItemsChanged = changeItemSelectionWhenShiftKeyPressed(that, itemIndex, items);
                            else if (keys.control) {
                                resetItemSelectionWhenShiftKeyPressed(that);
                                isSelected = that.isRowSelected(itemKey);
                                if (selectionMode === "single")
                                    clearSelectedItems(that);
                                if (isSelected)
                                    removeSelectedItem(that, itemKey);
                                else
                                    addSelectedItem(that, itemData);
                                isSelectedItemsChanged = true
                            }
                            else {
                                resetItemSelectionWhenShiftKeyPressed(that);
                                if (that._selectedItemKeys.length !== 1 || !equalKeys(that._selectedItemKeys[0], itemKey)) {
                                    setSelectedItems(that, [itemKey], [itemData]);
                                    isSelectedItemsChanged = true
                                }
                            }
                            if (isSelectedItemsChanged) {
                                that._focusedItemIndex = itemIndex;
                                updateSelectedItems(that);
                                return true
                            }
                        }
                        return false
                    },
                    focusedItemIndex: function(itemIndex) {
                        var that = this;
                        if (utils.isDefined(itemIndex))
                            that._focusedItemIndex = itemIndex;
                        else
                            return that._focusedItemIndex
                    },
                    isSelectionWithCheckboxes: function() {
                        var selectionMode = this.option(SELECTION_MODE),
                            showCheckboxesMode = this.option(SHOW_CHECKBOXES_MODE);
                        return selectionMode === "multiple" && (showCheckboxesMode === "always" || this._isSelectionWithCheckboxes)
                    },
                    startSelectionWithCheckboxes: function() {
                        var that = this,
                            isSelectColumnVisible = that.isSelectColumnVisible();
                        if (that.option(SELECTION_MODE) === "multiple" && !that.isSelectionWithCheckboxes()) {
                            that._isSelectionWithCheckboxes = true;
                            updateSelectColumn(that);
                            if (isSelectColumnVisible === that.isSelectColumnVisible() && that.option(SHOW_CHECKBOXES_MODE) === "onClick")
                                updateSelectedItems(that);
                            return true
                        }
                        return false
                    },
                    stopSelectionWithCheckboxes: function() {
                        var that = this;
                        if (that._isSelectionWithCheckboxes) {
                            that._isSelectionWithCheckboxes = false;
                            updateSelectColumn(that);
                            return true
                        }
                        return false
                    }
                }
        }());
        $.extend(dataGrid.__internals, {DATAGRID_CHECKBOXES_HIDDEN_CLASS: DATAGRID_CHECKBOXES_HIDDEN_CLASS});
        dataGrid.registerModule("selection", {
            defaultOptions: function() {
                return {
                        selection: {
                            mode: "none",
                            showCheckBoxesInMultipleMode: "onClick",
                            allowSelectAll: true
                        },
                        selectedRowKeys: []
                    }
            },
            controllers: {selection: dataGrid.SelectionController},
            extenders: {
                controllers: {data: {
                        setDataSource: function(dataSource) {
                            this.callBase(dataSource);
                            if (dataSource)
                                this.getController("selection").refresh()
                        },
                        setSelectionLoading: function(isLoading) {
                            this._isSelectionLoading = isLoading;
                            this._fireLoadingChanged()
                        },
                        isLoading: function() {
                            var isLoading = this.callBase();
                            return isLoading || !!this._isSelectionLoading
                        },
                        pageIndex: function(value) {
                            var that = this,
                                dataSource = that._dataSource;
                            if (dataSource && value && dataSource.pageIndex() !== value)
                                that.getController("selection").focusedItemIndex(-1);
                            return that.callBase(value)
                        },
                        _processDataItem: function() {
                            var that = this,
                                selectionController = that.getController("selection"),
                                hasSelectColumn = selectionController.isSelectColumnVisible(),
                                dataItem = this.callBase.apply(this, arguments);
                            dataItem.isSelected = selectionController.isRowSelected(dataItem.key);
                            if (hasSelectColumn && dataItem.values)
                                dataItem.values[0] = dataItem.isSelected;
                            return dataItem
                        },
                        refresh: function() {
                            return $.when(this.getController("selection").refresh(), this.callBase.apply(this, arguments))
                        }
                    }},
                views: {
                    columnHeadersView: {
                        _renderCore: function(options) {
                            var that = this;
                            that.getController("selection").selectionChanged.remove(that._selectionChangedHandler);
                            that.callBase(options)
                        },
                        _getDefaultTemplate: function(column) {
                            var that = this,
                                groupElement,
                                selectionController = that.getController("selection"),
                                dataController = that.getController("data");
                            if (column.command === "select")
                                return function($cell, options) {
                                        var column = options.column;
                                        if (column.command === "select") {
                                            $cell.addClass(DATAGRID_EDITOR_CELL_CLASS);
                                            groupElement = $("<div />").appendTo($cell).addClass(DATAGRID_SELECT_CHECKBOX_CLASS);
                                            that.setAria("label", Globalize.localize("dxDataGrid-ariaSelectAll"), $cell);
                                            that.getController("editorFactory").createEditor(groupElement, $.extend({}, column, {
                                                parentType: "headerRow",
                                                value: selectionController.isSelectAll(),
                                                tabIndex: -1,
                                                setValue: function(value, e) {
                                                    if (e.jQueryEvent && selectionController.isSelectAll() !== value) {
                                                        if (e.previousValue === undefined || e.previousValue) {
                                                            selectionController.deselectAll();
                                                            e.component.option("value", false)
                                                        }
                                                        if (e.previousValue === false)
                                                            if (that.option("selection.allowSelectAll"))
                                                                selectionController.selectAll();
                                                            else
                                                                e.component.option("value", false);
                                                        e.jQueryEvent.preventDefault()
                                                    }
                                                }
                                            }));
                                            $cell.on("dxclick", that.createAction(function(e) {
                                                var event = e.jQueryEvent;
                                                if (!$(event.target).closest("." + DATAGRID_SELECT_CHECKBOX_CLASS).length)
                                                    $(event.currentTarget).children().trigger("dxclick");
                                                event.preventDefault()
                                            }));
                                            that._selectionChangedHandler = function() {
                                                if (that.option("selection.mode") === "multiple")
                                                    groupElement.dxCheckBox("instance").option("value", selectionController.isSelectAll())
                                            };
                                            that._dataChangedHandler = function(e) {
                                                if (!e || e.changeType === "refresh")
                                                    that._selectionChangedHandler()
                                            };
                                            dataController.changed.add(that._dataChangedHandler);
                                            selectionController.selectionChanged.add(that._selectionChangedHandler)
                                        }
                                    };
                            else
                                return that.callBase(column)
                        }
                    },
                    rowsView: {
                        _getDefaultTemplate: function(column) {
                            var that = this,
                                groupElement;
                            if (column.command === "select")
                                return function(container, options) {
                                        if (options.rowType === "data" && !options.row.inserted) {
                                            container.addClass(DATAGRID_EDITOR_CELL_CLASS);
                                            container.on("dxclick", that.createAction(function(e) {
                                                var selectionController = that.getController("selection"),
                                                    event = e.jQueryEvent,
                                                    rowIndex = that.getRowIndex($(event.currentTarget).closest("." + DATAGRID_ROW_CLASS));
                                                if (rowIndex >= 0) {
                                                    selectionController.startSelectionWithCheckboxes();
                                                    selectionController.changeItemSelection(rowIndex, {shift: event.shiftKey})
                                                }
                                            }));
                                            that.setAria("label", Globalize.localize("dxDataGrid-ariaSelectRow"), container);
                                            groupElement = $("<div />").addClass(DATAGRID_SELECT_CHECKBOX_CLASS).appendTo(container);
                                            that.getController("editorFactory").createEditor(groupElement, $.extend({}, column, {
                                                parentType: "dataRow",
                                                value: options.value,
                                                tabIndex: -1,
                                                setValue: function(value, e) {
                                                    if (e && e.jQueryEvent && e.jQueryEvent.type === "keydown")
                                                        container.trigger("dxclick", e)
                                                }
                                            }))
                                        }
                                    };
                            else
                                return that.callBase(column)
                        },
                        _update: function(change) {
                            var that = this,
                                tableElements = that.getTableElements();
                            if (change.changeType === "updateSelection") {
                                if (tableElements.length > 0) {
                                    $.each(tableElements, function(_, tableElement) {
                                        $.each(change.itemIndexes || [], function(_, index) {
                                            var $row,
                                                isSelected;
                                            if (change.items[index]) {
                                                $row = that._getRowElements($(tableElement)).eq(index);
                                                isSelected = !!change.items[index].isSelected;
                                                $row.toggleClass(DATAGRID_ROW_SELECTION_CLASS, isSelected).find("." + DATAGRID_SELECT_CHECKBOX_CLASS).dxCheckBox("option", "value", isSelected);
                                                that.setAria("selected", isSelected, $row)
                                            }
                                        })
                                    });
                                    that._updateCheckboxesClass()
                                }
                            }
                            else
                                that.callBase(change)
                        },
                        _createTable: function() {
                            var that = this,
                                selectionMode = that.option("selection.mode"),
                                $table = that.callBase.apply(that, arguments);
                            if (selectionMode !== "none")
                                $table.on(events.addNamespace("dxhold", "dxDataGridRowsView"), "." + DATAGRID_DATA_ROW_CLASS, that.createAction(function(e) {
                                    var selectionController = that.getController("selection"),
                                        event = e.jQueryEvent,
                                        rowIndex = $(event.target).closest("." + DATAGRID_DATA_ROW_CLASS).index();
                                    if (that.option(SHOW_CHECKBOXES_MODE) === "onLongTap")
                                        if (selectionController.isSelectionWithCheckboxes())
                                            selectionController.stopSelectionWithCheckboxes();
                                        else
                                            selectionController.startSelectionWithCheckboxes();
                                    else {
                                        if (that.option(SHOW_CHECKBOXES_MODE) === "onClick")
                                            selectionController.startSelectionWithCheckboxes();
                                        selectionController.changeItemSelection(rowIndex, {control: true})
                                    }
                                })).on("mousedown selectstart", that.createAction(function(e) {
                                    var event = e.jQueryEvent;
                                    if (event.shiftKey)
                                        event.preventDefault()
                                }));
                            return $table
                        },
                        _createRow: function(row) {
                            var $row = this.callBase(row),
                                isSelected;
                            if (row) {
                                isSelected = !!row.isSelected;
                                $row.toggleClass(DATAGRID_ROW_SELECTION_CLASS, isSelected);
                                this.setAria("selected", isSelected, $row)
                            }
                            return $row
                        },
                        _rowClick: function(e) {
                            var that = this,
                                jQueryEvent = e.jQueryEvent,
                                isCommandSelect = $(jQueryEvent.target).closest("." + DATAGRID_COMMAND_SELECT_CLASS).length,
                                isSelectionDisabled = $(jQueryEvent.target).closest("." + DATAGRID_SELECTION_DISABLED_CLASS).length;
                            if (!isCommandSelect) {
                                if (!isSelectionDisabled)
                                    if (that.getController("selection").changeItemSelection(e.rowIndex, {
                                        control: jQueryEvent.ctrlKey,
                                        shift: jQueryEvent.shiftKey
                                    })) {
                                        jQueryEvent.preventDefault();
                                        e.handled = true
                                    }
                                that.callBase(e)
                            }
                        },
                        _renderCore: function(change) {
                            this.callBase(change);
                            this._updateCheckboxesClass()
                        },
                        _updateCheckboxesClass: function() {
                            var tableElements = this.getTableElements(),
                                selectionController = this.getController("selection"),
                                isCheckBoxesHidden = selectionController.isSelectColumnVisible() && !selectionController.isSelectionWithCheckboxes();
                            $.each(tableElements, function(_, tableElement) {
                                $(tableElement).toggleClass(DATAGRID_CHECKBOXES_HIDDEN_CLASS, isCheckBoxesHidden)
                            })
                        }
                    }
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.editorFactory.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            utils = DX.utils,
            addNamespace = DX.ui.events.addNamespace;
        var DATAGRID_CHECKBOX_SIZE_CLASS = "dx-datagrid-checkbox-size",
            DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
            DATAGRID_EDITOR_INLINE_BLOCK = "dx-editor-inline-block",
            DATAGRID_MODULE_NAMESPACE = "dxDataGridEditorFactory",
            DATAGRID_UPDATE_FOCUS_EVENTS = addNamespace("focusin dxpointerdown dxclick", DATAGRID_MODULE_NAMESPACE),
            DATAGRID_FOCUS_OVERLAY_CLASS = "dx-datagrid-focus-overlay",
            DATAGRID_FOCUSED_ELEMENT_CLASS = "dx-focused",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target",
            DATAGRID_POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
            DX_HIDDEN = "dx-hidden",
            TAB_KEY = 9;
        dataGrid.EditorFactoryController = dataGrid.ViewController.inherit(function() {
            var getResultConfig = function(config, options) {
                    return $.extend(config, {
                            readOnly: options.readOnly,
                            rtlEnabled: options.rtlEnabled,
                            disabled: options.disabled
                        })
                };
            var getTextEditorConfig = function(options) {
                    var isIE11 = DX.browser.msie && parseInt(DX.browser.version) === 11;
                    return getResultConfig({
                            placeholder: options.placeholder,
                            width: options.width,
                            value: options.value,
                            onValueChanged: function(e) {
                                var updateValue = function(e) {
                                        options && options.setValue(e.value)
                                    };
                                window.clearTimeout(e.component._valueChangeTimeoutID);
                                if (e.jQueryEvent && e.jQueryEvent.type === "keyup")
                                    e.component._valueChangeTimeoutID = window.setTimeout(function() {
                                        updateValue(e)
                                    }, utils.isDefined(options.updateValueTimeout) ? options.updateValueTimeout : 0);
                                else
                                    updateValue(e)
                            },
                            valueChangeEvent: "change" + (options.parentType === "filterRow" || isIE11 ? " keyup" : "")
                        }, options)
                };
            var prepareDateBox = function(options) {
                    options.editorName = "dxDateBox";
                    options.editorOptions = getResultConfig({
                        value: options.value,
                        pickerType: "calendar",
                        customOverlayCssClass: "dx-datagrid",
                        onValueChanged: function(args) {
                            options.setValue(args.value)
                        },
                        formatString: DX.utils.isString(options.format) && DX.DateTimeFormat[options.format.toLowerCase()] || options.format,
                        formatWidthCalculator: null,
                        width: "auto"
                    }, options)
                };
            var prepareTextBox = function(options) {
                    var config = getTextEditorConfig(options),
                        isSearching = options.parentType === "searchPanel",
                        toString = function(value) {
                            return DX.utils.isDefined(value) ? value.toString() : ""
                        };
                    config.value = toString(options.value);
                    config.valueChangeEvent += isSearching ? " keyup search" : "";
                    config.mode = isSearching ? "search" : "text";
                    options.editorName = "dxTextBox";
                    options.editorOptions = config
                };
            var prepareNumberBox = function(options) {
                    var config = getTextEditorConfig(options);
                    config.value = utils.isDefined(options.value) ? options.value : null;
                    options.editorName = "dxNumberBox";
                    options.editorOptions = config
                };
            var prepareBooleanEditor = function(options) {
                    if (options.parentType === "filterRow")
                        prepareSelectBox($.extend(options, {lookup: {
                                displayExpr: function(data) {
                                    if (data === true)
                                        return options.trueText || "true";
                                    else if (data === false)
                                        return options.falseText || "false"
                                },
                                dataSource: [true, false],
                                rtlEnabled: options.rtlEnabled,
                                disabled: options.disabled
                            }}));
                    else
                        prepareCheckBox(options)
                };
            var prepareSelectBox = function(options) {
                    var lookup = options.lookup,
                        displayGetter,
                        dataSource,
                        postProcess,
                        isFilterRow = options.parentType === "filterRow";
                    if (lookup) {
                        displayGetter = DX.data.utils.compileGetter(lookup.displayExpr);
                        if (utils.isObject(lookup.dataSource) || utils.isArray(lookup.dataSource)) {
                            dataSource = DX.data.utils.normalizeDataSourceOptions(lookup.dataSource);
                            if (isFilterRow) {
                                postProcess = dataSource.postProcess;
                                dataSource.postProcess = function(items) {
                                    if (this.pageIndex() === 0) {
                                        items = items.slice(0);
                                        items.unshift(null)
                                    }
                                    if (postProcess)
                                        return postProcess.call(this, items);
                                    return items
                                }
                            }
                        }
                        options.editorName = "dxSelectBox";
                        options.editorOptions = getResultConfig({
                            searchEnabled: true,
                            value: options.value,
                            valueExpr: options.lookup.valueExpr,
                            searchExpr: options.lookup.searchExpr || options.lookup.displayExpr,
                            showClearButton: Boolean(lookup.allowClearing && !isFilterRow),
                            displayExpr: function(data) {
                                if (data === null)
                                    return options.showAllText;
                                return displayGetter(data)
                            },
                            dataSource: dataSource,
                            onValueChanged: function(e) {
                                options.setValue(e.value, e)
                            }
                        }, options)
                    }
                };
            var prepareCheckBox = function(options) {
                    options.editorName = "dxCheckBox";
                    options.editorOptions = getResultConfig({
                        value: options.value,
                        onValueChanged: function(e) {
                            options.setValue && options.setValue(e.value, e)
                        },
                        tabIndex: options.tabIndex ? options.tabIndex : 0
                    }, options)
                };
            var createEditorCore = function(that, options) {
                    if (options.editorName && options.editorOptions && options.editorElement[options.editorName]) {
                        if (options.editorName === "dxCheckBox")
                            options.editorElement.addClass(DATAGRID_CHECKBOX_SIZE_CLASS);
                        that._createComponent(options.editorElement, options.editorName, options.editorOptions);
                        if (options.editorName === "dxTextBox")
                            options.editorElement.dxTextBox("instance").registerKeyHandler("enter", $.noop)
                    }
                };
            return {
                    _getFocusedElement: function($dataGridElement) {
                        return $dataGridElement.find("[tabindex]:focus, input:focus")
                    },
                    _updateFocusCore: function() {
                        var $focus = this._$focusedElement,
                            $dataGridElement = this.component && this.component.element(),
                            $focusCell,
                            hideBorders;
                        if ($dataGridElement) {
                            $focus = this._getFocusedElement($dataGridElement);
                            if ($focus.length) {
                                if (!$focus.hasClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS)) {
                                    $focusCell = $focus.closest(".dx-row > td, ." + DATAGRID_CELL_FOCUS_DISABLED_CLASS);
                                    hideBorders = $focusCell.get(0) !== $focus.get(0) && $focusCell.hasClass(DATAGRID_EDITOR_INLINE_BLOCK);
                                    $focus = $focusCell
                                }
                                if ($focus.length && !$focus.hasClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS)) {
                                    this.focus($focus, hideBorders);
                                    return
                                }
                            }
                        }
                        this.loseFocus()
                    },
                    _updateFocus: function(e) {
                        var that = this,
                            isFocusOverlay = e && e.jQueryEvent && $(e.jQueryEvent.target).hasClass(DATAGRID_FOCUS_OVERLAY_CLASS);
                        that._isFocusOverlay = that._isFocusOverlay || isFocusOverlay;
                        clearTimeout(that._updateFocusTimeoutID);
                        that._updateFocusTimeoutID = setTimeout(function() {
                            delete that._updateFocusTimeoutID;
                            if (!that._isFocusOverlay)
                                that._updateFocusCore();
                            that._isFocusOverlay = false
                        })
                    },
                    _updateFocusOverlaySize: function($element, position) {
                        var location = DX.calculatePosition($element, $.extend({collision: "fit"}, position));
                        if (location.h.oversize > 0)
                            $element.outerWidth($element.outerWidth() - location.h.oversize);
                        if (location.v.oversize > 0)
                            $element.outerHeight($element.outerHeight() - location.v.oversize)
                    },
                    callbackNames: function() {
                        return ["focused"]
                    },
                    focus: function($element, hideBorder) {
                        var that = this;
                        if ($element === undefined)
                            return that._$focusedElement;
                        else if ($element)
                            setTimeout(function() {
                                var $focusOverlay = that._$focusOverlay = that._$focusOverlay || $("<div>").addClass(DATAGRID_FOCUS_OVERLAY_CLASS + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS),
                                    focusOverlayPosition;
                                if (hideBorder)
                                    that._$focusOverlay && that._$focusOverlay.addClass(DX_HIDDEN);
                                else {
                                    var align = DevExpress.browser.msie ? "left bottom" : DevExpress.browser.mozilla ? "right bottom" : "left top",
                                        $content = $element.closest("." + DATAGRID_CONTENT_CLASS);
                                    $focusOverlay.removeClass(DX_HIDDEN).appendTo($content).outerWidth($element.outerWidth() + 1).outerHeight($element.outerHeight() + 1);
                                    focusOverlayPosition = {
                                        my: align,
                                        at: align,
                                        of: $element,
                                        boundary: $content.length && $content
                                    };
                                    that._updateFocusOverlaySize($focusOverlay, focusOverlayPosition);
                                    DX.position($focusOverlay, focusOverlayPosition);
                                    $focusOverlay.css("visibility", "visible")
                                }
                                that._$focusedElement && that._$focusedElement.removeClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
                                $element.addClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
                                that._$focusedElement = $element;
                                that.focused.fire($element)
                            })
                    },
                    resize: function() {
                        var $focusedElement = this._$focusedElement;
                        if ($focusedElement)
                            this.focus($focusedElement)
                    },
                    loseFocus: function() {
                        this._$focusedElement && this._$focusedElement.removeClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
                        this._$focusedElement = null;
                        this._$focusOverlay && this._$focusOverlay.addClass(DX_HIDDEN)
                    },
                    init: function() {
                        this.createAction("onEditorPreparing", {
                            excludeValidators: ["designMode", "disabled", "readOnly"],
                            category: "rendering"
                        });
                        this.createAction("onEditorPrepared", {
                            excludeValidators: ["designMode", "disabled", "readOnly"],
                            category: "rendering"
                        });
                        this._updateFocusHandler = this._updateFocusHandler || this.createAction($.proxy(this._updateFocus, this));
                        $(document).on(DATAGRID_UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
                        this._attachContainerEventHandlers()
                    },
                    _attachContainerEventHandlers: function() {
                        var that = this,
                            $container = that.component && that.component.element(),
                            isIE10OrLower = DX.browser.msie && parseInt(DX.browser.version) < 11;
                        if ($container) {
                            $container.on(addNamespace("keydown", DATAGRID_MODULE_NAMESPACE), function(e) {
                                if (e.which === TAB_KEY)
                                    that._updateFocusHandler(e)
                            });
                            isIE10OrLower && $container.on("dxclick dxpointerup dxpointerdown", "." + DATAGRID_POINTER_EVENTS_TARGET_CLASS, $.proxy(that._focusOverlayEventProxy, that))
                        }
                    },
                    _focusOverlayEventProxy: function(e) {
                        var $target = $(e.target),
                            $currentTarget = $(e.currentTarget),
                            element,
                            needProxy = $target.hasClass(DATAGRID_POINTER_EVENTS_TARGET_CLASS) || $target.hasClass(DATAGRID_POINTER_EVENTS_NONE_CLASS),
                            $focusedElement = this._$focusedElement;
                        if (!needProxy || $currentTarget.hasClass(DX_HIDDEN))
                            return;
                        $currentTarget.addClass(DX_HIDDEN);
                        element = $target.get(0).ownerDocument.elementFromPoint(e.clientX, e.clientY);
                        DX.ui.events.fireEvent({
                            originalEvent: e,
                            target: element
                        });
                        e.stopPropagation();
                        $currentTarget.removeClass(DX_HIDDEN);
                        $focusedElement && $focusedElement.find("input").focus()
                    },
                    dispose: function() {
                        clearTimeout(this._updateFocusTimeoutID);
                        $(document).off(DATAGRID_UPDATE_FOCUS_EVENTS, this._updateFocusHandler)
                    },
                    createEditor: function($container, options) {
                        this.component._suppressDeprecatedWarnings();
                        var editorPreparing = this.option("editorPreparing"),
                            editorPrepared = this.option("editorPrepared");
                        this.component._resumeDeprecatedWarnings();
                        options.rtlEnabled = this.option("rtlEnabled");
                        options.disabled = this.option("disabled");
                        options.cancel = false;
                        options.editorElement = $container;
                        if (options.lookup)
                            prepareSelectBox(options);
                        else
                            switch (options.dataType) {
                                case"date":
                                    prepareDateBox(options);
                                    break;
                                case"boolean":
                                    prepareBooleanEditor(options);
                                    break;
                                case"number":
                                    prepareNumberBox(options);
                                    break;
                                default:
                                    prepareTextBox(options);
                                    break
                            }
                        editorPreparing && editorPreparing($container, options);
                        this.executeAction("onEditorPreparing", options);
                        if (options.cancel)
                            return;
                        createEditorCore(this, options);
                        editorPrepared && editorPrepared($container, options);
                        this.executeAction("onEditorPrepared", options)
                    }
                }
        }());
        $.extend(dataGrid.__internals, {DATAGRID_FOCUSED_ELEMENT_CLASS: DATAGRID_FOCUSED_ELEMENT_CLASS});
        dataGrid.registerModule("editorFactory", {
            defaultOptions: function() {
                return {}
            },
            controllers: {editorFactory: dataGrid.EditorFactoryController},
            extenders: {controllers: {columnsResizer: {_startResizing: function(args) {
                            this.callBase(args);
                            if (this.isResizing())
                                this.getController("editorFactory").loseFocus()
                        }}}}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnsView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_SCROLL_CONTAINER_CLASS = "dx-datagrid-scroll-container",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_GROUP_SPACE_CLASS = "dx-datagrid-group-space",
            DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_COLUMN_INDICATORS_CLASS = "dx-column-indicators",
            DATAGRID_TABLE_FIXED_CLASS = "dx-datagrid-table-fixed",
            DATAGRID_INDICATOR_ALIGNMENT_CLASS = "dx-indicator-alignment-",
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            DATAGRID_CELL_HINT_VISIBLE = "dxCellHintVisible",
            indicatorNamesClass = {
                sort: "dx-sort",
                headerFilter: "dx-header-filter"
            };
        var appendElementTemplate = {render: function(element, container) {
                    container.append(element)
                }};
        dataGrid.getWidths = function($tableElement) {
            var cells,
                result = [],
                width,
                clientRect;
            if ($tableElement) {
                cells = $tableElement.children("tbody").children("tr").filter(":not(." + DATAGRID_GROUP_ROW_CLASS + ")").first().find("> td");
                $.each(cells, function(index, item) {
                    width = $(item).outerWidth(true);
                    if (item.getBoundingClientRect) {
                        clientRect = item.getBoundingClientRect();
                        if (clientRect.width > width)
                            width = Math.ceil(clientRect.width)
                    }
                    result.push(width)
                })
            }
            return result
        };
        dataGrid.ColumnsView = dataGrid.View.inherit({
            _getColumnAlignment: function(alignment) {
                var rtlEnabled = this.option("rtlEnabled");
                return alignment !== "center" ? alignment : utils.getDefaultAlignment(rtlEnabled)
            },
            _applyColumnState: function(options) {
                var that = this,
                    columnAlignment = that._getColumnAlignment(options.column.alignment),
                    parameters = $.extend(true, {columnAlignment: columnAlignment}, options),
                    $indicatorsContainer = that._createIndicatorContainer(parameters),
                    $span = $("<span />").addClass(indicatorNamesClass[options.name]);
                parameters.container = $indicatorsContainer;
                parameters.indicator = $span;
                that._renderIndicator(parameters);
                $indicatorsContainer[!options.showColumnLines ? "appendTo" : "prependTo"](options.rootElement).addClass(DATAGRID_INDICATOR_ALIGNMENT_CLASS + columnAlignment);
                return $span
            },
            _createIndicatorContainer: function(options) {
                var that = this,
                    $indicatorsContainer = options.rootElement.find("." + DATAGRID_COLUMN_INDICATORS_CLASS),
                    indicatorAlignment = that._getColumnAlignment(options.column.alignment) === "right" ? "left" : "right";
                if (!$indicatorsContainer.length)
                    $indicatorsContainer = $("<div/>").addClass(DATAGRID_COLUMN_INDICATORS_CLASS);
                $indicatorsContainer.css("float", options.showColumnLines ? indicatorAlignment : null);
                return $indicatorsContainer
            },
            _getIndicatorContainer: function($cell) {
                return $cell && $cell.find("." + DATAGRID_COLUMN_INDICATORS_CLASS)
            },
            _renderIndicator: function(options) {
                var $container = options.container,
                    $indicator = options.indicator;
                $container && $indicator && $container.append($indicator)
            },
            _updateIndicatorHeights: function(indicatorName) {
                var that = this,
                    columnElements = that.getColumnElements(),
                    $cell,
                    i;
                if (columnElements)
                    for (i = 0; i < columnElements.length; i++) {
                        $cell = columnElements.eq(i);
                        that._updateIndicatorHeight($cell, indicatorName)
                    }
            },
            _updateIndicatorHeight: function($cell, indicatorName) {
                var showColumnLines = this.option("showColumnLines"),
                    $textContent = $cell.find("." + DATAGRID_CELL_CONTENT_CLASS),
                    $indicator = $cell.find("." + indicatorNamesClass[indicatorName]);
                if ($indicator.length) {
                    $indicator.height("auto");
                    $indicator.height($textContent.height() || $cell.height())
                }
                !showColumnLines && this._setColumnTextWidth($cell)
            },
            _updateIndicators: function(indicatorName) {
                var that = this,
                    columns = that.getColumns(),
                    $cells = that.getColumnElements(),
                    i;
                for (i = 0; i < columns.length; i++)
                    that._updateIndicator($cells.eq(i), columns[i], indicatorName);
                that._updateIndicatorHeights(indicatorName)
            },
            _updateIndicator: function($cell, column, indicatorName) {
                if (!column.command)
                    return this._applyColumnState({
                            name: indicatorName,
                            rootElement: $cell,
                            column: column,
                            showColumnLines: this.option("showColumnLines")
                        })
            },
            _setColumnTextWidth: function($cell) {
                var maxWidth,
                    indicatorWidth = 0,
                    $indicatorContainer = this._getIndicatorContainer($cell);
                if ($indicatorContainer.length)
                    indicatorWidth = $indicatorContainer.outerWidth();
                maxWidth = $cell.width() - indicatorWidth;
                maxWidth > 0 && $cell.find("." + DATAGRID_CELL_CONTENT_CLASS).css("max-width", maxWidth)
            },
            _updateCell: function($cell, parameters) {
                if (parameters.rowType)
                    this._cellPrepared($cell, parameters)
            },
            _createCell: function(column) {
                var defaultAlignment = utils.getDefaultAlignment(this.option("rtlEnabled")),
                    alignment = column.alignment || defaultAlignment;
                var $cell = $("<td/>").css("text-align", alignment).attr("role", "gridcell");
                if (!utils.isDefined(column.groupIndex) && column.cssClass)
                    $cell.addClass(column.cssClass);
                if (column.command === "expand")
                    $cell.addClass(DATAGRID_GROUP_SPACE_CLASS);
                return $cell
            },
            _createRow: function(row) {
                return $("<tr />").addClass(DATAGRID_ROW_CLASS).attr("role", "row")
            },
            _createTable: function(columns) {
                var that = this,
                    $table = $("<table />").addClass(DATAGRID_TABLE_CLASS).addClass(DATAGRID_TABLE_FIXED_CLASS).attr("role", "grid");
                if (columns) {
                    $table.append(that._createColGroup(columns));
                    if (DX.devices.real().ios)
                        $table.append("<thead><tr></tr></thead>")
                }
                if (DX.browser.mozilla)
                    $table.on("mousedown", "td", function(e) {
                        if (e.ctrlKey)
                            e.preventDefault()
                    });
                if (that.option("cellHintEnabled"))
                    $table.on("mousemove", ".dx-row > td", this.createAction(function(args) {
                        var e = args.jQueryEvent,
                            $element = $(e.target),
                            $cell = $(e.currentTarget),
                            $row = $cell.parent(),
                            isDataRow = $row.hasClass("dx-data-row"),
                            isHeaderRow = $row.hasClass("dx-header-row"),
                            $cells = $row.children(),
                            visibleColumns = that._columnsController.getVisibleColumns(),
                            visibleColumnIndex = $cells.index($cell),
                            column = visibleColumns[visibleColumnIndex];
                        if (!isDataRow && !isHeaderRow || isDataRow && column && !column.cellTemplate || isHeaderRow && column && !column.headerCellTemplate) {
                            if ($element.data(DATAGRID_CELL_HINT_VISIBLE)) {
                                $element.removeAttr("title");
                                $element.data(DATAGRID_CELL_HINT_VISIBLE, false)
                            }
                            if ($element[0].scrollWidth > $element[0].clientWidth && !$element.attr("title")) {
                                $element.attr("title", $element.text());
                                $element.data(DATAGRID_CELL_HINT_VISIBLE, true)
                            }
                        }
                    }));
                var getOptions = function(event) {
                        var cellElement = $(event.currentTarget),
                            options = cellElement.data("options");
                        return $.extend({}, options, {
                                cellElement: cellElement,
                                jQueryEvent: event,
                                eventType: event.type
                            })
                    };
                if (that.option("onCellClick"))
                    $table.on("dxclick", ".dx-row > td", function(e) {
                        that.executeAction("onCellClick", getOptions(e))
                    });
                if (that.option("onCellHoverChanged")) {
                    $table.on("mouseover", ".dx-row > td", function(e) {
                        that.executeAction("onCellHoverChanged", getOptions(e))
                    });
                    $table.on("mouseout", ".dx-row > td", function(e) {
                        that.executeAction("onCellHoverChanged", getOptions(e))
                    })
                }
                return $table
            },
            _createColGroup: function(columns) {
                var i,
                    j,
                    colgroupElement = $("<colgroup />"),
                    colspan,
                    columnsLength = columns.length;
                for (i = 0; i < columnsLength; i++) {
                    colspan = columns[i].colspan || 1;
                    for (j = 0; j < colspan; j++)
                        colgroupElement.append(this._createCol(columns[i]))
                }
                return colgroupElement
            },
            _createCol: function(column) {
                return $("<col />").width(column.visibleWidth || column.width)
            },
            renderDelayedTemplates: function() {
                var templateParameters,
                    delayedTemplates = this._delayedTemplates;
                while (delayedTemplates.length) {
                    templateParameters = delayedTemplates.shift();
                    templateParameters.template.render(templateParameters.options, templateParameters.container);
                    if (templateParameters.options.column)
                        this._updateCell(templateParameters.container, templateParameters.options)
                }
            },
            _processTemplate: function(template, options) {
                var that = this,
                    renderingTemplate;
                if (template && template.render)
                    renderingTemplate = {
                        allowRenderToDetachedContainer: template.allowRenderToDetachedContainer,
                        render: function(options, container) {
                            template.render(container, options)
                        }
                    };
                else if ($.isFunction(template))
                    renderingTemplate = {render: function(options, container) {
                            template(container, options)
                        }};
                else {
                    if (!that._templatesCache[template])
                        that._templatesCache[template] = that.getTemplate(template);
                    renderingTemplate = that._templatesCache[template]
                }
                return renderingTemplate
            },
            _renderTemplate: function(container, template, options) {
                var that = this,
                    renderingTemplate = that._processTemplate(template, options);
                if (renderingTemplate)
                    if (renderingTemplate.allowRenderToDetachedContainer) {
                        renderingTemplate.render(options, container);
                        return true
                    }
                    else
                        that._delayedTemplates.push({
                            template: renderingTemplate,
                            container: container,
                            options: options
                        });
                return false
            },
            _appendRow: function($table, $row) {
                var that = this;
                if (that.option("rowTemplate") && that._delayedTemplates.length && $row)
                    that._delayedTemplates.push({
                        container: $table,
                        template: appendElementTemplate,
                        options: $row
                    });
                else
                    $table.append($row)
            },
            _renderCore: function(change) {
                var $root = this.element().parent();
                if (!$root || $root.parent().length)
                    this.renderDelayedTemplates()
            },
            _renderTable: function(options) {
                options = options || {};
                var that = this,
                    $table;
                options.columns = that._columnsController.getVisibleColumns();
                $table = that._createTable(options.columns);
                that._renderRows($table, options);
                return $table
            },
            _renderRows: function($table, options) {
                var that = this,
                    i,
                    rows = that._getRows(options.change);
                for (i = 0; i < rows.length; i++)
                    that._renderRow($table, $.extend({row: rows[i]}, options))
            },
            _renderRow: function($table, options) {
                var that = this,
                    $row;
                $row = that._createRow(options.row);
                that._renderCells($row, options);
                that._appendRow($table, $row);
                that._rowPrepared($row, $.extend({columns: options.columns}, options.row))
            },
            _renderCells: function($row, options) {
                var that = this,
                    i,
                    columnIndex = 0,
                    row = options.row,
                    columns = options.columns;
                for (i = 0; i < columns.length; i++) {
                    that._renderCell($row, $.extend({
                        column: columns[i],
                        columnIndex: columnIndex,
                        value: row.values && row.values[columnIndex]
                    }, options));
                    if (utils.isDefined(columns[i].colspan))
                        columnIndex += columns[i].colspan;
                    else
                        columnIndex++
                }
            },
            _renderCell: function($row, options) {
                var that = this,
                    cellOptions = that._getCellOptions(options),
                    column = options.column,
                    $cell;
                $cell = that._createCell(column);
                if (!utils.isDefined(column.command))
                    that.setAria("label", Globalize.localize("dxDataGrid-ariaColumn") + " " + column.caption + ", " + Globalize.localize("dxDataGrid-ariaValue") + " " + cellOptions.text, $cell);
                that._renderCellContent($cell, cellOptions);
                $row.get(0).appendChild($cell.get(0));
                return $cell
            },
            _renderCellContent: function($cell, options) {
                var template = this._getCellTemplate(options);
                if (!template || this._renderTemplate($cell, template, options))
                    this._updateCell($cell, options)
            },
            _getCellTemplate: function(options){},
            _getRows: function() {
                return []
            },
            _getCellOptions: function(options) {
                return {
                        column: options.column,
                        columnIndex: options.columnIndex,
                        rowType: options.row.rowType
                    }
            },
            _cellPrepared: function($cell, options) {
                var that = this,
                    cellPrepared;
                $cell.data("options", options);
                this.component._suppressDeprecatedWarnings();
                cellPrepared = that.option("cellPrepared");
                this.component._resumeDeprecatedWarnings();
                cellPrepared && cellPrepared($cell, options);
                options.cellElement = $cell;
                that.executeAction("onCellPrepared", options)
            },
            _rowPrepared: function($row, options) {
                var that = this,
                    rowPrepared;
                this.component._suppressDeprecatedWarnings();
                rowPrepared = that.option("rowPrepared");
                this.component._resumeDeprecatedWarnings();
                rowPrepared && rowPrepared($row, options);
                options.rowElement = $row;
                this.executeAction("onRowPrepared", options)
            },
            _columnOptionChanged: function(e) {
                var optionNames = e.optionNames;
                if (dataGrid.checkChanges(optionNames, ["width", "visibleWidth"])) {
                    var visibleColumns = this._columnsController.getVisibleColumns();
                    var widths = $.map(visibleColumns, function(column) {
                            return column.visibleWidth || column.width || "auto"
                        });
                    this.setColumnWidths(widths);
                    return
                }
                if (!this._requireReady)
                    this.render()
            },
            getTableElements: function() {
                return this._tableElement || $()
            },
            _getTableElement: function() {
                return this._tableElement
            },
            _setTableElement: function(tableElement) {
                this._tableElement = tableElement
            },
            optionChanged: function(args) {
                this.callBase(args);
                switch (args.name) {
                    case"cellHintEnabled":
                    case"onCellPrepared":
                    case"onRowPrepared":
                    case"onCellHoverChanged":
                        this._invalidate(true, true);
                        args.handled = true;
                        break
                }
            },
            init: function() {
                var that = this;
                that._scrollLeft = 0;
                that._columnsController = that.getController("columns");
                that._dataController = that.getController("data");
                that._delayedTemplates = [];
                that._templatesCache = {};
                that.createAction("onCellClick");
                that.createAction("onCellHoverChanged", {excludeValidators: ["disabled", "readOnly"]});
                that.createAction("onCellPrepared", {
                    excludeValidators: ["designMode", "disabled", "readOnly"],
                    category: "rendering"
                });
                that.createAction("onRowPrepared", {
                    excludeValidators: ["designMode", "disabled", "readOnly"],
                    category: "rendering"
                });
                that._columnsController.columnsChanged.add($.proxy(that._columnOptionChanged, that));
                that._dataController && that._dataController.changed.add($.proxy(that._handleDataChanged, that))
            },
            _handleDataChanged: function(e){},
            callbackNames: function() {
                return ["scrollChanged"]
            },
            scrollTo: function(pos) {
                var that = this,
                    $element = that.element(),
                    $scrollContainer = $element && $element.find("." + DATAGRID_SCROLL_CONTAINER_CLASS);
                that._skipScrollChanged = false;
                if (utils.isDefined(pos) && utils.isDefined(pos.left) && that._scrollLeft !== pos.left) {
                    that._scrollLeft = pos.left;
                    $scrollContainer && $scrollContainer.scrollLeft(pos.left);
                    that._skipScrollChanged = true
                }
            },
            wrapTableInScrollContainer: function($table) {
                var that = this,
                    $scrollContainer;
                $scrollContainer = $("<div/>").on("scroll", function() {
                    !that._skipScrollChanged && that.scrollChanged.fire({left: $scrollContainer.scrollLeft()}, that.name);
                    that._skipScrollChanged = false
                }).addClass(DATAGRID_CONTENT_CLASS).addClass(DATAGRID_SCROLL_CONTAINER_CLASS).append($table);
                return $scrollContainer
            },
            getColumnWidths: function() {
                var that = this,
                    result = [],
                    tableElement = that._getTableElement();
                if (tableElement)
                    result = dataGrid.getWidths(tableElement);
                return result
            },
            setColumnWidths: function(widths) {
                var $cols,
                    i,
                    j,
                    columnIndex,
                    columns,
                    tableElements = this.getTableElements(true);
                if (tableElements.length && widths)
                    for (i = 0; i < tableElements.length; i++) {
                        columnIndex = 0;
                        $cols = $(tableElements[i]).find("col");
                        columns = this.getColumns($(tableElements[i]));
                        for (j = 0; j < columns.length; j++) {
                            if (columns[j].colspan) {
                                columnIndex += columns[j].colspan;
                                continue
                            }
                            $cols.eq(columnIndex).css("width", widths[columnIndex] || "auto");
                            columnIndex++
                        }
                    }
            },
            getCellElements: function(rowIndex) {
                var $row = this._getRowElements().eq(rowIndex);
                return $row.children()
            },
            getCellElement: function(rowIndex, columnIdentificator) {
                var that = this,
                    $cells = that.getCellElements(rowIndex),
                    $cell,
                    columnsController = that._columnsController,
                    columnIndex,
                    columnVisibleIndex = columnIdentificator;
                if (utils.isString(columnIdentificator)) {
                    columnIndex = columnsController.columnOption(columnIdentificator, "index");
                    columnVisibleIndex = columnsController.getVisibleIndex(columnIndex)
                }
                if ($cells.length && columnVisibleIndex >= 0)
                    $cell = $cells.eq(columnVisibleIndex);
                if ($cell && $cell.length)
                    return $cell
            },
            getColumnElements: function(){},
            getColumns: function() {
                return this._columnsController.getVisibleColumns()
            },
            getCell: function(cellPosition) {
                var row,
                    tableElement = this._getTableElement();
                if (tableElement && tableElement.length === 1) {
                    row = tableElement[0].rows[cellPosition.rowIndex];
                    return row ? $(row.cells[cellPosition.columnIndex]) : null
                }
            },
            getRowsCount: function() {
                var tableElement = this._getTableElement();
                if (tableElement && tableElement.length === 1)
                    return tableElement[0].rows.length;
                return 0
            },
            _getRowElements: function(tableElement) {
                tableElement = tableElement || this._getTableElement();
                return tableElement && tableElement.children("tbody").children("." + DATAGRID_ROW_CLASS) || $()
            },
            getRowIndex: function($row) {
                return this._getRowElements().index($row)
            },
            getBoundingRect: function(){},
            getName: function(){}
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_INDICATOR_ALIGNMENT_CLASS: DATAGRID_INDICATOR_ALIGNMENT_CLASS,
            DATAGRID_GROUP_SPACE_CLASS: DATAGRID_GROUP_SPACE_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_ROW_CLASS: DATAGRID_ROW_CLASS,
            DATAGRID_GROUP_ROW_CLASS: DATAGRID_GROUP_ROW_CLASS,
            DATAGRID_TABLE_CLASS: DATAGRID_TABLE_CLASS,
            DATAGRID_TABLE_FIXED_CLASS: DATAGRID_TABLE_FIXED_CLASS,
            DATAGRID_SCROLL_CONTAINER_CLASS: DATAGRID_SCROLL_CONTAINER_CLASS,
            DATAGRID_COLUMN_INDICATORS_CLASS: DATAGRID_COLUMN_INDICATORS_CLASS,
            DATAGRID_HEADER_ROW_CLASS: DATAGRID_HEADER_ROW_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnChooserModule.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_COLUMN_CHOOSER_CLASS = "dx-datagrid-column-chooser",
            DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS = "dx-datagrid-column-chooser-button",
            DATAGRID_COLUMN_CHOOSER_ICON_NAME = "column-chooser",
            DATAGRID_COLUMN_CHOOSER_ITEM_CLASS = "dx-column-chooser-item",
            DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS = "dx-column-chooser-message",
            DATAGRID_HEADERS_DRAG_ACTION_CLASS = "dx-datagrid-drag-action";
        dataGrid.ColumnChooserController = dataGrid.ViewController.inherit({
            renderShowColumnChooserButton: function($element) {
                var that = this,
                    columnChooserEnabled = that.option("columnChooser.enabled"),
                    $showColumnChooserButton = $element.find("." + DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS),
                    $columnChooserButton;
                if (columnChooserEnabled)
                    if (!$showColumnChooserButton.length) {
                        $columnChooserButton = $("<div />").addClass(DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS).appendTo($element);
                        that._createComponent($columnChooserButton, "dxButton", {
                            icon: DATAGRID_COLUMN_CHOOSER_ICON_NAME,
                            onClick: function() {
                                that.getView("columnChooserView").showColumnChooser()
                            },
                            hint: that.option("columnChooser.title"),
                            _templates: {}
                        })
                    }
                    else
                        $showColumnChooserButton.show();
                else
                    $showColumnChooserButton.hide()
            },
            getPosition: function() {
                var rowsView = this.getView("rowsView");
                return {
                        my: "right bottom",
                        at: "right bottom",
                        of: rowsView && rowsView.element(),
                        collision: "fit",
                        offset: "-2 -2",
                        boundaryOffset: "2 2"
                    }
            }
        });
        dataGrid.ColumnChooserView = dataGrid.ColumnsView.inherit({
            _updateItems: function() {
                var chooserColumns = this._columnsController.getChooserColumns(),
                    columnChooserOptions = this.option("columnChooser"),
                    $content = this._popupContainer.content(),
                    scrollableInstance = this._createComponent($content, "dxScrollable", dataGrid.createScrollableOptions(this));
                this._renderColumnChooserItems($content, chooserColumns);
                if (!chooserColumns.length)
                    $("<span />").addClass(DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS).text(columnChooserOptions ? columnChooserOptions.emptyPanelText : "").appendTo(scrollableInstance.content())
            },
            _initializePopupContainer: function() {
                var that = this,
                    $element = that.element().addClass(DATAGRID_COLUMN_CHOOSER_CLASS),
                    columnChooserOptions = that.option("columnChooser"),
                    theme = DevExpress.ui.themes.current(),
                    isGenericTheme = theme && theme.indexOf("generic") > -1,
                    isAndroid5Theme = theme && theme.indexOf("android5") > -1,
                    dxPopupOptions = {
                        visible: false,
                        shading: false,
                        showCloseButton: false,
                        dragEnabled: true,
                        buttons: [{
                                text: columnChooserOptions.title,
                                toolbar: "top",
                                location: isGenericTheme || isAndroid5Theme ? "before" : "center"
                            }],
                        position: that.getController("columnChooser").getPosition(),
                        width: columnChooserOptions.width,
                        height: columnChooserOptions.height,
                        rtlEnabled: that.option("rtlEnabled"),
                        container: columnChooserOptions.container
                    };
                if (isGenericTheme)
                    $.extend(dxPopupOptions, {showCloseButton: true});
                else
                    dxPopupOptions.buttons[dxPopupOptions.buttons.length] = {shortcut: "cancel"};
                if (!utils.isDefined(this._popupContainer)) {
                    that._popupContainer = that._createComponent($element, "dxPopup", dxPopupOptions);
                    that._popupContainer.on("optionChanged", function(args) {
                        if (args.name === "visible")
                            that.renderCompleted.fire()
                    })
                }
                else
                    this._popupContainer.option(dxPopupOptions)
            },
            _renderCore: function() {
                if (this._popupContainer)
                    this._updateItems()
            },
            _renderColumnChooserItems: function($container, chooserColumns) {
                var dxScrollable = $container.dxScrollable("instance"),
                    $scrollableContainer = dxScrollable.content(),
                    $item;
                $scrollableContainer.empty();
                $.each(chooserColumns, function(index, chooserColumn) {
                    $item = $("<div />").addClass(chooserColumn.cssClass).addClass(DATAGRID_COLUMN_CHOOSER_ITEM_CLASS).toggleClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS, chooserColumn.allowHiding).text(chooserColumn.caption).appendTo($scrollableContainer)
                });
                dxScrollable.update()
            },
            getColumnElements: function() {
                var $content = this._popupContainer && this._popupContainer.content();
                return $content && $content.find("." + DATAGRID_COLUMN_CHOOSER_ITEM_CLASS)
            },
            getName: function() {
                return "columnChooser"
            },
            getColumns: function() {
                return this._columnsController.getChooserColumns()
            },
            allowDragging: function(column) {
                return this.isColumnChooserVisible() && column && column.allowHiding
            },
            getBoundingRect: function() {
                var that = this,
                    container = that._popupContainer && that._popupContainer._container(),
                    offset;
                if (container && container.is(":visible")) {
                    offset = container.offset();
                    return {
                            left: offset.left,
                            top: offset.top,
                            right: offset.left + container.outerWidth(),
                            bottom: offset.top + container.outerHeight()
                        }
                }
                return null
            },
            showColumnChooser: function() {
                this._isPopupContainerShown = true;
                if (!this._popupContainer) {
                    this._initializePopupContainer();
                    this.render()
                }
                this._popupContainer.show()
            },
            hideColumnChooser: function() {
                if (this._popupContainer) {
                    this._popupContainer.hide();
                    this._isPopupContainerShown = false
                }
            },
            isColumnChooserVisible: function() {
                var popupContainer = this._popupContainer;
                return popupContainer && popupContainer.option("visible")
            },
            publicMethods: function() {
                return ["showColumnChooser", "hideColumnChooser"]
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_COLUMN_CHOOSER_CLASS: DATAGRID_COLUMN_CHOOSER_CLASS,
            DATAGRID_COLUMN_CHOOSER_ITEM_CLASS: DATAGRID_COLUMN_CHOOSER_ITEM_CLASS,
            DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS: DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS,
            DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS: DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS
        });
        dataGrid.registerModule("columnChooser", {
            defaultOptions: function() {
                return {columnChooser: {
                            enabled: false,
                            width: 250,
                            height: 260,
                            title: Globalize.localize("dxDataGrid-columnChooserTitle"),
                            emptyPanelText: Globalize.localize("dxDataGrid-columnChooserEmptyText"),
                            container: undefined
                        }}
            },
            controllers: {columnChooser: dataGrid.ColumnChooserController},
            views: {columnChooserView: dataGrid.ColumnChooserView},
            extenders: {views: {headerPanel: {
                        _renderShowColumnChooserButton: function() {
                            this.getController("columnChooser").renderShowColumnChooserButton(this.element())
                        },
                        _renderCore: function() {
                            this.callBase();
                            this._renderShowColumnChooserButton()
                        },
                        optionChanged: function(args) {
                            switch (args.name) {
                                case"columnChooser":
                                    this._renderShowColumnChooserButton();
                                    args.handled = true;
                                    break;
                                default:
                                    this.callBase(args)
                            }
                        },
                        isVisible: function() {
                            var that = this,
                                columnChooserEnabled = that.option("columnChooser.enabled");
                            return that.callBase() || columnChooserEnabled
                        }
                    }}}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.editing.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            events = DX.ui.events,
            addNamespace = events.addNamespace,
            utils = DX.utils,
            getIndexByKey = dataGrid.getIndexByKey;
        var DATAGRID_LINK_CLASS = "dx-link",
            DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
            DATAGRID_ROW_SELECTED = "dx-selection",
            DATAGRID_EDIT_ROW = "dx-edit-row",
            DATAGRID_EDIT_BUTTON_CLASS = "dx-edit-button",
            DATAGRID_INSERT_INDEX = "__DX_INSERT_INDEX__",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_ROW_REMOVED = "dx-row-removed",
            DATAGRID_ROW_INSERTED = "dx-row-inserted",
            DATAGRID_ROW_MODIFIED = "dx-row-modified",
            DATAGRID_CELL_MODIFIED = "dx-cell-modified",
            DATAGRID_CELL_HIGHLIGHT_OUTLINE = "dx-highlight-outline",
            DATAGRID_EDITING_NAMESPACE = "dxDataGridEditing",
            DATAGRID_FOCUS_OVERLAY_CLASS = "dx-datagrid-focus-overlay",
            DATAGRID_READONLY_CLASS = "dx-datagrid-readonly",
            DATAGRID_DATA_ROW_CLASS = "dx-data-row",
            CHECKBOX_CLASS = "dx-checkbox",
            DATAGRID_EDITOR_INLINE_BLOCK = "dx-editor-inline-block",
            DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
            DATAGRID_EDIT_MODE_BATCH = "batch",
            DATAGRID_EDIT_MODE_ROW = "row",
            DATAGRID_EDIT_MODE_CELL = "cell",
            DATA_EDIT_DATA_INSERT_TYPE = "insert",
            DATA_EDIT_DATA_UPDATE_TYPE = "update",
            DATA_EDIT_DATA_REMOVE_TYPE = "remove",
            DATAGRID_POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
            DATAGRID_POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target";
        var getEditMode = function(that) {
                var editMode = that.option("editing.editMode");
                if (editMode === DATAGRID_EDIT_MODE_BATCH || editMode === DATAGRID_EDIT_MODE_CELL)
                    return editMode;
                return DATAGRID_EDIT_MODE_ROW
            };
        dataGrid.EditingController = dataGrid.ViewController.inherit(function() {
            var getDefaultEditorTemplate = function(that) {
                    return function(container, options) {
                            var $editor = $("<div/>").appendTo(container);
                            that.getController("editorFactory").createEditor($editor, $.extend({}, options.column, {
                                value: options.value,
                                setValue: options.setValue,
                                row: options.row,
                                parentType: "dataRow",
                                width: null,
                                readOnly: options.setValue === undefined
                            }))
                        }
                };
            return {
                    init: function() {
                        var that = this;
                        that._insertIndex = 1;
                        that._editRowIndex = -1;
                        that._editData = [];
                        that._editColumnIndex = -1;
                        that._columnsController = that.getController("columns");
                        that._dataController = that.getController("data");
                        that.createAction("onInitNewRow", {excludeValidators: ["disabled", "readOnly"]});
                        that.createAction("onRowInserting", {excludeValidators: ["disabled", "readOnly"]});
                        that.createAction("onRowInserted", {excludeValidators: ["disabled", "readOnly"]});
                        that.createAction("onEditingStart", {excludeValidators: ["disabled", "readOnly"]});
                        that.createAction("onRowUpdating", {excludeValidators: ["disabled", "readOnly"]});
                        that.createAction("onRowUpdated", {excludeValidators: ["disabled", "readOnly"]});
                        that.createAction("onRowRemoving", {excludeValidators: ["disabled", "readOnly"]});
                        that.createAction("onRowRemoved", {excludeValidators: ["disabled", "readOnly"]});
                        if (!that._dataChangedHandler) {
                            that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
                            that._dataController.changed.add(that._dataChangedHandler)
                        }
                        if (!that._saveEditorHandler) {
                            that._saveEditorHandler = that.createAction(function(e) {
                                var event = e.jQueryEvent,
                                    visibleColumns,
                                    isEditorPopup,
                                    isDomElement,
                                    isFocusOverlay,
                                    $targetCell,
                                    allowEditing,
                                    columnIndex,
                                    isDataRow,
                                    rowIndex;
                                if (getEditMode(that) !== DATAGRID_EDIT_MODE_ROW && that.isEditing() && !that._editCellInProgress) {
                                    isEditorPopup = $(event.target).closest(".dx-overlay-wrapper").length;
                                    isDomElement = $(event.target).closest(document).length;
                                    isFocusOverlay = $(event.target).hasClass(DATAGRID_FOCUS_OVERLAY_CLASS);
                                    isDataRow = $(event.target).closest("." + DATAGRID_DATA_ROW_CLASS).length;
                                    visibleColumns = that._columnsController.getVisibleColumns();
                                    $targetCell = $(event.target).closest("." + DATAGRID_ROW_CLASS + "> td");
                                    columnIndex = $targetCell[0] && $targetCell[0].cellIndex;
                                    rowIndex = that.getView("rowsView").getRowIndex($targetCell.parent());
                                    allowEditing = visibleColumns[columnIndex] && visibleColumns[columnIndex].allowEditing;
                                    if ((!isDataRow || isDataRow && !allowEditing && !that.isEditCell(rowIndex, columnIndex)) && !isEditorPopup && !isFocusOverlay && isDomElement)
                                        that.closeEditCell()
                                }
                            });
                            $(document).on("dxclick", that._saveEditorHandler)
                        }
                        that._updateEditColumn();
                        that._updateEditButtons()
                    },
                    _handleDataChanged: function(args) {
                        if (this.option("scrolling.mode") === "standard")
                            this.resetRowAndPageIndeces();
                        if (args.changeType === "prepend")
                            $.each(this._editData, function(_, editData) {
                                editData.rowIndex += args.items.length;
                                if (editData.type === DATA_EDIT_DATA_INSERT_TYPE)
                                    editData.key.rowIndex += args.items.length
                            })
                    },
                    getEditMode: function() {
                        return getEditMode(this)
                    },
                    getFirstEditableColumnIndex: function() {
                        var columnsController = this.getController("columns"),
                            visibleColumns = columnsController.getVisibleColumns(),
                            columnIndex;
                        $.each(visibleColumns, function(index, column) {
                            if (column.allowEditing) {
                                columnIndex = index;
                                return false
                            }
                        });
                        return columnIndex
                    },
                    getFirstEditableCellInRow: function(rowIndex) {
                        return this.getView("rowsView").getCellElement(rowIndex ? rowIndex : 0, this.getFirstEditableColumnIndex())
                    },
                    getFocusedCellInRow: function(rowIndex) {
                        return this.getFirstEditableCellInRow(rowIndex)
                    },
                    getIndexByKey: function(key, items) {
                        return getIndexByKey(key, items)
                    },
                    hasChanges: function() {
                        var that = this,
                            result = false;
                        $.each(that._editData, function(_, editData) {
                            result = result || !!editData.type
                        });
                        return result
                    },
                    dispose: function() {
                        this.callBase();
                        $(document).off("dxclick", this._saveEditorHandler)
                    },
                    optionChanged: function(args) {
                        if (args.name === "editing") {
                            this.init();
                            args.handled = true
                        }
                        else
                            this.callBase(args)
                    },
                    publicMethods: function() {
                        return ["insertRow", "editRow", "editCell", "closeEditCell", "removeRow", "saveEditData", "undeleteRow", "cancelEditData"]
                    },
                    refresh: function() {
                        if (getEditMode(this) === DATAGRID_EDIT_MODE_ROW || getEditMode(this) === DATAGRID_EDIT_MODE_CELL)
                            this.init();
                        else {
                            this._editRowIndex = -1;
                            this._editColumnIndex = -1
                        }
                    },
                    isEditing: function() {
                        return this._editRowIndex > -1
                    },
                    isEditRow: function(rowIndex) {
                        return getEditMode(this) === DATAGRID_EDIT_MODE_ROW && this._editRowIndex === rowIndex
                    },
                    isEditCell: function(rowIndex, columnIndex) {
                        return this._editRowIndex === rowIndex && this._editColumnIndex === columnIndex
                    },
                    _needInsertItem: function(editData, changeType) {
                        var that = this,
                            dataSource = that._dataController.dataSource(),
                            srollingMode = that.option("scrolling.mode"),
                            pageIndex = dataSource.pageIndex(),
                            beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : pageIndex,
                            endPageIndex = dataSource.endPageIndex ? dataSource.endPageIndex() : pageIndex;
                        if (srollingMode !== "standard")
                            switch (changeType) {
                                case"append":
                                    return editData.key.pageIndex === endPageIndex;
                                case"prepend":
                                    return editData.key.pageIndex === beginPageIndex;
                                case"refresh":
                                    editData.key.rowIndex = 0;
                                    editData.key.pageIndex = 0;
                                    break;
                                default:
                                    return editData.key.pageIndex >= beginPageIndex && editData.key.pageIndex <= endPageIndex
                            }
                        return editData.key.pageIndex === pageIndex
                    },
                    processItems: function(items, changeType) {
                        var that = this,
                            i,
                            key,
                            data,
                            editData = that._editData;
                        that.update();
                        for (i = 0; i < editData.length; i++) {
                            key = editData[i].key;
                            data = {key: key};
                            if (editData[i].type === DATA_EDIT_DATA_INSERT_TYPE && that._needInsertItem(editData[i], changeType)) {
                                data[DATAGRID_INSERT_INDEX] = key[DATAGRID_INSERT_INDEX];
                                items.splice(key.rowIndex, 0, data)
                            }
                        }
                        return items
                    },
                    processDataItem: function(item, columns, generateDataValues) {
                        var that = this,
                            editIndex,
                            editData,
                            data,
                            key = item.data[DATAGRID_INSERT_INDEX] ? item.data.key : item.key,
                            editMode = getEditMode(that);
                        editIndex = getIndexByKey(key, that._editData);
                        if (editIndex >= 0) {
                            editData = that._editData[editIndex];
                            data = editData.data;
                            switch (editData.type) {
                                case DATA_EDIT_DATA_INSERT_TYPE:
                                    item.inserted = true;
                                    item.key = key;
                                    item.data = data;
                                    break;
                                case DATA_EDIT_DATA_UPDATE_TYPE:
                                    item.modified = true;
                                    item.data = $.extend(true, {}, item.data, data);
                                    item.modifiedValues = generateDataValues(data, columns);
                                    break;
                                case DATA_EDIT_DATA_REMOVE_TYPE:
                                    if (editMode === DATAGRID_EDIT_MODE_BATCH)
                                        item.data = $.extend(true, {}, item.data, data);
                                    item.removed = true;
                                    break
                            }
                        }
                    },
                    insertRow: function() {
                        var that = this,
                            dataController = that._dataController,
                            store = dataController.store(),
                            key = store && store.key(),
                            rowsView = that.getView("rowsView"),
                            param = {data: {}},
                            insertKey = {
                                pageIndex: dataController.pageIndex(),
                                rowIndex: rowsView ? rowsView.getTopVisibleItemIndex() : 0
                            },
                            oldEditRowIndex = that._editRowIndex,
                            editMode = getEditMode(that),
                            $firstCell;
                        if (editMode === DATAGRID_EDIT_MODE_CELL && that.hasChanges())
                            that.saveEditData();
                        that.refresh();
                        if (editMode !== DATAGRID_EDIT_MODE_BATCH) {
                            if (that._insertIndex > 1)
                                return;
                            that._editRowIndex = insertKey.rowIndex
                        }
                        if (!key)
                            param.data.__KEY__ = String(new DX.data.Guid);
                        that.executeAction("onInitNewRow", param);
                        insertKey[DATAGRID_INSERT_INDEX] = that._insertIndex++;
                        that._addEditData({
                            key: insertKey,
                            data: param.data,
                            type: DATA_EDIT_DATA_INSERT_TYPE
                        });
                        dataController.updateItems({
                            changeType: "update",
                            rowIndices: [oldEditRowIndex, insertKey.rowIndex]
                        });
                        $firstCell = that.getFirstEditableCellInRow(insertKey.rowIndex);
                        that._delayedInputFocus($firstCell, function() {
                            var $cell = that.getFirstEditableCellInRow(insertKey.rowIndex);
                            $cell && $cell.trigger("dxclick")
                        });
                        that._afterInsertRow({
                            key: insertKey,
                            data: param.data
                        })
                    },
                    _isEditingStart: function(options) {
                        this.executeAction("onEditingStart", options);
                        return options.cancel
                    },
                    _beforeEditCell: function(rowIndex, columnIndex, item) {
                        if (getEditMode(this) === DATAGRID_EDIT_MODE_CELL && !item.inserted && this.hasChanges()) {
                            this.saveEditData();
                            if (this.hasChanges())
                                return true
                        }
                    },
                    editRow: function(rowIndex) {
                        var that = this,
                            dataController = that._dataController,
                            items = dataController.items(),
                            item = items[rowIndex],
                            params = {
                                data: item.data,
                                cancel: false
                            },
                            oldEditRowIndex = that._editRowIndex,
                            $editingCell;
                        if (rowIndex === oldEditRowIndex)
                            return true;
                        if (!item.inserted)
                            params.key = item.key;
                        if (that._isEditingStart(params))
                            return;
                        that.init();
                        that._pageIndex = dataController.pageIndex();
                        that._editRowIndex = items[0].inserted ? rowIndex - 1 : rowIndex;
                        that._addEditData({
                            data: {},
                            key: item.key,
                            oldData: item.data
                        });
                        dataController.updateItems({
                            changeType: "update",
                            rowIndices: [oldEditRowIndex, rowIndex]
                        });
                        $editingCell = that.getFocusedCellInRow(that._editRowIndex);
                        that._delayedInputFocus($editingCell, function() {
                            $editingCell && that.component.focus($editingCell)
                        })
                    },
                    editCell: function(rowIndex, columnIndex) {
                        var that = this,
                            dataController = that._dataController,
                            items = dataController.items(),
                            item = items[rowIndex],
                            params = {
                                data: item && item.data,
                                cancel: false,
                                column: that._columnsController.getVisibleColumns()[columnIndex]
                            },
                            editMode = getEditMode(that),
                            oldEditRowIndex = that._editRowIndex,
                            oldEditColumnIndex = that._editColumnIndex,
                            columns = that._columnsController.getVisibleColumns(),
                            showEditorAlways = params.column && params.column.showEditorAlways;
                        if (params.column && item && item.rowType === "data" && !item.removed && editMode !== DATAGRID_EDIT_MODE_ROW) {
                            if (this.isEditCell(rowIndex, columnIndex))
                                return true;
                            if (that._beforeEditCell(rowIndex, columnIndex, item))
                                return true;
                            if (!item.inserted)
                                params.key = item.key;
                            if (that._isEditingStart(params))
                                return true;
                            that._editRowIndex = rowIndex;
                            that._editColumnIndex = columnIndex;
                            that._pageIndex = dataController.pageIndex();
                            that._addEditData({
                                data: {},
                                key: item.key,
                                oldData: item.data
                            });
                            if (!showEditorAlways || columns[oldEditColumnIndex] && !columns[oldEditColumnIndex].showEditorAlways) {
                                that._editCellInProgress = true;
                                dataController.updateItems({
                                    changeType: "update",
                                    rowIndices: [oldEditRowIndex, that._editRowIndex]
                                })
                            }
                            that._focusEditingCell(function() {
                                that._editCellInProgress = false
                            });
                            return true
                        }
                        return false
                    },
                    _delayedInputFocus: function($cell, beforeFocusCallback) {
                        setTimeout(function() {
                            if (beforeFocusCallback)
                                beforeFocusCallback();
                            $cell.find("[tabindex], input").focus()
                        })
                    },
                    _focusEditingCell: function(beforeFocusCallback) {
                        var that = this,
                            $editCell = that.getView("rowsView").getCellElement(that._editRowIndex, that._editColumnIndex);
                        that._delayedInputFocus($editCell, beforeFocusCallback)
                    },
                    removeRow: function(rowIndex) {
                        var that = this,
                            editingOptions = that.option("editing"),
                            editingTexts = editingOptions && editingOptions.texts,
                            confirmDeleteTitle = editingTexts && editingTexts.confirmDeleteTitle,
                            isBatchMode = editingOptions && editingOptions.editMode === DATAGRID_EDIT_MODE_BATCH,
                            confirmDeleteMessage = editingTexts && editingTexts.confirmDeleteMessage,
                            dataController = that._dataController,
                            removeByKey,
                            showDialogTitle,
                            oldEditRowIndex = that._editRowIndex,
                            item = dataController.items()[rowIndex],
                            key = item && item.key;
                        if (item) {
                            removeByKey = function(key) {
                                that.refresh();
                                var editIndex = getIndexByKey(key, that._editData);
                                if (editIndex >= 0)
                                    if (that._editData[editIndex].type === DATA_EDIT_DATA_INSERT_TYPE)
                                        that._editData.splice(editIndex, 1);
                                    else
                                        that._editData[editIndex].type = DATA_EDIT_DATA_REMOVE_TYPE;
                                else
                                    that._addEditData({
                                        key: key,
                                        oldData: item.data,
                                        type: DATA_EDIT_DATA_REMOVE_TYPE
                                    });
                                if (isBatchMode)
                                    dataController.updateItems({
                                        changeType: "update",
                                        rowIndices: [oldEditRowIndex, rowIndex]
                                    });
                                else
                                    that.saveEditData()
                            };
                            if (isBatchMode || !confirmDeleteMessage)
                                removeByKey(key);
                            else {
                                showDialogTitle = utils.isDefined(confirmDeleteTitle) && confirmDeleteTitle.length > 0;
                                DX.ui.dialog.confirm(confirmDeleteMessage, confirmDeleteTitle, showDialogTitle).done(function(confirmResult) {
                                    if (confirmResult)
                                        removeByKey(key)
                                })
                            }
                        }
                    },
                    undeleteRow: function(rowIndex) {
                        var that = this,
                            dataController = that._dataController,
                            item = dataController.items()[rowIndex],
                            oldEditRowIndex = that._editRowIndex,
                            key = item && item.key;
                        if (item) {
                            var editIndex = getIndexByKey(key, that._editData),
                                editData;
                            if (editIndex >= 0) {
                                editData = that._editData[editIndex];
                                if ($.isEmptyObject(editData.data))
                                    that._editData.splice(editIndex, 1);
                                else
                                    editData.type = DATA_EDIT_DATA_UPDATE_TYPE;
                                dataController.updateItems({
                                    changeType: "update",
                                    rowIndices: [oldEditRowIndex, rowIndex]
                                })
                            }
                        }
                    },
                    _saveEditDataCore: function(deferreds, processedKeys) {
                        var that = this,
                            store = that._dataController.store(),
                            hasCanceledData = false;
                        $.each(that._editData, function(index, editData) {
                            var data = editData.data,
                                oldData = editData.oldData,
                                key = editData.key,
                                type = editData.type,
                                deferred,
                                doneDeferred,
                                params;
                            if (that._beforeSaveEditData(editData, index))
                                return;
                            switch (type) {
                                case DATA_EDIT_DATA_REMOVE_TYPE:
                                    params = {
                                        data: oldData,
                                        key: key,
                                        cancel: false
                                    };
                                    that.executeAction("onRowRemoving", params);
                                    if (params.cancel)
                                        return;
                                    deferred = store.remove(key);
                                    break;
                                case DATA_EDIT_DATA_INSERT_TYPE:
                                    params = {
                                        data: data,
                                        cancel: false
                                    };
                                    that.executeAction("onRowInserting", params);
                                    if (params.cancel)
                                        return;
                                    deferred = store.insert(params.data);
                                    break;
                                case DATA_EDIT_DATA_UPDATE_TYPE:
                                    params = {
                                        newData: data,
                                        oldData: oldData,
                                        key: key,
                                        cancel: false
                                    };
                                    that.executeAction("onRowUpdating", params);
                                    if (params.cancel) {
                                        hasCanceledData = true;
                                        return
                                    }
                                    deferred = store.update(key, params.newData);
                                    break
                            }
                            if (deferred) {
                                doneDeferred = $.Deferred();
                                deferred.always(function() {
                                    processedKeys.push(key)
                                }).always(doneDeferred.resolve);
                                deferreds.push(doneDeferred.promise())
                            }
                        });
                        return hasCanceledData
                    },
                    _processSaveEditDataResult: function(results, processedKeys) {
                        var that = this,
                            dataController = that._dataController,
                            i,
                            arg,
                            editIndex,
                            isError,
                            editMode = getEditMode(that);
                        for (i = 0; i < results.length; i++) {
                            arg = results[i];
                            editIndex = getIndexByKey(processedKeys[i], that._editData);
                            if (that._editData[editIndex]) {
                                isError = arg && arg instanceof Error;
                                if (isError) {
                                    that._editData[editIndex].error = arg;
                                    dataController.dataErrorOccurred.fire(arg);
                                    if (editMode !== DATAGRID_EDIT_MODE_BATCH)
                                        return false
                                }
                                else
                                    that._editData.splice(editIndex, 1)
                            }
                        }
                        return true
                    },
                    _fireSaveEditDataEvents: function(editData) {
                        var that = this;
                        $.each(editData, function(_, itemData) {
                            var data = itemData.data,
                                key = itemData.key,
                                type = itemData.type,
                                params = {
                                    key: key,
                                    data: data
                                };
                            if (itemData.error)
                                params.error = itemData.error;
                            switch (type) {
                                case DATA_EDIT_DATA_REMOVE_TYPE:
                                    that.executeAction("onRowRemoved", $.extend({}, params, {data: itemData.oldData}));
                                    break;
                                case DATA_EDIT_DATA_INSERT_TYPE:
                                    that.executeAction("onRowInserted", params);
                                    break;
                                case DATA_EDIT_DATA_UPDATE_TYPE:
                                    that.executeAction("onRowUpdated", params);
                                    break
                            }
                        })
                    },
                    saveEditData: function() {
                        var that = this,
                            processedKeys = [],
                            deferreds = [],
                            dataController = that._dataController,
                            rowIndex = that._editRowIndex,
                            editData = $.extend({}, that._editData),
                            editMode = getEditMode(that),
                            result = $.Deferred(),
                            hasCanceledData;
                        var resetEditIndices = function(that) {
                                that._editColumnIndex = -1;
                                that._editRowIndex = -1
                            };
                        if (that._beforeSaveEditData()) {
                            that._afterSaveEditData();
                            return
                        }
                        hasCanceledData = that._saveEditDataCore(deferreds, processedKeys);
                        if (deferreds.length) {
                            $.when.apply($, deferreds).done(function() {
                                if (that._processSaveEditDataResult(arguments, processedKeys)) {
                                    resetEditIndices(that);
                                    $.when(dataController.refresh()).always(function() {
                                        that._fireSaveEditDataEvents(editData);
                                        that._afterSaveEditData();
                                        result.resolve()
                                    })
                                }
                            }).fail(result.resolve);
                            return result.promise()
                        }
                        if (editMode === DATAGRID_EDIT_MODE_ROW) {
                            if (!that.hasChanges())
                                that.cancelEditData()
                        }
                        else if (editMode === DATAGRID_EDIT_MODE_BATCH || editMode === DATAGRID_EDIT_MODE_CELL && !hasCanceledData) {
                            resetEditIndices(that);
                            dataController.updateItems(rowIndex >= 0 && {
                                changeType: "update",
                                rowIndices: [rowIndex]
                            })
                        }
                        else
                            that._focusEditingCell();
                        that._afterSaveEditData();
                        return result.resolve().promise()
                    },
                    _updateEditColumn: function() {
                        var that = this,
                            editing = that.option("editing"),
                            isEditColumnVisible = editing && ((editing.editEnabled || editing.insertEnabled) && getEditMode(that) === DATAGRID_EDIT_MODE_ROW || editing.removeEnabled);
                        that._columnsController.addCommandColumn({
                            command: "edit",
                            visible: isEditColumnVisible,
                            cssClass: "dx-command-edit",
                            width: "auto"
                        });
                        that._columnsController.columnOption("command:edit", "visible", isEditColumnVisible)
                    },
                    _updateEditButtons: function() {
                        var that = this,
                            saveChangesButton = that._saveChangesButton,
                            cancelChangesButton = that._cancelChangesButton,
                            hasChanges = that.hasChanges();
                        if (saveChangesButton)
                            saveChangesButton.option("disabled", !hasChanges);
                        if (cancelChangesButton)
                            cancelChangesButton.option("disabled", !hasChanges)
                    },
                    cancelEditData: function() {
                        var that = this,
                            dataController = that._dataController;
                        that._beforeCancelEditData();
                        that.init();
                        dataController.updateItems()
                    },
                    closeEditCell: function() {
                        var that = this,
                            editMode = getEditMode(that),
                            oldEditRowIndex = that._editRowIndex,
                            dataController = that._dataController;
                        if (editMode !== DATAGRID_EDIT_MODE_ROW)
                            setTimeout(function() {
                                if (editMode === DATAGRID_EDIT_MODE_CELL && that.hasChanges())
                                    that.saveEditData();
                                else if (oldEditRowIndex >= 0) {
                                    that._editRowIndex = -1;
                                    that._editColumnIndex = -1;
                                    dataController.updateItems({
                                        changeType: "update",
                                        rowIndices: [oldEditRowIndex]
                                    })
                                }
                            })
                    },
                    update: function() {
                        var that = this,
                            dataController = that._dataController;
                        if (that._pageIndex !== dataController.pageIndex()) {
                            that.refresh();
                            that._pageIndex = dataController.pageIndex()
                        }
                        that._updateEditButtons()
                    },
                    updateFieldValue: function(options, value) {
                        var that = this,
                            data = {},
                            rowKey = options.key,
                            $cellElement = options.cellElement,
                            editMode = getEditMode(that),
                            params;
                        if (rowKey !== undefined && options.column.setCellValue) {
                            if (editMode === DATAGRID_EDIT_MODE_BATCH && $cellElement)
                                $cellElement.addClass(DATAGRID_CELL_MODIFIED);
                            options.value = value;
                            options.column.setCellValue(data, value);
                            params = {
                                data: data,
                                key: rowKey,
                                oldData: options.data,
                                type: DATA_EDIT_DATA_UPDATE_TYPE
                            };
                            that._addEditData(params);
                            that._updateEditButtons();
                            if (options.column.showEditorAlways && getEditMode(that) === DATAGRID_EDIT_MODE_CELL && options.row && !options.row.inserted)
                                that.saveEditData().always(function() {
                                    that._editColumnIndex = options.columnIndex;
                                    that._editRowIndex = options.rowIndex;
                                    that._focusEditingCell()
                                })
                        }
                    },
                    _addEditData: function(options) {
                        var that = this,
                            editDataIndex = getIndexByKey(options.key, that._editData);
                        if (editDataIndex < 0) {
                            editDataIndex = that._editData.length;
                            that._editData.push(options)
                        }
                        if (that._editData[editDataIndex]) {
                            options.type = that._editData[editDataIndex].type || options.type;
                            utils.deepExtendArraySafe(that._editData[editDataIndex], {
                                data: options.data,
                                type: options.type
                            })
                        }
                        return editDataIndex
                    },
                    getColumnTemplate: function(options) {
                        var that = this,
                            column = options.column,
                            rowIndex = options.row && options.row.rowIndex,
                            template,
                            editingOptions,
                            editingTexts,
                            editEnabled = that.option("editing.editEnabled"),
                            isRowMode = getEditMode(that) === DATAGRID_EDIT_MODE_ROW,
                            isRowEditing = that.isEditRow(rowIndex),
                            isCellEditing = that.isEditCell(rowIndex, options.columnIndex);
                        if ((column.showEditorAlways || column.setCellValue && (isRowEditing && column.allowEditing || isCellEditing)) && options.rowType === "data" && !utils.isDefined(column.command)) {
                            if (((editEnabled || isRowEditing) && column.allowEditing || isCellEditing) && (isRowMode && isRowEditing || !isRowMode))
                                options.setValue = function(value) {
                                    that.updateFieldValue(options, value)
                                };
                            template = column.editCellTemplate || getDefaultEditorTemplate(that)
                        }
                        else if (column.command === "edit" && options.rowType === "data")
                            template = function(container, options) {
                                var createLink = function(container, text, methodName, options) {
                                        var $link = $("<a />").addClass(DATAGRID_LINK_CLASS).text(text).on(addNamespace("dxclick", DATAGRID_EDITING_NAMESPACE), that.createAction(function(params) {
                                                var e = params.jQueryEvent;
                                                e.stopPropagation();
                                                setTimeout(function() {
                                                    options.row && that[methodName](options.row.rowIndex)
                                                })
                                            }));
                                        options.rtlEnabled ? container.prepend($link, "&nbsp;") : container.append($link, "&nbsp;")
                                    };
                                container.css("text-align", "center");
                                options.rtlEnabled = that.option("rtlEnabled");
                                editingOptions = that.option("editing") || {};
                                editingTexts = editingOptions.texts || {};
                                if (options.row && options.row.rowIndex === that._editRowIndex && isRowMode) {
                                    createLink(container, editingTexts.saveRowChanges, "saveEditData", options);
                                    createLink(container, editingTexts.cancelRowChanges, "cancelEditData", options)
                                }
                                else {
                                    if (editingOptions.editEnabled && isRowMode)
                                        createLink(container, editingTexts.editRow, "editRow", options);
                                    if (editingOptions.removeEnabled)
                                        if (options.row.removed)
                                            createLink(container, editingTexts.undeleteRow, "undeleteRow", options);
                                        else
                                            createLink(container, editingTexts.deleteRow, "removeRow", options)
                                }
                            };
                        return template
                    },
                    renderEditButtons: function(rootElement) {
                        var that = this,
                            insertButton = rootElement.find("." + DATAGRID_EDIT_BUTTON_CLASS),
                            editingOptions = that.option("editing") || {},
                            editingTexts = that.option("editing.texts") || {},
                            titleButtonTextByClassNames = {
                                cancel: editingTexts.cancelAllChanges,
                                save: editingTexts.saveAllChanges,
                                addrow: editingTexts.addRow
                            };
                        var createEditButton = function(rootElement, className, methodName) {
                                return that._createComponent($("<div />").addClass(DATAGRID_EDIT_BUTTON_CLASS).addClass("dx-datagrid-" + className + "-button").appendTo(rootElement), "dxButton", {
                                        icon: "edit-button-" + className,
                                        onClick: function(options) {
                                            var e = options.jQueryEvent;
                                            e.stopPropagation();
                                            that[methodName]()
                                        },
                                        hint: titleButtonTextByClassNames && titleButtonTextByClassNames[className]
                                    })
                            };
                        if (insertButton.length)
                            insertButton.remove();
                        if ((editingOptions.editEnabled || editingOptions.insertEnabled || editingOptions.removeEnabled) && getEditMode(that) === DATAGRID_EDIT_MODE_BATCH) {
                            that._cancelChangesButton = createEditButton(rootElement, "cancel", "cancelEditData");
                            that._saveChangesButton = createEditButton(rootElement, "save", "saveEditData");
                            that._updateEditButtons()
                        }
                        if (editingOptions.insertEnabled)
                            createEditButton(rootElement, "addrow", "insertRow")
                    },
                    createHighlightCell: function($cell) {
                        var $highlight = $cell.find("." + DATAGRID_CELL_HIGHLIGHT_OUTLINE);
                        if (!$highlight.length)
                            $cell.wrapInner($("<div>").addClass(DATAGRID_CELL_HIGHLIGHT_OUTLINE + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS))
                    },
                    resetRowAndPageIndeces: function(alwaysRest) {
                        var that = this;
                        $.each(that._editData, function(_, editData) {
                            if (editData.pageIndex !== that._pageIndex || alwaysRest) {
                                delete editData.pageIndex;
                                delete editData.rowIndex
                            }
                        })
                    },
                    _afterInsertRow: function(options){},
                    _beforeSaveEditData: function(editData, editIndex){},
                    _afterSaveEditData: function(){},
                    _beforeCancelEditData: function(){}
                }
        }());
        dataGrid.registerModule("editing", {
            defaultOptions: function() {
                return {editing: {
                            editMode: "row",
                            insertEnabled: false,
                            editEnabled: false,
                            removeEnabled: false,
                            texts: {
                                editRow: Globalize.localize("dxDataGrid-editingEditRow"),
                                saveAllChanges: Globalize.localize("dxDataGrid-editingSaveAllChanges"),
                                saveRowChanges: Globalize.localize("dxDataGrid-editingSaveRowChanges"),
                                cancelAllChanges: Globalize.localize("dxDataGrid-editingCancelAllChanges"),
                                cancelRowChanges: Globalize.localize("dxDataGrid-editingCancelRowChanges"),
                                addRow: Globalize.localize("dxDataGrid-editingAddRow"),
                                deleteRow: Globalize.localize("dxDataGrid-editingDeleteRow"),
                                undeleteRow: Globalize.localize("dxDataGrid-editingUndeleteRow"),
                                confirmDeleteMessage: Globalize.localize("dxDataGrid-editingConfirmDeleteMessage"),
                                confirmDeleteTitle: Globalize.localize("dxDataGrid-editingConfirmDeleteTitle")
                            }
                        }}
            },
            controllers: {editing: dataGrid.EditingController},
            extenders: {
                controllers: {
                    data: {
                        init: function() {
                            this._editingController = this.getController("editing");
                            this.callBase()
                        },
                        reload: function() {
                            var d,
                                editingController = this.getController("editing");
                            this._editingController.refresh();
                            d = this.callBase();
                            return d && d.done(function() {
                                    editingController.resetRowAndPageIndeces(true)
                                })
                        },
                        _processItems: function(items, changeType) {
                            items = this._editingController.processItems(items, changeType);
                            return this.callBase(items, changeType)
                        },
                        _processDataItem: function(dataItem, options) {
                            this._editingController.processDataItem(dataItem, options.visibleColumns, this._generateDataValues);
                            return this.callBase(dataItem, options)
                        },
                        _processItem: function(item, options) {
                            item = this.callBase(item, options);
                            if (item.inserted) {
                                options.dataIndex--;
                                delete item.dataIndex
                            }
                            return item
                        }
                    },
                    columnsResizer: {_startResizing: function(args) {
                            var that = this,
                                editingController = that.getController("editing"),
                                isCellEditing = function() {
                                    var editingOptions = that.option("editing");
                                    return editingOptions && editingOptions.editMode !== DATAGRID_EDIT_MODE_ROW && editingController.isEditing()
                                };
                            that.callBase(args);
                            if (that.isResizing() && isCellEditing())
                                editingController.closeEditCell()
                        }}
                },
                views: {
                    rowsView: {
                        _getColumnTemplate: function(options) {
                            var that = this,
                                template = that.getController("editing").getColumnTemplate(options);
                            return template || that.callBase(options)
                        },
                        _createTable: function() {
                            var that = this,
                                editing = that.option("editing"),
                                $table = that.callBase.apply(that, arguments);
                            if (editing && editing.editMode !== DATAGRID_EDIT_MODE_ROW && editing.editEnabled)
                                $table.on(events.addNamespace("dxhold", "dxDataGridRowsView"), "td:not(." + DATAGRID_EDITOR_CELL_CLASS + ")", that.createAction(function(e) {
                                    var editingController = that.getController("editing");
                                    if (editingController.isEditing())
                                        editingController.closeEditCell()
                                }));
                            return $table
                        },
                        _createRow: function(row) {
                            var $row = this.callBase(row),
                                editingController,
                                isEditRow,
                                isRowRemoved,
                                isRowInserted,
                                isRowModified;
                            if (row) {
                                editingController = this.getController("editing");
                                isEditRow = editingController.isEditRow(row.rowIndex);
                                isRowRemoved = !!row.removed;
                                isRowInserted = !!row.inserted;
                                isRowModified = !!row.modified;
                                if (getEditMode(this) === DATAGRID_EDIT_MODE_BATCH)
                                    $row.toggleClass(DATAGRID_ROW_REMOVED, isRowRemoved);
                                else
                                    $row.toggleClass(DATAGRID_EDIT_ROW, isEditRow);
                                $row.toggleClass(DATAGRID_ROW_INSERTED, isRowInserted);
                                $row.toggleClass(DATAGRID_ROW_MODIFIED, isRowModified);
                                if (isEditRow || isRowInserted || isRowRemoved)
                                    $row.removeClass(DATAGRID_ROW_SELECTED)
                            }
                            return $row
                        },
                        _rowClick: function(e) {
                            var that = this,
                                editingController = that.getController("editing"),
                                $targetCell = $(e.jQueryEvent.target).closest("." + DATAGRID_ROW_CLASS + "> td"),
                                columnIndex = that.getCellIndex($targetCell),
                                editEnabled = that.option("editing.editEnabled"),
                                column = that._columnsController.getVisibleColumns()[columnIndex],
                                allowEditing = column && (column.allowEditing || editingController.isEditCell(e.rowIndex, columnIndex));
                            if ($targetCell.hasClass(DATAGRID_POINTER_EVENTS_NONE_CLASS))
                                return;
                            if (!(editEnabled && allowEditing && editingController.editCell(e.rowIndex, columnIndex)) && !editingController.isEditRow(e.rowIndex))
                                that.callBase(e)
                        },
                        _cellPrepared: function($cell, parameters) {
                            var columnIndex = parameters.columnIndex,
                                editingController = this.getController("editing"),
                                editMode = editingController.getEditMode(),
                                isCommandCell = !!parameters.column.command,
                                isEditableCell = parameters.setValue;
                            parameters.isEditing = editingController.isEditCell(parameters.rowIndex, parameters.columnIndex) || editingController.isEditRow(parameters.rowIndex) && parameters.column.allowEditing;
                            if (!utils.isDefined(parameters.column.command) && (parameters.isEditing || parameters.column.showEditorAlways)) {
                                var alignment = parameters.column.alignment;
                                $cell.addClass(DATAGRID_EDITOR_CELL_CLASS).toggleClass(DATAGRID_READONLY_CLASS, !isEditableCell).toggleClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS, !isEditableCell);
                                if (alignment)
                                    $cell.find("input").first().css("text-align", alignment)
                            }
                            var firstChild = $cell.get(0).firstChild;
                            if (firstChild && firstChild.className && firstChild.className.indexOf(CHECKBOX_CLASS) >= 0)
                                $cell.addClass(DATAGRID_EDITOR_INLINE_BLOCK).toggleClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS, isCommandCell || !isEditableCell);
                            if (editMode === DATAGRID_EDIT_MODE_BATCH || editMode === DATAGRID_EDIT_MODE_CELL) {
                                var modifiedValues = parameters.row && (parameters.row.inserted ? parameters.row.values : parameters.row.modifiedValues);
                                if (modifiedValues && modifiedValues[columnIndex] !== undefined && parameters.column && !isCommandCell) {
                                    editingController.createHighlightCell($cell);
                                    $cell.addClass(DATAGRID_CELL_MODIFIED)
                                }
                                else if (isEditableCell)
                                    editingController.createHighlightCell($cell, true)
                            }
                            this.callBase.apply(this, arguments)
                        },
                        _update: function(change) {
                            this.callBase(change);
                            if (change.changeType === "updateSelection")
                                this.getTableElements().children("tbody").children("." + DATAGRID_EDIT_ROW).removeClass(DATAGRID_ROW_SELECTED)
                        }
                    },
                    headerPanel: {
                        _renderCore: function() {
                            this.callBase();
                            this.getController("editing").renderEditButtons(this.element())
                        },
                        isVisible: function() {
                            var that = this,
                                editingOptions = that.getController("editing").option("editing");
                            return that.callBase() || editingOptions && (editingOptions.insertEnabled || (editingOptions.editEnabled || editingOptions.removeEnabled) && editingOptions.editMode === DATAGRID_EDIT_MODE_BATCH)
                        }
                    }
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_LINK_CLASS: DATAGRID_LINK_CLASS,
            DATAGRID_EDITOR_CELL_CLASS: DATAGRID_EDITOR_CELL_CLASS,
            DATAGRID_EDIT_ROW: DATAGRID_EDIT_ROW,
            DATAGRID_EDIT_BUTTON_CLASS: DATAGRID_EDIT_BUTTON_CLASS,
            DATAGRID_CELL_MODIFIED: DATAGRID_CELL_MODIFIED,
            DATAGRID_ROW_REMOVED: DATAGRID_ROW_REMOVED,
            DATAGRID_ROW_INSERTED: DATAGRID_ROW_INSERTED,
            DATAGRID_ROW_MODIFIED: DATAGRID_ROW_MODIFIED,
            DATAGRID_CELL_HIGHLIGHT_OUTLINE: DATAGRID_CELL_HIGHLIGHT_OUTLINE,
            DATAGRID_FOCUS_OVERLAY_CLASS: DATAGRID_FOCUS_OVERLAY_CLASS,
            DATAGRID_READONLY_CLASS: DATAGRID_READONLY_CLASS,
            DATAGRID_CELL_FOCUS_DISABLED_CLASS: DATAGRID_CELL_FOCUS_DISABLED_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.validationModule.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            utils = DX.utils;
        var DATAGRID_INVALIDATE_CLASS = "dx-datagrid-invalid",
            DATAGRID_INVALID_MESSAGE_CLASS = "dx-invalid-message",
            DATAGRID_INVALID_MESSAGE_ALWAYS_CLASS = "dx-invalid-message-always",
            DATAGRID_REVERT_BUTTON_CLASS = "dx-revert-button",
            DATAGRID_REVERT_TOOLTIP_CLASS = "dx-datagrid-revert-tooltip",
            DATAGRID_CELL_HIGHLIGHT_OUTLINE = "dx-highlight-outline",
            DATAGRID_INSERT_INDEX = "__DX_INSERT_INDEX__",
            DATAGRID_EDIT_MODE_ROW = "row",
            DATAGRID_EDIT_MODE_BATCH = "batch",
            DATAGRID_EDIT_MODE_CELL = "cell";
        dataGrid.ValidatingController = dataGrid.Controller.inherit(function() {
            return {
                    init: function() {
                        this._editingController = this.getController("editing");
                        this.createAction("onRowValidating")
                    },
                    _rowValidating: function(editData, validate) {
                        var that = this,
                            brokenRules = validate ? validate.brokenRules || validate.brokenRule && [validate.brokenRule] : [],
                            isValid = validate ? validate.isValid : editData.isValid,
                            parameters = {
                                brokenRules: brokenRules,
                                isValid: isValid,
                                key: editData.key,
                                newData: editData.data,
                                oldData: editData.oldData,
                                errorText: null
                            };
                        that.executeAction("onRowValidating", parameters);
                        editData.isValid = parameters.isValid;
                        editData.errorText = parameters.errorText;
                        return parameters
                    },
                    validate: function(isFull) {
                        var that = this,
                            isValid = true,
                            editingController = that._editingController;
                        isFull = isFull || editingController.getEditMode() === DATAGRID_EDIT_MODE_ROW;
                        if (that._isValidationInProgress)
                            return false;
                        that._isValidationInProgress = true;
                        if (isFull)
                            $.each(editingController._editData, function(index, editData) {
                                var validationResult;
                                if (editData.type) {
                                    validationResult = that.validateGroup(editData);
                                    if (!validationResult.isValid)
                                        $.each(validationResult.brokenRules, function() {
                                            var value = this.validator.option("adapter").getValue();
                                            if (value === undefined)
                                                value = null;
                                            editingController.updateFieldValue({
                                                key: editData.key,
                                                column: this.column
                                            }, value, true)
                                        });
                                    isValid = isValid && validationResult.isValid
                                }
                            });
                        else if (that._currentCellValidator)
                            isValid = that.validateGroup(that._currentCellValidator._findGroup()).isValid;
                        that._isValidationInProgress = false;
                        return isValid
                    },
                    validateGroup: function(editData) {
                        var that = this,
                            validateGroup = DX.validationEngine.getGroupConfig(editData),
                            validationResults;
                        if (validateGroup && validateGroup.validators.length)
                            validationResults = DX.validationEngine.validateGroup(editData);
                        return that._rowValidating(editData, validationResults)
                    },
                    updateEditData: function(editData) {
                        this.setDisableApplyValidationResults(true);
                        editData.isValid = DX.validationEngine.getGroupConfig(editData) ? DX.validationEngine.validateGroup(editData).isValid : true;
                        this.setDisableApplyValidationResults(false)
                    },
                    setValidator: function(validator) {
                        this._currentCellValidator = validator
                    },
                    getValidator: function() {
                        return this._currentCellValidator
                    },
                    removeValidators: function(editIndex) {
                        var that = this,
                            editingController = that._editingController;
                        $.each(editingController._editData, function(index, editData) {
                            var validateGroup = DX.validationEngine.getGroupConfig(editData);
                            if (!utils.isDefined(editIndex) || editIndex === index)
                                if (validateGroup)
                                    for (var i = 0; i < validateGroup.validators.length; i++) {
                                        validateGroup.validators[i]._dispose();
                                        i--
                                    }
                        })
                    },
                    createValidator: function(parameters, $container) {
                        var that = this,
                            editingController = that._editingController,
                            column = parameters.column,
                            editData,
                            editIndex = editingController.getIndexByKey(parameters.key, editingController._editData),
                            defaultValidationResult = function(options) {
                                if (options.brokenRule) {
                                    options.brokenRule.columnIndex = column.index;
                                    options.brokenRule.column = column
                                }
                                if ($container && !that.getDisableApplyValidationResults()) {
                                    if (!options.isValid) {
                                        var $focus = $container.find(":focus");
                                        editingController.createHighlightCell($container, true);
                                        if (!$focus.is(":focus"))
                                            $focus.focus().trigger("dxpointerdown")
                                    }
                                    $container.toggleClass(DATAGRID_INVALIDATE_CLASS, !options.isValid)
                                }
                            };
                        if (editIndex < 0 && column.showEditorAlways)
                            editIndex = editingController._addEditData({key: parameters.key});
                        if (editIndex >= 0) {
                            editData = editingController._editData[editIndex];
                            return new DX.ui.dxValidator($container || {}, {
                                    name: column.caption,
                                    validationRules: $.extend(true, [], column.validationRules),
                                    validationGroup: editData,
                                    adapter: {
                                        getValue: function() {
                                            var value = column.calculateCellValue(editData.data || {});
                                            return value !== undefined ? value : parameters.value
                                        },
                                        applyValidationResults: defaultValidationResult
                                    }
                                })
                        }
                    },
                    setDisableApplyValidationResults: function(flag) {
                        this._disableApplyValidationResults = flag
                    },
                    getDisableApplyValidationResults: function() {
                        return this._disableApplyValidationResults
                    }
                }
        }());
        dataGrid.registerModule("validating", {
            defaultOptions: function() {
                return {}
            },
            controllers: {validating: dataGrid.ValidatingController},
            extenders: {
                controllers: {
                    editing: {
                        _addEditData: function(options) {
                            var that = this,
                                validatingController = that.getController("validating"),
                                editDataIndex = that.callBase(options),
                                editData;
                            if (editDataIndex >= 0) {
                                editData = that._editData[editDataIndex];
                                validatingController.updateEditData(editData)
                            }
                            return editDataIndex
                        },
                        _updateRowAndPageIndices: function() {
                            var that = this,
                                startInsertIndex = that.getView("rowsView").getTopVisibleItemIndex(),
                                rowIndex = startInsertIndex;
                            $.each(that._editData, function(_, editData) {
                                if (!editData.isValid && editData.pageIndex !== that._pageIndex) {
                                    editData.pageIndex = that._pageIndex;
                                    if (editData.type === "insert")
                                        editData.rowIndex = startInsertIndex;
                                    else
                                        editData.rowIndex = rowIndex;
                                    rowIndex++
                                }
                            })
                        },
                        processItems: function(items, changeType) {
                            var that = this,
                                dataController = that.getController("data"),
                                i,
                                editData = that._editData,
                                itemsCount = items.length,
                                insertCount = 0,
                                getIndexByEditData = function(editData, items) {
                                    var index = -1,
                                        isInsert = editData.type === "insert",
                                        key = editData.key;
                                    $.each(items, function(i, item) {
                                        if (dataGrid.equalKeys(key, isInsert ? item : dataController.keyOf(item))) {
                                            index = i;
                                            return false
                                        }
                                    });
                                    return index
                                },
                                addInValidItem = function(editData) {
                                    var data = {key: editData.key},
                                        index = getIndexByEditData(editData, items),
                                        rowIndex;
                                    if (index >= 0 && that.option("scrolling.mode") === "standard")
                                        return;
                                    editData.rowIndex = editData.rowIndex > itemsCount ? editData.rowIndex % itemsCount : editData.rowIndex;
                                    rowIndex = editData.rowIndex;
                                    data[DATAGRID_INSERT_INDEX] = 1;
                                    if (index >= 0) {
                                        items.splice(index, 1);
                                        rowIndex -= insertCount
                                    }
                                    items.splice(rowIndex, 0, data);
                                    insertCount++
                                };
                            that.update();
                            if (that.getEditMode() === DATAGRID_EDIT_MODE_BATCH && changeType !== "prepend" && changeType !== "append")
                                for (i = 0; i < editData.length; i++)
                                    if (editData[i].type && editData[i].pageIndex === that._pageIndex && editData[i].key.pageIndex !== that._pageIndex)
                                        addInValidItem(editData[i]);
                            return that.callBase(items, changeType)
                        },
                        processDataItem: function(item, columns, generateDataValues) {
                            var that = this,
                                editIndex,
                                editData,
                                isInserted = item.data[DATAGRID_INSERT_INDEX],
                                key = isInserted ? item.data.key : item.key,
                                editMode = that.getEditMode();
                            if (editMode === DATAGRID_EDIT_MODE_BATCH && isInserted && key) {
                                editIndex = dataGrid.getIndexByKey(key, that._editData);
                                if (editIndex >= 0) {
                                    editData = that._editData[editIndex];
                                    if (editData.type !== "insert") {
                                        item.data = $.extend(true, {}, editData.oldData, editData.data);
                                        item.key = key
                                    }
                                }
                            }
                            that.callBase.apply(that, arguments)
                        },
                        _afterInsertRow: function(options) {
                            var validatingController = this.getController("validating"),
                                hiddenColumns = this.getController("columns").getHiddenColumns();
                            $.each(hiddenColumns, function(_, column) {
                                if (utils.isArray(column.validationRules))
                                    validatingController.createValidator({
                                        column: column,
                                        key: options.key,
                                        value: options.data[column.dataField]
                                    })
                            });
                            this.callBase(options)
                        },
                        _beforeSaveEditData: function(editData, editIndex) {
                            var that = this,
                                isValid,
                                isFullValid,
                                result = that.callBase.apply(that, arguments),
                                validatingController = that.getController("validating");
                            if (editData) {
                                isValid = editData.type === "remove" || editData.isValid;
                                if (isValid)
                                    validatingController.removeValidators(editIndex);
                                result = result || !isValid
                            }
                            else {
                                isFullValid = validatingController.validate(true);
                                that._updateRowAndPageIndices();
                                if (that.getEditMode() === DATAGRID_EDIT_MODE_CELL) {
                                    if (!isFullValid) {
                                        that._focusEditingCell();
                                        result = true
                                    }
                                }
                                else if (that.getEditMode() === DATAGRID_EDIT_MODE_ROW)
                                    result = !isFullValid
                            }
                            return result
                        },
                        _beforeEditCell: function(rowIndex, columnIndex, item) {
                            var result = this.callBase(rowIndex, columnIndex, item),
                                $cell = this.component.getCellElement(rowIndex, columnIndex),
                                validator = $cell.data("dxValidator");
                            if (this.getEditMode(this) === DATAGRID_EDIT_MODE_CELL && (!validator || validator.validate().isValid))
                                return result
                        },
                        _afterSaveEditData: function() {
                            var that = this;
                            $.each(that._editData, function(_, editData) {
                                that._showErrorRow(editData)
                            })
                        },
                        _beforeCancelEditData: function() {
                            var validatingController = this.getController("validating");
                            validatingController.removeValidators();
                            this.callBase()
                        },
                        _showErrorRow: function(editData) {
                            var errorHandling = this.getController("errorHandling"),
                                items = this.getController("data").items(),
                                rowIndex = this.getIndexByKey(editData.key, items);
                            if (!editData.isValid && editData.errorText && rowIndex >= 0)
                                errorHandling && errorHandling.renderErrorRow(editData.errorText, rowIndex)
                        },
                        updateFieldValue: function(options, value) {
                            var that = this;
                            that.callBase.apply(that, arguments);
                            if (that.getEditMode() === DATAGRID_EDIT_MODE_ROW) {
                                var currentValidator = that.getController("validating").getValidator();
                                currentValidator && currentValidator.validate()
                            }
                        },
                        createHighlightCell: function($cell, skipValidation) {
                            var isValid = true,
                                validator;
                            if (!skipValidation) {
                                validator = $cell.data("dxValidator");
                                if (validator)
                                    isValid = validator.validate().isValid
                            }
                            if (isValid)
                                this.callBase($cell)
                        }
                    },
                    editorFactory: {
                        _showRevertButton: function($cell) {
                            var that = this,
                                $targetElement = $cell.find("." + DATAGRID_CELL_HIGHLIGHT_OUTLINE).first();
                            $("<div>").addClass(DATAGRID_REVERT_TOOLTIP_CLASS).appendTo($cell).dxTooltip({
                                animation: null,
                                visible: true,
                                target: $targetElement,
                                closeOnOutsideClick: false,
                                closeOnTargetScroll: false,
                                boundary: that._rowsView.element(),
                                contentTemplate: function() {
                                    return $("<div>").addClass(DATAGRID_REVERT_BUTTON_CLASS).dxButton({
                                            icon: "revert",
                                            onClick: function() {
                                                that._editingController.cancelEditData()
                                            }
                                        })
                                },
                                position: {
                                    my: "left top",
                                    at: "right top",
                                    of: $targetElement,
                                    offset: "1 0",
                                    collision: "flip"
                                }
                            })
                        },
                        _showValidationMessage: function($cell, message, alignment) {
                            var that = this;
                            $("<div/>").addClass(DATAGRID_INVALID_MESSAGE_CLASS).addClass(DATAGRID_INVALID_MESSAGE_ALWAYS_CLASS).text(message).appendTo($cell).dxTooltip({
                                target: $cell,
                                container: $cell,
                                visible: true,
                                closeOnOutsideClick: false,
                                closeOnTargetScroll: false,
                                position: {
                                    collision: "fit flip",
                                    boundary: that._rowsView.element(),
                                    boundaryOffset: "0 0",
                                    offset: "1 -10",
                                    my: "top " + alignment,
                                    at: "bottom " + alignment
                                },
                                onPositioned: function() {
                                    that._rowsView.element() && that._rowsView.updateFreeSpaceRowHeight()
                                }
                            })
                        },
                        init: function() {
                            this.callBase();
                            this._editingController = this.getController("editing");
                            this._rowsView = this.getView("rowsView")
                        },
                        loseFocus: function(skipValidator) {
                            if (!skipValidator)
                                this.getController("validating").setValidator(null);
                            this.callBase()
                        },
                        focus: function($element, hideBorder) {
                            var that = this,
                                $cell = $element && $element.closest("td"),
                                validator = $cell && $cell.data("dxValidator"),
                                validationResult,
                                $tooltips = $cell && $cell.closest(".dx-datagrid-rowsview").find(".dx-tooltip"),
                                column = $cell && that.getController("columns").getVisibleColumns()[$cell.index()];
                            $tooltips && $tooltips.remove();
                            if (validator && column) {
                                that.getController("validating").setValidator(validator);
                                if (validator.option("adapter").getValue() !== undefined) {
                                    validationResult = validator.validate();
                                    if (!validationResult.isValid) {
                                        hideBorder = true;
                                        that._showValidationMessage($cell, validationResult.brokenRule.message, column.alignment);
                                        if (that._editingController.getEditMode() === DATAGRID_EDIT_MODE_CELL)
                                            that._showRevertButton($cell)
                                    }
                                }
                            }
                            !hideBorder && that._rowsView.element() && that._rowsView.updateFreeSpaceRowHeight();
                            return that.callBase($element, hideBorder)
                        }
                    }
                },
                views: {rowsView: {
                        updateFreeSpaceRowHeight: function() {
                            var that = this,
                                $rowElements = that._getRowElements(),
                                $freeSpaceRowElements = that._getFreeSpaceRowElements(),
                                $freeSpaceRowElement = $freeSpaceRowElements.first(),
                                $tooltipContent = that.element().find(".dx-invalid-message .dx-overlay-content");
                            that.callBase();
                            if ($tooltipContent.length && $freeSpaceRowElement && $rowElements.length === 1 && (!$freeSpaceRowElement.is(":visible") || $tooltipContent.outerHeight() > $freeSpaceRowElement.outerHeight())) {
                                $freeSpaceRowElements.show();
                                $freeSpaceRowElements.height($tooltipContent.outerHeight())
                            }
                        },
                        _cellPrepared: function($cell, parameters) {
                            var validatingController = this.getController("validating"),
                                column = parameters.column;
                            if (utils.isArray(column.validationRules))
                                validatingController.createValidator(parameters, $cell);
                            this.callBase.apply(this, arguments)
                        }
                    }}
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_REVERT_TOOLTIP_CLASS: DATAGRID_REVERT_TOOLTIP_CLASS,
            DATAGRID_REVERT_BUTTON_CLASS: DATAGRID_REVERT_BUTTON_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.dataController.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            utils = DX.utils;
        dataGrid.proxyMethod = function(instance, methodName, defaultResult) {
            if (!instance[methodName])
                instance[methodName] = function() {
                    var dataSource = this._dataSource;
                    return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult
                }
        };
        dataGrid.combineFilters = function(filters, operation) {
            var resultFilter = [],
                i;
            operation = operation || "and";
            for (i = 0; i < filters.length; i++) {
                if (!filters[i])
                    continue;
                if (resultFilter.length)
                    resultFilter.push(operation);
                resultFilter.push(filters[i])
            }
            if (resultFilter.length === 1)
                resultFilter = resultFilter[0];
            if (resultFilter.length)
                return resultFilter
        };
        dataGrid.DataController = dataGrid.Controller.inherit({}).include(ui.DataHelperMixin).inherit(function() {
            var members = {
                    init: function() {
                        var that = this;
                        that._items = [];
                        that._columnsController = that.getController("columns");
                        that._columnsChangedHandler = $.proxy(that._handleColumnsChanged, that);
                        that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
                        that._loadingChangedHandler = $.proxy(that._handleLoadingChanged, that);
                        that._loadErrorHandler = $.proxy(that._handleLoadError, that);
                        that._customizeStoreLoadOptionsHandler = $.proxy(that._handleCustomizeStoreLoadOptions, that);
                        that._columnsController.columnsChanged.add(that._columnsChangedHandler);
                        that._isLoading = false;
                        that._isCustomLoading = false;
                        that._refreshDataSource();
                        that.createAction("onDataErrorOccurred");
                        that.dataErrorOccurred.add(function(error) {
                            return that.executeAction("onDataErrorOccurred", {error: error})
                        })
                    },
                    callbackNames: function() {
                        return ["changed", "loadingChanged", "dataErrorOccurred", "pageChanged", "dataSourceChanged"]
                    },
                    callbackFlags: function(name) {
                        if (name === "dataErrorOccurred")
                            return "stopOnFalse"
                    },
                    publicMethods: function() {
                        return ["beginCustomLoading", "endCustomLoading", "refresh", "filter", "clearFilter", "getCombinedFilter", "keyOf", "byKey", "getDataByKeys", "pageIndex", "pageSize", "pageCount", "totalCount", "_disposeDataSource", "getKeyByRowIndex", "getRowIndexByKey"]
                    },
                    optionChanged: function(args) {
                        var that = this;
                        function handled() {
                            args.handled = true
                        }
                        function reload() {
                            that._columnsController.reset();
                            that._refreshDataSource()
                        }
                        if (args.name === "dataSource" && args.name === args.fullName && args.value === args.previousValue) {
                            handled();
                            that.refresh();
                            return
                        }
                        switch (args.name) {
                            case"loadingTimeout":
                            case"remoteOperations":
                                handled();
                                break;
                            case"dataSource":
                            case"scrolling":
                            case"paging":
                                handled();
                                reload();
                                break;
                            case"rtlEnabled":
                                reload();
                                break;
                            default:
                                that.callBase(args)
                        }
                    },
                    isReady: function() {
                        return !this._isLoading
                    },
                    getCombinedFilter: function() {
                        return this.combinedFilter()
                    },
                    combinedFilter: function(filter) {
                        var that = this,
                            dataSource = that._dataSource,
                            columnsController = that._columnsController,
                            additionalFilter;
                        if (dataSource) {
                            if (filter === undefined)
                                filter = dataSource.filter();
                            additionalFilter = that._calculateAdditionalFilter();
                            if (additionalFilter)
                                if (columnsController.isDataSourceApplied() || columnsController.isAllDataTypesDefined())
                                    filter = dataGrid.combineFilters([additionalFilter, filter]);
                            if (!dataSource.remoteOperations().filtering)
                                columnsController.updateFilter(filter)
                        }
                        return filter
                    },
                    _handleCustomizeStoreLoadOptions: function(e) {
                        var columnsController = this._columnsController,
                            dataSource = this._dataSource,
                            storeLoadOptions = e.storeLoadOptions;
                        if (this._isLoadingAll) {
                            storeLoadOptions.isLoadingAll = true;
                            delete storeLoadOptions.skip;
                            delete storeLoadOptions.take
                        }
                        storeLoadOptions.filter = this.combinedFilter(storeLoadOptions.filter);
                        if (!columnsController.isDataSourceApplied())
                            columnsController.updateColumnDataTypes(dataSource);
                        this._columnsUpdating = true;
                        columnsController.updateSortingGrouping(dataSource, !this._isFirstLoading);
                        this._columnsUpdating = false;
                        storeLoadOptions.sort = columnsController.getSortDataSourceParameters();
                        storeLoadOptions.group = columnsController.getGroupDataSourceParameters();
                        dataSource.sort(storeLoadOptions.sort);
                        dataSource.group(storeLoadOptions.group);
                        storeLoadOptions.sort = columnsController.getSortDataSourceParameters(!dataSource.remoteOperations().sorting);
                        e.group = columnsController.getGroupDataSourceParameters(true);
                        this._isFirstLoading = false
                    },
                    _handleColumnsChanged: function(e) {
                        var that = this,
                            changeTypes = e.changeTypes,
                            optionNames = e.optionNames,
                            filterValue,
                            filterValues;
                        var updateItemsHandler = function() {
                                that._columnsController.columnsChanged.remove(updateItemsHandler);
                                that.updateItems()
                            };
                        if (changeTypes.sorting || changeTypes.grouping) {
                            if (that._dataSource && !that._columnsUpdating) {
                                that._dataSource.group(that._columnsController.getGroupDataSourceParameters());
                                that._dataSource.sort(that._columnsController.getSortDataSourceParameters());
                                that.reload()
                            }
                            that.pageChanged.fire()
                        }
                        else if (changeTypes.columns) {
                            if (optionNames.filterValues || optionNames.filterValue || optionNames.selectedFilterOperation)
                                if (this.option("filterRow.applyFilter") !== "onClick" || optionNames.filterValues) {
                                    filterValue = that._columnsController.columnOption(e.columnIndex, "filterValue");
                                    filterValues = that._columnsController.columnOption(e.columnIndex, "filterValues");
                                    if (utils.isArray(filterValues) || e.columnIndex === undefined || utils.isDefined(filterValue) || !optionNames.selectedFilterOperation || optionNames.filterValue)
                                        that._applyFilter()
                                }
                            if (!that._needApplyFilter && !dataGrid.checkChanges(optionNames, ["width", "visibleWidth", "filterValue", "selectedFilterOperation", "filterValues"]))
                                that._columnsController.columnsChanged.add(updateItemsHandler)
                        }
                    },
                    _handleDataChanged: function(e) {
                        var that = this,
                            dataSource = that._dataSource,
                            columnsController = that._columnsController,
                            isAllDataTypesDefined = columnsController.isAllDataTypesDefined();
                        if (dataSource && !that._isDataSourceApplying && !that._isLoadingAll) {
                            that._isDataSourceApplying = true;
                            $.when(that._columnsController.applyDataSource(dataSource)).done(function() {
                                if (that._isLoading)
                                    that._handleLoadingChanged(false);
                                that._isDataSourceApplying = false;
                                var additionalFilter = that._calculateAdditionalFilter(),
                                    needApplyFilter = that._needApplyFilter;
                                that._needApplyFilter = false;
                                if (needApplyFilter && additionalFilter && additionalFilter.length && !isAllDataTypesDefined) {
                                    DX.log("W1005", that.component.NAME);
                                    that._applyFilter()
                                }
                                else
                                    that.updateItems(e)
                            });
                            if (that._isDataSourceApplying)
                                that._handleLoadingChanged(true);
                            that._needApplyFilter = !that._columnsController.isDataSourceApplied()
                        }
                    },
                    _handleLoadingChanged: function(isLoading) {
                        this._isLoading = isLoading;
                        this._fireLoadingChanged()
                    },
                    _handleLoadError: function(e) {
                        this.dataErrorOccurred.fire(e)
                    },
                    _initDataSource: function() {
                        var that = this,
                            dataSource = this.option("dataSource"),
                            pageIndex = this.option("paging.pageIndex"),
                            pageSize = this.option("paging.pageSize"),
                            scrollingMode = that.option("scrolling.mode"),
                            pagingEnabled = this.option("paging.enabled"),
                            appendMode = scrollingMode === "infinite",
                            virtualMode = scrollingMode === "virtual",
                            oldDataSource = this._dataSource;
                        that.callBase();
                        dataSource = that._dataSource;
                        that._isFirstLoading = true;
                        if (dataSource) {
                            dataSource.requireTotalCount(!appendMode);
                            if (pagingEnabled !== undefined)
                                dataSource.paginate(pagingEnabled || virtualMode || appendMode);
                            if (pageSize !== undefined)
                                dataSource.pageSize(pageSize);
                            if (pageIndex !== undefined)
                                dataSource.pageIndex(pageIndex);
                            that._dataSource = oldDataSource;
                            that.setDataSource(dataSource)
                        }
                        else if (oldDataSource)
                            that.updateItems()
                    },
                    _loadDataSource: function() {
                        var dataSource = this._dataSource;
                        dataSource && dataSource.load()
                    },
                    _processItems: function(items) {
                        var that = this,
                            visibleColumns = that._columnsController.getVisibleColumns(),
                            options = {
                                visibleColumns: visibleColumns,
                                dataIndex: 0
                            },
                            result = [];
                        $.each(items, function(index, item) {
                            if (utils.isDefined(item)) {
                                item = that._processItem(item, options);
                                result.push(item)
                            }
                        });
                        return result
                    },
                    _processItem: function(item, options) {
                        item = this._generateDataItem(item);
                        item = this._processDataItem(item, options);
                        item.dataIndex = options.dataIndex++;
                        return item
                    },
                    _generateDataItem: function(data) {
                        return {
                                rowType: "data",
                                data: data,
                                key: this.keyOf(data)
                            }
                    },
                    _processDataItem: function(dataItem, options) {
                        dataItem.values = this._generateDataValues(dataItem.data, options.visibleColumns);
                        return dataItem
                    },
                    _generateDataValues: function(data, columns) {
                        var values = [];
                        $.each(columns, function() {
                            var value = null;
                            if (this.command)
                                value = null;
                            else if (this.calculateCellValue)
                                value = this.calculateCellValue(data);
                            else if (this.dataField)
                                value = data[this.dataField];
                            values.push(value)
                        });
                        return values
                    },
                    _updateItemsCore: function(change) {
                        var that = this,
                            items,
                            dataSource = that._dataSource,
                            changeType = change.changeType || "refresh";
                        change.changeType = changeType;
                        if (dataSource) {
                            items = change.items || dataSource.items();
                            items = that._processItems(items.slice(0), changeType);
                            change.items = items;
                            switch (changeType) {
                                case"prepend":
                                    that._items.unshift.apply(that._items, items);
                                    break;
                                case"append":
                                    that._items.push.apply(that._items, items);
                                    break;
                                case"update":
                                    var prevIndex = -1,
                                        rowIndices = change.rowIndices.slice(0),
                                        rowIndexCorrection = 0;
                                    rowIndices.sort(function(a, b) {
                                        return a - b
                                    });
                                    for (var i = 0; i < rowIndices.length; i++)
                                        if (rowIndices[i] < 0) {
                                            rowIndices.splice(i, 1);
                                            i--
                                        }
                                    change.items = [];
                                    change.rowIndices = [];
                                    change.changeTypes = [];
                                    var equalItems = function(item1, item2) {
                                            return dataGrid.equalKeys(item1.key, item2.key) && item1.rowType === item2.rowType
                                        };
                                    $.each(rowIndices, function(index, rowIndex) {
                                        var oldItem,
                                            newItem,
                                            oldNextItem,
                                            newNextItem;
                                        rowIndex += rowIndexCorrection;
                                        if (prevIndex === rowIndex)
                                            return;
                                        change.rowIndices.push(rowIndex);
                                        prevIndex = rowIndex;
                                        oldItem = that._items[rowIndex];
                                        oldNextItem = that._items[rowIndex + 1];
                                        newItem = items[rowIndex];
                                        newNextItem = items[rowIndex + 1];
                                        if (newItem)
                                            change.items.push(newItem);
                                        if (oldItem && newItem && equalItems(oldItem, newItem)) {
                                            changeType = "update";
                                            that._items[rowIndex] = newItem;
                                            if (oldItem.visible !== newItem.visible)
                                                change.items.splice(-1, 1, {visible: newItem.visible})
                                        }
                                        else if (newItem && !oldItem || newNextItem && equalItems(oldItem, newNextItem)) {
                                            changeType = "insert";
                                            that._items.splice(rowIndex, 0, newItem);
                                            rowIndexCorrection++
                                        }
                                        else if (oldItem && !newItem || oldNextItem && equalItems(newItem, oldNextItem)) {
                                            changeType = "remove";
                                            that._items.splice(rowIndex, 1);
                                            rowIndexCorrection--;
                                            prevIndex = -1
                                        }
                                        change.changeTypes.push(changeType)
                                    });
                                    break;
                                default:
                                    that._items = items.slice(0);
                                    break
                            }
                            $.each(that._items, function(index, item) {
                                item.rowIndex = index
                            })
                        }
                        else
                            that._items = []
                    },
                    updateItems: function(change) {
                        change = change || {};
                        this._updateItemsCore(change);
                        this.changed.fire(change)
                    },
                    isLoading: function() {
                        return this._isLoading || this._isCustomLoading
                    },
                    _fireLoadingChanged: function(messageText) {
                        this.loadingChanged.fire(this.isLoading(), messageText)
                    },
                    _calculateAdditionalFilter: function() {
                        return null
                    },
                    _applyFilter: function() {
                        var that = this,
                            dataSource = that._dataSource;
                        if (dataSource) {
                            dataSource.pageIndex(0);
                            return that.reload().done($.proxy(that.pageChanged, "fire"))
                        }
                    },
                    filter: function(filterExpr) {
                        var dataSource = this._dataSource;
                        if (arguments.length === 0)
                            return dataSource ? dataSource.filter() : undefined;
                        filterExpr = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0) : filterExpr;
                        if (dataSource)
                            dataSource.filter(filterExpr);
                        this._applyFilter()
                    },
                    clearFilter: function(filterName) {
                        var that = this,
                            columnsController = that._columnsController,
                            clearColumnOption = function(optionName) {
                                var columnCount = columnsController.columnCount(),
                                    index;
                                for (index = 0; index < columnCount; index++)
                                    columnsController.columnOption(index, optionName, undefined)
                            };
                        that.component.beginUpdate();
                        if (arguments.length > 0)
                            switch (filterName) {
                                case"dataSource":
                                    that.filter(null);
                                    break;
                                case"search":
                                    that.searchByText("");
                                    break;
                                case"header":
                                    clearColumnOption("filterValues");
                                    break;
                                case"row":
                                    clearColumnOption("filterValue");
                                    break
                            }
                        else {
                            that.filter(null);
                            that.searchByText("");
                            clearColumnOption("filterValue");
                            clearColumnOption("filterValues")
                        }
                        that.component.endUpdate()
                    },
                    _fireDataSourceChanged: function() {
                        var that = this;
                        var changedHandler = function() {
                                that.changed.remove(changedHandler);
                                that.dataSourceChanged.fire()
                            };
                        that.changed.add(changedHandler)
                    },
                    _getDataSourceAdapterType: function(remoteOperations) {
                        return remoteOperations && remoteOperations.filtering && remoteOperations.sorting && remoteOperations.paging ? dataGrid.DataSourceAdapterServer : dataGrid.DataSourceAdapterClient
                    },
                    _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
                        var dataSourceAdapterType,
                            dataSourceAdapter;
                        if (remoteOperations === "auto")
                            remoteOperations = !(dataSource.store() instanceof DX.data.ArrayStore);
                        if (remoteOperations === true)
                            remoteOperations = {
                                filtering: true,
                                sorting: true,
                                paging: true
                            };
                        dataSourceAdapterType = this._getDataSourceAdapterType(remoteOperations);
                        dataSourceAdapter = new dataSourceAdapterType(this.component);
                        dataSourceAdapter.init(dataSource, remoteOperations);
                        return dataSourceAdapter
                    },
                    _createDataSourceAdapter: function(dataSource) {
                        var remoteOperations = this.option("remoteOperations");
                        return this._createDataSourceAdapterCore(dataSource, remoteOperations)
                    },
                    setDataSource: function(dataSource) {
                        var that = this,
                            oldDataSource = that._dataSource;
                        if (oldDataSource) {
                            oldDataSource.changed.remove(that._dataChangedHandler);
                            oldDataSource.loadingChanged.remove(that._loadingChangedHandler);
                            oldDataSource.loadError.remove(that._loadErrorHandler);
                            oldDataSource.customizeStoreLoadOptions.remove(that._customizeStoreLoadOptionsHandler);
                            oldDataSource.dispose(that._isSharedDataSource)
                        }
                        if (dataSource)
                            dataSource = that._createDataSourceAdapter(dataSource);
                        that._dataSource = dataSource;
                        if (dataSource) {
                            that._fireDataSourceChanged();
                            that._isLoading = !dataSource.isLoaded();
                            that._needApplyFilter = true;
                            dataSource.changed.add(that._dataChangedHandler);
                            dataSource.loadingChanged.add(that._loadingChangedHandler);
                            dataSource.loadError.add(that._loadErrorHandler);
                            dataSource.customizeStoreLoadOptions.add(that._customizeStoreLoadOptionsHandler)
                        }
                    },
                    items: function() {
                        return this._items
                    },
                    isEmpty: function() {
                        return !this.items().length
                    },
                    pageCount: function() {
                        return this._dataSource ? this._dataSource.pageCount() : 1
                    },
                    dataSource: function() {
                        return this._dataSource
                    },
                    store: function() {
                        var dataSource = this._dataSource;
                        return dataSource && dataSource.store()
                    },
                    loadAll: function(data) {
                        var that = this,
                            d = $.Deferred(),
                            dataSource = that._dataSource;
                        if (dataSource)
                            if (data) {
                                var options = {
                                        data: data,
                                        loadOptions: {
                                            isLoadingAll: true,
                                            group: dataSource.group(),
                                            sort: dataSource.sort()
                                        }
                                    };
                                dataSource._handleDataLoaded(options);
                                d.resolve(that._processItems(options.data), options.totalAggregates)
                            }
                            else if (!that.isLoading()) {
                                that._isLoadingAll = true;
                                dataSource.load(true).done(function(items) {
                                    items = that._processItems(items.slice(0));
                                    d.resolve(items)
                                }).fail(d.reject).always(function() {
                                    that._isLoadingAll = false
                                })
                            }
                            else
                                d.reject();
                        else
                            d.resolve([]);
                        return d
                    },
                    getKeyByRowIndex: function(rowIndex) {
                        var item = this.items()[rowIndex];
                        if (item)
                            return item.key
                    },
                    getRowIndexByKey: function(key) {
                        return dataGrid.getIndexByKey(key, this.items())
                    },
                    keyOf: function(data) {
                        var store = this.store();
                        if (store)
                            return store.keyOf(data)
                    },
                    byKey: function(key) {
                        var store = this.store(),
                            rowIndex = this.getRowIndexByKey(key),
                            result;
                        if (!store)
                            return;
                        if (rowIndex >= 0)
                            result = $.Deferred().resolve(this.items()[rowIndex].data);
                        return result || store.byKey(key)
                    },
                    getDataByKeys: function(rowKeys) {
                        var that = this,
                            result = $.Deferred(),
                            deferreds = [],
                            data = [];
                        $.each(rowKeys, function(index, key) {
                            deferreds.push(that.byKey(key).done(function(keyData) {
                                data[index] = keyData
                            }))
                        });
                        $.when.apply($, deferreds).always(function() {
                            result.resolve(data)
                        });
                        return result
                    },
                    pageIndex: function(value) {
                        var that = this,
                            dataSource = that._dataSource;
                        if (dataSource) {
                            if (value !== undefined)
                                if (dataSource.pageIndex() !== value) {
                                    dataSource.pageIndex(value);
                                    return dataSource.load().done($.proxy(that.pageChanged, "fire"))
                                }
                            return dataSource.pageIndex()
                        }
                        return 0
                    },
                    pageSize: function(value) {
                        var that = this,
                            pagingOptions = that.option("paging"),
                            dataSource = that._dataSource;
                        if (value === undefined)
                            return dataSource ? dataSource.pageSize() : 0;
                        if (dataSource)
                            if (dataSource.pageSize() !== value) {
                                dataSource.pageIndex(0);
                                dataSource.pageSize(value);
                                if (pagingOptions)
                                    pagingOptions.pageSize = value;
                                return dataSource.reload().done($.proxy(that.pageChanged, "fire"))
                            }
                    },
                    beginCustomLoading: function(messageText) {
                        this._isCustomLoading = true;
                        this._fireLoadingChanged(messageText)
                    },
                    endCustomLoading: function() {
                        this._isCustomLoading = false;
                        this._fireLoadingChanged()
                    },
                    refresh: function() {
                        var that = this,
                            d = $.Deferred();
                        $.when(this._columnsController.refresh()).always(function() {
                            $.when(that.reload()).done(d.resolve).fail(d.reject)
                        });
                        return d
                    },
                    _disposeDataSource: function() {
                        this.setDataSource(null)
                    }
                };
            dataGrid.proxyMethod(members, "load");
            dataGrid.proxyMethod(members, "reload");
            dataGrid.proxyMethod(members, "itemsCount", 0);
            dataGrid.proxyMethod(members, "totalItemsCount", 0);
            dataGrid.proxyMethod(members, "hasKnownLastPage", true);
            dataGrid.proxyMethod(members, "isLoaded", false);
            dataGrid.proxyMethod(members, "totalCount", 0);
            return members
        }());
        dataGrid.registerModule("data", {
            defaultOptions: function() {
                return {
                        loadingTimeout: 0,
                        dataSource: null,
                        onDataErrorOccurred: null,
                        remoteOperations: "auto",
                        paging: {
                            enabled: true,
                            pageSize: undefined,
                            pageIndex: undefined
                        }
                    }
            },
            controllers: {data: ui.dxDataGrid.DataController}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.dataSourceAdapter.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid;
        dataGrid.DataSourceAdapterServer = dataGrid.Controller.inherit(function() {
            return {
                    init: function(dataSource, remoteOperations) {
                        var that = this;
                        that._dataSource = dataSource;
                        that._remoteOperations = remoteOperations || {};
                        that._isLastPage = !dataSource.isLastPage();
                        that._hasLastPage = false;
                        that._currentTotalCount = 0;
                        that.changed = $.Callbacks();
                        that.loadingChanged = $.Callbacks();
                        that.loadError = $.Callbacks();
                        that.customizeStoreLoadOptions = $.Callbacks();
                        that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
                        that._dataLoadingHandler = $.proxy(that._handleDataLoading, that);
                        that._dataLoadedHandler = $.proxy(that._handleDataLoaded, that);
                        that._loadingChangedHandler = $.proxy(that._handleLoadingChanged, that);
                        that._loadErrorHandler = $.proxy(that._handleLoadError, that);
                        dataSource.on("changed", that._dataChangedHandler);
                        dataSource.on("customizeStoreLoadOptions", that._dataLoadingHandler);
                        dataSource.on("customizeLoadResult", that._dataLoadedHandler);
                        dataSource.on("loadingChanged", that._loadingChangedHandler);
                        dataSource.on("loadError", that._loadErrorHandler);
                        $.each(dataSource, function(memberName, member) {
                            if (!that[memberName] && $.isFunction(member))
                                that[memberName] = function() {
                                    return this._dataSource[memberName].apply(this._dataSource, arguments)
                                }
                        })
                    },
                    remoteOperations: function() {
                        return this._remoteOperations
                    },
                    dispose: function(isSharedDataSource) {
                        var that = this,
                            dataSource = that._dataSource;
                        dataSource.off("changed", that._dataChangedHandler);
                        dataSource.off("customizeStoreLoadOptions", that._dataLoadingHandler);
                        dataSource.off("customizeLoadResult", that._dataLoadedHandler);
                        dataSource.off("loadingChanged", that._loadingChangedHandler);
                        dataSource.off("loadError", that._loadErrorHandler);
                        if (!isSharedDataSource)
                            dataSource.dispose()
                    },
                    refresh: function(storeLoadOptions, isReload) {
                        var that = this,
                            dataSource = that._dataSource;
                        if (isReload) {
                            that._currentTotalCount = 0;
                            that._isLastPage = !dataSource.paginate();
                            that._hasLastPage = that._isLastPage
                        }
                    },
                    _handleDataLoading: function(options) {
                        var that = this;
                        that.customizeStoreLoadOptions.fire(options);
                        options.delay = this.option("loadingTimeout");
                        options.originalStoreLoadOptions = options.storeLoadOptions;
                        var isReload = !that.isLoaded() && !that._isRefreshing;
                        that._isRefreshing = true;
                        $.when(that.refresh(options.storeLoadOptions, isReload)).always(function() {
                            if (that._lastOperationId === options.operationId)
                                that.load();
                            that._isRefreshing = false
                        });
                        that._dataSource.cancel(that._lastOperationId);
                        that._lastOperationId = options.operationId;
                        if (that._isRefreshing)
                            that._dataSource.cancel(that._lastOperationId)
                    },
                    _handleDataLoaded: function(options) {
                        options.storeLoadOptions = options.originalStoreLoadOptions
                    },
                    _handleLoadingChanged: function(isLoading) {
                        this.loadingChanged.fire(isLoading)
                    },
                    _handleLoadError: function(error) {
                        this.changed.fire({
                            changeType: "loadError",
                            error: error
                        });
                        this.loadError.fire(error)
                    },
                    _handleDataChanged: function(args) {
                        var that = this,
                            currentTotalCount,
                            dataSource = that._dataSource,
                            itemsCount = that.itemsCount();
                        that._isLastPage = !itemsCount || !that.pageSize() || itemsCount < that.pageSize();
                        if (that._isLastPage)
                            that._hasLastPage = true;
                        if (dataSource.totalCount() >= 0) {
                            if (dataSource.pageIndex() >= that.pageCount()) {
                                dataSource.pageIndex(that.pageCount() - 1);
                                dataSource.load()
                            }
                        }
                        else {
                            currentTotalCount = dataSource.pageIndex() * that.pageSize() + itemsCount;
                            that._currentTotalCount = Math.max(that._currentTotalCount, currentTotalCount);
                            if (itemsCount === 0 && dataSource.pageIndex() >= that.pageCount()) {
                                dataSource.pageIndex(that.pageCount() - 1);
                                dataSource.load()
                            }
                        }
                        if (!dataSource.isLoading())
                            this.changed.fire(args)
                    },
                    isLastPage: function() {
                        return this._isLastPage
                    },
                    totalCount: function() {
                        return parseInt(this._currentTotalCount || this._dataSource.totalCount())
                    },
                    itemsCount: function() {
                        return this._dataSource.items().length
                    },
                    totalItemsCount: function() {
                        return this.totalCount()
                    },
                    pageSize: function() {
                        var dataSource = this._dataSource;
                        if (!arguments.length && !dataSource.paginate())
                            return 0;
                        return dataSource.pageSize.apply(dataSource, arguments)
                    },
                    pageCount: function() {
                        var that = this,
                            count = that.totalItemsCount(),
                            pageSize = that.pageSize();
                        if (pageSize && count > 0)
                            return Math.max(1, Math.ceil(count / pageSize));
                        return 1
                    },
                    hasKnownLastPage: function() {
                        return this._hasLastPage || this._dataSource.totalCount() >= 0
                    }
                }
        }());
        dataGrid.DataSourceAdapterClient = dataGrid.DataSourceAdapterServer.inherit({
            _handleDataLoading: function(options) {
                this.callBase(options);
                var remoteOperations = this._remoteOperations,
                    loadOptions = options.loadOptions = options.storeLoadOptions,
                    storeLoadOptionNames = ["select"],
                    store = this.store();
                storeLoadOptionNames = storeLoadOptionNames.concat(store && store._customLoadOptions() || []);
                if (remoteOperations.filtering)
                    storeLoadOptionNames.push("filter");
                if (remoteOperations.sorting)
                    storeLoadOptionNames.push("sort");
                options.storeLoadOptions = {userData: loadOptions.userData};
                $.each(storeLoadOptionNames, function(_, optionName) {
                    options.storeLoadOptions[optionName] = loadOptions[optionName];
                    delete loadOptions[optionName]
                });
                this._handleDataLoadingCore(options)
            },
            _handleDataLoadingCore: function(){},
            _handleDataLoaded: function(options) {
                var callBase = this.callBase,
                    loadOptions = options.loadOptions;
                if (!loadOptions) {
                    this._dataSource.cancel(options.operationId);
                    return
                }
                options.skip = loadOptions.skip;
                options.take = loadOptions.take;
                delete loadOptions.skip;
                delete loadOptions.take;
                loadOptions.group = options.group || loadOptions.group;
                new DX.data.ArrayStore(options.data).load(loadOptions).done(function(data) {
                    options.data = data;
                    if (loadOptions.requireTotalCount)
                        options.extra = $.isPlainObject(options.extra) ? options.extra : {totalCount: data.length}
                });
                this._handleDataLoadedCore(options);
                callBase.apply(this, arguments)
            },
            _handleDataLoadedCore: function(options) {
                if (options.skip !== undefined)
                    options.data = options.data.slice(options.skip);
                if (options.take !== undefined)
                    options.data = options.data.slice(0, options.take)
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.groupingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            utils = DX.utils,
            normalizeSortingInfo = DX.data.utils.normalizeSortingInfo;
        var DATAGRID_GROUP_PANEL_CLASS = "dx-datagrid-group-panel",
            DATAGRID_GROUP_PANEL_MESSAGE_CLASS = "dx-group-panel-message",
            DATAGRID_GROUP_PANEL_ITEM_CLASS = "dx-group-panel-item",
            DATAGRID_GROUP_OPENED_CLASS = "dx-datagrid-group-opened",
            DATAGRID_GROUP_CLOSED_CLASS = "dx-datagrid-group-closed",
            DATAGRID_EXPAND_CLASS = "dx-datagrid-expand",
            DATAGRID_SELECTION_DISABLED_CLASS = "dx-selection-disabled";
        var GroupingDataSourceAdapterExtender = function() {
                var findGroupInfoByKey = function(groupsInfo, key) {
                        var hash = groupsInfo.hash;
                        return hash && hash[key]
                    };
                var getGroupInfoIndexByOffset = function(groupsInfo, offset) {
                        var index;
                        for (index = 0; index < groupsInfo.length; index++)
                            if (groupsInfo[index].offset > offset)
                                break;
                        return index
                    };
                var updateGroupInfoOffsets = function(groupsInfo) {
                        var groupInfo,
                            index,
                            newIndex;
                        for (index = 0; index < groupsInfo.length; index++) {
                            groupInfo = groupsInfo[index];
                            if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {
                                groupsInfo.splice(index, 1);
                                groupInfo.offset = groupInfo.data.offset;
                                newIndex = getGroupInfoIndexByOffset(groupsInfo, groupInfo.offset);
                                groupsInfo.splice(newIndex, 0, groupInfo);
                                if (newIndex > index)
                                    index--
                            }
                        }
                    };
                var cleanGroupsInfo = function(groupsInfo, groupIndex, groupsCount) {
                        var i;
                        for (i = 0; i < groupsInfo.length; i++)
                            if (groupIndex + 1 >= groupsCount)
                                groupsInfo[i].children = [];
                            else
                                cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount)
                    };
                return {
                        init: function() {
                            this.callBase.apply(this, arguments);
                            this.reset()
                        },
                        reset: function() {
                            this._groupsInfo = [];
                            this._totalCountCorrection = 0
                        },
                        totalItemsCount: function() {
                            var that = this,
                                totalCount = that.callBase();
                            return totalCount > 0 && that._dataSource.group() && that._dataSource.requireTotalCount() ? totalCount + that._totalCountCorrection : totalCount
                        },
                        itemsCount: function() {
                            return this._dataSource.group() ? this._itemsCount || 0 : this.callBase()
                        },
                        updateTotalItemsCount: function(totalCountCorrection) {
                            this._totalCountCorrection = totalCountCorrection || 0
                        },
                        _isGroupItemCountable: function(item) {
                            return !this._isVirtualPaging() || !item.isContinuation
                        },
                        _isVirtualPaging: function() {
                            var scrollingMode = this.option("scrolling.mode");
                            return scrollingMode === "virtual" || scrollingMode === "infinite"
                        },
                        updateItemsCount: function(data, groupsCount) {
                            function calculateItemsCount(that, items, groupsCount) {
                                var i,
                                    result = 0;
                                if (items)
                                    if (!groupsCount)
                                        result = items.length;
                                    else
                                        for (i = 0; i < items.length; i++) {
                                            if (that._isGroupItemCountable(items[i]))
                                                result++;
                                            result += calculateItemsCount(that, items[i].items, groupsCount - 1)
                                        }
                                return result
                            }
                            this._itemsCount = calculateItemsCount(this, data, groupsCount)
                        },
                        foreachGroups: function(callback, childrenAtFirst, foreachCollapsedGroups, updateOffsets) {
                            var that = this;
                            function foreachGroupsCore(groupsInfo, callback, childrenAtFirst, parents) {
                                var i,
                                    callbackResult,
                                    callbackResults = [];
                                function executeCallback(callback, data, parents, callbackResults) {
                                    var callbackResult = data && callback(data, parents);
                                    callbackResults.push(callbackResult);
                                    return callbackResult
                                }
                                for (i = 0; i < groupsInfo.length; i++) {
                                    parents.push(groupsInfo[i].data);
                                    if (!childrenAtFirst && executeCallback(callback, groupsInfo[i].data, parents, callbackResults) === false)
                                        return false;
                                    if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded || foreachCollapsedGroups) {
                                        callbackResult = foreachGroupsCore(groupsInfo[i].children, callback, childrenAtFirst, parents);
                                        callbackResults.push(callbackResult);
                                        if (callbackResult === false)
                                            return false
                                    }
                                    if (childrenAtFirst && executeCallback(callback, groupsInfo[i].data, parents, callbackResults) === false)
                                        return false;
                                    if (!groupsInfo[i].data || groupsInfo[i].data.offset !== groupsInfo[i].offset)
                                        updateOffsets = true;
                                    parents.pop()
                                }
                                return updateOffsets && $.when.apply($, callbackResults).always(function() {
                                        updateGroupInfoOffsets(groupsInfo)
                                    })
                            }
                            return foreachGroupsCore(that._groupsInfo, callback, childrenAtFirst, [])
                        },
                        findGroupInfo: function(path) {
                            var that = this,
                                pathIndex,
                                groupInfo,
                                groupsInfo = that._groupsInfo;
                            for (pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {
                                groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
                                groupsInfo = groupInfo && groupInfo.children
                            }
                            return groupInfo && groupInfo.data
                        },
                        addGroupInfo: function(groupInfoData) {
                            var that = this,
                                index,
                                groupInfo,
                                path = groupInfoData.path,
                                pathIndex,
                                groupsInfo = that._groupsInfo;
                            for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                                groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
                                if (!groupInfo) {
                                    groupInfo = {
                                        key: path[pathIndex],
                                        offset: groupInfoData.offset,
                                        children: []
                                    };
                                    index = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);
                                    groupsInfo.splice(index, 0, groupInfo);
                                    groupsInfo.hash = groupsInfo.hash || {};
                                    groupsInfo.hash[groupInfo.key] = groupInfo
                                }
                                if (pathIndex === path.length - 1) {
                                    groupInfo.data = groupInfoData;
                                    if (groupInfo.offset !== groupInfoData.offset)
                                        updateGroupInfoOffsets(groupsInfo)
                                }
                                groupsInfo = groupInfo.children
                            }
                        },
                        allowCollapseAll: function() {
                            return true
                        },
                        isRowExpanded: function(key) {
                            var groupInfo = this.findGroupInfo(key);
                            return groupInfo ? groupInfo.isExpanded : !this.allowCollapseAll()
                        },
                        collapseAll: function(groupIndex) {
                            if (!this.allowCollapseAll()) {
                                DX.log("E1018");
                                return false
                            }
                            return this._collapseExpandAll(groupIndex, false)
                        },
                        expandAll: function(groupIndex) {
                            return this._collapseExpandAll(groupIndex, true)
                        },
                        _collapseExpandAll: function(groupIndex, isExpand) {
                            var that = this,
                                dataSource = that._dataSource,
                                group = dataSource.group(),
                                groups = normalizeSortingInfo(group || []),
                                i;
                            if (groups.length) {
                                for (i = 0; i < groups.length; i++)
                                    if (groupIndex === undefined || groupIndex === i)
                                        groups[i].isExpanded = isExpand;
                                    else if (group && group[i])
                                        groups[i].isExpanded = group[i].isExpanded;
                                dataSource.group(groups);
                                that.foreachGroups(function(groupInfo, parents) {
                                    if (groupIndex === undefined || groupIndex === parents.length - 1)
                                        groupInfo.isExpanded = isExpand
                                }, false, true)
                            }
                            return true
                        },
                        refresh: function(storeLoadOptions) {
                            this.callBase.apply(this, arguments);
                            var that = this,
                                groupIndex,
                                oldGroups = normalizeSortingInfo(that._group || []),
                                groups = normalizeSortingInfo(storeLoadOptions.group || []),
                                groupsCount = Math.min(oldGroups.length, groups.length);
                            that._group = storeLoadOptions.group;
                            for (groupIndex = 0; groupIndex < groupsCount; groupIndex++)
                                if (oldGroups[groupIndex].selector !== groups[groupIndex].selector) {
                                    groupsCount = groupIndex;
                                    break
                                }
                            if (!groupsCount)
                                that.reset();
                            else
                                cleanGroupsInfo(that._groupsInfo, 0, groupsCount)
                        },
                        changeRowExpand: function(path) {
                            var that = this,
                                dataSource = that._dataSource;
                            if (dataSource.group()) {
                                dataSource._changeLoadingCount(1);
                                return that._changeRowExpandCore(path).always(function() {
                                        dataSource._changeLoadingCount(-1)
                                    })
                            }
                        }
                    }
            }();
        dataGrid.DataSourceAdapterClient = dataGrid.DataSourceAdapterClient.inherit(GroupingDataSourceAdapterExtender);
        dataGrid.DataSourceAdapterServer = dataGrid.DataSourceAdapterServer.inherit(GroupingDataSourceAdapterExtender);
        var GroupingDataControllerExtender = function() {
                return {
                        init: function() {
                            var that = this;
                            that.callBase();
                            that.createAction("onRowExpanding");
                            that.createAction("onRowExpanded");
                            that.createAction("onRowCollapsing");
                            that.createAction("onRowCollapsed")
                        },
                        _processItems: function(items, changeType) {
                            var groupColumns = this._columnsController.getGroupColumns();
                            if (items.length && groupColumns.length)
                                items = this._processGroupItems(items, groupColumns.length);
                            return this.callBase(items, changeType)
                        },
                        _processItem: function(item, options) {
                            if (utils.isDefined(item.groupIndex) && utils.isString(item.rowType) && item.rowType.indexOf("group") === 0) {
                                item = this._processGroupItem(item, options);
                                options.dataIndex = 0
                            }
                            else
                                item = this.callBase.apply(this, arguments);
                            return item
                        },
                        _processGroupItem: function(item, options) {
                            return item
                        },
                        _processGroupItems: function(items, groupsCount, options) {
                            var that = this,
                                scrollingMode,
                                i,
                                item,
                                resultItems,
                                path;
                            if (!options) {
                                scrollingMode = that.option("scrolling.mode");
                                options = {
                                    collectContinuationItems: scrollingMode !== "virtual" && scrollingMode !== "infinite",
                                    resultItems: [],
                                    path: []
                                }
                            }
                            resultItems = options.resultItems;
                            path = options.path;
                            if (options.data)
                                if (options.collectContinuationItems || !options.data.isContinuation)
                                    resultItems.push({
                                        rowType: "group",
                                        data: options.data,
                                        groupIndex: path.length - 1,
                                        isExpanded: !!options.data.items,
                                        key: path,
                                        values: path
                                    });
                            if (items)
                                if (groupsCount === 0)
                                    resultItems.push.apply(resultItems, items);
                                else
                                    for (i = 0; i < items.length; i++) {
                                        item = items[i];
                                        if (item) {
                                            options.data = item;
                                            options.path = path.concat(item.key);
                                            that._processGroupItems(item.items, groupsCount - 1, options);
                                            options.data = undefined;
                                            options.path = path
                                        }
                                    }
                            return resultItems
                        },
                        publicMethods: function() {
                            return this.callBase().concat(["collapseAll", "expandAll", "isRowExpanded", "expandRow", "collapseRow"])
                        },
                        collapseAll: function(groupIndex) {
                            var dataSource = this._dataSource;
                            if (dataSource && dataSource.collapseAll(groupIndex)) {
                                dataSource.pageIndex(0);
                                dataSource.reload()
                            }
                        },
                        expandAll: function(groupIndex) {
                            var dataSource = this._dataSource;
                            if (dataSource && dataSource.expandAll(groupIndex)) {
                                dataSource.pageIndex(0);
                                dataSource.reload()
                            }
                        },
                        changeRowExpand: function(key) {
                            var that = this,
                                expanded = that.isRowExpanded(key),
                                args = {
                                    key: key,
                                    expanded: expanded
                                };
                            that.executeAction(expanded ? "onRowCollapsing" : "onRowExpanding", args);
                            if (!args.cancel)
                                return $.when(that._changeRowExpandCore(key)).done(function() {
                                        args.expanded = !expanded;
                                        that.executeAction(expanded ? "onRowCollapsed" : "onRowExpanded", args)
                                    })
                        },
                        _changeRowExpandCore: function(key) {
                            var that = this,
                                dataSource = this._dataSource,
                                d;
                            if (!dataSource)
                                return;
                            d = $.Deferred();
                            $.when(dataSource.changeRowExpand(key)).done(function() {
                                that.load().done(d.resolve).fail(d.reject)
                            }).fail(d.reject);
                            return d
                        },
                        isRowExpanded: function(key) {
                            var dataSource = this._dataSource;
                            return dataSource && dataSource.isRowExpanded(key)
                        },
                        expandRow: function(key) {
                            if (!this.isRowExpanded(key))
                                this.changeRowExpand(key)
                        },
                        collapseRow: function(key) {
                            if (this.isRowExpanded(key))
                                this.changeRowExpand(key)
                        },
                        optionChanged: function(args) {
                            if (args.name === "grouping")
                                args.name = "dataSource";
                            this.callBase(args)
                        }
                    }
            }();
        var GroupingHeaderPanelExtender = function() {
                return {
                        _renderGroupPanel: function() {
                            var that = this,
                                $element = that.element(),
                                groupPanelOptions = that.option("groupPanel"),
                                $groupPanel,
                                groupColumns = that.getController("columns").getGroupColumns();
                            $groupPanel = $element.find("." + DATAGRID_GROUP_PANEL_CLASS);
                            if (groupPanelOptions && groupPanelOptions.visible) {
                                if (!$groupPanel.length)
                                    $groupPanel = $("<div />").addClass(DATAGRID_GROUP_PANEL_CLASS).prependTo($element);
                                else
                                    $groupPanel.show();
                                that._renderGroupPanelItems($groupPanel, groupColumns);
                                if (groupPanelOptions.allowColumnDragging && !groupColumns.length)
                                    $("<div />").addClass(DATAGRID_GROUP_PANEL_MESSAGE_CLASS).text(groupPanelOptions.emptyPanelText).appendTo($groupPanel)
                            }
                            else
                                $groupPanel.hide()
                        },
                        _renderGroupPanelItems: function($groupPanel, groupColumns) {
                            var that = this;
                            $groupPanel.empty();
                            $.each(groupColumns, function(index, groupColumn) {
                                that._createGroupPanelItem($groupPanel, groupColumn)
                            })
                        },
                        _createGroupPanelItem: function($rootElement, groupColumn) {
                            return $("<div />").addClass(groupColumn.cssClass).addClass(DATAGRID_GROUP_PANEL_ITEM_CLASS).appendTo($rootElement).text(groupColumn.caption)
                        },
                        _renderCore: function() {
                            this.callBase.apply(this, arguments);
                            this._renderGroupPanel()
                        },
                        allowDragging: function(column) {
                            var groupPanelOptions = this.option("groupPanel");
                            return groupPanelOptions && groupPanelOptions.visible && groupPanelOptions.allowColumnDragging && column && column.allowGrouping
                        },
                        getColumnElements: function() {
                            var $element = this.element();
                            return $element && $element.find("." + DATAGRID_GROUP_PANEL_ITEM_CLASS)
                        },
                        getColumns: function() {
                            return this.getController("columns").getGroupColumns()
                        },
                        getBoundingRect: function() {
                            var that = this,
                                $element = that.element(),
                                offset;
                            if ($element && $element.find("." + DATAGRID_GROUP_PANEL_CLASS).length) {
                                offset = $element.offset();
                                return {
                                        top: offset.top,
                                        bottom: offset.top + $element.height()
                                    }
                            }
                            return null
                        },
                        getName: function() {
                            return "group"
                        },
                        isVisible: function() {
                            return this.callBase() || this.option("groupPanel.visible")
                        },
                        optionChanged: function(args) {
                            if (args.name === "groupPanel") {
                                this._renderGroupPanel();
                                args.handled = true
                            }
                            else
                                this.callBase(args)
                        }
                    }
            }();
        dataGrid.GroupingHeaderPanelExtender = GroupingHeaderPanelExtender;
        var GroupingRowsViewExtender = function() {
                return {
                        _rowClick: function(e) {
                            var that = this,
                                dataController = that.getController("data"),
                                $expandElement = $(e.jQueryEvent.target).closest("." + DATAGRID_EXPAND_CLASS),
                                key;
                            if ($expandElement.length) {
                                key = dataController.getKeyByRowIndex(e.rowIndex);
                                dataController.changeRowExpand(key);
                                e.jQueryEvent.preventDefault();
                                e.handled = true
                            }
                            that.callBase(e)
                        },
                        _getDefaultTemplate: function(column) {
                            var that = this;
                            if (column.command === "expand")
                                return function(container, options) {
                                        if (utils.isDefined(options.value) && !(options.data && options.data.isContinuation) && !options.row.inserted) {
                                            container.addClass(DATAGRID_EXPAND_CLASS).addClass(DATAGRID_SELECTION_DISABLED_CLASS);
                                            $("<div>").addClass(options.value ? DATAGRID_GROUP_OPENED_CLASS : DATAGRID_GROUP_CLOSED_CLASS).appendTo(container);
                                            that.setAria("label", options.value ? Globalize.localize("dxDataGrid-ariaCollapse") : Globalize.localize("dxDataGrid-ariaExpand"), container)
                                        }
                                    };
                            return that.callBase(column)
                        }
                    }
            }();
        $.extend(dataGrid.__internals, {
            DATAGRID_GROUP_PANEL_CLASS: DATAGRID_GROUP_PANEL_CLASS,
            DATAGRID_GROUP_PANEL_MESSAGE_CLASS: DATAGRID_GROUP_PANEL_MESSAGE_CLASS,
            DATAGRID_GROUP_PANEL_ITEM_CLASS: DATAGRID_GROUP_PANEL_ITEM_CLASS,
            DATAGRID_GROUP_OPENED_CLASS: DATAGRID_GROUP_OPENED_CLASS,
            DATAGRID_GROUP_CLOSED_CLASS: DATAGRID_GROUP_CLOSED_CLASS,
            DATAGRID_EXPAND_CLASS: DATAGRID_EXPAND_CLASS,
            DATAGRID_SELECTION_DISABLED_CLASS: DATAGRID_SELECTION_DISABLED_CLASS
        });
        dataGrid.registerModule("grouping", {
            defaultOptions: function() {
                return {
                        grouping: {
                            autoExpandAll: true,
                            allowCollapsing: true,
                            groupContinuesMessage: Globalize.localize("dxDataGrid-groupContinuesMessage"),
                            groupContinuedMessage: Globalize.localize("dxDataGrid-groupContinuedMessage")
                        },
                        groupPanel: {
                            visible: false,
                            emptyPanelText: Globalize.localize("dxDataGrid-groupPanelEmptyText"),
                            allowColumnDragging: true
                        }
                    }
            },
            extenders: {
                controllers: {data: GroupingDataControllerExtender},
                views: {
                    headerPanel: GroupingHeaderPanelExtender,
                    rowsView: GroupingRowsViewExtender
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.grouping.server.js */
    (function($, DX) {
        var dataUtils = DX.data.utils,
            dataGrid = DX.ui.dxDataGrid,
            normalizeSortingInfo = dataGrid.normalizeSortingInfo,
            keysEqual = dataUtils.keysEqual;
        var loadTotalCount = function(store, options) {
                var d = $.Deferred(),
                    loadOptions = $.extend({
                        skip: 0,
                        take: 1,
                        requireTotalCount: true
                    }, options);
                store.load(loadOptions).done(function(data, extra) {
                    if (extra && isFinite(extra.totalCount))
                        d.resolve(extra.totalCount);
                    else
                        store.totalCount(options).done($.proxy(d.resolve, d)).fail($.proxy(d.reject, d))
                }).fail($.proxy(d.reject, d));
                return d
            };
        dataGrid.DataSourceAdapterServer = dataGrid.DataSourceAdapterServer.inherit(function() {
            var foreachCollapsedGroups = function(that, callback, updateOffsets) {
                    return that.foreachGroups(function(groupInfo) {
                            if (!groupInfo.isExpanded)
                                return callback(groupInfo)
                        }, false, false, updateOffsets)
                };
            var correctSkipLoadOption = function(that, skip) {
                    var skipCorrection = 0,
                        resultSkip = skip || 0;
                    if (skip) {
                        foreachCollapsedGroups(that, function(groupInfo) {
                            if (groupInfo.offset - skipCorrection >= skip)
                                return false;
                            skipCorrection += groupInfo.count - 1
                        });
                        resultSkip += skipCorrection
                    }
                    return resultSkip
                };
            var processGroupItems = function(that, items, path, offset, skipFirstItem, take) {
                    var i,
                        item,
                        offsetInfo,
                        removeLastItemsCount = 0,
                        needRemoveFirstItem = false;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item.items !== undefined) {
                            path.push(item.key);
                            var groupInfo = that.findGroupInfo(path);
                            if (groupInfo && !groupInfo.isExpanded) {
                                item.collapsedItems = item.items;
                                item.items = null;
                                offset += groupInfo.count;
                                take--;
                                if (take < 0)
                                    removeLastItemsCount++;
                                if (skipFirstItem)
                                    needRemoveFirstItem = true
                            }
                            else if (item.items) {
                                offsetInfo = processGroupItems(that, item.items, path, offset, skipFirstItem, take);
                                if (skipFirstItem)
                                    if (offsetInfo.offset - offset > 1)
                                        item.isContinuation = true;
                                    else
                                        needRemoveFirstItem = true;
                                offset = offsetInfo.offset;
                                take = offsetInfo.take;
                                if (take < 0)
                                    if (item.items.length)
                                        item.isContinuationOnNextPage = true;
                                    else
                                        removeLastItemsCount++
                            }
                            path.pop()
                        }
                        else {
                            if (skipFirstItem)
                                needRemoveFirstItem = true;
                            offset++;
                            take--;
                            if (take < 0)
                                removeLastItemsCount++
                        }
                        skipFirstItem = false
                    }
                    if (needRemoveFirstItem)
                        items.splice(0, 1);
                    if (removeLastItemsCount)
                        items.splice(-removeLastItemsCount, removeLastItemsCount);
                    return {
                            offset: offset,
                            take: take
                        }
                };
            var pathEquals = function(path1, path2) {
                    var i;
                    if (path1.length !== path2.length)
                        return false;
                    for (i = 0; i < path1.length; i++)
                        if (!keysEqual(null, path1[i], path2[i]))
                            return false;
                    return true
                };
            var updateGroupOffsets = function(that, items, path, offset, additionalGroupInfo) {
                    var i,
                        item;
                    if (!items)
                        return;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if ("key" in item && item.items !== undefined) {
                            path.push(item.key);
                            if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation)
                                additionalGroupInfo.offset = offset;
                            var groupInfo = that.findGroupInfo(path);
                            if (groupInfo && !groupInfo.isExpanded) {
                                if (!item.isContinuation) {
                                    groupInfo.offset = offset;
                                    offset += groupInfo.count
                                }
                            }
                            else
                                offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo);
                            path.pop()
                        }
                        else
                            offset++
                    }
                    return offset
                };
            var removeGroupLoadOption = function(storeLoadOptions) {
                    var groups,
                        sorts;
                    if (storeLoadOptions.group) {
                        groups = normalizeSortingInfo(storeLoadOptions.group);
                        sorts = normalizeSortingInfo(storeLoadOptions.sort);
                        storeLoadOptions.sort = dataUtils.arrangeSortingInfo(groups, sorts);
                        delete storeLoadOptions.group
                    }
                };
            var createGroupFilter = function(path, storeLoadOptions) {
                    var groups = normalizeSortingInfo(storeLoadOptions.group),
                        i,
                        filter = [];
                    for (i = 0; i < path.length; i++)
                        filter.push([groups[i].selector, "=", path[i]]);
                    if (storeLoadOptions.filter)
                        filter.push(storeLoadOptions.filter);
                    return dataGrid.combineFilters(filter)
                };
            var createNotGroupFilter = function(path, storeLoadOptions, group) {
                    var groups = normalizeSortingInfo(group || storeLoadOptions.group),
                        i,
                        j,
                        filterElement,
                        filter = [];
                    for (i = 0; i < path.length; i++) {
                        filterElement = [];
                        for (j = 0; j <= i; j++)
                            filterElement.push([groups[j].selector, i === j ? "<>" : "=", path[j]]);
                        filter.push(dataGrid.combineFilters(filterElement))
                    }
                    filter = dataGrid.combineFilters(filter, "or");
                    return dataGrid.combineFilters([filter, storeLoadOptions.filter])
                };
            var createOffsetFilter = function(path, storeLoadOptions) {
                    var groups = normalizeSortingInfo(storeLoadOptions.group),
                        i,
                        j,
                        filterElement,
                        filter = [];
                    for (i = 0; i < path.length; i++) {
                        filterElement = [];
                        for (j = 0; j <= i; j++)
                            filterElement.push([groups[j].selector, i === j ? groups[j].desc ? ">" : "<" : "=", path[j]]);
                        if (filter.length)
                            filter.push("or");
                        filter.push(filterElement)
                    }
                    if (storeLoadOptions.filter)
                        filter.push(storeLoadOptions.filter);
                    return filter
                };
            return {
                    _handleDataLoading: function(options) {
                        this.callBase(options);
                        var that = this,
                            storeLoadOptions = options.storeLoadOptions,
                            loadOptions,
                            collapsedPaths = [],
                            collapsedItemsCount = 0,
                            skipFirstItem = false,
                            take,
                            group = storeLoadOptions.group,
                            skipCorrection = 0;
                        removeGroupLoadOption(storeLoadOptions);
                        options.group = options.group || group;
                        if (storeLoadOptions.isLoadingAll)
                            return;
                        loadOptions = $.extend({}, storeLoadOptions);
                        loadOptions.skip = correctSkipLoadOption(that, storeLoadOptions.skip);
                        if (loadOptions.skip && loadOptions.take && group) {
                            loadOptions.skip--;
                            loadOptions.take++;
                            skipFirstItem = true
                        }
                        if (loadOptions.take && group) {
                            take = loadOptions.take;
                            loadOptions.take++
                        }
                        foreachCollapsedGroups(that, function(groupInfo) {
                            if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection)
                                return false;
                            else if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {
                                skipCorrection += groupInfo.count - 1;
                                collapsedPaths.push(groupInfo.path);
                                collapsedItemsCount += groupInfo.count
                            }
                        });
                        $.each(collapsedPaths, function() {
                            loadOptions.filter = createNotGroupFilter(this, loadOptions, group)
                        });
                        options.storeLoadOptions = loadOptions;
                        options.collapsedPaths = collapsedPaths;
                        options.collapsedItemsCount = collapsedItemsCount;
                        options.skip = loadOptions.skip || 0;
                        options.skipFirstItem = skipFirstItem;
                        options.take = take
                    },
                    _handleDataLoaded: function(options) {
                        var that = this,
                            data = options.data,
                            pathIndex,
                            query,
                            collapsedPaths = options.collapsedPaths,
                            groups = normalizeSortingInfo(options.group),
                            groupCount = groups.length;
                        function appendCollapsedPath(data, path, groups) {
                            if (!data || !path.length || !groups.length)
                                return;
                            var i,
                                keyValue,
                                pathValue = dataUtils.toComparable(path[0], true);
                            for (i = 0; i < data.length; i++) {
                                keyValue = dataUtils.toComparable(data[i].key, true);
                                if (groups[0].desc ? pathValue >= keyValue : pathValue <= keyValue)
                                    break
                            }
                            if (!data.length || pathValue !== keyValue)
                                data.splice(i, 0, {
                                    key: path[0],
                                    items: []
                                });
                            appendCollapsedPath(data[i].items, path.slice(1), groups.slice(1))
                        }
                        this.callBase(options);
                        if (groupCount) {
                            query = DX.data.query(data);
                            DX.data.utils.multiLevelGroup(query, groups).enumerate().done(function(groupedData) {
                                data = groupedData
                            });
                            if (collapsedPaths)
                                for (pathIndex = 0; pathIndex < collapsedPaths.length; pathIndex++)
                                    appendCollapsedPath(data, collapsedPaths[pathIndex], groups);
                            if (!options.storeLoadOptions.isLoadingAll) {
                                processGroupItems(that, data, [], options.skip, options.skipFirstItem, options.take);
                                that.updateItemsCount(data, groupCount)
                            }
                            options.data = data;
                            if (options.collapsedItemsCount && options.extra && options.extra.totalCount >= 0)
                                options.extra.totalCount += options.collapsedItemsCount
                        }
                    },
                    updateTotalItemsCount: function() {
                        var itemsCountCorrection = 0;
                        foreachCollapsedGroups(this, function(groupInfo) {
                            if (groupInfo.count)
                                itemsCountCorrection -= groupInfo.count - 1
                        });
                        this.callBase(itemsCountCorrection)
                    },
                    _changeRowExpandCore: function(path) {
                        var that = this,
                            dataSource = that._dataSource,
                            beginPageIndex = that.beginPageIndex ? that.beginPageIndex() : that.pageIndex(),
                            dataSourceItems = that.items(),
                            offset = correctSkipLoadOption(that, beginPageIndex * that.pageSize()),
                            groupInfo = that.findGroupInfo(path),
                            groupCountQuery;
                        if (groupInfo && !groupInfo.isExpanded)
                            groupCountQuery = $.Deferred().resolve(groupInfo.count);
                        else
                            groupCountQuery = loadTotalCount(dataSource.store(), {filter: createGroupFilter(path, {
                                    filter: dataSource.filter(),
                                    group: dataSource.group()
                                })});
                        return $.when(groupCountQuery).done(function(count) {
                                count = parseInt(count.length ? count[0] : count);
                                if (groupInfo) {
                                    updateGroupOffsets(that, dataSourceItems, [], offset);
                                    groupInfo.isExpanded = !groupInfo.isExpanded;
                                    groupInfo.count = count
                                }
                                else {
                                    groupInfo = {
                                        offset: -1,
                                        count: count,
                                        path: path,
                                        isExpanded: false
                                    };
                                    updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);
                                    if (groupInfo.offset >= 0)
                                        that.addGroupInfo(groupInfo)
                                }
                                that.updateTotalItemsCount()
                            }).fail($.proxy(dataSource.loadError.fire, dataSource.loadError))
                    },
                    allowCollapseAll: function() {
                        return false
                    },
                    refresh: function(storeLoadOptions, isReload) {
                        var that = this,
                            dataSource = that._dataSource,
                            store = dataSource.store();
                        this.callBase.apply(this, arguments);
                        if (isReload)
                            return foreachCollapsedGroups(that, function(groupInfo) {
                                    var groupCountQuery = loadTotalCount(store, {filter: createGroupFilter(groupInfo.path, storeLoadOptions)}),
                                        groupOffsetQuery = loadTotalCount(store, {filter: createOffsetFilter(groupInfo.path, storeLoadOptions)});
                                    dataSource._changeLoadingCount(1);
                                    return $.when(groupOffsetQuery, groupCountQuery).done(function(offset, count) {
                                            offset = parseInt(offset.length ? offset[0] : offset);
                                            count = parseInt(count.length ? count[0] : count);
                                            groupInfo.offset = offset;
                                            if (groupInfo.count !== count) {
                                                groupInfo.count = count;
                                                that.updateTotalItemsCount()
                                            }
                                        }).fail($.proxy(that._dataSource.loadError.fire, that._dataSource.loadError)).always(function() {
                                            dataSource._changeLoadingCount(-1)
                                        })
                                }, true)
                    }
                }
        }());
        $.extend(DX.ui.dxDataGrid.__internals, {loadTotalCount: loadTotalCount})
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.grouping.client.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            normalizeSortingInfo = dataGrid.normalizeSortingInfo;
        dataGrid.DataSourceAdapterClient = dataGrid.DataSourceAdapterClient.inherit(function() {
            var foreachExpandedGroups = function(that, callback) {
                    return that.foreachGroups(function(groupInfo, parents) {
                            if (groupInfo.isExpanded)
                                return callback(groupInfo, parents)
                        }, true)
                };
            var processGroupItems = function(that, items, path, groupsCount) {
                    var i,
                        item;
                    if (!groupsCount)
                        return;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item.items !== undefined) {
                            path.push(item.key);
                            var groupInfo = that.findGroupInfo(path);
                            if (!groupInfo || !groupInfo.isExpanded) {
                                item.collapsedItems = item.items;
                                item.items = null
                            }
                            else
                                processGroupItems(that, item.items, path, groupsCount - 1);
                            path.pop()
                        }
                    }
                };
            var updateGroupInfos = function(that, items, groupsCount, offset) {
                    return updateGroupInfosCore(that, items, 0, groupsCount, [], offset)
                };
            var updateGroupInfosCore = function(that, items, groupIndex, groupsCount, path, offset) {
                    var item,
                        totalCount = 0,
                        i,
                        groupInfo;
                    if (groupIndex >= groupsCount)
                        return items.length;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item) {
                            path.push(item.key);
                            groupInfo = that.findGroupInfo(path);
                            if (!groupInfo)
                                that.addGroupInfo({
                                    isExpanded: that._isGroupExpanded(groupIndex),
                                    path: path.slice(0),
                                    offset: offset + i,
                                    count: item.items.length
                                });
                            else {
                                groupInfo.count = item.items.length;
                                groupInfo.offset = offset + i
                            }
                            totalCount += updateGroupInfosCore(that, item.items, groupIndex + 1, groupsCount, path, 0);
                            path.pop()
                        }
                    }
                    return totalCount
                };
            var isGroupExpanded = function(groups, groupIndex) {
                    return groups && groups.length && groups[groupIndex] && !!groups[groupIndex].isExpanded
                };
            var getTotalOffset = function(groupInfos, pageSize, offset) {
                    var groupIndex,
                        groupSize,
                        totalOffset = offset;
                    for (groupIndex = 0; groupIndex < groupInfos.length; groupIndex++) {
                        groupSize = groupInfos[groupIndex].offset + 1;
                        if (groupIndex > 0) {
                            groupSize += groupInfos[groupIndex - 1].childrenTotalCount;
                            if (pageSize)
                                groupSize += getContinuationGroupCount(totalOffset, pageSize, groupSize, groupIndex - 1) * groupIndex
                        }
                        totalOffset += groupSize
                    }
                    return totalOffset
                };
            var getContinuationGroupCount = function(groupOffset, pageSize, groupSize, groupIndex) {
                    groupIndex = groupIndex || 0;
                    if (pageSize > 1 && groupSize > 0) {
                        var pageOffset = groupOffset - Math.floor(groupOffset / pageSize) * pageSize || pageSize;
                        pageOffset += groupSize - groupIndex - 2;
                        if (pageOffset < 0)
                            pageOffset += pageSize;
                        return Math.floor(pageOffset / (pageSize - groupIndex - 1))
                    }
                    return 0
                };
            DX.ui.dxDataGrid.getContinuationGroupCount = getContinuationGroupCount;
            return {
                    updateTotalItemsCount: function(options) {
                        var totalItemsCount = 0,
                            totalCount = options.extra && options.extra.totalCount || 0,
                            pageSize = this.pageSize(),
                            isVirtualPaging = this._isVirtualPaging();
                        foreachExpandedGroups(this, function(groupInfo, parents) {
                            groupInfo.childrenTotalCount = 0
                        });
                        foreachExpandedGroups(this, function(groupInfo, parents) {
                            var totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, totalItemsCount),
                                count = groupInfo.count + groupInfo.childrenTotalCount;
                            if (!isVirtualPaging)
                                count += getContinuationGroupCount(totalOffset, pageSize, count, parents.length - 1);
                            if (parents[parents.length - 2])
                                parents[parents.length - 2].childrenTotalCount += count;
                            else
                                totalItemsCount += count
                        });
                        this.callBase(totalItemsCount - totalCount + options.data.length)
                    },
                    _isGroupExpanded: function(groupIndex) {
                        var groups = this._dataSource.group();
                        return isGroupExpanded(groups, groupIndex)
                    },
                    _updatePagingOptions: function(options) {
                        var that = this,
                            isVirtualPaging = that._isVirtualPaging(),
                            pageSize = that.pageSize(),
                            skips = [],
                            takes = [],
                            skipChildrenTotalCount = 0,
                            childrenTotalCount = 0;
                        if (options.take) {
                            foreachExpandedGroups(this, function(groupInfo) {
                                groupInfo.childrenTotalCount = 0;
                                groupInfo.skipChildrenTotalCount = 0
                            });
                            foreachExpandedGroups(that, function(groupInfo, parents) {
                                var skip,
                                    take,
                                    takeCorrection = 0,
                                    parentTakeCorrection = 0,
                                    totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, childrenTotalCount),
                                    continuationGroupCount = 0,
                                    skipContinuationGroupCount = 0,
                                    groupInfoCount = groupInfo.count + groupInfo.childrenTotalCount,
                                    childrenGroupInfoCount = groupInfoCount;
                                skip = options.skip - totalOffset;
                                if (totalOffset <= options.skip + options.take && groupInfoCount) {
                                    take = options.take;
                                    if (!isVirtualPaging) {
                                        continuationGroupCount = getContinuationGroupCount(totalOffset, pageSize, groupInfoCount, parents.length - 1);
                                        groupInfoCount += continuationGroupCount * parents.length;
                                        childrenGroupInfoCount += continuationGroupCount;
                                        if (pageSize && skip >= 0) {
                                            takeCorrection = parents.length;
                                            parentTakeCorrection = parents.length - 1;
                                            skipContinuationGroupCount = Math.floor(skip / pageSize)
                                        }
                                    }
                                    if (skip >= 0) {
                                        if (totalOffset + groupInfoCount > options.skip)
                                            skips.unshift(skip - skipContinuationGroupCount * takeCorrection - groupInfo.skipChildrenTotalCount);
                                        if (totalOffset + groupInfoCount >= options.skip + take)
                                            takes.unshift(take - takeCorrection - groupInfo.childrenTotalCount + groupInfo.skipChildrenTotalCount)
                                    }
                                    else if (totalOffset + groupInfoCount >= options.skip + take)
                                        takes.unshift(take + skip - groupInfo.childrenTotalCount)
                                }
                                if (totalOffset <= options.skip)
                                    if (parents[parents.length - 2])
                                        parents[parents.length - 2].skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1 - skipContinuationGroupCount * parentTakeCorrection);
                                    else
                                        skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1);
                                if (totalOffset <= options.skip + take) {
                                    groupInfoCount = Math.min(childrenGroupInfoCount, skip + take - (skipContinuationGroupCount + 1) * parentTakeCorrection);
                                    if (parents[parents.length - 2])
                                        parents[parents.length - 2].childrenTotalCount += groupInfoCount;
                                    else
                                        childrenTotalCount += groupInfoCount
                                }
                            });
                            options.skip -= skipChildrenTotalCount;
                            options.take -= childrenTotalCount - skipChildrenTotalCount
                        }
                        options.skips = skips;
                        options.takes = takes
                    },
                    _changeRowExpandCore: function(path) {
                        var that = this,
                            groupInfo = that.findGroupInfo(path);
                        if (groupInfo) {
                            groupInfo.isExpanded = !groupInfo.isExpanded;
                            return $.Deferred().resolve()
                        }
                        return $.Deferred().reject()
                    },
                    _handleDataLoadedCore: function(options) {
                        var that = this,
                            callBase = that.callBase,
                            groupCount = normalizeSortingInfo(options.loadOptions.group).length,
                            totalCount,
                            skips,
                            takes,
                            i,
                            item,
                            items;
                        if (options.loadOptions.isLoadingAll) {
                            callBase.call(that, options);
                            return
                        }
                        totalCount = updateGroupInfos(that, options.data, groupCount, 0);
                        if (groupCount && options.extra)
                            options.extra.totalCount = totalCount;
                        that.updateTotalItemsCount(options);
                        that._updatePagingOptions(options);
                        callBase.call(that, options);
                        skips = options.skips;
                        takes = options.takes;
                        items = options.data;
                        for (i = 0; items && i < groupCount; i++) {
                            item = items[0];
                            items = item && item.items;
                            if (items && skips[i] !== undefined) {
                                item.isContinuation = true;
                                items = items.slice(skips[i]);
                                item.items = items
                            }
                        }
                        items = options.data;
                        for (i = 0; items && i < groupCount; i++) {
                            item = items[items.length - 1];
                            items = item && item.items;
                            if (items && takes[i] !== undefined && items.length > takes[i]) {
                                item.isContinuationOnNextPage = true;
                                items = items.slice(0, takes[i]);
                                item.items = items
                            }
                        }
                        processGroupItems(that, options.data, [], groupCount);
                        that.updateItemsCount(options.data, groupCount)
                    },
                    refresh: function(storeLoadOptions) {
                        var that = this,
                            oldGroups = normalizeSortingInfo(that._group),
                            isExpanded,
                            groupIndex;
                        function handleGroup(groupInfo, parents) {
                            if (parents.length === groupIndex + 1)
                                groupInfo.isExpanded = isExpanded
                        }
                        for (groupIndex = 0; groupIndex < oldGroups.length; groupIndex++) {
                            isExpanded = isGroupExpanded(storeLoadOptions.group, groupIndex);
                            if (isGroupExpanded(that._group, groupIndex) !== isExpanded)
                                that.foreachGroups(handleGroup)
                        }
                        that.callBase.apply(this, arguments);
                        that.foreachGroups(function(groupInfo) {
                            groupInfo.count = 0
                        })
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.virtualScrollingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_FREESPACE_CLASS = "dx-freespace-row",
            DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
            DATAGRID_BOTTOM_LOAD_PANEL_CLASS = "dx-datagrid-bottom-load-panel",
            DATAGRID_TABLE_CONTENT_CLASS = "dx-datagrid-table-content",
            DATAGRID_GROUP_SPACE_CLASS = "dx-datagrid-group-space",
            DATAGRID_SCROLLABLE_CONTAINER = "dx-scrollable-container",
            DATAGRID_SCROLLABLE_CONTENT = "dx-scrollable-content",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            SCROLLING_MODE_INFINITE = "infinite",
            SCROLLING_MODE_VIRTUAL = "virtual",
            PIXELS_LIMIT = 250000,
            CONTENT_HEIHGT_LIMIT = 15000000;
        var VirtualScrollingDataSourceAdapterExtender = function() {
                var getViewportPageCount = function(that) {
                        var pageSize = that.pageSize();
                        return pageSize && that._viewportSize >= 0 ? Math.ceil(that._viewportSize / pageSize) : 1
                    };
                var getPreloadPageCount = function(that) {
                        var preloadEnabled = that.option('scrolling.preloadEnabled'),
                            pageCount = getViewportPageCount(that);
                        if (pageCount) {
                            if (preloadEnabled)
                                pageCount++;
                            if (isAppendMode(that))
                                pageCount--
                        }
                        return pageCount
                    };
                var isVirtualMode = function(that) {
                        return !that._isLoadingAll && that.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL
                    };
                var isAppendMode = function(that) {
                        return !that._isLoadingAll && that.option("scrolling.mode") === SCROLLING_MODE_INFINITE
                    };
                var getBeginPageIndex = function(that) {
                        return that._cache.length ? that._cache[0].pageIndex : -1
                    };
                var getEndPageIndex = function(that) {
                        return that._cache.length ? that._cache[that._cache.length - 1].pageIndex : -1
                    };
                var updateLoading = function(that) {
                        var beginPageIndex = getBeginPageIndex(that);
                        if (isVirtualMode(that))
                            if (beginPageIndex < 0 || that._viewportSize >= 0 && that._viewportItemIndex >= 0 && (beginPageIndex * that.pageSize() > that._viewportItemIndex || beginPageIndex * that.pageSize() + that.itemsCount() < that._viewportItemIndex + that._viewportSize) && that._dataSource.isLoading()) {
                                if (!that._isLoading) {
                                    that._isLoading = true;
                                    that.loadingChanged.fire(true)
                                }
                            }
                            else if (that._isLoading) {
                                that._isLoading = false;
                                that.loadingChanged.fire(false)
                            }
                    };
                var fireChanged = function(that, changed, args) {
                        that._isChangedFiring = true;
                        changed.call(that, args);
                        that._isChangedFiring = false
                    };
                var processDelayChanged = function(that, changed) {
                        if (that._isDelayChanged) {
                            that._isDelayChanged = false;
                            fireChanged(that, changed);
                            return true
                        }
                    };
                var processChanged = function(that, changed, changeType, isDelayChanged) {
                        var dataSource = that._dataSource,
                            items = dataSource.items(),
                            change = changeType && {
                                changeType: changeType,
                                items: items
                            };
                        if (changeType === "append")
                            that._items.push.apply(that._items, items);
                        else if (changeType === "prepend")
                            that._items.unshift.apply(that._items, items);
                        else
                            that._items = items;
                        updateLoading(that);
                        that._lastPageIndex = that.pageIndex();
                        that._isDelayChanged = isDelayChanged;
                        that._isLoadingAll = false;
                        if (!isDelayChanged)
                            fireChanged(that, changed, change)
                    };
                return {
                        init: function(dataSource) {
                            var that = this;
                            that.callBase.apply(that, arguments);
                            that._isLoading = true;
                            that._pageIndex = dataSource.pageIndex();
                            that._lastPageIndex = that._pageIndex;
                            that._viewportSize = 0;
                            that._viewportItemIndex = -1;
                            that._userPageSize = that.option("paging.pageSize");
                            that._items = [];
                            that._isLoaded = true;
                            that._cache = []
                        },
                        _handleLoadingChanged: function(isLoading) {
                            var that = this;
                            if (!isVirtualMode(that)) {
                                that._isLoading = isLoading;
                                that.callBase.apply(that, arguments)
                            }
                        },
                        _handleLoadError: function() {
                            var that = this;
                            that._isLoadingAll = false;
                            that._isLoading = false;
                            that.loadingChanged.fire(false);
                            that.callBase.apply(that, arguments)
                        },
                        _handleDataChanged: function() {
                            var that = this,
                                beginPageIndex,
                                callBase = that.callBase,
                                dataSource = that._dataSource,
                                lastCacheLength = that._cache.length,
                                changeType,
                                cacheItem;
                            if (isVirtualMode(that) || isAppendMode(that)) {
                                beginPageIndex = getBeginPageIndex(that);
                                if (beginPageIndex >= 0) {
                                    if (isVirtualMode(that) && beginPageIndex + that._cache.length !== dataSource.pageIndex() && beginPageIndex - 1 !== dataSource.pageIndex())
                                        that._cache = [];
                                    if (isAppendMode(that) && dataSource.pageIndex() === 0)
                                        that._cache = []
                                }
                                cacheItem = {
                                    pageIndex: dataSource.pageIndex(),
                                    itemsCount: that.itemsCount(true)
                                };
                                processDelayChanged(that, callBase);
                                if (beginPageIndex === dataSource.pageIndex() + 1) {
                                    changeType = "prepend";
                                    that._cache.unshift(cacheItem)
                                }
                                else {
                                    changeType = "append";
                                    that._cache.push(cacheItem)
                                }
                                processChanged(that, callBase, that._cache.length > 1 ? changeType : undefined, lastCacheLength === 0);
                                that.load().done(function() {
                                    if (processDelayChanged(that, callBase))
                                        that.load()
                                })
                            }
                            else
                                processChanged(that, callBase)
                        },
                        items: function() {
                            return this._items
                        },
                        itemsCount: function(isBase) {
                            var itemsCount = 0;
                            if (!isBase && isVirtualMode(this))
                                $.each(this._cache, function() {
                                    itemsCount += this.itemsCount
                                });
                            else
                                itemsCount = this.callBase();
                            return itemsCount
                        },
                        virtualItemsCount: function() {
                            var that = this,
                                pageIndex,
                                itemsCount = 0,
                                beginItemsCount,
                                endItemsCount;
                            if (isVirtualMode(that)) {
                                pageIndex = getBeginPageIndex(that);
                                if (pageIndex < 0)
                                    pageIndex = 0;
                                beginItemsCount = pageIndex * that.pageSize();
                                itemsCount = that._cache.length * that.pageSize();
                                endItemsCount = Math.max(0, that.totalItemsCount() - itemsCount - beginItemsCount);
                                return {
                                        begin: beginItemsCount,
                                        end: endItemsCount
                                    }
                            }
                        },
                        setViewportItemIndex: function(itemIndex) {
                            var that = this,
                                pageSize = that.pageSize(),
                                pageCount = that.pageCount(),
                                virtualMode = isVirtualMode(that),
                                appendMode = isAppendMode(that),
                                totalItemsCount = that.totalItemsCount(),
                                needLoad = that._viewportItemIndex < 0,
                                lastPageSize,
                                maxPageIndex,
                                newPageIndex;
                            that._viewportItemIndex = itemIndex;
                            if (pageSize && (virtualMode || appendMode) && totalItemsCount >= 0) {
                                if (that._viewportSize && itemIndex + that._viewportSize >= totalItemsCount)
                                    if (that.hasKnownLastPage()) {
                                        newPageIndex = pageCount - 1;
                                        lastPageSize = totalItemsCount % pageSize;
                                        if (newPageIndex > 0 && lastPageSize > 0 && lastPageSize < pageSize / 2)
                                            newPageIndex--
                                    }
                                    else
                                        newPageIndex = pageCount;
                                else {
                                    newPageIndex = Math.floor(itemIndex / pageSize);
                                    maxPageIndex = pageCount - 1;
                                    newPageIndex = Math.max(newPageIndex, 0);
                                    newPageIndex = Math.min(newPageIndex, maxPageIndex)
                                }
                                if (that.pageIndex() !== newPageIndex || needLoad) {
                                    that.pageIndex(newPageIndex);
                                    that.load()
                                }
                            }
                        },
                        viewportSize: function(size) {
                            if (size !== undefined)
                                this._viewportSize = size;
                            return this._viewportSize
                        },
                        pageIndex: function(pageIndex) {
                            if (isVirtualMode(this) || isAppendMode(this)) {
                                if (pageIndex !== undefined)
                                    this._pageIndex = pageIndex;
                                return this._pageIndex
                            }
                            else
                                return this._dataSource.pageIndex(pageIndex)
                        },
                        beginPageIndex: function() {
                            var beginPageIndex = getBeginPageIndex(this);
                            return beginPageIndex >= 0 ? beginPageIndex : this.pageIndex()
                        },
                        endPageIndex: function() {
                            var endPageIndex = getEndPageIndex(this);
                            return endPageIndex > 0 ? endPageIndex : this._lastPageIndex
                        },
                        load: function(isLoadingAll) {
                            var beginPageIndex = getBeginPageIndex(this),
                                pageIndexForLoad = -1,
                                dataSource = this._dataSource,
                                result;
                            var loadCore = function(that, pageIndex) {
                                    var dataSource = that._dataSource;
                                    if (pageIndex === that.pageIndex() || !dataSource.isLoading() && pageIndex < that.pageCount() || !that.hasKnownLastPage() && pageIndex === that.pageCount()) {
                                        dataSource.pageIndex(pageIndex);
                                        return dataSource.load()
                                    }
                                };
                            this._isLoadingAll = isLoadingAll;
                            if (isVirtualMode(this) || isAppendMode(this)) {
                                if (beginPageIndex < 0 || !this._cache[this._pageIndex - beginPageIndex])
                                    pageIndexForLoad = this._pageIndex;
                                if (beginPageIndex >= 0 && pageIndexForLoad < 0 && this._viewportSize >= 0)
                                    if (beginPageIndex > 0 && getEndPageIndex(this) + 1 === this.pageCount() && this._cache.length < getPreloadPageCount(this) + 1)
                                        pageIndexForLoad = beginPageIndex - 1;
                                    else if (beginPageIndex + this._cache.length <= this._pageIndex + getPreloadPageCount(this))
                                        pageIndexForLoad = beginPageIndex + this._cache.length;
                                if (pageIndexForLoad >= 0)
                                    result = loadCore(this, pageIndexForLoad);
                                updateLoading(this)
                            }
                            else
                                result = dataSource.load();
                            if (!result && this._lastPageIndex !== this.pageIndex())
                                this.changed.fire({changeType: "pageIndex"});
                            return result || $.Deferred().resolve()
                        },
                        loadIfNeed: function() {
                            var that = this;
                            if ((isVirtualMode(that) || isAppendMode(that)) && !that.isLoading() && !that._isChangedFiring)
                                that.load()
                        },
                        isLoading: function() {
                            return this._isLoading
                        },
                        isLoaded: function() {
                            return this._dataSource.isLoaded() && this._isLoaded
                        },
                        _changeRowExpandCore: function() {
                            var result = this.callBase.apply(this, arguments);
                            this._cache = [];
                            updateLoading(this);
                            return result
                        },
                        refresh: function(storeLoadOptions, isReload) {
                            var that = this,
                                dataSource = that._dataSource;
                            if (isReload) {
                                that._cache = [];
                                that._isLoaded = false;
                                updateLoading(that);
                                that._isLoaded = true;
                                if (isAppendMode(that)) {
                                    that.pageIndex(0);
                                    dataSource.pageIndex(0);
                                    storeLoadOptions.pageIndex = 0;
                                    storeLoadOptions.skip = 0
                                }
                                else {
                                    dataSource.pageIndex(that.pageIndex());
                                    if (dataSource.paginate())
                                        storeLoadOptions.skip = that.pageIndex() * that.pageSize()
                                }
                            }
                            return that.callBase.apply(that, arguments)
                        }
                    }
            }();
        dataGrid.DataSourceAdapterServer = dataGrid.DataSourceAdapterServer.inherit(VirtualScrollingDataSourceAdapterExtender);
        dataGrid.DataSourceAdapterClient = dataGrid.DataSourceAdapterClient.inherit(VirtualScrollingDataSourceAdapterExtender);
        var VirtualScrollingRowsViewExtender = function() {
                return {
                        _renderCore: function() {
                            var that = this,
                                startRenderDate = new Date;
                            that.callBase.apply(that, arguments);
                            that._updateContentPosition();
                            that._renderTime = new Date - startRenderDate
                        },
                        _renderContent: function(contentElement, tableElement) {
                            var that = this,
                                virtualItemsCount = that._dataController.virtualItemsCount();
                            if (virtualItemsCount) {
                                tableElement.addClass(DATAGRID_TABLE_CONTENT_CLASS);
                                if (!contentElement.children().length)
                                    contentElement.append(tableElement);
                                else
                                    contentElement.children().first().replaceWith(tableElement);
                                if (contentElement.children("table").length === 1) {
                                    contentElement.append(that._createTable());
                                    that._contentHeight = 0
                                }
                                return contentElement
                            }
                            else
                                return that.callBase.apply(that, arguments)
                        },
                        _updateContent: function(contentElement, change, tableElement) {
                            var that = this,
                                contentTable,
                                changeType = change && change.changeType;
                            if (changeType === "append" || changeType === "prepend") {
                                contentTable = contentElement.children().first();
                                tableElement.children("tbody").children("tr")[changeType === "append" ? "appendTo" : "prependTo"](contentTable);
                                that._getFreeSpaceRowElements().not(":last").remove()
                            }
                            else
                                that.callBase.apply(that, arguments);
                            that._updateBottomLoading()
                        },
                        _updateContentPosition: function() {
                            var that = this,
                                contentElement,
                                contentHeight,
                                $tables,
                                $contentTable,
                                virtualTable,
                                rowHeight = that._rowHeight || 20,
                                virtualItemsCount = that._dataController.virtualItemsCount(),
                                isRenderVirtualTableContentRequired;
                            if (virtualItemsCount) {
                                contentElement = that._findContentElement();
                                $tables = contentElement.children();
                                $contentTable = $tables.eq(0);
                                virtualTable = $tables.eq(1);
                                that._contentTableHeight = $contentTable.outerHeight();
                                contentHeight = (virtualItemsCount.begin + virtualItemsCount.end + that._dataController.itemsCount()) * that._rowHeight;
                                if (contentHeight > CONTENT_HEIHGT_LIMIT)
                                    that._heightRatio = CONTENT_HEIHGT_LIMIT / contentHeight;
                                else
                                    that._heightRatio = 1;
                                contentHeight = (virtualItemsCount.begin + virtualItemsCount.end) * rowHeight * that._heightRatio + that._contentTableHeight;
                                DX.translator.move($contentTable, {top: Math.floor(virtualItemsCount.begin * rowHeight * that._heightRatio)});
                                isRenderVirtualTableContentRequired = that._contentHeight !== contentHeight || contentHeight === 0 || !that._isTableLinesDisplaysCorrect(virtualTable) || !that._isColumnElementsEqual($contentTable.find("col"), virtualTable.find("col"));
                                if (isRenderVirtualTableContentRequired) {
                                    that._contentHeight = contentHeight;
                                    that._renderVirtualTableContent(virtualTable, contentHeight)
                                }
                                return true
                            }
                            return false
                        },
                        _isTableLinesDisplaysCorrect: function(table) {
                            var hasColumnLines = table.find("." + DATAGRID_COLUMN_LINES_CLASS).length > 0;
                            return hasColumnLines === this.option("showColumnLines")
                        },
                        _isColumnElementsEqual: function($columns, $virtualColumns) {
                            var result = $columns.length === $virtualColumns.length;
                            if (result)
                                $.each($columns, function(index, element) {
                                    if (element.style.width !== $virtualColumns[index].style.width) {
                                        result = false;
                                        return result
                                    }
                                });
                            return result
                        },
                        _renderVirtualTableContent: function(container, height) {
                            var that = this,
                                columns = that._columnsController.getVisibleColumns(),
                                html = that._createColGroup(columns).prop("outerHTML"),
                                freeSpaceCellsHtml = "",
                                i,
                                columnLinesClass = that.option("showColumnLines") ? DATAGRID_COLUMN_LINES_CLASS : "",
                                createFreeSpaceRowHtml = function(height) {
                                    return "<tr style='height:" + height + "px;' class='" + DATAGRID_FREESPACE_CLASS + " " + DATAGRID_ROW_CLASS + " " + columnLinesClass + "' >" + freeSpaceCellsHtml + "</tr>"
                                };
                            for (i = 0; i < columns.length; i++)
                                freeSpaceCellsHtml += columns[i].command === "expand" ? "<td class='" + DATAGRID_GROUP_SPACE_CLASS + "'/>" : "<td />";
                            while (height > PIXELS_LIMIT) {
                                html += createFreeSpaceRowHtml(PIXELS_LIMIT);
                                height -= PIXELS_LIMIT
                            }
                            html += createFreeSpaceRowHtml(height);
                            container.addClass(DATAGRID_TABLE_CLASS);
                            container.html(html)
                        },
                        _findBottomLoadPanel: function() {
                            var $element = this.element();
                            var $bottomLoadPanel = $element && $element.find("." + DATAGRID_BOTTOM_LOAD_PANEL_CLASS);
                            if ($bottomLoadPanel && $bottomLoadPanel.length)
                                return $bottomLoadPanel
                        },
                        _updateBottomLoading: function() {
                            var that = this,
                                scrollingMode = that.option("scrolling.mode"),
                                virtualMode = scrollingMode === SCROLLING_MODE_VIRTUAL,
                                appendMode = scrollingMode === SCROLLING_MODE_INFINITE,
                                showBottomLoading = !that._dataController.hasKnownLastPage() && that._dataController.isLoaded() && (virtualMode || appendMode),
                                bottomLoadPanelElement = that._findBottomLoadPanel();
                            if (showBottomLoading) {
                                if (!bottomLoadPanelElement)
                                    $("<div />").addClass(DATAGRID_BOTTOM_LOAD_PANEL_CLASS).append(that._createComponent($("<div />"), "dxLoadIndicator").element()).appendTo(that._findContentElement())
                            }
                            else if (bottomLoadPanelElement)
                                bottomLoadPanelElement.remove()
                        },
                        _handleScroll: function(e) {
                            var that = this;
                            if (that._hasHeight && that._rowHeight)
                                that._setViewportScrollTop(e.scrollOffset.top);
                            that.callBase.apply(that, arguments)
                        },
                        _setViewportScrollTop: function(scrollTop) {
                            var that = this,
                                scrollingTimeout = Math.min(that.option("scrolling.timeout") || 0, that._renderTime || 0);
                            clearTimeout(that._scrollTimeoutID);
                            if (scrollingTimeout > 0)
                                that._scrollTimeoutID = setTimeout(function() {
                                    that._setViewportScrollTopCore(scrollTop)
                                }, scrollingTimeout);
                            else
                                that._setViewportScrollTopCore(scrollTop)
                        },
                        _setViewportScrollTopCore: function(scrollTop) {
                            var that = this,
                                virtualItemsCount = that._dataController.virtualItemsCount(),
                                heightRatio = that._heightRatio || 1,
                                rowHeight = that._rowHeight,
                                beginHeight = virtualItemsCount ? Math.floor(virtualItemsCount.begin * rowHeight * heightRatio) : 0;
                            if (virtualItemsCount && scrollTop >= beginHeight && scrollTop <= beginHeight + that._contentTableHeight)
                                that._dataController.setViewportItemIndex(virtualItemsCount.begin + (scrollTop - beginHeight) / rowHeight);
                            else
                                that._dataController.setViewportItemIndex(scrollTop / (rowHeight * heightRatio))
                        },
                        _renderScrollableCore: function($element) {
                            var that = this;
                            that.callBase.apply(that, arguments);
                            that._subscribeToWindowScrollEvents($element)
                        },
                        _subscribeToWindowScrollEvents: function($element) {
                            var that = this,
                                $componentContainer = that.component.element(),
                                $scrollElement;
                            if (!$componentContainer)
                                return;
                            if (!that._windowScrollEvents) {
                                that._windowScrollEvents = true;
                                var createWindowScrollHandler = function($scrollElement, oldHandler) {
                                        var handler = function(e) {
                                                var scrollTop = $scrollElement.scrollTop();
                                                if (!that._hasHeight && that._rowHeight) {
                                                    scrollTop -= $element.offset().top;
                                                    scrollTop = scrollTop > 0 ? scrollTop : 0;
                                                    that._scrollTop = scrollTop;
                                                    that._setViewportScrollTop(scrollTop)
                                                }
                                            };
                                        if (oldHandler)
                                            return function(e) {
                                                    handler(e);
                                                    oldHandler(e)
                                                };
                                        return handler
                                    };
                                var subscribeToScrollEvents = function($scrollElement) {
                                        var dxScrollable = $scrollElement.data("dxScrollable"),
                                            isDocument = $scrollElement.get(0).nodeName === "#document",
                                            scrollHandler,
                                            oldScrollHandler;
                                        if (dxScrollable) {
                                            oldScrollHandler = dxScrollable.option("onScroll");
                                            scrollHandler = createWindowScrollHandler($scrollElement, oldScrollHandler);
                                            dxScrollable.option("onScroll", scrollHandler);
                                            that.on("disposing", function() {
                                                if (dxScrollable.option("onScroll") === scrollHandler)
                                                    dxScrollable.option("onScroll", oldScrollHandler)
                                            })
                                        }
                                        else if (isDocument || $scrollElement.css("overflow-y") === "auto") {
                                            if (isDocument)
                                                $scrollElement = $(window);
                                            scrollHandler = createWindowScrollHandler($scrollElement);
                                            $scrollElement.on("scroll", scrollHandler);
                                            that.on("disposing", function() {
                                                $scrollElement.off("scroll", scrollHandler)
                                            })
                                        }
                                    };
                                for ($scrollElement = that.component.element().parent(); $scrollElement.length; $scrollElement = $scrollElement.parent())
                                    subscribeToScrollEvents($scrollElement)
                            }
                        },
                        _needUpdateRowHeight: function(itemsCount) {
                            var that = this;
                            return that.callBase.apply(that, arguments) || itemsCount > 0 && that.option("scrolling.mode") === SCROLLING_MODE_INFINITE
                        },
                        _updateRowHeight: function() {
                            var that = this,
                                viewportHeight;
                            that.callBase.apply(that, arguments);
                            if (that._rowHeight) {
                                that._updateContentPosition();
                                viewportHeight = that._hasHeight ? that.element().outerHeight() : $(window).outerHeight();
                                that._dataController.viewportSize(Math.round(viewportHeight / that._rowHeight))
                            }
                        },
                        setLoading: function(isLoading, messageText) {
                            var that = this,
                                callBase = that.callBase,
                                hasBottomLoadPanel = !!that._findBottomLoadPanel() && that._dataController.isLoaded();
                            if (hasBottomLoadPanel)
                                isLoading = false;
                            callBase.call(that, isLoading, messageText)
                        },
                        _resizeCore: function() {
                            this.callBase();
                            var dataSource = this._dataController.dataSource();
                            if (dataSource && dataSource.loadIfNeed)
                                dataSource.loadIfNeed()
                        },
                        getTableElements: function(isVirtualTable) {
                            var result = this.callBase();
                            if (isVirtualTable && this.option("scrolling.mode") === "virtual")
                                result = result.add(this.element().find("> ." + DATAGRID_SCROLLABLE_CONTAINER + " > ." + DATAGRID_SCROLLABLE_CONTENT + "> ." + DATAGRID_CONTENT_CLASS).children(":not(." + DATAGRID_TABLE_CONTENT_CLASS + ")"));
                            return result
                        },
                        dispose: function() {
                            clearTimeout(this._scrollTimeoutID);
                            this.callBase()
                        }
                    }
            }();
        $.extend(dataGrid.__internals, {
            DATAGRID_BOTTOM_LOAD_PANEL_CLASS: DATAGRID_BOTTOM_LOAD_PANEL_CLASS,
            DATAGRID_TABLE_CONTENT_CLASS: DATAGRID_TABLE_CONTENT_CLASS
        });
        dataGrid.registerModule("virtualScrolling", {
            defaultOptions: function() {
                return {scrolling: {
                            timeout: 300,
                            mode: "standard",
                            preloadEnabled: false,
                            useNativeScrolling: "auto"
                        }}
            },
            extenders: {
                controllers: {data: function() {
                        var members = {};
                        dataGrid.proxyMethod(members, "virtualItemsCount");
                        dataGrid.proxyMethod(members, "viewportSize");
                        dataGrid.proxyMethod(members, "setViewportItemIndex");
                        return members
                    }()},
                views: {rowsView: VirtualScrollingRowsViewExtender}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnHeadersView.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_HEADERS_CLASS = "dx-datagrid-headers",
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            DATAGRID_NOWRAP_CLASS = "dx-datagrid-nowrap",
            DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
            DATAGRID_CONTEXT_MENU_SORT_ASC_ICON = "context-menu-sort-asc",
            DATAGRID_CONTEXT_MENU_SORT_DESC_ICON = "context-menu-sort-desc",
            DATAGRID_CONTEXT_MENU_SORT_NONE_ICON = "context-menu-sort-none",
            DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
            DATAGRID_COLUMN_INDICATORS_CLASS = "dx-column-indicators";
        var createCellContent = function($cell, column, showColumnLines) {
                var $content = $("<div />").addClass(DATAGRID_CELL_CONTENT_CLASS);
                if (showColumnLines)
                    $content.appendTo($cell);
                else
                    $content.css({float: column.alignment || "left"}).prependTo($cell);
                return $content
            };
        dataGrid.ColumnHeadersView = dataGrid.ColumnsView.inherit({
            _getDefaultTemplate: function(column) {
                var that = this,
                    template,
                    showColumnLines = that.option("showColumnLines");
                if (column.command)
                    template = function($container, options) {
                        var column = options.column;
                        $container.html("&nbsp;");
                        $container.addClass(column.cssClass)
                    };
                else
                    template = function($container, options) {
                        var $content = createCellContent($container, options.column, showColumnLines);
                        $content.text(column.caption)
                    };
                return template
            },
            _getHeaderTemplate: function(column) {
                return !utils.isDefined(column.command) && column.headerCellTemplate || {
                        allowRenderToDetachedContainer: true,
                        render: this._getDefaultTemplate(column)
                    }
            },
            _processTemplate: function(template, options) {
                var that = this,
                    resultTemplate,
                    column = options.column,
                    renderingTemplate = this.callBase(template);
                if (renderingTemplate && column.headerCellTemplate)
                    resultTemplate = {render: function(options, $container) {
                            var $content = createCellContent($container, options.column, that.option("showColumnLines"));
                            renderingTemplate.render(options, $content)
                        }};
                else
                    resultTemplate = renderingTemplate;
                return resultTemplate
            },
            _handleDataChanged: function(e) {
                if (this._isGroupingChanged || this._requireReady) {
                    this._isGroupingChanged = false;
                    this.render()
                }
            },
            _renderCell: function($row, options) {
                var $cell = this.callBase($row, options);
                if (options.row.rowType === "header") {
                    $cell.addClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS);
                    if (!utils.isDefined(options.column.command))
                        this.setAria({
                            role: "columnheader",
                            label: options.column.caption + " " + Globalize.localize("dxDataGrid-ariaColumn")
                        }, $cell)
                }
                return $cell
            },
            _createRow: function(row) {
                var $row = this.callBase(row).toggleClass(DATAGRID_COLUMN_LINES_CLASS, this.option("showColumnLines"));
                if (row.rowType === "header")
                    $row.addClass(DATAGRID_HEADER_ROW_CLASS);
                return $row
            },
            _renderCore: function() {
                var that = this,
                    $container = that.element(),
                    scrollLeft = that._scrollLeft;
                $container.addClass(DATAGRID_HEADERS_CLASS).toggleClass(DATAGRID_NOWRAP_CLASS, !that.option("wordWrapEnabled")).empty();
                that._setTableElement(that._renderTable());
                that.callBase.apply(that, arguments);
                that._scrollLeft = 0;
                that.scrollTo({left: scrollLeft})
            },
            _renderTable: function() {
                var $table = this.callBase.apply(this, arguments),
                    $content = this.element();
                this.wrapTableInScrollContainer($table).appendTo($content);
                return $table
            },
            _getRows: function() {
                var result = [];
                if (this.option("showColumnHeaders"))
                    result.push({rowType: "header"});
                return result
            },
            _getCellTemplate: function(options) {
                if (options.rowType === "header")
                    return this._getHeaderTemplate(options.column)
            },
            _columnOptionChanged: function(e) {
                var changeTypes = e.changeTypes,
                    optionNames = e.optionNames;
                if (changeTypes.grouping) {
                    this._isGroupingChanged = true;
                    return
                }
                this.callBase(e);
                if (optionNames.width || optionNames.visibleWidth)
                    this.resizeCompleted.fire()
            },
            _isElementVisible: function(elementOptions) {
                return elementOptions && elementOptions.visible
            },
            getHeadersRowHeight: function() {
                var tableElement = this._getTableElement();
                if (tableElement) {
                    var $headerRow = tableElement.find("." + DATAGRID_HEADER_ROW_CLASS).first();
                    return $headerRow && $headerRow.height()
                }
                return 0
            },
            setColumnWidths: function(widths) {
                var that = this,
                    scrollLeft = that._scrollLeft;
                that.callBase(widths);
                that._scrollLeft = 0;
                that.scrollTo({left: scrollLeft})
            },
            getHeaderElement: function(index) {
                var columnElements = this.getColumnElements();
                return columnElements && columnElements.eq(index)
            },
            getColumnElements: function() {
                if (this.option("showColumnHeaders"))
                    return this.getCellElements(0)
            },
            getColumnWidths: function() {
                var that = this,
                    $columnElements = that.getColumnElements(),
                    resultWidths = that.callBase();
                if ($columnElements && resultWidths && $columnElements.length === resultWidths.length)
                    $.each($columnElements, function(index, columnElement) {
                        var $indicatorElements = $(columnElement).find("." + DATAGRID_COLUMN_INDICATORS_CLASS);
                        if ($indicatorElements.length)
                            resultWidths[index] += $indicatorElements.outerWidth(true)
                    });
                return resultWidths
            },
            allowDragging: function(column, draggingPanels) {
                var i,
                    columns = this.getColumns(),
                    draggableColumnCount = 0,
                    draggingPanel,
                    allowDrag = function(column) {
                        return column.allowReordering || column.allowGrouping || column.allowHiding
                    };
                for (i = 0; i < columns.length; i++)
                    if (allowDrag(columns[i]))
                        draggableColumnCount++;
                if (draggableColumnCount <= 1)
                    return false;
                else if (!draggingPanels)
                    return (this.option("allowColumnReordering") || this._columnsController.isColumnOptionUsed("allowReordering")) && column && column.allowReordering;
                for (i = 0; i < draggingPanels.length; i++) {
                    draggingPanel = draggingPanels[i];
                    if (draggingPanel && draggingPanel.allowDragging(column))
                        return true
                }
                return false
            },
            getBoundingRect: function() {
                var that = this,
                    offset,
                    $columnElements = that.getColumnElements();
                if ($columnElements && $columnElements.length) {
                    offset = that._getTableElement().offset();
                    return {top: offset.top}
                }
                return null
            },
            getName: function() {
                return "headers"
            },
            getColumnCount: function() {
                var $columnElements = this.getColumnElements();
                return $columnElements ? $columnElements.length : 0
            },
            init: function() {
                var that = this;
                that.callBase();
                that._scrollerWidth = 0
            },
            isVisible: function() {
                return this.option("showColumnHeaders")
            },
            setScrollerSpacing: function(width) {
                var that = this,
                    $element = that.element(),
                    rtlEnabled = that.option("rtlEnabled");
                that._scrollerWidth = width;
                $element && $element.css(rtlEnabled ? {paddingLeft: width} : {paddingRight: width})
            },
            optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"showColumnHeaders":
                    case"wordWrapEnabled":
                    case"showColumnLines":
                        that._invalidate(true, true);
                        args.handled = true;
                        break;
                    default:
                        that.callBase(args)
                }
            },
            getHeight: function() {
                var that = this,
                    $element = that.element();
                return $element ? $element.height() : 0
            },
            getContextMenuItems: function($targetElement) {
                var that = this,
                    $cell,
                    column,
                    onItemClick,
                    sortingOptions;
                if ($targetElement.closest("." + DATAGRID_HEADER_ROW_CLASS).length) {
                    $cell = $targetElement.closest("td");
                    column = $cell.length && that.getColumns($targetElement)[$cell[0].cellIndex];
                    sortingOptions = that.option("sorting");
                    if (sortingOptions && sortingOptions.mode !== "none" && column && column.allowSorting) {
                        onItemClick = function(params) {
                            setTimeout(function() {
                                that._columnsController.changeSortOrder(column.index, params.itemData.value)
                            })
                        };
                        return [{
                                    text: sortingOptions.ascendingText,
                                    value: "asc",
                                    disabled: column.sortOrder === "asc",
                                    icon: DATAGRID_CONTEXT_MENU_SORT_ASC_ICON,
                                    onItemClick: onItemClick
                                }, {
                                    text: sortingOptions.descendingText,
                                    value: "desc",
                                    disabled: column.sortOrder === "desc",
                                    icon: DATAGRID_CONTEXT_MENU_SORT_DESC_ICON,
                                    onItemClick: onItemClick
                                }, {
                                    text: sortingOptions.clearText,
                                    value: "none",
                                    disabled: !column.sortOrder,
                                    icon: DATAGRID_CONTEXT_MENU_SORT_NONE_ICON,
                                    onItemClick: onItemClick
                                }]
                    }
                    return []
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_HEADERS_CLASS: DATAGRID_HEADERS_CLASS,
            DATAGRID_HEADER_ROW_CLASS: DATAGRID_HEADER_ROW_CLASS,
            DATAGRID_NOWRAP_CLASS: DATAGRID_NOWRAP_CLASS
        });
        dataGrid.registerModule("columnHeaders", {
            defaultOptions: function() {
                return {
                        showColumnHeaders: true,
                        cellHintEnabled: true
                    }
            },
            views: {columnHeadersView: dataGrid.ColumnHeadersView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.filterRow.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var OPERATION_ICONS = {
                "=": "filter-operation-equals",
                "<>": "filter-operation-not-equals",
                "<": "filter-operation-less",
                "<=": "filter-operation-less-equal",
                ">": "filter-operation-greater",
                ">=": "filter-operation-greater-equal",
                "default": "filter-operation-default",
                notcontains: "filter-operation-not-contains",
                contains: "filter-operation-contains",
                startswith: "filter-operation-starts-with",
                endswith: "filter-operation-ends-with"
            };
        var FILTERING_TIMEOUT = 700,
            DATAGRID_CLASS = "dx-datagrid",
            DATAGRID_FIRST_CELL_CLASS = "dx-first-cell",
            DATAGRID_FILTER_ROW_CLASS = "dx-datagrid-filter-row",
            DATAGRID_MENU_CLASS = "dx-menu",
            DATAGRID_MENU_IMAGE_CLASS = "dx-menu-image",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_EDITOR_WITH_MENU_CLASS = "dx-editor-with-menu",
            DATAGRID_EDITOR_CONTAINER_CLASS = "dx-editor-container",
            DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
            DATAGRID_FILTER_MENU = "dx-filter-menu",
            DATAGRID_APPLY_BUTTON_CLASS = "dx-apply-button",
            DATAGRID_HIGHLIGHT_OUTLINE_CLASS = "dx-highlight-outline",
            DATAGRID_FOCUSED_CLASS = "dx-focused",
            DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
            TEXTEDITOR_CLASS = "dx-texteditor";
        var ColumnHeadersViewFilterRowExtender = {
                _columnOptionChanged: function(e) {
                    var that = this,
                        optionNames = e.optionNames,
                        visibleIndex,
                        column,
                        $cell,
                        $editor,
                        componentNames,
                        editor,
                        $menu;
                    if (dataGrid.checkChanges(optionNames, ["filterValue", "selectedFilterOperation"]) && e.columnIndex !== undefined) {
                        visibleIndex = that.getController("columns").getVisibleIndex(e.columnIndex);
                        column = that.getController("columns").columnOption(e.columnIndex);
                        $cell = that.element().find("." + DATAGRID_FILTER_ROW_CLASS).children().eq(visibleIndex);
                        $editor = $cell.find("." + TEXTEDITOR_CLASS);
                        if (optionNames.filterValue)
                            if ($editor.length) {
                                componentNames = $editor.data("dxComponents");
                                editor = componentNames.length && $editor.data(componentNames[0]);
                                if (editor instanceof ui.Editor)
                                    editor && editor.option("value", column.filterValue)
                            }
                        if (optionNames.selectedFilterOperation)
                            if (visibleIndex >= 0 && column) {
                                $menu = $cell.find("." + DATAGRID_MENU_CLASS);
                                if ($menu.length)
                                    that._updateFilterOperationChooser($menu, column, $editor.parent())
                            }
                        return
                    }
                    that.callBase(e)
                },
                isFilterRowVisible: function() {
                    return this._isElementVisible(this.option("filterRow"))
                },
                isVisible: function() {
                    return this.callBase() || this.isFilterRowVisible()
                },
                init: function() {
                    this.callBase();
                    this._applyFilterViewController = this.getController("applyFilter")
                },
                _createRow: function(row) {
                    var $row = this.callBase(row);
                    if (row.rowType === "filter")
                        $row.addClass(DATAGRID_FILTER_ROW_CLASS);
                    return $row
                },
                _getRows: function() {
                    var result = this.callBase();
                    if (this.isFilterRowVisible())
                        result.push({rowType: "filter"});
                    return result
                },
                _renderCellContent: function($cell, options) {
                    var that = this,
                        column = options.column,
                        columnsController = that._columnsController,
                        $container,
                        $editorContainer,
                        $editor;
                    var updateFilterValue = function(that, column, value) {
                            if (value === "")
                                value = undefined;
                            if (!utils.isDefined(column.filterValue) && !utils.isDefined(value))
                                return;
                            that._applyFilterViewController.setHighLight($editorContainer, column.filterValue !== value);
                            column.filterValue = value;
                            columnsController.columnOption(column.index, "filterValue", value)
                        };
                    if (options.rowType === "filter") {
                        $cell.toggleClass(DATAGRID_FIRST_CELL_CLASS, options.columnIndex === 0);
                        if (column.command)
                            $cell.html("&nbsp;");
                        else if (column.allowFiltering) {
                            that.setAria("label", Globalize.localize("dxDataGrid-ariaColumn") + " " + column.caption + ", " + Globalize.localize("dxDataGrid-ariaFilterCell"), $cell);
                            $cell.addClass(DATAGRID_EDITOR_CELL_CLASS);
                            $container = $("<div />").appendTo($cell),
                            $editorContainer = $("<div />").addClass(DATAGRID_EDITOR_CONTAINER_CLASS).appendTo($container),
                            $editor = $("<div />").appendTo($editorContainer);
                            that.getController("editorFactory").createEditor($editor, $.extend({}, column, {
                                value: columnsController.isDataSourceApplied() ? column.filterValue : undefined,
                                setValue: function(value) {
                                    updateFilterValue(that, column, value)
                                },
                                parentType: "filterRow",
                                showAllText: that.option("filterRow.showAllText"),
                                updateValueTimeout: that.option("filterRow.applyFilter") === "onClick" ? 0 : FILTERING_TIMEOUT,
                                width: null
                            }));
                            if (column.alignment)
                                $cell.find("input").first().css("text-align", column.alignment);
                            if (column.filterOperations && column.filterOperations.length)
                                that._renderFilterOperationChooser($container, column, $editorContainer)
                        }
                    }
                    that.callBase($cell, options)
                },
                _updateFilterOperationChooser: function($menu, column, $editorContainer) {
                    var that = this,
                        isCellWasFocused;
                    that._createComponent($menu, "dxMenu", {
                        templateProvider: ui.TemplateProvider,
                        _templates: {},
                        activeStateEnabled: false,
                        selectionMode: "single",
                        cssClass: DATAGRID_CLASS + " " + DATAGRID_CELL_FOCUS_DISABLED_CLASS + " " + DATAGRID_FILTER_MENU,
                        showFirstSubmenuMode: "onHover",
                        hideSubmenuOnMouseLeave: true,
                        items: [{
                                disabled: column.filterOperations && column.filterOperations.length ? false : true,
                                icon: OPERATION_ICONS[column.selectedFilterOperation || "default"],
                                selectable: false,
                                items: that._getFilterOperationMenuItems(column)
                            }],
                        onItemClick: function(properties) {
                            var selectedFilterOperation = properties.itemData.name;
                            if (properties.itemData.items)
                                return;
                            if (selectedFilterOperation)
                                that._columnsController.columnOption(column.index, "selectedFilterOperation", selectedFilterOperation);
                            else
                                that._columnsController.columnOption(column.index, {
                                    selectedFilterOperation: column.defaultSelectedFilterOperation,
                                    filterValue: undefined
                                });
                            that._applyFilterViewController.setHighLight($editorContainer, true);
                            that._focusEditor($editorContainer)
                        },
                        onSubmenuShown: function() {
                            isCellWasFocused = that._isEditorFocused($editorContainer);
                            that.getController("editorFactory").loseFocus()
                        },
                        onSubmenuHiding: function(e) {
                            $menu.blur();
                            $menu.dxMenu("instance").option("focusedElement", null);
                            isCellWasFocused && that._focusEditor($editorContainer)
                        },
                        rtlEnabled: that.option("rtlEnabled")
                    })
                },
                _isEditorFocused: function($container) {
                    return $container.hasClass(DATAGRID_FOCUSED_CLASS) || $container.parents("." + DATAGRID_FOCUSED_CLASS).length
                },
                _focusEditor: function($container, showCellFocus) {
                    this.getController("editorFactory").focus($container);
                    $container.find("input").focus()
                },
                _renderFilterOperationChooser: function($container, column, $editorContainer) {
                    var that = this,
                        $menu;
                    if (that.option("filterRow.showOperationChooser")) {
                        $container.addClass(DATAGRID_EDITOR_WITH_MENU_CLASS);
                        $menu = $("<div />").prependTo($container);
                        that._updateFilterOperationChooser($menu, column, $editorContainer)
                    }
                },
                _getFilterOperationMenuItems: function(column) {
                    var that = this,
                        result = [{}],
                        filterRowOptions = that.option("filterRow"),
                        operationDescriptions = filterRowOptions && filterRowOptions.operationDescriptions || {};
                    if (column.filterOperations && column.filterOperations.length) {
                        result = $.map(column.filterOperations, function(value) {
                            return {
                                    name: value,
                                    selected: (column.selectedFilterOperation || column.defaultFilterOperation) === value,
                                    text: operationDescriptions[value],
                                    icon: OPERATION_ICONS[value]
                                }
                        });
                        result.push({
                            name: null,
                            text: filterRowOptions && filterRowOptions.resetOperationText,
                            icon: OPERATION_ICONS["default"]
                        })
                    }
                    return result
                },
                optionChanged: function(args) {
                    var that = this;
                    switch (args.name) {
                        case"filterRow":
                        case"showColumnLines":
                            this._invalidate(true, true);
                            args.handled = true;
                            break;
                        default:
                            that.callBase(args);
                            break
                    }
                }
            };
        var DataControllerFilterRowExtender = {_calculateAdditionalFilter: function() {
                    var that = this,
                        filters = [that.callBase()],
                        columns = that._columnsController.getVisibleColumns();
                    $.each(columns, function() {
                        var filter;
                        if (this.allowFiltering && this.calculateFilterExpression && utils.isDefined(this.filterValue)) {
                            filter = this.calculateFilterExpression(this.filterValue, this.selectedFilterOperation || this.defaultFilterOperation);
                            filters.push(filter)
                        }
                    });
                    return dataGrid.combineFilters(filters)
                }};
        var ColumnsControllerFilterRowExtender = {_createCalculatedColumnOptions: function(columnOptions) {
                    var calculatedColumnOptions = this.callBase(columnOptions);
                    if (columnOptions.dataField)
                        $.extend(calculatedColumnOptions, {
                            calculateFilterExpression: function(value, selectedFilterOperation, filterInterval) {
                                var column = this,
                                    dataField = column.dataField,
                                    filter = null;
                                if (column.dataType === "string" && !column.lookup)
                                    filter = [dataField, selectedFilterOperation || "contains", value];
                                else if (column.dataType === "date" && utils.isDate(value)) {
                                    var dateStart,
                                        dateEnd;
                                    switch (filterInterval) {
                                        case"year":
                                            dateStart = new Date(value.getFullYear(), 0, 1),
                                            dateEnd = new Date(value.getFullYear() + 1, 0, 1);
                                            break;
                                        case"month":
                                            dateStart = new Date(value.getFullYear(), value.getMonth(), 1),
                                            dateEnd = new Date(value.getFullYear(), value.getMonth() + 1, 1);
                                            break;
                                        default:
                                            dateStart = new Date(value.getFullYear(), value.getMonth(), value.getDate()),
                                            dateEnd = new Date(value.getFullYear(), value.getMonth(), value.getDate() + 1)
                                    }
                                    switch (selectedFilterOperation) {
                                        case"<":
                                            return [dataField, "<", dateStart];
                                        case"<=":
                                            return [dataField, "<", dateEnd];
                                        case">":
                                            return [dataField, ">=", dateEnd];
                                        case">=":
                                            return [dataField, ">=", dateStart];
                                        case"<>":
                                            return [[dataField, "<", dateStart], "or", [dataField, ">=", dateEnd]];
                                        default:
                                            return [[dataField, ">=", dateStart], "and", [dataField, "<", dateEnd]]
                                    }
                                }
                                else
                                    filter = [dataField, selectedFilterOperation || "=", value];
                                return filter
                            },
                            allowFiltering: true
                        });
                    else
                        $.extend(calculatedColumnOptions, {allowFiltering: !!columnOptions.calculateFilterExpression});
                    return calculatedColumnOptions
                }};
        dataGrid.ApplyFilterViewController = dataGrid.ViewController.inherit({
            _isOnClick: function() {
                return this.option("filterRow.applyFilter") === "onClick"
            },
            _getHeaderPanel: function() {
                if (!this._headerPanel)
                    this._headerPanel = this.getView("headerPanel");
                return this._headerPanel
            },
            setHighLight: function($element, value) {
                if (this._isOnClick()) {
                    $element && $element.toggleClass(DATAGRID_HIGHLIGHT_OUTLINE_CLASS, value);
                    this._getHeaderPanel().enableApplyButton(value)
                }
            },
            removeHighLights: function() {
                if (this._isOnClick()) {
                    var columnHeadersView = this.getView("columnHeadersView");
                    columnHeadersView.element().find("." + DATAGRID_FILTER_ROW_CLASS + " ." + DATAGRID_HIGHLIGHT_OUTLINE_CLASS).removeClass(DATAGRID_HIGHLIGHT_OUTLINE_CLASS);
                    this._getHeaderPanel().enableApplyButton(false)
                }
            }
        });
        dataGrid.registerModule("filterRow", {
            defaultOptions: function() {
                return {filterRow: {
                            visible: false,
                            showOperationChooser: true,
                            showAllText: Globalize.localize("dxDataGrid-filterRowShowAllText"),
                            resetOperationText: Globalize.localize("dxDataGrid-filterRowResetOperationText"),
                            applyFilter: "auto",
                            applyFilterText: Globalize.localize("dxDataGrid-applyFilterText"),
                            operationDescriptions: {
                                "=": Globalize.localize("dxDataGrid-filterRowOperationEquals"),
                                "<>": Globalize.localize("dxDataGrid-filterRowOperationNotEquals"),
                                "<": Globalize.localize("dxDataGrid-filterRowOperationLess"),
                                "<=": Globalize.localize("dxDataGrid-filterRowOperationLessOrEquals"),
                                ">": Globalize.localize("dxDataGrid-filterRowOperationGreater"),
                                ">=": Globalize.localize("dxDataGrid-filterRowOperationGreaterOrEquals"),
                                startswith: Globalize.localize("dxDataGrid-filterRowOperationStartsWith"),
                                contains: Globalize.localize("dxDataGrid-filterRowOperationContains"),
                                notcontains: Globalize.localize("dxDataGrid-filterRowOperationNotContains"),
                                endswith: Globalize.localize("dxDataGrid-filterRowOperationEndsWith")
                            }
                        }}
            },
            controllers: {applyFilter: dataGrid.ApplyFilterViewController},
            extenders: {
                controllers: {
                    data: DataControllerFilterRowExtender,
                    columns: ColumnsControllerFilterRowExtender
                },
                views: {
                    columnHeadersView: ColumnHeadersViewFilterRowExtender,
                    headerPanel: {
                        _isShowApplyFilterButton: function() {
                            var filterRowOptions = this.option("filterRow");
                            return filterRowOptions && filterRowOptions.visible && filterRowOptions.applyFilter === "onClick"
                        },
                        _renderCore: function() {
                            var that = this,
                                disabled = that._applyButton ? that._applyButton.option("disabled") : true;
                            that.callBase();
                            that._$applyButton && that._$applyButton.remove();
                            if (that._isShowApplyFilterButton()) {
                                that._applyButton = that._createComponent($("<div>").addClass(DATAGRID_APPLY_BUTTON_CLASS).appendTo(that.element()), "dxButton", {
                                    disabled: disabled,
                                    hint: that.option("filterRow.applyFilterText"),
                                    icon: "apply-filter",
                                    onClick: function() {
                                        that._dataController._applyFilter();
                                        that._applyFilterViewController.removeHighLights()
                                    }
                                });
                                that._$applyButton = that._applyButton.element()
                            }
                        },
                        init: function() {
                            this.callBase();
                            this._dataController = this.getController("data");
                            this._applyFilterViewController = this.getController("applyFilter")
                        },
                        enableApplyButton: function(value) {
                            this._applyButton && this._applyButton.option("disabled", !value)
                        },
                        isVisible: function() {
                            return this.callBase() || this._isShowApplyFilterButton()
                        },
                        optionChanged: function(args) {
                            if (args.name === "filterRow") {
                                this._invalidate();
                                args.handled = true
                            }
                            else
                                this.callBase(args)
                        }
                    }
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_FILTER_ROW_CLASS: DATAGRID_FILTER_ROW_CLASS,
            DATAGRID_MENU_CLASS: DATAGRID_MENU_CLASS,
            DATAGRID_MENU_IMAGE_CLASS: DATAGRID_MENU_IMAGE_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_EDITOR_WITH_MENU_CLASS: DATAGRID_EDITOR_WITH_MENU_CLASS,
            DATAGRID_EDITOR_CONTAINER_CLASS: DATAGRID_EDITOR_CONTAINER_CLASS,
            DATAGRID_HIGHLIGHT_OUTLINE_CLASS: DATAGRID_HIGHLIGHT_OUTLINE_CLASS,
            DATAGRID_APPLY_BUTTON_CLASS: DATAGRID_APPLY_BUTTON_CLASS
        });
        dataGrid.ColumnHeadersViewFilterRowExtender = ColumnHeadersViewFilterRowExtender;
        dataGrid.DataControllerFilterRowExtender = DataControllerFilterRowExtender
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.headerPanel.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_HEADER_PANEL_CLASS = "dx-datagrid-header-panel";
        dataGrid.HeaderPanel = dataGrid.ColumnsView.inherit({
            _renderCore: function() {
                this.element().addClass(DATAGRID_HEADER_PANEL_CLASS)
            },
            getHeaderPanel: function() {
                return this.element()
            },
            getHeight: function() {
                var $element = this.element();
                return $element ? $element.outerHeight(true) : 0
            },
            isVisible: function() {
                return false
            }
        });
        $.extend(dataGrid.__internals, {DATAGRID_HEADER_PANEL_CLASS: DATAGRID_HEADER_PANEL_CLASS});
        dataGrid.registerModule("headerPanel", {
            defaultOptions: function() {
                return {}
            },
            views: {headerPanel: dataGrid.HeaderPanel}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.headerFilter.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            utils = DX.utils;
        var DATAGRID_HEADER_FILTER_CLASS = "dx-header-filter",
            DATAGRID_HEADER_FILTER_MENU_CLASS = "dx-header-filter-menu",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content";
        dataGrid.HeaderFilterController = dataGrid.ViewController.inherit({
            init: function() {
                this._columnsController = this.getController("columns");
                this._dataController = this.getController("data");
                this._headerFilterView = this.getView("headerFilterView")
            },
            getDataSource: function(column) {
                var that = this,
                    cutoffLevel,
                    group,
                    headerFilterOptions = that.option("headerFilter"),
                    dataSource = that._dataController.dataSource(),
                    store = dataSource.store();
                var processGroupItems = function(groupItems, level, currentLevel, path) {
                        var value,
                            displayValue,
                            formatOptions,
                            displaySelector,
                            valueSelector,
                            lookup = column.lookup;
                        currentLevel = currentLevel || 0;
                        path = path || [];
                        if (lookup) {
                            displaySelector = DX.data.utils.compileGetter(lookup.displayExpr);
                            valueSelector = DX.data.utils.compileGetter(lookup.valueExpr)
                        }
                        for (var i = 0; i < groupItems.length; i++) {
                            if (lookup) {
                                value = valueSelector(groupItems[i]);
                                displayValue = displaySelector(groupItems[i])
                            }
                            else {
                                value = groupItems[i].key;
                                displayValue = value
                            }
                            groupItems[i] = utils.isObject(groupItems[i]) ? groupItems[i] : {};
                            if (column.dataType === "date")
                                formatOptions = currentLevel === 1 ? {format: {
                                        format: "month",
                                        dateType: "full"
                                    }} : {};
                            else
                                formatOptions = column;
                            groupItems[i].text = dataGrid.formatValue(displayValue, formatOptions);
                            if (!groupItems[i].text)
                                groupItems[i].text = headerFilterOptions.texts.emptyValue;
                            path.push(value);
                            if (path.length === 1)
                                groupItems[i].filterValue = path[0];
                            else
                                groupItems[i].filterValue = path.join("/");
                            if ($.inArray(groupItems[i].filterValue, column.filterValues) > -1 ^ column.filterType === "exclude")
                                groupItems[i].selected = true;
                            delete groupItems[i].key;
                            if ("items" in groupItems[i])
                                if (currentLevel === level || !utils.isDefined(groupItems[i].filterValue))
                                    delete groupItems[i].items;
                                else
                                    processGroupItems(groupItems[i].items, level, currentLevel + 1, path);
                            path.pop()
                        }
                    };
                if (column.lookup) {
                    dataSource = DX.data.utils.normalizeDataSourceOptions(column.lookup.dataSource);
                    dataSource.postProcess = function(items) {
                        if (this.pageIndex() === 0) {
                            items = items.slice(0);
                            items.unshift(null)
                        }
                        processGroupItems(items, 0);
                        return items
                    };
                    return dataSource
                }
                else {
                    if (column.dataType === "date") {
                        group = [function(data) {
                                var value = column.calculateCellValue(data);
                                return value && value.getFullYear()
                            }, function(data) {
                                var value = column.calculateCellValue(data);
                                return value && value.getMonth() + 1
                            }, function(data) {
                                var value = column.calculateCellValue(data);
                                return value && value.getDate()
                            }];
                        cutoffLevel = 2
                    }
                    else {
                        group = $.proxy(column.calculateCellValue, column);
                        cutoffLevel = 0
                    }
                    return {
                            filter: that._dataController.getCombinedFilter(),
                            group: group,
                            load: function(options) {
                                var d = $.Deferred();
                                $.when(options.userData.data || store.load({
                                    filter: options.filter,
                                    expand: dataSource.loadOptions().expand
                                })).done(function(data) {
                                    options.userData.data = data;
                                    new DX.data.ArrayStore(data).load(options).done(function(data) {
                                        processGroupItems(data, cutoffLevel);
                                        d.resolve(data)
                                    }).fail(d.reject)
                                }).fail(d.reject);
                                return d
                            }
                        }
                }
            },
            getCurrentColumn: function() {
                return this._currentColumn
            },
            showHeaderFilterMenu: function(columnIndex) {
                var that = this,
                    column = that._columnsController.getColumns()[columnIndex];
                if (column) {
                    var visibleIndex = that._columnsController.getVisibleIndex(columnIndex),
                        isGroupColumn = column && utils.isDefined(column.groupIndex),
                        view = isGroupColumn ? that.getView("headerPanel") : that.getView("columnHeadersView"),
                        $columnElement = view.getColumnElements().eq(isGroupColumn ? column.groupIndex : visibleIndex);
                    that._currentColumn = column;
                    var options = $.extend({}, column, {
                            type: column.dataType === "date" ? "tree" : "list",
                            apply: function() {
                                that._currentColumn = null;
                                that._columnsController.columnOption(columnIndex, {
                                    filterValues: this.filterValues,
                                    filterType: this.filterType
                                })
                            },
                            cancel: function() {
                                that._currentColumn = null
                            },
                            onShowing: function(e) {
                                var dxResizableInstance = e.component.overlayContent().dxResizable("instance");
                                dxResizableInstance && dxResizableInstance.option("onResizeEnd", function(e) {
                                    var columnsController = that.getController("columns"),
                                        headerFilterByColumn = columnsController.columnOption(options.dataField, "headerFilter");
                                    headerFilterByColumn = headerFilterByColumn || {};
                                    headerFilterByColumn.width = e.width;
                                    headerFilterByColumn.height = e.height;
                                    columnsController.columnOption(options.dataField, "headerFilter", headerFilterByColumn, true)
                                })
                            }
                        });
                    options.dataSource = that.getDataSource(options),
                    that._headerFilterView.showHeaderFilterMenu($columnElement, options)
                }
            },
            hideHeaderFilterMenu: function() {
                this._headerFilterView.hideHeaderFilterMenu()
            }
        });
        dataGrid.HeaderFilterView = dataGrid.View.inherit({
            getPopupContainer: function() {
                return this._popupContainer
            },
            getListContainer: function() {
                return this._listContainer
            },
            applyHeaderFilter: function(options) {
                var that = this,
                    list = that.getListContainer(),
                    isSelectAll = list.element().find(".dx-checkbox").eq(0).hasClass("dx-checkbox-checked"),
                    filterValues = [];
                var fillSelectedItemKeys = function(filterValues, items, isExclude) {
                        $.each(items, function() {
                            if (!!this.selected ^ isExclude)
                                filterValues.push(this.filterValue);
                            else if (this.items && this.items.length)
                                fillSelectedItemKeys(filterValues, this.items)
                        })
                    };
                if (!isSelectAll) {
                    if (options.type === "tree") {
                        fillSelectedItemKeys(filterValues, list.option("items"), options.filterType === "exclude");
                        options.filterValues = filterValues
                    }
                    options.apply()
                }
                else if (utils.isArray(options.filterValues)) {
                    options.filterValues = [];
                    options.apply()
                }
                that.hideHeaderFilterMenu()
            },
            showHeaderFilterMenu: function($columnElement, options) {
                var that = this,
                    popupContainer;
                if (options) {
                    that._initializePopupContainer(options);
                    popupContainer = that.getPopupContainer();
                    that.hideHeaderFilterMenu();
                    that.updatePopup($columnElement, options);
                    popupContainer.show()
                }
            },
            hideHeaderFilterMenu: function() {
                var headerFilterMenu = this.getPopupContainer();
                headerFilterMenu && headerFilterMenu.hide()
            },
            updatePopup: function($element, options) {
                var that = this,
                    alignment = options.alignment === "right" ? "left" : "right";
                if (that._popupContainer) {
                    that._cleanPopupContent();
                    that._popupContainer.option("position", {
                        my: alignment + " top",
                        at: alignment + " bottom",
                        of: $element,
                        collision: "flip fit"
                    })
                }
            },
            _cleanPopupContent: function() {
                this._popupContainer && this._popupContainer.content().empty()
            },
            _initializePopupContainer: function(options) {
                var that = this,
                    $element = that.element(),
                    headerFilterOptions = that.option("headerFilter"),
                    width = options.headerFilter && options.headerFilter.width || headerFilterOptions && headerFilterOptions.width,
                    height = options.headerFilter && options.headerFilter.height || headerFilterOptions && headerFilterOptions.height,
                    dxPopupOptions = {
                        width: width,
                        height: height,
                        visible: false,
                        shading: false,
                        showTitle: false,
                        showCloseButton: false,
                        closeOnTargetScroll: true,
                        closeOnOutsideClick: true,
                        onShown: function() {
                            that._initializeListContainer(options)
                        },
                        buttons: [{
                                toolbar: "bottom",
                                location: "after",
                                widget: "button",
                                options: {
                                    text: headerFilterOptions.texts.ok,
                                    onClick: function() {
                                        that.applyHeaderFilter(options)
                                    }
                                }
                            }, {
                                toolbar: "bottom",
                                location: "after",
                                widget: "button",
                                options: {
                                    text: headerFilterOptions.texts.cancel,
                                    onClick: function() {
                                        that.hideHeaderFilterMenu();
                                        options.cancel && options.cancel()
                                    }
                                }
                            }],
                        resizeEnabled: true,
                        onShowing: options.onShowing
                    };
                if (!utils.isDefined(that._popupContainer))
                    that._popupContainer = that._createComponent($element, "dxPopup", dxPopupOptions);
                else
                    that._popupContainer.option(dxPopupOptions)
            },
            _initializeListContainer: function(options) {
                var that = this,
                    $content = that._popupContainer.content(),
                    widgetOptions = {
                        dataSource: options.dataSource,
                        onContentReady: function() {
                            that.renderCompleted.fire()
                        }
                    };
                if (options.type === "tree")
                    that._listContainer = that._createComponent($("<div/>").appendTo($content), "dxTreeView", $.extend(widgetOptions, {
                        showCheckBoxes: true,
                        selectAllEnabled: true,
                        keyExpr: "id"
                    }));
                else
                    that._listContainer = that._createComponent($("<div/>").appendTo($content), "dxList", $.extend(widgetOptions, {
                        pageLoadMode: "scrollBottom",
                        pullRefreshEnabled: true,
                        showSelectionControls: true,
                        selectionMode: "all",
                        onSelectionChanged: function(e) {
                            var items = e.component.option("items"),
                                selectedItems = e.component.option("selectedItems");
                            if (!e.component._selectedItemsUpdating)
                                if (selectedItems.length === 0 && items.length) {
                                    options.filterType = "include";
                                    options.filterValues = []
                                }
                                else if (selectedItems.length === items.length) {
                                    options.filterType = "exclude";
                                    options.filterValues = []
                                }
                            $.each(items, function(index, item) {
                                var selected = $.inArray(item, selectedItems) >= 0,
                                    oldSelected = !!item.selected,
                                    filterValueIndex;
                                if (oldSelected !== selected) {
                                    item.selected = selected;
                                    options.filterValues = options.filterValues || [];
                                    filterValueIndex = $.inArray(item.filterValue, options.filterValues);
                                    if (filterValueIndex >= 0)
                                        options.filterValues.splice(filterValueIndex, 1);
                                    if (selected ^ options.filterType === "exclude")
                                        options.filterValues.push(item.filterValue)
                                }
                            })
                        },
                        onContentReady: function(e) {
                            var component = e.component,
                                items = component.option("items"),
                                selectedItems = component.option("selectedItems"),
                                selectAllCheckBox = e.element.find(".dx-list-select-all-checkbox").dxCheckBox("instance");
                            $.each(items, function() {
                                if (this.selected)
                                    selectedItems.push(this)
                            });
                            component._selectedItemsUpdating = true;
                            component.option("selectedItems", selectedItems);
                            component._selectedItemsUpdating = false;
                            if (options.filterValues && options.filterValues.length)
                                selectAllCheckBox.option("value", undefined)
                        }
                    }))
            },
            _renderCore: function(options) {
                this.element().addClass(DATAGRID_HEADER_FILTER_MENU_CLASS)
            },
            init: function() {
                this._headerFilterController = this.getController("headerFilter")
            }
        });
        var headerFilterMixin = dataGrid.headerFilterMixin = {
                _applyColumnState: function(options) {
                    var $headerFilterIndicator,
                        rootElement = options.rootElement,
                        column = options.column;
                    if (options.name === "headerFilter") {
                        rootElement.find("." + DATAGRID_HEADER_FILTER_CLASS).remove();
                        if (column.allowFiltering)
                            $headerFilterIndicator = this.callBase(options).toggleClass("dx-header-filter-empty", !column.filterValues || !column.filterValues.length);
                        return $headerFilterIndicator
                    }
                    return this.callBase(options)
                },
                _renderIndicator: function(options) {
                    var rtlEnabled,
                        $container = options.container,
                        $indicator = options.indicator;
                    if (options.name === "headerFilter") {
                        rtlEnabled = this.option("rtlEnabled");
                        if ($container.children().length && (!rtlEnabled && options.columnAlignment === "right" || rtlEnabled && options.columnAlignment === "left")) {
                            $container.prepend($indicator);
                            return
                        }
                    }
                    this.callBase(options)
                },
                optionChanged: function(args) {
                    if (args.name === "headerFilter") {
                        this._invalidate();
                        args.handled = true
                    }
                    else
                        this.callBase(args)
                }
            };
        var ColumnHeadersViewHeaderFilterExtender = $.extend({}, headerFilterMixin, {
                _renderCellContent: function($cell, options) {
                    var that = this,
                        $headerFilterIndicator,
                        column = options.column;
                    that.callBase($cell, options);
                    if (!column.command && !utils.isDefined(column.groupIndex) && column.allowFiltering && that.option("headerFilter.visible") && options.rowType === "header") {
                        $headerFilterIndicator = that._applyColumnState({
                            name: "headerFilter",
                            rootElement: $cell,
                            column: column,
                            showColumnLines: that.option("showColumnLines")
                        });
                        $headerFilterIndicator && that._subscribeToIndicatorEvent($headerFilterIndicator, column, "headerFilter")
                    }
                },
                _subscribeToIndicatorEvent: function($indicator, column, indicatorName) {
                    var that = this;
                    if (indicatorName === "headerFilter")
                        $indicator.on("dxclick", that.createAction(function(e) {
                            var event = e.jQueryEvent;
                            event.stopPropagation();
                            that.getController("headerFilter").showHeaderFilterMenu(column.index)
                        }))
                },
                _updateIndicator: function($cell, column, indicatorName) {
                    var $indicator = this.callBase($cell, column, indicatorName);
                    $indicator && this._subscribeToIndicatorEvent($indicator, column, indicatorName)
                },
                _resizeCore: function() {
                    this.callBase();
                    this._updateIndicatorHeights("headerFilter")
                },
                _columnOptionChanged: function(e) {
                    var optionNames = e.optionNames;
                    if (dataGrid.checkChanges(optionNames, ["filterValues", "filterType"])) {
                        this._updateIndicators("headerFilter");
                        return
                    }
                    this.callBase(e);
                    if (optionNames.width || optionNames.visibleWidth)
                        this._updateIndicatorHeights("headerFilter")
                },
                _afterRender: function() {
                    this.callBase.apply(this, arguments);
                    this._updateIndicatorHeights("headerFilter")
                }
            });
        var HeaderPanelHeaderFilterExtender = $.extend({}, headerFilterMixin, {
                _createGroupPanelItem: function($rootElement, groupColumn) {
                    var that = this,
                        $item = that.callBase.apply(that, arguments),
                        $headerFilterIndicator;
                    if (!groupColumn.command && groupColumn.allowFiltering && that.option("headerFilter.visible")) {
                        $headerFilterIndicator = that._applyColumnState({
                            name: "headerFilter",
                            rootElement: $item,
                            column: {
                                alignment: utils.getDefaultAlignment(that.option("rtlEnabled")),
                                filterValues: groupColumn.filterValues,
                                allowFiltering: groupColumn.allowFiltering
                            },
                            showColumnLines: true
                        });
                        $headerFilterIndicator && $headerFilterIndicator.on("dxclick", that.createAction(function(e) {
                            var event = e.jQueryEvent;
                            event.stopPropagation();
                            that.getController("headerFilter").showHeaderFilterMenu(groupColumn.index)
                        }))
                    }
                    return $item
                },
                _renderGroupPanelItems: function($groupPanel, groupColumns) {
                    this.callBase.apply(this, arguments);
                    this._updateIndicatorHeights("headerFilter")
                },
                _resizeCore: function() {
                    this.callBase();
                    this._updateIndicatorHeights("headerFilter")
                }
            });
        var DataControllerFilterRowExtender = {_calculateAdditionalFilter: function() {
                    var that = this,
                        filters = [that.callBase()],
                        columns = that._columnsController.getVisibleColumns(),
                        headerFilterController = that.getController("headerFilter"),
                        currentColumn = headerFilterController.getCurrentColumn();
                    if (currentColumn && currentColumn.filterValues && currentColumn.filterValues.length)
                        return;
                    $.each(columns, function(_, column) {
                        var filter;
                        if (column.allowFiltering && column.calculateFilterExpression && utils.isArray(column.filterValues) && column.filterValues.length) {
                            var filterValues = [];
                            var isExclude = column.filterType === "exclude";
                            $.each(column.filterValues, function(_, filterValue) {
                                var value = filterValue,
                                    values,
                                    filterIntervals,
                                    dateInterval;
                                if (column.dataType === "date" && utils.isDefined(value)) {
                                    values = ("" + value).split("/");
                                    filterIntervals = ["year", "month", "day"];
                                    dateInterval = filterIntervals[values.length - 1];
                                    value = new Date(values[0], (values[1] || 1) - 1, values[2] || 1)
                                }
                                else if (column.deserializeValue)
                                    value = column.deserializeValue(value);
                                filter = column.calculateFilterExpression(value, isExclude ? "<>" : "=", dateInterval);
                                if (filterValues.length > 0)
                                    filterValues.push(isExclude ? "and" : "or");
                                filterValues.push(filter)
                            });
                            filters.push(filterValues)
                        }
                    });
                    return dataGrid.combineFilters(filters)
                }};
        dataGrid.registerModule("headerFilter", {
            defaultOptions: function() {
                return {headerFilter: {
                            visible: false,
                            width: 252,
                            height: 300,
                            texts: {
                                emptyValue: Globalize.localize("dxDataGrid-headerFilterEmptyValue"),
                                ok: Globalize.localize("dxDataGrid-headerFilterOK"),
                                cancel: Globalize.localize("dxDataGrid-headerFilterCancel")
                            }
                        }}
            },
            controllers: {headerFilter: dataGrid.HeaderFilterController},
            views: {headerFilterView: dataGrid.HeaderFilterView},
            extenders: {
                controllers: {data: DataControllerFilterRowExtender},
                views: {
                    columnHeadersView: ColumnHeadersViewHeaderFilterExtender,
                    headerPanel: HeaderPanelHeaderFilterExtender
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_HEADER_FILTER_CLASS: DATAGRID_HEADER_FILTER_CLASS,
            DATAGRID_HEADER_FILTER_MENU_CLASS: DATAGRID_HEADER_FILTER_MENU_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.sortingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            events = ui.events,
            utils = DX.utils;
        var DATAGRID_SORT_CLASS = "dx-sort",
            DATAGRID_SORTUP_CLASS = "dx-sort-up",
            DATAGRID_SORTDOWN_CLASS = "dx-sort-down",
            DATAGRID_HEADERS_ACTION_CLASS = "dx-datagrid-action",
            DATAGRID_COLUMN_INDICATORS_CLASS = "dx-column-indicators",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            COLUMN_HEADERS_VIEW_NAMESPACE = "dxDataGridColumnHeadersView";
        var sortingMixin = dataGrid.sortingMixin = {
                _applyColumnState: function(options) {
                    var that = this,
                        side,
                        sortingMode = that.option("sorting.mode"),
                        rootElement = options.rootElement,
                        column = options.column,
                        $indicatorsContainer = rootElement.find("." + DATAGRID_COLUMN_INDICATORS_CLASS);
                    if (options.name === "sort") {
                        side = that.option("rtlEnabled") ? "right" : "left";
                        if ((sortingMode === "single" || sortingMode === "multiple") && column.allowSorting)
                            options.rootElement.addClass(DATAGRID_HEADERS_ACTION_CLASS);
                        rootElement.find("." + DATAGRID_SORT_CLASS).remove();
                        !$indicatorsContainer.children().length && $indicatorsContainer.remove();
                        rootElement.children("." + DATAGRID_CELL_CONTENT_CLASS).css("margin-" + side, "");
                        if (utils.isDefined(column.sortOrder)) {
                            var ariaSortState = column.sortOrder === "asc" ? "ascending" : "descending";
                            that.setAria("sort", ariaSortState, rootElement);
                            var $sortIndicator = that.callBase(options).toggleClass(DATAGRID_SORTUP_CLASS, column.sortOrder === "asc").toggleClass(DATAGRID_SORTDOWN_CLASS, column.sortOrder === "desc");
                            if (column.alignment === "center")
                                rootElement.children("." + DATAGRID_CELL_CONTENT_CLASS).css("margin-" + side, $sortIndicator.outerWidth(true));
                            return $sortIndicator
                        }
                        else
                            that.setAria("sort", "none", rootElement)
                    }
                    else
                        return that.callBase(options)
                },
                _renderIndicator: function(options) {
                    var rtlEnabled,
                        $container = options.container,
                        $indicator = options.indicator;
                    if (options.name === "sort") {
                        rtlEnabled = this.option("rtlEnabled");
                        if ($container.children().length && (!rtlEnabled && options.columnAlignment === "left" || rtlEnabled && options.columnAlignment === "right")) {
                            $container.prepend($indicator);
                            return
                        }
                    }
                    this.callBase(options)
                },
                _updateIndicator: function($cell, column, indicatorName) {
                    if (indicatorName === "sort" && utils.isDefined(column.groupIndex))
                        return;
                    this.callBase.apply(this, arguments)
                }
            };
        var ColumnHeadersViewSortingExtender = $.extend({}, sortingMixin, {
                _renderCellContent: function($cell, options) {
                    var that = this,
                        column = options.column;
                    that.callBase($cell, options);
                    if (!column.command && options.rowType === "header") {
                        $cell.on(events.addNamespace("dxpointerdown", COLUMN_HEADERS_VIEW_NAMESPACE), that.createAction(function(e) {
                            e.jQueryEvent.preventDefault()
                        })).on(events.addNamespace("dxclick", COLUMN_HEADERS_VIEW_NAMESPACE), that.createAction(function(e) {
                            var keyName = null,
                                event = e.jQueryEvent;
                            setTimeout(function() {
                                if (event.shiftKey)
                                    keyName = "shift";
                                else if (event.ctrlKey)
                                    keyName = "ctrl";
                                if (column && !utils.isDefined(column.groupIndex))
                                    that._columnsController.changeSortOrder(column.index, keyName)
                            })
                        }));
                        that._applyColumnState({
                            name: "sort",
                            rootElement: $cell,
                            column: column,
                            showColumnLines: that.option("showColumnLines")
                        })
                    }
                },
                _columnOptionChanged: function(e) {
                    var changeTypes = e.changeTypes,
                        optionNames = e.optionNames;
                    if (changeTypes.length === 1 && changeTypes.sorting) {
                        this._updateIndicators("sort");
                        return
                    }
                    this.callBase(e);
                    if (optionNames.width || optionNames.visibleWidth)
                        this._updateIndicatorHeights("sort")
                },
                _resizeCore: function() {
                    this.callBase();
                    this._updateIndicatorHeights("sort")
                },
                _afterRender: function() {
                    this.callBase.apply(this, arguments);
                    this._updateIndicatorHeights("sort")
                },
                optionChanged: function(args) {
                    var that = this;
                    switch (args.name) {
                        case"sorting":
                            that._invalidate();
                            args.handled = true;
                            break;
                        default:
                            that.callBase(args)
                    }
                }
            });
        var HeaderPanelSortingExtender = $.extend({}, sortingMixin, {
                _createGroupPanelItem: function($rootElement, groupColumn) {
                    var that = this,
                        $item = that.callBase.apply(that, arguments);
                    $item.on(events.addNamespace("dxclick", "dxDataGridHeaderPanel"), that.createAction(function(e) {
                        setTimeout(function() {
                            that.getController("columns").changeSortOrder(groupColumn.index)
                        })
                    }));
                    that._applyColumnState({
                        name: "sort",
                        rootElement: $item,
                        column: {
                            alignment: that.option("rtlEnabled") ? "right" : "left",
                            allowSorting: groupColumn.allowSorting,
                            sortOrder: groupColumn.sortOrder === "desc" ? "desc" : "asc"
                        },
                        showColumnLines: true
                    });
                    return $item
                },
                _renderGroupPanelItems: function($groupPanel, groupColumns) {
                    this.callBase.apply(this, arguments);
                    this._updateIndicatorHeights("sort")
                },
                _resizeCore: function() {
                    this.callBase();
                    this._updateIndicatorHeights("sort")
                },
                optionChanged: function(args) {
                    var that = this;
                    switch (args.name) {
                        case"sorting":
                            that._invalidate();
                            args.handled = true;
                            break;
                        default:
                            that.callBase(args)
                    }
                }
            });
        dataGrid.registerModule("sorting", {
            defaultOptions: function() {
                return {sorting: {
                            mode: "single",
                            ascendingText: Globalize.localize("dxDataGrid-sortingAscendingText"),
                            descendingText: Globalize.localize("dxDataGrid-sortingDescendingText"),
                            clearText: Globalize.localize("dxDataGrid-sortingClearText")
                        }}
            },
            extenders: {views: {
                    columnHeadersView: ColumnHeadersViewSortingExtender,
                    headerPanel: HeaderPanelSortingExtender
                }}
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_SORT_CLASS: DATAGRID_SORT_CLASS,
            DATAGRID_SORTUP_CLASS: DATAGRID_SORTUP_CLASS,
            DATAGRID_SORTDOWN_CLASS: DATAGRID_SORTDOWN_CLASS,
            DATAGRID_HEADERS_ACTION_CLASS: DATAGRID_HEADERS_ACTION_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.search.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_SEARCH_PANEL_CLASS = "dx-datagrid-search-panel",
            DATAGRID_SEARCH_TEXT_CLASS = "dx-datagrid-search-text",
            FILTERING_TIMEOUT = 700;
        function allowSearch(column) {
            return utils.isDefined(column.allowSearch) ? column.allowSearch : column.allowFiltering
        }
        function parseValue(column, text) {
            var lookup = column.lookup;
            if (lookup && lookup.items)
                return column.parseValue.call(lookup, text);
            else
                return column.parseValue ? column.parseValue(text) : text
        }
        dataGrid.registerModule("search", {
            defaultOptions: function() {
                return {searchPanel: {
                            visible: false,
                            width: 160,
                            placeholder: Globalize.localize("dxDataGrid-searchPanelPlaceholder"),
                            highlightSearchText: true,
                            text: ""
                        }}
            },
            extenders: {
                controllers: {data: function() {
                        var calculateSearchFilter = function(that, text) {
                                var i,
                                    column,
                                    columns = that._columnsController.getColumns(),
                                    filterValue,
                                    lookup,
                                    filters = [];
                                if (!text)
                                    return null;
                                function onQueryDone(items) {
                                    var i,
                                        valueGetter = DX.data.utils.compileGetter(lookup.valueExpr),
                                        value;
                                    for (i = 0; i < items.length; i++) {
                                        value = valueGetter(items[i]);
                                        filters.push(column.calculateFilterExpression(value))
                                    }
                                }
                                for (i = 0; i < columns.length; i++) {
                                    column = columns[i];
                                    if (allowSearch(column) && column.calculateFilterExpression) {
                                        lookup = column.lookup;
                                        filterValue = parseValue(column, text);
                                        if (lookup && lookup.items)
                                            DX.data.query(lookup.items).filter(column.calculateFilterExpression.call({
                                                dataField: lookup.displayExpr,
                                                dataType: lookup.dataType
                                            }, filterValue)).enumerate().done(onQueryDone);
                                        else if (filterValue !== undefined)
                                            filters.push(column.calculateFilterExpression(filterValue))
                                    }
                                }
                                return dataGrid.combineFilters(filters, "or")
                            };
                        return {
                                publicMethods: function() {
                                    return this.callBase().concat(["searchByText"])
                                },
                                _calculateAdditionalFilter: function() {
                                    var that = this,
                                        filter = that.callBase(),
                                        searchFilter = calculateSearchFilter(that, that.option("searchPanel.text"));
                                    return dataGrid.combineFilters([filter, searchFilter])
                                },
                                searchByText: function(text) {
                                    this.option("searchPanel.text", text)
                                },
                                optionChanged: function(args) {
                                    var that = this;
                                    switch (args.fullName) {
                                        case"searchPanel.text":
                                        case"searchPanel":
                                            that._applyFilter();
                                            args.handled = true;
                                            break;
                                        default:
                                            that.callBase(args)
                                    }
                                }
                            }
                    }()},
                views: {
                    headerPanel: function() {
                        var getSearchPanelOptions = function(that) {
                                return that.option("searchPanel")
                            };
                        return {
                                _renderSearchPanel: function() {
                                    var that = this,
                                        $element = that.element(),
                                        dataController = that.getController("data"),
                                        searchPanelOptions = getSearchPanelOptions(that);
                                    if (searchPanelOptions && searchPanelOptions.visible) {
                                        if (!that._$searchPanel) {
                                            that._$searchPanel = $("<div/>").addClass(DATAGRID_SEARCH_PANEL_CLASS).prependTo($element);
                                            that.setAria("label", Globalize.localize("dxDataGrid-ariaSearchInGrid"), that._$searchPanel)
                                        }
                                        else
                                            that._$searchPanel.show();
                                        that.getController("editorFactory").createEditor(that._$searchPanel, {
                                            width: searchPanelOptions.width,
                                            placeholder: searchPanelOptions.placeholder,
                                            parentType: "searchPanel",
                                            value: that.option("searchPanel.text"),
                                            updateValueTimeout: FILTERING_TIMEOUT,
                                            setValue: function(value) {
                                                dataController.searchByText(value)
                                            }
                                        });
                                        that.resize()
                                    }
                                    else
                                        that._$searchPanel && that._$searchPanel.hide()
                                },
                                _renderCore: function() {
                                    this.callBase();
                                    this._renderSearchPanel()
                                },
                                focus: function() {
                                    var textBox = this._$searchPanel.dxTextBox("instance");
                                    if (textBox)
                                        textBox.focus()
                                },
                                isVisible: function() {
                                    var searchPanelOptions = getSearchPanelOptions(this);
                                    return this.callBase() || searchPanelOptions && searchPanelOptions.visible
                                },
                                optionChanged: function(args) {
                                    if (args.name === "searchPanel") {
                                        this._renderSearchPanel();
                                        args.handled = true
                                    }
                                    else
                                        this.callBase(args)
                                }
                            }
                    }(),
                    rowsView: {
                        _highlightSearchText: function(cellElement, isEquals, column) {
                            var that = this,
                                $parent,
                                searchHTML,
                                searchText = that.option("searchPanel.text");
                            if (searchText && that.option("searchPanel.highlightSearchText")) {
                                if (isEquals && column) {
                                    var value = parseValue(column, searchText);
                                    searchText = dataGrid.formatValue(value, column);
                                    if (!searchText)
                                        return
                                }
                                searchHTML = $("<div>").text(searchText).html();
                                $parent = cellElement.parent();
                                if (!$parent.length)
                                    $parent = $("<div>").append(cellElement);
                                $.each($parent.find(":dxicontains('" + searchText + "')"), function(index, element) {
                                    $.each($(element).contents(), function(index, content) {
                                        if (content.nodeType !== 3)
                                            return;
                                        var highlightSearchTextInTextNode = function($content, searchText) {
                                                var $searchTextSpan = $("<span />").addClass(DATAGRID_SEARCH_TEXT_CLASS),
                                                    text = $content.text(),
                                                    index = text.toLowerCase().indexOf(searchText.toLowerCase());
                                                if (index >= 0) {
                                                    if ($content[0].textContent)
                                                        $content[0].textContent = text.substr(0, index);
                                                    else
                                                        $content[0].nodeValue = text.substr(0, index);
                                                    $content.after($searchTextSpan.text(text.substr(index, searchText.length)));
                                                    $content = $(document.createTextNode(text.substr(index + searchText.length))).insertAfter($searchTextSpan);
                                                    return highlightSearchTextInTextNode($content, searchText)
                                                }
                                            };
                                        if (isEquals) {
                                            if ($(content).text().toLowerCase() === searchText.toLowerCase())
                                                $(this).replaceWith($("<span />").addClass(DATAGRID_SEARCH_TEXT_CLASS).text($(content).text()))
                                        }
                                        else
                                            highlightSearchTextInTextNode($(content), searchText)
                                    })
                                })
                            }
                        },
                        _renderCore: function($table, options) {
                            this.callBase.apply(this, arguments);
                            if (this.option("rowTemplate"))
                                this._highlightSearchText(this._getTableElement())
                        },
                        _updateCell: function($cell, parameters) {
                            var that = this,
                                column = parameters.column,
                                isEquals = column.dataType !== "string";
                            if (allowSearch(column))
                                that._highlightSearchText($cell, isEquals, column);
                            that.callBase($cell, parameters)
                        }
                    }
                }
            }
        });
        dataGrid.__internals = $.extend({}, dataGrid.__internals, {
            DATAGRID_SEARCH_PANEL_CLASS: DATAGRID_SEARCH_PANEL_CLASS,
            DATAGRID_SEARCH_TEXT_CLASS: DATAGRID_SEARCH_TEXT_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.rowsView.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
            DATAGRID_ROWS_VIEW_CLASS = "dx-datagrid-rowsview",
            DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_DATA_ROW_CLASS = "dx-data-row",
            DATAGRID_FREESPACE_CLASS = "dx-freespace-row",
            DATAGRID_NODATA_TEXT_CLASS = "dx-datagrid-nodata",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_NOWRAP_CLASS = "dx-datagrid-nowrap",
            DATAGRID_ROW_LINES_CLASS = "dx-row-lines",
            DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
            DATAGRID_ROW_ALTERNATION_CLASS = "dx-row-alt",
            DATAGRID_LAST_ROW_BORDER = "dx-last-row-border",
            DATAGRID_LOADPANEL_HIDE_TIMEOUT = 200;
        var createScrollableOptions = function(that) {
                var useNativeScrolling = that.option("scrolling.useNativeScrolling");
                var options = {
                        direction: "both",
                        bounceEnabled: false,
                        useKeyboard: false
                    };
                if (useNativeScrolling === undefined)
                    useNativeScrolling = true;
                if (useNativeScrolling !== "auto") {
                    options.useNative = !!useNativeScrolling;
                    options.useSimulatedScrollbar = !useNativeScrolling
                }
                return options
            };
        dataGrid.createScrollableOptions = createScrollableOptions;
        dataGrid.RowsView = dataGrid.ColumnsView.inherit({
            _getDefaultTemplate: function(column) {
                switch (column.command) {
                    case"empty":
                        return function(container) {
                                container.html("&nbsp;")
                            };
                    default:
                        return function(container, options) {
                                var isDataTextEmpty = !options.text && options.rowType === "data",
                                    text = isDataTextEmpty ? "&nbsp;" : options.text;
                                if (column.encodeHtml && !isDataTextEmpty)
                                    container.text(text);
                                else
                                    container.html(text)
                            }
                }
            },
            _getDefaultGroupTemplate: function() {
                var that = this,
                    summaryTexts = that.option("summary.texts");
                return function(container, options) {
                        var data = options.data,
                            text = options.column.caption + ": " + options.text;
                        if (options.summaryItems && options.summaryItems.length)
                            text += " " + dataGrid.getGroupRowSummaryText(options.summaryItems, summaryTexts);
                        if (data)
                            if (options.groupContinuedMessage && options.groupContinuesMessage)
                                text += " (" + options.groupContinuedMessage + ". " + options.groupContinuesMessage + ")";
                            else if (options.groupContinuesMessage)
                                text += " (" + options.groupContinuesMessage + ")";
                            else if (options.groupContinuedMessage)
                                text += " (" + options.groupContinuedMessage + ")";
                        container.addClass("dx-group-cell");
                        container.text(text)
                    }
            },
            _update: function(change){},
            _getColumnTemplate: function(options) {
                var that = this,
                    column = options.column,
                    template;
                if (options.rowType === "group" && column.groupIndex !== undefined && !column.showWhenGrouped)
                    template = column.groupCellTemplate || {
                        allowRenderToDetachedContainer: true,
                        render: that._getDefaultGroupTemplate()
                    };
                else
                    template = column.cellTemplate || {
                        allowRenderToDetachedContainer: true,
                        render: that._getDefaultTemplate(column)
                    };
                return template
            },
            _getCellTemplate: function(options) {
                return this._getColumnTemplate(options)
            },
            _createRow: function(row) {
                var $row = this.callBase(row),
                    isGroup,
                    isDataRow,
                    isRowExpanded;
                if (row) {
                    isGroup = row.rowType === "group";
                    isDataRow = row.rowType === "data";
                    $row.toggleClass(DATAGRID_DATA_ROW_CLASS, isDataRow).toggleClass(DATAGRID_ROW_ALTERNATION_CLASS, isDataRow && row.dataIndex % 2 === 1 && this.option("rowAlternationEnabled")).toggleClass(DATAGRID_ROW_LINES_CLASS, isDataRow && this.option("showRowLines")).toggleClass(DATAGRID_COLUMN_LINES_CLASS, this.option("showColumnLines")).toggleClass(DATAGRID_GROUP_ROW_CLASS, isGroup);
                    if (isGroup) {
                        isRowExpanded = row.isExpanded;
                        this.setAria({
                            role: "rowgroup",
                            expanded: utils.isDefined(isRowExpanded) && isRowExpanded.toString()
                        }, $row)
                    }
                }
                return $row
            },
            _createTable: function() {
                var that = this;
                return that.callBase.apply(that, arguments).on("dxclick", ".dx-row", that.createAction(function(e) {
                        var jQueryEvent = e.jQueryEvent;
                        if (!$(jQueryEvent.target).closest("a").length) {
                            e.rowIndex = that.getRowIndex(jQueryEvent.currentTarget);
                            e.rowElement = $(jQueryEvent.currentTarget);
                            that._rowClick(e)
                        }
                    }))
            },
            _renderScrollable: function($table) {
                var that = this,
                    $element = that.element();
                if (!$element.children().length)
                    $element.append("<div />");
                that._renderLoadPanel($element);
                that._renderScrollableCore($element)
            },
            _handleScroll: function(e) {
                var that = this;
                that._scrollTop = e.scrollOffset.top;
                that._scrollLeft = e.scrollOffset.left;
                that.scrollChanged.fire(e.scrollOffset, that.name)
            },
            _renderScrollableCore: function($element) {
                var that = this,
                    dxScrollableOptions = createScrollableOptions(that),
                    scrollHandler = $.proxy(that._handleScroll, that);
                dxScrollableOptions.onScroll = scrollHandler;
                dxScrollableOptions.onStop = scrollHandler;
                that._scrollable = that._createComponent($element, "dxScrollable", dxScrollableOptions);
                that._scrollableContainer = that._scrollable._$container
            },
            _renderLoadPanel: function($element) {
                var that = this,
                    loadPanelOptions;
                if ($element.dxLoadPanel) {
                    that._loadPanel && that._loadPanel.element().remove();
                    loadPanelOptions = that.option("loadPanel");
                    if (loadPanelOptions && loadPanelOptions.enabled) {
                        loadPanelOptions = $.extend({
                            shading: false,
                            message: loadPanelOptions.text,
                            position: {of: $element},
                            container: $element
                        }, loadPanelOptions);
                        that._loadPanel = that._createComponent($("<div />").appendTo($element.parent()), "dxLoadPanel", loadPanelOptions)
                    }
                    else
                        that._loadPanel = null
                }
            },
            _renderContent: function(contentElement, tableElement) {
                contentElement.replaceWith($("<div>").addClass(DATAGRID_CONTENT_CLASS).append(tableElement));
                return this._findContentElement()
            },
            _updateContent: function(contentElement, change, newTableElement) {
                var that = this,
                    tableElement = that._getTableElement(),
                    changeType = change && change.changeType,
                    executors = [];
                switch (changeType) {
                    case"update":
                        $.each(change.rowIndices, function(index, rowIndex) {
                            var $newRowElement = that._getRowElements(newTableElement).eq(index),
                                changeType = change.changeTypes[index],
                                item = change.items && change.items[index];
                            executors.push(function() {
                                var $rowsElement = that._getRowElements(),
                                    $rowElement = $rowsElement.eq(rowIndex);
                                switch (changeType) {
                                    case"update":
                                        if (utils.isDefined(item.visible) && item.visible !== $rowElement.is(":visible"))
                                            $rowElement.toggle(item.visible);
                                        else
                                            $rowElement.replaceWith($newRowElement);
                                        break;
                                    case"insert":
                                        if (!$rowsElement.length)
                                            $newRowElement.prependTo(tableElement);
                                        else if ($rowElement.length)
                                            $newRowElement.insertBefore($rowElement);
                                        else
                                            $newRowElement.insertAfter($rowsElement.last());
                                        break;
                                    case"remove":
                                        $rowElement.remove();
                                        break
                                }
                            })
                        });
                        $.each(executors, function() {
                            this()
                        });
                        break;
                    default:
                        that._setTableElement(newTableElement);
                        contentElement.addClass(DATAGRID_CONTENT_CLASS);
                        that._renderContent(contentElement, newTableElement);
                        break
                }
            },
            _renderFreeSpaceRow: function(tableElement) {
                var that = this,
                    i,
                    freeSpaceRowElement = that._createRow(),
                    columns = this.getColumns();
                freeSpaceRowElement.addClass(DATAGRID_FREESPACE_CLASS).toggleClass(DATAGRID_COLUMN_LINES_CLASS, that.option("showColumnLines"));
                for (i = 0; i < columns.length; i++)
                    freeSpaceRowElement.append(that._createCell(columns[i]));
                that._appendRow(tableElement, freeSpaceRowElement)
            },
            _needUpdateRowHeight: function(itemsCount) {
                return itemsCount > 0 && !this._rowHeight
            },
            _updateRowHeight: function() {
                var that = this,
                    tableElement = that._getTableElement(),
                    tableHeight,
                    itemsCount = that._dataController.items().length,
                    $freeSpaceRowElement;
                if (tableElement && that._needUpdateRowHeight(itemsCount)) {
                    tableHeight = tableElement.outerHeight();
                    $freeSpaceRowElement = that._getFreeSpaceRowElements().first();
                    if ($freeSpaceRowElement && $freeSpaceRowElement.is(":visible"))
                        tableHeight -= $freeSpaceRowElement.outerHeight();
                    that._rowHeight = tableHeight / itemsCount
                }
            },
            _findContentElement: function() {
                var $element = this.element(),
                    $scrollableContent;
                if ($element) {
                    $scrollableContent = $element.find(".dx-scrollable-content");
                    if (!$scrollableContent)
                        $scrollableContent = $element;
                    return $scrollableContent.children().first()
                }
            },
            _getRowElements: function(tableElement) {
                var $rows = this.callBase(tableElement);
                return $rows && $rows.not("." + DATAGRID_FREESPACE_CLASS)
            },
            _getFreeSpaceRowElements: function() {
                var tableElements = this.getTableElements();
                return tableElements && tableElements.children("tbody").children("." + DATAGRID_FREESPACE_CLASS)
            },
            _getNoDataText: function() {
                return this.option("noDataText")
            },
            _updateNoDataText: function($element) {
                $element = $element || this.element();
                var noDataElement = $element.find("." + DATAGRID_NODATA_TEXT_CLASS),
                    isVisible = this._dataController.isEmpty(),
                    isLoading = this._dataController.isLoading(),
                    rtlEnabled = this.option("rtlEnabled");
                if (!noDataElement.length)
                    noDataElement = $("<span>").addClass(DATAGRID_NODATA_TEXT_CLASS).appendTo($element);
                if (isVisible && !isLoading)
                    noDataElement.text(this._getNoDataText()).css({
                        marginTop: -Math.floor(noDataElement.height() / 2),
                        marginRight: rtlEnabled ? -Math.floor(noDataElement.width() / 2) : 0,
                        marginLeft: rtlEnabled ? 0 : -Math.floor(noDataElement.width() / 2)
                    }).removeClass("dx-hidden");
                else
                    noDataElement.addClass("dx-hidden")
            },
            _rowClick: function(e) {
                var item = this._dataController.items()[e.rowIndex] || {};
                this.executeAction("onRowClick", $.extend({
                    columns: this.getColumns(),
                    evaluate: function(expr) {
                        var getter = DX.data.utils.compileGetter(expr);
                        return getter(item.data)
                    }
                }, e, item))
            },
            _getGroupCellOptions: function(options) {
                var columnIndex = (options.row.groupIndex || 0) + options.columnsCountBeforeGroups;
                return {
                        columnIndex: columnIndex,
                        colspan: options.columns.length - columnIndex - 1
                    }
            },
            _renderCells: function($row, options) {
                if (options.row.rowType === "group")
                    this._renderGroupedCells($row, options);
                else if (options.row.values)
                    this.callBase($row, options)
            },
            _renderGroupedCells: function($row, options) {
                var $groupCell,
                    row = options.row,
                    i,
                    columns = options.columns,
                    rowIndex = row.rowIndex,
                    isExpanded,
                    groupColumn,
                    groupColumnAlignment,
                    groupCellOptions = this._getGroupCellOptions(options);
                for (i = 0; i <= groupCellOptions.columnIndex; i++) {
                    if (i === groupCellOptions.columnIndex && columns[i].allowCollapsing && options.scrollingMode !== "infinite")
                        isExpanded = !!row.isExpanded;
                    else
                        isExpanded = null;
                    this._renderCell($row, {
                        value: isExpanded,
                        row: row,
                        rowIndex: rowIndex,
                        column: {
                            command: "expand",
                            cssClass: columns[i].cssClass
                        },
                        columnIndex: i
                    })
                }
                groupColumnAlignment = utils.getDefaultAlignment(this.option("rtlEnabled"));
                groupColumn = $.extend({}, columns[groupCellOptions.columnIndex], {
                    command: null,
                    cssClass: null,
                    showWhenGrouped: false,
                    alignment: groupColumnAlignment
                });
                $groupCell = this._renderCell($row, {
                    value: row.values[row.groupIndex],
                    row: row,
                    rowIndex: rowIndex,
                    column: groupColumn,
                    columnIndex: groupCellOptions.columnIndex
                });
                $groupCell.attr("colspan", groupCellOptions.colspan)
            },
            _renderRows: function($table, options) {
                var that = this,
                    i,
                    columns = options.columns,
                    columnsCountBeforeGroups = 0,
                    scrollingMode = that.option("scrolling.mode");
                for (i = 0; i < columns.length; i++)
                    if (columns[i].command === "expand") {
                        columnsCountBeforeGroups = i;
                        break
                    }
                that.callBase($table, $.extend({
                    scrollingMode: scrollingMode,
                    columnsCountBeforeGroups: columnsCountBeforeGroups
                }, options));
                that._renderFreeSpaceRow($table)
            },
            _renderRow: function($table, options) {
                var that = this,
                    row = options.row,
                    rowTemplate = that.option("rowTemplate");
                if ((row.rowType === "data" || row.rowType === "group") && !utils.isDefined(row.groupIndex) && rowTemplate)
                    that._renderTemplate($table, rowTemplate, $.extend({columns: options.columns}, row));
                else
                    that.callBase($table, options)
            },
            _renderTable: function(options) {
                var $table = this.callBase(options);
                if (!utils.isDefined(this._getTableElement())) {
                    this._setTableElement($table);
                    this._renderScrollable($table)
                }
                return $table
            },
            _renderCore: function(change) {
                var that = this,
                    $table,
                    $content,
                    $element = that.element();
                $element.addClass(DATAGRID_ROWS_VIEW_CLASS).toggleClass(DATAGRID_NOWRAP_CLASS, !that.option("wordWrapEnabled"));
                $table = that._renderTable({change: change});
                $content = that._findContentElement();
                that._updateContent($content, change, $table);
                that.callBase(change);
                that._lastColumnWidths = null
            },
            _getRows: function(change) {
                return change && change.items || this._dataController.items()
            },
            _getCellOptions: function(options) {
                var that = this,
                    parameters,
                    column = options.column,
                    row = options.row,
                    data = row.data,
                    summaryCells = row && row.summaryCells,
                    value = options.value,
                    displayValue = dataGrid.getDisplayValue(column, value),
                    groupingOptions = that.option("grouping"),
                    scrollingMode = that.option("scrolling.mode");
                parameters = $.extend(this.callBase(options), {
                    value: value,
                    displayValue: displayValue,
                    row: row,
                    key: row.key,
                    data: data,
                    rowType: row.rowType,
                    values: row.values,
                    text: !utils.isDefined(column.command) && dataGrid.formatValue(displayValue, column),
                    rowIndex: row.rowIndex,
                    summaryItems: summaryCells && summaryCells[options.columnIndex],
                    resized: column.resizedCallbacks
                });
                if (utils.isDefined(column.groupIndex) && scrollingMode !== "virtual" && scrollingMode !== "infinite") {
                    parameters.groupContinuesMessage = data && data.isContinuationOnNextPage && groupingOptions && groupingOptions.groupContinuesMessage;
                    parameters.groupContinuedMessage = data && data.isContinuation && groupingOptions && groupingOptions.groupContinuedMessage
                }
                return parameters
            },
            getRow: function(index) {
                var rows = this._getRowElements();
                if (rows.length > index)
                    return $(rows[index])
            },
            getCell: function(cellPosition, rows) {
                var $rows = rows || this._getRowElements(),
                    cells;
                if ($rows.length > 0 && cellPosition.rowIndex >= 0) {
                    cellPosition.rowIndex = cellPosition.rowIndex < $rows.length ? cellPosition.rowIndex : $rows.length - 1;
                    cells = $rows[cellPosition.rowIndex].cells;
                    if (cells && cells.length > 0)
                        return $(cells[cells.length > cellPosition.columnIndex ? cellPosition.columnIndex : cells.length - 1])
                }
            },
            getCellIndex: function($cell) {
                var cellIndex = $cell.length ? $cell[0].cellIndex : -1;
                return cellIndex
            },
            updateFreeSpaceRowHeight: function() {
                var that = this,
                    elementHeight,
                    contentElement = that._findContentElement(),
                    freeSpaceRowElements = that._getFreeSpaceRowElements(),
                    contentHeight = 0,
                    freespaceRowCount,
                    scrollingMode,
                    resultHeight;
                if (freeSpaceRowElements && contentElement) {
                    freeSpaceRowElements.hide();
                    elementHeight = that.element().height();
                    contentHeight = contentElement.outerHeight();
                    resultHeight = elementHeight - contentHeight - that.getScrollbarWidth(true);
                    if (that._dataController.items().length > 0) {
                        if (resultHeight > 0 || !that._dataController.items().length) {
                            freeSpaceRowElements.height(resultHeight);
                            freeSpaceRowElements.show()
                        }
                        else if (!that._hasHeight) {
                            freespaceRowCount = that._dataController.pageSize() - that._dataController.items().length;
                            scrollingMode = that.option("scrolling.mode");
                            if (freespaceRowCount > 0 && that._dataController.pageCount() > 1 && scrollingMode !== "virtual" && scrollingMode !== "infinite") {
                                freeSpaceRowElements.height(freespaceRowCount * that._rowHeight);
                                freeSpaceRowElements.show()
                            }
                        }
                    }
                    else {
                        freeSpaceRowElements.height(0);
                        freeSpaceRowElements.show()
                    }
                }
            },
            _columnOptionChanged: function(e) {
                var optionNames = e.optionNames;
                if (e.changeTypes.grouping)
                    return;
                if (optionNames.width || optionNames.visibleWidth) {
                    this.callBase(e);
                    this._fireColumnResizedCallbacks()
                }
            },
            getScrollable: function() {
                return this._scrollable
            },
            init: function() {
                var that = this,
                    dataController = that.getController("data");
                that.callBase();
                that._editorFactoryController = that.getController("editorFactory");
                that._rowHeight = 0;
                that._scrollTop = 0;
                that._scrollLeft = 0;
                that._hasHeight = false;
                dataController.loadingChanged.add(function(isLoading, messageText) {
                    that.setLoading(isLoading, messageText)
                });
                that.createAction("onRowClick");
                var scrollToCurrentPageHandler = function() {
                        that.scrollToPage(dataController.pageIndex())
                    };
                dataController.pageChanged.add(scrollToCurrentPageHandler);
                dataController.dataSourceChanged.add(function() {
                    that._handleScroll({scrollOffset: {
                            top: that._scrollTop,
                            left: that._scrollLeft
                        }})
                })
            },
            _handleDataChanged: function(change) {
                var that = this;
                switch (change.changeType) {
                    case"refresh":
                    case"prepend":
                    case"append":
                    case"update":
                        that.render(null, change);
                        break;
                    default:
                        that._update(change);
                        break
                }
            },
            publicMethods: function() {
                return ["isScrollbarVisible", "getTopVisibleRowData", "getScrollbarWidth", "getCellElement"]
            },
            contentWidth: function() {
                return this.element().width() - this.getScrollbarWidth()
            },
            getScrollbarWidth: function(isHorizontal) {
                var scrollableContainer = this._scrollableContainer && this._scrollableContainer.get(0),
                    scrollbarWidth = 0;
                if (scrollableContainer)
                    if (!isHorizontal)
                        scrollbarWidth = scrollableContainer.offsetWidth - scrollableContainer.clientWidth;
                    else
                        scrollbarWidth = scrollableContainer.offsetHeight - scrollableContainer.clientHeight;
                return scrollbarWidth
            },
            _fireColumnResizedCallbacks: function() {
                var that = this,
                    lastColumnWidths = that._lastColumnWidths || [],
                    columnWidths = [],
                    columns = that.getColumns(),
                    i;
                for (i = 0; i < columns.length; i++) {
                    columnWidths[i] = columns[i].visibleWidth;
                    if (columns[i].resizedCallbacks && !utils.isDefined(columns[i].groupIndex) && lastColumnWidths[i] !== columnWidths[i])
                        columns[i].resizedCallbacks.fire(columnWidths[i])
                }
                that._lastColumnWidths = columnWidths
            },
            _updateLastRowBorder: function() {
                var $freeSpaceRow = this._getFreeSpaceRowElements().first(),
                    isFreeSpaceRowHidden = $freeSpaceRow.css("display") === "none";
                if (this.option("showBorders") && this.option("showRowLines") && isFreeSpaceRowHidden)
                    this.element().addClass(DATAGRID_LAST_ROW_BORDER)
            },
            _resizeCore: function() {
                var that = this,
                    dxScrollable;
                that.callBase();
                that._fireColumnResizedCallbacks();
                that._updateRowHeight();
                that._updateNoDataText();
                that.updateFreeSpaceRowHeight();
                that._updateLastRowBorder();
                dxScrollable = that.element().data("dxScrollable");
                if (dxScrollable)
                    dxScrollable.update();
                that.setLoading(that._dataController.isLoading())
            },
            scrollToPage: function(pageIndex) {
                var that = this,
                    scrollingMode = that.option("scrolling.mode"),
                    dataController = that._dataController,
                    pageSize = dataController ? dataController.pageSize() : 0,
                    scrollPosition;
                if (scrollingMode === "virtual" || scrollingMode === "infinite")
                    scrollPosition = pageIndex * that._rowHeight * pageSize;
                else
                    scrollPosition = 0;
                that.scrollTo({
                    y: scrollPosition,
                    x: that._scrollLeft
                })
            },
            scrollTo: function(location) {
                var $element = this.element(),
                    dxScrollable = $element && $element.data("dxScrollable");
                if (dxScrollable)
                    dxScrollable.scrollTo(location)
            },
            height: function(height) {
                var that = this,
                    $element = this.element(),
                    freeSpaceRowElements;
                if (utils.isDefined(height)) {
                    that._hasHeight = height !== "auto";
                    if ($element)
                        $element.height(height);
                    freeSpaceRowElements = this._getFreeSpaceRowElements();
                    freeSpaceRowElements && freeSpaceRowElements.hide()
                }
                else
                    return $element ? $element.height() : 0
            },
            setLoading: function(isLoading, messageText) {
                var that = this,
                    loadPanel = that._loadPanel,
                    dataController = that._dataController,
                    loadPanelOptions = that.option("loadPanel") || {},
                    animation = dataController.isLoaded() ? loadPanelOptions.animation : null,
                    visibilityOptions;
                if (loadPanel) {
                    visibilityOptions = {
                        message: messageText || loadPanelOptions.text,
                        animation: animation,
                        visible: isLoading
                    };
                    clearTimeout(that._hideLoadingTimeoutID);
                    if (loadPanel.option("visible") && !isLoading)
                        that._hideLoadingTimeoutID = setTimeout(function() {
                            loadPanel.option(visibilityOptions)
                        }, DATAGRID_LOADPANEL_HIDE_TIMEOUT);
                    else
                        loadPanel.option(visibilityOptions);
                    that._updateNoDataText()
                }
            },
            isScrollbarVisible: function() {
                var $element = this.element();
                return $element ? this._findContentElement().outerHeight() - $element.height() > 0 : false
            },
            setRowsOpacity: function(columnIndex, value) {
                var that = this,
                    $rows = that._getRowElements().not("." + DATAGRID_GROUP_ROW_CLASS) || [];
                $.each($rows, function(rowIndex, row) {
                    if (!$(row).hasClass(DATAGRID_GROUP_ROW_CLASS))
                        that.getCellElements(rowIndex).eq(columnIndex).css({opacity: value})
                })
            },
            getTopVisibleItemIndex: function() {
                var that = this,
                    itemIndex = 0,
                    prevOffsetTop = 0,
                    offsetTop = 0,
                    rowElements,
                    rowElelemnt,
                    scrollPosition = that._scrollTop,
                    contentElementOffsetTop = that._findContentElement().offset().top,
                    items = that._dataController.items(),
                    tableElement = that._getTableElement();
                if (items.length && tableElement) {
                    rowElements = tableElement.children("tbody").children(".dx-row:visible, .dx-error-row").not("." + DATAGRID_FREESPACE_CLASS);
                    for (itemIndex = 0; itemIndex < items.length; itemIndex++) {
                        prevOffsetTop = offsetTop;
                        rowElelemnt = rowElements.eq(itemIndex);
                        if (rowElelemnt.length) {
                            offsetTop = rowElelemnt.offset().top - contentElementOffsetTop;
                            if (offsetTop > scrollPosition) {
                                if (scrollPosition * 2 < offsetTop + prevOffsetTop && itemIndex)
                                    itemIndex--;
                                break
                            }
                        }
                    }
                    if (itemIndex && itemIndex === items.length)
                        itemIndex--
                }
                return itemIndex
            },
            getTopVisibleRowData: function() {
                var itemIndex = this.getTopVisibleItemIndex(),
                    items = this._dataController.items();
                if (items[itemIndex])
                    return items[itemIndex].data
            },
            optionChanged: function(args) {
                var that = this;
                that.callBase(args);
                switch (args.name) {
                    case"wordWrapEnabled":
                    case"showColumnLines":
                    case"showRowLines":
                    case"rowAlternationEnabled":
                    case"rowTemplate":
                        that._invalidate(true, true);
                        args.handled = true;
                        break;
                    case"scrolling":
                        that._rowHeight = null;
                        that._tableElement = null;
                        args.handled = true;
                        break;
                    case"rtlEnabled":
                        that._rowHeight = null;
                        that._tableElement = null;
                        break;
                    case"loadPanel":
                        that._tableElement = null;
                        that._invalidate(true, true);
                        args.handled = true;
                        break;
                    case"noDataText":
                        that._updateNoDataText();
                        args.handled = true;
                        break
                }
            },
            dispose: function() {
                clearTimeout(this._hideLoadingTimeoutID)
            },
            setScrollerSpacing: function(){}
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_GROUP_ROW_CLASS: DATAGRID_GROUP_ROW_CLASS,
            DATAGRID_ROWS_VIEW_CLASS: DATAGRID_ROWS_VIEW_CLASS,
            DATAGRID_TABLE_CLASS: DATAGRID_TABLE_CLASS,
            DATAGRID_FREESPACE_CLASS: DATAGRID_FREESPACE_CLASS,
            DATAGRID_NODATA_TEXT_CLASS: DATAGRID_NODATA_TEXT_CLASS,
            DATAGRID_NOWRAP_CLASS: DATAGRID_NOWRAP_CLASS,
            DATAGRID_ROW_LINES_CLASS: DATAGRID_ROW_LINES_CLASS,
            DATAGRID_COLUMN_LINES_CLASS: DATAGRID_COLUMN_LINES_CLASS,
            DATAGRID_ROW_ALTERNATION_CLASS: DATAGRID_ROW_ALTERNATION_CLASS,
            DATAGRID_LAST_ROW_BORDER: DATAGRID_LAST_ROW_BORDER
        });
        dataGrid.registerModule("rows", {
            defaultOptions: function() {
                return {
                        hoverStateEnabled: false,
                        loadPanel: {
                            enabled: true,
                            text: Globalize.localize("Loading"),
                            width: 200,
                            height: 70,
                            showIndicator: true,
                            indicatorSrc: "",
                            showPane: true
                        },
                        rowTemplate: null,
                        columnAutoWidth: false,
                        noDataText: Globalize.localize("dxDataGrid-noDataText"),
                        wordWrapEnabled: false,
                        showColumnLines: true,
                        showRowLines: false,
                        rowAlternationEnabled: false,
                        activeStateEnabled: false
                    }
            },
            views: {rowsView: dataGrid.RowsView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.pager.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_PAGER_CLASS = "dx-datagrid-pager";
        var MAX_PAGES_COUNT = 10;
        dataGrid.PagerView = dataGrid.View.inherit({
            init: function() {
                var that = this,
                    dataController = that.getController("data");
                that._isVisible = false;
                dataController.changed.add(function() {
                    that.render()
                })
            },
            _getPager: function() {
                var $element = this.element();
                return $element && $element.data("dxPager")
            },
            _renderCore: function() {
                var that = this,
                    $element = that.element().addClass(DATAGRID_PAGER_CLASS),
                    pagerOptions = that.option("pager") || {},
                    dataController = that.getController("data"),
                    options = {
                        maxPagesCount: MAX_PAGES_COUNT,
                        pageIndex: 1 + (parseInt(dataController.pageIndex()) || 0),
                        pageCount: dataController.pageCount(),
                        pageSize: dataController.pageSize(),
                        showPageSizes: pagerOptions.showPageSizeSelector,
                        showInfo: pagerOptions.showInfo,
                        showNavigationButtons: pagerOptions.showNavigationButtons,
                        pageSizes: that.getPageSizes(),
                        hasKnownLastPage: dataController.hasKnownLastPage(),
                        pageIndexChanged: function(pageIndex) {
                            if (dataController.pageIndex() !== pageIndex - 1)
                                setTimeout(function() {
                                    dataController.pageIndex(pageIndex - 1)
                                })
                        },
                        pageSizeChanged: function(pageSize) {
                            setTimeout(function() {
                                dataController.pageSize(pageSize)
                            })
                        }
                    };
                if (utils.isDefined(pagerOptions.infoText))
                    options.infoText = pagerOptions.infoText;
                that._createComponent($element, "dxPager", options)
            },
            getPageSizes: function() {
                var that = this,
                    dataController = that.getController("data"),
                    pagerOptions = that.option("pager"),
                    allowedPageSizes = pagerOptions && pagerOptions.allowedPageSizes,
                    pageSize = dataController.pageSize();
                if (!utils.isDefined(that._pageSizes) || $.inArray(pageSize, that._pageSizes) === -1) {
                    that._pageSizes = [];
                    if (pagerOptions)
                        if ($.isArray(allowedPageSizes))
                            that._pageSizes = allowedPageSizes;
                        else if (allowedPageSizes && pageSize > 1)
                            that._pageSizes = [Math.floor(pageSize / 2), pageSize, pageSize * 2]
                }
                return that._pageSizes
            },
            isVisible: function() {
                var that = this,
                    dataController = that.getController("data"),
                    pagerOptions = that.option("pager"),
                    pagerVisible = pagerOptions && pagerOptions.visible,
                    scrolling = that.option("scrolling");
                if (that._isVisible)
                    return true;
                if (pagerVisible === "auto")
                    if (scrolling && (scrolling.mode === "virtual" || scrolling.mode === "infinite"))
                        pagerVisible = false;
                    else
                        pagerVisible = dataController.pageCount() > 1 || dataController.isLoaded() && !dataController.hasKnownLastPage();
                that._isVisible = pagerVisible;
                return pagerVisible
            },
            getHeight: function() {
                var pager = this._getPager();
                return pager && this.isVisible() ? pager.getHeight() : 0
            },
            optionChanged: function(args) {
                var that = this,
                    name = args.name,
                    isPager = name === "pager",
                    isPaging = name === "paging",
                    isDataSource = name === "dataSource",
                    isScrolling = name === "scrolling";
                if (isPager || isPaging || isScrolling || isDataSource) {
                    if (isPager || isPaging)
                        that._pageSizes = null;
                    if (isPager || isPaging || isScrolling)
                        that._isVisible = false;
                    if (!isDataSource) {
                        that._invalidate();
                        if (isPager && that.component)
                            that.component.resize()
                    }
                    args.handled = true
                }
            }
        });
        dataGrid.registerModule("pager", {
            defaultOptions: function() {
                return {pager: {
                            visible: "auto",
                            showPageSizeSelector: false,
                            allowedPageSizes: "auto"
                        }}
            },
            views: {pagerView: dataGrid.PagerView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnsResizingReorderingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            events = ui.events,
            addNamespace = events.addNamespace,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid,
            fx = DX.fx;
        var DATAGRID_COLUMNS_SEPARATOR_CLASS = "dx-datagrid-columns-separator",
            DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT = "dx-datagrid-columns-separator-transparent",
            DATAGRID_DRAGGING_HEADER_CLASS = "dx-datagrid-drag-header",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_HEADERS_DRAG_ACTION_CLASS = "dx-datagrid-drag-action",
            DATAGRID_TRACKER_CLASS = "dx-datagrid-tracker",
            DATAGRID_BLOCK_SEPARATOR_CLASS = "dx-block-separator",
            DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS = "dx-datagrid-drop-highlight",
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            WIDGET_CLASS = "dx-widget",
            DATAGRID_MODULE_NAMESPACE = "dxDataGridResizingReordering",
            COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH = 10,
            DRAGGING_DELTA = 5;
        var allowResizing = function(that) {
                return that.option("allowColumnResizing") || that.getController("columns").isColumnOptionUsed("allowResizing")
            };
        var allowReordering = function(that) {
                return that.option("allowColumnReordering") || that.getController("columns").isColumnOptionUsed("allowReordering")
            };
        dataGrid.getPointsByColumns = function(items, pointCreated, isVertical) {
            var cellsLength = items.length,
                notCreatePoint = false,
                point,
                i,
                item,
                offset,
                result = [],
                rtlEnabled,
                columnIndex = 0;
            for (i = 0; i <= cellsLength; i++) {
                if (i < cellsLength) {
                    item = items.eq(columnIndex);
                    offset = item.offset();
                    rtlEnabled = item.css("direction") === "rtl"
                }
                point = {
                    index: i,
                    x: offset ? offset.left + (!isVertical && rtlEnabled ^ i === cellsLength ? item.outerWidth() : 0) : 0,
                    y: offset ? offset.top + (isVertical && i === cellsLength ? item.outerHeight() : 0) : 0,
                    columnIndex: columnIndex
                };
                if (pointCreated)
                    notCreatePoint = pointCreated(point);
                if (!notCreatePoint)
                    result.push(point);
                columnIndex++
            }
            return result
        };
        dataGrid.TrackerView = dataGrid.View.inherit({
            _renderCore: function(options) {
                this.callBase();
                this.element().addClass(DATAGRID_TRACKER_CLASS);
                this.hide()
            },
            init: function() {
                var that = this,
                    $element;
                that.callBase();
                that.getController("tablePosition").positionChanged.add(function(position) {
                    $element = that.element();
                    if ($element && $element.hasClass(DATAGRID_TRACKER_CLASS)) {
                        $element.css({top: position.top});
                        $element.height(position.height)
                    }
                })
            },
            isVisible: function() {
                return allowResizing(this)
            },
            show: function() {
                this.element().show()
            },
            hide: function() {
                this.element().hide()
            },
            setHeight: function(value) {
                this.element().height(value)
            }
        });
        dataGrid.SeparatorView = dataGrid.View.inherit({
            _renderSeparator: function(){},
            _renderCore: function(options) {
                this.callBase(options);
                this._isShown = true;
                this._renderSeparator();
                this.hide()
            },
            show: function() {
                this._isShown = true
            },
            hide: function() {
                this._isShown = false
            },
            height: function(value) {
                var $element = this.element();
                if ($element)
                    if (utils.isDefined(value))
                        $element.height(value);
                    else
                        return $element.height()
            },
            width: function(value) {
                var $element = this.element();
                if ($element)
                    if (utils.isDefined(value))
                        $element.width(value);
                    else
                        return $element.width()
            }
        });
        dataGrid.ColumnsSeparatorView = dataGrid.SeparatorView.inherit({
            _renderSeparator: function() {
                this.callBase();
                var $element = this.element();
                $element.addClass(DATAGRID_COLUMNS_SEPARATOR_CLASS)
            },
            _subscribeToEvent: function() {
                var that = this,
                    $element;
                that.getController("tablePosition").positionChanged.add(function(position) {
                    $element = that.element();
                    if ($element) {
                        $element.css({top: position.top});
                        $element.height(position.height)
                    }
                })
            },
            isVisible: function() {
                return this.option("showColumnHeaders") && (allowReordering(this) || allowResizing(this))
            },
            init: function() {
                this.callBase();
                this._isTransparent = allowResizing(this);
                if (this.isVisible())
                    this._subscribeToEvent()
            },
            show: function() {
                var that = this,
                    $element = this.element();
                if ($element && !that._isShown)
                    if (that._isTransparent)
                        $element.removeClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT);
                    else
                        $element.show();
                this.callBase()
            },
            hide: function() {
                var $element = this.element();
                if ($element && this._isShown)
                    if (this._isTransparent)
                        $element.addClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT);
                    else
                        $element.hide();
                this.callBase()
            },
            moveByX: function(outerX) {
                var $element = this.element();
                if ($element) {
                    $element.css("left", outerX - this._parentElement().offset().left);
                    this._testPosx = outerX
                }
            },
            changeCursor: function(cursorName) {
                cursorName = utils.isDefined(cursorName) ? cursorName : "";
                var $element = this.element();
                if ($element) {
                    $element.css("cursor", cursorName);
                    this._testCursorName = cursorName
                }
            }
        });
        dataGrid.BlockSeparatorView = dataGrid.SeparatorView.inherit({
            _renderSeparator: function() {
                this.callBase();
                this.element().addClass(DATAGRID_BLOCK_SEPARATOR_CLASS).html("&nbsp;")
            },
            hide: function() {
                var that = this,
                    $parent = this._parentElement(),
                    $element = this.element();
                if ($element && this._isShown)
                    $element.hide();
                if ($parent && !$parent.children("." + DATAGRID_BLOCK_SEPARATOR_CLASS).length)
                    $parent.prepend(that.element());
                that.callBase()
            },
            isVisible: function() {
                var groupPanelOptions = this.option("groupPanel"),
                    columnChooserOptions = this.option("columnChooser");
                return groupPanelOptions && groupPanelOptions.visible || columnChooserOptions && columnChooserOptions.enabled
            },
            show: function(targetLocation) {
                var that = this,
                    $element = this.element(),
                    startAnimate = function(toOptions) {
                        fx.stop($element, true);
                        fx.animate($element, {
                            type: "slide",
                            from: {
                                width: 0,
                                display: toOptions.display
                            },
                            to: toOptions,
                            duration: 300,
                            easing: "swing"
                        })
                    };
                if ($element && !that._isShown)
                    switch (targetLocation) {
                        case"group":
                            startAnimate({
                                width: "50px",
                                display: "inline-block"
                            });
                            break;
                        case"columnChooser":
                            startAnimate({
                                width: "100%",
                                display: "block"
                            });
                            break;
                        default:
                            $element.show()
                    }
                that.callBase()
            }
        });
        dataGrid.DraggingHeaderView = dataGrid.View.inherit({
            _isDragging: false,
            _getDropOptions: function() {
                var that = this;
                if (that._dragOptions)
                    return {
                            sourceColumnIndex: that._dragOptions.columnIndex,
                            sourceColumnElement: that._dragOptions.columnElement,
                            sourceLocation: that._dragOptions.sourceLocation,
                            targetColumnIndex: that._dropColumnIndex,
                            targetLocation: that._dropLocation
                        }
            },
            _getDraggingPanelByPos: function(pos) {
                var that = this,
                    result;
                $.each(that._dragOptions.draggingPanels, function(index, draggingPanel) {
                    if (draggingPanel) {
                        var boundingRect = draggingPanel.getBoundingRect();
                        if (boundingRect && (boundingRect.bottom === undefined || pos.y < boundingRect.bottom) && (boundingRect.top === undefined || pos.y > boundingRect.top) && (boundingRect.left === undefined || pos.x > boundingRect.left) && (boundingRect.right === undefined || pos.x < boundingRect.right)) {
                            result = draggingPanel;
                            return false
                        }
                    }
                });
                return result
            },
            _renderCore: function() {
                this.element().addClass(DATAGRID_DRAGGING_HEADER_CLASS + " " + DATAGRID_CELL_CONTENT_CLASS + " " + WIDGET_CLASS).css("display", "none")
            },
            dispose: function() {
                var element = this.element();
                this._dragOptions = null;
                element && element.parent().find("." + DATAGRID_DRAGGING_HEADER_CLASS).remove()
            },
            isVisible: function() {
                var columnsController = this.getController("columns"),
                    commonColumnSettings = columnsController.getCommonSettings();
                return this.option("showColumnHeaders") && (allowReordering(this) || commonColumnSettings.allowGrouping || commonColumnSettings.allowHiding)
            },
            init: function() {
                this.callBase();
                this._controller = this.getController("draggingHeader");
                this._columnsResizerViewController = this.getController("columnsResizer")
            },
            dragHeader: function(options) {
                var that = this,
                    columnElement = options.columnElement;
                that._dragOptions = options;
                that._isDragging = true;
                that._dropColumnIndex = options.columnIndex;
                that._dropLocation = options.sourceLocation;
                that._onSelectStart = document.onselectstart;
                document.onselectstart = function() {
                    return false
                };
                that.element().css({
                    textAlign: columnElement && columnElement.css("text-align"),
                    height: columnElement && columnElement.height(),
                    width: columnElement && columnElement.width(),
                    whiteSpace: columnElement && columnElement.css("white-space")
                }).addClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS).text(options.sourceColumn.caption);
                that.element().appendTo($(document.body))
            },
            moveHeader: function(args) {
                var e = args.jQueryEvent,
                    that = e.data.that,
                    newLeft,
                    newTop,
                    moveDeltaX,
                    moveDeltaY,
                    eventData = events.eventData(e),
                    isResizing = that._columnsResizerViewController ? that._columnsResizerViewController.isResizing() : false,
                    dragOptions = that._dragOptions;
                if (that._isDragging && !isResizing) {
                    moveDeltaX = Math.abs(eventData.x - dragOptions.columnElement.offset().left - dragOptions.deltaX);
                    moveDeltaY = Math.abs(eventData.y - dragOptions.columnElement.offset().top - dragOptions.deltaY);
                    if (that.element().is(":visible") || moveDeltaX > DRAGGING_DELTA || moveDeltaY > DRAGGING_DELTA) {
                        that.element().show();
                        newLeft = eventData.x - dragOptions.deltaX;
                        newTop = eventData.y - dragOptions.deltaY;
                        that.element().offset({
                            left: newLeft,
                            top: newTop
                        });
                        that.dockHeader(eventData)
                    }
                    e.preventDefault()
                }
            },
            dockHeader: function(eventData) {
                var that = this,
                    targetDraggingPanel = that._getDraggingPanelByPos(eventData),
                    controller = that._controller,
                    i,
                    params,
                    centerPosition;
                if (targetDraggingPanel) {
                    var rtlEnabled = that.option("rtlEnabled"),
                        isVerticalOrientation = targetDraggingPanel.getName() === "columnChooser",
                        axisName = isVerticalOrientation ? "y" : "x",
                        columnElements = targetDraggingPanel.getColumnElements() || [],
                        pointsByColumns = controller._generatePointsByColumns($.extend({}, that._dragOptions, {
                            targetDraggingPanel: targetDraggingPanel,
                            columns: targetDraggingPanel.getColumns(),
                            columnElements: columnElements,
                            isVerticalOrientation: isVerticalOrientation
                        }));
                    that._dropLocation = targetDraggingPanel.getName();
                    if (pointsByColumns.length > 0)
                        for (i = 0; i < pointsByColumns.length; i++) {
                            centerPosition = pointsByColumns[i + 1] && (pointsByColumns[i][axisName] + pointsByColumns[i + 1][axisName]) / 2;
                            if (centerPosition === undefined || (rtlEnabled && axisName === "x" ? eventData[axisName] > centerPosition : eventData[axisName] < centerPosition)) {
                                that._dropColumnIndex = pointsByColumns[i].columnIndex;
                                params = that._getDropOptions();
                                if (columnElements[i])
                                    params.targetColumnElement = columnElements.eq(i);
                                else {
                                    params.targetColumnElement = columnElements.last();
                                    params.isLast = true
                                }
                                params.posX = pointsByColumns[i].x;
                                controller.dock(params);
                                break
                            }
                        }
                    else {
                        that._dropColumnIndex = -1;
                        params = that._getDropOptions();
                        controller.dock(params)
                    }
                }
            },
            dropHeader: function(args) {
                var e = args.jQueryEvent,
                    that = e.data.that,
                    controller = that._controller;
                that.element().hide();
                if (controller && that._isDragging)
                    controller.drop(that._getDropOptions());
                that.element().appendTo(that._parentElement());
                that._dragOptions = null;
                that._isDragging = false;
                document.onselectstart = that._onSelectStart || null
            }
        });
        dataGrid.ColumnsResizerViewController = dataGrid.ViewController.inherit({
            _isHeadersRowArea: function(posY) {
                if (this._columnHeadersView) {
                    var element = this._columnHeadersView.element(),
                        headersRowHeight,
                        offsetTop;
                    if (element) {
                        offsetTop = element.offset().top;
                        headersRowHeight = this._columnHeadersView.getHeadersRowHeight();
                        return posY >= offsetTop && posY <= offsetTop + headersRowHeight
                    }
                }
                return false
            },
            _pointCreated: function(point, cellsLength, columns) {
                var currentColumn,
                    nextColumn;
                if (point.index > 0 && point.index < cellsLength) {
                    point.columnIndex -= 1;
                    currentColumn = columns[point.columnIndex] || {};
                    nextColumn = columns[point.columnIndex + 1] || {};
                    return !(currentColumn.allowResizing && nextColumn.allowResizing)
                }
                return true
            },
            _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
                if (pointsByColumns)
                    for (var i = 0; i < pointsByColumns.length; i++)
                        if (pointsByColumns[i].x - deltaX <= currentX && currentX <= pointsByColumns[i].x + deltaX)
                            return pointsByColumns[i];
                return null
            },
            _moveSeparator: function(args) {
                var e = args.jQueryEvent,
                    that = e.data,
                    pointsByColumns = that._pointsByColumns,
                    columnsSeparatorWidth = that._columnsSeparatorView.width(),
                    columnsSeparatorOffset = that._columnsSeparatorView.element().offset(),
                    deltaX = columnsSeparatorWidth / 2,
                    parentOffsetLeft = that._$parentContainer.offset().left,
                    eventData = events.eventData(e);
                if (that._isResizing) {
                    if (parentOffsetLeft <= eventData.x && eventData.x <= parentOffsetLeft + that._$parentContainer.width())
                        if (that._updateColumnsWidthIfNeeded(that._targetPoint.columnIndex, eventData.x)) {
                            that._columnsSeparatorView.moveByX(that._targetPoint.x + (eventData.x - that._resizingInfo.startPosX));
                            that._tablePositionController.update();
                            e.preventDefault()
                        }
                }
                else if (that._isHeadersRowArea(eventData.y)) {
                    that._targetPoint = that._getTargetPoint(pointsByColumns, eventData.x, columnsSeparatorWidth);
                    that._isReadyResizing = false;
                    that._columnsSeparatorView.changeCursor();
                    if (that._targetPoint && columnsSeparatorOffset.top <= eventData.y && columnsSeparatorOffset.top + that._columnsSeparatorView.height() >= eventData.y) {
                        that._columnsSeparatorView.changeCursor("col-resize");
                        that._columnsSeparatorView.moveByX(that._targetPoint.x - deltaX);
                        that._isReadyResizing = true;
                        e.preventDefault()
                    }
                }
                else {
                    that._isReadyResizing = false;
                    that._columnsSeparatorView.changeCursor()
                }
            },
            _endResizing: function(args) {
                var e = args.jQueryEvent,
                    that = e.data;
                if (that._isResizing) {
                    that._generatePointsByColumns();
                    that._resizingInfo = null;
                    that._columnsSeparatorView.hide();
                    that._columnsSeparatorView.changeCursor();
                    that._trackerView.hide();
                    that._isReadyResizing = false;
                    that._isResizing = false
                }
            },
            _setupResizingInfo: function(posX) {
                var that = this,
                    currentHeader = that._columnHeadersView.getHeaderElement(that._targetPoint.columnIndex),
                    nextHeader = that._columnHeadersView.getHeaderElement(that._targetPoint.columnIndex + 1);
                that._resizingInfo = {
                    startPosX: posX,
                    currentColumnWidth: currentHeader && currentHeader.length > 0 ? currentHeader.outerWidth() : 0,
                    nextColumnWidth: nextHeader && nextHeader.length > 0 ? nextHeader.outerWidth() : 0
                }
            },
            _startResizing: function(args) {
                var e = args.jQueryEvent,
                    that = e.data,
                    eventData = events.eventData(e);
                if (events.isTouchEvent(e))
                    if (that._isHeadersRowArea(eventData.y)) {
                        that._targetPoint = that._getTargetPoint(that._pointsByColumns, eventData.x, COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH);
                        if (that._targetPoint) {
                            that._columnsSeparatorView.moveByX(that._targetPoint.x - that._columnsSeparatorView.width() / 2);
                            that._isReadyResizing = true
                        }
                    }
                    else
                        that._isReadyResizing = false;
                if (that._isReadyResizing) {
                    if (that._targetPoint)
                        that._testColumnIndex = that._targetPoint.columnIndex;
                    that._setupResizingInfo(eventData.x);
                    that._columnsSeparatorView.show();
                    that._trackerView.show();
                    that._isResizing = true;
                    e.preventDefault();
                    e.stopPropagation()
                }
            },
            _generatePointsByColumns: function() {
                var that = this,
                    columns = that._columnsController ? that._columnsController.getVisibleColumns() : [],
                    cells = that._columnHeadersView.getColumnElements(),
                    pointsByColumns = [];
                if (cells && cells.length > 0)
                    pointsByColumns = dataGrid.getPointsByColumns(cells, function(point) {
                        return that._pointCreated(point, cells.length, columns)
                    });
                that._pointsByColumns = pointsByColumns
            },
            _unsubscribeFromEvents: function() {
                this._moveSeparatorHandler && this._$parentContainer.off(addNamespace("dxpointermove", DATAGRID_MODULE_NAMESPACE), this._moveSeparatorHandler);
                this._startResizingHandler && this._$parentContainer.off(addNamespace("dxpointerdown", DATAGRID_MODULE_NAMESPACE), this._startResizingHandler);
                if (this._endResizingHandler) {
                    this._columnsSeparatorView.element().off(addNamespace("dxpointerup", DATAGRID_MODULE_NAMESPACE), this._endResizingHandler);
                    $(document).off(addNamespace("dxpointerup", DATAGRID_MODULE_NAMESPACE), this._endResizingHandler)
                }
            },
            _subscribeToEvents: function() {
                this._moveSeparatorHandler = this.createAction(this._moveSeparator);
                this._startResizingHandler = this.createAction(this._startResizing);
                this._endResizingHandler = this.createAction(this._endResizing);
                this._$parentContainer.on(addNamespace("dxpointermove", DATAGRID_MODULE_NAMESPACE), this, this._moveSeparatorHandler);
                this._$parentContainer.on(addNamespace("dxpointerdown", DATAGRID_MODULE_NAMESPACE), this, this._startResizingHandler);
                this._columnsSeparatorView.element().on(addNamespace("dxpointerup", DATAGRID_MODULE_NAMESPACE), this, this._endResizingHandler);
                $(document).on(addNamespace("dxpointerup", DATAGRID_MODULE_NAMESPACE), this, this._endResizingHandler)
            },
            _updateColumnsWidthIfNeeded: function(columnIndex, posX) {
                var deltaX,
                    isUpdated = false,
                    nextCellWidth,
                    columnsController = this._columnsController,
                    visibleColumns = columnsController.getVisibleColumns(),
                    columnsSeparatorWidth = this._columnsSeparatorView.width(),
                    column,
                    nextColumn,
                    cellWidth;
                deltaX = posX - this._resizingInfo.startPosX;
                if (this.option("rtlEnabled"))
                    deltaX = -deltaX;
                cellWidth = this._resizingInfo.currentColumnWidth + deltaX;
                nextCellWidth = this._resizingInfo.nextColumnWidth - deltaX;
                isUpdated = !(cellWidth <= columnsSeparatorWidth || nextCellWidth <= columnsSeparatorWidth);
                if (isUpdated) {
                    column = visibleColumns[columnIndex];
                    nextColumn = visibleColumns[columnIndex + 1];
                    columnsController.beginUpdate();
                    column && columnsController.columnOption(column.index, "visibleWidth", undefined);
                    nextColumn && columnsController.columnOption(nextColumn.index, "visibleWidth", undefined);
                    column && columnsController.columnOption(column.index, "width", Math.floor(cellWidth));
                    nextColumn && columnsController.columnOption(nextColumn.index, "width", Math.floor(nextCellWidth));
                    columnsController.endUpdate()
                }
                return isUpdated
            },
            isResizing: function() {
                return this._isResizing
            },
            init: function() {
                var that = this,
                    gridView,
                    previousScrollbarVisibility,
                    generatePointsByColumnsScrollHandler = function(offset) {
                        if (that._scrollLeft !== offset.left) {
                            that._scrollLeft = offset.left;
                            that._generatePointsByColumns()
                        }
                    },
                    generatePointsByColumnsHandler = function() {
                        that._generatePointsByColumns()
                    };
                that.callBase();
                if (allowResizing(that)) {
                    that._columnsSeparatorView = that.getView("columnsSeparatorView");
                    that._columnHeadersView = that.getView("columnHeadersView");
                    that._trackerView = that.getView("trackerView");
                    that._rowsView = that.getView("rowsView");
                    that._columnsController = that.getController("columns");
                    that._tablePositionController = that.getController("tablePosition");
                    that._$parentContainer = that._columnsSeparatorView.component.element();
                    that._columnHeadersView.renderCompleted.add(generatePointsByColumnsHandler);
                    that._columnHeadersView.resizeCompleted.add(generatePointsByColumnsHandler);
                    that._columnsSeparatorView.renderCompleted.add(function() {
                        that._unsubscribeFromEvents();
                        that._subscribeToEvents()
                    });
                    that._rowsView.renderCompleted.add(function() {
                        that._rowsView.scrollChanged.remove(generatePointsByColumnsScrollHandler);
                        that._rowsView.scrollChanged.add(generatePointsByColumnsScrollHandler)
                    });
                    gridView = that.getView("gridView");
                    previousScrollbarVisibility = that._rowsView.getScrollbarWidth() !== 0;
                    that.getController("tablePosition").positionChanged.add(function() {
                        if (that._isResizing && !that._rowsView.isResizing) {
                            var scrollbarVisibility = that._rowsView.getScrollbarWidth() !== 0;
                            if (previousScrollbarVisibility !== scrollbarVisibility) {
                                previousScrollbarVisibility = scrollbarVisibility;
                                gridView.resize()
                            }
                            else
                                that._rowsView.updateFreeSpaceRowHeight()
                        }
                    })
                }
            },
            dispose: function() {
                this._unsubscribeFromEvents()
            }
        });
        dataGrid.TablePositionViewController = dataGrid.ViewController.inherit({
            update: function() {
                var $element = this._columnHeadersView.element(),
                    columnsHeadersHeight = this._columnHeadersView ? this._columnHeadersView.getHeight() : 0,
                    rowsHeight = this._rowsView ? this._rowsView.height() - this._rowsView.getScrollbarWidth(true) : 0;
                this.positionChanged.fire({
                    height: columnsHeadersHeight + rowsHeight,
                    top: $element && $element.length > 0 ? Math.floor($element[0].offsetTop) : 0
                })
            },
            init: function() {
                var that = this;
                that.callBase();
                that._columnHeadersView = this.getView("columnHeadersView");
                that._rowsView = this.getView("rowsView");
                that._pagerView = this.getView("pagerView");
                that._rowsView.resizeCompleted.add(function() {
                    that.update()
                })
            },
            ctor: function(component) {
                this.callBase(component);
                this.positionChanged = $.Callbacks()
            }
        });
        dataGrid.DraggingHeaderViewController = dataGrid.ViewController.inherit({
            _generatePointsByColumns: function(options) {
                var that = this;
                return dataGrid.getPointsByColumns(options.columnElements, function(point) {
                        return that._pointCreated(point, options.columns, options.targetDraggingPanel.getName(), options.sourceColumn)
                    }, options.isVerticalOrientation)
            },
            _pointCreated: function(point, columns, location, sourceColumn) {
                var targetColumn = columns[point.columnIndex],
                    prevColumn = columns[point.columnIndex - 1];
                switch (location) {
                    case"columnChooser":
                        return true;
                    case"headers":
                        return sourceColumn && !sourceColumn.allowReordering || (!targetColumn || !targetColumn.allowReordering) && (!prevColumn || !prevColumn.allowReordering);
                    default:
                        return columns.length === 0
                }
            },
            _subscribeToEvents: function(draggingHeader, draggingPanels) {
                var that = this;
                $.each(draggingPanels, function(_, draggingPanel) {
                    if (draggingPanel) {
                        var columnElements = draggingPanel.getColumnElements() || [],
                            nameDraggingPanel = draggingPanel.getName(),
                            columns = draggingPanel.getColumns() || [];
                        $.each(columnElements, function(index, columnElement) {
                            var $columnElement = $(columnElement);
                            if (draggingPanel.allowDragging(columns[index], draggingPanels)) {
                                $columnElement.addClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS);
                                $columnElement.on(addNamespace("dxdragstart", DATAGRID_MODULE_NAMESPACE), that.createAction(function(args) {
                                    var e = args.jQueryEvent,
                                        eventData = events.eventData(e);
                                    draggingHeader.dragHeader({
                                        deltaX: eventData.x - $(e.currentTarget).offset().left,
                                        deltaY: eventData.y - $(e.currentTarget).offset().top,
                                        sourceColumn: columns[index],
                                        columnIndex: index,
                                        columnElement: $columnElement,
                                        sourceLocation: nameDraggingPanel,
                                        draggingPanels: draggingPanels
                                    })
                                }));
                                $columnElement.on(addNamespace("dxdrag", DATAGRID_MODULE_NAMESPACE), {that: draggingHeader}, that.createAction(draggingHeader.moveHeader));
                                $columnElement.on(addNamespace("dxdragend", DATAGRID_MODULE_NAMESPACE), {that: draggingHeader}, that.createAction(draggingHeader.dropHeader))
                            }
                        })
                    }
                })
            },
            _unsubscribeFromEvents: function(draggingHeader, draggingPanels) {
                $.each(draggingPanels, function(_, draggingPanel) {
                    if (draggingPanel) {
                        var columnElements = draggingPanel.getColumnElements() || [];
                        $.each(columnElements, function(index, columnElement) {
                            var $columnElement = $(columnElement);
                            $columnElement.off(addNamespace("dxdragstart", DATAGRID_MODULE_NAMESPACE));
                            $columnElement.off(addNamespace("dxdrag", DATAGRID_MODULE_NAMESPACE));
                            $columnElement.off(addNamespace("dxdragend", DATAGRID_MODULE_NAMESPACE));
                            $columnElement.removeClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS)
                        })
                    }
                })
            },
            _getSeparator: function(targetLocation) {
                return targetLocation === "headers" ? this._columnsSeparatorView : this._blockSeparatorView
            },
            hideSeparators: function() {
                var blockSeparator = this._blockSeparatorView,
                    columnsSeparator = this._columnsSeparatorView;
                this._animationColumnIndex = null;
                blockSeparator && blockSeparator.hide();
                columnsSeparator && columnsSeparator.hide()
            },
            init: function() {
                var that = this,
                    subscribeToEvents;
                that.callBase();
                that._columnsController = that.getController("columns");
                that._columnHeadersView = that.getView("columnHeadersView");
                that._columnsSeparatorView = that.getView("columnsSeparatorView");
                that._draggingHeaderView = that.getView("draggingHeaderView");
                that._rowsView = that.getView("rowsView");
                that._blockSeparatorView = that.getView("blockSeparatorView");
                that._headerPanelView = that.getView("headerPanel");
                that._columnChooserView = that.getView("columnChooserView");
                subscribeToEvents = function() {
                    if (that._draggingHeaderView) {
                        var draggingPanels = [that._columnChooserView, that._columnHeadersView, that._headerPanelView];
                        that._unsubscribeFromEvents(that._draggingHeaderView, draggingPanels);
                        that._subscribeToEvents(that._draggingHeaderView, draggingPanels)
                    }
                };
                that._columnHeadersView.renderCompleted.add(subscribeToEvents);
                that._headerPanelView && that._headerPanelView.renderCompleted.add(subscribeToEvents);
                that._columnChooserView && that._columnChooserView.renderCompleted.add(subscribeToEvents)
            },
            allowDrop: function(parameters) {
                return this._columnsController.allowMoveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
            },
            dock: function(parameters) {
                var that = this,
                    targetColumnIndex = parameters.targetColumnIndex,
                    sourceLocation = parameters.sourceLocation,
                    sourceColumnIndex = parameters.sourceColumnIndex,
                    sourceColumnElement = parameters.sourceColumnElement,
                    targetLocation = parameters.targetLocation,
                    separator = that._getSeparator(targetLocation),
                    hasTargetColumnIndex = targetColumnIndex >= 0;
                var showSeparator = function() {
                        if (that._animationColumnIndex !== targetColumnIndex) {
                            that.hideSeparators();
                            separator.element()[parameters.isLast ? "insertAfter" : "insertBefore"](parameters.targetColumnElement);
                            that._animationColumnIndex = targetColumnIndex;
                            separator.show(targetLocation)
                        }
                    };
                that._columnHeadersView.element().find("." + DATAGRID_HEADER_ROW_CLASS).toggleClass(DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS, sourceLocation !== "headers" && targetLocation === "headers" && !hasTargetColumnIndex);
                if (separator) {
                    if (sourceColumnElement) {
                        sourceColumnElement.css({opacity: 0.5});
                        if (sourceLocation === "headers")
                            that._rowsView.setRowsOpacity(sourceColumnIndex, 0.5)
                    }
                    if (that.allowDrop(parameters) && hasTargetColumnIndex)
                        if (targetLocation === "group" || targetLocation === "columnChooser")
                            showSeparator();
                        else {
                            that.hideSeparators();
                            separator.moveByX(parameters.posX - separator.width());
                            separator.show()
                        }
                    else
                        that.hideSeparators()
                }
            },
            drop: function(parameters) {
                var sourceColumnElement = parameters.sourceColumnElement;
                if (sourceColumnElement) {
                    sourceColumnElement.css({opacity: ""});
                    this._rowsView.setRowsOpacity(parameters.sourceColumnIndex, "");
                    this._columnHeadersView.element().find("." + DATAGRID_HEADER_ROW_CLASS).removeClass(DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS)
                }
                if (this.allowDrop(parameters)) {
                    var separator = this._getSeparator(parameters.targetLocation);
                    if (separator)
                        separator.hide();
                    this._columnsController.moveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
                }
            },
            dispose: function() {
                if (this._draggingHeaderView)
                    this._unsubscribeFromEvents(this._draggingHeaderView, [this._columnChooserView, this._columnHeadersView, this._headerPanelView])
            }
        });
        dataGrid.__internals = $.extend({}, dataGrid.__internals, {
            DATAGRID_COLUMNS_SEPARATOR_CLASS: DATAGRID_COLUMNS_SEPARATOR_CLASS,
            DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT: DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT,
            DATAGRID_DRAGGING_HEADER_CLASS: DATAGRID_DRAGGING_HEADER_CLASS,
            DATAGRID_HEADERS_DRAG_ACTION_CLASS: DATAGRID_HEADERS_DRAG_ACTION_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_TRACKER_CLASS: DATAGRID_TRACKER_CLASS,
            DATAGRID_MODULE_NAMESPACE: DATAGRID_MODULE_NAMESPACE,
            DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS: DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS,
            WIDGET_CLASS: WIDGET_CLASS
        });
        dataGrid.registerModule("columnsResizingReordering", {
            views: {
                columnsSeparatorView: dataGrid.ColumnsSeparatorView,
                blockSeparatorView: dataGrid.BlockSeparatorView,
                draggingHeaderView: dataGrid.DraggingHeaderView,
                trackerView: dataGrid.TrackerView
            },
            controllers: {
                draggingHeader: dataGrid.DraggingHeaderViewController,
                tablePosition: dataGrid.TablePositionViewController,
                columnsResizer: dataGrid.ColumnsResizerViewController
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.contextMenuView.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_CLASS = "dx-datagrid",
            DATAGRID_CONTEXT_MENU = "dx-context-menu",
            viewName = {
                columnHeadersView: "header",
                rowsView: "content",
                footerView: "footer"
            },
            VIEW_NAMES = ["columnHeadersView", "rowsView", "footerView"];
        dataGrid.ContextMenuController = dataGrid.ViewController.inherit({
            init: function() {
                this.createAction("onContextMenuPreparing")
            },
            getContextMenuItems: function($targetElement) {
                var that = this,
                    view,
                    options,
                    rowIndex,
                    columnIndex,
                    $targetRowElement,
                    $targetCellElement,
                    menuItems;
                $.each(VIEW_NAMES, function() {
                    view = that.getView(this);
                    if (view && view.element().find($targetElement).length) {
                        $targetCellElement = $targetElement.closest("td");
                        $targetRowElement = $targetCellElement.closest(".dx-row");
                        rowIndex = view.getRowIndex($targetRowElement);
                        columnIndex = $targetCellElement[0] && $targetCellElement[0].cellIndex;
                        options = {
                            targetElement: $targetElement,
                            target: viewName[this],
                            rowIndex: rowIndex,
                            row: view._getRows()[rowIndex],
                            columnIndex: columnIndex,
                            column: view.getColumns()[columnIndex],
                            items: view.getContextMenuItems && view.getContextMenuItems($targetElement)
                        };
                        that.executeAction("onContextMenuPreparing", options);
                        menuItems = options.items;
                        if (menuItems)
                            return false
                    }
                });
                return menuItems
            }
        });
        dataGrid.ContextMenuView = dataGrid.View.inherit({_renderCore: function() {
                var that = this;
                this._createComponent(that.element().addClass(DATAGRID_CONTEXT_MENU), "dxContextMenu", {
                    onPositioning: function(actionArgs) {
                        var event = actionArgs.jQueryEvent,
                            $targetElement = $(event.target),
                            contextMenuInstance = actionArgs.component,
                            items = that.getController("contextMenu").getContextMenuItems($targetElement);
                        if (items) {
                            contextMenuInstance.option("items", items);
                            event.stopPropagation()
                        }
                        else
                            actionArgs.canceled = true
                    },
                    onItemClick: function(params) {
                        params.itemData.onItemClick && params.itemData.onItemClick(params)
                    },
                    cssClass: DATAGRID_CLASS,
                    target: that.component.element()
                })
            }});
        dataGrid.registerModule("contextMenu", {
            defaultOptions: function() {
                return {onContextMenuPreparing: null}
            },
            controllers: {contextMenu: dataGrid.ContextMenuController},
            views: {contextMenuView: dataGrid.ContextMenuView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.keyboardNavigation.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
            DATAGRID_ROWS_VIEW_CLASS = "dx-datagrid-rowsview",
            DATAGRID_MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row",
            DATAGRID_GROUP_FOOTER_CLASS = "dx-datagrid-group-footer",
            DATAGRID_COMMAND_EXPAND_CLASS = "dx-command-expand",
            DATAGRID_CLASS_SELECTOR = ".dx-datagrid",
            DATAGRID_INTERACTIVE_ELEMENTS_SELECTOR = ".dx-checkbox, .dx-menu, input, textarea",
            DATAGRID_VIEWS = ["rowsView"],
            DATAGRID_EDIT_MODE_ROW = "row";
        dataGrid.KeyboardNavigationController = dataGrid.ViewController.inherit({
            _focusView: function(view, viewIndex) {
                this._focusedViews.viewIndex = viewIndex;
                this._focusedView = view
            },
            _focusInteractiveElement: function($cell) {
                var $focusedElement = $cell.find(DATAGRID_INTERACTIVE_ELEMENTS_SELECTOR).first();
                this._testInteractiveElement = $focusedElement;
                $focusedElement.focus()
            },
            _updateFocus: function() {
                var that = this,
                    $cell = that._getFocusedCell();
                if ($cell) {
                    if (that._hasSkipRow($cell.parent()))
                        $cell = that._getNextCell("upArrow");
                    if ($cell && $cell.length > 0)
                        setTimeout(function() {
                            if (that.getController("editorFactory").focus())
                                that._focus($cell);
                            that._editingController.isEditing() && $.proxy(that._focusInteractiveElement, that)($cell)
                        })
                }
            },
            _clickHandler: function(e) {
                var event = e.jQueryEvent,
                    $cell = $(event.currentTarget),
                    $grid = $(event.target).closest(DATAGRID_CLASS_SELECTOR).parent();
                if ($grid.is(this.component.element()) && this._isCellValid($cell, true)) {
                    this._focusView(event.data.view, event.data.viewIndex);
                    this._updateFocusedCellPosition($cell);
                    if (!this._editingController.isEditing()) {
                        $cell.focus();
                        this._testCellIsFocused = true
                    }
                }
                else
                    this._resetFocusedCell(this)
            },
            _initFocusedViews: function() {
                var that = this,
                    clickAction = that.createAction(that._clickHandler);
                that._focusedViews = [];
                $.each(DATAGRID_VIEWS, function(key, viewName) {
                    var view = that.getView(viewName);
                    if (view && view.isVisible())
                        that._focusedViews.push(view)
                });
                $.each(that._focusedViews, function(index, view) {
                    if (view)
                        view.renderCompleted.add(function() {
                            var $element = view.element();
                            $element.off(events.addNamespace("dxpointerdown", "dxDataGridKeyboardNavigation"), clickAction);
                            $element.on(events.addNamespace("dxpointerdown", "dxDataGridKeyboardNavigation"), "." + DATAGRID_ROW_CLASS + " td", {
                                viewIndex: index,
                                view: view
                            }, clickAction);
                            that._initKeyDownProcessor(that, $element, that._keyDownHandler);
                            if (that._focusedView && that._focusedView.name === view.name && that._isNeedFocus)
                                that._updateFocus()
                        })
                })
            },
            _initKeyDownProcessor: function(context, element, handler) {
                if (this._keyDownProcessor) {
                    this._keyDownProcessor.dispose();
                    this._keyDownProcessor = null
                }
                this._keyDownProcessor = new ui.KeyboardProcessor({
                    element: element,
                    context: context,
                    handler: handler
                })
            },
            _getFocusedCell: function() {
                if (this._focusedView && this._focusedCellPosition)
                    return this._focusedView.getCell(this._focusedCellPosition)
            },
            _updateFocusedCellPosition: function($cell) {
                var that = this,
                    rowsView = that.getView("rowsView");
                if ($cell.length > 0)
                    this._focusedCellPosition = {
                        columnIndex: rowsView.getCellIndex($cell),
                        rowIndex: $cell.parent().length > 0 && that._focusedView ? that._focusedView.getRowIndex($cell.parent()) : null
                    }
            },
            _isCellValid: function($cell, allCommandColumns, skipDisabledCell) {
                if (utils.isDefined($cell)) {
                    var rowsView = this.getView("rowsView"),
                        visibleColumns = this._columnsController.getVisibleColumns(),
                        rowIndex = rowsView.getRowIndex($cell.parent()),
                        columnIndex = rowsView.getCellIndex($cell),
                        column = visibleColumns[columnIndex],
                        isRowEditMode = this._editingController.getEditMode() === DATAGRID_EDIT_MODE_ROW,
                        isValidGroupSpaceColumn = function() {
                            return column && !utils.isDefined(column.groupIndex) || parseInt($cell.attr("colspan")) > 1
                        };
                    if (visibleColumns.length > columnIndex && isValidGroupSpaceColumn()) {
                        var isExpandColumn = !allCommandColumns ? column.command === "expand" : false;
                        return column && !utils.isDefined(column.command) && (!skipDisabledCell || isRowEditMode && !this._editingController.isEditRow(rowIndex) || column.allowEditing) || isExpandColumn
                    }
                }
            },
            _isCellByPositionValid: function(cellPosition, allCommandColumns) {
                var $cell = this._focusedView && this._focusedView.getCell(cellPosition);
                return this._isCellValid($cell, allCommandColumns)
            },
            _isGroupRow: function($row) {
                return $row && $row.hasClass(DATAGRID_GROUP_ROW_CLASS)
            },
            _focus: function($cell) {
                var $row = $cell.parent(),
                    $focusedCell = this._getFocusedCell(),
                    $focusElement;
                $focusedCell && $focusedCell.attr("tabindex", null);
                if (this._isGroupRow($row)) {
                    $focusElement = $row;
                    this._focusedCellPosition.rowIndex = this._focusedView.getRowIndex($row)
                }
                else {
                    $focusElement = $cell;
                    this._updateFocusedCellPosition($cell)
                }
                $focusElement.attr("tabindex", 0);
                $focusElement.focus();
                this.getController("editorFactory").focus($focusElement)
            },
            _hasSkipRow: function($row) {
                return $row && ($row.hasClass(DATAGRID_MASTER_DETAIL_ROW_CLASS) || $row.hasClass(DATAGRID_GROUP_FOOTER_CLASS))
            },
            _enterKeyHandler: function(eventArgs, isEditing) {
                var $cell = this._getFocusedCell(),
                    editingOptions = this.option("editing"),
                    rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
                    $row = this._focusedView && this._focusedView.getRow(rowIndex);
                if (this.option("grouping.allowCollapsing") && this._isGroupRow($row) || this.option("masterDetail.enabled") && $cell.hasClass(DATAGRID_COMMAND_EXPAND_CLASS)) {
                    var key = this._dataController.getKeyByRowIndex(rowIndex),
                        item = this._dataController.items()[rowIndex];
                    if (key !== undefined && item && item.data && !item.data.isContinuation)
                        this._dataController.changeRowExpand(key)
                }
                else {
                    var isRowEditMode = this._editingController.getEditMode() === DATAGRID_EDIT_MODE_ROW;
                    if (isEditing) {
                        this._updateFocusedCellPosition(this._getCellElementFromTarget(eventArgs.originalEvent.target));
                        if (isRowEditMode)
                            setTimeout($.proxy(this._editingController.saveEditData, this._editingController));
                        else
                            this._editingController.closeEditCell()
                    }
                    else {
                        var column = this._columnsController.getVisibleColumns()[this._focusedCellPosition.columnIndex];
                        if (editingOptions.editEnabled && column.allowEditing)
                            if (isRowEditMode)
                                this._editingController.editRow(rowIndex);
                            else
                                this._focusedCellPosition && this._editingController.editCell(rowIndex, this._focusedCellPosition.columnIndex)
                    }
                }
            },
            _leftRightKeysHandler: function(eventArgs, isEditing) {
                var rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
                    $row = this._focusedView && this._focusedView.getRow(rowIndex),
                    directionCode,
                    $cell;
                if (!isEditing && !this._isGroupRow($row)) {
                    directionCode = this._getDirectionCodeByKey(eventArgs.key);
                    $cell = this._getNextCell(directionCode);
                    if ($cell && this._isCellValid($cell))
                        this._focus($cell);
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _getDirectionCodeByKey: function(key) {
                var directionCode;
                if (this.option("rtlEnabled"))
                    directionCode = key === "leftArrow" ? "nextInRow" : "previousInRow";
                else
                    directionCode = key === "leftArrow" ? "previousInRow" : "nextInRow";
                return directionCode
            },
            _upDownKeysHandler: function(eventArgs, isEditing) {
                var rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
                    $cell;
                if (!isEditing) {
                    if (rowIndex === 0 || this._focusedView && rowIndex === this._focusedView.getRowsCount() - 1);
                    $cell = this._getNextCell(eventArgs.key);
                    if ($cell && this._isCellValid($cell))
                        this._focus($cell);
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _pageUpKeyHandler: function(eventArgs) {
                var scrollingMode = this.option("scrolling.mode"),
                    pageIndex = this._dataController.pageIndex(),
                    isVirtualScrolling = scrollingMode === "virtual" || scrollingMode === "infinite";
                if (pageIndex > 0 && !isVirtualScrolling) {
                    this._dataController.pageIndex(pageIndex - 1);
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _pageDownKeyHandler: function(eventArgs) {
                var scrollingMode = this.option("scrolling.mode"),
                    isVirtualScrolling = scrollingMode === "virtual" || scrollingMode === "infinite",
                    pageIndex = this._dataController.pageIndex(),
                    pageCount = this._dataController.pageCount();
                if (pageIndex < pageCount - 1 && !isVirtualScrolling) {
                    this._dataController.pageIndex(pageIndex + 1);
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _spaceKeyHandler: function(eventArgs, isEditing) {
                var rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null;
                if (this.option("selection") && this.option("selection").mode !== "none" && !isEditing) {
                    this._selectionController.changeItemSelection(rowIndex, {
                        shift: eventArgs.shift,
                        control: eventArgs.ctrl
                    });
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _crtlAKeyHandler: function(eventArgs) {
                if (eventArgs.ctrl && this.option("selection.mode") === "multiple" && this.option("selection.allowSelectAll")) {
                    this._selectionController.selectAll();
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _tabKeyHandler: function(eventArgs, isEditing) {
                var editingOptions = this.option("editing"),
                    direction = eventArgs.shift ? "previous" : "next",
                    isOriginalHandlerRequired = !eventArgs.shift && this._isLastValidCell(this._focusedCellPosition) || eventArgs.shift && this._isFirstValidCell(this._focusedCellPosition),
                    $cell;
                if (editingOptions && eventArgs.originalEvent.target && !isOriginalHandlerRequired)
                    if (isEditing) {
                        var editMode = this._editingController.getEditMode(),
                            column,
                            isEditingAllowed;
                        this._updateFocusedCellPosition(this._getCellElementFromTarget(eventArgs.originalEvent.target));
                        $cell = this._getNextCell(direction, null, null, true);
                        column = this._columnsController.getVisibleColumns()[this.getView("rowsView").getCellIndex($cell)];
                        isEditingAllowed = editingOptions.editEnabled && column.allowEditing;
                        if (!isEditingAllowed)
                            this._editingController.closeEditCell();
                        if (this._focusCell($cell))
                            if (editMode !== DATAGRID_EDIT_MODE_ROW && isEditingAllowed)
                                this._editingController.editCell(this._focusedCellPosition.rowIndex, this._focusedCellPosition.columnIndex);
                            else
                                this._focusInteractiveElement($cell)
                    }
                    else {
                        $cell = this._getNextCell(direction, this._getElementType(eventArgs.originalEvent.target));
                        this._focusCell($cell)
                    }
                if (isOriginalHandlerRequired) {
                    if (this._editingController.isEditing() && this._editingController.getEditMode() !== DATAGRID_EDIT_MODE_ROW)
                        this._editingController.closeEditCell()
                }
                else
                    eventArgs.originalEvent.preventDefault()
            },
            _focusCell: function($cell) {
                if (this._isCellValid($cell)) {
                    this._focus($cell);
                    return true
                }
            },
            _getElementType: function(target) {
                return $(target).is("tr") ? "row" : "cell"
            },
            _escapeKeyHandler: function(eventArgs, isEditing) {
                if (isEditing) {
                    var $cell = this._getCellElementFromTarget(eventArgs.originalEvent.target);
                    this._updateFocusedCellPosition($cell);
                    if (this._editingController.getEditMode() !== DATAGRID_EDIT_MODE_ROW)
                        this._editingController.closeEditCell();
                    else
                        this._editingController.cancelEditData();
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _ctrlFKeyHandler: function(eventArgs) {
                if (eventArgs.ctrl && this.option("searchPanel") && this.option("searchPanel").visible) {
                    this._testHeaderPanelFocused = true;
                    this._headerPanel.focus();
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _keyDownHandler: function(e) {
                var isEditing = this._editingController.isEditing(),
                    args = {
                        handled: false,
                        jQueryEvent: e.originalEvent
                    };
                this.executeAction("onKeyDown", args);
                if (e.originalEvent.isDefaultPrevented())
                    return;
                this._isNeedFocus = true;
                this._isNeedScroll = true;
                if (!args.handled) {
                    switch (e.key) {
                        case"leftArrow":
                        case"rightArrow":
                            this._leftRightKeysHandler(e, isEditing);
                            break;
                        case"upArrow":
                        case"downArrow":
                            this._upDownKeysHandler(e, isEditing);
                            break;
                        case"pageUp":
                            this._pageUpKeyHandler(e);
                            break;
                        case"pageDown":
                            this._pageDownKeyHandler(e);
                            break;
                        case"space":
                            this._spaceKeyHandler(e, isEditing);
                            break;
                        case"A":
                            this._crtlAKeyHandler(e);
                            break;
                        case"tab":
                            this._tabKeyHandler(e, isEditing);
                            break;
                        case"enter":
                            this._enterKeyHandler(e, isEditing);
                            break;
                        case"escape":
                            this._escapeKeyHandler(e, isEditing);
                            break;
                        case"F":
                            this._ctrlFKeyHandler(e);
                            break
                    }
                    e.originalEvent.stopPropagation()
                }
            },
            _isLastRow: function(rowIndex) {
                return rowIndex === this.getController("data").items().length - 1
            },
            _getNextCell: function(keyCode, elementType, cellPosition, skipDisabledCell) {
                var focusedCellPosition = cellPosition || this._focusedCellPosition,
                    includeCommandCells = $.inArray(keyCode, ["next", "previous"]) > -1,
                    rowIndex,
                    newFocusedCellPosition,
                    $cell,
                    $row;
                if (this._focusedView && focusedCellPosition) {
                    newFocusedCellPosition = this._getNewPositionByCode({
                        columnIndex: focusedCellPosition.columnIndex,
                        rowIndex: focusedCellPosition.rowIndex
                    }, elementType, keyCode);
                    $cell = this._focusedView.getCell(newFocusedCellPosition);
                    if (!this._isCellValid($cell, null, skipDisabledCell) && this._isCellInRow(newFocusedCellPosition.columnIndex, includeCommandCells))
                        $cell = this._getNextCell(keyCode, "cell", newFocusedCellPosition, skipDisabledCell);
                    $row = $cell && $cell.parent();
                    if (this._hasSkipRow($row)) {
                        rowIndex = this._focusedView.getRowIndex($row);
                        if (!this._isLastRow(rowIndex))
                            $cell = this._getNextCell(keyCode, "row", $.extend({}, focusedCellPosition, {rowIndex: rowIndex}));
                        else
                            return null
                    }
                    return $cell
                }
                return null
            },
            _getNewPositionByCode: function(cellPosition, elementType, code) {
                var columnIndex = cellPosition.columnIndex,
                    rowIndex = cellPosition.rowIndex,
                    visibleColumnsCount = this.getController("columns").getVisibleColumns().length;
                switch (code) {
                    case"nextInRow":
                    case"next":
                        if (columnIndex < visibleColumnsCount - 1 && !this._isLastValidCell({
                            columnIndex: columnIndex,
                            rowIndex: rowIndex
                        }) && elementType !== "row")
                            columnIndex++;
                        else if (!this._isLastRow(rowIndex) && code === "next") {
                            columnIndex = 0;
                            rowIndex++
                        }
                        break;
                    case"previousInRow":
                    case"previous":
                        if (columnIndex > 0 && !this._isFirstValidCell({
                            columnIndex: columnIndex,
                            rowIndex: rowIndex
                        }) && elementType !== "row")
                            columnIndex--;
                        else if (rowIndex > 0 && code === "previous") {
                            columnIndex = visibleColumnsCount - 1;
                            rowIndex--
                        }
                        break;
                    case"upArrow":
                        rowIndex = rowIndex > 0 ? rowIndex - 1 : rowIndex;
                        break;
                    case"downArrow":
                        rowIndex = !this._isLastRow(rowIndex) ? rowIndex + 1 : rowIndex;
                        break
                }
                return {
                        columnIndex: columnIndex,
                        rowIndex: rowIndex
                    }
            },
            _isFirstValidCell: function(cellPosition) {
                var isFirstValidCell = false;
                if (cellPosition.rowIndex === 0 && cellPosition.columnIndex >= 0)
                    isFirstValidCell = isFirstValidCell || !this._haveValidCellBeforePosition(cellPosition);
                return isFirstValidCell
            },
            _haveValidCellBeforePosition: function(cellPosition) {
                var columnIndex = cellPosition.columnIndex,
                    hasValidCells = false;
                while (columnIndex > 0 && !hasValidCells) {
                    var checkingPosition = {
                            columnIndex: --columnIndex,
                            rowIndex: cellPosition.rowIndex
                        };
                    hasValidCells = this._isCellByPositionValid(checkingPosition)
                }
                return hasValidCells
            },
            _isLastValidCell: function(cellPosition) {
                var checkingPosition = {
                        columnIndex: cellPosition.columnIndex + 1,
                        rowIndex: cellPosition.rowIndex
                    },
                    visibleColumnsCount = this.getController("columns").getVisibleColumns().length,
                    isCheckingCellValid = this._isCellByPositionValid(checkingPosition);
                if (!this._isLastRow(cellPosition.rowIndex) || isCheckingCellValid)
                    return false;
                else if (cellPosition.columnIndex === visibleColumnsCount - 1)
                    return true;
                return this._isLastValidCell(checkingPosition)
            },
            _isCellInRow: function(columnIndex, includeCommandCells) {
                var visibleColumnsCount = this.getController("columns").getVisibleColumns().length;
                return includeCommandCells ? columnIndex >= 0 && columnIndex <= visibleColumnsCount - 1 : columnIndex > 0 && columnIndex < visibleColumnsCount - 1
            },
            _resetFocusedCell: function(that) {
                var $cell = that._getFocusedCell();
                $cell && $cell.attr("tabindex", null);
                that._isNeedFocus = false;
                that._isNeedScroll = false
            },
            _getCellElementFromTarget: function(target) {
                return $(target).closest("." + DATAGRID_ROW_CLASS + "> td")
            },
            init: function() {
                var that = this;
                if (that.option("useKeyboard")) {
                    that._dataController = that.getController("data");
                    that._selectionController = that.getController("selection");
                    that._editingController = that.getController("editing");
                    that._headerPanel = that.getView("headerPanel");
                    that._columnsController = that.getController("columns");
                    that.getController("editorFactory").focused.add(function($element) {
                        that.setupFocusedView();
                        if (that._isNeedScroll)
                            if ($element.is(":visible") && that._focusedView && that._focusedView.getScrollable) {
                                that._scrollToElement($element);
                                that._isNeedScroll = false
                            }
                    });
                    that._focusedCellPosition = {
                        columnIndex: 0,
                        rowIndex: 0
                    };
                    that._dataController.changed.add(function(change) {
                        if (that._focusedCellPosition && change && change.changeType === "prepend")
                            that._focusedCellPosition.rowIndex += change.items.length
                    });
                    that._initFocusedViews();
                    that._documentClickHandler = that.createAction(function(e) {
                        if (!$(e.jQueryEvent.target).closest("." + DATAGRID_ROWS_VIEW_CLASS).length)
                            that._resetFocusedCell(that)
                    });
                    that.createAction("onKeyDown");
                    $(document).on(events.addNamespace("dxpointerdown", "dxDataGridKeyboardNavigation"), that._documentClickHandler)
                }
            },
            _scrollToElement: function($element, offset) {
                this._focusedView.getScrollable().scrollToElement($element, offset)
            },
            focus: function($element) {
                var focusView = this._getFocusedViewByElement($element);
                if (focusView) {
                    this._focusView(focusView.view, focusView.viewIndex);
                    this._isNeedFocus = true;
                    this._isNeedScroll = true;
                    this._focus($element);
                    this._isHeaderView(focusView.view.name) && this._focusInteractiveElement($element)
                }
            },
            getFocusedView: function() {
                return this._focusedView
            },
            _getFocusedViewByElement: function($element) {
                var condition = function(view) {
                        return $element.closest(view._$element).length
                    };
                return this._getFocusedViewByCondition(condition)
            },
            _getFocusedViewByCondition: function(conditionFunction) {
                var focusView;
                $.each(this._focusedViews, function(index, view) {
                    if (conditionFunction(view)) {
                        focusView = {
                            viewIndex: index,
                            view: view
                        };
                        return false
                    }
                });
                return focusView
            },
            _isHeaderView: function(viewName) {
                return viewName === "columnHeadersView"
            },
            focusViewByName: function(viewName) {
                var view = this._getFocusedViewByName(viewName);
                this._focusView(view.view, view.viewIndex)
            },
            setupFocusedView: function() {
                if (!utils.isDefined(this._focusedView))
                    this.focusViewByName("rowsView")
            },
            _getFocusedViewByName: function(viewName) {
                var condition = function(view) {
                        return view.name === viewName
                    };
                return this._getFocusedViewByCondition(condition)
            },
            optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"useKeyboard":
                        args.handled = true;
                        break;
                    default:
                        that.callBase(args)
                }
            },
            dispose: function() {
                this.callBase();
                this._focusedView = null;
                this._focusedViews = null;
                this._keyDownProcessor && this._keyDownProcessor.dispose();
                $(document).off(events.addNamespace("dxpointerdown", "dxDataGridKeyboardNavigation"), this._documentClickHandler)
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_GROUP_ROW_CLASS: DATAGRID_GROUP_ROW_CLASS,
            DATAGRID_ROW_CLASS: DATAGRID_ROW_CLASS
        });
        dataGrid.registerModule("keyboardNavigation", {
            defaultOptions: function() {
                return {useKeyboard: true}
            },
            controllers: {keyboardNavigation: dataGrid.KeyboardNavigationController},
            extenders: {
                views: {rowsView: {_renderCore: function(change) {
                            this.callBase(change);
                            this.element().attr("tabindex", this.option("useKeyboard") ? 0 : null)
                        }}},
                controllers: {editing: {
                        editCell: function(rowIndex, columnIndex) {
                            var isCellEditing = this.callBase(rowIndex, columnIndex),
                                keyboardNavigationController = this.getController("keyboardNavigation");
                            if (isCellEditing)
                                keyboardNavigationController.setupFocusedView();
                            return isCellEditing
                        },
                        getFocusedCellInRow: function(rowIndex) {
                            var keyboardNavigationController = this.getController("keyboardNavigation"),
                                $cell = this.callBase(rowIndex);
                            if (this.option("useKeyboard") && keyboardNavigationController._focusedCellPosition.rowIndex === rowIndex)
                                $cell = keyboardNavigationController._getFocusedCell() || $cell;
                            return $cell
                        }
                    }}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.errorHandling.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_ERROR_ROW_CLASS = "dx-error-row",
            DATAGRID_ERROR_MESSAGE_CLASS = "dx-error-message",
            DATAGRID_ERROR_CLOSEBUTTON_CLASS = "dx-closebutton",
            DATAGRID_ACTION_CLASS = "dx-datagrid-action";
        dataGrid.ErrorHandlingController = dataGrid.ViewController.inherit({
            init: function() {
                var that = this;
                that._columnHeadersView = that.getView("columnHeadersView");
                that._rowsView = that.getView("rowsView")
            },
            _createErrorRow: function(message, $tableElements) {
                var that = this,
                    $errorRow = $("<tr />").addClass(DATAGRID_ERROR_ROW_CLASS),
                    $errorMessage = $("<div/>").addClass(DATAGRID_ERROR_MESSAGE_CLASS).text(message),
                    $closeButton = $("<div/>").addClass(DATAGRID_ERROR_CLOSEBUTTON_CLASS).addClass(DATAGRID_ACTION_CLASS);
                $closeButton.on("dxclick", that.createAction(function(args) {
                    var e = args.jQueryEvent,
                        $errorRow,
                        errorRowIndex = $(e.currentTarget).closest("." + DATAGRID_ERROR_ROW_CLASS).index();
                    e.stopPropagation();
                    $.each($tableElements, function(_, tableElement) {
                        $errorRow = $(tableElement).find("tbody > tr").eq(errorRowIndex);
                        that.removeErrorRow($errorRow)
                    })
                }));
                $("<td/>").attr({
                    colspan: that._columnHeadersView.getColumnCount(),
                    role: "presentation"
                }).prepend($closeButton).append($errorMessage).appendTo($errorRow);
                return $errorRow
            },
            renderErrorRow: function(message, rowIndex) {
                var that = this,
                    $row,
                    $errorRow,
                    rowElements,
                    viewElement = rowIndex >= 0 ? that._rowsView : that._columnHeadersView,
                    $tableElements = viewElement.getTableElements();
                $.each($tableElements, function(_, tableElement) {
                    $errorRow = that._createErrorRow(message, $tableElements);
                    rowElements = $(tableElement).find("tr");
                    if (rowIndex >= 0) {
                        $row = viewElement._getRowElements($(tableElement)).eq(rowIndex);
                        that.removeErrorRow(rowElements.eq($row.index() + 1));
                        $errorRow.insertAfter($row)
                    }
                    else {
                        that.removeErrorRow(rowElements.last());
                        $(tableElement).append($errorRow)
                    }
                })
            },
            removeErrorRow: function($row) {
                $row.hasClass(DATAGRID_ERROR_ROW_CLASS) && $row.remove()
            },
            optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"errorRowEnabled":
                        args.handled = true;
                        break;
                    default:
                        that.callBase(args)
                }
            }
        });
        dataGrid.registerModule("errorHandling", {
            defaultOptions: function() {
                return {errorRowEnabled: true}
            },
            controllers: {errorHandling: dataGrid.ErrorHandlingController},
            extenders: {controllers: {data: {init: function() {
                            var that = this,
                                errorHandlingController = that.getController("errorHandling");
                            that.callBase();
                            that.dataErrorOccurred.add(function(error) {
                                var message = error && error.message || error;
                                if (that.option("errorRowEnabled"))
                                    errorHandlingController.renderErrorRow(message)
                            })
                        }}}}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.summaryModule.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid,
            normalizeSortingInfo = DX.data.utils.normalizeSortingInfo;
        var DATAGRID_TOTAL_FOOTER_CLASS = "dx-datagrid-total-footer",
            DATAGRID_SUMMARY_ITEM_CLASS = "dx-datagrid-summary-item",
            DATAGRID_TEXT_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_GROUP_FOOTER_CLASS = "dx-datagrid-group-footer",
            DATAGRID_GROUP_TEXT_CONTENT_CLASS = "dx-datagrid-group-text-content",
            DATAGRID_GROUP_FOOTER_ROW_TYPE = "groupFooter";
        var renderSummaryCell = function($cell, options) {
                var i,
                    column = options.column,
                    summaryItems = options.summaryItems,
                    summaryItem,
                    $summaryItems = [];
                if (!column.command && summaryItems) {
                    for (i = 0; i < summaryItems.length; i++) {
                        summaryItem = summaryItems[i];
                        $summaryItems.push($("<div>").css("text-align", summaryItem.alignment || column.alignment).addClass(DATAGRID_SUMMARY_ITEM_CLASS).addClass(DATAGRID_TEXT_CONTENT_CLASS).addClass(summaryItem.cssClass).toggleClass(DATAGRID_GROUP_TEXT_CONTENT_CLASS, options.rowType === "group").text(dataGrid.getSummaryText(summaryItem, options.summaryTexts)))
                    }
                    $cell.append($summaryItems)
                }
            },
            getSummaryCellOptions = function(that, options) {
                var summaryTexts = that.option("summary.texts");
                return {
                        totalItem: options.row,
                        summaryItems: options.row.summaryCells[options.columnIndex],
                        summaryTexts: summaryTexts
                    }
            };
        dataGrid.FooterView = dataGrid.ColumnsView.inherit(function() {
            return {
                    _getRows: function() {
                        return this._dataController.footerItems()
                    },
                    _getCellOptions: function(options) {
                        return $.extend(this.callBase(options), getSummaryCellOptions(this, options))
                    },
                    _renderCellContent: function($cell, options) {
                        renderSummaryCell($cell, options);
                        this.callBase($cell, options)
                    },
                    _renderCore: function() {
                        var totalItem = this._dataController.footerItems()[0];
                        this.element().empty().addClass(DATAGRID_TOTAL_FOOTER_CLASS);
                        if (totalItem && totalItem.summaryCells && totalItem.summaryCells.length)
                            this._setTableElement(this._renderTable())
                    },
                    _renderTable: function() {
                        var $table = this.callBase.apply(this, arguments),
                            $content = this.element();
                        this.wrapTableInScrollContainer($table).appendTo($content);
                        return $table
                    },
                    _columnOptionChanged: function(e) {
                        var optionNames = e.optionNames;
                        if (e.changeTypes.grouping)
                            return;
                        if (optionNames.width || optionNames.visibleWidth)
                            this.callBase(e)
                    },
                    _handleDataChanged: function(e) {
                        if (e.changeType === "refresh")
                            this.render()
                    },
                    getHeight: function() {
                        var $element = this.element();
                        return $element ? $element.outerHeight() : 0
                    },
                    isVisible: function() {
                        return !!this._dataController.footerItems().length
                    }
                }
        }());
        var SummaryDataSourceAdapterExtender = function() {
                return {
                        init: function() {
                            this.callBase.apply(this, arguments);
                            this._totalAggregates = []
                        },
                        summary: function(summary) {
                            if (!arguments.length)
                                return this._summary;
                            this._summary = summary
                        },
                        totalAggregates: function() {
                            return this._totalAggregates
                        }
                    }
            }();
        var SummaryDataSourceAdapterClientExtender = function() {
                var calculateAggregates = function(that, summary, data, groupLevel) {
                        var calculator;
                        if (summary) {
                            calculator = new DX.data.AggregateCalculator({
                                totalAggregates: summary.totalAggregates,
                                groupAggregates: summary.groupAggregates,
                                data: data,
                                groupLevel: groupLevel
                            });
                            calculator.calculate()
                        }
                        that._totalAggregates = calculator ? calculator.totalAggregates() : []
                    };
                var sortGroupsBySummaryCore = function(items, groups, sortByGroups) {
                        if (!items || !groups.length)
                            return items;
                        var group = groups[0],
                            sorts = sortByGroups[0],
                            query;
                        if (group && sorts && sorts.length) {
                            query = DX.data.query(items);
                            $.each(sorts, function(index) {
                                if (index === 0)
                                    query = query.sortBy(this.selector, this.desc);
                                else
                                    query = query.thenBy(this.selector, this.desc)
                            });
                            query.enumerate().done(function(sortedItems) {
                                items = sortedItems
                            })
                        }
                        groups = groups.slice(1);
                        sortByGroups = sortByGroups.slice(1);
                        if (groups.length && sortByGroups.length)
                            $.each(items, function() {
                                this.items = sortGroupsBySummaryCore(this.items, groups, sortByGroups)
                            });
                        return items
                    };
                var sortGroupsBySummary = function(data, group, summary) {
                        var sortByGroups = summary && summary.sortByGroups && summary.sortByGroups();
                        if (sortByGroups && sortByGroups.length)
                            return sortGroupsBySummaryCore(data, group, sortByGroups);
                        return data
                    };
                return {_handleDataLoadedCore: function(options) {
                            var that = this,
                                groups = normalizeSortingInfo(options.loadOptions.group || []),
                                summary = that.summary();
                            calculateAggregates(that, summary, options.data, groups.length);
                            options.data = sortGroupsBySummary(options.data, groups, summary);
                            options.totalAggregates = that._totalAggregates;
                            that.callBase(options)
                        }}
            }();
        dataGrid.DataSourceAdapterServer = dataGrid.DataSourceAdapterServer.inherit(SummaryDataSourceAdapterExtender);
        dataGrid.DataSourceAdapterClient = dataGrid.DataSourceAdapterClient.inherit(SummaryDataSourceAdapterExtender).inherit(SummaryDataSourceAdapterClientExtender);
        dataGrid.renderSummaryCell = renderSummaryCell;
        $.extend(dataGrid.__internals, {
            DATAGRID_TOTAL_FOOTER_CLASS: DATAGRID_TOTAL_FOOTER_CLASS,
            DATAGRID_SUMMARY_ITEM_CLASS: DATAGRID_SUMMARY_ITEM_CLASS,
            DATAGRID_GROUP_FOOTER_CLASS: DATAGRID_GROUP_FOOTER_CLASS
        });
        dataGrid.registerModule("summary", {
            defaultOptions: function() {
                return {
                        summary: {
                            groupItems: undefined,
                            totalItems: undefined,
                            calculateCustomSummary: undefined,
                            texts: {
                                sum: Globalize.localize("dxDataGrid-summarySum"),
                                sumOtherColumn: Globalize.localize("dxDataGrid-summarySumOtherColumn"),
                                min: Globalize.localize("dxDataGrid-summaryMin"),
                                minOtherColumn: Globalize.localize("dxDataGrid-summaryMinOtherColumn"),
                                max: Globalize.localize("dxDataGrid-summaryMax"),
                                maxOtherColumn: Globalize.localize("dxDataGrid-summaryMaxOtherColumn"),
                                avg: Globalize.localize("dxDataGrid-summaryAvg"),
                                avgOtherColumn: Globalize.localize("dxDataGrid-summaryAvgOtherColumn"),
                                count: Globalize.localize("dxDataGrid-summaryCount")
                            }
                        },
                        sortByGroupSummaryInfo: undefined
                    }
            },
            views: {footerView: dataGrid.FooterView},
            extenders: {
                controllers: {data: function() {
                        return {
                                _isDataColumn: function(column) {
                                    return column && (!utils.isDefined(column.groupIndex) || column.showWhenGrouped)
                                },
                                _isGroupFooterVisible: function() {
                                    var groupItems = this.option("summary.groupItems") || [],
                                        groupItem,
                                        column,
                                        i;
                                    for (i = 0; i < groupItems.length; i++) {
                                        groupItem = groupItems[i];
                                        column = this._columnsController.columnOption(groupItem.column);
                                        if (groupItem.showInGroupFooter && this._isDataColumn(column))
                                            return true
                                    }
                                    return false
                                },
                                _processGroupItems: function(items, groupCount, options) {
                                    var result = this.callBase.apply(this, arguments);
                                    if (options) {
                                        if (options.isGroupFooterVisible === undefined)
                                            options.isGroupFooterVisible = this._isGroupFooterVisible();
                                        if (options.data && options.data.items && options.isGroupFooterVisible)
                                            result.push({
                                                rowType: DATAGRID_GROUP_FOOTER_ROW_TYPE,
                                                data: options.data,
                                                groupIndex: options.path.length - 1,
                                                values: []
                                            })
                                    }
                                    return result
                                },
                                _processGroupItem: function(groupItem, options) {
                                    var that = this;
                                    if (!options.summaryGroupItems)
                                        options.summaryGroupItems = that.option("summary.groupItems") || [];
                                    if (groupItem.rowType === "group") {
                                        var groupColumnIndex = -1,
                                            afterGroupColumnIndex = -1;
                                        $.each(options.visibleColumns, function(visibleIndex) {
                                            var prevColumn = options.visibleColumns[visibleIndex - 1];
                                            if (groupItem.groupIndex === this.groupIndex)
                                                groupColumnIndex = this.index;
                                            if (visibleIndex > 0 && prevColumn.command === "expand" && this.command !== "expand")
                                                afterGroupColumnIndex = this.index
                                        });
                                        groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, groupItem.data.aggregates || [], options.visibleColumns, function(summaryItem, column) {
                                            if (summaryItem.showInGroupFooter)
                                                return -1;
                                            if (summaryItem.alignByColumn && column && !utils.isDefined(column.groupIndex) && column.index !== afterGroupColumnIndex)
                                                return column.index;
                                            else
                                                return groupColumnIndex
                                        })
                                    }
                                    if (groupItem.rowType === DATAGRID_GROUP_FOOTER_ROW_TYPE)
                                        groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, groupItem.data.aggregates || [], options.visibleColumns, function(summaryItem, column) {
                                            return summaryItem.showInGroupFooter && that._isDataColumn(column) ? column.index : -1
                                        });
                                    return groupItem
                                },
                                _calculateSummaryCells: function(summaryItems, aggregates, visibleColumns, calculateTargetColumnIndex) {
                                    var that = this,
                                        summaryCells = [],
                                        summaryCellsByColumns = {};
                                    $.each(summaryItems, function(summaryIndex, summaryItem) {
                                        var column = that._columnsController.columnOption(summaryItem.column),
                                            showInColumn = summaryItem.showInColumn && that._columnsController.columnOption(summaryItem.showInColumn) || column,
                                            columnIndex = calculateTargetColumnIndex(summaryItem, showInColumn),
                                            aggregate;
                                        if (columnIndex >= 0) {
                                            if (!summaryCellsByColumns[columnIndex])
                                                summaryCellsByColumns[columnIndex] = [];
                                            aggregate = aggregates[summaryIndex];
                                            if (utils.isDefined(aggregate) && !isNaN(aggregate))
                                                summaryCellsByColumns[columnIndex].push($.extend({}, summaryItem, {
                                                    value: aggregate,
                                                    valueFormat: !utils.isDefined(summaryItem.valueFormat) ? dataGrid.getFormatByDataType(column && column.dataType) : summaryItem.valueFormat,
                                                    columnCaption: column && column.index !== columnIndex ? column.caption : undefined
                                                }))
                                        }
                                    });
                                    if (!$.isEmptyObject(summaryCellsByColumns))
                                        $.each(visibleColumns, function() {
                                            summaryCells.push(summaryCellsByColumns[this.index] || [])
                                        });
                                    return summaryCells
                                },
                                _getSummaryCells: function(summaryTotalItems, totalAggregates) {
                                    var that = this,
                                        columnsController = that._columnsController;
                                    return that._calculateSummaryCells(summaryTotalItems, totalAggregates, columnsController.getVisibleColumns(), function(summaryItem, column) {
                                            return that._isDataColumn(column) ? column.index : -1
                                        })
                                },
                                _updateItemsCore: function(change) {
                                    var that = this,
                                        summaryCells,
                                        totalAggregates,
                                        dataSource = that._dataSource,
                                        summaryTotalItems = that.option("summary.totalItems");
                                    that.callBase(change);
                                    that._footerItems = [];
                                    if (dataSource && summaryTotalItems && summaryTotalItems.length) {
                                        totalAggregates = dataSource.totalAggregates();
                                        summaryCells = this._getSummaryCells(summaryTotalItems, totalAggregates);
                                        if (summaryCells.length)
                                            that._footerItems.push({
                                                rowType: "totalFooter",
                                                summaryCells: summaryCells
                                            })
                                    }
                                },
                                _getAggregates: function(summaryItems) {
                                    var that = this,
                                        columnsController = that.getController("columns"),
                                        calculateCustomSummary = that.option("summary.calculateCustomSummary");
                                    return $.map(summaryItems || [], function(summaryItem) {
                                            var column = columnsController.columnOption(summaryItem.column),
                                                calculateCellValue = column && column.calculateCellValue ? $.proxy(column, "calculateCellValue") : DX.data.utils.compileGetter(column ? column.dataField : summaryItem.column),
                                                aggregator = summaryItem.summaryType || "count",
                                                selector = calculateCellValue,
                                                options;
                                            if (aggregator === "avg" || aggregator === "sum")
                                                selector = function(data) {
                                                    return Number(calculateCellValue(data))
                                                };
                                            if (aggregator === "custom") {
                                                if (!calculateCustomSummary) {
                                                    DX.log("E1026");
                                                    calculateCustomSummary = function(){}
                                                }
                                                options = {
                                                    component: that.component,
                                                    name: summaryItem.name
                                                };
                                                calculateCustomSummary(options);
                                                options.summaryProcess = "calculate";
                                                aggregator = {
                                                    seed: function() {
                                                        options.summaryProcess = "start";
                                                        options.totalValue = undefined;
                                                        delete options.value;
                                                        calculateCustomSummary(options);
                                                        return options.totalValue
                                                    },
                                                    step: function(totalValue, value) {
                                                        options.summaryProcess = "calculate";
                                                        options.totalValue = totalValue;
                                                        options.value = value;
                                                        calculateCustomSummary(options);
                                                        return options.totalValue
                                                    },
                                                    finalize: function(totalValue) {
                                                        options.summaryProcess = "finalize";
                                                        options.totalValue = totalValue;
                                                        delete options.value;
                                                        calculateCustomSummary(options);
                                                        return options.totalValue
                                                    }
                                                }
                                            }
                                            return {
                                                    selector: selector,
                                                    aggregator: aggregator
                                                }
                                        })
                                },
                                _addSortInfo: function(sortByGroups, groupColumn, selector, sortOrder) {
                                    var groupIndex;
                                    if (groupColumn) {
                                        groupIndex = groupColumn.groupIndex;
                                        sortOrder = sortOrder || groupColumn.sortOrder;
                                        if (utils.isDefined(groupIndex)) {
                                            sortByGroups[groupIndex] = sortByGroups[groupIndex] || [];
                                            sortByGroups[groupIndex].push({
                                                selector: selector,
                                                desc: sortOrder === "desc"
                                            })
                                        }
                                    }
                                },
                                _findSummaryItem: function(summaryItems, name) {
                                    var summaryItemIndex = -1;
                                    var getFullName = function(summaryItem) {
                                            var summaryType = summaryItem.summaryType,
                                                column = summaryItem.column;
                                            return summaryType && column && summaryType + "_" + column
                                        };
                                    if (utils.isDefined(name))
                                        $.each(summaryItems || [], function(index) {
                                            if (this.name === name || index === name || this.summaryType === name || this.column === name || getFullName(this) === name) {
                                                summaryItemIndex = index;
                                                return false
                                            }
                                        });
                                    return summaryItemIndex
                                },
                                _getSummarySortByGroups: function(sortByGroupSummaryInfo, groupSummaryItems) {
                                    var that = this,
                                        columnsController = that._columnsController,
                                        groupColumns = columnsController.getGroupColumns(),
                                        sortByGroups = [];
                                    if (!groupSummaryItems || !groupSummaryItems.length)
                                        return;
                                    $.each(sortByGroupSummaryInfo || [], function() {
                                        var sortOrder = this.sortOrder,
                                            groupColumn = this.groupColumn,
                                            summaryItemIndex = that._findSummaryItem(groupSummaryItems, this.summaryItem);
                                        if (summaryItemIndex < 0)
                                            return;
                                        var selector = function(data) {
                                                return data.aggregates[summaryItemIndex]
                                            };
                                        if (utils.isDefined(groupColumn)) {
                                            groupColumn = columnsController.columnOption(groupColumn);
                                            that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder)
                                        }
                                        else
                                            $.each(groupColumns, function(groupIndex, groupColumn) {
                                                that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder)
                                            })
                                    });
                                    return sortByGroups
                                },
                                _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
                                    var summary = this._getSummaryOptions(),
                                        dataSourceAdapter;
                                    if (remoteOperations === "auto" && summary && !(dataSource.store() instanceof DX.data.ArrayStore))
                                        remoteOperations = {
                                            filtering: true,
                                            sorting: true,
                                            paging: false
                                        };
                                    dataSourceAdapter = this.callBase(dataSource, remoteOperations);
                                    dataSourceAdapter.summary(summary);
                                    return dataSourceAdapter
                                },
                                _getSummaryOptions: function() {
                                    var that = this,
                                        groupSummaryItems = that.option("summary.groupItems"),
                                        totalSummaryItems = that.option("summary.totalItems"),
                                        sortByGroupSummaryInfo = that.option("sortByGroupSummaryInfo"),
                                        groupAggregates = that._getAggregates(groupSummaryItems),
                                        totalAggregates = that._getAggregates(totalSummaryItems),
                                        sortByGroups = function() {
                                            return that._getSummarySortByGroups(sortByGroupSummaryInfo, groupSummaryItems)
                                        };
                                    if (groupAggregates.length || totalAggregates.length)
                                        return {
                                                groupAggregates: groupAggregates,
                                                totalAggregates: totalAggregates,
                                                sortByGroups: sortByGroups
                                            }
                                },
                                publicMethods: function() {
                                    var methods = this.callBase();
                                    methods.push("getTotalSummaryValue");
                                    return methods
                                },
                                getTotalSummaryValue: function(summaryItemName) {
                                    var summaryItemIndex = this._findSummaryItem(this.option("summary.totalItems"), summaryItemName),
                                        aggregates = this._dataSource.totalAggregates();
                                    if (aggregates.length && summaryItemIndex > -1)
                                        return aggregates[summaryItemIndex]
                                },
                                optionChanged: function(args) {
                                    if (args.name === "summary" || args.name === "sortByGroupSummaryInfo")
                                        args.name = "dataSource";
                                    this.callBase(args)
                                },
                                init: function() {
                                    this._footerItems = [];
                                    this.callBase()
                                },
                                footerItems: function() {
                                    return this._footerItems
                                }
                            }
                    }()},
                views: {rowsView: function() {
                        return {
                                _createRow: function(row) {
                                    var $row = this.callBase(row);
                                    row && $row.addClass(row.rowType === DATAGRID_GROUP_FOOTER_ROW_TYPE ? DATAGRID_GROUP_FOOTER_CLASS : "");
                                    return $row
                                },
                                _renderCells: function($row, options) {
                                    this.callBase.apply(this, arguments);
                                    if (options.row.rowType === "group" && options.row.summaryCells && options.row.summaryCells.length)
                                        this._renderGroupSummaryCells($row, options)
                                },
                                _hasAlignByColumnSummaryItems: function(columnIndex, options) {
                                    return !utils.isDefined(options.columns[columnIndex].groupIndex) && options.row.summaryCells[columnIndex].length
                                },
                                _getAlignByColumnCellCount: function(groupCellColSpan, options) {
                                    var alignByColumnCellCount = 0,
                                        columnIndex;
                                    for (var i = 1; i < groupCellColSpan; i++) {
                                        columnIndex = options.row.summaryCells.length - i;
                                        alignByColumnCellCount = this._hasAlignByColumnSummaryItems(columnIndex, options) ? i : alignByColumnCellCount
                                    }
                                    return alignByColumnCellCount
                                },
                                _renderGroupSummaryCells: function($row, options) {
                                    var $groupCell = $row.children().last(),
                                        groupCellColSpan = Number($groupCell.attr("colspan")) || 1,
                                        alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);
                                    this._renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount)
                                },
                                _renderGroupSummaryCellsCore: function($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
                                    if (alignByColumnCellCount > 0) {
                                        $groupCell.attr("colspan", groupCellColSpan - alignByColumnCellCount);
                                        for (var i = 0; i < alignByColumnCellCount; i++) {
                                            var columnIndex = options.columns.length - alignByColumnCellCount + i;
                                            this._renderCell($groupCell.parent(), $.extend({
                                                column: options.columns[columnIndex],
                                                columnIndex: columnIndex
                                            }, options))
                                        }
                                    }
                                },
                                _getColumnTemplate: function(options) {
                                    if (!options.column.command && !utils.isDefined(options.column.groupIndex) && options.summaryItems && options.summaryItems.length)
                                        return renderSummaryCell;
                                    else
                                        return this.callBase(options)
                                },
                                _getCellOptions: function(options) {
                                    var that = this,
                                        parameters = that.callBase(options);
                                    if (options.row.summaryCells)
                                        return $.extend(parameters, getSummaryCellOptions(that, options));
                                    else
                                        return parameters
                                }
                            }
                    }()}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.masterDetailModule.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid,
            DATAGRID_MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
            DATAGRID_MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row",
            DATAGRID_ROW_LINES_CLASS = "dx-row-lines";
        $.extend(dataGrid.__internals, {
            DATAGRID_MASTER_DETAIL_CELL_CLASS: DATAGRID_MASTER_DETAIL_CELL_CLASS,
            DATAGRID_MASTER_DETAIL_ROW_CLASS: DATAGRID_MASTER_DETAIL_ROW_CLASS,
            DATAGRID_ROW_LINES_CLASS: DATAGRID_ROW_LINES_CLASS
        });
        dataGrid.registerModule("masterDetail", {
            defaultOptions: function() {
                return {masterDetail: {
                            enabled: false,
                            autoExpandAll: false,
                            template: null
                        }}
            },
            extenders: {
                controllers: {
                    editorFactory: {focus: function($element, hideBorder) {
                            if ($element && $element.hasClass(DATAGRID_MASTER_DETAIL_CELL_CLASS))
                                this.loseFocus();
                            else
                                return this.callBase($element, hideBorder)
                        }},
                    columns: {_getExpandColumnsCore: function() {
                            var expandColumns = this.callBase();
                            if (this.option("masterDetail.enabled"))
                                expandColumns.push({});
                            return expandColumns
                        }},
                    data: function() {
                        var initMasterDetail = function(that) {
                                that._expandedItems = [];
                                that._isExpandAll = that.option("masterDetail.autoExpandAll")
                            };
                        return {
                                init: function() {
                                    var that = this;
                                    initMasterDetail(that);
                                    that.callBase()
                                },
                                expandAll: function(groupIndex) {
                                    var that = this;
                                    if (groupIndex < 0) {
                                        that._isExpandAll = true;
                                        that._expandedItems = [];
                                        that.updateItems()
                                    }
                                    else
                                        that.callBase.apply(that, arguments)
                                },
                                collapseAll: function(groupIndex) {
                                    var that = this;
                                    if (groupIndex < 0) {
                                        that._isExpandAll = false;
                                        that._expandedItems = [];
                                        that.updateItems()
                                    }
                                    else
                                        that.callBase.apply(that, arguments)
                                },
                                isRowExpanded: function(key) {
                                    var that = this,
                                        expandIndex = dataGrid.getIndexByKey(key, that._expandedItems);
                                    if (utils.isArray(key))
                                        return that.callBase.apply(that, arguments);
                                    else
                                        return !!(that._isExpandAll ^ (expandIndex >= 0 && that._expandedItems[expandIndex].visible))
                                },
                                _changeRowExpandCore: function(key) {
                                    var that = this,
                                        expandIndex,
                                        rowIndex;
                                    if (utils.isArray(key))
                                        return that.callBase.apply(that, arguments);
                                    else {
                                        expandIndex = dataGrid.getIndexByKey(key, that._expandedItems);
                                        if (expandIndex >= 0) {
                                            var visible = that._expandedItems[expandIndex].visible;
                                            that._expandedItems[expandIndex].visible = !visible
                                        }
                                        else
                                            that._expandedItems.push({
                                                key: key,
                                                visible: true
                                            });
                                        rowIndex = that.getRowIndexByKey(key);
                                        that.updateItems({
                                            changeType: "update",
                                            rowIndices: [rowIndex, rowIndex + 1]
                                        })
                                    }
                                },
                                _processDataItem: function(data, options) {
                                    var that = this,
                                        dataItem = that.callBase.apply(that, arguments);
                                    dataItem.isExpanded = that.isRowExpanded(dataItem.key);
                                    if (options.detailColumnIndex === undefined) {
                                        options.detailColumnIndex = -1;
                                        $.each(options.visibleColumns, function(index, column) {
                                            if (column.command === "expand" && !utils.isDefined(column.groupIndex)) {
                                                options.detailColumnIndex = index;
                                                return false
                                            }
                                        })
                                    }
                                    if (options.detailColumnIndex >= 0)
                                        dataItem.values[options.detailColumnIndex] = dataItem.isExpanded;
                                    return dataItem
                                },
                                _processItems: function(items, changeType) {
                                    var that = this,
                                        expandIndex,
                                        result = [];
                                    items = that.callBase.apply(that, arguments);
                                    if (this._isLoadingAll)
                                        return items;
                                    if (changeType === "refresh")
                                        that._expandedItems = $.grep(that._expandedItems, function(item) {
                                            return item.visible
                                        });
                                    $.each(items, function(index, item) {
                                        result.push(item);
                                        expandIndex = dataGrid.getIndexByKey(item.key, that._expandedItems);
                                        if (item.rowType === "data" && (item.isExpanded || expandIndex >= 0) && !item.inserted)
                                            result.push({
                                                visible: item.isExpanded,
                                                rowType: "detail",
                                                key: item.key,
                                                data: item.data,
                                                values: []
                                            })
                                    });
                                    return result
                                },
                                optionChanged: function(args) {
                                    var that = this,
                                        value,
                                        previousValue,
                                        isEnabledChanged,
                                        isAutoExpandAllChanged;
                                    if (args.name === "masterDetail") {
                                        args.name = "dataSource";
                                        switch (args.fullName) {
                                            case"masterDetail":
                                                value = args.value || {};
                                                previousValue = args.previousValue || {};
                                                isEnabledChanged = value.enabled !== previousValue.enabled;
                                                isAutoExpandAllChanged = value.autoExpandAll !== previousValue.autoExpandAll;
                                                break;
                                            case"masterDetail.enabled":
                                                isEnabledChanged = true;
                                                break;
                                            case"masterDetail.autoExpandAll":
                                                isAutoExpandAllChanged = true;
                                                break
                                        }
                                        if (isEnabledChanged || isAutoExpandAllChanged)
                                            initMasterDetail(that)
                                    }
                                    that.callBase(args)
                                },
                                refresh: function() {
                                    var that = this;
                                    initMasterDetail(that);
                                    return that.callBase.apply(that, arguments)
                                }
                            }
                    }()
                },
                views: {rowsView: function() {
                        return {
                                _getColumnTemplate: function(options) {
                                    var that = this,
                                        column = options.column,
                                        template;
                                    if (column.command === "detail")
                                        template = that.option("masterDetail.template") || that._getDefaultTemplate(column);
                                    else
                                        template = that.callBase.apply(that, arguments);
                                    return template
                                },
                                _createRow: function(row) {
                                    var $row = this.callBase(row);
                                    if (row && row.rowType === "detail") {
                                        this.option("showRowLines") && $row.addClass(DATAGRID_ROW_LINES_CLASS);
                                        $row.addClass(DATAGRID_MASTER_DETAIL_ROW_CLASS).toggle(row.visible)
                                    }
                                    return $row
                                },
                                _getGroupCellOptions: function(options) {
                                    var row = options.row,
                                        groupColumns = this._columnsController.getGroupColumns(),
                                        columnIndex = groupColumns.length + options.columnsCountBeforeGroups,
                                        emptyCellsCount = columnIndex + Number(this.option("masterDetail.enabled"));
                                    if (row && row.rowType === "detail")
                                        return {
                                                columnIndex: columnIndex,
                                                emptyCellsCount: emptyCellsCount,
                                                colspan: options.columns.length - emptyCellsCount
                                            };
                                    return this.callBase(options)
                                },
                                _renderCells: function($row, options) {
                                    var row = options.row,
                                        $detailCell,
                                        groupCellOptions = this._getGroupCellOptions(options),
                                        i;
                                    if (row.rowType === "detail") {
                                        for (i = 0; i < groupCellOptions.emptyCellsCount; i++)
                                            this._renderCell($row, {
                                                value: null,
                                                row: row,
                                                rowIndex: row.rowIndex,
                                                column: options.columns[i]
                                            });
                                        $detailCell = this._renderCell($row, {
                                            value: null,
                                            row: row,
                                            rowIndex: row.rowIndex,
                                            column: {command: "detail"},
                                            columnIndex: groupCellOptions.columnIndex
                                        });
                                        $detailCell.addClass(DATAGRID_MASTER_DETAIL_CELL_CLASS).attr("colspan", groupCellOptions.colspan)
                                    }
                                    else
                                        this.callBase.apply(this, arguments)
                                }
                            }
                    }()}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.fixedColumns.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
            DATAGRID_FIRST_CELL_CLASS = "dx-first-cell",
            DATAGRID_HOVER_STATE_CLASS = "dx-state-hover",
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            DATAGRID_CONTENT_FIXED_CLASS = "dx-datagrid-content-fixed",
            DATAGRID_FIXED_COL_CLASS = "dx-col-fixed",
            DATAGRID_POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target",
            DATAGRID_POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
            getTransparentColumnIndex = function(fixedColumns) {
                var transparentColumnIndex = -1;
                $.each(fixedColumns, function(index, column) {
                    if (column.command === "transparent") {
                        transparentColumnIndex = index;
                        return false
                    }
                });
                return transparentColumnIndex
            };
        var baseFixedColumns = {
                init: function() {
                    this.callBase();
                    this._isFixedTableRendering = false;
                    this._isFixedColumns = false
                },
                _createCol: function(column) {
                    return this.callBase(column).toggleClass(DATAGRID_FIXED_COL_CLASS, this._isFixedTableRendering && (column.fixed || column.command && column.command !== "transparent"))
                },
                _createCell: function(column) {
                    var $cell = this.callBase(column);
                    if (column.colspan)
                        $cell.attr("colspan", column.colspan);
                    if (column.command === "transparent")
                        $cell.addClass(DATAGRID_POINTER_EVENTS_NONE_CLASS);
                    return $cell
                },
                _renderTable: function(options) {
                    var that = this,
                        $fixedTable,
                        $table,
                        fixedColumns = that._columnsController.getFixedColumns();
                    that._isFixedColumns = !!fixedColumns.length;
                    $table = that.callBase(options);
                    if (that._isFixedColumns) {
                        that._isFixedTableRendering = true;
                        that._fixedTableElement = $fixedTable = that._createTable(fixedColumns);
                        $fixedTable.addClass(DATAGRID_POINTER_EVENTS_NONE_CLASS);
                        that._renderRows($fixedTable, $.extend({}, options, {columns: fixedColumns}));
                        that.wrapTableInScrollContainer(that._fixedTableElement).appendTo(that.element()).addClass(DATAGRID_CONTENT_FIXED_CLASS + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS);
                        that._isFixedTableRendering = false
                    }
                    else {
                        that._fixedTableElement && that._fixedTableElement.remove();
                        that._fixedTableElement = null
                    }
                    return $table
                },
                _renderCellContent: function($cell, options) {
                    var that = this,
                        trasparentColumnIndex,
                        column = options.column;
                    if (!that._isFixedTableRendering && that._isFixedColumns && (options.rowType !== "group" || !utils.isDefined(column.groupIndex))) {
                        if (column.fixed || column.command) {
                            $cell.html("&nbsp;").addClass(column.cssClass);
                            return
                        }
                        if (options.rowType === "filter") {
                            that.callBase($cell, options);
                            trasparentColumnIndex = getTransparentColumnIndex(that._columnsController.getFixedColumns());
                            $cell.toggleClass(DATAGRID_FIRST_CELL_CLASS, options.columnIndex === trasparentColumnIndex);
                            return
                        }
                    }
                    if (column.command !== "transparent")
                        that.callBase($cell, options)
                },
                getCellElements: function(rowIndex) {
                    var that = this,
                        fixedColumns,
                        fixedColumnIndex = 0,
                        fixedCellElements,
                        cellElements = that.callBase(rowIndex);
                    if (that._fixedTableElement && cellElements) {
                        fixedColumns = that._columnsController.getFixedColumns(),
                        fixedCellElements = that._fixedTableElement.find(".dx-row").eq(rowIndex).children("td");
                        $.each(fixedColumns, function(index, column) {
                            if (column.command === "transparent")
                                fixedColumnIndex += column.colspan;
                            else {
                                cellElements[fixedColumnIndex] = fixedCellElements.get(index);
                                fixedColumnIndex++
                            }
                        })
                    }
                    return cellElements
                },
                getColumnWidths: function() {
                    var that = this,
                        i,
                        fixedColumnIndex = 0,
                        widths,
                        result = that.callBase(),
                        fixedColumns = that._columnsController.getFixedColumns();
                    if (that._fixedTableElement && result.length) {
                        widths = dataGrid.getWidths(that._fixedTableElement);
                        for (i = 0; i < fixedColumns.length; i++)
                            if (fixedColumns[i].command === "transparent")
                                fixedColumnIndex += fixedColumns[i].colspan;
                            else {
                                if (result[fixedColumnIndex] < widths[i])
                                    result[fixedColumnIndex] = widths[i];
                                fixedColumnIndex++
                            }
                    }
                    return result
                },
                _getTableElement: function() {
                    var tableElement = this._isFixedTableRendering ? this._fixedTableElement : this.callBase();
                    return tableElement
                },
                _setTableElement: function(tableElement) {
                    if (this._isFixedTableRendering)
                        this._fixedTableElement = tableElement;
                    else
                        this.callBase(tableElement)
                },
                getColumns: function($tableElement) {
                    $tableElement = $tableElement || this._getTableElement();
                    if (this._isFixedTableRendering || $tableElement && $tableElement.closest("table").parent("." + DATAGRID_CONTENT_FIXED_CLASS).length)
                        return this._columnsController.getFixedColumns();
                    return this.callBase($tableElement)
                },
                getRowIndex: function($row) {
                    var $fixedTable = this._fixedTableElement;
                    if ($fixedTable && $fixedTable.find($row).length)
                        return this._getRowElements($fixedTable).index($row);
                    return this.callBase($row)
                },
                getTableElements: function() {
                    var result = this.callBase.apply(this, arguments);
                    if (this._fixedTableElement)
                        result = result.add(this._fixedTableElement);
                    return result
                },
                getFixedColumns: function() {
                    return this._columnsController.getFixedColumns()
                },
                getFixedColumnsOffset: function() {
                    var offset = {
                            left: 0,
                            right: 0
                        },
                        $transparentColumn,
                        positionTransparentColumn;
                    if (this._fixedTableElement) {
                        $transparentColumn = this.getTransparentColumnElement();
                        positionTransparentColumn = $transparentColumn.position();
                        offset = {
                            left: positionTransparentColumn.left,
                            right: this.element().outerWidth(true) - ($transparentColumn.outerWidth(true) + positionTransparentColumn.left)
                        }
                    }
                    return offset
                },
                getTransparentColumnElement: function() {
                    return this._fixedTableElement && this._fixedTableElement.find("." + DATAGRID_POINTER_EVENTS_NONE_CLASS).first()
                },
                isFixedColumns: function() {
                    return this._isFixedColumns
                },
                _resizeCore: function() {
                    this.callBase();
                    this._synchronizeRows()
                },
                setColumnWidths: function(widths) {
                    this.callBase(widths);
                    this._synchronizeRows()
                },
                _getClientHeight: function(element) {
                    var boundingClientRectElement = element.getBoundingClientRect && element.getBoundingClientRect();
                    return boundingClientRectElement && boundingClientRectElement.height ? boundingClientRectElement.height : element.clientHeight
                },
                _synchronizeRows: function() {
                    var that = this,
                        rowHeight,
                        fixedRowHeight,
                        rowIndex,
                        heightTable,
                        heightFixedTable,
                        $rowElements,
                        $fixedRowElements;
                    if (that._isFixedColumns && that._tableElement && that._fixedTableElement) {
                        heightTable = that._getClientHeight(that._tableElement.get(0));
                        heightFixedTable = that._getClientHeight(that._fixedTableElement.get(0));
                        $rowElements = that._getRowElements(that._tableElement);
                        $fixedRowElements = that._getRowElements(that._fixedTableElement);
                        if (heightTable !== heightFixedTable) {
                            $rowElements.height("");
                            $fixedRowElements.height("");
                            for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
                                rowHeight = that._getClientHeight($rowElements.get(rowIndex));
                                fixedRowHeight = that._getClientHeight($fixedRowElements.get(rowIndex));
                                if (rowHeight > fixedRowHeight)
                                    $fixedRowElements.eq(rowIndex).css("height", rowHeight);
                                else if (rowHeight < fixedRowHeight)
                                    $rowElements.eq(rowIndex).css("height", fixedRowHeight)
                            }
                        }
                    }
                }
            };
        var ColumnHeadersViewFixedColumnsExtender = $.extend({}, baseFixedColumns, {
                getContextMenuItems: function($targetElement) {
                    var that = this,
                        $cell,
                        column,
                        onItemClick,
                        columnFixingOptions = that.option("columnFixing"),
                        items = that.callBase($targetElement);
                    if ($targetElement.closest("." + DATAGRID_HEADER_ROW_CLASS).length) {
                        $cell = $targetElement.closest("td");
                        column = $cell.length && that.getColumns($targetElement)[$cell[0].cellIndex];
                        if (column.allowFixing) {
                            onItemClick = function(params) {
                                switch (params.itemData.value) {
                                    case"none":
                                        that._columnsController.columnOption(column.index, "fixed", false);
                                        break;
                                    case"left":
                                        that._columnsController.columnOption(column.index, {
                                            fixed: true,
                                            fixedPosition: "left"
                                        });
                                        break;
                                    case"right":
                                        that._columnsController.columnOption(column.index, {
                                            fixed: true,
                                            fixedPosition: "right"
                                        });
                                        break
                                }
                            };
                            items.push({
                                text: columnFixingOptions.texts.fix,
                                beginGroup: true,
                                items: [{
                                        text: columnFixingOptions.texts.leftPosition,
                                        value: "left",
                                        disabled: column.fixed && (!column.fixedPosition || column.fixedPosition === "left"),
                                        onItemClick: onItemClick
                                    }, {
                                        text: columnFixingOptions.texts.rightPosition,
                                        value: "right",
                                        disabled: column.fixed && column.fixedPosition === "right",
                                        onItemClick: onItemClick
                                    }]
                            }, {
                                text: columnFixingOptions.texts.unfix,
                                value: "none",
                                disabled: !column.fixed,
                                onItemClick: onItemClick
                            })
                        }
                    }
                    return items
                },
                setScrollerSpacing: function(width) {
                    var that = this,
                        rtlEnabled = that.option("rtlEnabled");
                    that.callBase(width);
                    that.element().children("." + DATAGRID_CONTENT_FIXED_CLASS).css(rtlEnabled ? {paddingLeft: width} : {paddingRight: width})
                },
                getFixedColumnElements: function() {
                    return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(0).children()
                }
            });
        var RowsViewFixedColumnsExtender = $.extend({}, baseFixedColumns, {
                _detachHoverEvents: function() {
                    this._fixedTableElement && this._fixedTableElement.off("mouseover mouseout", ".dx-data-row");
                    this._tableElement && this._tableElement.off("mouseover mouseout", ".dx-data-row")
                },
                _attachHoverEvents: function() {
                    var that = this,
                        attachHoverEvent = function($table) {
                            $table.on("mouseover mouseout", ".dx-data-row", that.createAction(function(args) {
                                var event = args.jQueryEvent,
                                    rowIndex = that.getRowIndex($(event.target).closest(".dx-row")),
                                    isHover = event.type === "mouseover";
                                that._tableElement && that._getRowElements(that._tableElement).eq(rowIndex).toggleClass(DATAGRID_HOVER_STATE_CLASS, isHover);
                                that._fixedTableElement && that._getRowElements(that._fixedTableElement).eq(rowIndex).toggleClass(DATAGRID_HOVER_STATE_CLASS, isHover)
                            }))
                        };
                    if (that._fixedTableElement && that._tableElement) {
                        attachHoverEvent(that._fixedTableElement);
                        attachHoverEvent(that._tableElement)
                    }
                },
                _renderTable: function(options) {
                    var that = this,
                        $content,
                        $table,
                        $fixedTable,
                        fixedColumns = that._columnsController.getFixedColumns();
                    that._isFixedColumns = !!fixedColumns.length;
                    $table = that.callBase(options);
                    if (that._isFixedColumns) {
                        that._isFixedTableRendering = true;
                        $fixedTable = that._createTable(fixedColumns);
                        $fixedTable.addClass(DATAGRID_POINTER_EVENTS_NONE_CLASS);
                        that._fixedTableElement = that._fixedTableElement || $fixedTable;
                        that._renderRows($fixedTable, $.extend({}, options, {columns: fixedColumns}));
                        $content = that._findContentElement();
                        that._updateContent($content, options.change, $fixedTable);
                        that._isFixedTableRendering = false
                    }
                    else {
                        that._fixedTableElement && that._fixedTableElement.remove();
                        that._fixedTableElement = null
                    }
                    return $table
                },
                _findContentElement: function() {
                    var that = this,
                        $content,
                        scrollable,
                        scrollTop,
                        element = that.element();
                    if (element && that._isFixedTableRendering) {
                        $content = element.children("." + DATAGRID_CONTENT_CLASS);
                        if (!$content.length) {
                            scrollable = that.getScrollable();
                            $content = $("<div/>").addClass(DATAGRID_CONTENT_CLASS).on("scroll", function(e) {
                                scrollTop = $(e.target).scrollTop();
                                if (scrollTop)
                                    $(e.target).scrollTop(0)
                            }).on("dxmousewheel", function(e) {
                                if (scrollable) {
                                    scrollTop = scrollable.scrollTop();
                                    scrollable.scrollTo({y: scrollTop - e.delta});
                                    if (scrollable.scrollTop() > 0 && scrollable.scrollTop() + scrollable.clientHeight() < scrollable.scrollHeight() + that.getScrollbarWidth())
                                        return false
                                }
                            }).appendTo(element)
                        }
                        return $content
                    }
                    return that.callBase()
                },
                _updateBottomLoading: function() {
                    if (!this._isFixedTableRendering)
                        this.callBase()
                },
                _renderContent: function(contentElement, tableElement) {
                    if (this._isFixedTableRendering)
                        return contentElement.empty().addClass(DATAGRID_CONTENT_CLASS + " " + DATAGRID_CONTENT_FIXED_CLASS + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS).append(tableElement);
                    return this.callBase(contentElement, tableElement)
                },
                _getGroupCellOptions: function(options) {
                    if (this._isFixedTableRendering)
                        return this.callBase($.extend({}, options, {columns: this._columnsController.getVisibleColumns()}));
                    return this.callBase(options)
                },
                _renderGroupSummaryCells: function($row, options) {
                    if (this._isFixedTableRendering)
                        this.callBase($row, $.extend({}, options, {columns: this._columnsController.getVisibleColumns()}));
                    else
                        this.callBase($row, options)
                },
                _hasAlignByColumnSummaryItems: function(columnIndex, options) {
                    var result = this.callBase.apply(this, arguments);
                    return result && Boolean(options.columns[columnIndex].fixed) === Boolean(options.isFixed)
                },
                _renderGroupSummaryCellsCore: function($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
                    if (this._isFixedTableRendering) {
                        if (alignByColumnCellCount > 0)
                            $groupCell.css("visibility", "hidden");
                        options.isFixed = true;
                        alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);
                        options.isFixed = false
                    }
                    this.callBase($groupCell, options, groupCellColSpan, alignByColumnCellCount)
                },
                _renderCore: function(change) {
                    this._detachHoverEvents();
                    this.callBase(change);
                    if (this.option("hoverStateEnabled") && this._isFixedColumns)
                        this._attachHoverEvents()
                },
                optionChanged: function(args) {
                    var that = this;
                    that.callBase(args);
                    if (args.name === "hoverStateEnabled" && that._isFixedColumns)
                        args.value ? this._attachHoverEvents() : this._detachHoverEvents()
                },
                getCellIndex: function($cell) {
                    var $fixedTable = this._fixedTableElement,
                        columns,
                        cellIndex = 0;
                    if ($fixedTable && $fixedTable.find($cell).length) {
                        columns = this._columnsController.getFixedColumns();
                        $.each(columns, function(index, column) {
                            if (index === $cell[0].cellIndex)
                                return false;
                            if (column.colspan) {
                                cellIndex += column.colspan;
                                return
                            }
                            cellIndex++
                        });
                        return cellIndex
                    }
                    return this.callBase($cell)
                },
                _updateFixedTablePosition: function(scrollTop) {
                    if (this._fixedTableElement && this._tableElement)
                        this._fixedTableElement.css("top", scrollTop + this._tableElement.position().top)
                },
                setScrollerSpacing: function() {
                    var that = this,
                        vWidth,
                        hWidth,
                        styles;
                    var $fixedContent = that.element().children("." + DATAGRID_CONTENT_FIXED_CLASS);
                    if ($fixedContent.length) {
                        vWidth = that.getScrollbarWidth();
                        hWidth = that.getScrollbarWidth(true);
                        styles = that.option("rtlEnabled") ? {marginLeft: vWidth} : {marginRight: vWidth};
                        styles.marginBottom = hWidth;
                        $fixedContent.css(styles)
                    }
                },
                _handleScroll: function(e) {
                    this._updateFixedTablePosition(-e.scrollOffset.top);
                    this.callBase(e)
                },
                _updateContentPosition: function() {
                    var isUpdated = this.callBase();
                    if (isUpdated)
                        this._updateFixedTablePosition(-this._scrollTop);
                    return isUpdated
                },
                getCell: function(cellPosition) {
                    var that = this,
                        columns = that.getColumns(),
                        columnIndex = cellPosition.columnIndex,
                        $rows = that._getRowElements(that._fixedTableElement),
                        $row = $rows.eq(cellPosition.rowIndex),
                        isGroupRow = $row.hasClass(DATAGRID_GROUP_ROW_CLASS),
                        $fixedRows;
                    if (columns && columnIndex < columns.length && (columns[columnIndex].fixed || columns[columnIndex].command === "expand" || isGroupRow)) {
                        var $colspanElement;
                        $fixedRows = $rows;
                        $colspanElement = $row.find("[colspan]");
                        if (!isGroupRow && $colspanElement.length && $colspanElement[0].cellIndex < columnIndex)
                            cellPosition.columnIndex = columnIndex - $colspanElement.attr("colspan") + 1
                    }
                    return that.callBase(cellPosition, $fixedRows)
                }
            });
        var FooterViewFixedColumnsExtender = baseFixedColumns;
        dataGrid.registerModule("fixedColumns", {
            defaultOptions: function() {
                return {columnFixing: {
                            enabled: false,
                            texts: {
                                fix: Globalize.localize("dxDataGrid-columnFixingFix"),
                                unfix: Globalize.localize("dxDataGrid-columnFixingUnfix"),
                                leftPosition: Globalize.localize("dxDataGrid-columnFixingLeftPosition"),
                                rightPosition: Globalize.localize("dxDataGrid-columnFixingRightPosition")
                            }
                        }}
            },
            extenders: {
                views: {
                    columnHeadersView: ColumnHeadersViewFixedColumnsExtender,
                    rowsView: RowsViewFixedColumnsExtender,
                    footerView: FooterViewFixedColumnsExtender
                },
                controllers: function() {
                    var normalizeColumnIndicesByPoints = function(columns, pointsByColumns) {
                            var transparentColumnIndex = getTransparentColumnIndex(columns);
                            if (transparentColumnIndex >= 0)
                                $.each(pointsByColumns, function(_, point) {
                                    if (point.index > transparentColumnIndex) {
                                        point.columnIndex += columns[transparentColumnIndex].colspan - 1;
                                        point.index += columns[transparentColumnIndex].colspan - 1
                                    }
                                });
                            return pointsByColumns
                        };
                    return {
                            draggingHeader: {
                                _generatePointsByColumns: function(options) {
                                    var pointsByColumns,
                                        targetDraggingPanel = options.targetDraggingPanel;
                                    if (targetDraggingPanel && targetDraggingPanel.getName() === "headers" && targetDraggingPanel.isFixedColumns())
                                        if (options.sourceColumn.fixed) {
                                            options.columnElements = targetDraggingPanel.getFixedColumnElements();
                                            options.columns = targetDraggingPanel.getFixedColumns();
                                            pointsByColumns = this.callBase(options);
                                            return normalizeColumnIndicesByPoints(options.columns, pointsByColumns)
                                        }
                                    return this.callBase(options)
                                },
                                _pointCreated: function(point, columns, location, sourceColumn) {
                                    var result = this.callBase.apply(this, arguments),
                                        $transparentColumn = this._columnHeadersView.getTransparentColumnElement(),
                                        boundingRect;
                                    if (!result && location === "headers" && $transparentColumn) {
                                        boundingRect = $transparentColumn.get(0).getBoundingClientRect();
                                        if (sourceColumn && sourceColumn.fixed)
                                            return sourceColumn.fixedPosition === "right" ? point.x < boundingRect.right : point.x > boundingRect.left;
                                        else
                                            return point.x < boundingRect.left || point.x > boundingRect.right
                                    }
                                    return result
                                }
                            },
                            columnsResizer: {
                                _generatePointsByColumns: function() {
                                    var that = this,
                                        columns = that._columnsController ? that._columnsController.getFixedColumns() : [],
                                        cells = that._columnHeadersView.getFixedColumnElements(),
                                        pointsByFixedColumns = [];
                                    that.callBase();
                                    if (cells && cells.length > 0) {
                                        pointsByFixedColumns = dataGrid.getPointsByColumns(cells, function(point) {
                                            return that._pointCreated(point, cells.length, columns)
                                        });
                                        that._pointsByFixedColumns = normalizeColumnIndicesByPoints(columns, pointsByFixedColumns)
                                    }
                                },
                                _pointCreated: function(point, cellsLength, columns) {
                                    var currentColumn,
                                        nextColumn;
                                    if (point.index > 0 && point.index < cellsLength) {
                                        currentColumn = columns[point.columnIndex - 1] || {};
                                        nextColumn = columns[point.columnIndex] || {};
                                        if (currentColumn.fixed || nextColumn.fixed) {
                                            point.columnIndex -= 1;
                                            return !((currentColumn.allowResizing || currentColumn.command === "transparent") && (nextColumn.allowResizing || nextColumn.command === "transparent"))
                                        }
                                    }
                                    return this.callBase.apply(this, arguments)
                                },
                                _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
                                    var $transparentColumn = this._columnHeadersView.getTransparentColumnElement(),
                                        boundingRect;
                                    if ($transparentColumn) {
                                        boundingRect = $transparentColumn.get(0).getBoundingClientRect();
                                        if (currentX <= boundingRect.left || currentX >= boundingRect.right)
                                            return this.callBase(this._pointsByFixedColumns, currentX, deltaX)
                                    }
                                    return this.callBase(pointsByColumns, currentX, deltaX)
                                }
                            },
                            keyboardNavigation: {_scrollToElement: function($element) {
                                    var focusedView = this.getFocusedView();
                                    this.callBase($element, focusedView && focusedView.getFixedColumnsOffset())
                                }}
                        }
                }()
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.exportController.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            dataGrid = ui.dxDataGrid,
            DATAGRID_CHECKBOX_SIZE = "dx-datagrid-checkbox-size",
            DATAGRID_EXPORT_MENU_CLASS = "dx-datagrid-export-menu",
            DATAGRID_EXPORT_BUTTON_CLASS = "dx-datagrid-export-button",
            DATAGRID_EXPORT_ICON = "export-to",
            DATAGRID_EXPORT_EXCEL_ICON = "exportxlsx",
            DATAGRID_EXPORT_EXCEL_BUTTON_ICON = "export-excel-button";
        dataGrid.DataProvider = DX.Class.inherit({
            _getGroupValue: function(item) {
                var groupColumn = this._options.groupColumns[item.groupIndex],
                    value = dataGrid.getDisplayValue(groupColumn, item.values[item.groupIndex]),
                    result = groupColumn.caption + ": " + dataGrid.formatValue(value, groupColumn),
                    visibleIndex;
                visibleIndex = this._options.getVisibleIndex(groupColumn.index);
                if (item.summaryCells && item.summaryCells.length && item.summaryCells[visibleIndex].length)
                    result += " " + dataGrid.getGroupRowSummaryText(item.summaryCells[visibleIndex], this._options.summaryTexts);
                return result
            },
            _correctCellIndex: function(cellIndex) {
                var startIndex = this._options.startValueIndex,
                    endIndex = this._options.endValueIndex;
                return cellIndex <= endIndex ? startIndex + cellIndex : null
            },
            ctor: function(options) {
                this._options = options
            },
            getColumns: function() {
                return this._options.columns
            },
            getRowsCount: function() {
                return this._options.items.length
            },
            isGroupRow: function(rowIndex) {
                return rowIndex < this._options.items.length && this._options.items[rowIndex].rowType === "group"
            },
            getGroupLevel: function(rowIndex) {
                var item = this._options.items[rowIndex],
                    groupIndex = item.groupIndex;
                if (item.isTotalSummary)
                    return 0;
                return utils.isDefined(groupIndex) ? groupIndex : this._options.groupColumns.length
            },
            getCellType: function(rowIndex, cellIndex) {
                if (cellIndex < this._options.columns.length) {
                    var item = this._options.items.length && this._options.items[rowIndex],
                        column = this._options.columns[cellIndex];
                    if (item && item.rowType === "data")
                        if (isFinite(item.values[this._correctCellIndex(cellIndex)]) && !utils.isDefined(column.customizeText))
                            return utils.isDefined(column.lookup) ? column.lookup.dataType : column.dataType;
                    return "string"
                }
            },
            ready: function() {
                var options = this._options;
                return $.when(options.items).done(function(items) {
                        options.items = items
                    })
            },
            getCellValue: function(rowIndex, cellIndex) {
                var column,
                    value,
                    i,
                    summaryItems,
                    correctedCellIndex = this._correctCellIndex(cellIndex),
                    itemValues,
                    item = this._options.items.length && this._options.items[rowIndex];
                if (item) {
                    itemValues = item.values;
                    switch (item.rowType) {
                        case"summaryFooter":
                            if (correctedCellIndex < itemValues.length) {
                                value = itemValues[correctedCellIndex];
                                if (utils.isDefined(value))
                                    return dataGrid.getSummaryText(value, this._options.summaryTexts)
                            }
                            break;
                        case"group":
                            if (cellIndex < 1)
                                return this._getGroupValue(item);
                            else {
                                summaryItems = item.values[correctedCellIndex];
                                if (utils.isArray(summaryItems)) {
                                    value = "";
                                    for (i = 0; i < summaryItems.length; i++)
                                        value += (i > 0 ? " \n " : "") + dataGrid.getSummaryText(summaryItems[i], this._options.summaryTexts);
                                    return value
                                }
                            }
                            break;
                        default:
                            column = this._options.columns[cellIndex];
                            if (column) {
                                value = dataGrid.getDisplayValue(column, itemValues[correctedCellIndex]);
                                return !isFinite(value) || column.customizeText ? dataGrid.formatValue(value, column) : value
                            }
                    }
                }
            },
            isHeadersVisible: function() {
                return this._options.isHeadersVisible
            },
            isTotalCell: function(rowIndex, cellIndex) {
                var items = this._options.items,
                    item = items[rowIndex],
                    correctCellIndex = this._correctCellIndex(cellIndex),
                    isSummaryAlignByColumn = item.summaryCells && item.summaryCells[correctCellIndex] && item.summaryCells[correctCellIndex].length > 0 && item.summaryCells[correctCellIndex][0].alignByColumn;
                return item && item.rowType === "summaryFooter" || isSummaryAlignByColumn
            }
        });
        dataGrid.ExportController = dataGrid.ViewController.inherit({
            _getColumns: function() {
                var result = [],
                    visibleColumns = this._columnsController.getVisibleColumns(),
                    columnWidths = this._rowsView.getColumnWidths(),
                    column,
                    i;
                for (i = 0; i < visibleColumns.length; i++) {
                    column = visibleColumns[i];
                    if (!utils.isDefined(column.command))
                        result.push($.extend({}, column, {width: columnWidths[i]}))
                }
                return result
            },
            _getFooterSummaryItems: function(summaryCells, isTotal) {
                var result = [],
                    estimatedItemsCount = 1,
                    values,
                    itemslength,
                    summaryCell,
                    j,
                    i = 0;
                do {
                    values = [];
                    for (j = 0; j < summaryCells.length; j++) {
                        summaryCell = summaryCells[j];
                        itemslength = summaryCell.length;
                        if (estimatedItemsCount < itemslength)
                            estimatedItemsCount = itemslength;
                        values.push(summaryCell[i])
                    }
                    result.push({
                        values: values,
                        rowType: "summaryFooter",
                        isTotalSummary: isTotal
                    })
                } while (i++ < estimatedItemsCount - 1);
                return result
            },
            _hasSummaryGroupFooters: function() {
                var i,
                    groupItems = this.option("summary.groupItems");
                if (utils.isDefined(groupItems))
                    for (i = 0; i < groupItems.length; i++)
                        if (groupItems[i].showInGroupFooter)
                            return true;
                return false
            },
            _getItemsWithSummaryGroupFooters: function(sourceItems) {
                var item,
                    result = [],
                    beforeGroupFooterItems = [],
                    groupFooterItems = [],
                    i;
                for (i = 0; i < sourceItems.length; i++) {
                    item = sourceItems[i];
                    if (item.rowType === "groupFooter") {
                        groupFooterItems = this._getFooterSummaryItems(item.summaryCells);
                        result = result.concat(beforeGroupFooterItems, groupFooterItems);
                        beforeGroupFooterItems = []
                    }
                    else
                        beforeGroupFooterItems.push(item)
                }
                return result.length ? result : beforeGroupFooterItems
            },
            _updateGroupValuesWithSummaryByColumn: function(sourceItems) {
                var item,
                    summaryCells,
                    summaryItem,
                    summaryValues = [],
                    groupColumnCount,
                    k,
                    j,
                    i;
                for (i = 0; i < sourceItems.length; i++) {
                    item = sourceItems[i];
                    summaryCells = item.summaryCells;
                    if (item.rowType === "group" && summaryCells && summaryCells.length > 1) {
                        groupColumnCount = item.values.length;
                        for (j = 1; j < summaryCells.length; j++)
                            for (k = 0; k < summaryCells[j].length; k++) {
                                summaryItem = summaryCells[j][k];
                                if (summaryItem && summaryItem.alignByColumn) {
                                    if (!utils.isArray(summaryValues[j - groupColumnCount]))
                                        summaryValues[j - groupColumnCount] = [];
                                    summaryValues[j - groupColumnCount].push(summaryItem)
                                }
                            }
                        if (summaryValues.length > 0) {
                            $.merge(item.values, summaryValues);
                            summaryValues = []
                        }
                    }
                }
            },
            _getAllItems: function(data) {
                var that = this,
                    d = $.Deferred(),
                    dataController = this.getController("data"),
                    footerItems = dataController.footerItems(),
                    totalItem = footerItems.length && footerItems[0],
                    summaryTotalItems = that.option("summary.totalItems"),
                    summaryCells,
                    summaryItems;
                dataController.loadAll(data).done(function(sourceItems, totalAggregates) {
                    that._updateGroupValuesWithSummaryByColumn(sourceItems);
                    if (that._hasSummaryGroupFooters())
                        sourceItems = that._getItemsWithSummaryGroupFooters(sourceItems);
                    summaryCells = totalItem && totalItem.summaryCells;
                    if (utils.isDefined(totalAggregates) && summaryTotalItems)
                        summaryCells = dataController._getSummaryCells(summaryTotalItems, totalAggregates);
                    summaryItems = totalItem && that._getFooterSummaryItems(summaryCells, true);
                    if (summaryItems)
                        sourceItems = sourceItems.concat(summaryItems);
                    d.resolve(sourceItems)
                }).fail(d.reject);
                return d
            },
            _getSelectedItems: function() {
                var selectionController = this.getController("selection"),
                    selectedRowData = selectionController.getSelectedRowsData();
                return this._getAllItems(selectedRowData)
            },
            _getStartEndValueIndexces: function(visibleColumns) {
                var i,
                    startIndex,
                    endIndex,
                    visibleColumnslength = visibleColumns.length;
                for (i = 0; i < visibleColumnslength; i++)
                    if (!utils.isDefined(visibleColumns[i].command)) {
                        startIndex = i;
                        break
                    }
                for (i = visibleColumnslength - 1; i >= 0; i--)
                    if (!utils.isDefined(visibleColumns[i].command)) {
                        endIndex = i;
                        break
                    }
                return {
                        startIndex: startIndex,
                        endIndex: endIndex
                    }
            },
            init: function() {
                this._columnsController = this.getController("columns");
                this._rowsView = this.getView("rowsView");
                this.createAction("onExporting", {excludeValidators: ["disabled", "readOnly"]});
                this.createAction("onExported", {excludeValidators: ["disabled", "readOnly"]});
                this._clientExporter = new DX.dxClientExporter({
                    exportingAction: this.getAction("onExporting"),
                    exportedAction: this.getAction("onExported")
                })
            },
            optionChanged: function(args) {
                this.callBase(args);
                if (args.name === "onExporting")
                    this._clientExporter.option("exportingAction", this.getAction(args.name));
                if (args.name === "onExported")
                    this._clientExporter.option("exportedAction", this.getAction(args.name))
            },
            callbackNames: function() {
                return ["selectionOnlyChanged"]
            },
            getExportFormat: function() {
                return ["EXCEL"]
            },
            getDataProvider: function() {
                var groupColumns = this._columnsController.getGroupColumns(),
                    startEndIndexces = this._getStartEndValueIndexces(this._columnsController.getVisibleColumns());
                return new dataGrid.DataProvider({
                        columns: this._getColumns(),
                        groupColumns: groupColumns,
                        items: !!this._selectionOnly ? this._getSelectedItems() : this._getAllItems(),
                        getVisibleIndex: $.proxy(this._columnsController.getVisibleIndex, this._columnsController),
                        startValueIndex: startEndIndexces.startIndex,
                        endValueIndex: startEndIndexces.endIndex,
                        isHeadersVisible: this.option("showColumnHeaders"),
                        summaryTexts: this.option("summary.texts")
                    })
            },
            exportToExcel: function(selectionOnly) {
                this._selectionOnly = selectionOnly;
                var excelWrapTextEnabled = this.option("export.excelWrapTextEnabled");
                utils.isDefined(this._clientExporter) && this._clientExporter.exportTo({
                    fileName: this.option("export.fileName"),
                    proxyUrl: this.option("export.proxyUrl"),
                    format: "EXCEL",
                    wrapTextEnabled: utils.isDefined(excelWrapTextEnabled) ? excelWrapTextEnabled : !!this.option("wordWrapEnabled"),
                    autoFilterEnabled: !!this.option("export.excelFilterEnabled"),
                    component: this.component
                })
            },
            publicMethods: function() {
                return ["getDataProvider", "getExportFormat", "exportToExcel"]
            },
            selectionOnly: function(value) {
                if (utils.isDefined(value)) {
                    this._isSelectedRows = value;
                    this.selectionOnlyChanged.fire()
                }
                else
                    return this._isSelectedRows
            }
        });
        dataGrid.registerModule("export", {
            defaultOptions: function() {
                return {"export": {
                            enabled: false,
                            fileName: "DataGrid",
                            excelFilterEnabled: false,
                            excelWrapTextEnabled: undefined,
                            proxyUrl: undefined,
                            allowExportSelectedData: false,
                            texts: {
                                exportTo: Globalize.localize("dxDataGrid-exportTo"),
                                exportToExcel: Globalize.localize("dxDataGrid-exportToExcel"),
                                excelFormat: Globalize.localize("dxDataGrid-excelFormat"),
                                selectedRows: Globalize.localize("dxDataGrid-selectedRows")
                            }
                        }}
            },
            controllers: {"export": dataGrid.ExportController},
            extenders: {
                controllers: {editing: {
                        callbackNames: function() {
                            var callbackList = this.callBase();
                            return utils.isDefined(callbackList) ? callbackList.push("editingChanged") : ["editingChanged"]
                        },
                        _updateEditButtons: function() {
                            this.callBase();
                            this.editingChanged.fire(this.hasChanges())
                        }
                    }},
                views: {headerPanel: {
                        _isExportButtonVisible: function() {
                            return this.option("export.enabled")
                        },
                        _getButtonOptions: function() {
                            var that = this,
                                texts = that.option("export.texts");
                            return that.option("export.allowExportSelectedData") ? {
                                    hint: texts.exportTo,
                                    icon: DATAGRID_EXPORT_ICON,
                                    onClick: null
                                } : {
                                    hint: texts.exportToExcel,
                                    icon: DATAGRID_EXPORT_EXCEL_BUTTON_ICON,
                                    onClick: function() {
                                        that._exportController.exportToExcel()
                                    }
                                }
                        },
                        _renderExportButton: function() {
                            var that = this;
                            if (that.option("export.enabled"))
                                if (!that._$exportButton) {
                                    that._$exportButton = $("<div>").addClass(DATAGRID_EXPORT_BUTTON_CLASS).appendTo(that.element());
                                    that._exportButton = that._createComponent(that._$exportButton, "dxButton", that._getButtonOptions())
                                }
                                else {
                                    that._exportButton.option(that._getButtonOptions());
                                    that._$exportButton.show()
                                }
                            else
                                that._$exportButton && that._$exportButton.hide()
                        },
                        _renderExportMenu: function() {
                            var that = this,
                                texts = that.option("export.texts"),
                                menuItems = [{
                                        text: texts.excelFormat,
                                        icon: DATAGRID_EXPORT_EXCEL_ICON
                                    }];
                            utils.isDefined(that._exportContextMenu) && that._exportContextMenu.element().remove();
                            if (that.option("export.enabled") && that.option("export.allowExportSelectedData")) {
                                menuItems.push({
                                    value: "selectionOnly",
                                    template: function() {
                                        var $selectionOnlyEditor = that._createComponent($("<div>").addClass(DATAGRID_CHECKBOX_SIZE), "dxCheckBox", {
                                                text: texts.selectedRows,
                                                value: !!that._exportController.selectionOnly(),
                                                onValueChanged: function(e) {
                                                    that._exportController.selectionOnly(e.value)
                                                }
                                            }).element();
                                        return $selectionOnlyEditor
                                    },
                                    beginGroup: true,
                                    closeMenuOnClick: false
                                });
                                that._exportContextMenu = that._createComponent($("<div>").appendTo(that.component.element()), "dxContextMenu", {
                                    alternativeInvocationMode: {
                                        enabled: true,
                                        invokingElement: that._$exportButton
                                    },
                                    items: menuItems,
                                    cssClass: DATAGRID_EXPORT_MENU_CLASS,
                                    onItemClick: function(e) {
                                        if (e.itemData.text && e.itemData.text.indexOf("Excel") > -1)
                                            that._exportController.exportToExcel(that._exportController.selectionOnly())
                                    },
                                    target: this._$exportButton,
                                    position: {
                                        at: "left bottom",
                                        my: "left top",
                                        offset: "0 3",
                                        collision: "fit",
                                        boundary: that._$parent,
                                        boundaryOffset: "1 1"
                                    }
                                })
                            }
                        },
                        _renderCore: function() {
                            this.callBase();
                            this._renderExportButton();
                            this._renderExportMenu()
                        },
                        optionChanged: function(args) {
                            this.callBase(args);
                            if (args.name === "export") {
                                args.handled = true;
                                this._invalidate()
                            }
                        },
                        init: function() {
                            var that = this;
                            this.callBase();
                            this._exportController = this.getController("export");
                            this._editingController = this.getController("editing");
                            this._editingController.editingChanged.add(function(hasChanges) {
                                if (utils.isDefined(that._exportButton))
                                    that._exportButton.option("disabled", hasChanges)
                            })
                        },
                        isVisible: function() {
                            return this.callBase() || this._isExportButtonVisible()
                        }
                    }}
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_EXPORT_MENU_CLASS: DATAGRID_EXPORT_MENU_CLASS,
            DATAGRID_EXPORT_BUTTON_CLASS: DATAGRID_EXPORT_BUTTON_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.gridView.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            utils = DX.utils;
        var DATAGRID_CLASS = "dx-datagrid",
            DATAGRID_HIDDEN_CLASS = "dx-hidden",
            DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_BORDERS_CLASS = "dx-datagrid-borders",
            DATAGRID_TABLE_FIXED_CLASS = "dx-datagrid-table-fixed",
            DATAGRID_COLUMN_HEADERS_HIDDEN = "dx-datagrid-headers-hidden",
            DATAGRID_IMPORTANT_MARGIN_CLASS = "dx-datagrid-important-margin",
            EMPTY_GRID_ROWS_HEIGHT = 100,
            LOADPANEL_MARGIN = 50,
            VIEW_NAMES = ["columnsSeparatorView", "blockSeparatorView", "trackerView", "headerPanel", "columnHeadersView", "rowsView", "footerView", "columnChooserView", "pagerView", "draggingHeaderView", "contextMenuView", "errorView", "headerFilterView"];
        var isPercentWidth = function(width) {
                return utils.isString(width) && width.slice(-1) === "%"
            };
        var mergeArraysByMaxValue = function(values1, values2) {
                var result = [],
                    i;
                if (values1 && values2 && values1.length && values1.length === values2.length)
                    for (i = 0; i < values1.length; i++)
                        result.push(values1[i] > values2[i] ? values1[i] : values2[i]);
                else if (values1)
                    result = values1;
                return result
            };
        dataGrid.ResizingController = dataGrid.ViewController.inherit({
            _initPostRenderHandlers: function() {
                var that = this;
                if (!that._refreshSizesHandler) {
                    that._refreshSizesHandler = function(e) {
                        that._dataController.changed.remove(that._refreshSizesHandler);
                        if (that._columnsController.columnsChanged.firing) {
                            (window.setImmediate || setTimeout)($.proxy(that._refreshSizesHandler, that, e));
                            return
                        }
                        var changeType = e && e.changeType;
                        if (!e || changeType === "refresh" || changeType === "prepend" || changeType === "append" || changeType === "update")
                            that.resize();
                        if (changeType && changeType !== "updateSelection") {
                            utils.triggerShownEvent(that.getView("rowsView").element());
                            that.component._fireContentReadyAction()
                        }
                    };
                    that._dataController.changed.add(function() {
                        that._dataController.changed.add(that._refreshSizesHandler)
                    })
                }
            },
            _getBestFitWidths: function() {
                var that = this,
                    rowsColumnWidths = that._rowsView.getColumnWidths(),
                    headerColumnWidths = that._columnHeadersView && that._columnHeadersView.getColumnWidths(),
                    footerColumnWidths = that._footerView && that._footerView.getColumnWidths(),
                    resultWidths;
                resultWidths = mergeArraysByMaxValue(rowsColumnWidths, headerColumnWidths);
                resultWidths = mergeArraysByMaxValue(resultWidths, footerColumnWidths);
                return resultWidths
            },
            _setVisibleWidths: function(visibleColumns, widths) {
                var columnsController = this._columnsController;
                columnsController.beginUpdate();
                $.each(visibleColumns, function(index, column) {
                    var columnId = column.command ? "command:" + column.command : column.index;
                    columnsController.columnOption(columnId, "visibleWidth", widths[index])
                });
                columnsController.endUpdate()
            },
            _toggleBestFitMode: function(isBestFit) {
                var $element = this.component.element();
                $element.find("." + DATAGRID_TABLE_CLASS).toggleClass(DATAGRID_TABLE_FIXED_CLASS, !isBestFit);
                $element.find("input").toggleClass(DATAGRID_HIDDEN_CLASS, isBestFit);
                $element.find(".dx-group-cell").toggleClass(DATAGRID_HIDDEN_CLASS, isBestFit);
                $element.find(".dx-header-row .dx-datagrid-text-content").css("max-width", "")
            },
            _synchronizeColumns: function() {
                var that = this,
                    columnsController = that._columnsController,
                    visibleColumns = columnsController.getVisibleColumns(),
                    columnAutoWidth = that.option("columnAutoWidth"),
                    needBestFit = columnAutoWidth,
                    lastWidthReseted = false,
                    resultWidths = [],
                    normalizeWidthsByExpandColumns = function() {
                        var expandColumnWidth;
                        $.each(visibleColumns, function(index, column) {
                            if (column.command === "expand")
                                expandColumnWidth = resultWidths[index]
                        });
                        $.each(visibleColumns, function(index, column) {
                            if (column.command === "expand" && expandColumnWidth)
                                resultWidths[index] = expandColumnWidth
                        })
                    };
                !needBestFit && $.each(visibleColumns, function(index, column) {
                    if (column.width === "auto") {
                        needBestFit = true;
                        return false
                    }
                });
                that._setVisibleWidths(visibleColumns, []);
                if (needBestFit) {
                    that._toggleBestFitMode(true);
                    resultWidths = that._getBestFitWidths();
                    $.each(visibleColumns, function(index, column) {
                        var columnId = column.command ? "command:" + column.command : column.index;
                        columnsController.columnOption(columnId, "bestFitWidth", resultWidths[index], true)
                    })
                }
                $.each(visibleColumns, function(index) {
                    if (this.width !== "auto")
                        if (this.width)
                            resultWidths[index] = this.width;
                        else if (!columnAutoWidth)
                            resultWidths[index] = undefined
                });
                lastWidthReseted = that._correctColumnWidths(resultWidths, visibleColumns);
                if (columnAutoWidth) {
                    normalizeWidthsByExpandColumns();
                    that._processStretch(resultWidths, visibleColumns)
                }
                if (needBestFit)
                    that._toggleBestFitMode(false);
                if (needBestFit || lastWidthReseted)
                    that._setVisibleWidths(visibleColumns, resultWidths)
            },
            _correctColumnWidths: function(resultWidths, visibleColumns) {
                var that = this,
                    hasPercentWidth = false,
                    hasAutoWidth = false,
                    lastWidthReseted = false,
                    $element = that.component.element(),
                    hasWidth = that._hasWidth,
                    lastColumnIndex;
                $.each(visibleColumns, function(index) {
                    if (this.width !== "auto")
                        if (this.width)
                            resultWidths[index] = this.width;
                        else
                            hasAutoWidth = true;
                    if (isPercentWidth(this.width))
                        hasPercentWidth = true
                });
                if ($element && that._maxWidth) {
                    delete that._maxWidth;
                    $element.css("max-width", "")
                }
                if (!hasAutoWidth && resultWidths.length) {
                    var contentWidth = that._rowsView.contentWidth();
                    var totalWidth = that._getTotalWidth(resultWidths, contentWidth);
                    if (totalWidth <= contentWidth) {
                        lastColumnIndex = resultWidths.length - 1;
                        while (lastColumnIndex >= 0 && visibleColumns[lastColumnIndex] && visibleColumns[lastColumnIndex].command)
                            lastColumnIndex--;
                        if (lastColumnIndex >= 0) {
                            resultWidths[lastColumnIndex] = "auto";
                            lastWidthReseted = true;
                            if (!hasWidth && !hasPercentWidth) {
                                that._maxWidth = totalWidth;
                                $element.css("max-width", that._maxWidth)
                            }
                        }
                    }
                }
                return lastWidthReseted
            },
            _processStretch: function(resultSizes, visibleColumns) {
                var groupSize = this._rowsView.contentWidth(),
                    tableSize = this._getTotalWidth(resultSizes, groupSize),
                    unusedIndexes = {length: 0},
                    diff,
                    diffElement,
                    onePixelElementsCount,
                    i;
                if (!resultSizes.length)
                    return;
                $.each(visibleColumns, function(index) {
                    if (this.width) {
                        unusedIndexes[index] = true;
                        unusedIndexes.length++
                    }
                });
                diff = groupSize - tableSize;
                diffElement = Math.floor(diff / (resultSizes.length - unusedIndexes.length));
                onePixelElementsCount = diff - diffElement * (resultSizes.length - unusedIndexes.length);
                if (diff >= 0)
                    for (i = 0; i < resultSizes.length; i++) {
                        if (unusedIndexes[i])
                            continue;
                        resultSizes[i] += diffElement;
                        if (onePixelElementsCount) {
                            resultSizes[i]++;
                            onePixelElementsCount--
                        }
                    }
            },
            _getTotalWidth: function(widths, groupWidth) {
                var result = 0,
                    width,
                    i;
                for (i = 0; i < widths.length; i++) {
                    width = widths[i];
                    if (width)
                        result += isPercentWidth(width) ? parseInt(width) * groupWidth / 100 : parseInt(width)
                }
                return Math.round(result)
            },
            updateSize: function($rootElement) {
                var that = this,
                    $groupElement,
                    width;
                if (that._hasHeight === undefined && $rootElement && $rootElement.closest(document).length) {
                    $groupElement = $rootElement.children("." + DATAGRID_CLASS);
                    if ($groupElement.length)
                        $groupElement.detach();
                    that._hasHeight = !!$rootElement.height();
                    width = $rootElement.width();
                    $rootElement.addClass(DATAGRID_IMPORTANT_MARGIN_CLASS);
                    that._hasWidth = $rootElement.width() === width;
                    $rootElement.removeClass(DATAGRID_IMPORTANT_MARGIN_CLASS);
                    if ($groupElement.length)
                        $groupElement.appendTo($rootElement)
                }
            },
            publicMethods: function() {
                return ["resize", "updateDimensions"]
            },
            resize: function() {
                !this.component._requireResize && this.updateDimensions()
            },
            updateDimensions: function() {
                var that = this,
                    dataController = that._dataController,
                    $rootElement = that.component.element(),
                    rootElementHeight = $rootElement && ($rootElement.get(0).clientHeight || $rootElement.height()),
                    loadPanelOptions = that.option("loadPanel"),
                    height = that.option("height"),
                    rowsViewHeight,
                    editorFactory = that.getController("editorFactory"),
                    $testDiv;
                that._initPostRenderHandlers();
                that.updateSize($rootElement);
                if (height && that._hasHeight ^ height !== "auto") {
                    $testDiv = $("<div>").height(height).appendTo($rootElement);
                    that._hasHeight = !!$testDiv.height();
                    $testDiv.remove()
                }
                if (that._hasHeight && rootElementHeight > 0 && that.option("scrolling")) {
                    rowsViewHeight = rootElementHeight;
                    $.each(that.getViews(), function() {
                        if (this.isVisible() && this.getHeight)
                            rowsViewHeight -= this.getHeight()
                    })
                }
                else if (!that._hasHeight && dataController.items().length === 0)
                    rowsViewHeight = loadPanelOptions && loadPanelOptions.visible ? loadPanelOptions.height + LOADPANEL_MARGIN : EMPTY_GRID_ROWS_HEIGHT;
                else
                    rowsViewHeight = "auto";
                that._rowsView.height(rowsViewHeight);
                that._columnHeadersView.setScrollerSpacing(that._rowsView.getScrollbarWidth());
                that._rowsView.setScrollerSpacing();
                that._synchronizeColumns();
                $.each(VIEW_NAMES, function(index, viewName) {
                    var view = that.getView(viewName);
                    if (view)
                        view.resize()
                });
                editorFactory && editorFactory.resize()
            },
            optionChanged: function(args) {
                switch (args.name) {
                    case"width":
                    case"height":
                        this.component._renderDimensions();
                        this.resize();
                    default:
                        this.callBase(args)
                }
            },
            init: function() {
                var that = this;
                that._dataController = that.getController("data");
                that._columnsController = that.getController("columns");
                that._columnHeadersView = that.getView("columnHeadersView");
                that._footerView = that.getView("footerView");
                that._rowsView = that.getView("rowsView")
            }
        });
        dataGrid.SynchronizeScrollingController = dataGrid.ViewController.inherit({
            _scrollChangedHandler: function(views, pos, viewName) {
                for (var j = 0; j < views.length; j++)
                    if (views[j].name !== viewName)
                        views[j].scrollTo({
                            left: pos.left,
                            top: pos.top
                        })
            },
            init: function() {
                var view,
                    views = [this.getView("columnHeadersView"), this.getView("footerView"), this.getView("rowsView")],
                    i;
                for (i = 0; i < views.length; i++) {
                    view = views[i];
                    if (view)
                        view.scrollChanged.add($.proxy(this._scrollChangedHandler, this, views))
                }
            }
        });
        dataGrid.GridView = dataGrid.View.inherit({
            _endUpdateCore: function() {
                if (this.component._requireResize) {
                    this.component._requireResize = false;
                    this._resizingController.resize()
                }
            },
            init: function() {
                var that = this;
                that._resizingController = this.getController("resizing");
                that._dataController = that.getController("data")
            },
            getView: function(name) {
                return this.component._views[name]
            },
            element: function() {
                return this._groupElement
            },
            optionChanged: function(args) {
                var that = this;
                if (utils.isDefined(that._groupElement) && args.name === "showBorders") {
                    that._groupElement.toggleClass(DATAGRID_BORDERS_CLASS, !!args.value);
                    args.handled = true
                }
                else
                    that.callBase(args)
            },
            render: function($rootElement) {
                var that = this,
                    groupElement = that._groupElement || $("<div />").addClass(DATAGRID_CLASS).toggleClass(DATAGRID_BORDERS_CLASS, !!that.option("showBorders"));
                that.component.setAria({
                    role: "application",
                    label: Globalize.localize("dxDataGrid-ariaDataGrid")
                }, $rootElement);
                that._rootElement = $rootElement || that._rootElement;
                that._groupElement = groupElement;
                $.each(VIEW_NAMES, function(index, viewName) {
                    var view = that.getView(viewName);
                    if (view)
                        view.render(groupElement)
                });
                that.update()
            },
            update: function() {
                var that = this,
                    $rootElement = that._rootElement,
                    $groupElement = that._groupElement,
                    resizingController = that.getController("resizing");
                if ($rootElement && $groupElement) {
                    if (!$groupElement.parent().length) {
                        resizingController.updateSize($rootElement);
                        $groupElement.appendTo($rootElement);
                        that.getView("columnHeadersView").renderDelayedTemplates();
                        that.getView("rowsView").renderDelayedTemplates()
                    }
                    resizingController.resize();
                    if (that._dataController.isLoaded())
                        that.component._fireContentReadyAction()
                }
            }
        });
        dataGrid.registerModule("gridView", {
            defaultOptions: function() {
                return {showBorders: false}
            },
            controllers: {
                resizing: dataGrid.ResizingController,
                synchronizeScrolling: dataGrid.SynchronizeScrollingController
            },
            views: {gridView: dataGrid.GridView}
        });
        $.extend(dataGrid.__internals, {
            viewNames: VIEW_NAMES,
            DATAGRID_CLASS: DATAGRID_CLASS,
            DATAGRID_COLUMN_HEADERS_HIDDEN: DATAGRID_COLUMN_HEADERS_HIDDEN,
            DATAGRID_BORDERS_CLASS: DATAGRID_BORDERS_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.js */
    (function($, DX) {
        var ui = DX.ui,
            events = ui.events,
            utils = DX.utils,
            MIN_AREA_GROUP_WIDTH = 10;
        function mergeArraysByMaxValue(values1, values2) {
            var result = [],
                i;
            for (i = 0; i < values1.length; i++)
                result.push(Math.max(values1[i] || 0, values2[i] || 0));
            return result
        }
        function getAreaScrollable(area) {
            return area.groupElement().data('dxScrollable')
        }
        function subscribeToScrollEvent(area, handler) {
            var scrollable = getAreaScrollable(area);
            if (scrollable)
                scrollable.on('scroll', handler).on("stop", handler)
        }
        function setScrollPos(area, pos) {
            var scrollable;
            if (area) {
                scrollable = getAreaScrollable(area);
                if (scrollable) {
                    scrollable.scrollTo(pos);
                    scrollable.update()
                }
            }
        }
        function getScrollBarInfo(rootElement, useNativeScrolling) {
            var scrollBarWidth = 0,
                scrollBarUseNative,
                options = {};
            var container = $('<div>').css({
                    position: 'absolute',
                    visibility: 'hidden',
                    width: 100,
                    height: 100
                }).appendTo(rootElement);
            var content = $('<p>').css({
                    width: '100%',
                    height: 200
                }).appendTo(container);
            if (useNativeScrolling !== 'auto') {
                options.useNative = !!useNativeScrolling;
                options.useSimulatedScrollbar = !useNativeScrolling
            }
            container.dxScrollable(options);
            scrollBarUseNative = container.dxScrollable('instance').option('useNative');
            scrollBarWidth = scrollBarUseNative ? container.width() - content.width() : 0;
            container.remove();
            return {
                    scrollBarWidth: scrollBarWidth,
                    scrollBarUseNative: scrollBarUseNative
                }
        }
        DX.registerComponent("dxPivotGrid", ui, ui.Widget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    useNativeScrolling: "auto",
                    encodeHtml: true,
                    descriptions: null,
                    dataSource: null,
                    activeStateEnabled: false,
                    fieldChooser: {
                        minWidth: 250,
                        minHeight: 250,
                        enabled: true,
                        layout: 0,
                        title: Globalize.localize("dxPivotGrid-fieldChooserTitle"),
                        width: 600,
                        height: 600
                    },
                    onContextMenuPreparing: null,
                    allowSorting: false,
                    allowSortingBySummary: false,
                    allowFiltering: false,
                    allowExpandAll: false,
                    showRowTotals: true,
                    showRowGrandTotals: true,
                    showColumnTotals: true,
                    showColumnGrandTotals: true,
                    loadPanel: {
                        enabled: true,
                        text: Globalize.localize("Loading"),
                        width: 200,
                        height: 70,
                        showIndicator: true,
                        indicatorSrc: "",
                        showPane: true
                    },
                    texts: {
                        grandTotal: Globalize.localize("dxPivotGrid-grandTotal"),
                        total: Globalize.localize("dxPivotGrid-total"),
                        noData: Globalize.localize("dxDataGrid-noDataText"),
                        showFieldChooser: Globalize.localize("dxPivotGrid-showFieldChooser"),
                        expandAll: Globalize.localize("dxPivotGrid-expandAll"),
                        collapseAll: Globalize.localize("dxPivotGrid-collapseAll"),
                        sortColumnBySummary: Globalize.localize("dxPivotGrid-sortColumnBySummary"),
                        sortRowBySummary: Globalize.localize("dxPivotGrid-sortRowBySummary"),
                        removeAllSorting: Globalize.localize("dxPivotGrid-removeAllSorting")
                    },
                    onCellClick: null,
                    onCellPrepared: null,
                    onExpandValueChanging: null,
                    renderCellCountLimit: 20000
                })
            },
            _initDataController: function() {
                var that = this;
                if (that._dataController)
                    that._dataController.dispose();
                that._dataController = new pivotGrid.DataController({
                    descriptions: that.option('descriptions'),
                    dataSource: that.option('dataSource'),
                    texts: that.option('texts'),
                    showRowTotals: that.option('showRowTotals'),
                    showRowGrandTotals: that.option('showRowGrandTotals'),
                    showColumnTotals: that.option('showColumnTotals'),
                    showColumnGrandTotals: that.option('showColumnGrandTotals'),
                    onFieldsPrepared: function(fields) {
                        $.each(fields, function(index, field) {
                            $.each(["allowSorting", "allowSortingBySummary", "allowFiltering", "allowExpandAll"], function(_, optionName) {
                                if (field[optionName] === undefined)
                                    field[optionName] = that.option(optionName)
                            })
                        })
                    }
                });
                that._dataController.changed.add(function() {
                    that._render()
                });
                that._dataController.loadingChanged.add(function() {
                    that._updateLoading()
                });
                var expandValueChanging = that.option('onExpandValueChanging');
                if (expandValueChanging)
                    that._dataController.expandValueChanging.add(function(e) {
                        expandValueChanging(e)
                    })
            },
            _init: function() {
                var that = this;
                that.callBase();
                that._initDataController();
                that._scrollLeft = that._scrollTop = null;
                that._initActions()
            },
            _initActions: function() {
                this._actions = {
                    onContextMenuPreparing: this._createActionByOption("onContextMenuPreparing"),
                    onCellClick: this._createActionByOption("onCellClick")
                }
            },
            _trigger: function(eventName, eventArg) {
                this._actions[eventName](eventArg)
            },
            _optionValuesEqual: function(name, oldValue, newValue) {
                if (name === "dataSource" && newValue instanceof DX.data.PivotGridDataSource && oldValue instanceof DX.data.PivotGridDataSource)
                    return newValue === oldValue;
                return this.callBase.apply(this, arguments)
            },
            _optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"dataSource":
                    case"descriptions":
                    case"texts":
                    case"showRowTotals":
                    case"showRowGrandTotals":
                    case"showColumnTotals":
                    case"showColumnGrandTotals":
                    case"showColumnGrandTotals":
                    case"allowSorting":
                    case"allowFiltering":
                        that._initDataController();
                        that._fieldChooserPopup.hide();
                        that._invalidate();
                        break;
                    case"useNativeScrolling":
                    case"encodeHtml":
                    case"renderCellCountLimit":
                        that._invalidate();
                        break;
                    case"rtlEnabled":
                        that.callBase(args);
                        that._renderFieldChooser();
                        that._renderContextMenu();
                        that._renderLoadPanel(that._dataArea.groupElement());
                        that._invalidate();
                        break;
                    case"onExpandValueChanging":
                    case"onCellPrepared":
                    case"allowSortingBySummary":
                    case"allowExpandAll":
                        break;
                    case"onCellClick":
                    case"onContextMenuPreparing":
                        that._actions[args.name] = that._createActionByOption(args.name);
                        break;
                    case"fieldChooser":
                        that._renderFieldChooser();
                        break;
                    case"loadPanel":
                        that._renderLoadPanel(that._dataArea.groupElement());
                        that._invalidate();
                        break;
                    default:
                        that.callBase(args)
                }
            },
            _updateScrollPosition: function(columnsArea, rowsArea, dataArea) {
                var that = this,
                    scrollTop,
                    scrollLeft,
                    dataAreaScrollable,
                    scrolled = that._scrollTop || that._scrollLeft;
                if (rowsArea && !rowsArea.hasScroll())
                    that._scrollTop = null;
                if (columnsArea && !columnsArea.hasScroll())
                    that._scrollLeft = null;
                if (that._scrollTop !== null || that._scrollLeft !== null || scrolled) {
                    scrollTop = that._scrollTop || 0;
                    scrollLeft = that._scrollLeft || 0;
                    setScrollPos(dataArea, {
                        x: scrollLeft,
                        y: scrollTop
                    });
                    setScrollPos(columnsArea, scrollLeft);
                    setScrollPos(rowsArea, scrollTop)
                }
                else if (dataArea) {
                    dataAreaScrollable = getAreaScrollable(dataArea);
                    dataAreaScrollable && dataAreaScrollable.update()
                }
            },
            _subscribeToEvents: function(columnsArea, rowsArea, dataArea) {
                var that = this;
                subscribeToScrollEvent(dataArea, function(e) {
                    var scrollOffset = e.scrollOffset;
                    if (that._scrollLeft !== scrollOffset.left || that._scrollTop !== scrollOffset.top) {
                        that._scrollLeft = Math.floor(e.scrollOffset.left);
                        that._scrollTop = Math.floor(e.scrollOffset.top);
                        that._updateScrollPosition(columnsArea, rowsArea, null)
                    }
                });
                rowsArea.groupElement().off("dxmousewheel").on("dxmousewheel", function(e) {
                    var scrollable = dataArea.groupElement().data("dxScrollable");
                    scrollable && scrollable.scrollTo({y: that._scrollTop - Math.floor(e.delta)})
                })
            },
            _clean: $.noop,
            _needDelayResizing: function() {
                var cells = this._dataController.getCellsInfo(),
                    cellsCount = cells.length * (cells.length ? cells[0].length : 0);
                return cellsCount > this.option("renderCellCountLimit")
            },
            _renderFieldChooser: function() {
                var that = this,
                    container = that._pivotGridContainer,
                    fieldChooserOptions = that.option("fieldChooser") || {};
                var popupOptions = {
                        visible: false,
                        shading: false,
                        title: fieldChooserOptions.title,
                        width: fieldChooserOptions.width,
                        height: fieldChooserOptions.height,
                        showCloseButton: true,
                        onShown: function(e) {
                            var popup = e.component,
                                $content = e.component.content();
                            that._createComponent($content, "dxPivotGridFieldChooser", {
                                layout: fieldChooserOptions.layout,
                                texts: fieldChooserOptions.texts || {},
                                dataSource: that.getDataSource(),
                                width: undefined,
                                height: undefined
                            });
                            that._createComponent($content.parent(), "dxResizable", {
                                handles: that.option('rtlEnabled') ? "left bottom" : "right bottom",
                                onResize: function(e) {
                                    popup._setContentHeight();
                                    $content.dxPivotGridFieldChooser("updateDimensions")
                                },
                                minWidth: fieldChooserOptions.minWidth,
                                minHeight: fieldChooserOptions.minHeight
                            })
                        }
                    };
                if (that._fieldChooserPopup)
                    that._fieldChooserPopup.option(popupOptions);
                else
                    that._fieldChooserPopup = that._createComponent($('<div>').addClass('dx-fieldchooser-popup').appendTo(container), "dxPopup", popupOptions)
            },
            _renderContextMenu: function() {
                var that = this,
                    $container = that._pivotGridContainer;
                if (that._contextMenu)
                    that._contextMenu.element().remove();
                that._contextMenu = that._createComponent($("<div>").appendTo($container), "dxContextMenu", {
                    onPositioning: function(actionArgs) {
                        var event = actionArgs.jQueryEvent,
                            cellElement = event.target.cellIndex >= 0 ? event.target : $(event.target).closest('td').get(0),
                            cellArgs,
                            items;
                        if (cellElement) {
                            cellArgs = that._createCellArgs(cellElement, event);
                            items = that._getContextMenuItems(cellArgs);
                            if (items) {
                                actionArgs.component.option('items', items);
                                return
                            }
                        }
                        actionArgs.canceled = true
                    },
                    onItemClick: function(params) {
                        params.itemData.onItemClick && params.itemData.onItemClick(params)
                    },
                    cssClass: pivotGrid.cssClassNames.pivotGrid,
                    target: that.element()
                })
            },
            _getContextMenuItems: function(e) {
                var that = this,
                    items = [];
                if (e.area === "row" || e.area === "column") {
                    var areaFields = e[e.area + "Fields"],
                        oppositeAreaFields = e[e.area === "column" ? "rowFields" : "columnFields"],
                        field = e.cell.path && areaFields[e.cell.path.length - 1],
                        dataSource = that.getDataSource();
                    if (field && field.allowExpandAll && e.cell.path.length < e[e.area + "Fields"].length && e.cell.type === "D") {
                        items.push({
                            beginGroup: true,
                            icon: "none",
                            text: that.option("texts.expandAll"),
                            onItemClick: function() {
                                dataSource.expandAll(field.index)
                            }
                        });
                        items.push({
                            text: that.option("texts.collapseAll"),
                            icon: "none",
                            onItemClick: function() {
                                dataSource.collapseAll(field.index)
                            }
                        })
                    }
                    if (e.cell.isLast) {
                        var sortingBySummaryItemCount = 0;
                        $.each(oppositeAreaFields, function(index, field) {
                            if (field.allowSortingBySummary)
                                $.each(e.dataFields, function(dataIndex, dataField) {
                                    if (utils.isDefined(e.cell.dataIndex) && e.cell.dataIndex !== dataIndex)
                                        return;
                                    var showDataFieldCaption = !utils.isDefined(e.cell.dataIndex) && e.dataFields.length > 1,
                                        textFormat = that.option(e.area === "column" ? "texts.sortColumnBySummary" : "texts.sortRowBySummary"),
                                        checked = pivotGrid.findField(e.dataFields, field.sortBySummaryField) === dataIndex && (e.cell.path || []).join("/") === (field.sortBySummaryPath || []).join("/"),
                                        text = utils.stringFormat(textFormat, showDataFieldCaption ? field.caption + " - " + dataField.caption : field.caption);
                                    items.push({
                                        beginGroup: sortingBySummaryItemCount === 0,
                                        icon: checked ? field.sortOrder === "desc" ? "desc" : "asc" : "none",
                                        text: text,
                                        onItemClick: function() {
                                            dataSource.field(field.index, {
                                                sortBySummaryField: dataField.caption || dataField.dataField,
                                                sortBySummaryPath: e.cell.path,
                                                sortOrder: field.sortOrder === "desc" ? "asc" : "desc"
                                            });
                                            dataSource.load()
                                        }
                                    });
                                    sortingBySummaryItemCount++
                                })
                        });
                        $.each(oppositeAreaFields, function(index, field) {
                            if (field.allowSortingBySummary && utils.isDefined(field.sortBySummaryField)) {
                                items.push({
                                    beginGroup: sortingBySummaryItemCount === 0,
                                    icon: "none",
                                    text: that.option("texts.removeAllSorting"),
                                    onItemClick: function() {
                                        $.each(oppositeAreaFields, function(index, field) {
                                            dataSource.field(field.index, {
                                                sortBySummaryField: undefined,
                                                sortBySummaryPath: undefined,
                                                sortOrder: undefined
                                            })
                                        });
                                        dataSource.load()
                                    }
                                });
                                return false
                            }
                        })
                    }
                }
                if (that.option("fieldChooser.enabled"))
                    items.push({
                        beginGroup: true,
                        icon: "field-chooser",
                        text: that.option("texts.showFieldChooser"),
                        onItemClick: function() {
                            that._fieldChooserPopup.show()
                        }
                    });
                e.items = items;
                that._trigger("onContextMenuPreparing", e);
                items = e.items;
                if (items && items.length)
                    return items
            },
            _createCellArgs: function(cellElement, jQueryEvent) {
                var that = this,
                    $cellElement = $(cellElement),
                    columnIndex = cellElement.cellIndex,
                    rowIndex = cellElement.parentElement.rowIndex,
                    $table = $cellElement.closest('table'),
                    dataSource = that.getDataSource(),
                    data = $table.data("data"),
                    cell = data && data[rowIndex] && data[rowIndex][columnIndex],
                    args = {
                        area: $table.data("area"),
                        rowFields: dataSource.getAreaFields("row"),
                        columnFields: dataSource.getAreaFields("column"),
                        dataFields: dataSource.getAreaFields("data"),
                        rowIndex: rowIndex,
                        columnIndex: columnIndex,
                        cellElement: $cellElement,
                        cell: cell,
                        jQueryEvent: jQueryEvent
                    };
                return args
            },
            _handleCellClick: function(e) {
                var that = this,
                    args = that._createCellArgs(e.currentTarget, e);
                if (!args.area && (args.rowIndex || args.columnIndex))
                    return;
                that._trigger("onCellClick", args);
                if (!args.handled)
                    if (!args.area && that.option("fieldChooser.enabled"))
                        that._fieldChooserPopup.show()
            },
            _getNoDataText: function() {
                return this.option("texts.noData")
            },
            _updateNoDataText: DX.ui.dxDataGrid.RowsView.prototype._updateNoDataText,
            _renderLoadPanel: DX.ui.dxDataGrid.RowsView.prototype._renderLoadPanel,
            _updateLoading: function() {
                var that = this;
                that._loadPanel && that._loadPanel.option("visible", that._dataController.isLoading())
            },
            _renderContentImpl: function() {
                var that = this,
                    columnsAreaElement = $('<td>'),
                    rowsAreaElement = $('<td>'),
                    dataAreaElement = $('<td>'),
                    tableElement = $('<table>'),
                    dataArea = that._dataArea || new pivotGrid.DataArea(that),
                    rowsArea = (that._rowsArea || new pivotGrid.VerticalHeadersArea(that)).setDataController(that._dataController),
                    columnsArea = (that._columnsArea || new pivotGrid.HorizontalHeadersArea(that)).setDataController(that._dataController),
                    scrollBarInfo = getScrollBarInfo(that.element(), that.option("useNativeScrolling"));
                that._scrollBarWidth = scrollBarInfo.scrollBarWidth;
                that._scrollBarUseNative = scrollBarInfo.scrollBarUseNative;
                if (!utils.isDefined(that._pivotGridContainer)) {
                    that._pivotGridContainer = $('<div>');
                    that._renderFieldChooser();
                    that._renderContextMenu();
                    $('<tr>').append($('<td>').addClass(pivotGrid.cssClassNames.areaDescription)).append(columnsAreaElement).appendTo(tableElement);
                    $('<tr>').addClass(pivotGrid.cssClassNames.bottomAraesRow).append(rowsAreaElement).append(dataAreaElement).appendTo(tableElement);
                    tableElement.appendTo(that._pivotGridContainer);
                    tableElement.on(events.addNamespace("dxclick", "dxPivotGrid"), 'td', $.proxy(that, "_handleCellClick"))
                }
                else
                    tableElement = that._pivotGridContainer.children().first();
                that._rowsArea = rowsArea;
                that._columnsArea = columnsArea;
                that._dataArea = dataArea;
                columnsArea.render(columnsAreaElement, that._dataController.getColumnsInfo());
                rowsArea.render(rowsAreaElement, that._dataController.getRowsInfo());
                dataArea.render(dataAreaElement, that._dataController.getCellsInfo());
                dataArea.tableElement().prepend(columnsArea.headElement());
                var updateHandler = function() {
                        that.updateDimensions();
                        that._subscribeToEvents(columnsArea, rowsArea, dataArea)
                    };
                if (!utils.isDefined(that._pivotGridContainer[0].parentElement)) {
                    that._hasHeight = that.element().height() > 0;
                    that._pivotGridContainer.appendTo(that.element());
                    that.element().addClass(pivotGrid.cssClassNames.pivotGrid).addClass(pivotGrid.cssClassNames.rowLines);
                    that._renderLoadPanel(dataArea.groupElement());
                    rowsArea.processScroll();
                    columnsArea.processScroll();
                    if (that._needDelayResizing())
                        setTimeout(updateHandler);
                    else
                        updateHandler()
                }
                else
                    updateHandler()
            },
            _fireContentReadyAction: function() {
                if (!this._dataController.isLoading())
                    this.callBase()
            },
            getScrollPath: function(area) {
                var that = this,
                    i,
                    currentScrollPosition = 0,
                    scrollPosition,
                    columnSizes;
                if (area === 'column') {
                    scrollPosition = that._scrollLeft;
                    columnSizes = that._columnsArea.getColumnsWidth()
                }
                else {
                    scrollPosition = that._scrollTop;
                    columnSizes = that._rowsArea.getRowsHeight()
                }
                for (i = 0; i < columnSizes.length; i++) {
                    if (scrollPosition < currentScrollPosition + columnSizes[i] / 2)
                        return that._dataController.getHeaderItemPath(area, i);
                    currentScrollPosition += columnSizes[i]
                }
            },
            getDataSource: function() {
                return this._dataController.getDataSource()
            },
            hasScroll: function(area) {
                var that = this;
                if (area === 'column')
                    return that._columnsArea.hasScroll();
                else
                    return that._rowsArea.hasScroll()
            },
            _dimensionChanged: function() {
                this.updateDimensions()
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this.updateDimensions()
            },
            _dispose: function() {
                var that = this;
                that.callBase.apply(that, arguments);
                if (that._dataController)
                    that._dataController.dispose()
            },
            resize: function() {
                this.updateDimensions()
            },
            isReady: function() {
                return this.callBase() && !this._dataController.isLoading()
            },
            updateDimensions: function() {
                var that = this,
                    diff,
                    groupWidth,
                    groupHeight,
                    tableElement = that.element().find('table').first(),
                    bottomAraesRowElement,
                    rowsArea = that._rowsArea,
                    columnsArea = that._columnsArea,
                    dataArea = that._dataArea,
                    dataAreaHeights,
                    rowsAreaHeights,
                    resultHeights,
                    resultWidths,
                    rowsAreaColumnWidths,
                    totalWidth = 0,
                    totalHeight = 0,
                    rowsAreaWidth = 0,
                    hasRowsScroll,
                    hasColumnsScroll,
                    dataFields = that.getDataSource().getAreaFields("data"),
                    loadPanelOptions = that.option("loadPanel") || {},
                    minHeight,
                    scrollBarWidth = that._scrollBarWidth || 0;
                if (!dataArea.headElement().length) {
                    dataArea.tableElement().prepend(columnsArea.headElement());
                    dataArea.resetColumnsWidth()
                }
                dataArea.groupWidth(MIN_AREA_GROUP_WIDTH);
                resultWidths = dataArea.getColumnsWidth();
                rowsAreaHeights = rowsArea.getRowsHeight();
                dataAreaHeights = dataArea.getRowsHeight();
                resultHeights = mergeArraysByMaxValue(rowsAreaHeights, dataAreaHeights.slice(that._dataController.getColumnsInfo().length));
                rowsAreaColumnWidths = rowsArea.getColumnsWidth();
                if (that._hasHeight) {
                    diff = that.element().height() - tableElement.height() - dataArea.headElement().height();
                    bottomAraesRowElement = tableElement.find('.' + pivotGrid.cssClassNames.bottomAraesRow),
                    groupHeight = Math.floor(bottomAraesRowElement.height() + diff)
                }
                totalWidth = dataArea.tableElement().width();
                $.each(resultHeights, function(index, height) {
                    totalHeight += height || 0
                });
                $.each(rowsAreaColumnWidths, function(index, width) {
                    rowsAreaWidth += width || 0
                });
                groupWidth = that.element().width() - rowsAreaWidth;
                hasRowsScroll = groupHeight < totalHeight;
                hasColumnsScroll = groupWidth < totalWidth;
                if (!hasRowsScroll)
                    groupHeight = totalHeight + (hasColumnsScroll ? scrollBarWidth : 0);
                columnsArea.tableElement().append(dataArea.headElement());
                if (resultHeights.length === 1 && loadPanelOptions.enabled && loadPanelOptions.height) {
                    minHeight = loadPanelOptions.height + 50;
                    if (resultHeights[0] < minHeight) {
                        resultHeights[0] = minHeight;
                        if (groupHeight < minHeight)
                            groupHeight = minHeight
                    }
                }
                columnsArea.groupWidth(groupWidth);
                columnsArea.processScrollBarSpacing(hasRowsScroll ? scrollBarWidth : 0);
                columnsArea.processStretch(resultWidths, hasColumnsScroll, dataFields);
                columnsArea.setColumnsWidth(resultWidths);
                rowsArea.groupHeight(groupHeight);
                rowsArea.processScrollBarSpacing(hasColumnsScroll ? scrollBarWidth : 0);
                rowsArea.setColumnsWidth(rowsAreaColumnWidths);
                rowsArea.setRowsHeight(resultHeights);
                dataArea.setColumnsWidth(resultWidths);
                dataArea.setRowsHeight(resultHeights);
                dataArea.groupWidth(groupWidth);
                dataArea.groupHeight(groupHeight);
                dataArea.groupElement().css('border-bottom-width', hasRowsScroll || scrollBarWidth ? '0px' : '');
                rowsArea.groupElement().css('border-bottom-width', hasRowsScroll && !scrollBarWidth ? '0px' : '');
                dataArea.processScroll(scrollBarWidth, hasRowsScroll, hasColumnsScroll, that._scrollBarUseNative);
                that._updateNoDataText(dataArea.groupElement());
                that._updateLoading();
                that._updateScrollPosition(columnsArea, rowsArea, dataArea);
                that._testResultWidths = resultWidths;
                that._testResultHeights = resultHeights
            },
            applyPartialDataSource: function(area, path, dataSource) {
                this._dataController.applyPartialDataSource(area, path, dataSource)
            }
        }));
        var pivotGrid = $.extend(ui.dxPivotGrid, {
                cssClassNames: {
                    pivotGrid: 'dx-pivotgrid',
                    rowLines: 'dx-row-lines',
                    area: 'dx-pivotgrid-area',
                    areaData: 'dx-pivotgrid-area-data',
                    areaDescription: 'dx-pivotgrid-area-description',
                    splitter: 'dx-pivotgrid-splitter',
                    splitterButton: 'dx-button',
                    splitterButtonDisable: 'dx-button-disable',
                    splitterExpand: 'dx-expand',
                    splitterCollapse: 'dx-collapse',
                    bottomAraesRow: 'dx-bottom-row',
                    verticalScroll: 'dx-vertical-scroll',
                    headersVertical: 'dx-pivotgrid-vertical-headers',
                    headersHorizontal: 'dx-pivotgrid-horizontal-headers',
                    headersVerticalLastCell: 'dx-last-cell',
                    headersVerticalExpandBorder: 'dx-expand-border',
                    headersExpandCollapseImage: 'dx-expand',
                    headersExpanded: 'dx-pivotgrid-expanded',
                    headersCollapsed: 'dx-pivotgrid-collapsed',
                    bottomBorder: 'dx-pivotgrid-bottom-border',
                    total: 'dx-total',
                    grandTotal: 'dx-grandtotal',
                    rowTotal: 'dx-row-total'
                },
                mergeArraysByMaxValue: mergeArraysByMaxValue
            })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.dataSource.js */
    (function($, DX) {
        var pivotGrid = DX.ui.dxPivotGrid,
            utils = DX.utils,
            isDefined = utils.isDefined;
        var DESCRIPTION_NAME_BY_AREA = {
                row: "rows",
                column: "columns",
                data: "values",
                filter: "filters"
            };
        function findField(fields, id) {
            var i,
                field;
            if (fields && utils.isDefined(id))
                for (i = 0; i < fields.length; i++) {
                    field = fields[i];
                    if (field.name === id || field.caption === id || field.dataField === id || field.index === id)
                        return i
                }
            return -1
        }
        function foreachTreeItems(items, callback, path, parentAtFirst) {
            var index,
                item;
            if (!items)
                return;
            for (index = 0; index < items.length; index++) {
                item = items[index];
                if (item) {
                    if (path)
                        path.push(item.value);
                    if (parentAtFirst && callback(item, path, index, items) === false)
                        return false;
                    if (foreachTreeItems(item.children, callback, path, parentAtFirst) === false)
                        return false;
                    if (!parentAtFirst && callback(item, path, index, items) === false)
                        return false;
                    if (path)
                        path.pop()
                }
            }
        }
        function formatValue(value, options) {
            var formatObject = {
                    value: value,
                    valueText: DX.formatHelper.format(value, options.format, options.precision) || ''
                };
            return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText
        }
        function foreachDataLevel(data, callback, index, childrenField) {
            var item,
                i;
            index = index || 0;
            childrenField = childrenField || "children";
            if (data.length)
                callback(data, index);
            for (i = 0; i < data.length; i++) {
                item = data[i];
                if (item[childrenField] && item[childrenField].length)
                    foreachDataLevel(item[childrenField], callback, index + 1, childrenField)
            }
        }
        function getCompareFunction(valueSelector) {
            return function(a, b) {
                    var result = 0;
                    if (valueSelector(a) > valueSelector(b))
                        result = 1;
                    else if (valueSelector(a) < valueSelector(b))
                        result = -1;
                    return result
                }
        }
        DX.data.PivotGridDataSource = pivotGrid.DataSource = DX.Class.inherit(function() {
            var isValuesEqual = function(value1, value2) {
                    return DevExpress.data.utils.toComparable(value1) === DevExpress.data.utils.toComparable(value2)
                };
            var findHeaderItem = function(headerItems, path) {
                    var pathIndex,
                        foundHeaderItems,
                        headerItem = null;
                    var checkHeaderItem = function(item) {
                            return isValuesEqual(item.value, path[pathIndex])
                        };
                    if ($.isArray(path))
                        for (pathIndex = 0; pathIndex < path.length && headerItems; pathIndex++) {
                            foundHeaderItems = $.grep(headerItems || [], checkHeaderItem);
                            if (foundHeaderItems.length === 0) {
                                headerItem = null;
                                break
                            }
                            headerItem = foundHeaderItems[0];
                            headerItems = headerItem.children
                        }
                    return headerItem
                };
            var getHeaderItemsLastIndex = function(headerItems, grandTotalIndex) {
                    var i,
                        lastIndex = -1,
                        headerItem;
                    if (headerItems)
                        for (i = 0; i < headerItems.length; i++) {
                            headerItem = headerItems[i];
                            lastIndex = Math.max(lastIndex, headerItem.index);
                            if (headerItem.children)
                                lastIndex = Math.max(lastIndex, getHeaderItemsLastIndex(headerItem.children));
                            else if (headerItem.collapsedChildren)
                                lastIndex = Math.max(lastIndex, getHeaderItemsLastIndex(headerItem.collapsedChildren))
                        }
                    if (isDefined(grandTotalIndex))
                        lastIndex = Math.max(lastIndex, grandTotalIndex);
                    return lastIndex
                };
            var updateHeaderItemChildren = function(headerItems, headerItem, children, grandTotalIndex) {
                    var applyingHeaderItemsCount = getHeaderItemsLastIndex(children) + 1,
                        emptyIndex = getHeaderItemsLastIndex(headerItems, grandTotalIndex) + 1,
                        index,
                        applyingItemIndexesToCurrent = [];
                    for (index = 0; index < applyingHeaderItemsCount; index++)
                        applyingItemIndexesToCurrent[index] = emptyIndex++;
                    headerItem.children = [];
                    $.extend(true, headerItem.children, children);
                    foreachTreeItems(headerItem.children, function(item) {
                        item.index = applyingItemIndexesToCurrent[item.index]
                    });
                    return applyingItemIndexesToCurrent
                };
            var updateHeaderItems = function(headerItems, newHeaderItems) {
                    var applyingItemIndexesToCurrent = [];
                    foreachTreeItems(headerItems, function(headerItem) {
                        delete headerItem.collapsedChildren
                    });
                    foreachTreeItems(newHeaderItems, function(newHeaderItem, path) {
                        var headerItem = findHeaderItem(headerItems, path);
                        if (headerItem)
                            applyingItemIndexesToCurrent[newHeaderItem.index] = headerItem.index
                    }, []);
                    return applyingItemIndexesToCurrent
                };
            var updateDataSourceCells = function(dataSource, newDataSourceCells, newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent) {
                    var newRowIndex,
                        newColumnIndex,
                        newRowCells,
                        newCell,
                        rowIndex,
                        columnIndex,
                        dataSourceCells = dataSource.values;
                    if (newDataSourceCells)
                        for (newRowIndex = 0; newRowIndex <= newDataSourceCells.length; newRowIndex++) {
                            newRowCells = newDataSourceCells[newRowIndex];
                            rowIndex = newRowItemIndexesToCurrent[newRowIndex];
                            if (!isDefined(rowIndex))
                                rowIndex = dataSource.grandTotalRowIndex;
                            if (newRowCells && isDefined(rowIndex)) {
                                if (!dataSourceCells[rowIndex])
                                    dataSourceCells[rowIndex] = [];
                                for (newColumnIndex = 0; newColumnIndex <= newRowCells.length; newColumnIndex++) {
                                    newCell = newRowCells[newColumnIndex];
                                    columnIndex = newColumnItemIndexesToCurrent[newColumnIndex];
                                    if (!isDefined(columnIndex))
                                        columnIndex = dataSource.grandTotalColumnIndex;
                                    if (isDefined(newCell) && isDefined(columnIndex))
                                        dataSourceCells[rowIndex][columnIndex] = newCell
                                }
                            }
                        }
                };
            function createStore(dataSourceOptions) {
                var store,
                    storeOptions;
                if ($.isPlainObject(dataSourceOptions) && dataSourceOptions.load)
                    store = new pivotGrid.LocalStore(dataSourceOptions);
                else {
                    if (dataSourceOptions && !dataSourceOptions.store)
                        dataSourceOptions = {store: dataSourceOptions};
                    storeOptions = dataSourceOptions.store;
                    if (storeOptions.type === "xmla")
                        store = new pivotGrid.XmlaStore(storeOptions);
                    else if ($.isPlainObject(storeOptions) && storeOptions.type || storeOptions instanceof DX.data.Store || $.isArray(storeOptions))
                        store = new pivotGrid.LocalStore(dataSourceOptions);
                    else if (storeOptions instanceof DX.Class)
                        store = storeOptions
                }
                return store
            }
            function getExpandedPaths(dataSource, loadOptions, dimentionName) {
                var result = [],
                    fields = loadOptions[dimentionName];
                foreachTreeItems(dataSource[dimentionName], function(item, path) {
                    if (item.children && fields[path.length - 1] && !fields[path.length - 1].expanded)
                        path.length < fields.length && result.push(path.slice())
                }, [], true);
                if (result.length)
                    return result
            }
            function getFieldsByGroup(fields, grouppingField) {
                return $.map(fields, function(field) {
                        if (field.groupName === grouppingField.groupName && utils.isNumber(field.groupIndex) && field.visible !== false)
                            return $.extend(field, {
                                    areaIndex: grouppingField.areaIndex,
                                    area: grouppingField.area,
                                    dataField: field.dataField || grouppingField.dataField,
                                    dataType: field.dataType || grouppingField.dataType,
                                    sortBy: field.sortBy || grouppingField.sortBy,
                                    sortOrder: field.sortOrder || grouppingField.sortOrder,
                                    sortBySummaryField: field.sortBySummaryField || grouppingField.sortBySummaryField,
                                    sortBySummaryPath: field.sortBySummaryPath || grouppingField.sortBySummaryPath,
                                    visible: field.visible || grouppingField.visible
                                });
                        return null
                    }).sort(function(a, b) {
                        return a.groupIndex - b.groupIndex
                    })
            }
            function sortFieldsByAreaIndex(fields) {
                fields.sort(function(field1, field2) {
                    return field1.areaIndex - field2.areaIndex
                })
            }
            function createDescriptions(currentField) {
                var that = this,
                    fields = that.fields(),
                    descriptions = {
                        rows: [],
                        columns: [],
                        values: [],
                        filters: []
                    };
                $.each(["row", "column", "data", "filter"], function(_, areaName) {
                    utils.normalizeIndexes(that.getAreaFields(areaName, true), 'areaIndex', currentField)
                });
                $.each(fields || [], function(_, field) {
                    var descriptionName = DESCRIPTION_NAME_BY_AREA[field.area],
                        dimension = descriptions[descriptionName],
                        groupName = field.groupName;
                    if (groupName && !utils.isNumber(field.groupIndex))
                        field.levels = getFieldsByGroup(fields, field);
                    if (!dimension || groupName && utils.isNumber(field.groupIndex) || field.visible === false)
                        return;
                    if (field.levels && dimension !== descriptions.filters) {
                        dimension.push.apply(dimension, field.levels);
                        if (field.filterValues && field.filterValues.length)
                            descriptions.filters.push(field)
                    }
                    else
                        dimension.push(field)
                });
                $.each(descriptions, function(_, fields) {
                    sortFieldsByAreaIndex(fields)
                });
                return descriptions
            }
            function getFieldId(field) {
                return (field.dataField || field.groupName || '') + (field.groupInterval ? field.groupName || '' : "NOGROUP") + (field.groupInterval || '')
            }
            function mergeFields(fields, storeFields, retrieveFieldsOptionValue) {
                var result = [],
                    fieldsDictionary = {},
                    removedFields = {},
                    mergedGroups = [],
                    dataTypes = getFieldsDataType(fields);
                if (storeFields) {
                    $.each(storeFields, function(_, field) {
                        fieldsDictionary[getFieldId(field)] = field
                    });
                    $.each(fields, function(_, field) {
                        var fieldKey = getFieldId(field),
                            storeField = fieldsDictionary[fieldKey] || removedFields[fieldKey],
                            mergedField;
                        if (storeField)
                            mergedField = $.extend({}, storeField, field);
                        else
                            fieldsDictionary[fieldKey] = mergedField = field;
                        $.extend(mergedField, {dataType: dataTypes[field.dataField]});
                        delete fieldsDictionary[fieldKey];
                        removedFields[fieldKey] = storeField;
                        result.push(mergedField)
                    });
                    if (retrieveFieldsOptionValue)
                        $.each(fieldsDictionary, function(_, field) {
                            result.push(field)
                        })
                }
                else
                    result = fields;
                result.push.apply(result, mergedGroups);
                return result
            }
            function createCaption(field) {
                var caption = field.dataField || field.groupName || "",
                    summaryType = (field.summaryType || "").toLowerCase();
                if (utils.isString(field.groupInterval))
                    caption += "_" + field.groupInterval;
                if (summaryType && summaryType !== "custom") {
                    summaryType = summaryType.replace(/^./, summaryType[0].toUpperCase());
                    if (caption.length)
                        summaryType = " (" + summaryType + ")"
                }
                else
                    summaryType = "";
                return DX.inflector.titleize(caption) + summaryType
            }
            function getFieldsDataType(fields) {
                var result = {};
                $.each(fields, function(_, field) {
                    result[field.dataField] = result[field.dataField] || field.dataType
                });
                return result
            }
            function getFields(that) {
                var result = $.Deferred(),
                    store = that._store,
                    storeFields = store && store.getFields(getFieldsDataType(that._fields)),
                    mergedFields;
                $.when(storeFields).done(function(storeFields) {
                    that._storeFields = storeFields;
                    mergedFields = mergeFields(that._fields, storeFields, that._retrieveFields);
                    result.resolve(mergedFields)
                }).fail(function() {
                    result.resolve(that._fields)
                });
                return result
            }
            function getSliceIndex(items, path) {
                var index = null,
                    pathValue = (path || []).join(".");
                if (pathValue.length)
                    foreachTreeItems(items, function(item, itemPath) {
                        if (pathValue === itemPath.join(".")) {
                            index = item.index;
                            return false
                        }
                    }, []);
                return index
            }
            function getFieldSummaryValueSelector(field, dataSource, loadOptions, dimensionName) {
                var values = dataSource.values,
                    sortBySummaryFieldIndex = findField(loadOptions.values, field.sortBySummaryField),
                    areRows = dimensionName === "rows",
                    sortByDimension = areRows ? dataSource.columns : dataSource.rows,
                    grandTotalIndex = areRows ? dataSource.grandTotalRowIndex : dataSource.grandTotalColumnIndex,
                    sortBySummaryPath = field.sortBySummaryPath || [],
                    sliceIndex = sortBySummaryPath.length ? getSliceIndex(sortByDimension, sortBySummaryPath) : grandTotalIndex;
                if (values && values.length && sortBySummaryFieldIndex >= 0 && isDefined(sliceIndex))
                    return function(field) {
                            var rowIndex = areRows ? field.index : sliceIndex,
                                columnIndex = areRows ? sliceIndex : field.index;
                            return ((values[rowIndex] || [[]])[columnIndex] || [])[sortBySummaryFieldIndex] || null
                        }
            }
            function getSortingMethod(field, dataSource, loadOptions, dimensionName) {
                var sortOrder = field.sortOrder,
                    defaultCompare = field.sortingMethod || getCompareFunction(function(item) {
                        return item.value
                    }),
                    summaryValueSelector = getFieldSummaryValueSelector(field, dataSource, loadOptions, dimensionName),
                    summaryCompare = summaryValueSelector && getCompareFunction(summaryValueSelector),
                    sortingMethod = function(a, b) {
                        var result = summaryCompare && summaryCompare(a, b) || 0;
                        if (result === 0)
                            result = defaultCompare(a, b);
                        return sortOrder === "desc" ? -result : result
                    };
                return sortingMethod
            }
            function sortDimension(dataSource, loadOptions, dimensionName) {
                var fields = loadOptions[dimensionName] || [],
                    baseIndex = loadOptions.headerName === dimensionName ? loadOptions.path.length : 0,
                    sortingMetodByLevel = [];
                foreachDataLevel(dataSource[dimensionName], function(item, index) {
                    var field = fields[index] || {},
                        sortingMethod = sortingMetodByLevel[index] = sortingMetodByLevel[index] || getSortingMethod(field, dataSource, loadOptions, dimensionName);
                    item.sort(sortingMethod)
                }, baseIndex)
            }
            function sort(loadOptions, dataSource) {
                sortDimension(dataSource, loadOptions, "rows");
                sortDimension(dataSource, loadOptions, "columns")
            }
            function formatHeaderItems(data, loadOptions, headerName) {
                foreachTreeItems(data[headerName], function(item, path) {
                    item.text = item.text || formatValue(item.value, loadOptions[headerName][path.length - 1])
                }, [])
            }
            function formatHeaders(loadOptions, data) {
                formatHeaderItems(data, loadOptions, "columns");
                formatHeaderItems(data, loadOptions, "rows")
            }
            pivotGrid.sort = sort;
            return {
                    ctor: function(options) {
                        options = options || {};
                        var that = this,
                            store = createStore(options);
                        that._store = store;
                        that._loadedData = {
                            rows: [],
                            columns: [],
                            values: []
                        };
                        that._data = $.extend(true, {}, that._loadedData);
                        that._loadingCount = 0;
                        $.each(["changed", "loadError", "loadingChanged", "fieldsPrepared", "expandValueChanging"], $.proxy(function(_, eventName) {
                            var optionName = "on" + eventName[0].toUpperCase() + eventName.slice(1);
                            if (options.hasOwnProperty(optionName))
                                this.on(eventName, options[optionName])
                        }, this));
                        that._localSorting = !!options.localSorting;
                        that._retrieveFields = isDefined(options.retrieveFields) ? options.retrieveFields : true;
                        that._fields = options.fields || [];
                        that._descriptions = options.descriptions ? $.extend(that._createDescriptions(), options.descriptions) : undefined;
                        if (!store) {
                            $.extend(true, that._loadedData, options.store || options);
                            that._data = $.extend(true, {}, that._loadedData)
                        }
                    },
                    getData: function() {
                        return this._data
                    },
                    getAreaFields: function(area, collectGroups) {
                        var areaFields = [],
                            descriptions;
                        if (collectGroups || area === "data") {
                            $.each(this._fields, function() {
                                if (this.area === area && !isDefined(this.groupIndex) && this.visible !== false)
                                    areaFields.push(this)
                            });
                            sortFieldsByAreaIndex(areaFields)
                        }
                        else {
                            descriptions = this._descriptions || {};
                            areaFields = descriptions[DESCRIPTION_NAME_BY_AREA[area]] || []
                        }
                        return areaFields
                    },
                    fields: function(fields) {
                        var that = this;
                        if (fields) {
                            that._fields = mergeFields(fields, that._storeFields, that._retrieveFields);
                            that._fieldsPrepared(that._fields)
                        }
                        return that._fields
                    },
                    field: function(id, options) {
                        var that = this,
                            fields = that._fields,
                            field = fields && fields[utils.isNumber(id) ? id : findField(fields, id)],
                            levels;
                        if (field && options) {
                            $.each(options, function(optionName, optionValue) {
                                field[optionName] = optionValue;
                                if (optionName === "sortOrder") {
                                    levels = field.levels || [];
                                    for (var i = 0; i < levels.length; i++)
                                        levels[i][optionName] = optionValue
                                }
                            });
                            that._descriptions = that._createDescriptions(field)
                        }
                        return field
                    },
                    getFieldValues: function(index) {
                        var that = this,
                            field = this._fields && this._fields[index],
                            store = this.store(),
                            loadFields = [],
                            loadOptions = {
                                columns: loadFields,
                                rows: [],
                                values: this.getAreaFields("data"),
                                filters: [],
                                localSorting: this._localSorting
                            },
                            d = $.Deferred();
                        if (field && store) {
                            $.each(field.levels || [field], function() {
                                loadFields.push($.extend({}, this, {
                                    expanded: true,
                                    filterValues: null,
                                    sortOrder: 'asc',
                                    sortBySummaryField: null
                                }))
                            });
                            store.load(loadOptions).done(function(data) {
                                formatHeaders(loadOptions, data);
                                that._sort(loadOptions, data);
                                d.resolve(data.columns)
                            }).fail(d)
                        }
                        else
                            d.reject();
                        return d
                    },
                    load: function(options) {
                        var that = this,
                            d = $.Deferred();
                        options = options || {};
                        that._changeLoadingCount(1);
                        d.fail(function(e) {
                            that.fireEvent("loadError", [e])
                        }).always(function() {
                            that._changeLoadingCount(-1)
                        });
                        that._delayedLoadTask = DX.utils.executeAsync(function() {
                            that._delayedLoadTask = undefined;
                            if (!that._descriptions)
                                $.when(getFields(that)).done(function(fields) {
                                    that._fieldsPrepared(fields);
                                    that._loadCore(options, d)
                                }).fail(d.reject).fail(that._loadErrorHandler);
                            else
                                that._loadCore(options, d)
                        });
                        return d
                    },
                    _createDescriptions: createDescriptions,
                    _fieldsPrepared: function(fields) {
                        var that = this;
                        that._fields = fields;
                        $.each(fields, function(index, field) {
                            field.index = index;
                            if (!isDefined(field.caption))
                                field.caption = createCaption(field)
                        });
                        that.fireEvent("fieldsPrepared", [fields]);
                        that._descriptions = that._createDescriptions()
                    },
                    isLoading: function() {
                        return this._loadingCount > 0
                    },
                    _changeLoadingCount: function(increment) {
                        var oldLoading = this.isLoading(),
                            newLoading;
                        this._loadingCount += increment;
                        newLoading = this.isLoading();
                        if (oldLoading ^ newLoading)
                            this.fireEvent("loadingChanged", [newLoading])
                    },
                    _loadCore: function(options, deferred) {
                        var that = this,
                            store = this._store,
                            descriptions = this._descriptions,
                            headerName = DESCRIPTION_NAME_BY_AREA[options.area];
                        options = options || {};
                        if (store) {
                            $.extend(options, descriptions);
                            options.columnExpandedPaths = getExpandedPaths(this._loadedData, options, "columns");
                            options.rowExpandedPaths = getExpandedPaths(this._loadedData, options, "rows");
                            if (that._localSorting)
                                options.localSorting = true;
                            if (headerName)
                                options.headerName = headerName;
                            $.when(store.load(options)).done(function(data) {
                                if (options.path)
                                    that.applyPartialDataSource(options.area, options.path, data, deferred);
                                else {
                                    $.extend(that._loadedData, data);
                                    that._update(deferred)
                                }
                                deferred.resolve(that._data)
                            }).fail(deferred.reject)
                        }
                        else {
                            that._update(deferred);
                            deferred.resolve(that._data)
                        }
                    },
                    _sort: function(descriptions, data) {
                        var store = this._store;
                        if (store && store.supportSorting && (this._localSorting || !store.supportSorting()))
                            sort(descriptions, data)
                    },
                    _update: function(deferred) {
                        var that = this;
                        formatHeaders(that._descriptions, that._loadedData);
                        that._sort(that._descriptions, that._loadedData);
                        that._data = $.extend(true, {}, that._loadedData);
                        $.when(deferred).done(function() {
                            that.fireEvent("changed");
                            if (utils.isDefined(that._data.grandTotalRowIndex))
                                that._loadedData.grandTotalRowIndex = that._data.grandTotalRowIndex;
                            if (utils.isDefined(that._data.grandTotalColumnIndex))
                                that._loadedData.grandTotalColumnIndex = that._data.grandTotalColumnIndex
                        })
                    },
                    getHeaderItemPath: function(area, visibleIndex) {
                        var that = this,
                            index = 0,
                            result,
                            headerItems = area === 'column' ? that._data.columns : that._data.rows;
                        if (area === 'column' && that._descriptions.values.length > 1)
                            visibleIndex = Math.floor(visibleIndex / that._descriptions.values.length);
                        foreachTreeItems(headerItems, function(_, path) {
                            if (index === visibleIndex) {
                                result = path;
                                return false
                            }
                            index++
                        }, []);
                        return result
                    },
                    store: function() {
                        return this._store
                    },
                    collapseHeaderItem: function(area, path) {
                        var that = this,
                            headerItems = area === 'column' ? that._loadedData.columns : that._loadedData.rows,
                            headerItem = findHeaderItem(headerItems, path),
                            field = that.getAreaFields(area)[path.length - 1];
                        if (headerItem && headerItem.children) {
                            that.fireEvent("expandValueChanging", [{
                                    area: area,
                                    path: path,
                                    expanded: false
                                }]);
                            if (field)
                                field.expanded = false;
                            headerItem.collapsedChildren = headerItem.children;
                            delete headerItem.children;
                            that._update();
                            return true
                        }
                        return false
                    },
                    collapseAll: function(id) {
                        var dataChanged = false,
                            field = this.field(id) || {},
                            areaOffset = $.inArray(field, this.getAreaFields(field.area));
                        field.expanded = false;
                        foreachTreeItems(this._loadedData[field.area + "s"], function(item, path) {
                            if (item && item.children && areaOffset === path.length - 1) {
                                item.collapsedChildren = item.children;
                                delete item.children;
                                dataChanged = true
                            }
                        }, [], true);
                        dataChanged && this._update()
                    },
                    expandAll: function(id) {
                        var field = this.field(id);
                        if (field && field.area) {
                            field.expanded = true;
                            this.load()
                        }
                    },
                    expandHeaderItem: function(area, path) {
                        var that = this,
                            hasCache,
                            headerItems = area === 'column' ? that._loadedData.columns : that._loadedData.rows,
                            headerItem = findHeaderItem(headerItems, path),
                            options;
                        if (headerItem && !headerItem.children) {
                            hasCache = !!headerItem.collapsedChildren;
                            options = {
                                area: area,
                                path: path,
                                expanded: true,
                                needExpandData: !hasCache
                            };
                            that.fireEvent("expandValueChanging", [options]);
                            if (hasCache) {
                                headerItem.children = headerItem.collapsedChildren;
                                delete headerItem.collapsedChildren;
                                that._update()
                            }
                            else
                                that.load(options);
                            return hasCache
                        }
                        return false
                    },
                    applyPartialDataSource: function(area, path, dataSource, deferred) {
                        var that = this,
                            loadedData = that._loadedData,
                            headerItems = area === 'column' ? loadedData.columns : loadedData.rows,
                            headerItem,
                            newRowItemIndexesToCurrent,
                            newColumnItemIndexesToCurrent;
                        if (dataSource && dataSource.values) {
                            dataSource.rows = dataSource.rows || [];
                            dataSource.columns = dataSource.columns || [];
                            headerItem = findHeaderItem(headerItems, path);
                            if (headerItem) {
                                if (area === 'column') {
                                    newColumnItemIndexesToCurrent = updateHeaderItemChildren(headerItems, headerItem, dataSource.columns, loadedData.grandTotalColumnIndex);
                                    newRowItemIndexesToCurrent = updateHeaderItems(loadedData.rows, dataSource.rows)
                                }
                                else {
                                    newRowItemIndexesToCurrent = updateHeaderItemChildren(headerItems, headerItem, dataSource.rows, loadedData.grandTotalRowIndex);
                                    newColumnItemIndexesToCurrent = updateHeaderItems(loadedData.columns, dataSource.columns)
                                }
                                updateDataSourceCells(loadedData, dataSource.values, newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent);
                                that._update(deferred)
                            }
                        }
                    },
                    dispose: function() {
                        var that = this,
                            delayedLoadTask = that._delayedLoadTask;
                        this._disposeEvents();
                        if (delayedLoadTask)
                            delayedLoadTask.abort();
                        this._isDisposed = true
                    },
                    isDisposed: function() {
                        return !!this._isDisposed
                    }
                }
        }()).include(DX.EventsMixin);
        pivotGrid.foreachTreeItems = foreachTreeItems;
        pivotGrid.foreachDataLevel = foreachDataLevel;
        pivotGrid.getCompareFunction = getCompareFunction;
        pivotGrid.findField = findField;
        pivotGrid.formatValue = formatValue
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.dataController.js */
    (function($, DX) {
        var pivotGrid = DX.ui.dxPivotGrid,
            utils = DX.utils;
        pivotGrid.proxyMethod = function(instance, methodName, defaultResult) {
            if (!instance[methodName])
                instance[methodName] = function() {
                    var dataSource = this._dataSource;
                    return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult
                }
        };
        pivotGrid.DataController = DX.Class.inherit(function() {
            var foreachTreeItems = pivotGrid.foreachTreeItems,
                formatValue = pivotGrid.formatValue;
            function getHeaderItemText(item, description, options) {
                var text = item.text;
                if (utils.isDefined(item.displayText))
                    text = item.displayText;
                else if (utils.isDefined(item.caption))
                    text = item.caption;
                else if (item.type === 'GT')
                    text = options.texts.grandTotal;
                if (item.isAdditionalTotal)
                    text = utils.stringFormat(options.texts.total || '', text);
                return text
            }
            var createHeaderInfo = function() {
                    var getHeaderItemsDepth = function(headerItems) {
                            var depth = 0;
                            foreachTreeItems(headerItems, function(item, path) {
                                depth = Math.max(depth, path.length)
                            }, []);
                            return depth
                        };
                    var createInfoItem = function(headerItem, breadth, isHorizontal) {
                            var infoItem = {
                                    type: headerItem.type,
                                    text: headerItem.text
                                };
                            if (headerItem.path)
                                infoItem.path = headerItem.path;
                            if (headerItem.width)
                                infoItem.width = headerItem.width;
                            if (headerItem.isLast)
                                infoItem.isLast = true;
                            if (headerItem.sorted)
                                infoItem.sorted = true;
                            if (headerItem.isMetric)
                                infoItem.dataIndex = headerItem.dataIndex;
                            if (utils.isDefined(headerItem.expanded))
                                infoItem.expanded = headerItem.expanded;
                            if (breadth > 1)
                                infoItem[isHorizontal ? 'colspan' : 'rowspan'] = breadth;
                            if (headerItem.depthSize && headerItem.depthSize > 1)
                                infoItem[isHorizontal ? 'rowspan' : 'colspan'] = headerItem.depthSize;
                            return infoItem
                        };
                    var addInfoItem = function(info, options) {
                            var itemInfo,
                                breadth = options.lastIndex - options.index || 1,
                                addInfoItemCore = function(info, infoItem, itemIndex, depthIndex, isHorizontal) {
                                    var index = isHorizontal ? depthIndex : itemIndex;
                                    while (!info[index])
                                        info.push([]);
                                    if (isHorizontal)
                                        info[index].push(infoItem);
                                    else
                                        info[index].unshift(infoItem)
                                };
                            itemInfo = createInfoItem(options.headerItem, breadth, options.isHorizontal);
                            addInfoItemCore(info, itemInfo, options.index, options.depth, options.isHorizontal);
                            if (!options.headerItem.children || options.headerItem.children.length === 0)
                                return options.lastIndex + 1;
                            return options.lastIndex
                        };
                    var getViewHeaderItems = function(headerItems, headerDescriptions, cellDescriptions, depthSize, options) {
                            var cellDescriptionsCount = cellDescriptions.length,
                                viewHeaderItems = $.extend(true, [], headerItems);
                            setHeaderItemsParameters(viewHeaderItems, headerDescriptions);
                            if (options.showTotals !== false)
                                addAdditionalTotalHeaderItems(viewHeaderItems);
                            if (options.showGrandTotals !== false)
                                viewHeaderItems.push({type: 'GT'});
                            foreachTreeItems(viewHeaderItems, function(item, path) {
                                if (!item.children || item.children.length === 0)
                                    item.depthSize = depthSize - path.length + 1
                            }, []);
                            if (cellDescriptionsCount > 1)
                                addMetricHeaderItems(viewHeaderItems, cellDescriptions);
                            foreachTreeItems(viewHeaderItems, function(item, path) {
                                var field = headerDescriptions[path.length - 1] || {};
                                item.text = getHeaderItemText(item, field, options);
                                if (item.type === 'D')
                                    item.width = field.width;
                                item.isLast = !item.children || !item.children.length;
                                if (item.isLast)
                                    $.each(options.sortBySummaryPaths, function(index, sortBySummaryPath) {
                                        var headerPath = path;
                                        if (!utils.isDefined(item.dataIndex)) {
                                            sortBySummaryPath = sortBySummaryPath.slice(0);
                                            sortBySummaryPath.pop()
                                        }
                                        if (item.type === "GT")
                                            headerPath = headerPath.slice(1);
                                        if (headerPath.join("/") === sortBySummaryPath.join("/")) {
                                            item.sorted = true;
                                            return false
                                        }
                                    })
                            }, []);
                            if (!viewHeaderItems.length)
                                viewHeaderItems.push({});
                            return viewHeaderItems
                        };
                    var setHeaderItemsParameters = function(viewHeaderItems, headerDescriptions) {
                            var headerDescriptionsCount = headerDescriptions && headerDescriptions.length || 0;
                            foreachTreeItems(viewHeaderItems, function(item) {
                                item.type = 'D'
                            });
                            foreachTreeItems(viewHeaderItems, function(item, path) {
                                item.path = path.slice(0);
                                if (path.length < headerDescriptionsCount && (!item.children || item.children.length !== 0))
                                    item.expanded = !!item.children
                            }, [])
                        };
                    var addMetricHeaderItems = function(headerItems, cellDescriptions) {
                            foreachTreeItems(headerItems, function(item) {
                                var i;
                                if (!item.children || item.children.length === 0) {
                                    item.children = [];
                                    for (i = 0; i < cellDescriptions.length; i++)
                                        item.children.push({
                                            caption: cellDescriptions[i].caption,
                                            path: item.path,
                                            type: item.type,
                                            value: i,
                                            dataIndex: i,
                                            isMetric: true
                                        })
                                }
                            })
                        };
                    var addAdditionalTotalHeaderItems = function(headerItems) {
                            foreachTreeItems(headerItems, function(item, path, index, items) {
                                if (item.type === 'D' && item.expanded)
                                    items.splice(index + 1, 0, $.extend(true, {}, item, {
                                        children: null,
                                        type: 'T',
                                        expanded: null,
                                        isAdditionalTotal: true
                                    }))
                            }, [])
                        };
                    var fillHeaderInfo = function(info, viewHeaderItems, depthSize, isHorizontal) {
                            var lastIndex = 0,
                                index,
                                depth,
                                indexesByDepth = [0];
                            foreachTreeItems(viewHeaderItems, function(headerItem, path) {
                                depth = headerItem.isMetric ? depthSize : path.length - 1;
                                while (indexesByDepth.length - 1 < depth)
                                    indexesByDepth.push(indexesByDepth[indexesByDepth.length - 1]);
                                index = indexesByDepth[depth] || 0;
                                lastIndex = addInfoItem(info, {
                                    headerItem: headerItem,
                                    index: index,
                                    lastIndex: lastIndex,
                                    depth: depth,
                                    isHorizontal: isHorizontal
                                });
                                indexesByDepth.length = depth;
                                indexesByDepth.push(lastIndex)
                            }, [])
                        };
                    return function(headerItems, headerDescriptions, cellDescriptions, isHorizontal, options) {
                            var info = [],
                                viewHeaderItems,
                                depthSize = getHeaderItemsDepth(headerItems) || 1;
                            viewHeaderItems = getViewHeaderItems(headerItems, headerDescriptions, cellDescriptions, depthSize, options);
                            fillHeaderInfo(info, viewHeaderItems, depthSize, isHorizontal);
                            return info
                        }
                }();
            var createCellsInfo = function(dataSource, cellDescriptions, rowIndexedItems, columnIndexedItems) {
                    var rowIndex,
                        columnIndex,
                        valueIndex,
                        cells,
                        rowInfo,
                        dataSourceCells = dataSource.values,
                        cellDescriptionsCount = cellDescriptions ? cellDescriptions.length : 0,
                        cellValues,
                        cellInfo,
                        columnItem,
                        rowItem,
                        getHeaderItemType = function(headerItem) {
                            if (!headerItem)
                                return 'GT';
                            if (headerItem.children && headerItem.children.length > 0)
                                return 'T';
                            return 'D'
                        },
                        columnCount = 0,
                        info = [];
                    if (dataSourceCells && cellDescriptionsCount > 0) {
                        for (rowIndex = 0; rowIndex < dataSourceCells.length; rowIndex++)
                            columnCount = Math.max(columnCount, dataSourceCells[rowIndex].length);
                        for (rowIndex = 0; rowIndex < dataSourceCells.length; rowIndex++) {
                            rowItem = rowIndexedItems[rowIndex];
                            if (!rowItem && rowIndex !== dataSource.grandTotalRowIndex)
                                continue;
                            cells = dataSourceCells[rowIndex];
                            rowInfo = [];
                            for (columnIndex = 0; columnIndex < columnCount; columnIndex++) {
                                columnItem = columnIndexedItems[columnIndex];
                                if (!columnItem && columnIndex !== dataSource.grandTotalColumnIndex)
                                    continue;
                                cellValues = cells[columnIndex];
                                if (!$.isArray(cellValues))
                                    cellValues = [cellValues];
                                for (valueIndex = 0; valueIndex < cellDescriptionsCount; valueIndex++) {
                                    cellInfo = {
                                        text: formatValue(cellValues[valueIndex], cellDescriptions[valueIndex]),
                                        columnType: getHeaderItemType(columnItem),
                                        rowType: getHeaderItemType(rowItem),
                                        rowPath: rowItem && rowItem.path,
                                        columnPath: columnItem && columnItem.path,
                                        dataIndex: valueIndex
                                    };
                                    if (cellDescriptions[valueIndex].width)
                                        cellInfo.width = cellDescriptions[valueIndex].width;
                                    if (columnItem)
                                        rowInfo[columnItem.visibleIndex * cellDescriptionsCount + valueIndex] = cellInfo;
                                    else if (columnIndexedItems.grandTotalVisibleIndex >= 0)
                                        rowInfo[columnIndexedItems.grandTotalVisibleIndex * cellDescriptionsCount + valueIndex] = cellInfo
                                }
                            }
                            if (rowItem)
                                info[rowItem.visibleIndex] = rowInfo;
                            else if (rowIndexedItems.grandTotalVisibleIndex >= 0)
                                info[rowIndexedItems.grandTotalVisibleIndex] = rowInfo
                        }
                    }
                    return info
                };
            var getHeaderIndexedItems = function(headerItems, maxDepth, options) {
                    var visibleIndex = 0,
                        indexedItems = [];
                    foreachTreeItems(headerItems, function(headerItem, path) {
                        if (headerItem.children && options.showTotals === false)
                            return;
                        var indexedItem = $.extend(true, {}, headerItem, {
                                visibleIndex: visibleIndex++,
                                path: path
                            });
                        if (utils.isDefined(indexedItem.index))
                            indexedItems[indexedItem.index] = indexedItem;
                        else
                            indexedItems.push(indexedItem)
                    }, []);
                    if (options.showGrandTotals !== false)
                        indexedItems.grandTotalVisibleIndex = visibleIndex;
                    return indexedItems
                };
            var members = {
                    ctor: function(options) {
                        var that = this;
                        that._options = options || {};
                        that._dataSource = that._createDataSource(options);
                        that._columnsInfo = [];
                        that._rowsInfo = [];
                        that._cellsInfo = [];
                        that.expandValueChanging = $.Callbacks();
                        that.loadingChanged = $.Callbacks();
                        that._dataSource.load();
                        that._update();
                        that.changed = $.Callbacks()
                    },
                    _handleChanged: function() {
                        this._update()
                    },
                    _handleExpandValueChanging: function(e) {
                        this.expandValueChanging.fire(e)
                    },
                    _handleLoadingChanged: function(e) {
                        this.loadingChanged.fire(e)
                    },
                    _handleFieldsPrepared: function(e) {
                        this._options.onFieldsPrepared && this._options.onFieldsPrepared(e)
                    },
                    _createDataSource: function(options) {
                        var that = this,
                            dataSourceOptions = options.dataSource,
                            dataSource;
                        that._isSharedDataSource = dataSourceOptions instanceof pivotGrid.DataSource;
                        if (that._isSharedDataSource)
                            dataSource = dataSourceOptions;
                        else
                            dataSource = new pivotGrid.DataSource(dataSourceOptions);
                        that._changedHandler = $.proxy(that, "_handleChanged");
                        that._expandValueChangingHandler = $.proxy(that, "_handleExpandValueChanging");
                        that._loadingChangedHandler = $.proxy(that, "_handleLoadingChanged");
                        that._fieldsPreparedHandler = $.proxy(that, "_handleFieldsPrepared");
                        dataSource.on("changed", that._changedHandler);
                        dataSource.on("expandValueChanging", that._expandValueChangingHandler);
                        dataSource.on("loadingChanged", that._loadingChangedHandler);
                        dataSource.on("fieldsPrepared", that._fieldsPreparedHandler);
                        return dataSource
                    },
                    getDataSource: function() {
                        return this._dataSource
                    },
                    isLoading: function() {
                        return this._dataSource.isLoading()
                    },
                    isEmpty: function() {
                        var dataFields = this._dataSource.getAreaFields("data"),
                            data = this._dataSource.getData();
                        return !dataFields.length || !data.values.length
                    },
                    _update: function() {
                        var columnFields = this._dataSource.getAreaFields("column"),
                            rowFields = this._dataSource.getAreaFields("row"),
                            dataFields = this._dataSource.getAreaFields("data"),
                            dataSource = this._dataSource.getData();
                        var createSortPaths = function(headerFields, dataFields) {
                                var sortBySummaryPaths = [];
                                $.each(headerFields, function(index, headerField) {
                                    var fieldIndex = pivotGrid.findField(dataFields, headerField.sortBySummaryField);
                                    if (fieldIndex >= 0)
                                        sortBySummaryPaths.push((headerField.sortBySummaryPath || []).concat([fieldIndex]))
                                });
                                return sortBySummaryPaths
                            };
                        var rowOptions = {
                                texts: this._options.texts || {},
                                showTotals: this._options.showRowTotals,
                                showGrandTotals: this._options.showRowGrandTotals,
                                sortBySummaryPaths: createSortPaths(columnFields, dataFields)
                            };
                        var columnOptions = {
                                texts: this._options.texts || {},
                                showTotals: this._options.showColumnTotals,
                                showGrandTotals: this._options.showColumnGrandTotals,
                                sortBySummaryPaths: createSortPaths(rowFields, dataFields)
                            };
                        var rowIndexedItems = getHeaderIndexedItems(dataSource.rows, rowFields.length - 1, rowOptions),
                            columnIndexedItems = getHeaderIndexedItems(dataSource.columns, columnFields.length - 1, columnOptions);
                        if (!utils.isDefined(dataSource.grandTotalRowIndex))
                            dataSource.grandTotalRowIndex = rowIndexedItems.length;
                        if (!utils.isDefined(dataSource.grandTotalColumnIndex))
                            dataSource.grandTotalColumnIndex = columnIndexedItems.length;
                        this._columnsInfo = createHeaderInfo(dataSource.columns, columnFields, dataFields, true, columnOptions);
                        this._rowsInfo = createHeaderInfo(dataSource.rows, rowFields, [], false, rowOptions);
                        this._cellsInfo = createCellsInfo(dataSource, dataFields, rowIndexedItems, columnIndexedItems);
                        this.changed && this.changed.fire()
                    },
                    getHeaderItemPath: function(area, visibleIndex) {
                        var that = this,
                            index = 0,
                            result,
                            data = that._dataSource.getData(),
                            dataFields = that._dataSource.getAreaFields("data"),
                            headerItems = area === 'column' ? data.columns : data.rows;
                        if (area === 'column' && dataFields.length > 1)
                            visibleIndex = Math.floor(visibleIndex / dataFields.length);
                        foreachTreeItems(headerItems, function(item, path) {
                            if (index === visibleIndex) {
                                result = path;
                                return false
                            }
                            index++
                        }, []);
                        return result
                    },
                    getRowsInfo: function() {
                        return this._rowsInfo
                    },
                    getColumnsInfo: function() {
                        return this._columnsInfo
                    },
                    getCellsInfo: function() {
                        return this._cellsInfo
                    },
                    dispose: function() {
                        var that = this;
                        if (that._isSharedDataSource) {
                            that._dataSource.off("changed", that._changedHandler);
                            that._dataSource.off("expandValueChanging", that._expandValueChangingHandler);
                            that._dataSource.off("loadingChanged", that._loadingChangedHandler)
                        }
                        else
                            that._dataSource.dispose();
                        that.expandValueChanging.empty();
                        that.changed.empty();
                        that.loadingChanged.empty()
                    }
                };
            pivotGrid.proxyMethod(members, "load");
            pivotGrid.proxyMethod(members, "applyPartialDataSource");
            pivotGrid.proxyMethod(members, "collapseHeaderItem");
            pivotGrid.proxyMethod(members, "expandHeaderItem");
            pivotGrid.proxyMethod(members, "getData");
            return members
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.store.xmla.js */
    (function($, DX) {
        DX.data.XmlaStore = DX.ui.dxPivotGrid.XmlaStore = DX.Class.inherit(function() {
            var discover = '<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"><Body><Discover xmlns="urn:schemas-microsoft-com:xml-analysis"><RequestType>{2}</RequestType><Restrictions><RestrictionList><CATALOG_NAME>{0}</CATALOG_NAME><CUBE_NAME>{1}</CUBE_NAME></RestrictionList></Restrictions><Properties><PropertyList><Catalog>{0}</Catalog></PropertyList></Properties></Discover></Body></Envelope>',
                execute = '<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"><Body><Execute xmlns="urn:schemas-microsoft-com:xml-analysis"><Command><Statement>{0}</Statement></Command><Properties><PropertyList><Catalog>{1}</Catalog><ShowHiddenCubes>True</ShowHiddenCubes><SspropInitAppName>Microsoft SQL Server Management Studio</SspropInitAppName><Timeout>3600</Timeout></PropertyList></Properties></Execute></Body></Envelope>',
                mdx = "SELECT {2} FROM {0} {1} CELL PROPERTIES VALUE, FORMAT_STRING, LANGUAGE, BACK_COLOR, FORE_COLOR, FONT_FLAGS",
                mdxFilterSelect = "(SELECT {0} FROM {1})",
                mdxWith = " set [{0}] as {1}",
                orderMdx = "ORDER({0}, {1}, {2})",
                mdxSlice = "WHERE ({0})",
                mdxNonEmpty = "NonEmpty({0}, {1})",
                mdxHierarchize = "Hierarchize({{0}})",
                mdxAxis = "{0} DIMENSION PROPERTIES PARENT_UNIQUE_NAME,HIERARCHY_UNIQUE_NAME ON {1}",
                mdxCrossJoin = "CrossJoin({0})",
                mdxGenerate = "Generate({{0}}, ({1}, {2}))",
                mdxSet = "{{0}}",
                utils = DX.utils,
                stringFormat = utils.stringFormat,
                sortOrderDictionary = {
                    asc: "asc",
                    desc: "desc"
                },
                sortByDictionary = {
                    displaytext: ".member_caption",
                    value: ".member_value"
                },
                MEASURE_DEMENSION_KEY = "DX_MEASURES",
                MD_DIMTYPE_MEASURE = "2";
            DX.ui.dxPivotGrid.sendRequest = function(options) {
                return $.ajax(options)
            };
            function execXMLA(requestOptions, data) {
                var deferred = $.Deferred(),
                    beforeSend = requestOptions.beforeSend,
                    ajaxSettings = {
                        url: requestOptions.url,
                        dataType: "text",
                        data: data,
                        headers: {'Content-Type': 'text/xml'},
                        xhrFields: {},
                        method: "POST"
                    };
                if (utils.isFunction(beforeSend))
                    beforeSend(ajaxSettings);
                DX.ui.dxPivotGrid.sendRequest(ajaxSettings).fail(function() {
                    deferred.reject(arguments)
                }).done(function(text) {
                    var xml;
                    try {
                        xml = $.parseXML(text)
                    }
                    catch(e) {
                        deferred.reject({
                            statusText: e.message,
                            stack: e.stack,
                            responseText: text
                        })
                    }
                    deferred.resolve(xml)
                });
                return deferred
            }
            function mdxDescendants(level, levelMember, nextLevel) {
                levelMember = levelMember ? ".[" + levelMember + "]" : "";
                return "Descendants({" + level + levelMember + "}, " + nextLevel + ", SELF_AND_BEFORE)"
            }
            function getAllMember(dimention) {
                return (dimention.hierarchyName || dimention.dataField) + ".[All]"
            }
            function getAllMembers(field) {
                return field.dataField + ".allMembers"
            }
            function getCurrentMember(field) {
                return (field.hierarchyName || field.dataField) + ".currentMember"
            }
            function crossJoinElements(elements) {
                var elementsString = elements.join(",");
                return elements.length > 1 ? stringFormat(mdxCrossJoin, elementsString) : elementsString
            }
            function orderField(field, orderArg, options, axisName, withArray) {
                var sortOrder = sortOrderDictionary[field.sortOrder];
                if (sortOrder || sortByDictionary[(field.sortBy + "").toLowerCase()])
                    return stringFormat(orderMdx, orderArg, getOrderValue(field, options, axisName, orderArg, withArray), sortOrder || "asc");
                else
                    return orderArg
            }
            function generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName, withArray) {
                var crossJoinArgs = [],
                    dimensions = options[axisName],
                    dataField,
                    allMember,
                    fields = [],
                    hierarchyName,
                    arg,
                    prevDimension,
                    prevHierarchyName,
                    isLastDimesionInGroup,
                    isFirstDimesionInGroup,
                    expandAllIndex,
                    field,
                    member,
                    useGenerate,
                    i;
                for (i = expandIndex; i <= expandLevel; i++) {
                    field = dimensions[i];
                    dataField = field.dataField;
                    prevHierarchyName = dimensions[i - 1] && dimensions[i - 1].hierarchyName;
                    hierarchyName = field.hierarchyName;
                    isLastDimesionInGroup = !hierarchyName || !dimensions[i + 1] || dimensions[i + 1].hierarchyName !== hierarchyName;
                    expandAllIndex = path.length + expandAllCount + expandIndex;
                    arg = null;
                    useGenerate = false;
                    fields.push(field);
                    if (i < path.length) {
                        if (isLastDimesionInGroup)
                            arg = "(" + dataField + ".[" + path[i] + "])"
                    }
                    else if (i <= expandAllIndex)
                        if (i === 0 && expandAllCount === 0) {
                            allMember = getAllMember(dimensions[expandIndex]);
                            if (!hierarchyName)
                                arg = getAllMembers(dimensions[expandIndex]);
                            else
                                arg = allMember + "," + dimensions[expandIndex].dataField
                        }
                        else if (hierarchyName) {
                            member = slicePath[slicePath.length - 1];
                            if (isLastDimesionInGroup || i === expandAllIndex)
                                if (prevHierarchyName === hierarchyName) {
                                    if (slicePath.length)
                                        prevDimension = dimensions[slicePath.length - 1];
                                    if (!prevDimension || prevDimension.hierarchyName !== hierarchyName) {
                                        prevDimension = dimensions[i - 1];
                                        member = ""
                                    }
                                    arg = mdxDescendants(prevDimension.dataField, member, dataField)
                                }
                                else
                                    arg = getAllMembers(field)
                        }
                        else {
                            arg = getAllMembers(field);
                            if (field.sortBySummaryField && crossJoinArgs.length && i === expandAllIndex)
                                useGenerate = true
                        }
                    else {
                        isFirstDimesionInGroup = !hierarchyName || prevHierarchyName !== hierarchyName;
                        if (isFirstDimesionInGroup)
                            arg = "(" + getAllMember(field) + ")"
                    }
                    if (arg) {
                        arg = stringFormat(mdxSet, arg);
                        arg = orderField(field, arg, options, axisName, withArray);
                        if (useGenerate)
                            arg = stringFormat(mdxGenerate, crossJoinArgs.pop(), getCurrentMember(dimensions[i - 1]), arg);
                        crossJoinArgs.push(arg)
                    }
                }
                return crossJoinElements(crossJoinArgs)
            }
            function fillCrossJoins(crossJoins, path, expandLevel, expandIndex, slicePath, options, axisName, withArray) {
                var expandAllCount = -1,
                    dimensions = options[axisName],
                    dimestionIndex;
                do {
                    expandAllCount++;
                    dimestionIndex = path.length + expandAllCount + expandIndex;
                    crossJoins.push(generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName, withArray))
                } while (dimensions[dimestionIndex] && dimensions[dimestionIndex + 1] && dimensions[dimestionIndex].expanded)
            }
            function declareSet(set, withArray, name) {
                name = name || "DX_Set_" + withArray.length;
                withArray.push(stringFormat(mdxWith, name, set));
                return "[" + name + "]"
            }
            function getRank(field, orderArg, withArray) {
                var set;
                if (field.hierarchyName)
                    set = declareSet(stringFormat(mdxHierarchize, orderArg), withArray);
                else
                    set = getAllMembers(field);
                return "rank(" + getCurrentMember(field) + "," + set + ")"
            }
            function getOrderValueForSummary(field, options, axisName) {
                var sortByFields = (axisName === "columns" ? options.rows : options.columns) || [],
                    dataFields = options.values || [],
                    sortBySummaryFieldIndex = DX.ui.dxPivotGrid.findField(dataFields, field.sortBySummaryField),
                    tupleElements = dataFields[sortBySummaryFieldIndex] ? [dataFields[sortBySummaryFieldIndex].dataField] : [],
                    orderPath = field.sortBySummaryPath || [],
                    prevElementHierarchyName;
                $.each(orderPath, function(index, path) {
                    var sortByField = sortByFields[index];
                    if (sortByField)
                        if (sortByField.hierarchyName && sortByField.hierarchyName === prevElementHierarchyName)
                            tupleElements[tupleElements.length - 1] = (sortByField.hierarchyName || sortByField.dataField) + ".[" + path + "]";
                        else {
                            tupleElements.push((sortByField.hierarchyName || sortByField.dataField) + ".[" + path + "]");
                            prevElementHierarchyName = sortByField.hierarchyName
                        }
                });
                return tupleElements.join(",")
            }
            function getOrderValue(field, options, axisName, orderArg, withArray) {
                var orderProperty = sortByDictionary[(field.sortBy + "").toLowerCase()];
                if (field.sortBySummaryField)
                    return "(" + getOrderValueForSummary(field, options, axisName) + ")";
                else if (orderProperty)
                    return getCurrentMember(field) + orderProperty;
                else
                    return getRank(field, orderArg, withArray)
            }
            function generateAxisMdx(options, axisName, cells, withArray, parseOptions) {
                var dimensions = options[axisName],
                    crossJoins = [],
                    path = [],
                    expandedPaths = [],
                    expandIndex = 0,
                    expandLevel = 0,
                    result = [],
                    cellsString = stringFormat(mdxSet, cells.join(","));
                if (dimensions && dimensions.length) {
                    if (options.headerName === axisName) {
                        path = options.path;
                        expandLevel = expandIndex = path.length
                    }
                    else {
                        expandedPaths = (axisName === "columns" ? options.columnExpandedPaths : options.rowExpandedPaths) || expandedPaths;
                        $.each(expandedPaths, function(_, path) {
                            expandLevel = Math.max(expandLevel, path.length)
                        })
                    }
                    while (dimensions[expandLevel + 1] && dimensions[expandLevel].expanded)
                        expandLevel++;
                    fillCrossJoins(crossJoins, [], expandLevel, expandIndex, path, options, axisName, withArray);
                    $.each(expandedPaths, function(_, expandedPath) {
                        fillCrossJoins(crossJoins, expandedPath, expandLevel, expandIndex, expandedPath, options, axisName, withArray)
                    });
                    for (var i = expandLevel; i >= path.length; i--)
                        if (dimensions[i].hierarchyName) {
                            parseOptions.visibleLevels[dimensions[i].hierarchyName] = parseOptions.visibleLevels[dimensions[i].hierarchyName] || [];
                            parseOptions.visibleLevels[dimensions[i].hierarchyName].push(dimensions[i].dataField)
                        }
                }
                crossJoins.length && result.push(stringFormat(mdxNonEmpty, declareSet(stringFormat(mdxSet, crossJoins.join(",")), withArray, axisName), cellsString));
                if (axisName === "columns" && cells.length)
                    result.push(cellsString);
                return stringFormat(mdxAxis, crossJoinElements(result), axisName)
            }
            function generateAxisFieldsFilter(fields) {
                var filterMembers = [];
                $.each(fields, function(_, field) {
                    var dataField = field.dataField,
                        filterExpression = [],
                        filterValues = field.filterValues || [],
                        filterStringExpression;
                    if (field.hierarchyName && utils.isNumber(field.groupIndex))
                        return;
                    $.each(filterValues, function(_, filterValue) {
                        var filterMdx = dataField + ".[" + (utils.isArray(filterValue) ? filterValue[filterValue.length - 1] : filterValue) + "]";
                        if (field.filterType === "exclude") {
                            filterExpression.push(filterMdx + ".parent");
                            filterMdx = "Descendants(" + filterMdx + ")"
                        }
                        filterExpression.push(filterMdx)
                    });
                    if (filterValues.length) {
                        filterStringExpression = stringFormat(mdxSet, filterExpression.join(","));
                        if (field.filterType === "exclude")
                            filterStringExpression = "Except(" + getAllMembers(field) + "," + filterStringExpression + ")";
                        filterMembers.push(filterStringExpression)
                    }
                });
                return filterMembers.length ? crossJoinElements(filterMembers) : ""
            }
            function generateFrom(columnsFilter, rowsFilter, filter, cubeName) {
                var from = "[" + cubeName + "]";
                $.each([columnsFilter, rowsFilter, filter], function(_, filter) {
                    if (filter)
                        from = stringFormat(mdxFilterSelect, filter + "on 0", from)
                });
                return from
            }
            function generateMDX(options, cubeName, parseOptions) {
                var columns = options.columns || [],
                    rows = options.rows || [],
                    values = options.values && options.values.length ? options.values : [{dataField: '[Measures]'}],
                    slice = [],
                    withArray = [],
                    axisStrings = [],
                    dataFields = $.map(values, function(cell) {
                        return cell.dataField
                    });
                parseOptions.measureCount = values.length;
                parseOptions.visibleLevels = {};
                if (options.headerName && options.path)
                    $.each(options.path, function(index, value) {
                        var dimention = options[options.headerName][index];
                        if (!dimention.hierarchyName || dimention.hierarchyName !== options[options.headerName][index + 1].hierarchyName)
                            slice.push(dimention.dataField + ".[" + value + "]")
                    });
                if (columns.length || dataFields.length)
                    axisStrings.push(generateAxisMdx(options, "columns", dataFields, withArray, parseOptions));
                if (rows.length)
                    axisStrings.push(generateAxisMdx(options, "rows", dataFields, withArray, parseOptions));
                if (!axisStrings.length)
                    return "";
                var withString = (withArray.length ? "with" + withArray.join(" ") : "") + " ";
                return withString + stringFormat(mdx, generateFrom(generateAxisFieldsFilter(columns), generateAxisFieldsFilter(rows), generateAxisFieldsFilter(options.filters || []), cubeName), slice.length ? stringFormat(mdxSlice, slice.join(",")) : "", axisStrings.join(","))
            }
            function getNumber(str) {
                return parseInt(str, 10)
            }
            function parseAxes(xml) {
                var axes = [];
                $.each($(xml).find("Axis"), function(_, axisElement) {
                    var $axis = $(axisElement),
                        name = axisElement.getAttribute("name"),
                        axis = [],
                        index = 0;
                    if (name.indexOf("Axis") === 0 && utils.isNumber(getNumber(name.substr(4)))) {
                        axes.push(axis);
                        $.each($axis.children("Tuples").children(), function(_, tupleElement) {
                            var tupleMembers = $(tupleElement).children(),
                                $tuple,
                                levelSum = 0,
                                members = [],
                                level,
                                membersCount = tupleMembers.length - 1,
                                isAxisWithMeasure = axes.length === 1,
                                i;
                            if (isAxisWithMeasure)
                                membersCount--;
                            axis.push(members);
                            for (i = membersCount; i >= 0; i--) {
                                $tuple = $(tupleMembers[i]);
                                level = getNumber($tuple.children("LNum").text());
                                members[i] = {
                                    caption: $tuple.children("Caption").text(),
                                    level: level,
                                    index: index++,
                                    hasValue: !levelSum && (!!level || i === 0),
                                    name: $tuple.children("UName").text(),
                                    parentName: $tuple.children("PARENT_UNIQUE_NAME").text(),
                                    levelName: $tuple.children("LName").text(),
                                    hierarchyName: tupleMembers[i].getAttribute("Hierarchy")
                                };
                                levelSum += level
                            }
                        })
                    }
                });
                while (axes.length < 2)
                    axes.push([[{level: 0}]]);
                return axes
            }
            function parseCells(xml, axes, measureCount) {
                var cells = [],
                    cell = [],
                    index = 0,
                    measureIndex,
                    cellsOriginal = [],
                    row;
                $.each($(xml).find("CellData > Cell"), function(_, xmlCell) {
                    var $cell = $(xmlCell),
                        value = parseFloat($cell.children("Value").text());
                    cellsOriginal[getNumber(xmlCell.getAttribute("CellOrdinal"))] = {value: isNaN(value) ? null : value}
                });
                $.each(axes[1], function() {
                    row = [];
                    cells.push(row);
                    $.each(axes[0], function() {
                        measureIndex = index % measureCount;
                        if (measureIndex === 0) {
                            cell = [];
                            row.push(cell)
                        }
                        cell.push(cellsOriginal[index] ? cellsOriginal[index].value : null);
                        index++
                    })
                });
                return cells
            }
            function getItem(hash, name, member, index) {
                var item = hash[name];
                if (!item) {
                    item = {};
                    hash[name] = item
                }
                if (!item.value && member) {
                    item.value = member.caption;
                    item.levelName = member.levelName;
                    item.hierarchyName = member.hierarchyName;
                    item.parentName = member.parentName;
                    item.index = index;
                    item.level = member.level
                }
                return item
            }
            function getVisibleChildren(item, visibleLevels) {
                var result = [],
                    children = item.children && (item.children.length ? item.children : $.map(item.children.grandTotalHash || [], function(e) {
                        return e.children
                    })),
                    firstChild = children && children[0];
                if (firstChild && (visibleLevels[firstChild.hierarchyName] && $.inArray(firstChild.levelName, visibleLevels[firstChild.hierarchyName]) !== -1 || !visibleLevels[firstChild.hierarchyName] || firstChild.level === 0)) {
                    var newChildren = $.map(children, function(child) {
                            return child.hierarchyName === firstChild.hierarchyName ? child : null
                        });
                    newChildren.grandTotalHash = children.grandTotalHash;
                    return newChildren
                }
                else if (firstChild)
                    for (var i = 0; i < children.length; i++)
                        if (children[i].hierarchyName === firstChild.hierarchyName)
                            result.push.apply(result, getVisibleChildren(children[i], visibleLevels));
                return result
            }
            function processMember(dataIndex, member, parentItem) {
                var currentItem,
                    children = parentItem.children = parentItem.children || [],
                    hash = children.hash = children.hash || {},
                    grandTotalHash = children.grandTotalHash = children.grandTotalHash || {};
                if (member.parentName) {
                    parentItem = getItem(hash, member.parentName);
                    children = parentItem.children = parentItem.children || []
                }
                currentItem = getItem(hash, member.name, member, dataIndex);
                if (member.hasValue && !currentItem.added) {
                    currentItem.index = dataIndex;
                    currentItem.added = true;
                    children.push(currentItem)
                }
                if ((!parentItem.value || !parentItem.parentName) && member.parentName)
                    grandTotalHash[member.parentName] = parentItem;
                else if (grandTotalHash[parentItem.name])
                    delete grandTotalHash[member.parentName];
                return currentItem
            }
            function getGrandTotalIndex(parentItem, visibleLevels) {
                var grandTotalIndex;
                if (parentItem.children.length === 1 && parentItem.children[0].parentName === "") {
                    grandTotalIndex = parentItem.children[0].index;
                    var grandTotalHash = parentItem.children.grandTotalHash;
                    parentItem.children = parentItem.children[0].children;
                    parentItem.children.grandTotalHash = grandTotalHash;
                    parentItem.children = getVisibleChildren(parentItem, visibleLevels)
                }
                else if (parentItem.children.length === 0)
                    grandTotalIndex = 0;
                return grandTotalIndex
            }
            function fillDataSourceAxes(dataSourceAxis, axisTuples, measureCount, visibleLevels) {
                var grandTotalIndex,
                    result = [];
                $.each(axisTuples, function(tupleIndex, members) {
                    var parentItem = {children: result},
                        dataIndex = utils.isDefined(measureCount) ? Math.floor(tupleIndex / measureCount) : tupleIndex;
                    $.each(members, function(_, member) {
                        parentItem = processMember(dataIndex, member, parentItem)
                    })
                });
                var parentItem = {children: result};
                parentItem.children = getVisibleChildren(parentItem, visibleLevels);
                grandTotalIndex = getGrandTotalIndex(parentItem, visibleLevels);
                DX.ui.dxPivotGrid.foreachTreeItems(parentItem.children, function(item) {
                    var children = getVisibleChildren(item, visibleLevels);
                    if (children.length)
                        item.children = children;
                    else
                        delete item.children;
                    delete item.levelName;
                    delete item.hierarchyName;
                    delete item.added;
                    delete item.parentName;
                    delete item.level
                }, undefined, true);
                $.each(parentItem.children || [], function(_, e) {
                    dataSourceAxis.push(e)
                });
                return grandTotalIndex
            }
            function parseResult(xml, parseOptions) {
                var dataSource = {
                        columns: [],
                        rows: []
                    },
                    axes,
                    error = $(xml).find("Error"),
                    measureCount = parseOptions.measureCount;
                if (error.length) {
                    utils.logger.error(error.attr("Description"));
                    return null
                }
                axes = parseAxes(xml);
                dataSource.grandTotalColumnIndex = fillDataSourceAxes(dataSource.columns, axes[0], measureCount, parseOptions.visibleLevels);
                dataSource.grandTotalRowIndex = fillDataSourceAxes(dataSource.rows, axes[1], undefined, parseOptions.visibleLevels);
                dataSource.values = parseCells(xml, axes, measureCount);
                return dataSource
            }
            function parseDiscoverRowSet(xml, schema, dimensions) {
                var result = [],
                    isMeasure = schema === "MEASURE",
                    displayFolderField = isMeasure ? "MEASUREGROUP_NAME" : schema + "_DISPLAY_FOLDER";
                $.each($(xml).find("row"), function(_, row) {
                    var $row = $(row),
                        hierarchyName = schema === "LEVEL" ? $row.children("HIERARCHY_UNIQUE_NAME").text() : undefined,
                        levelNumber = $row.children("LEVEL_NUMBER").text();
                    if ((levelNumber !== "0" || $row.children(schema + "_IS_VISIBLE").text() !== "true") && $row.children("DIMENSION_TYPE").text() !== MD_DIMTYPE_MEASURE) {
                        var dimension = isMeasure ? MEASURE_DEMENSION_KEY : $row.children("DIMENSION_UNIQUE_NAME").text(),
                            dataField = $row.children(schema + "_UNIQUE_NAME").text();
                        result.push({
                            dimension: dimensions.names[dimension] || dimension,
                            groupIndex: levelNumber ? getNumber(levelNumber) - 1 : undefined,
                            dataField: dataField,
                            caption: $row.children(schema + "_CAPTION").text(),
                            hierarchyName: hierarchyName,
                            groupName: hierarchyName,
                            displayFolder: $row.children(displayFolderField).text(),
                            isMeasure: isMeasure,
                            isDefault: !!dimensions.defaultHierarhies[dataField]
                        })
                    }
                });
                return result
            }
            function parseDimensionsDiscoverRowSet(xml) {
                var result = {
                        names: {},
                        defaultHierarhies: {}
                    };
                $.each($(xml).find("row"), function() {
                    var $row = $(this),
                        type = $row.children("DIMENSION_TYPE").text(),
                        dimensionName = type === MD_DIMTYPE_MEASURE ? MEASURE_DEMENSION_KEY : $row.children("DIMENSION_UNIQUE_NAME").text();
                    result.names[dimensionName] = $row.children("DIMENSION_CAPTION").text();
                    result.defaultHierarhies[$row.children("DEFAULT_HIERARCHY").text()] = true
                });
                return result
            }
            return {
                    ctor: function(options) {
                        this._options = options
                    },
                    getFields: function() {
                        var options = this._options,
                            catalog = options.catalog,
                            cube = options.cube,
                            dimensionsRequest = execXMLA(options, stringFormat(discover, catalog, cube, "MDSCHEMA_DIMENSIONS")),
                            measuresRequest = execXMLA(options, stringFormat(discover, catalog, cube, "MDSCHEMA_MEASURES")),
                            hierarchiesRequest = execXMLA(options, stringFormat(discover, catalog, cube, "MDSCHEMA_HIERARCHIES")),
                            levelsRequest = execXMLA(options, stringFormat(discover, catalog, cube, "MDSCHEMA_LEVELS")),
                            result = $.Deferred();
                        $.when(dimensionsRequest, measuresRequest, hierarchiesRequest, levelsRequest).done(function(dimensionsResponse, measuresResponse, hierarhiesResponse, levelsResponse) {
                            var dimensions = parseDimensionsDiscoverRowSet(dimensionsResponse),
                                hierarchies = parseDiscoverRowSet(hierarhiesResponse, "HIERARCHY", dimensions),
                                levels = parseDiscoverRowSet(levelsResponse, "LEVEL", dimensions),
                                fields = parseDiscoverRowSet(measuresResponse, "MEASURE", dimensions).concat(hierarchies),
                                levelsByHierarchy = {};
                            $.each(levels, function(_, level) {
                                levelsByHierarchy[level.hierarchyName] = levelsByHierarchy[level.hierarchyName] || [];
                                levelsByHierarchy[level.hierarchyName].push(level)
                            });
                            $.each(hierarchies, function(_, hierarchy) {
                                if (levelsByHierarchy[hierarchy.dataField] && levelsByHierarchy[hierarchy.dataField].length > 1) {
                                    hierarchy.groupName = hierarchy.hierarchyName = hierarchy.dataField;
                                    fields.push.apply(fields, levelsByHierarchy[hierarchy.hierarchyName])
                                }
                            });
                            result.resolve(fields)
                        }).fail(result.reject);
                        return result
                    },
                    load: function(options) {
                        var result = $.Deferred(),
                            storeOptions = this._options,
                            data,
                            executeQuery,
                            parseOptions = {},
                            mdxString = generateMDX(options, storeOptions.cube, parseOptions);
                        if (mdxString) {
                            executeQuery = stringFormat(execute, mdxString, storeOptions.catalog);
                            $.when(execXMLA(storeOptions, executeQuery)).done(function(executeXml) {
                                data = parseResult(executeXml, parseOptions);
                                if (data)
                                    result.resolve(data);
                                else
                                    result.reject()
                            }).fail(result.reject)
                        }
                        else
                            result.resolve({
                                columns: [],
                                rows: [],
                                values: [],
                                grandTotalColumnIndex: 0,
                                grandTotalRowIndex: 0
                            });
                        return result
                    },
                    supportSorting: function() {
                        return true
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.store.local.js */
    (function($, DX) {
        var dataUtils = DX.data.utils,
            utils = DX.utils,
            pivotGrid = DX.ui.dxPivotGrid;
        pivotGrid.LocalStore = DevExpress.Class.inherit(function() {
            var DATE_INTERVAL_SELECTORS = {
                    year: function(date) {
                        return date && date.getFullYear()
                    },
                    quarter: function(date) {
                        return date && Math.floor(date.getMonth() / 3) + 1
                    },
                    month: function(date) {
                        return date && date.getMonth() + 1
                    },
                    day: function(date) {
                        return date && date.getDate()
                    },
                    dayOfWeek: function(date) {
                        return date && date.getDay()
                    }
                };
            var DATE_INTERVAL_FORMATS = {
                    month: {
                        format: 'month',
                        dateType: 'full'
                    },
                    quarter: {
                        format: 'quarter',
                        dateType: 'full'
                    },
                    dayOfWeek: {
                        format: 'dayOfWeek',
                        dateType: 'full'
                    }
                };
            function prepareFields(fields) {
                $.each(fields || [], function() {
                    var fieldSelector,
                        intervalSelector,
                        dataField = this.dataField,
                        groupInteval,
                        levels = this.levels;
                    if (!this.selector) {
                        if (!dataField)
                            fieldSelector = function(data) {
                                return data
                            };
                        else
                            fieldSelector = dataField.indexOf(".") !== -1 ? dataUtils.compileGetter(dataField) : function(data) {
                                return data[dataField]
                            };
                        if (levels) {
                            prepareFields(levels);
                            this.selector = function(data) {
                                var value = [];
                                $.each(levels, function(_, field) {
                                    value.push(field.selector(data))
                                });
                                return value
                            }
                        }
                        else if (this.dataType === 'date') {
                            intervalSelector = DATE_INTERVAL_SELECTORS[this.groupInterval];
                            this.selector = function(data) {
                                var value = fieldSelector(data);
                                if (value && !(value instanceof Date))
                                    value = new Date(value);
                                return intervalSelector ? intervalSelector(value) : value
                            };
                            this.format = this.format || DATE_INTERVAL_FORMATS[this.groupInterval]
                        }
                        else if (this.dataType === 'number') {
                            groupInteval = utils.isNumber(this.groupInterval) && this.groupInterval > 0 && this.groupInterval;
                            if (groupInteval)
                                this.customizeText = this.customizeText || function(formatObject) {
                                    var secondValue = formatObject.value + groupInteval,
                                        secondValueText = DX.formatHelper.format(secondValue, this.format, this.precision);
                                    return formatObject.valueText && secondValueText ? formatObject.valueText + " - " + secondValueText : ""
                                };
                            this.selector = function(data) {
                                var value = fieldSelector(data);
                                if (DX.utils.isString(value))
                                    value = Number(value);
                                return groupInteval ? Math.floor(value / groupInteval) * groupInteval : value
                            }
                        }
                        else
                            this.selector = fieldSelector
                    }
                })
            }
            var addHierarchyItem = function(value, hierarchyItems, pathHash, childrenHash) {
                    var hierarchyItem = childrenHash[pathHash];
                    if (!hierarchyItem) {
                        hierarchyItem = {
                            value: value,
                            index: childrenHash.length++
                        };
                        childrenHash[pathHash] = hierarchyItem;
                        hierarchyItems.push(hierarchyItem)
                    }
                    return hierarchyItem
                };
            function fillHierarchyItemIndexesCore(indexes, options, children, expandIndex, pathHash) {
                var dimension = options.dimensions[expandIndex],
                    expandedPathsHash = options.expandedPathsHash,
                    dimensionValue,
                    hierarchyItem;
                if (dimension) {
                    dimensionValue = dimension.selector(options.data);
                    pathHash = pathHash ? pathHash + "." + dimensionValue : dimensionValue;
                    hierarchyItem = addHierarchyItem(dimensionValue, children, pathHash, options.childrenHash);
                    indexes.push(hierarchyItem.index);
                    if (expandedPathsHash && expandedPathsHash[pathHash] || dimension.expanded) {
                        if (!hierarchyItem.children)
                            hierarchyItem.children = [];
                        fillHierarchyItemIndexesCore(indexes, options, hierarchyItem.children, expandIndex + 1, pathHash)
                    }
                }
            }
            function generateHierarchyItems(data, loadOptions, headers, headerName) {
                var result = [0],
                    expandIndex = loadOptions.headerName === headerName ? loadOptions.path.length : 0,
                    expandedPaths = headerName === "rows" ? loadOptions.rowExpandedPaths : loadOptions.columnExpandedPaths,
                    options = {
                        data: data,
                        childrenHash: headers[headerName + "Hash"],
                        dimensions: loadOptions[headerName],
                        expandedPathsHash: loadOptions.headerName !== headerName && expandedPaths && expandedPaths.hash
                    };
                fillHierarchyItemIndexesCore(result, options, headers[headerName], expandIndex);
                return result
            }
            function generateAggregationCells(data, cells, headers, options) {
                var cellSet = [],
                    x,
                    y,
                    rowIndex,
                    columnIndex;
                var rowIndexes = generateHierarchyItems(data, options, headers, "rows");
                var columnIndexes = generateHierarchyItems(data, options, headers, "columns");
                for (y = 0; y < rowIndexes.length; y++) {
                    rowIndex = rowIndexes[y];
                    cells[rowIndex] = cells[rowIndex] || [];
                    for (x = 0; x < columnIndexes.length; x++) {
                        columnIndex = columnIndexes[x];
                        cellSet.push(cells[rowIndex][columnIndex] = cells[rowIndex][columnIndex] || [])
                    }
                }
                return cellSet
            }
            function fillHashExpandedPath(expandedPaths) {
                if (expandedPaths) {
                    expandedPaths.hash = {};
                    $.each(expandedPaths, function() {
                        expandedPaths.hash[this.join(".")] = true
                    })
                }
            }
            function prepareLoadOption(options) {
                options.rows = options.rows || [];
                options.columns = options.columns || [];
                options.filters = options.filters || [];
                fillHashExpandedPath(options.columnExpandedPaths);
                fillHashExpandedPath(options.rowExpandedPaths);
                prepareFields(options.columns);
                prepareFields(options.rows);
                prepareFields(options.values);
                prepareFields(options.filters)
            }
            function getAggregator(field) {
                if (field.summaryType === "custom") {
                    field.calculateCustomSummary = field.calculateCustomSummary || $.noop;
                    return {
                            seed: function() {
                                var options = {
                                        summaryProcess: "start",
                                        totalValue: undefined
                                    };
                                field.calculateCustomSummary(options);
                                return options
                            },
                            step: function(options, value) {
                                options.summaryProcess = "calculate";
                                options.value = value;
                                field.calculateCustomSummary(options);
                                return options
                            },
                            finalize: function(options) {
                                options.summaryProcess = "finalize";
                                delete options.value;
                                field.calculateCustomSummary(options);
                                return options.totalValue
                            }
                        }
                }
                return dataUtils.aggregators[field.summaryType] || dataUtils.aggregators.count
            }
            function aggregationStep(measures, aggregationCells, data) {
                for (var aggregatorIndex = 0; aggregatorIndex < measures.length; aggregatorIndex++) {
                    var cellField = measures[aggregatorIndex];
                    var cellValue = cellField.selector(data);
                    var aggregator = getAggregator(cellField);
                    for (var cellSetIndex = 0; cellSetIndex < aggregationCells.length; cellSetIndex++) {
                        var cell = aggregationCells[cellSetIndex];
                        if (cell.length <= aggregatorIndex)
                            cell[aggregatorIndex] = utils.isFunction(aggregator.seed) ? aggregator.seed() : aggregator.seed;
                        if (cell[aggregatorIndex] === undefined)
                            cell[aggregatorIndex] = cellValue;
                        else if (utils.isDefined(cellValue))
                            cell[aggregatorIndex] = aggregator.step(cell[aggregatorIndex], cellValue)
                    }
                }
            }
            function aggregationFinalize(measures, cells) {
                $.each(measures, function(aggregatorIndex, cellField) {
                    var aggregator = getAggregator(cellField);
                    if (aggregator.finalize)
                        $.each(cells, function(_, row) {
                            $.each(row, function(_, cell) {
                                if (cell)
                                    cell[aggregatorIndex] = aggregator.finalize(cell[aggregatorIndex])
                            })
                        })
                })
            }
            function areValuesEqual(filterValue, fieldValue) {
                if (utils.isArray(filterValue)) {
                    fieldValue = fieldValue || [];
                    for (var i = 0; i < filterValue.length; i++)
                        if (filterValue[i] !== fieldValue[i])
                            return false;
                    return true
                }
                else
                    return filterValue === fieldValue
            }
            function createDimensionFilters(dimention) {
                var filters = [];
                $.each(dimention, function(_, field) {
                    var filterValues = field.filterValues || [],
                        groupName = field.groupName,
                        filter;
                    if (groupName && utils.isNumber(field.groupIndex))
                        return;
                    filter = function(dataItem) {
                        var value = field.selector(dataItem),
                            result = false;
                        for (var i = 0; i < filterValues.length; i++)
                            if (areValuesEqual(filterValues[i], value)) {
                                result = true;
                                break
                            }
                        return field.filterType === "exclude" ? !result : result
                    };
                    filterValues.length && filters.push(filter)
                });
                return filters
            }
            function createFilter(options) {
                var filters = createDimensionFilters(options.rows).concat(createDimensionFilters(options.columns)).concat(createDimensionFilters(options.filters)),
                    expandedDimensions = options[options.headerName],
                    path = options.path;
                if (expandedDimensions)
                    filters.push(function(dataItem) {
                        var expandValue;
                        for (var i = 0; i < path.length; i++) {
                            expandValue = expandedDimensions[i].selector(dataItem);
                            if (expandValue !== path[i])
                                return false
                        }
                        return true
                    });
                return function(dataItem) {
                        for (var i = 0; i < filters.length; i++)
                            if (!filters[i](dataItem))
                                return false;
                        return true
                    }
            }
            function loadCore(items, options) {
                var headers = {
                        columns: [],
                        rows: [],
                        columnsHash: {length: 1},
                        rowsHash: {length: 1}
                    },
                    values = [[[]]],
                    aggregationCells,
                    filter,
                    data,
                    i;
                prepareLoadOption(options);
                filter = createFilter(options);
                for (i = 0; i < items.length; i++) {
                    data = items[i];
                    if (filter(data)) {
                        aggregationCells = generateAggregationCells(data, values, headers, options);
                        aggregationStep(options.values, aggregationCells, data)
                    }
                }
                aggregationFinalize(options.values, values);
                return {
                        rows: headers.rows,
                        columns: headers.columns,
                        values: values,
                        grandTotalRowIndex: 0,
                        grandTotalColumnIndex: 0
                    }
            }
            function createGroupFields(item) {
                return $.map(["year", "quarter", "month"], function(value, index) {
                        return $.extend({}, item, {
                                groupInterval: value,
                                groupIndex: index
                            })
                    })
            }
            function parseFields(dataSource, fieldsList, path, fieldsDataType) {
                var result = [];
                $.each(fieldsList || [], function(field, value) {
                    var dataIndex = 1,
                        currentPath = path.length ? path + "." + field : field,
                        dataType = fieldsDataType[currentPath],
                        getter = dataUtils.compileGetter(currentPath),
                        items;
                    while (!utils.isDefined(value) && dataSource[dataIndex]) {
                        value = getter(dataSource[dataIndex]);
                        dataIndex++
                    }
                    if (!dataType && utils.isDefined(value))
                        dataType = $.type(value);
                    items = [{
                            dataField: currentPath,
                            dataType: dataType,
                            groupName: dataType === "date" ? field : undefined,
                            groupInterval: undefined,
                            displayFolder: path
                        }];
                    if (dataType === "date")
                        items = items.concat(createGroupFields(items[0]));
                    else if (dataType === "object")
                        items = parseFields(dataSource, value, currentPath, fieldsDataType);
                    result.push.apply(result, items)
                });
                return result
            }
            function discover(items, fieldsDataType) {
                fieldsDataType = fieldsDataType || {};
                return parseFields(items, items[0], "", fieldsDataType)
            }
            function loadDataSource(dataSource) {
                var d = $.Deferred();
                if (!dataSource.isLoaded())
                    $.when(dataSource.load()).always(function() {
                        loadDataSource(dataSource).done(d.resolve).fail(d.reject)
                    });
                else
                    d.resolve(dataSource.items());
                return d
            }
            return {
                    ctor: function(options) {
                        options = $.extend(dataUtils.normalizeDataSourceOptions(options), {
                            paginate: false,
                            onChanged: null
                        });
                        this._dataSource = new DX.data.DataSource(options)
                    },
                    getFields: function(fieldsDataType) {
                        var that = this,
                            dataSource = that._dataSource,
                            d = $.Deferred();
                        loadDataSource(dataSource).done(function(data) {
                            d.resolve(discover(data, fieldsDataType))
                        }).fail(d.reject);
                        return d
                    },
                    load: function(options) {
                        var that = this,
                            dataSource = that._dataSource,
                            d = $.Deferred();
                        loadDataSource(dataSource).done(function(data) {
                            var parsedData = loadCore(data, options);
                            d.resolve(parsedData)
                        }).fail(d.reject);
                        return d
                    },
                    supportSorting: function() {
                        return false
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.areaItem.js */
    (function($, DX) {
        var pivotGrid = DX.ui.dxPivotGrid,
            utils = DX.utils,
            Class = DX.Class;
        var IE_WIDTH_CORRECTION = 1;
        var getRealElementWidth = function(element, isFixed) {
                return isFixed ? element.offsetWidth : element.offsetWidth + IE_WIDTH_CORRECTION
            };
        pivotGrid.getRealElementWidth = getRealElementWidth;
        pivotGrid.AreaItem = Class.inherit({
            _getRowElement: function(index) {
                var that = this;
                if (that._tableElement && that._tableElement.length > 0)
                    return that._tableElement[0].rows[index];
                return null
            },
            _createGroupElement: function() {
                return $('<div>')
            },
            _createTableElement: function() {
                return $('<table>')
            },
            _renderTableContent: function(tableElement, data) {
                var that = this,
                    rowElements = tableElement.find("tr"),
                    areaName = that._getAreaName(),
                    onCellPrepared = that.option("onCellPrepared"),
                    rowElement,
                    cellElement,
                    row,
                    cell,
                    rowIndex,
                    columnIndex;
                tableElement.data("area", areaName);
                tableElement.data("data", data);
                if (onCellPrepared)
                    for (rowIndex = 0; rowIndex < data.length; rowIndex++) {
                        row = data[rowIndex];
                        rowElement = rowElements.eq(rowIndex);
                        for (columnIndex = 0; columnIndex < row.length; columnIndex++) {
                            cell = row[columnIndex];
                            cellElement = rowElement.children().eq(columnIndex);
                            onCellPrepared({
                                area: areaName,
                                rowIndex: rowIndex,
                                columnIndex: columnIndex,
                                cellElement: cellElement,
                                cell: cell
                            })
                        }
                    }
            },
            _getRowHeight: function(index) {
                var row = this._getRowElement(index);
                if (row && row.lastChild)
                    return row.lastChild.offsetHeight;
                return 0
            },
            _setRowHeight: function(index, value) {
                var row = this._getRowElement(index);
                if (row)
                    row.style.height = value + 'px'
            },
            ctor: function(component) {
                this.component = component
            },
            option: function() {
                return this.component.option.apply(this.component, arguments)
            },
            getRowsLength: function() {
                var that = this;
                if (that._tableElement && that._tableElement.length > 0)
                    return that._tableElement[0].rows.length;
                return 0
            },
            getRowsHeight: function() {
                var that = this,
                    result = [],
                    rowsLength = that.getRowsLength(),
                    i;
                for (i = 0; i < rowsLength; i++)
                    result.push(that._getRowHeight(i));
                return result
            },
            setRowsHeight: function(values) {
                var that = this,
                    totalHeight = 0,
                    valuesLength = values.length,
                    i;
                for (i = 0; i < valuesLength; i++) {
                    totalHeight += values[i];
                    that._setRowHeight(i, values[i])
                }
                this._tableHeight = totalHeight;
                this._tableElement[0].style.height = totalHeight + 'px'
            },
            getColumnsWidth: function() {
                var rowsLength = this.getRowsLength(),
                    rowIndex,
                    isFixed = this._tableElement[0].style.tableLayout === 'fixed',
                    row,
                    i,
                    columnIndex,
                    processedCells = [],
                    result = [],
                    fillCells = function(cells, rowIndex, columnIndex, rowSpan, colSpan) {
                        var rowOffset,
                            columnOffset;
                        for (rowOffset = 0; rowOffset < rowSpan; rowOffset++)
                            for (columnOffset = 0; columnOffset < colSpan; columnOffset++) {
                                cells[rowIndex + rowOffset] = cells[rowIndex + rowOffset] || [];
                                cells[rowIndex + rowOffset][columnIndex + columnOffset] = true
                            }
                    };
                if (rowsLength)
                    for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
                        processedCells[rowIndex] = processedCells[rowIndex] || [];
                        row = this._getRowElement(rowIndex);
                        for (i = 0; i < row.cells.length; i++) {
                            for (columnIndex = 0; processedCells[rowIndex][columnIndex]; columnIndex++);;
                            fillCells(processedCells, rowIndex, columnIndex, row.cells[i].rowSpan, row.cells[i].colSpan);
                            if (row.cells[i].colSpan === 1)
                                result[columnIndex] = result[columnIndex] || getRealElementWidth(row.cells[i], isFixed)
                        }
                    }
                return result
            },
            setColumnsWidth: function(values) {
                var i,
                    totalWidth = 0;
                var colgroupElementHTML = '';
                for (i = 0; i < values.length; i++) {
                    totalWidth += values[i];
                    colgroupElementHTML += '<col style="width: ' + values[i] + 'px"/>'
                }
                this._colgroupElement.html(colgroupElementHTML);
                this._tableWidth = totalWidth;
                this._tableElement[0].style.width = totalWidth + 'px';
                this._tableElement[0].style.tableLayout = 'fixed'
            },
            resetColumnsWidth: function() {
                this._colgroupElement.find('col').width('auto');
                this._tableElement.css({
                    width: '',
                    tableLayout: ''
                })
            },
            groupWidth: function(value) {
                if (value === undefined)
                    return this._groupElement.width();
                else if (value >= 0) {
                    this._groupWidth = value;
                    return this._groupElement[0].style.width = value + 'px'
                }
            },
            groupHeight: function(value) {
                if (value === undefined)
                    return this._groupElement.height();
                else if (value >= 0) {
                    this._groupHeight = value;
                    this._groupElement[0].style.height = value + 'px'
                }
            },
            groupElement: function() {
                return this._groupElement
            },
            tableElement: function() {
                return this._tableElement
            },
            element: function() {
                return this._rootElement
            },
            headElement: function() {
                return this._tableElement.find('thead')
            },
            render: function(rootElement, data) {
                var that = this,
                    tableElement = that._createTableElement();
                if (utils.isDefined(that._tableElement)) {
                    try {
                        that._tableElement[0].innerHTML = ''
                    }
                    catch(e) {
                        that._tableElement.empty()
                    }
                    that._tableElement.attr('style', '');
                    that._colgroupElement = $('<colgroup>').appendTo(that._tableElement);
                    that._renderTableContent(that._tableElement, data)
                }
                else {
                    that._groupElement = that._createGroupElement();
                    that._tableElement = tableElement;
                    that._colgroupElement = $('<colgroup>').appendTo(that._tableElement);
                    that._renderTableContent(that._tableElement, data);
                    that._tableElement.appendTo(that._groupElement);
                    that._groupElement.appendTo(rootElement);
                    that._rootElement = rootElement
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.headersArea.js */
    (function($, DX) {
        var ui = DX.ui,
            events = ui.events,
            pivotGrid = ui.dxPivotGrid,
            utils = DX.utils;
        pivotGrid.HorizontalHeadersArea = pivotGrid.AreaItem.inherit({
            _getAreaName: function() {
                return "column"
            },
            _getAreaClassName: function() {
                return pivotGrid.cssClassNames.headersHorizontal
            },
            _textCellRender: function(rootElement, value) {
                var $span = $('<span>');
                if (!value)
                    $span.html("&nbsp");
                else
                    this.option("encodeHtml") ? $span.text(value) : $span.html(value);
                $span.appendTo(rootElement)
            },
            _createGroupElement: function() {
                return $('<div>').addClass(this._getAreaClassName()).addClass(pivotGrid.cssClassNames.area)
            },
            _createTableElement: function() {
                return $('<table>')
            },
            _createRow: function() {
                return $('<tr>')
            },
            _createCell: function(cell) {
                var that = this,
                    cellElement = $('<td>').attr({
                        colspan: cell.colspan,
                        rowspan: cell.rowspan
                    });
                if (utils.isDefined(cell.expanded)) {
                    cellElement.addClass(cell.expanded ? pivotGrid.cssClassNames.headersExpanded : pivotGrid.cssClassNames.headersCollapsed).on(events.addNamespace("dxclick", this._getEventsNamespace()), function(e) {
                        setTimeout(function() {
                            var area = that._getAreaName();
                            if (cell.expanded)
                                that._dataSource.collapseHeaderItem(area, cell.path);
                            else
                                that._dataSource.expandHeaderItem(area, cell.path)
                        })
                    });
                    $('<span>').addClass(pivotGrid.cssClassNames.headersExpandCollapseImage).appendTo(cellElement)
                }
                return cellElement
            },
            _applyCustomStyles: function(options) {
                if (options.cellIndex === options.cellsCount - 1)
                    options.cellElement.css('border-right', '0px');
                if (options.cell.rowspan === options.rowsCount - options.rowIndex || options.rowIndex + 1 === options.rowsCount)
                    options.cellElement.css('border-bottom-width', '0px');
                options.cellElement.toggleClass(pivotGrid.cssClassNames.rowTotal, options.cell.type === 'T' || options.cell.type === 'GT').toggleClass(pivotGrid.cssClassNames.total, options.cell.type === 'T').toggleClass(pivotGrid.cssClassNames.grandTotal, options.cell.type === 'GT');
                if (options.cell.width)
                    options.cellElement.css("min-width", options.cell.width);
                if (options.cell.sorted)
                    $('<span>').addClass("dx-icon-sorted").appendTo(options.cellElement)
            },
            _renderTableContent: function(tableElement, data) {
                var that = this,
                    rowsCount = data.length,
                    row,
                    cell,
                    i,
                    j,
                    rowElement,
                    cellElement,
                    theadElement = $('<thead>').addClass(this._getAreaClassName());
                tableElement.width('auto');
                for (i = 0; i < rowsCount; i++) {
                    row = data[i];
                    rowElement = that._createRow();
                    for (j = 0; j < row.length; j++) {
                        cell = row[j];
                        cellElement = that._createCell(cell);
                        that._textCellRender(cellElement, cell.text);
                        that._applyCustomStyles({
                            cellElement: cellElement,
                            cell: cell,
                            cellsCount: row.length,
                            cellIndex: j,
                            rowElement: rowElement,
                            rowIndex: i,
                            rowsCount: rowsCount
                        });
                        rowElement.append(cellElement)
                    }
                    theadElement.append(rowElement)
                }
                tableElement.append(theadElement);
                that.callBase.apply(that, arguments)
            },
            _getEventsNamespace: function() {
                return 'dxHeadersArea'
            },
            hasScroll: function() {
                if (this._groupWidth && this._tableWidth)
                    return this._tableWidth > this._groupWidth;
                return false
            },
            processScroll: function() {
                if (!this._groupElement.data('dxScrollable')) {
                    this._groupElement.dxScrollable({
                        useNative: true,
                        useSimulatedScrollbar: false,
                        showScrollbar: false,
                        bounceEnabled: false,
                        direction: "horizontal"
                    });
                    this._groupElement.find('.dx-scrollable-container').css('overflow', 'hidden')
                }
            },
            processScrollBarSpacing: function(scrollBarWidth) {
                var that = this;
                if (that._groupWidth)
                    that.groupWidth(that._groupWidth - scrollBarWidth);
                if (that._scrollBarWidth)
                    that._groupElement.next().remove();
                that._groupElement.toggleClass(pivotGrid.cssClassNames.verticalScroll, scrollBarWidth > 0);
                that._groupElement.css('float', 'left').width(that._groupHeight);
                that._scrollBarWidth = scrollBarWidth
            },
            processStretch: function(resultSizes, hasScroll, dataFields) {
                var that = this,
                    tableSize = 0,
                    groupSize = that._groupWidth,
                    diff,
                    diffElement,
                    onePixelElementsCount,
                    fixedWidthCount = 0,
                    i;
                for (i = 0; i < resultSizes.length; i++) {
                    if (dataFields.length && dataFields[i % dataFields.length].width) {
                        if (dataFields.length > 1)
                            fixedWidthCount++;
                        resultSizes[i] = dataFields[i % dataFields.length].width
                    }
                    tableSize += resultSizes[i]
                }
                that._testOriginalTableSize = tableSize;
                if (groupSize && !hasScroll) {
                    diff = groupSize - tableSize;
                    diffElement = Math.floor(diff / (resultSizes.length - fixedWidthCount));
                    onePixelElementsCount = diff - diffElement * (resultSizes.length - fixedWidthCount);
                    for (i = 0; i < resultSizes.length; i++) {
                        if (dataFields.length > 1 && dataFields[i % dataFields.length].width)
                            continue;
                        resultSizes[i] += diffElement;
                        if (onePixelElementsCount) {
                            resultSizes[i]++;
                            onePixelElementsCount--
                        }
                    }
                }
            },
            ctor: function(component) {
                this.callBase(component);
                this._scrollBarWidth = 0
            },
            setDataController: function(dataController) {
                this._dataSource = dataController;
                return this
            }
        });
        pivotGrid.VerticalHeadersArea = pivotGrid.HorizontalHeadersArea.inherit({
            _getAreaClassName: function() {
                return pivotGrid.cssClassNames.headersVertical
            },
            _applyCustomStyles: function(options) {
                var cellElement = options.cellElement;
                this.callBase(options);
                cellElement.addClass(options.cellIndex === options.cellsCount - 1 ? pivotGrid.cssClassNames.headersVerticalLastCell : null);
                if (options.rowIndex === options.rowsCount - 1)
                    cellElement.css('border-bottom', '0px');
                if (options.rowIndex !== 0 && options.cell.expanded)
                    options.rowElement.addClass(pivotGrid.cssClassNames.headersVerticalExpandBorder)
            },
            _getAreaName: function() {
                return "row"
            },
            _getEventsNamespace: function() {
                return 'dxVerticalHeadersArea'
            },
            hasScroll: function() {
                if (this._groupHeight && this._tableHeight)
                    return this._tableHeight > this._groupHeight;
                return false
            },
            processScroll: function() {
                if (!this._groupElement.data('dxScrollable')) {
                    this._groupElement.dxScrollable({
                        useNative: true,
                        useSimulatedScrollbar: false,
                        showScrollbar: false,
                        bounceEnabled: false,
                        direction: "vertical"
                    });
                    this._groupElement.find('.dx-scrollable-container').css('overflow', 'hidden')
                }
            },
            processScrollBarSpacing: function(scrollBarWidth) {
                var that = this;
                if (that._groupHeight)
                    that.groupHeight(that._groupHeight - scrollBarWidth);
                if (that._scrollBarWidth)
                    that._groupElement.next().remove();
                if (scrollBarWidth)
                    that._groupElement.after($('<div>').width('100%').height(scrollBarWidth - 1));
                that._scrollBarWidth = scrollBarWidth
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.dataArea.js */
    (function($, DX) {
        var pivotGrid = DX.ui.dxPivotGrid;
        pivotGrid.DataArea = pivotGrid.AreaItem.inherit({
            _getAreaName: function() {
                return "data"
            },
            _createGroupElement: function() {
                return $('<div />').addClass(pivotGrid.cssClassNames.area).addClass(pivotGrid.cssClassNames.areaData)
            },
            _renderTableContent: function(tableElement, data) {
                var i,
                    j,
                    row,
                    cell,
                    cellText,
                    tableContentHTML = '',
                    style,
                    classNames;
                for (i = 0; i < data.length; i++) {
                    tableContentHTML += '<tr>';
                    row = data[i];
                    for (j = 0; j < row.length; j++) {
                        cell = row[j];
                        classNames = [];
                        style = '';
                        if (i === data.length - 1)
                            style = 'border-bottom: 0px';
                        if (cell) {
                            if (cell.rowType === 'T' || cell.columnType === 'T')
                                classNames.push(pivotGrid.cssClassNames.total);
                            if (cell.rowType === 'GT' || cell.columnType === 'GT')
                                classNames.push(pivotGrid.cssClassNames.grandTotal);
                            if (cell.rowType === 'T' || cell.rowType === 'GT')
                                classNames.push(pivotGrid.cssClassNames.rowTotal);
                            cellText = cell.text || '';
                            if (this.option("encodeHtml") && (cellText.indexOf("<") !== -1 || cellText.indexOf(">") !== -1))
                                cellText = $("<div>").text(cellText).html();
                            if (cell.width) {
                                if (style)
                                    style += '; ';
                                style += 'min-width: ' + cell.width + 'px'
                            }
                        }
                        else
                            cellText = '';
                        tableContentHTML += '<td class="' + classNames.join(' ') + '" style="' + style + '">' + cellText + '</td>'
                    }
                    tableContentHTML += '</tr>'
                }
                tableElement.append(tableContentHTML);
                this.callBase.apply(this, arguments)
            },
            _processScrollCore: function(hasRowsScroll, hasColumnsScroll, useNativeScrolling) {
                var that = this,
                    groupElement = that._groupElement,
                    options = {
                        useNative: !!useNativeScrolling,
                        useSimulatedScrollbar: !useNativeScrolling,
                        direction: "both",
                        bounceEnabled: false
                    };
                if (hasColumnsScroll && !hasRowsScroll)
                    options.direction = "horizontal";
                else if (!hasColumnsScroll)
                    options.direction = "vertical";
                groupElement.dxScrollable(options)
            },
            processScroll: function(scrollBarWidth, hasRowsScroll, hasColumnsScroll, useNativeScrolling) {
                var that = this,
                    groupElement = that._groupElement;
                that._rootElement.css({
                    position: 'relative',
                    display: 'block'
                });
                groupElement.css('border-top-width', 0);
                that._processScrollCore(hasRowsScroll, hasColumnsScroll, useNativeScrolling)
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.fieldChooser.js */
    (function($, DX) {
        var ui = DX.ui,
            utils = DX.utils,
            pivotGrid = ui.dxPivotGrid,
            dataGrid = ui.dxDataGrid,
            DIV = "<div>";
        var ColumnsView = dataGrid.ColumnsView.inherit(dataGrid.sortingMixin).inherit(dataGrid.headerFilterMixin);
        var HeaderFilterView = dataGrid.HeaderFilterView;
        var FIELDCHOOSER_CLASS = "dx-pivotgridfieldchooser",
            FIELDCHOOSER_CONTAINER_CLASS = "dx-pivotgridfieldchooser-container";
        var processItems = function(groupItems, field, filterValues, isTree, level, path) {
                level = level || 0;
                path = path || [];
                var currentField = field.levels ? field.levels[level] : field,
                    i;
                for (i = 0; i < groupItems.length; i++) {
                    groupItems[i].text = groupItems[i].text || DX.formatHelper.format(groupItems[i].value, currentField.format, currentField.precision);
                    path.push(groupItems[i].value);
                    groupItems[i].filterValue = isTree ? path.slice(0) : groupItems[i].value;
                    if ($.inArray(isTree ? path.join("/") : groupItems[i].value, filterValues) > -1 ^ field.filterType === "exclude")
                        groupItems[i].selected = true;
                    if (groupItems[i].children) {
                        groupItems[i].items = groupItems[i].children;
                        groupItems[i].children = null;
                        processItems(groupItems[i].items, field, filterValues, isTree, level + 1, path)
                    }
                    path.pop()
                }
            };
        function getDimensionFields(item, fields) {
            var result = [];
            if (item.items)
                for (var i = 0; i < item.items.length; i++)
                    result.push.apply(result, getDimensionFields(item.items[i], fields));
            else if (utils.isDefined(item.index))
                result.push(fields[item.index]);
            return result
        }
        function getFirstItem(item, condition) {
            if (item.items)
                for (var i = 0; i < item.items.length; i++) {
                    var childrenItem = getFirstItem(item.items[i], condition);
                    if (childrenItem)
                        return childrenItem
                }
            if (condition(item))
                return item
        }
        var compareOrder = [function(a, b) {
                    var aValue = -!!a.isMeasure,
                        bValue = +!!b.isMeasure;
                    return aValue + bValue
                }, function(a, b) {
                    var aValue = -!!(a.items && a.items.length),
                        bValue = +!!(b.items && b.items.length);
                    return aValue + bValue
                }, function(a, b) {
                    var aValue = +!!(a.field && a.field.levels && a.field.levels.length),
                        bValue = -!!(b.field && b.field.levels && b.field.levels.length);
                    return aValue + bValue
                }, pivotGrid.getCompareFunction(function(item) {
                    return item.text
                })];
        function compareItems(a, b) {
            var result = 0,
                i = 0;
            while (!result && compareOrder[i])
                result = compareOrder[i++](a, b);
            return result
        }
        function getScrollable(container) {
            return container.find(".dx-scrollable").dxScrollable("instance")
        }
        DX.registerComponent("dxPivotGridFieldChooser", ui, ui.Widget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    height: 400,
                    layout: 0,
                    dataSource: null,
                    texts: {
                        columnFields: Globalize.localize("dxPivotGrid-columnFields"),
                        rowFields: Globalize.localize("dxPivotGrid-rowFields"),
                        dataFields: Globalize.localize("dxPivotGrid-dataFields"),
                        filterFields: Globalize.localize("dxPivotGrid-filterFields"),
                        allFields: Globalize.localize("dxPivotGrid-allFields")
                    },
                    headerFilter: {
                        width: 252,
                        height: 300,
                        texts: {
                            emptyValue: Globalize.localize("dxDataGrid-headerFilterEmptyValue"),
                            ok: Globalize.localize("dxDataGrid-headerFilterOK"),
                            cancel: Globalize.localize("dxDataGrid-headerFilterCancel")
                        }
                    }
                })
            },
            _refreshDataSource: function() {
                var that = this;
                that._expandedPaths = [];
                that._changedHandler = that._changedHandler || function() {
                    $.each(that._dataChangedHandlers, function(_, func) {
                        func()
                    });
                    that._updateIndicatorsPosition()
                };
                if (that._dataSource) {
                    that._dataSource.off("changed", that._changedHandler);
                    that._dataSource = undefined
                }
                var dataSource = this.option("dataSource");
                if (dataSource && dataSource.fields && dataSource.load)
                    that._dataSource = dataSource;
                that._dataSource && that._dataSource.on("changed", that._changedHandler)
            },
            _init: function() {
                this.callBase();
                this._columnsView = new ColumnsView(this);
                this._headerFilterView = new HeaderFilterView(this);
                this._subscribeToEvents();
                this._refreshDataSource();
                this._dataChangedHandlers = []
            },
            _subscribeToEvents: function() {
                var that = this;
                that.element().on("dxclick", ".dx-area-field.dx-area-box", function(e) {
                    var field = $.extend(true, {}, $(e.currentTarget).data("field")),
                        isHeaderFilter = $(e.target).hasClass("dx-header-filter");
                    if (isHeaderFilter)
                        that._headerFilterView.showHeaderFilterMenu($(e.currentTarget), {
                            type: field.groupName ? 'tree' : 'list',
                            dataSource: {
                                load: function(options) {
                                    var userData = options.userData;
                                    if (userData.store)
                                        return userData.store.load(options);
                                    else {
                                        var d = $.Deferred();
                                        that._dataSource.getFieldValues(field.index).done(function(data) {
                                            userData.store = new DX.data.ArrayStore(data);
                                            userData.store.load(options).done(d.resolve).fail(d.reject)
                                        }).fail(d.reject);
                                        return d
                                    }
                                },
                                postProcess: function(data) {
                                    var filterValues = [];
                                    if (field.filterValues)
                                        $.each(field.filterValues, function(index, filterValue) {
                                            filterValues.push(utils.isArray(filterValue) ? filterValue.join("/") : filterValue)
                                        });
                                    processItems(data, field, filterValues, !!field.groupName);
                                    return data
                                }
                            },
                            filterValues: field.filterValues,
                            filterType: field.filterType,
                            apply: function() {
                                that._dataSource.field(field.index, {
                                    filterValues: this.filterValues,
                                    filterType: this.filterType
                                });
                                that._dataSource.load()
                            }
                        });
                    else if (field.allowSorting && field.area !== "data") {
                        that._dataSource.field(field.index, {sortOrder: field.sortOrder === "desc" ? "asc" : "desc"});
                        that._dataSource.load()
                    }
                })
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {dataSource: true})
            },
            _optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"dataSource":
                        that._refreshDataSource();
                        that._invalidate();
                        break;
                    case"layout":
                    case"texts":
                    case"headerFilter":
                        that._invalidate();
                        break;
                    default:
                        that.callBase(args)
                }
            },
            _clean: function() {
                this.element().children("." + FIELDCHOOSER_CONTAINER_CLASS).remove()
            },
            _renderContentImpl: function() {
                var that = this,
                    element = this.element(),
                    $col1,
                    $col2;
                element.addClass(FIELDCHOOSER_CLASS);
                that._dataChangedHandlers = [];
                that._renderSortable(element);
                that._headerFilterView.render(element);
                var $container = $(DIV).addClass(FIELDCHOOSER_CONTAINER_CLASS).appendTo(element);
                if (this.option("layout") === 0) {
                    $col1 = $(DIV).addClass("dx-col").appendTo($container);
                    $col2 = $(DIV).addClass("dx-col").appendTo($container);
                    this._renderArea($col1, "all");
                    this._renderArea($col1, "filter");
                    this._renderArea($col2, "row");
                    this._renderArea($col2, "column");
                    this._renderArea($col2, "data")
                }
                else if (this.option("layout") === 1) {
                    $col1 = $(DIV).addClass("dx-col").appendTo($container);
                    $col2 = $(DIV).addClass("dx-col").appendTo($container);
                    this._renderArea($col1, "all");
                    this._renderArea($col2, "filter");
                    this._renderArea($col2, "row");
                    this._renderArea($col2, "column");
                    this._renderArea($col2, "data")
                }
                else {
                    this._renderArea($container, "all");
                    $col1 = $(DIV).addClass("dx-col").appendTo($container);
                    $col2 = $(DIV).addClass("dx-col").appendTo($container);
                    this._renderArea($col1, "filter");
                    this._renderArea($col1, "row");
                    this._renderArea($col2, "column");
                    this._renderArea($col2, "data")
                }
                this.updateDimensions()
            },
            _renderSortable: function(element) {
                var that = this;
                that._createComponent(element, "dxSortable", {
                    itemSelector: ".dx-area-field",
                    itemContainerSelector: ".dx-area-field-container",
                    groupSelector: ".dx-area-fields",
                    itemRender: function($sourceItem, target) {
                        var $item;
                        if ($sourceItem.hasClass("dx-area-box")) {
                            $item = $sourceItem.clone();
                            $item.insertBefore($sourceItem)
                        }
                        else
                            $item = $(DIV).addClass("dx-area-field").addClass("dx-area-box").text($sourceItem.text());
                        if (target === "drag")
                            $item.width(element.find(".dx-area-field-container").first().width());
                        return $item
                    },
                    onDragging: function(e) {
                        var field = e.sourceElement.data("field"),
                            targetGroup = e.targetGroup;
                        e.cancel = false;
                        if (field.isMeasure === true) {
                            if (targetGroup === "column" || targetGroup === "row" || targetGroup === "filter")
                                e.cancel = true
                        }
                        else if (field.isMeasure === false && targetGroup === "data")
                            e.cancel = true
                    },
                    onChanged: function(e) {
                        var dataSource = that._dataSource,
                            field = e.sourceElement.data("field");
                        e.removeSourceElement = !!e.sourceGroup;
                        if (field) {
                            dataSource.field(field.index, {
                                area: e.targetGroup,
                                areaIndex: e.targetIndex
                            });
                            dataSource.load()
                        }
                    }
                })
            },
            _createTreeItems: function(fields, groupFieldNames, path) {
                var that = this,
                    isMeasure,
                    resultItems = [],
                    groupedItems = [],
                    groupFieldName = groupFieldNames[0],
                    fieldsByGroup = {};
                if (!groupFieldName)
                    $.each(fields, function(index, field) {
                        var icon;
                        if (field.isMeasure === true)
                            icon = "measure";
                        if (field.isMeasure === false)
                            icon = field.groupName ? "hierarchy" : "dimension";
                        resultItems.push({
                            index: field.index,
                            field: field,
                            key: field.dataField,
                            selected: utils.isDefined(field.area),
                            text: field.caption || field.dataField,
                            icon: icon,
                            isMeasure: field.isMeasure,
                            isDefault: field.isDefault
                        })
                    });
                else {
                    $.each(fields, function(index, field) {
                        var groupName = field[groupFieldName] || "";
                        fieldsByGroup[groupName] = fieldsByGroup[groupName] || [];
                        fieldsByGroup[groupName].push(field);
                        if (isMeasure === undefined)
                            isMeasure = true;
                        isMeasure = isMeasure && field.isMeasure === true
                    });
                    $.each(fieldsByGroup, function(groupName, fields) {
                        var currentPath = path ? path + '.' + groupName : groupName;
                        var items = that._createTreeItems(fields, groupFieldNames.slice(1), currentPath);
                        if (groupName)
                            groupedItems.push({
                                key: groupName,
                                text: groupName,
                                path: currentPath,
                                isMeasure: items.isMeasure,
                                expanded: $.inArray(currentPath, that._expandedPaths) >= 0,
                                items: items
                            });
                        else
                            resultItems = items
                    });
                    resultItems = groupedItems.concat(resultItems);
                    resultItems.isMeasure = isMeasure
                }
                return resultItems
            },
            _createFieldsDataSource: function(dataSource) {
                var fields = dataSource && dataSource.fields() || [],
                    treeItems;
                fields = $.map(fields, function(field) {
                    return field.visible === false || utils.isDefined(field.groupIndex) ? null : field
                });
                treeItems = this._createTreeItems(fields, ["dimension", "displayFolder"]);
                pivotGrid.foreachDataLevel(treeItems, function(items) {
                    items.sort(compareItems)
                }, 0, "items");
                return treeItems
            },
            _renderFieldsTreeView: function(container) {
                var that = this,
                    dataSource = that._dataSource,
                    treeView = that._createComponent(container, "dxTreeView", {
                        dataSource: that._createFieldsDataSource(dataSource),
                        showCheckBoxes: true,
                        itemTemplate: function(itemData, itemIndex, itemElement) {
                            if (itemData.icon)
                                utils.getImageContainer(itemData.icon).appendTo(itemElement);
                            $('<span>').toggleClass("dx-area-field", !itemData.items).data("field", itemData.field).text(itemData.text).appendTo(itemElement)
                        },
                        onItemCollapsed: function(e) {
                            var index = $.inArray(e.itemData.path, that._expandedPaths);
                            if (index >= 0)
                                that._expandedPaths.splice(index, 1)
                        },
                        onItemExpanded: function(e) {
                            var index = $.inArray(e.itemData.path, that._expandedPaths);
                            if (index < 0)
                                that._expandedPaths.push(e.itemData.path)
                        },
                        onItemSelected: function(e) {
                            var data = e.itemData,
                                field,
                                fields,
                                needSelectDefaultItem = true,
                                area;
                            if (data.items) {
                                if (data.selected) {
                                    treeView.unselectItem(data);
                                    return
                                }
                                fields = getDimensionFields(data, dataSource.fields());
                                for (var i = 0; i < fields.length; i++)
                                    if (fields[i].area) {
                                        needSelectDefaultItem = false;
                                        break
                                    }
                                if (needSelectDefaultItem) {
                                    var item = getFirstItem(data, function(item) {
                                            return item.isDefault
                                        }) || getFirstItem(data, function(item) {
                                            return utils.isDefined(item.index)
                                        });
                                    item && treeView.selectItem(item);
                                    return
                                }
                            }
                            else {
                                field = dataSource.fields()[data.index];
                                if (data.selected)
                                    area = field.isMeasure ? "data" : "column";
                                if (field)
                                    fields = [field]
                            }
                            $.each(fields, function(_, field) {
                                dataSource.field(field.index, {
                                    area: area,
                                    areaIndex: undefined
                                })
                            });
                            dataSource.load()
                        }
                    }),
                    dataChanged = function() {
                        var scrollable = getScrollable(container),
                            scrollTop = scrollable ? scrollable.scrollTop() : 0;
                        treeView.option({dataSource: that._createFieldsDataSource(dataSource)});
                        scrollable = getScrollable(container);
                        if (scrollable) {
                            scrollable.scrollTo({y: scrollTop});
                            scrollable.update()
                        }
                    };
                that._dataChangedHandlers.push(dataChanged)
            },
            _renderField: function(field) {
                var that = this,
                    $fieldContent = $(DIV).addClass("dx-area-field-content").text(field.caption || field.dataField),
                    $fieldElement = $(DIV).addClass("dx-area-field").addClass("dx-area-box").data("field", field).append($fieldContent);
                if (field.area !== "data") {
                    if (field.allowSorting)
                        that._columnsView._applyColumnState({
                            name: 'sort',
                            rootElement: $fieldElement,
                            column: {
                                alignment: that.option("rtlEnabled") ? 'right' : 'left',
                                sortOrder: field.sortOrder === 'desc' ? 'desc' : 'asc'
                            },
                            showColumnLines: true
                        });
                    that._columnsView._applyColumnState({
                        name: 'headerFilter',
                        rootElement: $fieldElement,
                        column: {
                            alignment: that.option("rtlEnabled") ? 'right' : 'left',
                            filterValues: field.filterValues,
                            allowFiltering: field.allowFiltering
                        },
                        showColumnLines: true
                    })
                }
                return $fieldElement
            },
            _renderAreaFields: function($container, area) {
                var that = this,
                    dataSource = that._dataSource,
                    fields = dataSource ? dataSource.getAreaFields(area, true) : [];
                $container.empty();
                $.each(fields, function() {
                    that._renderField(this).appendTo($container)
                })
            },
            _renderArea: function(container, area) {
                var that = this,
                    $areaContainer = $(DIV).addClass("dx-area").appendTo(container),
                    caption = that.option("texts." + area + "Fields"),
                    $fieldsContainer,
                    $fieldsContent,
                    render;
                $("<span>").addClass("dx-area-icon").addClass("dx-area-icon-" + area).appendTo($areaContainer);
                $("<span>").html("&nbsp;").appendTo($areaContainer);
                $("<span>").addClass("dx-area-caption").text(caption).appendTo($areaContainer);
                $fieldsContainer = $(DIV).addClass("dx-area-fields").height(0).appendTo($areaContainer);
                if (area !== "all") {
                    $fieldsContent = $(DIV).addClass("dx-area-field-container").appendTo($fieldsContainer);
                    render = function() {
                        that._renderAreaFields($fieldsContent, area)
                    };
                    that._dataChangedHandlers.push(render);
                    render();
                    $fieldsContainer.attr("group", area).dxScrollable()
                }
                else {
                    $fieldsContainer.addClass("dx-treeview-border-visible");
                    that._renderFieldsTreeView($fieldsContainer)
                }
            },
            _updateIndicatorsPosition: function() {
                var columnsView = this._columnsView;
                $.each(this.element().find(".dx-area-field.dx-area-box"), function() {
                    columnsView._updateIndicatorHeight($(this), "sort");
                    columnsView._updateIndicatorHeight($(this), "headerFilter")
                })
            },
            updateDimensions: function() {
                var that = this,
                    $element = this.element(),
                    $container = $element.children(".dx-pivotgridfieldchooser-container"),
                    $cols = $element.find(".dx-col"),
                    $areaElements = $element.find(".dx-area-fields"),
                    $scrollableElements = $element.find(".dx-area .dx-scrollable"),
                    areaHeight;
                that._updateIndicatorsPosition();
                $areaElements.height(0);
                if (this.option("layout") === 0) {
                    areaHeight = Math.floor(($element.height() - $container.height()) / 3);
                    $areaElements.height(areaHeight);
                    $areaElements.eq(0).height($cols.eq(1).height() - $cols.eq(0).height() + areaHeight)
                }
                else if (this.option("layout") === 1) {
                    areaHeight = Math.floor(($element.height() - $container.height()) / 4);
                    $areaElements.height(areaHeight);
                    $areaElements.eq(0).height($cols.eq(1).height() - $cols.eq(0).height() + areaHeight)
                }
                else {
                    areaHeight = Math.floor(($element.height() - $container.height()) / 4);
                    $areaElements.height(areaHeight);
                    $areaElements.eq(0).height(areaHeight * 2)
                }
                $scrollableElements.dxScrollable("update")
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils;
        var WIDGET_CLASS = "dx-scheduler",
            WIDGET_READONLY_CLASS = "dx-scheduler-readonly",
            APPOINTMENT_POPUP_CLASS = "dx-scheduler-appointment-popup",
            APPOINTEMENT_POPUP_WIDTH = 610;
        var WORKSPACES = {
                day: "dxSchedulerWorkSpaceDay",
                week: "dxSchedulerWorkSpaceWeek",
                workWeek: "dxSchedulerWorkSpaceWorkWeek",
                month: "dxSchedulerWorkSpaceMonth"
            };
        DX.registerComponent("dxScheduler", ui, ui.Widget.inherit({
            _stripDateTime: function(date) {
                utils.correctDateWithUnitBeginning(date, "day");
                return date
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    views: ["day", "week"],
                    currentView: "day",
                    currentDate: this._stripDateTime(new Date),
                    min: undefined,
                    max: undefined,
                    firstDayOfWeek: undefined,
                    groups: [],
                    resources: [],
                    dataSource: null,
                    appointmentTemplate: "item",
                    startDayHour: 0,
                    endDayHour: 24,
                    editing: true,
                    onAppointmentRendered: null,
                    onAppointmentAdding: null,
                    onAppointmentAdded: null,
                    onAppointmentUpdating: null,
                    onAppointmentUpdated: null,
                    onAppointmentDeleting: null,
                    onAppointmentDeleted: null
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return DX.devices.real().generic && !DX.devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _optionChanged: function(args) {
                var value = args.value;
                switch (args.name) {
                    case"firstDayOfWeek":
                        this._workSpace.option("firstDayOfWeek", value);
                        this._header.option("firstDayOfWeek", value);
                        break;
                    case"currentDate":
                        value = utils.makeDate(value);
                        value = this._stripDateTime(value);
                        this._appointments.option("dataSource", []);
                        this._workSpace.option("currentDate", value);
                        this._header.option("currentDate", value);
                        this._filterAppointmentsByDate();
                        this._reloadDataSource().done($.proxy(function() {
                            this._appointments.option("dataSource", this._dataSource)
                        }, this));
                        break;
                    case"dataSource":
                        this._initDataSource();
                        this._appointmentModel.setDataSource(this._dataSource);
                        this._loadResources().done($.proxy(function(resources) {
                            this._filterAppointmentsByDateAndResources(resources);
                            this._appointments.option("dataSource", this._dataSource)
                        }, this));
                        break;
                    case"min":
                    case"max":
                        this._header.option(args.name, utils.makeDate(value));
                        this._workSpace.option(args.name, utils.makeDate(value));
                        break;
                    case"views":
                        this._header.option(args.name, value);
                        break;
                    case"currentView":
                        this._appointments.option("dataSource", []);
                        this._header.option("currentView", value);
                        this._loadResources().done($.proxy(function(resources) {
                            this._refreshWorkSpace(resources);
                            this._filterAppointmentsByDateAndResources(resources);
                            this._reloadDataSource().done($.proxy(function() {
                                this._appointments.option("renderingStrategy", this._getAppointmentsRenderingStrategy());
                                this._appointments.option("allowAllDayResize", value !== "day");
                                this._appointments.option("dataSource", this._dataSource)
                            }, this))
                        }, this));
                        break;
                    case"appointmentTemplate":
                        this._appointments.option("itemTemplate", value);
                        break;
                    case"groups":
                        this._loadResources().done($.proxy(function(resources) {
                            this._filterAppointmentsByDateAndResources(resources);
                            this._workSpace.option("groups", resources);
                            this._reloadDataSource()
                        }, this));
                        break;
                    case"resources":
                        this._resourcesManager.setResources(value);
                        this._loadResources().done($.proxy(function(resources) {
                            this._filterAppointmentsByDateAndResources(resources);
                            this._workSpace.option("groups", resources);
                            this._reloadDataSource()
                        }, this));
                        break;
                    case"startDayHour":
                        this._workSpace.option("startDayHour", value);
                        this._filterAppointmentsByDate();
                        this._reloadDataSource();
                        break;
                    case"endDayHour":
                        this._workSpace.option("endDayHour", value);
                        this._filterAppointmentsByDate();
                        this._reloadDataSource();
                        break;
                    case"onAppointmentAdding":
                    case"onAppointmentAdded":
                    case"onAppointmentUpdating":
                    case"onAppointmentUpdated":
                    case"onAppointmentDeleting":
                    case"onAppointmentDeleted":
                        this._actions[args.name] = this._createActionByOption(args.name);
                        break;
                    case"onAppointmentRendered":
                        this._appointments.option("onItemRendered", value);
                        break;
                    case"tabIndex":
                    case"focusStateEnabled":
                        this._header.option(args.name, value);
                        this._workSpace.option(args.name, value);
                        this._appointments.option(args.name, value);
                        this.callBase(args);
                        break;
                    case"width":
                        this._header.option("width", value);
                        this.callBase(args);
                        this._dimensionChanged();
                        break;
                    case"height":
                        this.callBase(args);
                        this._dimensionChanged();
                        break;
                    case"editing":
                        this.element().toggleClass(WIDGET_READONLY_CLASS, !value);
                        this._appointments.option({
                            allowDrag: value,
                            allowResize: value,
                            allowAllDayResize: value
                        });
                        this._refreshPopup();
                        this._hideTooltip();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _filterAppointmentsByDate: function() {
                var dateRange = this._workSpace.getDateRange();
                this._appointmentModel.filterByDate(dateRange[0], dateRange[1], this.option("startDayHour"), this.option("endDayHour"))
            },
            _filterAppointmentsByDateAndResources: function(resources) {
                var dateRange = this._workSpace.getDateRange(),
                    that = this;
                that._appointmentModel.filterByDateAndResources({
                    min: dateRange[0],
                    max: dateRange[1],
                    resources: that._prepareResourcesForFilter(resources),
                    startDayHour: that.option("startDayHour"),
                    endDayHour: that.option("endDayHour")
                })
            },
            _loadResources: function() {
                var groups = this.option("groups");
                return this._resourcesManager.getResourcesValueByFields(groups)
            },
            _reloadDataSource: function() {
                if (this._dataSource)
                    return this._dataSource.load();
                return $.Deferred().resolve().promise()
            },
            _prepareResourcesForFilter: function(resources) {
                return $.map(resources, function(resource) {
                        var resourceItems = resource.items,
                            data = [];
                        for (var i = 0, len = resourceItems.length; i < len; i++)
                            data.push(resourceItems[i].id);
                        return {
                                field: resource.name,
                                data: data
                            }
                    })
            },
            _dimensionChanged: function() {
                this._appointments && this._appointments.repaint()
            },
            _visibilityChanged: function(visible) {
                visible && this._dimensionChanged()
            },
            _init: function() {
                this.callBase();
                this._initDataSource();
                this._proxiedCustomizeStoreLoadOptionsHandler = $.proxy(this._customizeStoreLoadOptionsHandler, this);
                this._customizeStoreLoadOptions();
                this.element().addClass(WIDGET_CLASS);
                this.element().toggleClass(WIDGET_READONLY_CLASS, !this.option("editing"));
                this._appointmentModel = new ui.dxScheduler.dxSchedulerAppointmentModel(this._dataSource);
                this._resourcesManager = new ui.dxScheduler.dxSchedulerResourceManager(this.option("resources"));
                this._initActions();
                this._subscribes = ui.dxScheduler.subscribes
            },
            _dataSourceOptions: function() {
                return {paginate: false}
            },
            _customizeStoreLoadOptions: function() {
                this._dataSource && this._dataSource.on("customizeStoreLoadOptions", this._proxiedCustomizeStoreLoadOptionsHandler)
            },
            _dispose: function() {
                this._dataSource && this._dataSource.off("customizeStoreLoadOptions", this._proxiedCustomizeStoreLoadOptionsHandler);
                this.callBase()
            },
            _customizeStoreLoadOptionsHandler: function(options) {
                options.storeLoadOptions.dxScheduler = {
                    startDate: this._workSpace.getFirstViewDate(),
                    endDate: this._workSpace.getLastViewDate(),
                    resources: this.option("resources")
                }
            },
            _initActions: function() {
                this._actions = {
                    onAppointmentAdding: this._createActionByOption("onAppointmentAdding"),
                    onAppointmentAdded: this._createActionByOption("onAppointmentAdded"),
                    onAppointmentUpdating: this._createActionByOption("onAppointmentUpdating"),
                    onAppointmentUpdated: this._createActionByOption("onAppointmentUpdated"),
                    onAppointmentDeleting: this._createActionByOption("onAppointmentDeleting"),
                    onAppointmentDeleted: this._createActionByOption("onAppointmentDeleted")
                }
            },
            _initAppointmentRenderedAction: function() {
                return this._createActionByOption("onAppointmentRendered", {excludeValidators: ["designMode", "disabled", "readOnly"]})
            },
            _defaultAppointmentViewEditors: function() {
                var that = this;
                return [{
                            key: "text",
                            type: "dxTextBox",
                            label: "dxScheduler-editorLabelTitle",
                            cssClass: APPOINTMENT_POPUP_CLASS + "-caption"
                        }, {
                            key: "allDay",
                            type: "dxSwitch",
                            label: "dxScheduler-allDay",
                            cssClass: APPOINTMENT_POPUP_CLASS + "-allday",
                            options: {onValueChanged: function(args) {
                                    var value = args.value,
                                        startDateEditor = that._appointmentView.getEditorInstance("startDate"),
                                        endDateEditor = that._appointmentView.getEditorInstance("endDate"),
                                        startDate;
                                    if (startDateEditor && endDateEditor) {
                                        startDateEditor.option("format", value ? "date" : "datetime");
                                        endDateEditor.option("format", value ? "date" : "datetime");
                                        startDate = new Date(startDateEditor.option("value"));
                                        if (value) {
                                            startDate.setHours(0);
                                            startDate.setMinutes(0);
                                            startDateEditor.option("value", startDate);
                                            var endDate = new Date(startDate);
                                            endDate.setDate(startDate.getDate() + 1);
                                            endDateEditor.option("value", endDate)
                                        }
                                        else if (startDateEditor.option("value")) {
                                            startDate.setHours(that.option("startDayHour"));
                                            startDateEditor.option("value", startDate);
                                            endDateEditor.option("value", that._workSpace._calculateEndDate(startDateEditor.option("value")))
                                        }
                                    }
                                }}
                        }, {
                            key: "startDate",
                            type: "dxDateBox",
                            label: "dxScheduler-editorLabelStartDate",
                            cssClass: APPOINTMENT_POPUP_CLASS + "-start-date",
                            options: {
                                format: "datetime",
                                onValueChanged: function(args) {
                                    var value = args.value,
                                        previousValue = args.previousValue,
                                        endDateEditor = that._appointmentView.getEditorInstance("endDate"),
                                        endValue = endDateEditor.option("value");
                                    if (endValue <= value) {
                                        var duration = endValue.getTime() - previousValue.getTime();
                                        endDateEditor.option("value", new Date(value.getTime() + duration))
                                    }
                                }
                            }
                        }, {
                            key: "endDate",
                            type: "dxDateBox",
                            label: "dxScheduler-editorLabelEndDate",
                            cssClass: APPOINTMENT_POPUP_CLASS + "-end-date",
                            options: {
                                format: "datetime",
                                onValueChanged: function(args) {
                                    var value = args.value,
                                        previousValue = args.previousValue,
                                        startDateEditor = that._appointmentView.getEditorInstance("startDate"),
                                        startValue = startDateEditor.option("value");
                                    if (startValue >= value) {
                                        var duration = previousValue.getTime() - startValue.getTime();
                                        startDateEditor.option("value", new Date(value.getTime() - duration))
                                    }
                                }
                            }
                        }, {
                            key: "description",
                            type: "dxTextArea",
                            label: "dxScheduler-editorLabelDescription",
                            cssClass: APPOINTMENT_POPUP_CLASS + "-description"
                        }, {
                            key: "recurrenceRule",
                            type: "dxSchedulerRecurrenceEditor",
                            label: "dxScheduler-editorLabelRecurrence",
                            cssClass: APPOINTMENT_POPUP_CLASS + "-recurrence"
                        }]
            },
            _renderFocusTarget: $.noop,
            _render: function() {
                this.callBase();
                this._renderHeader();
                this._appointments = this._createComponent("<div>", "dxSchedulerAppointments", this._appointmentsConfig());
                this._loadResources().done($.proxy(function(resources) {
                    this._renderWorkSpace(resources);
                    var allDayContainerClass = this._workSpace.getAllDayContainerClass();
                    this._appointments.option({fixedContainer: this.element().find("." + allDayContainerClass)});
                    this._filterAppointmentsByDateAndResources(resources);
                    this._appointments.option("dataSource", this._dataSource)
                }, this))
            },
            _renderHeader: function() {
                this._header = this._createComponent("<div>", "dxSchedulerHeader", this._headerConfig());
                this.element().append(this._header.element())
            },
            _headerConfig: function() {
                return {
                        observer: this,
                        min: utils.makeDate(this.option("min")),
                        max: utils.makeDate(this.option("max")),
                        views: this.option("views"),
                        firstDayOfWeek: this.option("firstDayOfWeek"),
                        currentView: this.option("currentView"),
                        currentDate: this._stripDateTime(utils.makeDate(this.option("currentDate"))),
                        tabIndex: this.option("tabIndex"),
                        focusStateEnabled: this.option("focusStateEnabled"),
                        width: this.option("width"),
                        rtlEnabled: this.option("rtlEnabled")
                    }
            },
            _appointmentsConfig: function() {
                return {
                        observer: this,
                        renderingStrategy: this._getAppointmentsRenderingStrategy(),
                        itemTemplate: this._getTemplateByOption("appointmentTemplate"),
                        onItemRendered: this.option("onAppointmentRendered"),
                        tabIndex: this.option("tabIndex"),
                        focusStateEnabled: this.option("focusStateEnabled"),
                        allowDrag: this.option("editing"),
                        allowResize: this.option("editing"),
                        allowAllDayResize: this.option("editing") && this.option("currentView") !== "day",
                        rtlEnabled: this.option("rtlEnabled")
                    }
            },
            _getAppointmentsRenderingStrategy: function() {
                return this.option("currentView") === "month" ? "horizontal" : "vertical"
            },
            _renderWorkSpace: function(groups) {
                this._workSpace = this._createComponent("<div>", WORKSPACES[this.option("currentView")], this._workSpaceConfig(groups));
                this._workSpace.getWorkArea().append(this._appointments.element());
                this.element().append(this._workSpace.element());
                DX.utils.triggerShownEvent(this._workSpace.element())
            },
            _workSpaceConfig: function(groups) {
                return {
                        observer: this,
                        min: utils.makeDate(this.option("min")),
                        max: utils.makeDate(this.option("max")),
                        currentDate: this._stripDateTime(utils.makeDate(this.option("currentDate"))),
                        firstDayOfWeek: this.option("firstDayOfWeek"),
                        groups: groups,
                        startDayHour: this.option("startDayHour"),
                        endDayHour: this.option("endDayHour"),
                        tabIndex: this.option("tabIndex"),
                        focusStateEnabled: this.option("focusStateEnabled")
                    }
            },
            _refreshWorkSpace: function(groups) {
                var allDayContainerClass = this._workSpace.getAllDayContainerClass();
                this._appointments.element().detach();
                this._workSpace._dispose();
                this._workSpace.element().remove();
                delete this._workSpace;
                this._renderWorkSpace(groups);
                this._appointments.option({fixedContainer: this.element().find("." + allDayContainerClass)})
            },
            getWorkSpaceScrollable: function() {
                return this._workSpace.getScrollable()
            },
            getWorkSpaceScrollableScrollTop: function() {
                return this._workSpace.getScrollableScrollTop()
            },
            getWorkSpaceScrollableContainer: function() {
                return this._workSpace.getScrollableContainer()
            },
            getWorkSpaceAllDayHeight: function() {
                return this._workSpace.getAllDayHeight()
            },
            getWorkSpace: function() {
                return this._workSpace
            },
            getHeader: function() {
                return this._header
            },
            _createPopup: function() {
                !this._$popup && this._refreshPopup()
            },
            _refreshPopup: function() {
                this._$popup = $("<div>").addClass(APPOINTMENT_POPUP_CLASS).appendTo(this.element());
                this._popup = this._createComponent(this._$popup, "dxPopup", this._popupConfig());
                var $popupContent = this._popup.content();
                $popupContent.empty();
                var editors = this._defaultAppointmentViewEditors(),
                    resources = this.option("resources");
                if (resources && resources.length) {
                    this._resourcesManager.setResources(this.option("resources"));
                    editors = editors.concat(this._resourcesManager.getEditors())
                }
                this._appointmentView = new ui.dxScheduler.dxSchedulerAppointmentDetailsView($popupContent, {
                    editors: editors,
                    rtlEnabled: this.option("rtlEnabled"),
                    readOnly: !this.option("editing")
                })
            },
            _popupConfig: function() {
                var buttons = [];
                if (this.option("editing"))
                    buttons = [{
                            shortcut: "done",
                            location: "after",
                            onClick: $.proxy(this._doneButtonClickHandler, this)
                        }, {
                            shortcut: "cancel",
                            location: "after"
                        }];
                return {
                        width: APPOINTEMENT_POPUP_WIDTH,
                        buttons: buttons,
                        onHiding: $.proxy(function() {
                            this._workSpace.focus()
                        }, this)
                    }
            },
            _doneButtonClickHandler: function(args) {
                this._saveChanges(args);
                var bounds = this._workSpace.getVisibleBounds(),
                    startDate = this._appointmentView.option("values").startDate,
                    startDateHour = startDate.getHours(),
                    startDateMinutes = startDate.getMinutes(),
                    update = false;
                if (startDateHour < bounds.top.hours || startDateHour > bounds.bottom.hours)
                    update = true;
                if (startDateHour === bounds.top.hours && startDateMinutes < bounds.top.minutes)
                    update = true;
                if (startDateHour === bounds.bottom.hours && startDateMinutes > bounds.top.minutes)
                    update = true;
                if (update)
                    this._updateScrollPosition()
            },
            _saveChanges: function() {
                var appointmentData = this._appointmentView.option("values"),
                    oldData = this._editAppointmentData;
                if (oldData)
                    this._checkRecurringAppointment(oldData.recurrenceRule, $.proxy(function() {
                        this.updateAppointment(this._editAppointmentData, appointmentData)
                    }, this));
                else
                    this.addAppointment(appointmentData)
            },
            _updateScrollPosition: function() {
                var dateToScroll = this._appointmentView.option("values").startDate;
                this.scrollToTime(dateToScroll.getHours(), dateToScroll.getMinutes())
            },
            _checkRecurringAppointment: function(recurrenceRule, callback, isDeleted) {
                if (utils.getRecurrenceRule(recurrenceRule).isValid)
                    this._showRecurrenceChangeConfirm(isDeleted).done($.proxy(function(result) {
                        if (result)
                            callback();
                        else
                            this._appointments.moveAppointmentBack()
                    }, this));
                else
                    callback()
            },
            _showRecurrenceChangeConfirm: function(isDeleted) {
                var message;
                if (isDeleted)
                    message = "All occurrences of the recurring appointment will be deleted.<br> Are you sure you want to delete them?";
                else
                    message = "All occurrences of the recurring appointment will be edited.<br> Are you sure you want to edit them?";
                return ui.dialog.confirm(message, null, false)
            },
            _getUpdatedData: function(options) {
                var target = options.data,
                    data = this.getTargetCellData(),
                    date = data.date || target.startDate,
                    groups = data.groups,
                    duration = target.endDate.getTime() - target.startDate.getTime();
                var updatedData = {};
                updatedData.allDay = data.allDay;
                updatedData.startDate = date;
                updatedData.endDate = new Date(date.getTime() + duration);
                for (var name in groups)
                    if (groups.hasOwnProperty(name))
                        updatedData[name] = groups[name];
                return updatedData
            },
            _getCoordinates: function(dates, resources, allDay) {
                var result = [];
                for (var i = 0; i < dates.length; i++)
                    result = result.concat(this._workSpace.getCoordinatesByDateInGroup(dates[i], resources, allDay));
                return result
            },
            subsribe: function(subject, action) {
                this._subscribes[subject] = ui.dxScheduler.subscribes[subject] = action
            },
            fire: function(subject, args) {
                var callback = this._subscribes[subject];
                if (!$.isFunction(callback))
                    throw DX.Error("E1031", subject);
                callback.call(this, args)
            },
            getTargetCellData: function() {
                return this._workSpace.getDataByDroppableCell()
            },
            showAppointmentTooltip: function(appointmentData, $appointment) {
                ui.dxScheduler.tooltip.show(appointmentData, $appointment, this)
            },
            _hideTooltip: function() {
                ui.dxScheduler.tooltip.hide()
            },
            _executeActionWhenOperationIsCompleted: function(action, appointment, e) {
                var options = {appointment: appointment},
                    isError = e && e.name === "Error";
                if (isError)
                    options.error = e;
                action(options)
            },
            _processActionResult: function(actionOptions, callback) {
                $.when(actionOptions.cancel).then($.proxy(callback, this))
            },
            _updateAppointment: function(target, appointment, onUpdatePrevented) {
                var updatingOptions = {
                        newData: appointment,
                        oldData: target,
                        cancel: false
                    };
                this._actions["onAppointmentUpdating"](updatingOptions);
                this._processActionResult(updatingOptions, function(canceled) {
                    if (!canceled)
                        this._appointmentModel.update(target, appointment).always($.proxy(function(e) {
                            this._executeActionWhenOperationIsCompleted(this._actions["onAppointmentUpdated"], appointment, e)
                        }, this));
                    else if ($.isFunction(onUpdatePrevented))
                        onUpdatePrevented.call(this)
                })
            },
            showAppointmentPopup: function(appointmentData) {
                this._createPopup();
                this._popup.show();
                this._appointmentView.option("values", appointmentData)
            },
            getAppointmentDetailsView: function() {
                return this._appointmentView
            },
            getAppointmentsInstance: function() {
                return this._appointments
            },
            getAppointmentResourceData: function(field, value) {
                return this._resourcesManager.getResourceDataByValue(field, value)
            },
            getActions: function() {
                return this._actions
            },
            appointmentTakesAllDay: function(appointment) {
                var etalonDayDurationInHours = this.option("endDayHour") - this.option("startDayHour"),
                    appointmentDurationInHours = (appointment.endDate.getTime() - appointment.startDate.getTime()) / 3600000;
                return appointmentDurationInHours >= etalonDayDurationInHours
            },
            scrollToTime: function(hours, minutes) {
                if (this.option("currentView") === "month")
                    return;
                var currentDate = new Date(this.option("currentDate")),
                    scrollable = this._workSpace.getScrollable(),
                    startDayHour = this.option("startDayHour"),
                    endDayHour = this.option("endDayHour"),
                    coordinates;
                if (hours < startDayHour)
                    hours = startDayHour;
                if (hours >= endDayHour)
                    hours = endDayHour - 1;
                currentDate.setHours(hours);
                currentDate.setMinutes(minutes);
                coordinates = this._workSpace.getCoordinatesByDate(currentDate);
                scrollable.scrollBy(coordinates.top - scrollable.scrollTop())
            },
            addAppointment: function(appointment) {
                if (!appointment.text)
                    appointment.text = "";
                var addingOptions = {
                        appointment: appointment,
                        cancel: false
                    };
                this._actions["onAppointmentAdding"](addingOptions);
                this._processActionResult(addingOptions, function(canceled) {
                    if (!canceled)
                        this._appointmentModel.add(appointment).always($.proxy(function(e) {
                            this._executeActionWhenOperationIsCompleted(this._actions["onAppointmentAdded"], appointment, e)
                        }, this))
                })
            },
            updateAppointment: function(target, appointment) {
                this._updateAppointment(target, appointment)
            },
            deleteAppointment: function(appointment) {
                var deletingOptions = {
                        appointment: appointment,
                        cancel: false
                    };
                this._actions["onAppointmentDeleting"](deletingOptions);
                this._processActionResult(deletingOptions, function(canceled) {
                    if (!canceled)
                        this._appointmentModel.remove(appointment).always($.proxy(function(e) {
                            this._executeActionWhenOperationIsCompleted(this._actions["onAppointmentDeleted"], appointment, e)
                        }, this))
                })
            }
        }).include(ui.DataHelperMixin))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.subscribes.js */
    (function($, DX, undefined) {
        DX.ui.dxScheduler.subscribes = {
            currentViewUpdated: function(currentView) {
                this.option("currentView", currentView)
            },
            needCoordinates: function(options) {
                var appointmentData = options.appointmentData,
                    startDate = options.startDate,
                    dateRange = this._workSpace.getDateRange(),
                    dates = DX.utils.getDatesByRecurrence(appointmentData.recurrenceRule, startDate, dateRange[0], dateRange[1]);
                if (!dates.length)
                    dates.push(startDate);
                var itemResources = this._resourcesManager.getResourcesFromItem(appointmentData);
                options.callback(this._getCoordinates(dates, itemResources, appointmentData.allDay))
            },
            showEditAppointmentPopup: function(appointmentData) {
                this._editAppointmentData = appointmentData;
                this.showAppointmentPopup(appointmentData)
            },
            showAppointmentTooltip: function(options) {
                this._editAppointmentData = options.data;
                this.showAppointmentTooltip(options.data, options.target)
            },
            hideAppointmentTooltip: function() {
                this._hideTooltip()
            },
            showAddAppointmentPopup: function(appointmentData) {
                delete this._editAppointmentData;
                if (this.option("editing"))
                    this.showAppointmentPopup(appointmentData)
            },
            deleteAppointment: function(appointmentData) {
                this._checkRecurringAppointment(appointmentData.recurrenceRule, $.proxy(function() {
                    this.deleteAppointment(appointmentData)
                }, this), true)
            },
            updateAppointmentAfterResize: function(options) {
                this._checkRecurringAppointment(options.target.recurrenceRule, $.proxy(function() {
                    this._updateAppointment(options.target, options.data, function() {
                        this._appointments.moveAppointmentBack()
                    })
                }, this))
            },
            updateAppointmentAfterDrag: function(options) {
                var target = options.data,
                    updatedData = this._getUpdatedData(options),
                    allDayContainerClass = this._workSpace.getAllDayContainerClass(),
                    newCellIndex = this._workSpace.getDroppableCellIndex(),
                    oldCellIndex = this._workSpace.getCellIndexByCoordinates(options.coordinates);
                if (options.$appointment.parent().hasClass(allDayContainerClass) && !updatedData.allDay)
                    updatedData.endDate = this._workSpace._calculateEndDate(updatedData.startDate);
                var appointment = $.extend({}, target, updatedData);
                var isAllDay = target.allDay || updatedData.allDay;
                if (newCellIndex !== oldCellIndex || isAllDay)
                    this._checkRecurringAppointment(target.recurrenceRule, $.proxy(function() {
                        this._updateAppointment(target, appointment, function() {
                            this._appointments.moveAppointmentBack()
                        })
                    }, this));
                else
                    this._appointments.moveAppointmentBack()
            },
            updateCurrentDate: function(date) {
                this.option("currentDate", this._stripDateTime(DX.utils.makeDate(date)))
            },
            getAppointmentColor: function(options) {
                var resourceForPainting = this._resourcesManager.getResourceForPainting(this.option("groups")),
                    response = $.Deferred().resolve().promise();
                if (resourceForPainting) {
                    var field = resourceForPainting.field;
                    if (options.itemData[field]) {
                        var resourceValues = DX.utils.wrapToArray(options.itemData[field]),
                            resourceIndex = options.resourceIndex,
                            groups = this.option("groups");
                        if (!groups || !groups.length)
                            resourceIndex = 0;
                        response = this._resourcesManager.getResourceColor(field, resourceValues[resourceIndex])
                    }
                }
                options.callback(response)
            },
            getResourceForPainting: function(options) {
                options.callback(this._resourcesManager.getResourceForPainting(this.option("groups")))
            },
            getResourcesFromItem: function(options) {
                options.callback(this._resourcesManager.getResourcesFromItem(options.itemData))
            },
            getCellDimensions: function(options) {
                if (this._workSpace)
                    options.callback(this._workSpace.getCellWidth(), this._workSpace.getCellHeight(), this._workSpace.getAllDayHeight())
            },
            initAppointmentRenderedAction: function(options) {
                options.callback(this._initAppointmentRenderedAction())
            },
            getMaxAllowedPosition: function(options) {
                if (this._workSpace)
                    options.callback(this._workSpace.getMaxAllowedPosition())
            },
            getItemGroupIndexes: function(options) {
                var groups = this._resourcesManager.getResourcesFromItem(options.item),
                    indexes = this._workSpace._getGroupIndexes(groups);
                options.callback(indexes)
            },
            appointmentTakesAllDay: function(options) {
                options.callback(this.appointmentTakesAllDay({
                    startDate: options.startDate,
                    endDate: options.endDate
                }))
            },
            checkContainerVisibility: function(options) {
                options.callback(this.element().is(":hidden"))
            },
            getResizableAppointmentArea: function(options) {
                var area;
                if (this.option("groups") && this.option("groups").length && (options.allDay || this.option("currentView") === "month")) {
                    var groupBounds = this._workSpace.getGroupBounds(options.coordinates, options.allDay);
                    area = {
                        left: groupBounds.left,
                        right: groupBounds.right,
                        top: 0,
                        bottom: 0
                    }
                }
                options.callback(area)
            },
            normalizeAppointmentDates: function(options) {
                var appointmentData = options.appointmentData;
                var startDate = DX.utils.makeDate(appointmentData.startDate),
                    endDate = DX.utils.makeDate(appointmentData.endDate);
                appointmentData.startDate = startDate;
                appointmentData.endDate = endDate;
                options.callback(appointmentData)
            },
            formatDates: function(options) {
                var startDate = options.startDate,
                    endDate = options.endDate,
                    formatType = options.formatType;
                var formatTypes = {
                        DATETIME: function() {
                            var dateTimeFormat = "MMMM d h:mm tt",
                                startDateString = Globalize.format(startDate, dateTimeFormat) + " - ";
                            var endDateString = startDate.getDate() === endDate.getDate() ? Globalize.format(endDate, "t") : Globalize.format(endDate, dateTimeFormat);
                            return startDateString + endDateString
                        },
                        TIME: function() {
                            return Globalize.format(startDate, "t") + " - " + Globalize.format(endDate, "t")
                        }
                    };
                options.callback(formatTypes[formatType]())
            },
            renderDropDownAppointments: function(options) {
                DX.ui.dxScheduler.dropDownAppointments.render(options, this)
            },
            updateAppointmentStartDate: function(options) {
                var firstViewDate = this._workSpace.getFirstViewDate(),
                    updatedStartDate = DX.utils.normalizeDate(options.startDate, firstViewDate);
                options.callback(updatedStartDate)
            }
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.appointmentTooltip.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            APPOINTMENT_TOOLTIP_CLASS = "dx-scheduler-appointment-tooltip",
            APPOINTMENT_TOOLTIP_TITLE_CLASS = "dx-scheduler-appointment-tooltip-title",
            APPOINTMENT_TOOLTIP_DATE_CLASS = "dx-scheduler-appointment-tooltip-date",
            APPOINTMENT_TOOLTIP_BUTTONS_CLASS = "dx-scheduler-appointment-tooltip-buttons";
        ui.dxScheduler.tooltip = {
            show: function(appointmentData, $appointment, instance) {
                this.instance = instance;
                var that = this,
                    isAllDay = instance.appointmentTakesAllDay(appointmentData) || appointmentData.allDay;
                ui.tooltip.show({
                    target: $appointment,
                    rtlEnabled: instance.option("rtlEnabled"),
                    contentTemplate: function($content) {
                        var $tooltip = that._tooltipContent(appointmentData);
                        $tooltip.addClass($content.attr("class"));
                        $content.replaceWith($tooltip)
                    },
                    position: {
                        my: "bottom",
                        at: "top",
                        of: $appointment,
                        boundary: isAllDay ? instance.element() : instance.getWorkSpaceScrollableContainer(),
                        collision: "fit flipfit"
                    }
                })
            },
            hide: function() {
                ui.tooltip.hide()
            },
            _tooltipContent: function(appointmentData) {
                var $tooltip = $("<div>").addClass(APPOINTMENT_TOOLTIP_CLASS);
                $("<div>").text(appointmentData.text).addClass(APPOINTMENT_TOOLTIP_TITLE_CLASS).appendTo($tooltip);
                $("<div>").addClass(APPOINTMENT_TOOLTIP_DATE_CLASS).text(this._formatTooltipDate(appointmentData.startDate, appointmentData.endDate)).appendTo($tooltip);
                var $buttons = $("<div>").addClass(APPOINTMENT_TOOLTIP_BUTTONS_CLASS).appendTo($tooltip);
                if (this.instance.option("editing"))
                    this._getDeleteButton(appointmentData).appendTo($buttons);
                this._getOpenButton(appointmentData).appendTo($buttons);
                return $tooltip
            },
            _formatTooltipDate: function(startDate, endDate) {
                var fotmatType = this.instance.option("currentView") === "month" ? "DATETIME" : "TIME",
                    formattedString = "";
                this.instance.fire("formatDates", {
                    startDate: startDate,
                    endDate: endDate,
                    formatType: fotmatType,
                    callback: function(result) {
                        formattedString = result
                    }
                });
                return formattedString
            },
            _getDeleteButton: function(appointmentData) {
                var that = this;
                return $("<div>").dxButton({
                        icon: "trash",
                        onClick: function() {
                            that.instance._checkRecurringAppointment(appointmentData.recurrenceRule, function() {
                                that.instance.deleteAppointment(appointmentData)
                            }, true);
                            that.hide()
                        }
                    })
            },
            _getOpenButton: function(appointmentData) {
                var that = this;
                return $("<div>").dxButton({
                        icon: that.instance.option("editing") ? "edit" : "",
                        text: Globalize.localize("dxScheduler-openAppointment"),
                        onClick: function() {
                            that.instance.showAppointmentPopup(appointmentData)
                        }
                    })
            }
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.appointmentModel.js */
    (function($, DX, undefined) {
        var utils = DX.utils;
        var AppointmentModel = DX.Class.inherit({
                _resourceFilter: function(itemData, resources) {
                    var result = true;
                    for (var i = 0, len = resources.length; i < len; i++) {
                        var resourceField = resources[i].field,
                            resourceData = resources[i].data;
                        if (itemData.hasOwnProperty(resourceField))
                            if (!$.isArray(itemData[resourceField])) {
                                if ($.inArray(itemData[resourceField], resourceData) === -1) {
                                    result = false;
                                    break
                                }
                            }
                            else {
                                result = false;
                                for (var j = 0, itemDataCount = itemData[resourceField].length; j < itemDataCount; j++)
                                    if ($.inArray(itemData[resourceField][j], resourceData) > -1) {
                                        result = true;
                                        break
                                    }
                            }
                        else {
                            result = false;
                            break
                        }
                    }
                    return result
                },
                ctor: function(dataSource) {
                    this.setDataSource(dataSource)
                },
                setDataSource: function(dataSource) {
                    this._dataSource = dataSource
                },
                filterByDate: function(min, max, startDayHour, endDayHour) {
                    if (!this._dataSource)
                        return;
                    var filter = this._prepareDateFilter(min, max, startDayHour, endDayHour);
                    this._dataSource.filter(filter)
                },
                _prepareDateFilter: function(min, max, startDayHour, endDayHour) {
                    var ds = this._dataSource,
                        that = this;
                    return function(itemData) {
                            if ($.isFunction(ds._mapFunc))
                                itemData = ds._mapFunc(itemData);
                            var startDate = utils.makeDate(itemData.startDate),
                                endDate = that._getEndDate(startDate, itemData.endDate),
                                rule = itemData.recurrenceRule,
                                isAllDay = itemData.allDay;
                            var stripDateTime = function(date) {
                                    date = new Date(date);
                                    utils.correctDateWithUnitBeginning(date, "day");
                                    return date
                                };
                            var isRecurrenceRuleValid = utils.getRecurrenceRule(rule).isValid;
                            var result = endDate > min && startDate <= max && !isRecurrenceRuleValid || utils.dateInRange(startDate, stripDateTime(min), max) && isAllDay || utils.dateInRecurrenceRange(rule, startDate, min, max);
                            if (result && startDayHour)
                                result = startDate.getHours() >= startDayHour || endDate.getHours() >= startDayHour || isAllDay;
                            if (result && endDayHour)
                                result = startDate.getHours() <= endDayHour || isAllDay;
                            return result
                        }
                },
                _getEndDate: function(startDate, endDate) {
                    if (!utils.isDefined(endDate))
                        endDate = new Date(startDate.getTime() + 0.5 * 3600000);
                    return utils.makeDate(endDate)
                },
                filterByResources: function(resources) {
                    if (!this._dataSource)
                        return;
                    var filter = this._prepareResourcesFilter(resources);
                    this._dataSource.filter(filter)
                },
                _prepareResourcesFilter: function(resources) {
                    return $.proxy(function(itemData) {
                            return this._resourceFilter(itemData, resources)
                        }, this)
                },
                filterByDateAndResources: function(options) {
                    if (!this._dataSource)
                        return;
                    this._dataSource.filter($.proxy(function(itemData) {
                        var dateFilter = this._prepareDateFilter(options.min, options.max, options.startDayHour, options.endDayHour),
                            resourceFilter = this._prepareResourcesFilter(options.resources);
                        return dateFilter(itemData) && resourceFilter(itemData)
                    }, this))
                },
                add: function(data) {
                    return this._dataSource.store().insert(data).done($.proxy(function() {
                            this._dataSource.load()
                        }, this))
                },
                update: function(target, data) {
                    return this._dataSource.store().update(target, data).done($.proxy(function() {
                            this._dataSource.load()
                        }, this))
                },
                remove: function(target) {
                    var store = this._dataSource.store(),
                        key = store.keyOf(target);
                    return this._dataSource.store().remove(key).done($.proxy(function() {
                            this._dataSource.load()
                        }, this))
                }
            });
        DX.ui.dxScheduler.dxSchedulerAppointmentModel = AppointmentModel
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.recurrenceEditor.js */
    (function($, DX, undefined) {
        var utils = DX.utils;
        var RECURRENCE_EDITOR = "dx-recurrence-editor",
            LABEL_PREFIX = "-label",
            RECURRENCE_EDITOR_CONTAINER = "dx-recurrence-editor-container",
            SWITCH_EDITOR = "dx-recurrence-switch",
            SWITCH_REPEAT_END_EDITOR = "dx-recurrence-switch-repeat-end",
            FREQUENCY_EDITOR = "dx-recurrence-radiogroup-freq",
            INTERVAL_EDITOR = "dx-recurrence-numberbox-interval",
            INTERVAL_EDITOR_FIELD = "dx-recurrence-interval-field",
            REPEAT_END_EDITOR = "dx-recurrence-repeat-end",
            REPEAT_END_EDITOR_FIELD = "dx-recurrence-repeat-end-field",
            REPEAT_END_EDITOR_CONTAINER = "dx-recurrence-repeat-end-container",
            REPEAT_TYPE_EDITOR = "dx-recurrence-radiogroup-repeat-type",
            REPEAT_COUNT_EDITOR = "dx-recurrence-numberbox-repeat-count",
            REPEAT_UNTIL_DATE_EDITOR = "dx-recurrence-datebox-until-date",
            REPEAT_ON_EDITOR = "dx-recurrence-repeat-on",
            REPEAT_ON_WEEK_EDITOR = "dx-recurrence-repeat-on-week",
            DAY_OF_WEEK = "dx-recurrence-checkbox-day-of-week",
            REPEAT_ON_MONTH_EDITOR = "dx-recurrence-repeat-on-month",
            DAY_OF_MONTH = "dx-recurrence-numberbox-day-of-month",
            REPEAT_ON_YEAR_EDITOR = "dx-recurrence-repeat-on-year",
            MONTH_OF_YEAR = "dx-recurrence-selectbox-month-of-year",
            FIELD_CLASS = "dx-field",
            FIELD_LABEL_CLASS = "dx-field-label",
            FIELD_VALUE_CLASS = "dx-field-value",
            frequencies = [{
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceDaily")
                    },
                    value: "DAILY"
                }, {
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceWeekly")
                    },
                    value: "WEEKLY"
                }, {
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceMonthly")
                    },
                    value: "MONTHLY"
                }, {
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceYearly")
                    },
                    value: "YEARLY"
                }],
            repeatEndTypes = [{
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceRepeatCount")
                    },
                    value: "count"
                }, {
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceRepeatOnDate")
                    },
                    value: "until"
                }];
        var RecurrenceRule = DX.Class.inherit({
                ctor: function(recurrence) {
                    this._recurrenceRule = DX.utils.getRecurrenceRule(recurrence).rule
                },
                makeRules: function(string) {
                    var that = this;
                    that._recurrenceRule = utils.getRecurrenceRule(string).rule
                },
                makeRule: function(field, value) {
                    if (!value) {
                        delete this._recurrenceRule[field];
                        return
                    }
                    if (utils.isDefined(field)) {
                        if (field === "until")
                            delete this._recurrenceRule.count;
                        if (field === "count")
                            delete this._recurrenceRule.until;
                        this._recurrenceRule[field] = value
                    }
                },
                repeatableRule: function() {
                    var rules = this._recurrenceRule;
                    if ("count" in rules)
                        return "count";
                    if ("until" in rules)
                        return "until";
                    return null
                },
                recurrenceString: function() {
                    return utils.getRecurrenceString(this._recurrenceRule)
                },
                rules: function() {
                    return this._recurrenceRule
                },
                daysFromByDayRule: function() {
                    return utils.daysFromByDayRule(this._recurrenceRule)
                }
            });
        DX.registerComponent("dxSchedulerRecurrenceEditor", DX.ui.dxScheduler, DX.ui.Editor.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    value: null,
                    onValueChanged: null,
                    startDate: new Date
                })
            },
            _createComponent: function(element, name, config) {
                config = config || {};
                this._extendConfig(config, {readOnly: this.option("readOnly")});
                return this.callBase(element, name, config)
            },
            _init: function() {
                this.callBase();
                this._recurrenceRule = new RecurrenceRule(this.option("value"))
            },
            _render: function() {
                this.callBase();
                this.element().addClass(RECURRENCE_EDITOR);
                this._renderSwitch();
                this._$container = $("<div>").addClass(RECURRENCE_EDITOR_CONTAINER).appendTo(this.element());
                this._renderEditors();
                this._renderContainerVisibility()
            },
            _renderSwitch: function() {
                var $switchEditor = $("<div>").addClass(SWITCH_EDITOR);
                this._switchEditor = this._createComponent($switchEditor, "dxSwitch", {
                    value: false,
                    onValueChanged: $.proxy(this._switchValueChangeHandler, this)
                });
                this.element().append($switchEditor)
            },
            _switchValueChangeHandler: function(args) {
                var value = args.value;
                this._renderContainerVisibility(value);
                if (!this.option("value") && value)
                    this._handleDefaults();
                else if (!value) {
                    this._recurrenceRule.makeRules("");
                    this.option("value", "")
                }
            },
            _renderContainerVisibility: function(value) {
                if (value) {
                    this._$container.show();
                    DX.utils.triggerShownEvent(this._$container)
                }
                else
                    this._$container.hide()
            },
            _handleDefaults: function() {
                this._recurrenceRule.makeRule("freq", "DAILY");
                this.option("value", this._recurrenceRule.recurrenceString())
            },
            _renderEditors: function() {
                this._renderFreqEditor();
                this._renderIntervalEditor();
                this._renderRepeatOnEditor();
                this._renderRepeatEndSwitch();
                this._renderRepeatEndEditor();
                this._renderRepeatEndVisibility()
            },
            _renderFreqEditor: function() {
                var freq = this._recurrenceRule.rules().freq || "DAILY";
                var $freqEditor = $("<div>").addClass(FREQUENCY_EDITOR).addClass(FIELD_VALUE_CLASS);
                this._freqEditor = this._createComponent($freqEditor, "dxRadioGroup", {
                    field: "freq",
                    items: frequencies,
                    value: freq,
                    valueExpr: "value",
                    displayExpr: "text",
                    layout: "horizontal",
                    onValueChanged: $.proxy(this._valueChangedHandler, this)
                });
                var $field = $("<div>").addClass(FIELD_CLASS).append($freqEditor);
                this._$container.append($field)
            },
            _renderIntervalEditor: function() {
                var freq = this._recurrenceRule.rules().freq || "DAILY";
                var $intervalEditor = $("<div>").addClass(INTERVAL_EDITOR).addClass(FIELD_VALUE_CLASS);
                var $intervalEditorLabel = $("<div>").text(Globalize.localize("dxScheduler-recurrenceEvery") + ":").addClass(INTERVAL_EDITOR + LABEL_PREFIX).addClass(FIELD_LABEL_CLASS);
                this._$intervalTypeLabel = $("<div>").text(Globalize.localize("dxScheduler-recurrenceRepeat" + freq.charAt(0).toUpperCase() + freq.substr(1).toLowerCase())).addClass(REPEAT_TYPE_EDITOR + LABEL_PREFIX);
                var interval = this._recurrenceRule.rules().interval || 1;
                this._intervalEditor = this._createComponent($intervalEditor, "dxNumberBox", {
                    field: "interval",
                    min: 1,
                    value: interval,
                    showSpinButtons: true,
                    useTouchSpinButtons: false,
                    onValueChanged: $.proxy(this._valueChangedHandler, this)
                });
                var $field = $("<div>").addClass(FIELD_CLASS).addClass(INTERVAL_EDITOR_FIELD).append($intervalEditorLabel, $intervalEditor, this._$intervalTypeLabel);
                this._$container.append($field);
                this._setAriaDescribedBy(this._intervalEditor, $intervalEditorLabel)
            },
            _renderRepeatOnEditor: function() {
                var freq = this._recurrenceRule.rules().freq;
                if (!utils.isDefined(this._$repeatOnEditor))
                    this._$repeatOnEditor = $("<div>").addClass(REPEAT_ON_EDITOR).addClass(FIELD_CLASS).appendTo(this._$container);
                if (!freq || freq === "DAILY") {
                    this._clearRepeatOnEditor();
                    this._clearRepeatOnLabel();
                    return
                }
                if (!utils.isDefined(this._$repeatOnLabel))
                    this._renderRepeatOnLabel(this._$repeatOnEditor);
                if (freq === "WEEKLY" && !this._$repeatOnWeek) {
                    this._renderRepeatOnWeekEditor();
                    return
                }
                if (freq === "MONTHLY" && !this._$repeatOnMonth) {
                    this._renderRepeatOnMonthEditor();
                    return
                }
                if (freq === "YEARLY" && !this._$repeatOnYear) {
                    this._renderRepeatOnYearEditor();
                    return
                }
            },
            _renderRepeatOnLabel: function($element) {
                this._$repeatOnLabel = $("<div>").text(Globalize.localize("dxScheduler-recurrenceOn") + ":").addClass(REPEAT_ON_EDITOR + LABEL_PREFIX).addClass(FIELD_LABEL_CLASS);
                $element.append(this._$repeatOnLabel)
            },
            _clearRepeatOnEditor: function() {
                if (utils.isDefined(this._$repeatOnWeek)) {
                    this._$repeatOnWeek.detach();
                    this._$repeatOnWeek.remove();
                    delete this._$repeatOnWeek
                }
                if (utils.isDefined(this._$repeatOnMonth)) {
                    this._$repeatOnMonth.detach();
                    this._$repeatOnMonth.remove();
                    delete this._$repeatOnMonth
                }
                if (utils.isDefined(this._$repeatOnYear)) {
                    this._$repeatOnYear.detach();
                    this._$repeatOnYear.remove();
                    delete this._$repeatOnYear
                }
            },
            _clearRepeatOnEditorValues: function() {
                this._recurrenceRule.makeRule("bymonth", "");
                this._recurrenceRule.makeRule("bymonthday", "");
                this._recurrenceRule.makeRule("byday", "")
            },
            _clearRepeatOnLabel: function() {
                if (utils.isDefined(this._$repeatOnLabel)) {
                    this._$repeatOnLabel.detach();
                    this._$repeatOnLabel.remove();
                    delete this._$repeatOnLabel
                }
            },
            _renderRepeatOnWeekEditor: function() {
                this._clearRepeatOnEditor();
                this._$repeatOnWeek = $("<div>").addClass(REPEAT_ON_WEEK_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo(this._$repeatOnEditor);
                var days = Globalize.culture().calendar.days.namesShort,
                    daysFromRules = this._daysOfWeekByRules();
                this._daysOfWeek = [];
                for (var i = 0; i < 7; i++) {
                    var checkBoxText = days[i].toUpperCase();
                    var $day = $("<div>").addClass(DAY_OF_WEEK),
                        day = this._createComponent($day, "dxCheckBox", {
                            text: checkBoxText,
                            value: $.inArray(checkBoxText, daysFromRules) > -1 ? true : false,
                            onValueChanged: $.proxy(this._repeatByDayValueChangeHandler, this)
                        });
                    this._daysOfWeek[i] = day;
                    this._$repeatOnWeek.append($day)
                }
            },
            _daysOfWeekByRules: function() {
                var days = Globalize.culture().calendar.days.namesShort;
                var daysByRule = this._recurrenceRule.daysFromByDayRule();
                if (!daysByRule.length)
                    daysByRule = [days[this.option("startDate").getDay()].toUpperCase()];
                return daysByRule
            },
            _repeatByDayValueChangeHandler: function() {
                var byDayRule = "";
                $.each(this._daysOfWeek, function(index, day) {
                    if (day.option("value")) {
                        var dayName = day.option("text");
                        if (!byDayRule)
                            byDayRule = dayName;
                        else
                            byDayRule = byDayRule + "," + dayName
                    }
                });
                this._recurrenceRule.makeRule("byday", byDayRule);
                this.option("value", this._recurrenceRule.recurrenceString())
            },
            _renderRepeatOnMonthEditor: function() {
                this._clearRepeatOnEditor();
                this._$repeatOnMonth = $("<div>").addClass(REPEAT_ON_MONTH_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo(this._$repeatOnEditor);
                this._renderDayOfMonthEditor(this._$repeatOnMonth)
            },
            _renderRepeatOnYearEditor: function() {
                this._clearRepeatOnEditor();
                this._$repeatOnYear = $("<div>").addClass(REPEAT_ON_YEAR_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo(this._$repeatOnEditor);
                var months = [],
                    monthsNames = Globalize.culture().calendar.months.names;
                for (var i = 0; i < 12; i++)
                    months[i] = {
                        value: String(i + 1),
                        text: monthsNames[i]
                    };
                var bymonth = this._monthOfYearByRules();
                var $monthOfYear = $("<div>").addClass(MONTH_OF_YEAR).appendTo(this._$repeatOnYear);
                var monthChanged = function(args) {
                        this._valueChangedHandler.call(this, args);
                        var monthValue = parseInt(args.component.option("value"));
                        if (this._dayEditor && monthValue) {
                            var maxAllowedDay = new Date((new Date).getFullYear(), parseInt(monthValue), 0).getDate();
                            if (monthValue === 2)
                                maxAllowedDay = 29;
                            this._dayEditor.option("max", maxAllowedDay)
                        }
                    };
                this._monthEditor = this._createComponent($monthOfYear, "dxSelectBox", {
                    field: "bymonth",
                    items: months,
                    value: bymonth,
                    displayExpr: "text",
                    valueExpr: "value",
                    onValueChanged: $.proxy(monthChanged, this)
                });
                this._renderDayOfMonthEditor(this._$repeatOnYear)
            },
            _monthOfYearByRules: function() {
                var monthByRule = this._recurrenceRule.rules().bymonth;
                if (!monthByRule)
                    monthByRule = this.option("startDate").getMonth();
                return monthByRule
            },
            _renderDayOfMonthEditor: function($element) {
                var bymonthday = this._dayOfMonthByRules();
                var $dayEditor = $("<div>").addClass(DAY_OF_MONTH);
                this._dayEditor = this._createComponent($dayEditor, "dxNumberBox", {
                    field: "bymonthday",
                    min: 1,
                    max: 31,
                    showSpinButtons: true,
                    useTouchSpinButtons: false,
                    value: bymonthday,
                    onValueChanged: $.proxy(this._valueChangedHandler, this)
                });
                $element.append($dayEditor)
            },
            _dayOfMonthByRules: function() {
                var dayByRule = this._recurrenceRule.rules().bymonthday;
                if (!dayByRule)
                    dayByRule = this.option("startDate").getDate();
                return dayByRule
            },
            _setAriaDescribedBy: function(editor, $label) {
                var labelId = "label-" + new DevExpress.data.Guid;
                editor.setAria("describedby", labelId);
                editor.setAria("id", labelId, $label)
            },
            _renderRepeatEndSwitch: function() {
                var that = this;
                var $switchEndEditor = $("<div>").addClass(SWITCH_REPEAT_END_EDITOR).addClass(FIELD_VALUE_CLASS),
                    $switchEndLabel = $("<div>").text(Globalize.localize("dxScheduler-recurrenceEnd") + ":").addClass(INTERVAL_EDITOR + LABEL_PREFIX).addClass(FIELD_LABEL_CLASS);
                this._switchEndEditor = this._createComponent($switchEndEditor, "dxSwitch", {
                    value: that._recurrenceRule.repeatableRule() ? true : false,
                    onValueChanged: $.proxy(this._repeatEndSwitchValueChangeHandler, this)
                });
                $("<div>").addClass(FIELD_CLASS).addClass(REPEAT_END_EDITOR_FIELD).append($switchEndLabel, $switchEndEditor).appendTo(this._$container);
                this._setAriaDescribedBy(this._switchEndEditor, $switchEndLabel)
            },
            _repeatEndSwitchValueChangeHandler: function(args) {
                var value = args.value;
                this._renderRepeatEndVisibility(value);
                if (!this._recurrenceRule.rules().count && !this._recurrenceRule.rules().until && value)
                    this._handleRepeatEndDefaults();
                else if (!value) {
                    this._recurrenceRule.makeRule("count", "");
                    this._recurrenceRule.makeRule("until", "");
                    this.option("value", this._recurrenceRule.recurrenceString())
                }
            },
            _renderRepeatEndVisibility: function(value) {
                if (!value)
                    this._$repeatEndEditor.hide();
                else
                    this._$repeatEndEditor.show()
            },
            _handleRepeatEndDefaults: function() {
                this._recurrenceRule.makeRule("count", 1);
                this.option("value", this._recurrenceRule.recurrenceString())
            },
            _renderRepeatEndEditor: function(rule) {
                rule = utils.isDefined(rule) ? rule : this._recurrenceRule.repeatableRule();
                if (!rule)
                    rule = "count";
                if (!utils.isDefined(this._$repeatEndEditor)) {
                    this._$repeatEndEditor = $("<div>").addClass(REPEAT_END_EDITOR_CONTAINER).addClass(FIELD_CLASS).appendTo(this._$container);
                    this._renderRepeatEndTypeEditor()
                }
            },
            _renderRepeatEndTypeEditor: function() {
                var repeatType = this._recurrenceRule.repeatableRule() || "count",
                    that = this;
                this._$repeatTypeEditor = $("<div>").addClass(REPEAT_TYPE_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo(this._$repeatEndEditor);
                this._repeatTypeEditor = this._createComponent(this._$repeatTypeEditor, "dxRadioGroup", {
                    items: repeatEndTypes,
                    value: repeatType,
                    displayExpr: "text",
                    valueExpr: "value",
                    itemTemplate: function(itemData) {
                        if (itemData.value === "count")
                            return that._renderRepeatCountEditor();
                        else
                            return that._renderRepeatUntilEditor()
                    },
                    layout: "vertical",
                    onValueChanged: $.proxy(this._repeatTypeValueChangedHandler, this)
                });
                this._disableRepeatEndParts(repeatType)
            },
            _repeatTypeValueChangedHandler: function(args) {
                var value = args.value;
                this._disableRepeatEndParts(value);
                if (value === "until")
                    this._recurrenceRule.makeRule(value, utils.getAsciiStringByDate(this._repeatUntilDate.option("value")));
                else if (value === "count")
                    this._recurrenceRule.makeRule(value, this._repeatCountEditor.option("value"));
                this.option("value", this._recurrenceRule.recurrenceString())
            },
            _disableRepeatEndParts: function(value) {
                if (value === "until") {
                    this._repeatCountEditor.option("disabled", true);
                    this._repeatUntilDate.option("disabled", false)
                }
                else if (value === "count") {
                    this._repeatCountEditor.option("disabled", false);
                    this._repeatUntilDate.option("disabled", true)
                }
            },
            _renderRepeatCountEditor: function() {
                var repeatCount = this._recurrenceRule.rules().count || 1,
                    $editorTemplate = $("<div>");
                $("<div>").text(Globalize.localize("dxScheduler-recurrenceAfter") + ":").addClass(REPEAT_END_EDITOR + LABEL_PREFIX).appendTo($editorTemplate);
                this._$repeatCountEditor = $("<div>").addClass(REPEAT_COUNT_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo($editorTemplate);
                $("<div>").text(Globalize.localize("dxScheduler-recurrenceRepeatCount")).addClass(REPEAT_END_EDITOR + LABEL_PREFIX).appendTo($editorTemplate);
                this._repeatCountEditor = this._createComponent(this._$repeatCountEditor, "dxNumberBox", {
                    field: "count",
                    min: 1,
                    showSpinButtons: true,
                    useTouchSpinButtons: false,
                    value: repeatCount,
                    onValueChanged: $.proxy(this._repeatCountValueChangeHandler, this)
                });
                return $editorTemplate
            },
            _repeatCountValueChangeHandler: function(args) {
                if (this._recurrenceRule.repeatableRule() !== "count")
                    return;
                var value = args.value;
                this._recurrenceRule.makeRule("count", value);
                this.option("value", this._recurrenceRule.recurrenceString())
            },
            _renderRepeatUntilEditor: function() {
                var repeatUntil = this._recurrenceRule.rules().until || new Date,
                    $editorTemplate = $("<div>");
                $("<div>").text(Globalize.localize("dxScheduler-recurrenceOn") + ":").addClass(REPEAT_END_EDITOR + LABEL_PREFIX).appendTo($editorTemplate);
                this._$repeatDateEditor = $("<div>").addClass(REPEAT_UNTIL_DATE_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo($editorTemplate);
                this._repeatUntilDate = this._createComponent(this._$repeatDateEditor, "dxDateBox", {
                    field: "until",
                    value: repeatUntil,
                    format: "date",
                    onValueChanged: $.proxy(this._repeatUntilValueChangeHandler, this)
                });
                return $editorTemplate
            },
            _repeatUntilValueChangeHandler: function(args) {
                if (this._recurrenceRule.repeatableRule() !== "until")
                    return;
                var value = args.value;
                if (typeof value !== "string")
                    value = utils.getAsciiStringByDate(value);
                this._recurrenceRule.makeRule("until", value);
                this.option("value", this._recurrenceRule.recurrenceString())
            },
            _valueChangedHandler: function(args) {
                var value = args.component.option("value"),
                    field = args.component.option("field");
                if (field === "freq")
                    this._clearRepeatOnEditorValues();
                this._recurrenceRule.makeRule(field, value);
                this.option("value", this._recurrenceRule.recurrenceString() || "");
                this._makeRepeatOnRule(field, value)
            },
            _makeRepeatOnRule: function(field, value) {
                if (field !== "freq" || value === "DAILY")
                    return;
                if (value === "WEEKLY")
                    this._recurrenceRule.makeRule("byday", this._daysOfWeekByRules());
                if (value === "MONTHLY")
                    this._recurrenceRule.makeRule("bymonthday", this._dayOfMonthByRules());
                if (value === "YEARLY") {
                    this._recurrenceRule.makeRule("bymonthday", this._dayOfMonthByRules());
                    this._recurrenceRule.makeRule("bymonth", this._monthOfYearByRules())
                }
                this.option("value", this._recurrenceRule.recurrenceString())
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"value":
                        this._recurrenceRule.makeRules(args.value);
                        this._switchEditor.option("value", !!args.value);
                        this._switchEndEditor.option("value", !!this._recurrenceRule.repeatableRule());
                        this._repeatTypeEditor.option("value", this._recurrenceRule.repeatableRule() || "count");
                        this._renderRepeatEndEditor();
                        this._renderRepeatOnEditor();
                        this._changeEditorsValues(this._recurrenceRule.rules());
                        this.callBase(args);
                        break;
                    case"startDate":
                        this._clearRepeatOnEditor();
                        this._renderRepeatOnEditor();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _changeEditorsValues: function(rules) {
                this._freqEditor.option("value", rules.freq);
                this._changeRepeatTypeLabel();
                this._intervalEditor.option("value", rules.interval);
                this._changeRepeatCountValue();
                this._changeRepeatUntilValue();
                this._changeCheckBoxesValue();
                this._changeDayOfMonthValue();
                this._changeMonthOfYearValue()
            },
            _changeRepeatTypeLabel: function() {
                var $labels = this.element().find("." + REPEAT_TYPE_EDITOR + LABEL_PREFIX);
                if (!$labels.length)
                    return;
                var freq = this._recurrenceRule.rules().freq || "DAILY";
                $.each($labels, function(_, $label) {
                    $($label).text(Globalize.localize("dxScheduler-recurrenceRepeat" + freq.charAt(0).toUpperCase() + freq.substr(1).toLowerCase()))
                })
            },
            _changeRepeatCountValue: function() {
                if (!this._$repeatCountEditor)
                    return;
                var count = this._recurrenceRule.rules().count || 1;
                this._repeatCountEditor.option("value", count)
            },
            _changeRepeatUntilValue: function() {
                if (!this._$repeatDateEditor)
                    return;
                var date = utils.getDateByAsciiString(this._recurrenceRule.rules().until) || new Date;
                this._repeatUntilDate.option("value", date)
            },
            _changeCheckBoxesValue: function() {
                if (!this._$repeatOnWeek)
                    return;
                var daysByRule = this._daysOfWeekByRules();
                $.each(this._daysOfWeek, function(index, day) {
                    day.option("value", $.inArray(day.option("text"), daysByRule) > -1)
                })
            },
            _changeDayOfMonthValue: function() {
                if (!this._$repeatOnMonth && !this._$repeatOnYear)
                    return;
                var day = this._dayOfMonthByRules() || 1;
                this._dayEditor.option("value", day)
            },
            _changeMonthOfYearValue: function() {
                if (!this._$repeatOnYear)
                    return;
                var month = this._monthOfYearByRules() || 1;
                this._monthEditor.option("value", month)
            },
            setAria: function() {
                if (this._switchEditor)
                    this._switchEditor.setAria(arguments[0], arguments[1])
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.appointmentDetailsView.js */
    (function($, DX, undefined) {
        var EDITOR_LABEL_PREFIX = "dx-scheduler-editor-label-",
            FIELD_CLASS = "dx-field",
            FILED_POSTFIX = "-field",
            FIELD_LABEL_CLASS = "dx-field-label",
            FIELD_VALUE_CLASS = "dx-field-value",
            FIELDSET_CLASS = "dx-fieldset";
        var AppointmentDetailsView = DX.DOMComponent.inherit({
                _setDefaultOptions: function() {
                    this.callBase();
                    this.option({
                        values: {},
                        editors: [],
                        readOnly: false
                    })
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"values":
                            this._setEditorValues(args.value);
                            break;
                        case"editors":
                            break;
                        case"readOnly":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _setEditorValues: function(values) {
                    var editors = this.option("editors");
                    for (var i = 0, length = editors.length; i < length; i++) {
                        var editor = editors[i],
                            type = editor.type,
                            $editor = this.element().find("." + editor.cssClass),
                            instance = $editor[type]("instance");
                        if (editor.key === "recurrenceRule")
                            instance.option("startDate", values.startDate);
                        var value = values ? values[editor.key] : null;
                        instance.option(this._getEditorValueOptions(type, value))
                    }
                },
                _render: function() {
                    var editors = this.option("editors");
                    this._$fieldset = $("<div>").addClass(FIELDSET_CLASS);
                    this._scrollable = this._createComponent("<div>", "dxScrollable", {useKeyboard: false});
                    this._scrollable.content().append(this._$fieldset);
                    for (var i = 0, length = editors.length; i < length; i++)
                        this._renderEditor(editors[i]);
                    this.element().append(this._scrollable.element())
                },
                _renderEditor: function(editor) {
                    var scrollable = this._scrollable,
                        values = this.option("values"),
                        key = editor.key,
                        type = editor.type,
                        valueOptions = this._getEditorValueOptions(type, values[key]),
                        options = $.extend(valueOptions, editor.options, {
                            onValueChanged: function(arg) {
                                if (editor.options && editor.options.onValueChanged)
                                    editor.options.onValueChanged(arg);
                                scrollable.update();
                                values[key] = arg.values ? arg.values : arg.value;
                                if (values[key] === undefined)
                                    delete values[key]
                            },
                            readOnly: this.option("readOnly")
                        });
                    var $field = $("<div>").addClass(FIELD_CLASS).addClass(editor.cssClass + FILED_POSTFIX);
                    var labelId = "label-" + new DevExpress.data.Guid;
                    var labelText = Globalize.localize(editor.label) || editor.label,
                        $label = $("<div>").attr("id", labelId).text(labelText + ":").addClass(EDITOR_LABEL_PREFIX + key.toLowerCase()),
                        $editor = $("<div>").addClass(editor.cssClass);
                    var instance = this._createComponent($editor, type, options);
                    instance.setAria("describedby", labelId);
                    $label.addClass(FIELD_LABEL_CLASS);
                    if (key !== "recurrenceRule")
                        $editor.addClass(FIELD_VALUE_CLASS);
                    $field.append($label, $editor);
                    this._$fieldset.append($field)
                },
                _getEditorValueOptions: function(type, value) {
                    var result = {value: value};
                    if (type === "dxTagBox") {
                        var values = value ? DX.utils.wrapToArray(value) : [];
                        result = {values: values}
                    }
                    return result
                },
                getEditorInstance: function(key) {
                    var result = null,
                        editors = this.option("editors");
                    for (var i = 0, length = editors.length; i < length; i++) {
                        var editor = editors[i];
                        if (editor.key === key)
                            result = this.element().find("." + editor.cssClass)[editor.type]("instance")
                    }
                    return result
                }
            });
        DX.ui.dxScheduler.dxSchedulerAppointmentDetailsView = AppointmentDetailsView
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.resourceManager.js */
    (function($, DX, undefined) {
        var utils = DX.utils,
            dataUtils = DX.data.utils;
        var RESOURCE_CLASS_PREFIX = "dx-scheduler-resource-",
            DEFAULT_VALUE_EXPR = "id",
            DEFAULT_DISPLAY_EXPR = "text";
        var ResourceManager = DX.Class.inherit({
                _wrapDataSource: function(dataSource) {
                    if (dataSource instanceof DX.data.DataSource)
                        return dataSource;
                    return new DX.data.DataSource({
                            store: new DevExpress.data.ArrayStore(dataSource),
                            pageSize: 0
                        })
                },
                _mapResourceData: function(resource, data) {
                    var valueGetter = dataUtils.compileGetter(resource.valueExpr || DEFAULT_VALUE_EXPR),
                        displayGetter = dataUtils.compileGetter(resource.displayExpr || DEFAULT_DISPLAY_EXPR);
                    return $.map(data, function(item) {
                            return {
                                    id: valueGetter(item),
                                    text: displayGetter(item)
                                }
                        })
                },
                ctor: function(resources) {
                    this.setResources(resources)
                },
                setResources: function(resources) {
                    this._resources = resources;
                    this._resourceFields = $.map(resources || [], function(resource) {
                        return resource.field
                    })
                },
                getResources: function() {
                    return this._resources || []
                },
                getEditors: function() {
                    var result = [];
                    $.each(this.getResources(), function(i, resource) {
                        result.push({
                            options: {
                                dataSource: resource.dataSource,
                                displayExpr: resource.displayExpr || DEFAULT_DISPLAY_EXPR,
                                valueExpr: resource.valueExpr || DEFAULT_VALUE_EXPR
                            },
                            key: resource.field,
                            type: resource.allowMultiple ? "dxTagBox" : "dxSelectBox",
                            label: resource.label || resource.field,
                            cssClass: RESOURCE_CLASS_PREFIX + resource.field.toLowerCase()
                        })
                    });
                    return result
                },
                getResourceDataByValue: function(field, value) {
                    var result = $.Deferred(),
                        that = this;
                    $.each(this.getResources(), function(_, resource) {
                        if (resource.field === field) {
                            var dataSource = that._wrapDataSource(resource.dataSource);
                            dataSource.filter(resource.valueExpr || DEFAULT_VALUE_EXPR, value);
                            dataSource.load().done(function(data) {
                                result.resolve(data[0])
                            }).fail(function() {
                                result.reject()
                            });
                            return false
                        }
                    });
                    return result.promise()
                },
                getResourcesFromItem: function(itemData) {
                    var that = this,
                        result = null;
                    $.each(itemData, function(name) {
                        if ($.inArray(name, that._resourceFields) > -1) {
                            if (!result)
                                result = {};
                            result[name] = utils.wrapToArray(itemData[name])
                        }
                    });
                    return result
                },
                getResourcesValueByFields: function(groups) {
                    var result = $.Deferred(),
                        that = this,
                        deferreds = [];
                    $.each(this.getResourcesByFields(groups), function(i, resource) {
                        var deferred = $.Deferred();
                        that._wrapDataSource(resource.dataSource).load().done(function(data) {
                            deferred.resolve({
                                name: resource.field,
                                items: that._mapResourceData(resource, data)
                            });
                            deferreds.push(deferred)
                        }).fail(function() {
                            deferred.reject()
                        })
                    });
                    $.when.apply(null, deferreds).done(function() {
                        result.resolve(Array.prototype.slice.call(arguments))
                    }).fail(function() {
                        result.reject()
                    });
                    return result.promise()
                },
                getResourceColor: function(field, value) {
                    var result = $.Deferred(),
                        color;
                    this.getResourceDataByValue(field, value).done(function(data) {
                        if (data)
                            color = data.color;
                        result.resolve(color)
                    }).fail(function() {
                        result.reject()
                    });
                    return result.promise()
                },
                getResourcesByFields: function(fields) {
                    return $.grep(this.getResources(), function(resource) {
                            return $.inArray(resource.field, fields) > -1
                        })
                },
                getResourceForPainting: function(groups) {
                    var resources = this.getResources(),
                        result;
                    $.each(resources, function(index, resource) {
                        if (resource.mainColor) {
                            result = resource;
                            return false
                        }
                    });
                    if (!result) {
                        if ($.isArray(groups) && groups.length)
                            resources = this.getResourcesByFields(groups);
                        result = resources[resources.length - 1]
                    }
                    return result
                }
            });
        DX.ui.dxScheduler.dxSchedulerResourceManager = ResourceManager
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.publisherMixin.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        ui.dxScheduler.PublisherMixin = {notifyObserver: function(subject, args) {
                var observer = this.option("observer");
                if (observer)
                    observer.fire(subject, args)
            }}
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.navigator.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils;
        var ELEMENT_CLASS = "dx-scheduler-navigator",
            CALENDAR_CLASS = "dx-scheduler-navigator-calendar",
            NEXT_BUTTON_CLASS = "dx-scheduler-navigator-next",
            CAPTION_BUTTON_CLASS = "dx-scheduler-navigator-caption",
            PREVIOUS_BUTTON_CLASS = "dx-scheduler-navigator-previous";
        var getWeekCaption = function(date, shift) {
                var firstWeekDate = utils.getFirstWeekDate(date, shift ? this.option("firstDayOfWeek") || 1 : this.option("firstDayOfWeek")),
                    lastWeekDate = new Date(firstWeekDate);
                shift = shift || 6;
                lastWeekDate = new Date(lastWeekDate.setDate(lastWeekDate.getDate() + shift));
                return Globalize.format(firstWeekDate, " d") + "-" + Globalize.format(lastWeekDate, "d MMMM yyyy")
            };
        var CONFIG = {
                day: {
                    duration: 1,
                    setter: "setDate",
                    getter: "getDate",
                    getCaption: function(date) {
                        return Globalize.format(date, "d MMMM yyyy")
                    }
                },
                week: {
                    duration: 7,
                    setter: "setDate",
                    getter: "getDate",
                    getCaption: getWeekCaption
                },
                workWeek: {
                    duration: 7,
                    setter: "setDate",
                    getter: "getDate",
                    getCaption: function(date) {
                        return getWeekCaption.call(this, date, 4)
                    }
                },
                month: {
                    duration: 1,
                    setter: "setMonth",
                    getter: "getMonth",
                    getCaption: function(date) {
                        return Globalize.format(date, "MMMM yyyy")
                    }
                }
            };
        DX.registerComponent("dxSchedulerNavigator", ui.dxScheduler, ui.Widget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    date: new Date,
                    step: "day",
                    min: undefined,
                    max: undefined,
                    firstDayOfWeek: undefined
                })
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"step":
                    case"date":
                        this._updateButtonsState();
                        this._renderCaption();
                        break;
                    case"min":
                    case"max":
                        this._updateButtonsState();
                        this._setCalendarOption(args.name, args.value);
                        break;
                    case"firstDayOfWeek":
                        this._setCalendarOption(args.name, args.value);
                        break;
                    case"tabIndex":
                    case"focusStateEnabled":
                        this._next.option(args.name, args.value);
                        this._caption.option(args.name, args.value);
                        this._prev.option(args.name, args.value);
                        this._setCalendarOption(args.name, args.value);
                        this.callBase(args);
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _init: function() {
                this.callBase();
                this.element().addClass(ELEMENT_CLASS);
                this._initButtons()
            },
            _initButtons: function() {
                var $next = $("<div>").addClass(NEXT_BUTTON_CLASS);
                this._next = this._createComponent($next, "dxButton", {
                    icon: "chevronnext",
                    onClick: $.proxy(this._updateCurrentDate, this, 1),
                    focusStateEnabled: this.option("focusStateEnabled"),
                    tabIndex: this.option("tabIndex"),
                    _templates: {}
                });
                var $caption = $("<div>").addClass(CAPTION_BUTTON_CLASS);
                this._caption = this._createComponent($caption, "dxButton", {
                    focusStateEnabled: this.option("focusStateEnabled"),
                    tabIndex: this.option("tabIndex"),
                    _templates: {}
                });
                var $prev = $("<div>").addClass(PREVIOUS_BUTTON_CLASS);
                this._prev = this._createComponent($prev, "dxButton", {
                    icon: "chevronprev",
                    onClick: $.proxy(this._updateCurrentDate, this, -1),
                    focusStateEnabled: this.option("focusStateEnabled"),
                    tabIndex: this.option("tabIndex"),
                    _templates: {}
                });
                this.setAria("label", "Next period", $next);
                this.setAria("label", "Previous period", $prev);
                this._updateButtonsState();
                this.element().append($prev, $caption, $next)
            },
            _updateButtonsState: function() {
                var config = this._getConfig();
                this._updatePrevButton(config, new Date(this.option("date")));
                this._updateNextButton(config, new Date(this.option("date")))
            },
            _updatePrevButton: function(config, date) {
                var previousDate = date[config.setter](date[config.getter]() - config.duration);
                this._prev.option("disabled", previousDate < this.option("min"))
            },
            _updateNextButton: function(config, date) {
                var nextDate = date[config.setter](date[config.getter]() + config.duration);
                this._next.option("disabled", nextDate > this.option("max"))
            },
            _updateCurrentDate: function(direction) {
                var stepConfig = this._getConfig(),
                    offset = stepConfig.duration * direction,
                    date = new Date(this.option("date"));
                date[stepConfig.setter](date[stepConfig.getter]() + offset);
                date = utils.normalizeDate(date, this.option("min"), this.option("max"));
                this.notifyObserver("updateCurrentDate", date)
            },
            _renderFocusTarget: $.noop,
            _render: function() {
                this.callBase();
                this._renderPopover();
                this._renderCaption();
                this._renderCaptionKeys()
            },
            _renderPopover: function() {
                this._popover = this._createComponent("<div>", "dxPopover", {
                    target: this._caption.element(),
                    onContentReady: $.proxy(this._popoverContentReadyHandler, this)
                });
                this._popover.element().appendTo(this.element())
            },
            _popoverContentReadyHandler: function() {
                this._calendar = this._createComponent($("<div>"), "dxCalendar", this._calendarOptions());
                this._calendar.element().addClass(CALENDAR_CLASS);
                this._popover.content().append(this._calendar.element())
            },
            _calendarOptions: function() {
                return {
                        min: this.option("min"),
                        max: this.option("max"),
                        firstDayOfWeek: this.option("firstDayOfWeek"),
                        value: this.option("date"),
                        focusStateEnabled: this.option("focusStateEnabled"),
                        onValueChanged: $.proxy(function(e) {
                            this.notifyObserver("updateCurrentDate", e.value);
                            this._popover.hide()
                        }, this),
                        _keyboardProcessor: this._calendarKeyboardProcessor
                    }
            },
            _renderCaption: function() {
                var date = this.option("date"),
                    caption = this._getConfig().getCaption.call(this, date);
                this._caption.option({
                    text: caption,
                    onClick: $.proxy(function() {
                        this._popover.toggle()
                    }, this)
                })
            },
            _renderCaptionKeys: function() {
                if (!this.option("focusStateEnabled") || this.option("disabled"))
                    return;
                this._calendarKeyboardProcessor = this._caption._keyboardProcessor.attachChildProcessor();
                this._setCalendarOption("_keyboardProcessor", this._calendarKeyboardProcessor);
                var keyboardHandler = $.proxy(function(e) {
                        if (this._popover.content().is(":hidden"))
                            this._popover.show();
                        else
                            return true
                    }, this);
                this._caption.registerKeyHandler("enter", keyboardHandler);
                this._caption.registerKeyHandler("space", keyboardHandler)
            },
            _setCalendarOption: function(name, value) {
                if (this._calendar)
                    this._calendar.option(name, value)
            },
            _getConfig: function() {
                var step = this.option("step"),
                    config = CONFIG[step];
                if (!config)
                    throw DX.Error("E1033", step);
                return config
            }
        }).include(ui.dxScheduler.PublisherMixin))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.header.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var COMPONENT_CLASS = "dx-scheduler-header",
            VIEW_SWITCHER_CLASS = "dx-scheduler-view-switcher";
        DX.registerComponent("dxSchedulerHeader", ui.dxScheduler, ui.Widget.inherit({
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    views: [],
                    currentView: "day",
                    firstDayOfWeek: undefined,
                    currentDate: new Date,
                    min: undefined,
                    max: undefined
                })
            },
            _optionChanged: function(args) {
                var value = args.value;
                switch (args.name) {
                    case"views":
                        this._viewSwitcher.option("items", value);
                        break;
                    case"currentView":
                        this._viewSwitcher.option("selectedItem", value);
                        this._navigator.option("step", value);
                        break;
                    case"currentDate":
                        this._navigator.option("date", value);
                        break;
                    case"min":
                    case"max":
                    case"firstDayOfWeek":
                        this._navigator.option(args.name, value);
                        break;
                    case"tabIndex":
                    case"focusStateEnabled":
                        this._viewSwitcher.option(args.name, value);
                        this._navigator.option(args.name, value);
                        this.callBase(args);
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _init: function() {
                this.callBase();
                this.element().addClass(COMPONENT_CLASS);
                this._navigator = this._createComponent("<div>", "dxSchedulerNavigator", {
                    min: this.option("min"),
                    max: this.option("max"),
                    date: this.option("currentDate"),
                    step: this.option("currentView"),
                    firstDayOfWeek: this.option("firstDayOfWeek"),
                    tabIndex: this.option("tabIndex"),
                    focusStateEnabled: this.option("focusStateEnabled"),
                    observer: this.option("observer")
                });
                this._navigator.element().appendTo(this.element());
                var $viewSwitcher = $("<div>").addClass(VIEW_SWITCHER_CLASS).appendTo(this.element());
                this._viewSwitcher = this._createComponent($viewSwitcher, "dxTabs", {
                    selectionRequired: true,
                    scrollingEnabled: false,
                    onSelectionChanged: $.proxy(this._updateCurrentView, this),
                    items: this.option("views"),
                    itemTemplate: function(item) {
                        return $("<span>").addClass("dx-tab-text").text(Globalize.localize("dxScheduler-switcher" + DX.inflector.camelize(item, true)))
                    },
                    selectedItem: this.option("currentView"),
                    tabIndex: this.option("tabIndex"),
                    focusStateEnabled: this.option("focusStateEnabled")
                })
            },
            _updateCurrentView: function(e) {
                var selectedItem = e.component.option("selectedItem");
                this.notifyObserver("currentViewUpdated", selectedItem)
            },
            _renderFocusTarget: $.noop
        }).include(ui.dxScheduler.PublisherMixin))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.workSpace.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils,
            events = ui.events;
        var COMPONENT_CLASS = "dx-scheduler-work-space",
            GROUPED_WORKSPACE_CLASS = "dx-scheduler-work-space-grouped",
            TIME_PANEL_CLASS = "dx-scheduler-time-panel",
            TIME_PANEL_CELL_CLASS = "dx-scheduler-time-panel-cell",
            TIME_PANEL_ROW_CLASS = "dx-scheduler-time-panel-row",
            ALL_DAY_PANEL_CLASS = "dx-scheduler-all-day-panel",
            ALL_DAY_TABLE_CLASS = "dx-scheduler-all-day-table",
            FIXED_CONTAINER_CLASS = "dx-scheduler-fixed-appointments",
            ALL_DAY_TITLE_CLASS = "dx-scheduler-all-day-title",
            ALL_DAY_TABLE_CELL_CLASS = "dx-scheduler-all-day-table-cell",
            ALL_DAY_TABLE_ROW_CLASS = "dx-scheduler-all-day-table-row",
            HEADER_PANEL_CLASS = "dx-scheduler-header-panel",
            HEADER_PANEL_CELL_CLASS = "dx-scheduler-header-panel-cell",
            HEADER_ROW_CLASS = "dx-scheduler-header-row",
            GROUP_ROW_CLASS = "dx-scheduler-group-row",
            GROUP_HEADER_CLASS = "dx-scheduler-group-header",
            DATE_TABLE_CLASS = "dx-scheduler-date-table",
            DATE_TABLE_CELL_CLASS = "dx-scheduler-date-table-cell",
            DATE_TABLE_ROW_CLASS = "dx-scheduler-date-table-row",
            DATE_TABLE_CURRENT_DATE_CLASS = "dx-scheduler-date-table-current-date",
            DATE_TABLE_OTHER_MONTH_DATE_CLASS = "dx-scheduler-date-table-other-month",
            DATE_TABLE_DROPPABLE_CELL_CLASS = "dx-scheduler-date-table-droppable-cell",
            SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME = events.addNamespace("dxpointerdown", "dxSchedulerWorkSpace"),
            SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME = events.addNamespace("dxdragenter", "dxSchedulerDateTable"),
            SCHEDULER_CELL_DXDROP_EVENT_NAME = events.addNamespace("dxdrop", "dxSchedulerDateTable"),
            CELL_DATA = "dxCellData";
        DX.registerComponent("dxSchedulerWorkSpace", ui.dxScheduler, ui.Widget.inherit({
            _supportedKeys: function() {
                var isRTL = this.option("rtlEnabled");
                var click = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (this._$focusedCell && this._$focusedCell.length)
                            this._showAddAppointmentPopup(this._$focusedCell)
                    };
                return $.extend(this.callBase(), {
                        enter: click,
                        space: click,
                        downArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            var cellIndex = this._getFocusedCell().index(),
                                $row = this._getFocusedCell().parent(),
                                $cell = $row.next().children().eq(cellIndex);
                            this._moveToCell($cell)
                        },
                        upArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            var cellIndex = this._getFocusedCell().index(),
                                $row = this._getFocusedCell().parent(),
                                $cell = $row.prev().children().eq(cellIndex);
                            this._moveToCell($cell)
                        },
                        rightArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            var $cell = isRTL ? this._getFocusedCell().prev() : this._getFocusedCell().next();
                            this._moveToCell($cell)
                        },
                        leftArrow: function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            var $cell = isRTL ? this._getFocusedCell().next() : this._getFocusedCell().prev();
                            this._moveToCell($cell)
                        }
                    })
            },
            _getFocusedCell: function() {
                return this._$focusedCell || this._$dateTable.find("." + DATE_TABLE_CELL_CLASS).eq(0)
            },
            _setFocusedCell: function($cell) {
                if (!$cell.length)
                    return;
                this._releaseFocusedCell();
                this._toggleFocusClass(true, $cell);
                if (utils.isDefined(this._$focusedCell))
                    this.setAria("label", undefined, this._$focusedCell);
                this._$focusedCell = $cell;
                this.setAria("label", "Add appointment", this._$focusedCell)
            },
            _moveToCell: function($cell) {
                this._setFocusedCell($cell);
                this._scrollable.scrollToElement($cell)
            },
            _releaseFocusedCell: function() {
                if (utils.isDefined(this._$focusedCell))
                    this._toggleFocusClass(false, this._$focusedCell)
            },
            _focusTarget: function() {
                return this.element()
            },
            _focusInHandler: function(e) {
                if ($(e.target).is(this._focusTarget()) && this._isCellClick !== false) {
                    delete this._isCellClick;
                    this.callBase.apply(this, arguments);
                    var $cell = this._getFocusedCell();
                    this._setFocusedCell($cell)
                }
            },
            _focusOutHandler: function(e) {
                this.callBase.apply(this, arguments);
                this._releaseFocusedCell()
            },
            _activeStateUnit: "." + DATE_TABLE_CELL_CLASS + ", ." + ALL_DAY_TABLE_CELL_CLASS,
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    currentDate: new Date,
                    firstDayOfWeek: undefined,
                    startDayHour: 0,
                    endDayHour: 24,
                    hoursInterval: 0.5,
                    activeStateEnabled: true,
                    hoverStateEnabled: true,
                    groups: []
                })
            },
            _optionChanged: function(args) {
                var that = this;
                function rerenderView() {
                    that._cleanView();
                    that._setFirstViewDate();
                    that._renderView()
                }
                switch (args.name) {
                    case"firstDayOfWeek":
                    case"currentDate":
                    case"groups":
                        this._toggleGroupedClass();
                        rerenderView();
                        break;
                    case"startDayHour":
                    case"endDayHour":
                        rerenderView();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _init: function() {
                this.callBase();
                this.element().addClass(COMPONENT_CLASS);
                this._$headerPanel = $("<table>").addClass(HEADER_PANEL_CLASS);
                this._$allDayTable = $("<table>").addClass(ALL_DAY_TABLE_CLASS);
                this._$fixedContainer = $("<div>").addClass(FIXED_CONTAINER_CLASS);
                this._$allDayPanel = $("<div>").append($("<div>").addClass(ALL_DAY_TITLE_CLASS).text(Globalize.localize("dxScheduler-allDay"))).append(this._$allDayTable).addClass(ALL_DAY_PANEL_CLASS);
                this._$timePanel = $("<table>").addClass(TIME_PANEL_CLASS);
                this._$dateTable = $("<table>").addClass(DATE_TABLE_CLASS);
                this._scrollable = this._createComponent("<div>", "dxScrollable", {useKeyboard: false});
                this._scrollable.content().append(this._$timePanel, this._$dateTable);
                this.element().append(this._$headerPanel, this._$fixedContainer, this._$allDayPanel, this._scrollable.element());
                this.element().addClass(this._getElementClass())
            },
            _getElementClass: $.noop,
            _getRowCount: $.noop,
            _getCellCount: $.noop,
            _render: function() {
                this.callBase();
                this._setFirstViewDate();
                this._renderView();
                this._toggleGroupedClass();
                this._attachEvents()
            },
            _setFirstViewDate: function() {
                this._firstViewDate = utils.getFirstWeekDate(this.option("currentDate"), this._firstDayOfWeek());
                if (this.option("startDayHour"))
                    this._firstViewDate.setHours(this.option("startDayHour"))
            },
            _firstDayOfWeek: function() {
                return this.option("firstDayOfWeek")
            },
            _renderView: function() {
                this._renderHeaderPanel();
                this._renderAllDayPanel();
                this._renderTimePanel();
                this._renderDateTable()
            },
            _toggleGroupedClass: function() {
                this.element().toggleClass(GROUPED_WORKSPACE_CLASS, this.option("groups").length > 0)
            },
            _attachEvents: function() {
                var pointerDownAction = this._createAction($.proxy(this._pointerDownHandler, this));
                this.element().off(SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME).on(SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME, function(e) {
                    if (ui.events.isMouseEvent(e) && e.which > 1) {
                        e.preventDefault();
                        return
                    }
                    pointerDownAction({jQueryEvent: e})
                })
            },
            _pointerDownHandler: function(e) {
                var $target = $(e.jQueryEvent.target);
                if (!$target.hasClass(DATE_TABLE_CELL_CLASS) && !$target.hasClass(ALL_DAY_TABLE_CELL_CLASS)) {
                    this._isCellClick = false;
                    return
                }
                this._isCellClick = true;
                if (this._hasFocusClass($target))
                    this._showAddAppointmentPopup($target);
                else
                    this._setFocusedCell($target)
            },
            _showAddAppointmentPopup: function($cell) {
                var cellData = this.getCellData($cell),
                    args = $.extend(cellData, cellData.groups);
                delete args.groups;
                this.notifyObserver("showAddAppointmentPopup", args)
            },
            _renderHeaderPanel: function() {
                var $head = $("<thead>");
                this._renderGroupHeader($head);
                this._renderDateHeader($head);
                this._$headerPanel.append($head)
            },
            _renderDateHeader: function($element) {
                var $headerRow = $("<tr>").addClass(HEADER_ROW_CLASS),
                    count = this._getCellCount(),
                    groupCount = this._getGroupCount() || 1;
                for (var j = 0; j < groupCount; j++)
                    for (var i = 0; i < count; i++) {
                        var text = this._getHeaderText(i),
                            $cell = $("<th>").text(text).addClass(HEADER_PANEL_CELL_CLASS).attr("title", text);
                        $headerRow.append($cell)
                    }
                $element.append($headerRow)
            },
            _renderGroupHeader: function($element) {
                var groupCount = this._getGroupCount();
                if (groupCount) {
                    var groupRows = this._makeGroupRows(this.option("groups"));
                    this.element().attr("dx-group-row-count", groupRows.length);
                    $element.append(groupRows)
                }
            },
            _makeGroupRows: function(groups) {
                var repeatCount = 1,
                    groupCount = groups.length,
                    cellCount = this._getCellCount() || 1,
                    rows = [];
                for (var i = 0; i < groupCount; i++) {
                    if (i > 0)
                        repeatCount = groups[i - 1].items.length * repeatCount;
                    var cells = this._makeGroupRowCells(groups[i].items, repeatCount);
                    rows.push($("<tr>").addClass(GROUP_ROW_CLASS).append(cells))
                }
                var maxCellCount = rows[groupCount - 1].find("th").length;
                for (var j = 0; j < groupCount; j++) {
                    var $cell = rows[j].find("th"),
                        colspan = maxCellCount / $cell.length * cellCount;
                    if (colspan > 1)
                        $cell.attr("colspan", colspan)
                }
                return rows
            },
            _makeGroupRowCells: function(items, repeatCount) {
                var cells = [],
                    itemCount = items.length;
                for (var i = 0; i < repeatCount; i++)
                    for (var j = 0; j < itemCount; j++)
                        cells.push($("<th>").addClass(GROUP_HEADER_CLASS).text(items[j].text));
                return cells
            },
            _renderAllDayPanel: function() {
                var cellCount = this._getCellCount() * (this._getGroupCount() || 1);
                this._renderTableBody({
                    container: this._$allDayTable,
                    rowCount: 1,
                    cellCount: cellCount,
                    cellClass: ALL_DAY_TABLE_CELL_CLASS,
                    rowClass: ALL_DAY_TABLE_ROW_CLASS,
                    dataGenerator: $.proxy(this._setAllDayCellData, this)
                })
            },
            _setAllDayCellData: function($cell, rowIndex, cellIndex) {
                var startDate = this._getDateByCellIndexes(rowIndex, cellIndex);
                utils.correctDateWithUnitBeginning(startDate, "day");
                var data = {
                        startDate: startDate,
                        endDate: new Date(startDate.getTime() + 24 * 60 * 60000),
                        allDay: true
                    };
                var groups = this._getCellGroups(cellIndex);
                if (groups.length)
                    data.groups = {};
                for (var i = 0; i < groups.length; i++)
                    data.groups[groups[i].name] = groups[i].id;
                $cell.data(CELL_DATA, data)
            },
            _renderTimePanel: function() {
                this._renderTableBody({
                    container: this._$timePanel,
                    rowCount: this._calculateDayDuration(),
                    cellCount: 1,
                    cellClass: TIME_PANEL_CELL_CLASS,
                    rowClass: TIME_PANEL_ROW_CLASS
                });
                var startDayHour = this.option("startDayHour");
                this._$timePanel.find("td").each(function(index) {
                    $(this).text(Globalize.format(new Date(new Date(1970, 0).getTime() + 3600000 * (startDayHour + index)), "t"))
                })
            },
            _calculateDayDuration: function() {
                return this.option("endDayHour") - this.option("startDayHour")
            },
            _renderDateTable: function() {
                var cellCount = this._getCellCount() * (this._getGroupCount() || 1);
                this._renderTableBody({
                    container: this._$dateTable,
                    rowCount: this._getRowCount(),
                    cellCount: cellCount,
                    cellClass: DATE_TABLE_CELL_CLASS,
                    rowClass: DATE_TABLE_ROW_CLASS,
                    dataGenerator: $.proxy(this._setCellData, this)
                });
                this._attachTablesEvents()
            },
            _setCellData: function($cell, rowIndex, cellIndex) {
                var startDate = this._getDateByCellIndexes(rowIndex, cellIndex),
                    endDate = this._calculateEndDate(startDate),
                    data = {
                        startDate: startDate,
                        endDate: endDate,
                        allDay: this._getTableAllDay()
                    };
                $cell.toggleClass(DATE_TABLE_CURRENT_DATE_CLASS, this._isCurrentDate(startDate)).toggleClass(DATE_TABLE_OTHER_MONTH_DATE_CLASS, this._isOtherMonth(startDate));
                var groups = this._getCellGroups(cellIndex);
                if (groups.length)
                    data.groups = {};
                for (var i = 0; i < groups.length; i++)
                    data.groups[groups[i].name] = groups[i].id;
                $cell.data(CELL_DATA, data)
            },
            _getTableAllDay: function() {
                return false
            },
            _isCurrentDate: function(cellDate) {
                var today = new Date;
                return utils.sameMonthAndYear(cellDate, today) && cellDate.getDate() === today.getDate()
            },
            _isOtherMonth: function(cellDate) {
                return cellDate.getMonth() !== this.option("currentDate").getMonth()
            },
            _calculateEndDate: function(startDate) {
                return new Date(startDate.getTime() + this._getInterval())
            },
            _getGroupCount: function() {
                var groups = this.option("groups"),
                    result = 0;
                for (var i = 0, len = groups.length; i < len; i++)
                    if (!i)
                        result = groups[i].items.length;
                    else
                        result *= groups[i].items.length;
                return result
            },
            _getPathToLeaf: function(leafIndex) {
                var tree = this._createGroupTree(this.option("groups")[0], 0);
                function findLeafByIndex(data, index) {
                    for (var i = 0; i < data.length; i++)
                        if (data[i].leafIndex === index)
                            return data[i];
                        else {
                            var leaf = findLeafByIndex(data[i].children, index);
                            if (leaf)
                                return leaf
                        }
                }
                function makeBranch(leaf, result) {
                    result = result || [];
                    result.push(leaf.value);
                    if (leaf.parent)
                        makeBranch(leaf.parent, result);
                    return result
                }
                var leaf = findLeafByIndex(tree, leafIndex);
                return makeBranch(leaf).reverse()
            },
            _getCellGroups: function(index) {
                var result = [];
                if (this._getGroupCount()) {
                    var groupIndex = Math.floor(index / this._getCellCount()),
                        groups = this.option("groups");
                    if (groupIndex < 0)
                        return;
                    var path = this._getPathToLeaf(groupIndex);
                    for (var i = 0; i < groups.length; i++)
                        result.push({
                            name: groups[i].name,
                            id: path[i]
                        })
                }
                return result
            },
            _attachTablesEvents: function() {
                this._attachTableEvents(this._getDateTable());
                this._attachTableEvents(this._getAllDayTable())
            },
            _attachTableEvents: function($table) {
                var that = this,
                    cellHeight,
                    cellWidth;
                $table.off(SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME).off(SCHEDULER_CELL_DXDROP_EVENT_NAME).on(SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME, "td", {itemSizeFunc: function($element) {
                        if (!cellHeight)
                            cellHeight = $element.height();
                        if (!cellWidth)
                            cellWidth = $element.width();
                        return {
                                width: cellWidth,
                                height: cellHeight
                            }
                    }}, function(e) {
                    if (that._$currentTableTarget)
                        that._$currentTableTarget.removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);
                    that._$currentTableTarget = $(e.target);
                    that._$currentTableTarget.addClass(DATE_TABLE_DROPPABLE_CELL_CLASS)
                }).on(SCHEDULER_CELL_DXDROP_EVENT_NAME, "td", function(e) {
                    $(e.target).removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);
                    cellHeight = 0;
                    cellWidth = 0
                })
            },
            _getDateTables: function() {
                return this._$dateTable.add(this._$allDayTable)
            },
            _getDateTable: function() {
                return this._$dateTable
            },
            _getAllDayTable: function() {
                return this._$allDayTable
            },
            _getInterval: function() {
                return this.option("hoursInterval") * 3600000
            },
            _getHeaderText: function(headerIndex) {
                return Globalize.format(this._getDateByIndex(headerIndex), this._getFormat()).toUpperCase()
            },
            _getDateByIndex: DX.abstract,
            _getFormat: DX.abstract,
            _getCellText: function(rowIndex, cellIndex) {
                return ""
            },
            _calculateCellIndex: function(rowIndex, cellIndex) {
                cellIndex = cellIndex % this._getCellCount();
                var virtualRowCount = this._getVirtualRowCount();
                return (this._getRowCount() + virtualRowCount) * cellIndex + rowIndex
            },
            _getVirtualRowCount: function() {
                return this.option("startDayHour") / this.option("hoursInterval") + this._getEndDayHours() / this.option("hoursInterval")
            },
            _getEndDayHours: function() {
                return 24 - this.option("endDayHour")
            },
            _getEndDayMilliseconds: function() {
                return this._getEndDayHours() * 3600000
            },
            _renderTableBody: function(options) {
                var rows = [];
                for (var i = 0; i < options.rowCount; i++) {
                    var $row = $("<tr>");
                    if (options.rowClass)
                        $row.addClass(options.rowClass);
                    for (var j = 0; j < options.cellCount; j++) {
                        var $td = $("<td>").text(this._getCellText(i, j));
                        if (options.cellClass)
                            $td.addClass(options.cellClass);
                        if ($.isFunction(options.dataGenerator))
                            options.dataGenerator($td, i, j);
                        $row.append($td)
                    }
                    rows.push($row)
                }
                options.container.append($("<tbody>").append(rows))
            },
            _cleanView: function() {
                this._$headerPanel.empty();
                this._$dateTable.empty();
                this._$timePanel.empty();
                this._$allDayTable.empty()
            },
            getWorkArea: function() {
                return this._scrollable.content()
            },
            getScrollable: function() {
                return this._scrollable
            },
            getScrollableScrollTop: function() {
                return this._scrollable.scrollTop()
            },
            getScrollableContainer: function() {
                return this._scrollable._container()
            },
            _getCellCoordinatesByIndex: function(index) {
                var cellIndex = Math.floor(index / this._getRowCount()),
                    rowIndex = index - this._getRowCount() * cellIndex;
                return {
                        cellIndex: cellIndex,
                        rowIndex: rowIndex
                    }
            },
            _createGroupTree: function(group, groupIndex) {
                var leafIndex = 0;
                function make(group, groupIndex, result, parent) {
                    result = result || [];
                    for (var i = 0; i < group.items.length; i++) {
                        var resultItem = {
                                name: group.name,
                                value: group.items[i].id,
                                children: [],
                                parent: parent ? parent : null
                            };
                        result.push(resultItem);
                        var nextGroupIndex = groupIndex + 1;
                        if (this.option("groups")[nextGroupIndex])
                            make.call(this, this.option("groups")[nextGroupIndex], nextGroupIndex, resultItem.children, resultItem);
                        if (!resultItem.children.length) {
                            resultItem.leafIndex = leafIndex;
                            leafIndex++
                        }
                    }
                    return result
                }
                return make.call(this, group, groupIndex)
            },
            _hasGroupItem: function(groups, groupName, itemValue) {
                var group = groups[groupName];
                if (group)
                    if ($.inArray(itemValue, group) > -1)
                        return true;
                return false
            },
            _grep: function(tree, groups, result) {
                result = result || [];
                for (var i = 0; i < tree.length; i++) {
                    if (!this._hasGroupItem(groups, tree[i].name, tree[i].value))
                        continue;
                    if (utils.isDefined(tree[i].leafIndex))
                        result.push(tree[i].leafIndex);
                    if (tree[i].children)
                        this._grep(tree[i].children, groups, result)
                }
                return result
            },
            _getDateByCellIndexes: function(rowIndex, cellIndex) {
                var millisecondsOffset = this._getInterval() * this._calculateCellIndex(rowIndex, cellIndex);
                return new Date(this.getFirstViewDate().getTime() + millisecondsOffset)
            },
            _getCellTimeOffset: function(dateTimeStamp) {
                var timeInterval = this._getInterval(),
                    timeOffset = dateTimeStamp % timeInterval;
                return timeOffset ? timeOffset / timeInterval : 0
            },
            _getIntervalBetween: function(currentDate, firstViewDate, allDay) {
                var startDayHour = this.option("startDayHour"),
                    firstViewDateTime = firstViewDate.getTime();
                if (allDay)
                    firstViewDateTime = firstViewDateTime - startDayHour * 60 * 60 * 1000;
                var result = currentDate.getTime() - firstViewDateTime,
                    days = Math.floor(result / (24 * 60 * 60 * 1000));
                if (!allDay)
                    result = result - days * startDayHour * 3600000 - days * this._getEndDayMilliseconds();
                return result
            },
            _getGroupIndexes: function(groups) {
                var indexes = [];
                if (groups && this.option("groups").length) {
                    var tree = this._createGroupTree(this.option("groups")[0], 0);
                    indexes = this._grep(tree, groups)
                }
                return indexes
            },
            _updateIndex: function(index) {
                return index * this._getRowCount()
            },
            _getTimePanelWidth: function() {
                return this._$timePanel.outerWidth()
            },
            _getDroppableCell: function() {
                return this._getDateTables().find("." + DATE_TABLE_DROPPABLE_CELL_CLASS)
            },
            getCellData: function($cell) {
                return $.extend(true, {}, $cell.data(CELL_DATA))
            },
            getCoordinatesByDate: function(date, groupIndex, allDay) {
                var isRtl = this.option("rtlEnabled"),
                    timeInterval = allDay ? 24 * 60 * 60 * 1000 : this._getInterval(),
                    dateTimeStamp = this._getIntervalBetween(date, this.getFirstViewDate(), allDay);
                groupIndex = groupIndex || 0;
                var index = Math.floor(dateTimeStamp / timeInterval);
                if (allDay)
                    index = this._updateIndex(index);
                Math.ceil(index / this._getRowCount()) * this.option("startDayHour") * 2;
                if (index < 0)
                    index = 0;
                var cellCoordinates = this._getCellCoordinatesByIndex(index),
                    $cell = this._$dateTable.find("tr").eq(cellCoordinates.rowIndex).find("td").eq(cellCoordinates.cellIndex + groupIndex * this._getCellCount()),
                    position = $cell.position();
                position.top += $cell.height() * this._getCellTimeOffset(dateTimeStamp);
                if (isRtl)
                    position.left += $cell.outerWidth();
                return position
            },
            getCoordinatesByDateInGroup: function(date, groups, allDay) {
                var indexes = this._getGroupIndexes(groups),
                    result = [];
                if (indexes.length)
                    for (var i = 0; i < indexes.length; i++)
                        result.push(this.getCoordinatesByDate(date, indexes[i], allDay));
                else
                    result.push(this.getCoordinatesByDate(date, 0, allDay));
                return result
            },
            getDroppableCellIndex: function() {
                var $droppableCell = this._getDroppableCell(),
                    $row = $droppableCell.parent(),
                    rowIndex = $row.index();
                return rowIndex * $row.find("td").length + $droppableCell.index()
            },
            getDataByDroppableCell: function() {
                var cellData = this.getCellData(this._getDroppableCell());
                return {
                        date: cellData.startDate,
                        allDay: cellData.allDay,
                        groups: cellData.groups
                    }
            },
            getDateRange: function() {
                return [this.getFirstViewDate(), this.getLastViewDate()]
            },
            getCellWidth: function() {
                return this.element().find("." + DATE_TABLE_CELL_CLASS).first().outerWidth()
            },
            getCellHeight: function() {
                return this.element().find("." + DATE_TABLE_CELL_CLASS).first().outerHeight()
            },
            getAllDayHeight: function() {
                return this.element().find("." + ALL_DAY_TABLE_CELL_CLASS).first().outerHeight()
            },
            getMaxAllowedPosition: function() {
                var result = [],
                    isRtl = this.option("rtlEnabled");
                this._$dateTable.find("tr").first().find("td:nth-child(" + this._getCellCount() + "n)").each(function(_, cell) {
                    var maxPosition = $(cell).position().left;
                    if (!isRtl)
                        maxPosition += $(cell).outerWidth();
                    result.push(maxPosition)
                });
                return result
            },
            getAllDayContainerClass: function() {
                return FIXED_CONTAINER_CLASS
            },
            getCellIndexByCoordinates: function(coordinates) {
                var $cell = this.element().find("." + DATE_TABLE_CELL_CLASS).first(),
                    cellCount = this._getCellCount() * (this._getGroupCount() || 1),
                    timePanelWidth = this._getTimePanelWidth(),
                    cellWidth = Math.floor((this.element().outerWidth() - timePanelWidth) / cellCount),
                    leftOffset = this.option("rtlEnabled") ? 0 : timePanelWidth,
                    topIndex = Math.floor(coordinates.top / $cell.outerHeight()),
                    leftIndex = Math.floor((coordinates.left + 5 - leftOffset) / cellWidth);
                if (this.option("rtlEnabled"))
                    leftIndex = cellCount - leftIndex - 1;
                return cellCount * topIndex + leftIndex
            },
            getFirstViewDate: function() {
                return this._firstViewDate
            },
            getLastViewDate: function() {
                var dateOfLastViewCell = this._getDateByCellIndexes(this._getRowCount() - 1, this._getCellCount() - 1);
                return new Date(dateOfLastViewCell.getTime() + this._getInterval() - 60000)
            },
            getGroupBounds: function(coordinates, allDay) {
                var cellIndex = this.getCellIndexByCoordinates(coordinates),
                    cellCount = this._getCellCount(),
                    groupIndex = Math.floor(cellIndex / cellCount),
                    cellClass = allDay ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS,
                    $cells = this.element().find("." + cellClass),
                    cellWidth = $cells.first().outerWidth(),
                    startCellIndex = groupIndex * cellCount,
                    startOffset = $cells.eq(startCellIndex).offset().left,
                    endOffset = $cells.eq(startCellIndex + cellCount - 1).offset().left + cellWidth;
                var result = {
                        left: startOffset,
                        right: endOffset
                    };
                if (this.option("rtlEnabled")) {
                    result.left = endOffset - cellWidth;
                    result.right = startOffset + cellWidth
                }
                return result
            },
            getVisibleBounds: function() {
                var result = {},
                    $scrollable = this.getScrollable().element(),
                    cellHeight = this.getCellHeight(),
                    scrolledCellCount = this.getScrollableScrollTop() / cellHeight,
                    totalCellCount = scrolledCellCount + $scrollable.height() / cellHeight;
                result.top = {
                    hours: Math.floor(scrolledCellCount / 2) + this.option("startDayHour"),
                    minutes: scrolledCellCount % 2 ? 30 : 0
                };
                result.bottom = {
                    hours: Math.floor(totalCellCount / 2) + this.option("startDayHour"),
                    minutes: Math.floor(totalCellCount) % 2 ? 30 : 0
                };
                return result
            }
        }).include(ui.dxScheduler.PublisherMixin))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.workSpaceDay.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var DAY_CLASS = "dx-scheduler-work-space-day";
        DX.registerComponent("dxSchedulerWorkSpaceDay", ui.dxScheduler, ui.dxScheduler.dxSchedulerWorkSpace.inherit({
            _getElementClass: function() {
                return DAY_CLASS
            },
            _getRowCount: function() {
                var day = this._calculateDayDuration();
                return day / this.option("hoursInterval")
            },
            _getCellCount: function() {
                return 1
            },
            _setFirstViewDate: function() {
                this._firstViewDate = this.option("currentDate");
                if (this.option("startDayHour"))
                    this._firstViewDate.setHours(this.option("startDayHour"))
            },
            _getDateByIndex: function() {
                return this._firstViewDate
            },
            _getFormat: function() {
                return "D"
            },
            _renderDateHeader: $.noop
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.workSpaceWeek.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var WEEK_CLASS = "dx-scheduler-work-space-week";
        DX.registerComponent("dxSchedulerWorkSpaceWeek", ui.dxScheduler, ui.dxScheduler.dxSchedulerWorkSpace.inherit({
            _getElementClass: function() {
                return WEEK_CLASS
            },
            _getRowCount: function() {
                var day = this._calculateDayDuration();
                return day / this.option("hoursInterval")
            },
            _getCellCount: function() {
                return 7
            },
            _getDateByIndex: function(headerIndex) {
                var resultDate = new Date(this._firstViewDate);
                resultDate.setDate(this._firstViewDate.getDate() + headerIndex);
                return resultDate
            },
            _getFormat: function() {
                return "ddd d"
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.workSpaceWorkWeek.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var WORK_WEEK_CLASS = "dx-scheduler-work-space-work-week";
        var weekendCounter = 0;
        DX.registerComponent("dxSchedulerWorkSpaceWorkWeek", ui.dxScheduler, ui.dxScheduler.dxSchedulerWorkSpaceWeek.inherit({
            _getElementClass: function() {
                return WORK_WEEK_CLASS
            },
            _getCellCount: function() {
                return 5
            },
            _firstDayOfWeek: function() {
                return this.option("firstDayOfWeek") || 1
            },
            _getDateByIndex: function(headerIndex) {
                var resultDate = new Date(this._firstViewDate);
                resultDate.setDate(this._firstViewDate.getDate() + headerIndex + weekendCounter);
                var day = resultDate.getDay();
                if (day % 6 === 0) {
                    weekendCounter = Math.floor(day / 6 + 1);
                    resultDate.setDate(resultDate.getDate() + weekendCounter)
                }
                return resultDate
            },
            _renderHeaderPanel: function() {
                weekendCounter = 0;
                this.callBase()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.workSpaceMonth.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            utils = DX.utils;
        var MONTH_CLASS = "dx-scheduler-work-space-month";
        var DAYS_IN_WEEK = 7,
            DAY_IN_MILLISECONDS = 86400000;
        DX.registerComponent("dxSchedulerWorkSpaceMonth", ui.dxScheduler, ui.dxScheduler.dxSchedulerWorkSpace.inherit({
            _getElementClass: function() {
                return MONTH_CLASS
            },
            _getRowCount: function() {
                return 6
            },
            _getCellCount: function() {
                return DAYS_IN_WEEK
            },
            _getDateByIndex: function(headerIndex) {
                var resultDate = new Date(this._firstViewDate);
                resultDate.setDate(this._firstViewDate.getDate() + headerIndex);
                return resultDate
            },
            _getFormat: function() {
                return "ddd"
            },
            _calculateCellIndex: function(rowIndex, cellIndex) {
                cellIndex = cellIndex % this._getCellCount();
                return rowIndex * this._getCellCount() + cellIndex
            },
            _getInterval: function() {
                return DAY_IN_MILLISECONDS
            },
            _calculateEndDate: function(startDate) {
                var startDateCopy = new Date(startDate);
                return new Date(startDateCopy.setHours(this.option("endDayHour")))
            },
            _getIntervalBetween: function(currentDate, firstViewDate) {
                return currentDate.getTime() - (firstViewDate.getTime() - this.option("startDayHour") * 3600000)
            },
            _getCellCoordinatesByIndex: function(index) {
                var rowIndex = Math.floor(index / this._getCellCount()),
                    cellIndex = index - this._getCellCount() * rowIndex;
                return {
                        rowIndex: rowIndex,
                        cellIndex: cellIndex
                    }
            },
            _renderTimePanel: $.noop,
            _renderAllDayPanel: $.noop,
            _getTableAllDay: $.noop,
            _getCellTimeOffset: function() {
                return 0
            },
            _setFirstViewDate: function() {
                var firstMonthDate = DX.utils.getFirstMonthDate(this.option("currentDate"));
                this._firstViewDate = utils.getFirstWeekDate(firstMonthDate, this.option("firstDayOfWeek"));
                if (this.option("startDayHour"))
                    this._firstViewDate.setHours(this.option("startDayHour"))
            },
            _getDate: function(week, day) {
                var result = new Date(this._firstViewDate);
                result.setDate(result.getDate() + week * DAYS_IN_WEEK + day);
                return result
            },
            _getCellText: function(rowIndex, cellIndex) {
                cellIndex = cellIndex % this._getCellCount();
                var date = this._getDate(rowIndex, cellIndex);
                return Globalize.format(date, "dd")
            },
            _updateIndex: function(index) {
                return index
            },
            _getTimePanelWidth: function() {
                return 0
            },
            getCoordinatesByDates: function(startDate, endDate) {
                var result = [],
                    date = new Date(startDate);
                while (date <= endDate) {
                    result.push(this.getCoordinatesByDate(date));
                    date.setDate(date.getDate() + 7);
                    date = utils.getFirstWeekDate(date, this.option("firstDayOfWeek"))
                }
                return result
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.appointments.strategy.base.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var APPOINTMENT_DEFAULT_SIZE = 20,
            COMPACT_APPOINTMENT_DEFAULT_SIZE = 15;
        var BaseRenderingStrategy = DX.Class.inherit({
                ctor: function(instance) {
                    this.instance = instance
                },
                getAppointmentDefaultSize: function() {
                    return APPOINTMENT_DEFAULT_SIZE
                },
                resizableConfig: DX.abstract,
                getDeltaTime: function(args, initialSize) {
                    var cellWidth = this._defaultWidth || this.getAppointmentDefaultSize(),
                        initialWidth = initialSize.width,
                        deltaWidth = Math.round((args.width - initialWidth) / cellWidth);
                    return 24 * 60 * 60000 * deltaWidth
                },
                getAppointmentGeometry: function(coordinates) {
                    return this.applyCellBorder(coordinates)
                },
                createTaskPositionMap: function(items) {
                    var length = items.length;
                    if (!length)
                        return;
                    this.instance.notifyObserver("getCellDimensions", {callback: $.proxy(function(width, height, allDayHeight) {
                            this._defaultWidth = width;
                            this._defaultHeight = height;
                            this._allDayHeight = allDayHeight
                        }, this)});
                    this.instance.notifyObserver("getMaxAllowedPosition", {callback: $.proxy(function(result) {
                            if (result)
                                this._maxAllowedPosition = result
                        }, this)});
                    var map = [];
                    for (var i = 0; i < length; i++) {
                        var coordinates = this._getItemPosition(items[i]);
                        if (this._isRtl())
                            coordinates = this._correctRtlCoordinates(coordinates);
                        map.push(coordinates)
                    }
                    var positionArray = this._getSortedPositions(map),
                        resultPositions = this._getResultPositions(positionArray);
                    return this._getExtendedPositionMap(map, resultPositions)
                },
                _correctRtlCoordinates: function(coordinates) {
                    return coordinates
                },
                applyCellBorder: function(config) {
                    var cellBorderSize = 1;
                    config.left += cellBorderSize;
                    config.top += cellBorderSize;
                    config.width -= cellBorderSize;
                    config.height -= cellBorderSize;
                    return config
                },
                _getItemPosition: function(item) {
                    var height = this.calculateAppointmentHeight(item),
                        width = this.calculateAppointmentWidth(item),
                        position = this._getAppointmentCoordinates(item),
                        allDay = this.isAllDay(item),
                        appointmentReduced = false;
                    for (var j = 0; j < position.length; j++) {
                        if (allDay)
                            position[j].top = 0;
                        if ((this._needVerifyItemSize() || allDay) && this._maxAllowedPosition) {
                            var currentMaxAllowedPosition = this._getCurrentMaxAllowedPosition(j, item);
                            if (this.isAppointmentGreaterThan(currentMaxAllowedPosition, {
                                left: position[j].left,
                                width: width
                            })) {
                                appointmentReduced = true;
                                if (this._isRtl())
                                    width = Math.floor(position[j].left - currentMaxAllowedPosition);
                                else
                                    width = currentMaxAllowedPosition - Math.floor(position[j].left)
                            }
                        }
                        $.extend(position[j], {
                            height: height,
                            width: width,
                            allDay: allDay,
                            appointmentReduced: appointmentReduced
                        })
                    }
                    return position
                },
                _getAppointmentCoordinates: function(itemData) {
                    var startDate = DX.utils.makeDate(itemData.startDate),
                        coordinates = [{
                                top: 0,
                                left: 0
                            }];
                    this.instance.notifyObserver("needCoordinates", {
                        startDate: startDate,
                        appointmentData: itemData,
                        callback: function(value) {
                            coordinates = value
                        }
                    });
                    return coordinates
                },
                _needVerifyItemSize: function() {
                    return false
                },
                _isRtl: function() {
                    return this.instance.option("rtlEnabled")
                },
                _getCurrentMaxAllowedPosition: function(index, item) {
                    this.instance.notifyObserver("getItemGroupIndexes", {
                        item: item,
                        callback: function(indexes) {
                            if (indexes.length)
                                index = indexes[index]
                        }
                    });
                    return Math.floor(this._maxAllowedPosition[index])
                },
                calculateAppointmentHeight: function() {
                    return 0
                },
                calculateAppointmentWidth: function() {
                    return 0
                },
                isAppointmentGreaterThan: function(etalon, comparisonParameters) {
                    if (this._isRtl())
                        return comparisonParameters.left - comparisonParameters.width < etalon;
                    return comparisonParameters.left + comparisonParameters.width > etalon
                },
                isAllDay: function() {
                    return false
                },
                _getSortedPositions: function(arr) {
                    var result = [];
                    for (var i = 0, arrLength = arr.length; i < arrLength; i++)
                        for (var j = 0, itemLength = arr[i].length; j < itemLength; j++) {
                            var item = arr[i][j];
                            result.push({
                                i: i,
                                j: j,
                                top: item.top,
                                left: item.left,
                                isStart: true,
                                allDay: item.allDay
                            }, {
                                i: i,
                                j: j,
                                top: item.top + item.height,
                                left: item.left + item.width,
                                isStart: false,
                                allDay: item.allDay
                            })
                        }
                    result.sort($.proxy(this._sortCondition, this));
                    return result
                },
                _sortCondition: DX.abstract,
                _rowCondition: function(a, b) {
                    var columnCondition = this._normalizeCondition(a.left, b.left),
                        rowCondition = this._normalizeCondition(a.top, b.top);
                    return columnCondition ? columnCondition : rowCondition ? rowCondition : a.isStart - b.isStart
                },
                _columnCondition: function(a, b) {
                    var columnCondition = this._normalizeCondition(a.left, b.left),
                        rowCondition = this._normalizeCondition(a.top, b.top);
                    return rowCondition ? rowCondition : columnCondition ? columnCondition : a.isStart - b.isStart
                },
                _normalizeCondition: function(first, second) {
                    var result = first - second;
                    return Math.abs(result) > 1.001 ? result : 0
                },
                _getResultPositions: function(sortedArray) {
                    var stack = [],
                        indexes = [],
                        result = [],
                        intersectPositions = [],
                        intersectPositionCount = 0,
                        position;
                    for (var i = 0; i < sortedArray.length; i++) {
                        var current = sortedArray[i],
                            j;
                        if (current.isStart) {
                            position = undefined;
                            for (j = 0; j < indexes.length; j++)
                                if (!indexes[j]) {
                                    position = j;
                                    indexes[j] = true;
                                    break
                                }
                            if (position === undefined) {
                                position = indexes.length;
                                indexes.push(true);
                                for (j = 0; j < stack.length; j++)
                                    stack[j].count++
                            }
                            stack.push({
                                index: position,
                                count: indexes.length,
                                i: current.i,
                                j: current.j
                            });
                            if (intersectPositionCount < indexes.length)
                                intersectPositionCount = indexes.length
                        }
                        else {
                            var removeIndex = this._findIndexByKey(stack, "i", "j", current.i, current.j),
                                resultItem = stack[removeIndex];
                            stack.splice(removeIndex, 1);
                            indexes[resultItem.index] = false;
                            intersectPositions.push(resultItem);
                            if (!stack.length) {
                                indexes = [];
                                for (var k = 0; k < intersectPositions.length; k++)
                                    intersectPositions[k].count = intersectPositionCount;
                                intersectPositions = [];
                                intersectPositionCount = 0
                            }
                            result.push(resultItem)
                        }
                    }
                    return result.sort(function(a, b) {
                            var columnCondition = a.j - b.j,
                                rowCondition = a.i - b.i;
                            return rowCondition ? rowCondition : columnCondition
                        })
                },
                _findIndexByKey: function(arr, ikey, jkey, ivalue, jvalue) {
                    var result = 0;
                    for (var i = 0, len = arr.length; i < len; i++)
                        if (arr[i][ikey] === ivalue && arr[i][jkey] === jvalue) {
                            result = i;
                            break
                        }
                    return result
                },
                _getExtendedPositionMap: function(map, positions) {
                    var positionCounter = 0;
                    for (var i = 0, mapLength = map.length; i < mapLength; i++)
                        for (var j = 0, itemLength = map[i].length; j < itemLength; j++) {
                            map[i][j].index = positions[positionCounter].index;
                            map[i][j].count = positions[positionCounter++].count;
                            map[i][j].groupIndex = map[i][j].top + "-" + map[i][j].left
                        }
                    return map
                },
                _startDate: function(item, skipNormalize) {
                    var startDate = this.instance._getStartDate(item, skipNormalize);
                    if (isNaN(startDate.getTime()))
                        throw DX.Error("E1032", item.text);
                    return startDate
                },
                _endDate: function(item) {
                    var endDate = this.instance._getEndDate(item),
                        realStartDate = this._startDate(item, true),
                        viewStartDate = this._startDate(item);
                    if (!endDate || realStartDate >= endDate) {
                        endDate = new Date(realStartDate.getTime() + this.instance.option("appointmentDurationInMinutes") * 60000);
                        item.endDate = endDate
                    }
                    if (viewStartDate >= endDate) {
                        var duration = endDate.getTime() - realStartDate.getTime();
                        endDate = new Date(viewStartDate.getTime() + duration)
                    }
                    return endDate
                },
                _getMaxNeighborAppointmentCount: function() {
                    return Math.floor(this.getCompactAppointmentGroupMaxWidth() / this.getCompactAppointmentDefaultSize())
                },
                _markAppointmentAsVirtual: function(coordinates, isAllDay) {
                    if (coordinates.count > 5)
                        coordinates.virtual = {
                            top: coordinates.top,
                            left: coordinates.left,
                            groupIndex: coordinates.groupIndex,
                            isAllDay: isAllDay
                        }
                },
                getCompactAppointmentGroupMaxWidth: function() {
                    var widthInPercents = 75;
                    return widthInPercents * this.getDefaultCellWidth() / 100
                },
                getDefaultCellWidth: function() {
                    return this._defaultWidth
                },
                getCompactAppointmentDefaultSize: function() {
                    return COMPACT_APPOINTMENT_DEFAULT_SIZE
                }
            });
        ui.dxScheduler.BaseAppointmentsStrategy = BaseRenderingStrategy
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.appointments.strategy.horizontal.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            MONTH_APPOINTMENT_HEIGHT_RATIO = 0.6,
            MONTH_APPOINTMENT_DEFAULT_OFFSET = 3;
        var HorizontalRenderingStrategy = ui.dxScheduler.BaseAppointmentsStrategy.inherit({
                resizableConfig: function() {
                    return {
                            minWidth: this._defaultWidth,
                            minHeight: 0,
                            step: this._defaultWidth,
                            handles: "right left"
                        }
                },
                _needVerifyItemSize: function() {
                    return true
                },
                _correctRtlCoordinates: function(coordinates) {
                    if (!coordinates[0].appointmentReduced)
                        coordinates[0].left -= coordinates[0].width;
                    return coordinates
                },
                calculateAppointmentWidth: function(appointment) {
                    var startDate = this._startDate(appointment),
                        endDate = this._endDate(appointment),
                        cellWidth = this._defaultWidth || this.getAppointmentDefaultSize();
                    var durationInHours = (endDate.getTime() - startDate.getTime()) / 3600000;
                    var width = Math.ceil(durationInHours / 24) * cellWidth;
                    return width
                },
                getAppointmentGeometry: function(coordinates) {
                    var maxHeight = this._defaultHeight || this.getAppointmentDefaultSize(),
                        index = coordinates.index,
                        height = MONTH_APPOINTMENT_HEIGHT_RATIO * maxHeight / 2,
                        width = coordinates.width,
                        top = (1 - MONTH_APPOINTMENT_HEIGHT_RATIO) * maxHeight + coordinates.top + index * height,
                        left = coordinates.left,
                        compactAppointmentDefaultSize = this.getCompactAppointmentDefaultSize();
                    if (index > 1) {
                        top = coordinates.top + MONTH_APPOINTMENT_DEFAULT_OFFSET;
                        left = coordinates.left + (index - 2) * (compactAppointmentDefaultSize + MONTH_APPOINTMENT_DEFAULT_OFFSET) + MONTH_APPOINTMENT_DEFAULT_OFFSET;
                        height = compactAppointmentDefaultSize,
                        width = compactAppointmentDefaultSize;
                        coordinates.skipResizing = true;
                        this._markAppointmentAsVirtual(coordinates)
                    }
                    return this.callBase({
                            height: height,
                            width: width,
                            top: top,
                            left: left
                        })
                },
                _sortCondition: function(a, b) {
                    return this._columnCondition(a, b)
                }
            });
        ui.dxScheduler.HorizontalAppointmentsStrategy = HorizontalRenderingStrategy
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.appointments.strategy.vertical.js */
    (function($, DX, undefined) {
        var ui = DX.ui;
        var WEEK_APPOINTMENT_DEFAULT_OFFSET = 10;
        var VerticalRenderingStrategy = ui.dxScheduler.BaseAppointmentsStrategy.inherit({
                resizableConfig: function(appointment) {
                    if (this.isAllDay(appointment))
                        return {
                                minWidth: this._defaultWidth,
                                step: this._defaultWidth,
                                handles: "right left"
                            };
                    return {
                            minHeight: this._defaultHeight,
                            step: this._defaultHeight,
                            handles: "top bottom"
                        }
                },
                getDeltaTime: function(args, initialSize, appointment) {
                    var deltaTime = 0;
                    if (this.isAllDay(appointment))
                        deltaTime = this.callBase(args, initialSize);
                    else {
                        var deltaHeight = args.height - initialSize.height;
                        if (deltaHeight < 0)
                            deltaHeight = this._correctOnePxGap(deltaHeight);
                        deltaTime = 60000 * deltaHeight / this._defaultHeight * this.instance.option("appointmentDurationInMinutes")
                    }
                    return deltaTime
                },
                getAppointmentGeometry: function(coordinates) {
                    var result;
                    if (coordinates.allDay)
                        result = this._getAllDayAppointmentGeometry(coordinates);
                    else
                        result = this._getSimpleAppointmentGeometry(coordinates);
                    return this.callBase(result)
                },
                _correctOnePxGap: function(deltaHeight) {
                    if (Math.abs(deltaHeight) % this._defaultHeight)
                        deltaHeight--;
                    return deltaHeight
                },
                _getMinuteHeight: function() {
                    return this._defaultHeight / this.instance.option("appointmentDurationInMinutes")
                },
                _getAllDayAppointmentGeometry: function(coordinates) {
                    var maxHeight = this._allDayHeight || this.getAppointmentDefaultSize(),
                        index = coordinates.index,
                        count = coordinates.count,
                        height = maxHeight / (count > 3 ? 3 : count),
                        width = coordinates.width,
                        top = coordinates.top + index * height,
                        left = coordinates.left,
                        compactAppointmentDefaultSize = this.getCompactAppointmentDefaultSize();
                    if (!this.instance.option("allowResize") || !this.instance.option("allowAllDayResize"))
                        coordinates.skipResizing = true;
                    if (count > 3)
                        if (index > 1) {
                            top = coordinates.top;
                            left = coordinates.left + (index - 2) * compactAppointmentDefaultSize;
                            height = compactAppointmentDefaultSize,
                            width = compactAppointmentDefaultSize;
                            coordinates.skipResizing = true;
                            this._markAppointmentAsVirtual(coordinates, true)
                        }
                        else
                            top += height;
                    if (this._isRtl())
                        left -= width;
                    return {
                            height: height,
                            width: width,
                            top: top,
                            left: left
                        }
                },
                _getSimpleAppointmentGeometry: function(coordinates) {
                    var maxWidth = this._defaultWidth - WEEK_APPOINTMENT_DEFAULT_OFFSET || this.getAppointmentDefaultSize(),
                        width = maxWidth / coordinates.count,
                        height = coordinates.height,
                        top = coordinates.top,
                        left = coordinates.left + coordinates.index * width;
                    if (this._isRtl())
                        left -= maxWidth;
                    return {
                            height: height,
                            width: width,
                            top: top,
                            left: left
                        }
                },
                isAllDay: function(item) {
                    var appointmentTakesAllDay = false;
                    this.instance.notifyObserver("appointmentTakesAllDay", {
                        startDate: DX.utils.makeDate(item.startDate),
                        endDate: DX.utils.makeDate(item.endDate),
                        callback: function(result) {
                            appointmentTakesAllDay = result
                        }
                    });
                    return item.allDay || appointmentTakesAllDay
                },
                calculateAppointmentWidth: function(appointment) {
                    if (!this.isAllDay(appointment))
                        return 0;
                    var startDate = this._startDate(appointment),
                        endDate = this._endDate(appointment),
                        cellWidth = this._defaultWidth || this.getAppointmentDefaultSize();
                    var durationInHours = (endDate.getTime() - startDate.getTime()) / 3600000;
                    var width = Math.ceil(durationInHours / 24) * cellWidth;
                    return width
                },
                calculateAppointmentHeight: function(appointment) {
                    if (this.isAllDay(appointment))
                        return 0;
                    var startDate = this._startDate(appointment),
                        endDate = this._endDate(appointment);
                    var durationInMinutes = (endDate.getTime() - startDate.getTime()) / 60000,
                        minHeight = this.getAppointmentDefaultSize();
                    var height = Math.round(durationInMinutes * this._getMinuteHeight());
                    if (height < minHeight)
                        height = minHeight;
                    return height
                },
                _sortCondition: function(a, b) {
                    var allDayCondition = a.allDay - b.allDay;
                    return allDayCondition ? allDayCondition : this._rowCondition(a, b)
                }
            });
        ui.dxScheduler.VerticalAppointmentsStrategy = VerticalRenderingStrategy
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.appointments.dropDown.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.translator,
            DROPDOWN_APPOINTMENTS_CLASS = "dx-scheduler-dropdown-appointments",
            DROPDOWN_APPOINTMENTS_CONTENT_CLASS = "dx-scheduler-dropdown-appointments-content",
            DROPDOWN_APPOINTMENT_CLASS = "dx-scheduler-dropdown-appointment",
            DROPDOWN_APPOINTMENT_TITLE_CLASS = "dx-scheduler-dropdown-appointment-title",
            DROPDOWN_APPOINTMENT_DATE_CLASS = "dx-scheduler-dropdown-appointment-date",
            DROPDOWN_APPOINTMENT_REMOVE_BUTTON_CLASS = "dx-scheduler-dropdown-appointment-remove-button",
            DROPDOWN_APPOINTMENT_EDIT_BUTTON_CLASS = "dx-scheduler-dropdown-appointment-edit-button",
            DROPDOWN_APPOINTMENT_INFO_BLOCK_CLASS = "dx-scheduler-dropdown-appointment-info-block",
            DROPDOWN_APPOINTMENT_BUTTONS_BLOCK_CLASS = "dx-scheduler-dropdown-appointment-buttons-block";
        ui.dxScheduler.dropDownAppointments = {
            render: function(options, instance) {
                var coordinates = options.coordinates,
                    items = options.items;
                this.instance = instance;
                var $menu = $("<div>").addClass(DROPDOWN_APPOINTMENTS_CLASS).appendTo(options.$container);
                this.instance._createComponent($menu, "dxButton", {
                    template: this._createButtonTemplate(items.length),
                    width: options.buttonWidth,
                    onClick: $.proxy(function() {
                        this._createDropDownMenu($menu, items, options.itemTemplate, options.color, options.buttonWidth)
                    }, this)
                });
                if (options.color)
                    $menu.css("background-color", options.color);
                this._applyInnerShadow($menu, options.buttonWidth);
                translator.move($menu, {
                    top: coordinates.top,
                    left: coordinates.left
                });
                return $menu
            },
            _createButtonTemplate: function(appointmentCount) {
                return $("<div />").html([$("<span />").text(appointmentCount), $("<span />").text("...")]).addClass(DROPDOWN_APPOINTMENTS_CONTENT_CLASS)
            },
            _applyInnerShadow: function($element) {
                $element.css("box-shadow", "inset " + $element.outerWidth() + "px 0 0 0 rgba(0, 0, 0, 0.3)")
            },
            _createDropDownMenu: function($element, items, itemTemplate, color, buttonWidth) {
                if (!$element.data("dxDropDownMenu")) {
                    itemTemplate = $.proxy(function(appointmentData, index, appointmentElement) {
                        this._createDropDownAppointmentTemplate(appointmentData, index, appointmentElement, color)
                    }, this);
                    this.instance._createComponent($element, "dxDropDownMenu", {
                        buttonIcon: null,
                        usePopover: true,
                        popupHeight: 200,
                        items: items,
                        buttonTemplate: this._createButtonTemplate(items.length),
                        buttonWidth: buttonWidth,
                        onItemClick: function(args) {
                            args.component.open()
                        },
                        activeStateEnabled: false,
                        focusStateEnabled: false,
                        itemTemplate: itemTemplate
                    }).open()
                }
            },
            _createDropDownAppointmentTemplate: function(appointmentData, index, appointmentElement, color) {
                var dateString = "",
                    appointmentMarkup = [],
                    borderSide = "left",
                    $title,
                    $date,
                    $infoBlock;
                appointmentElement.addClass(DROPDOWN_APPOINTMENT_CLASS);
                if (this.instance.option("rtlEnabled"))
                    borderSide = "right";
                if (color)
                    appointmentElement.css("border-" + borderSide + "-color", color);
                this.instance.fire("normalizeAppointmentDates", {
                    appointmentData: appointmentData,
                    callback: function(result) {
                        appointmentData = result
                    }
                });
                this.instance.fire("formatDates", {
                    startDate: appointmentData.startDate,
                    endDate: appointmentData.endDate,
                    formatType: "DATETIME",
                    callback: function(result) {
                        dateString = result
                    }
                });
                $infoBlock = $("<div />").addClass(DROPDOWN_APPOINTMENT_INFO_BLOCK_CLASS);
                $title = $("<div>").addClass(DROPDOWN_APPOINTMENT_TITLE_CLASS).text(appointmentData.text);
                $date = $("<div>").addClass(DROPDOWN_APPOINTMENT_DATE_CLASS).text(dateString);
                $infoBlock.append([$title, $date]);
                appointmentMarkup.push($infoBlock);
                if (this.instance.option("editing"))
                    appointmentMarkup.push(this._createButtons(appointmentData));
                appointmentElement.append(appointmentMarkup)
            },
            _createButtons: function(appointmentData) {
                var $container = $("<div />").addClass(DROPDOWN_APPOINTMENT_BUTTONS_BLOCK_CLASS),
                    $removeButton = $("<div>").addClass(DROPDOWN_APPOINTMENT_REMOVE_BUTTON_CLASS),
                    $editButton = $("<div>").addClass(DROPDOWN_APPOINTMENT_EDIT_BUTTON_CLASS);
                $container.append([$removeButton, $editButton]);
                this.instance._createComponent($removeButton, "dxButton", {
                    icon: "trash",
                    height: 25,
                    width: 25,
                    onClick: $.proxy(function(e) {
                        e.jQueryEvent.stopPropagation();
                        this.instance.deleteAppointment(appointmentData)
                    }, this)
                });
                this.instance._createComponent($editButton, "dxButton", {
                    icon: "edit",
                    height: 25,
                    width: 25,
                    onClick: $.proxy(function(e) {
                        e.jQueryEvent.stopPropagation();
                        this.instance.fire("showEditAppointmentPopup", appointmentData)
                    }, this)
                });
                return $container
            }
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.scheduler.appointments.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            translator = DX.translator,
            events = ui.events,
            utils = DX.utils;
        var COMPONENT_CLASS = "dx-scheduler-scrollable-appointments",
            APPOINTMENT_ITEM_CLASS = "dx-scheduler-appointment",
            APPOINTMENT_ALL_DAY_ITEM_CLASS = "dx-scheduler-all-day-appointment",
            RECURRENCE_APPOINTMENT_CLASS = "dx-scheduler-appointment-recurrence",
            REDUCED_APPOINTMENT_CLASS = "dx-scheduler-appointment-reduced",
            REDUCED_APPOINTMENT_ICON = "dx-appointment-reduced-icon",
            EMPTY_APPOINTMENT_CLASS = "dx-scheduler-appointment-empty",
            REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME = events.addNamespace("dxpointerenter", "dxSchedulerAppointment"),
            REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME = events.addNamespace("dxpointerleave", "dxSchedulerAppointment"),
            DBLCLICK_EVENT_NAME = events.addNamespace("dxdblclick", "dxSchedulerAppointment"),
            EMPTY_APPOINTMENT_MAX_WIDTH = 40;
        DX.registerComponent("dxSchedulerAppointments", ui.dxScheduler, ui.CollectionWidget.inherit({
            _supportedKeys: function(e) {
                var parent = this.callBase();
                return $.extend(parent, {
                        escape: $.proxy(function() {
                            this.moveAppointmentBack();
                            this._escPressed = true
                        }, this),
                        del: $.proxy(function(e) {
                            var data = this._getItemData(e.target);
                            this.notifyObserver("deleteAppointment", data)
                        })
                    })
            },
            _moveFocus: $.noop,
            _focusTarget: function() {
                return this._itemElements()
            },
            _focusInHandler: function(e) {
                this.callBase.apply(this, arguments);
                this.option("focusedElement", $(e.target))
            },
            _keyboardEventBindingTarget: function() {
                return this._itemContainer()
            },
            _setDefaultOptions: function() {
                this.callBase();
                this.option({
                    noDataText: null,
                    activeStateEnabled: true,
                    hoverStateEnabled: true,
                    tabIndex: 0,
                    appointmentDurationInMinutes: 30,
                    fixedContainer: null,
                    renderingStrategy: "vertical",
                    allowDrag: true,
                    allowResize: true,
                    allowAllDayResize: true
                })
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"appointmentDurationInMinutes":
                        break;
                    case"renderingStrategy":
                        this._initRenderingStrategy();
                        break;
                    case"fixedContainer":
                        break;
                    case"allowDrag":
                    case"allowResize":
                    case"allowAllDayResize":
                        this.repaint();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _itemClass: function() {
                return APPOINTMENT_ITEM_CLASS
            },
            _itemContainer: function() {
                var $container = this.callBase(),
                    $result = $container,
                    $fixedContainer = this.option("fixedContainer");
                if ($fixedContainer)
                    $result = $container.add($fixedContainer);
                return $result
            },
            _cleanItemContainer: function() {
                this.callBase();
                var $fixedContainer = this.option("fixedContainer");
                if ($fixedContainer)
                    $fixedContainer.empty();
                this._virtualAppointments = {}
            },
            _clean: function() {
                this.callBase();
                delete this._$currentAppointment;
                delete this._initialSize;
                delete this._initialCoordinates
            },
            _init: function() {
                this.callBase();
                this._initRenderingStrategy();
                this.element().addClass(COMPONENT_CLASS);
                this._preventSingleAppointmentClick = false
            },
            _initRenderingStrategy: function() {
                this._renderingStrategy = this.option("renderingStrategy") === "horizontal" ? new ui.dxScheduler.HorizontalAppointmentsStrategy(this) : new ui.dxScheduler.VerticalAppointmentsStrategy(this)
            },
            _executeItemRenderAction: function(index, itemData, itemElement) {
                var action = this._getItemRenderAction();
                if (action)
                    action({
                        appointmentElement: itemElement,
                        appointmentIndex: index,
                        appointment: itemData
                    })
            },
            _createItemRenderAction: function() {
                this.notifyObserver("initAppointmentRenderedAction", {callback: $.proxy(function(action) {
                        this._itemRenderAction = action
                    }, this)});
                return this._itemRenderAction
            },
            _getStartDate: function(appointment, skipNormalize) {
                var startDate = utils.makeDate(appointment.startDate);
                !skipNormalize && this.notifyObserver("updateAppointmentStartDate", {
                    startDate: startDate,
                    callback: function(result) {
                        startDate = result
                    }
                });
                return startDate
            },
            _getEndDate: function(appointment) {
                var result = appointment.endDate;
                if (result)
                    return utils.makeDate(result);
                return result
            },
            _itemClickHandler: function(e) {
                this._createAction($.proxy(function(e) {
                    this._processItemClick(e.jQueryEvent)
                }, this))({jQueryEvent: e});
                this.callBase(e)
            },
            _processItemClick: function(e) {
                var target = e.currentTarget,
                    data = this._getItemData(target);
                if ($(target).is(".dx-state-disabled, .dx-state-disabled *")) {
                    e.stopPropagation();
                    return
                }
                this._normalizeAppointmentDates(data);
                if (e.type === "keydown") {
                    this.notifyObserver("showEditAppointmentPopup", data);
                    return
                }
                this._appointmentClickTimeout = setTimeout($.proxy(function() {
                    if (!this._preventSingleAppointmentClick)
                        this.notifyObserver("showAppointmentTooltip", {
                            data: data,
                            target: target
                        });
                    this._preventSingleAppointmentClick = false
                }, this), 300)
            },
            _normalizeAppointmentDates: function(appointmentData) {
                var startDate = DX.utils.makeDate(appointmentData.startDate),
                    endDate = DX.utils.makeDate(appointmentData.endDate);
                appointmentData.startDate = startDate;
                appointmentData.endDate = endDate
            },
            _renderItems: function(items) {
                if (this._isContainerInvisible())
                    return;
                this._positionMap = this._renderingStrategy.createTaskPositionMap(items);
                this.callBase(items)
            },
            _renderItem: function(index, itemData) {
                var $fixedContainer = this.option("fixedContainer"),
                    $container = this.itemsContainer().not($fixedContainer);
                if (this._renderingStrategy.isAllDay(itemData) && $fixedContainer)
                    $container = $fixedContainer;
                this.callBase(index, itemData, $container)
            },
            _toggleAllDayClass: function($element, value) {
                $element.toggleClass(APPOINTMENT_ALL_DAY_ITEM_CLASS, !!value)
            },
            _virtualAppointments: {},
            _postprocessRenderItem: function(args) {
                var $appointment = args.itemElement,
                    itemData = args.itemData,
                    itemSettings = this._positionMap[args.itemIndex];
                this._toggleAllDayClass($appointment, this._renderingStrategy.isAllDay(itemData));
                this._attachAppointmentDblclick($appointment, itemData);
                var deferredColor = this._paintAppointment($appointment, 0);
                utils.getRecurrenceRule(itemData.recurrenceRule).isValid && $appointment.addClass(RECURRENCE_APPOINTMENT_CLASS);
                this._applyResourceDataAttr($appointment);
                this._renderAppointmentClones($appointment, itemSettings);
                this._renderAppointmentGeometry($appointment, itemSettings[0]);
                this._renderDraggable($appointment);
                if (!itemSettings[0].skipResizing)
                    this._renderResizable($appointment, itemSettings[0]);
                if (itemSettings[0].appointmentReduced)
                    this._renderAppointmentReducedIcon($appointment);
                if (itemSettings[0].virtual)
                    deferredColor.done($.proxy(function(color) {
                        this._processVirtualAppointment(itemSettings[0], $appointment, itemData, color)
                    }, this))
            },
            _processVirtualAppointment: function(appointmentSetting, $appointment, itemData, color) {
                var virtualAppointment = appointmentSetting.virtual,
                    virtualGroupIndex = virtualAppointment.groupIndex;
                if (!utils.isDefined(this._virtualAppointments[virtualGroupIndex]))
                    this._virtualAppointments[virtualGroupIndex] = {
                        coordinates: {
                            top: virtualAppointment.top,
                            left: virtualAppointment.left
                        },
                        items: [],
                        isAllDay: virtualAppointment.isAllDay,
                        color: color
                    };
                this._virtualAppointments[virtualGroupIndex].items.push(itemData);
                $appointment.remove()
            },
            _renderContentImpl: function() {
                this.callBase();
                this._renderDropDownAppointments()
            },
            _renderDropDownAppointments: function() {
                var buttonWidth = this._renderingStrategy.getCompactAppointmentGroupMaxWidth(),
                    rtlOffset = 0;
                if (this.option("rtlEnabled"))
                    rtlOffset = this._calculateDropDownButtonRtlOffset(buttonWidth);
                $.each(this._virtualAppointments, $.proxy(function(groupIndex, appointment) {
                    var virtualGroup = this._virtualAppointments[groupIndex],
                        virtualItems = virtualGroup.items,
                        virtualCoordinates = virtualGroup.coordinates,
                        $container = virtualGroup.isAllDay ? this.option("fixedContainer") : this.element(),
                        left = virtualCoordinates.left;
                    this.notifyObserver("renderDropDownAppointments", {
                        $container: $container,
                        coordinates: {
                            top: virtualCoordinates.top,
                            left: left + rtlOffset
                        },
                        items: virtualItems,
                        color: virtualGroup.color,
                        itemTemplate: this.option("itemTemplate"),
                        buttonWidth: buttonWidth
                    })
                }, this))
            },
            _calculateDropDownButtonRtlOffset: function(dropDownWidth) {
                return this._renderingStrategy.getDefaultCellWidth() - dropDownWidth
            },
            _renderAppointmentGeometry: function($appointment, coordinates) {
                var geometry = this._renderingStrategy.getAppointmentGeometry(coordinates);
                if (!this.option("allowResize"))
                    coordinates.skipResizing = true;
                translator.move($appointment, {
                    top: geometry.top,
                    left: geometry.left
                });
                $appointment.css({
                    width: geometry.width,
                    height: geometry.height
                });
                if (this.option("strategy") === "horizontal") {
                    if (coordinates.index > 1 || geometry.width < EMPTY_APPOINTMENT_MAX_WIDTH)
                        $appointment.addClass(EMPTY_APPOINTMENT_CLASS)
                }
                else if (geometry.width < EMPTY_APPOINTMENT_MAX_WIDTH)
                    $appointment.addClass(EMPTY_APPOINTMENT_CLASS)
            },
            _isContainerInvisible: function() {
                var isContainerInvisible = false;
                this.notifyObserver("checkContainerVisibility", {callback: function(result) {
                        isContainerInvisible = result
                    }});
                return isContainerInvisible
            },
            _attachAppointmentDblclick: function($appointment, appointmentData) {
                var dblClickAction = this._createAction($.proxy(function() {
                        clearTimeout(this._appointmentClickTimeout);
                        this._preventSingleAppointmentClick = true;
                        this.notifyObserver("showEditAppointmentPopup", appointmentData)
                    }, this));
                $appointment.off(DBLCLICK_EVENT_NAME).on(DBLCLICK_EVENT_NAME, $.proxy(function(e) {
                    dblClickAction({jQueryEvent: e})
                }, this))
            },
            _applyResourceDataAttr: function($appointment) {
                this.notifyObserver("getResourcesFromItem", {
                    itemData: this._getItemData($appointment),
                    callback: function(resources) {
                        if (resources)
                            $.each(resources, function(name, values) {
                                var attr = "data-" + name.toLowerCase() + "-";
                                for (var i = 0; i < values.length; i++)
                                    $appointment.attr(attr + values[i], true)
                            })
                    }
                })
            },
            _renderDraggable: function($appointment) {
                if (!this.option("allowDrag"))
                    return;
                var that = this,
                    appointmentData = that._getItemData($appointment),
                    isAllDay = this._renderingStrategy.isAllDay(appointmentData),
                    $fixedContainer = this.option("fixedContainer"),
                    $scheduler = $appointment.closest(".dx-scheduler"),
                    scheduler = $scheduler.dxScheduler("instance"),
                    draggableArea = scheduler ? scheduler.getWorkSpaceScrollableContainer() : undefined,
                    allDayPanelHeight = scheduler ? scheduler.getWorkSpaceAllDayHeight() : 0;
                this._createComponent($appointment, "dxDraggable", {
                    onDragStart: function(e) {
                        that.notifyObserver("hideAppointmentTooltip");
                        e.jQueryEvent.targetElements = $scheduler;
                        if (!isAllDay && $fixedContainer)
                            $fixedContainer.append($appointment);
                        that._$currentAppointment = $(e.element);
                        that._initialSize = {
                            width: e.width,
                            height: e.height
                        };
                        that._initialCoordinates = translator.locate(e.element)
                    },
                    onDrag: function(e) {
                        var scrollTop = scheduler && !isAllDay ? scheduler.getWorkSpaceScrollableScrollTop() - allDayPanelHeight : 0,
                            currentCoordinates = translator.locate(e.element);
                        translator.move($appointment, {top: currentCoordinates.top - scrollTop})
                    },
                    onDragEnd: function(e) {
                        if (!isAllDay)
                            that.element().append($appointment);
                        if (this._escPressed) {
                            e.jQueryEvent.cancel = true;
                            return
                        }
                        that._dragEndHandler(e)
                    },
                    area: draggableArea,
                    boundOffset: {
                        left: 0,
                        top: -allDayPanelHeight,
                        right: 0,
                        bottom: 0
                    }
                })
            },
            _renderResizable: function($appointment, itemSetting) {
                var appointmentData = this._getItemData($appointment),
                    config = this._renderingStrategy.resizableConfig(appointmentData);
                $.extend(config, {
                    area: this._calculateResizableArea(itemSetting, appointmentData),
                    onResizeStart: $.proxy(function(e) {
                        this._$currentAppointment = $(e.element);
                        this._initialSize = {
                            width: e.width,
                            height: e.height
                        };
                        this._initialCoordinates = translator.locate(e.element)
                    }, this),
                    onResizeEnd: $.proxy(function(e) {
                        if (this._escPressed) {
                            e.jQueryEvent.cancel = true;
                            return
                        }
                        this._resizeEndHandler(e)
                    }, this)
                });
                this._createComponent($appointment, "dxResizable", config)
            },
            _calculateResizableArea: function(itemSetting, appointmentData) {
                var area = this.element().closest(".dx-scrollable-content"),
                    allDay = this._renderingStrategy.isAllDay(appointmentData);
                this.notifyObserver("getResizableAppointmentArea", {
                    coordinates: {
                        left: itemSetting.left,
                        top: 0
                    },
                    allDay: allDay,
                    callback: function(result) {
                        if (result)
                            area = result
                    }
                });
                return area
            },
            _paintAppointment: function($appointment, resourceIndex) {
                var res = $.Deferred();
                this.notifyObserver("getAppointmentColor", {
                    itemData: this._getItemData($appointment),
                    resourceIndex: resourceIndex,
                    callback: function(d) {
                        d.done(function(color) {
                            if (color)
                                $appointment.css("background-color", color);
                            res.resolve(color)
                        })
                    }
                });
                return res.promise()
            },
            _renderAppointmentReducedIcon: function($appointment) {
                $appointment.toggleClass(REDUCED_APPOINTMENT_CLASS, true);
                var $icon = $("<div>").addClass(REDUCED_APPOINTMENT_ICON).appendTo($appointment),
                    endDate = this._getEndDate(this._getItemData($appointment));
                $icon.off(REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME).on(REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME, function() {
                    ui.tooltip.show({
                        target: $icon,
                        content: Globalize.localize("dxScheduler-editorLabelEndDate") + ": " + Globalize.format(endDate, "d MMMM yyyy")
                    })
                }).off(REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME).on(REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME, function() {
                    ui.tooltip.hide()
                });
                $icon.on("dxclick", function(e) {
                    e.stopPropagation()
                })
            },
            _renderAppointmentClones: function($appointment, coordinates) {
                var coordinateCount = coordinates.length;
                if (coordinateCount > 1) {
                    var clones = [],
                        itemData = this._getItemData($appointment),
                        resourceForPaintingField = this._getResourceForPaintingField();
                    for (var i = coordinateCount - 1; i > 0; i--) {
                        var $clone = $appointment.clone(true);
                        $appointment.after($clone);
                        translator.clearCache($clone);
                        this._renderAppointmentGeometry($clone, coordinates[i]);
                        this._renderDraggable($clone);
                        if (!coordinates[i].skipResizing)
                            this._renderResizable($clone, coordinates[i]);
                        if (coordinates[i].appointmentReduced)
                            this._renderAppointmentReducedIcon($clone);
                        if (coordinates[i].virtual) {
                            clones.push({
                                element: $clone,
                                virtualCoordinates: coordinates[i]
                            });
                            if (!resourceForPaintingField)
                                this._processVirtualAppointment(coordinates[i], $clone, itemData)
                        }
                        else
                            clones.push({element: $clone})
                    }
                    if (resourceForPaintingField)
                        this._paintClones(clones, coordinates, itemData, resourceForPaintingField)
                }
            },
            _paintClones: function(clones, coordinates, itemData, resourceForPaintingField) {
                var resourceValues = DX.utils.wrapToArray(itemData[resourceForPaintingField]),
                    coordinateCount = coordinates.length;
                this._iterateArray(resourceValues, coordinateCount - 1, function(elementIndex, iterationIndex) {
                    var currentClone = clones[iterationIndex];
                    this._paintAppointment(currentClone.element, elementIndex).done($.proxy(function(color) {
                        if (currentClone.virtualCoordinates)
                            this._processVirtualAppointment(currentClone.virtualCoordinates, currentClone.element, itemData, color)
                    }, this))
                }, 1)
            },
            _getResourceForPaintingField: function() {
                var resourceForPainting;
                this.notifyObserver("getResourceForPainting", {callback: function(resource) {
                        if (resource)
                            resourceForPainting = resource.field
                    }});
                return resourceForPainting
            },
            _iterateArray: function(array, iterationCount, callback, startIndex) {
                startIndex = startIndex || 0;
                var arrayLength = array.length;
                for (var i = 0; i < iterationCount; i++) {
                    var elementIndex = startIndex + i;
                    if (elementIndex >= arrayLength)
                        elementIndex = elementIndex % arrayLength;
                    callback.call(this, elementIndex, i)
                }
            },
            _getDateRange: function(e, startDate, endDate) {
                var itemData = this._getItemData(e.element),
                    deltaTime = this._renderingStrategy.getDeltaTime(e, this._initialSize, itemData),
                    cond = false;
                if (this.option("renderingStrategy") === "horizontal" || this._renderingStrategy.isAllDay(itemData))
                    cond = this.option("rtlEnabled") ? e.handles.right : e.handles.left;
                else
                    cond = e.handles.top;
                var startTime = cond ? startDate.getTime() - deltaTime : startDate.getTime(),
                    endTime = cond ? endDate.getTime() : endDate.getTime() + deltaTime;
                return [startTime, endTime]
            },
            _resizeEndHandler: function(e) {
                var itemData = this._getItemData(e.element),
                    startDate = this._getStartDate(itemData),
                    endDate = this._getEndDate(itemData);
                var dateRange = this._getDateRange(e, startDate, endDate);
                var updatedDates = {};
                updatedDates.startDate = new Date(dateRange[0]);
                updatedDates.endDate = new Date(dateRange[1]);
                var data = $.extend({}, itemData, updatedDates);
                this.notifyObserver("updateAppointmentAfterResize", {
                    target: itemData,
                    data: data,
                    $appointment: e.element
                })
            },
            _dragEndHandler: function(e) {
                var itemData = this._getItemData(e.element),
                    coordinates = this._initialCoordinates;
                this._normalizeAppointmentDates(itemData);
                this.notifyObserver("updateAppointmentAfterDrag", {
                    data: itemData,
                    $appointment: e.element,
                    coordinates: coordinates
                })
            },
            moveAppointmentBack: function() {
                var $appointment = this._$currentAppointment,
                    size = this._initialSize,
                    coords = this._initialCoordinates;
                if ($appointment) {
                    if (coords)
                        translator.move($appointment, coords);
                    if (size) {
                        $appointment.outerWidth(size.width);
                        $appointment.outerHeight(size.height)
                    }
                }
            }
        }).include(ui.dxScheduler.PublisherMixin))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file clientExporter.js */
    (function(DX, $) {
        var utils = DX.utils;
        DX.registerComponent("dxClientExporter", DX, DX.Component.inherit({
            NAME: "dxClientExporter",
            _getDocumentCreator: function(exportableComponent, options) {
                if (options.format === "EXCEL")
                    return new DX.dxClientExporter.ExcelCreator(exportableComponent.getDataProvider(), $.extend({rtlEnabled: exportableComponent.option("rtlEnabled")}, options))
            },
            exportTo: function(options) {
                var that = this,
                    eventArgs,
                    exportingAction = this.option("exportingAction"),
                    exportedAction = this.option("exportedAction"),
                    data,
                    documentCreator,
                    exportableComponent = options.component;
                if (exportableComponent) {
                    eventArgs = {
                        fileName: options.fileName,
                        format: options.format,
                        cancel: false
                    };
                    utils.isDefined(exportingAction) && exportingAction(eventArgs);
                    if (!eventArgs.cancel) {
                        documentCreator = that._getDocumentCreator(exportableComponent, options);
                        documentCreator.ready().done(function() {
                            data = documentCreator.getData(utils.isFunction(window.Blob) && !utils.isDefined(window.cordova));
                            utils.isDefined(exportedAction) && exportedAction();
                            DX.dxClientExporter.fileSaver.saveAs(eventArgs.fileName, options.format, data, options.proxyUrl)
                        })
                    }
                }
            }
        }))
    })(DevExpress, jQuery);
    /*! Module widgets-web, file excelCreator.js */
    (function($, DX) {
        var utils = DX.utils,
            Class = DX.Class,
            exporter = DX.dxClientExporter,
            XML_TAG = "<?xml version=\"1.0\" encoding=\"utf-8\"?>",
            GROUP_SHEET_PR_XML = "<sheetPr><outlinePr summaryBelow=\"0\"/></sheetPr>",
            SINGLE_SHEET_PR_XML = "<sheetPr/>",
            BASE_STYLE_XML = "<fonts count=\"2\"><font><sz val=\"11\"/><color theme=\"1\"/><name val=\"Calibri\"/><family val=\"2\"/><scheme val=\"minor\"/></font><font><b/><sz val=\"11\"/><color theme=\"1\"/><name val=\"Calibri\"/><family val=\"2\"/><scheme val=\"minor\"/></font></fonts><fills count=\"1\"><fill><patternFill patternType=\"none\"/></fill></fills><borders count=\"1\"><border><left style=\"thin\"><color rgb=\"FFD3D3D3\"/></left><right style=\"thin\"><color rgb=\"FFD3D3D3\"/></right><top style=\"thin\"><color rgb=\"FFD3D3D3\"/></top><bottom style=\"thin\"><color rgb=\"FFD3D3D3\"/></bottom></border></borders><cellStyleXfs count=\"1\"><xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\"/></cellStyleXfs>",
            OPEN_XML_FORMAT_URL = "http://schemas.openxmlformats.org",
            RELATIONSHIP_PART_NAME = "rels",
            XL_FOLDER_NAME = "xl",
            WORKBOOK_FILE_NAME = "workbook.xml",
            CONTENTTYPES_FILE_NAME = "[Content_Types].xml",
            SHAREDSTRING_FILE_NAME = "sharedStrings.xml",
            STYLE_FILE_NAME = "styles.xml",
            WORKSHEETS_FOLDER = "worksheets",
            WORKSHEET_FILE_NAME = "sheet1.xml",
            UNSUPPORTED_DEFINED_DATE_FORMATS = ["quarter", "quarterAndYear", "millisecond"],
            DEFAULT_DATE_FORMAT = "shortDate",
            DEFINED_NUMBER_FORMTATS = {
                thousands: "#,##0{0},&quot;K&quot;",
                millions: "#,##0{0},,&quot;M&quot;",
                billions: "#,##0{0},,,&quot;B&quot;",
                trillions: "#,##0{0},,,,&quot;T&quot;",
                percent: "0{0}%",
                decimal: "#{0}",
                fixedPoint: "#,##0{0}",
                exponential: "0{0}E+00",
                currency: " "
            },
            EXCEL_START_TIME = Date.UTC(1899, 11, 30),
            DAYS_COUNT_BEFORE_29_FEB_1900 = 60,
            BOLD_STYLES_COUNT = 4,
            MAX_DIGIT_WIDTH_IN_PIXELS = 7,
            CUSTOM_FORMAT_START_INDEX = 165;
        exporter.excelFormatConverter = {
            _applyPrecision: function(format, precision) {
                var result,
                    i;
                if (precision > 0) {
                    result = format !== "decimal" ? "." : "";
                    for (i = 0; i < precision; i++)
                        result += "0";
                    return result
                }
                return ""
            },
            _getCurrencyFormat: function() {
                var currency = Globalize.cultures[Globalize.cultureSelector].numberFormat.currency,
                    i,
                    result,
                    symbol,
                    encodeSymbols;
                if (utils.isArray(currency.pattern)) {
                    encodeSymbols = {
                        n: "#,##0{0}",
                        "'": "\\'",
                        "\\(": "\\(",
                        "\\)": "\\)",
                        " ": "\\ ",
                        "\"": "&quot;",
                        "\\$": currency.symbol
                    };
                    result = currency.pattern.slice();
                    for (symbol in encodeSymbols)
                        for (i = 0; i < result.length; i++)
                            result[i] = result[i].replace(new RegExp(symbol, "g"), encodeSymbols[symbol]);
                    return result.length === 2 ? result[1] + "_);" + result[0] : result[0]
                }
            },
            _convertDateFormat: function(format) {
                if (!DX.DateTimeFormat[format.toLowerCase()] || $.inArray(format, UNSUPPORTED_DEFINED_DATE_FORMATS) !== -1)
                    format = DEFAULT_DATE_FORMAT;
                var datePatterns = Globalize.cultures[Globalize.cultureSelector].calendar.patterns,
                    pattern = DX.DateTimeFormat[format.toLowerCase()];
                if (utils.isDefined(datePatterns[pattern]))
                    pattern = datePatterns[pattern];
                return pattern.replace(/\//g, "\\/").replace(/ /g, "\\ ").replace(/,/g, "\\,").replace(/:/g, "\\:").replace(/tt/g, "AM/PM").replace(/N/g, "#\\,###")
            },
            _convertNumberFormat: function(format, precision) {
                var result,
                    excelFormat = format === "currency" ? this._getCurrencyFormat() : DEFINED_NUMBER_FORMTATS[format];
                if (excelFormat)
                    result = utils.stringFormat(excelFormat, this._applyPrecision(format, precision));
                return result
            },
            convertFormat: function(format, precision, type) {
                if (utils.isDefined(format))
                    if (type === "date")
                        return exporter.excelFormatConverter._convertDateFormat(format);
                    else if (DEFINED_NUMBER_FORMTATS[format])
                        return exporter.excelFormatConverter._convertNumberFormat(format, precision)
            }
        };
        exporter.ExcelCreator = Class.inherit({
            _getXMLTag: function(tagName, attributes, content) {
                var result = ["<"],
                    key;
                result.push(tagName);
                for (key in attributes) {
                    result.push(" ");
                    result.push(key);
                    result.push("=\"");
                    result.push(attributes[key]);
                    result.push("\"")
                }
                if (utils.isDefined(content)) {
                    result.push(">");
                    result.push(content);
                    result.push("</");
                    result.push(tagName);
                    result.push(">")
                }
                else
                    result.push(" />");
                return result.join("")
            },
            _getDataProviderRowIndex: function(dpRowIndex) {
                return dpRowIndex - !!this._dataProvider.isHeadersVisible()
            },
            _getExcelRowIndex: function(exRowIndex) {
                return exRowIndex + !!this._dataProvider.isHeadersVisible()
            },
            _getCellIndex: function(rowIndex, cellIndex) {
                var sheetIndex = '',
                    max = 26,
                    charCode;
                if (this._maxIndex[0] < Number(rowIndex))
                    this._maxIndex[0] = Number(rowIndex);
                if (this._maxIndex[1] < Number(cellIndex))
                    this._maxIndex[1] = Number(cellIndex);
                do {
                    charCode = 65 + (cellIndex >= max ? cellIndex % max : Math.ceil(cellIndex));
                    sheetIndex = String.fromCharCode(charCode) + sheetIndex;
                    if (cellIndex >= max)
                        cellIndex = Math.floor(cellIndex / max) - 1;
                    else
                        break
                } while (true);
                sheetIndex += rowIndex;
                return sheetIndex
            },
            _getDataType: function(dataType) {
                var validTypes = {
                        boolean: "b",
                        date: "d",
                        number: "n",
                        string: "s"
                    };
                return utils.isDefined(validTypes[dataType]) ? validTypes[dataType] : "s"
            },
            _appendFormat: function(format, precision, dataType) {
                format = exporter.excelFormatConverter.convertFormat(format, precision, dataType);
                if (format) {
                    if ($.inArray(format, this._styleFormat) === -1)
                        this._styleFormat.push(format);
                    return $.inArray(format, this._styleFormat) + 1
                }
            },
            _appendString: function(value) {
                if (utils.isDefined(value)) {
                    value = String(value);
                    if (value.length) {
                        value = utils.encodeHtml(value);
                        if ($.inArray(value, this._stringArray) === -1)
                            this._stringArray.push(value);
                        return $.inArray(value, this._stringArray)
                    }
                }
            },
            _getExcelDateValue: function(date) {
                var days,
                    totalTime;
                if (utils.isDate(date)) {
                    days = Math.floor((Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - EXCEL_START_TIME) / (1000 * 60 * 60 * 24));
                    if (days < DAYS_COUNT_BEFORE_29_FEB_1900)
                        days--;
                    totalTime = (date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds()) / (24 * 3600);
                    return days + totalTime
                }
            },
            _prepareValue: function(rowIndex, cellIndex) {
                var value = this._dataProvider.getCellValue(rowIndex, cellIndex),
                    type = this._getDataType(this._dataProvider.getCellType(rowIndex, cellIndex)),
                    formatID = this._styleArray[cellIndex + BOLD_STYLES_COUNT].formatID,
                    format = DX.utils.isNumber(formatID) ? this._styleFormat[formatID - 1] : null;
                switch (type) {
                    case"s":
                        value = this._appendString(value);
                        break;
                    case"d":
                        value = this._getExcelDateValue(value, format);
                        type = "n";
                        break
                }
                return {
                        value: value,
                        type: type
                    }
            },
            _getHeadersArray: function() {
                var i,
                    columns = this._dataProvider.getColumns(),
                    result = [],
                    startIndex = !this._rtlEnabled ? 0 : columns.length - 1,
                    endIndex = !this._rtlEnabled ? columns.length : -1,
                    counter = !this._rtlEnabled ? 1 : -1;
                for (i = startIndex; i !== endIndex; i += counter)
                    result.push({
                        style: 0,
                        type: "s",
                        value: this._appendString(columns[i].caption)
                    });
                return result
            },
            _getDataArray: function() {
                var rowIndex,
                    cellIndex,
                    cellsArray,
                    cellData,
                    result = [],
                    type,
                    styleID,
                    columns = this._dataProvider.getColumns(),
                    startIndex = !this._rtlEnabled ? 0 : columns.length - 1,
                    endIndex = !this._rtlEnabled ? columns.length : -1;
                for (rowIndex = 0; rowIndex < this._dataProvider.getRowsCount(); rowIndex++) {
                    cellsArray = [];
                    for (cellIndex = startIndex; cellIndex !== endIndex; cellIndex += !this._rtlEnabled ? 1 : -1) {
                        cellData = this._prepareValue(rowIndex, cellIndex);
                        type = cellData.type;
                        if (!this._dataProvider.isGroupRow(rowIndex) && utils.isDefined(this._styleArray[cellIndex + BOLD_STYLES_COUNT].formatID) && cellData.type !== "s")
                            type = "n";
                        styleID = cellIndex + BOLD_STYLES_COUNT;
                        if (this._dataProvider.isGroupRow(rowIndex))
                            styleID = BOLD_STYLES_COUNT - 1;
                        if (this._dataProvider.isTotalCell(rowIndex, cellIndex))
                            styleID = this._getBoldStyleID(columns[cellIndex].alignment);
                        cellsArray.push({
                            style: styleID,
                            value: cellData.value,
                            type: type
                        })
                    }
                    if (rowIndex && !this._needSheetPr && this._dataProvider.getGroupLevel(this._getDataProviderRowIndex(rowIndex)) > 0)
                        this._needSheetPr = true;
                    result.push(cellsArray)
                }
                return result
            },
            _getBoldStyleID: function(alignment) {
                for (var i = 0; i < BOLD_STYLES_COUNT - 1; i++)
                    if (this._styleArray[i].alignment === alignment)
                        return i
            },
            _culculateWidth: function(pixelsWidth) {
                return Math.min(255, Math.floor((pixelsWidth - 5) / MAX_DIGIT_WIDTH_IN_PIXELS * 100 + 0.5) / 100)
            },
            _prepareStyleData: function() {
                var i,
                    column,
                    wrapText = Number(!!this._options.wrapTextEnabled),
                    alignments = ["center", "left", "right"],
                    columns = this._dataProvider.getColumns();
                for (i = 0; i < alignments.length; i++)
                    this._styleArray.push({
                        bold: true,
                        alignment: alignments[i],
                        wrapText: 1
                    });
                this._styleArray.push({
                    bold: true,
                    alignment: utils.getDefaultAlignment(this._rtlEnabled),
                    wrapText: 0
                });
                for (i = 0; i < columns.length; i++) {
                    column = columns[i];
                    this._styleArray.push({
                        alignment: utils.isDefined(column.alignment) ? column.alignment : "left",
                        formatID: this._appendFormat(column.format, column.precision, column.dataType),
                        wrapText: wrapText
                    });
                    this._colsArray.push(this._culculateWidth(column.width))
                }
            },
            _prepareCellData: function() {
                if (this._dataProvider.isHeadersVisible())
                    this._cellsArray.push(this._getHeadersArray());
                this._cellsArray = this._cellsArray.concat(this._getDataArray())
            },
            _createXMLRelationships: function(xmlRelationships) {
                return this._getXMLTag("Relationships", {xmlns: OPEN_XML_FORMAT_URL + "/package/2006/relationships"}, xmlRelationships)
            },
            _createXMLRelationship: function(id, type, target) {
                return this._getXMLTag("Relationship", {
                        Id: "rId" + id,
                        Type: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships/" + type,
                        Target: target
                    })
            },
            _getWorkbookContent: function() {
                var content = "<bookViews><workbookView xWindow=\"0\" yWindow=\"0\" windowWidth=\"0\" windowHeight=\"0\"/></bookViews><sheets><sheet name=\"Sheet\" sheetId=\"1\" r:id=\"rId1\" /></sheets><definedNames><definedName name=\"_xlnm.Print_Titles\" localSheetId=\"0\">Sheet!$1:$1</definedName><definedName name=\"_xlnm._FilterDatabase\" hidden=\"0\" localSheetId=\"0\">Sheet!$A$1:$F$6332</definedName></definedNames>";
                return XML_TAG + this._getXMLTag("workbook", {
                        "xmlns:r": OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships",
                        xmlns: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
                    }, content)
            },
            _getContentTypesContent: function() {
                return XML_TAG + "<Types xmlns=\"" + OPEN_XML_FORMAT_URL + "/package/2006/content-types\"><Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\" /><Default Extension=\"xml\" ContentType=\"application/xml\" /><Override PartName=\"/xl/worksheets/sheet1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\" /><Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\" /><Override PartName=\"/xl/sharedStrings.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\" /><Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\" /></Types>"
            },
            _generateStylesXML: function() {
                var xlFolder = this._zip.folder(XL_FOLDER_NAME),
                    styleIndex,
                    style,
                    xmlStyles = [],
                    formatIndex,
                    XML = "";
                for (formatIndex in this._styleFormat)
                    this._styleFormat[formatIndex] = this._getXMLTag("numFmt", {
                        numFmtId: Number(formatIndex) + CUSTOM_FORMAT_START_INDEX,
                        formatCode: this._styleFormat[formatIndex]
                    });
                XML += this._getXMLTag("numFmts", {count: this._styleFormat.length}, this._styleFormat.join(""));
                XML += BASE_STYLE_XML;
                for (styleIndex in this._styleArray) {
                    style = this._styleArray[styleIndex];
                    xmlStyles.push(this._getXMLTag("xf", {
                        xfId: 0,
                        applyAlignment: 1,
                        fontId: Number(!!style.bold),
                        applyNumberFormat: utils.isDefined(style.formatID) ? 1 : 0,
                        numFmtId: utils.isDefined(style.formatID) ? Number(style.formatID) + CUSTOM_FORMAT_START_INDEX - 1 : 0
                    }, this._getXMLTag("alignment", {
                        horizontal: style.alignment,
                        wrapText: style.wrapText
                    })))
                }
                XML += this._getXMLTag("cellXfs", {count: xmlStyles.length}, xmlStyles.join(""));
                XML += this._getXMLTag("cellStyles", {count: 1}, this._getXMLTag("cellStyle", {
                    name: "Normal",
                    xfId: 0,
                    builtinId: 0
                }));
                XML = XML_TAG + this._getXMLTag("styleSheet", {xmlns: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"}, XML);
                xlFolder.file(STYLE_FILE_NAME, XML);
                this._styleArray = []
            },
            _generateStringsXML: function() {
                var xlFolder = this._zip.folder(XL_FOLDER_NAME),
                    stringIndex,
                    sharedStringXml = XML_TAG;
                for (stringIndex in this._stringArray)
                    this._stringArray[stringIndex] = this._getXMLTag("si", {}, this._getXMLTag("t", {}, this._stringArray[stringIndex]));
                sharedStringXml += this._getXMLTag("sst", {
                    xmlns: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main",
                    count: this._stringArray.length,
                    uniqueCount: this._stringArray.length
                }, this._stringArray.join(""));
                xlFolder.file(SHAREDSTRING_FILE_NAME, sharedStringXml);
                this._stringArray = []
            },
            _generateWorksheetXML: function() {
                var colIndex,
                    rowIndex,
                    cellData,
                    xmlCells,
                    maxCellIndex,
                    counter = 0,
                    xmlRows = [],
                    rSpans = "1:" + this._colsArray.length,
                    xmlResult = [["<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">", this._needSheetPr ? GROUP_SHEET_PR_XML : SINGLE_SHEET_PR_XML, "<dimension ref=\"A1:", this._getCellIndex(this._maxIndex[0], this._maxIndex[1]) + "\"/><sheetViews><sheetView tabSelected=\"1\" workbookViewId=\"0\"><pane ySplit=\"1\" topLeftCell=\"A2\" activePane=\"bottomLeft\" state=\"frozen\"/></sheetView></sheetViews><sheetFormatPr defaultRowHeight=\"15\" outlineLevelRow=\"", this._dataProvider.getRowsCount() > 0 ? this._dataProvider.getGroupLevel(0) : 0, "\" x14ac:dyDescent=\"0.25\"/>"].join("")];
                for (colIndex in this._colsArray)
                    this._colsArray[colIndex] = this._getXMLTag("col", {
                        width: this._colsArray[colIndex],
                        min: Number(colIndex) + 1,
                        max: Number(colIndex) + 1
                    });
                xmlResult.push(this._getXMLTag("cols", [], this._colsArray.join("")) + "<sheetData>");
                for (rowIndex in this._cellsArray) {
                    xmlCells = [];
                    for (colIndex in this._cellsArray[rowIndex]) {
                        rowIndex = Number(rowIndex);
                        cellData = this._cellsArray[rowIndex][colIndex];
                        xmlCells.push(this._getXMLTag("c", {
                            r: this._getCellIndex(rowIndex + 1, colIndex),
                            s: cellData.style,
                            t: cellData.type
                        }, utils.isDefined(cellData.value) ? this._getXMLTag("v", {}, cellData.value) : null))
                    }
                    xmlRows.push(this._getXMLTag("row", {
                        r: Number(rowIndex) + 1,
                        spans: rSpans,
                        outlineLevel: !Number(rowIndex) ? 0 : this._dataProvider.getGroupLevel(this._getDataProviderRowIndex(rowIndex)),
                        "x14ac:dyDescent": "0.25"
                    }, xmlCells.join("")));
                    this._cellsArray[rowIndex] = null;
                    if (counter++ > 10000) {
                        xmlResult.push(xmlRows.join(""));
                        xmlRows = [];
                        counter = 0
                    }
                }
                xmlResult.push(xmlRows.join(""));
                xmlRows = [];
                maxCellIndex = this._getCellIndex(this._maxIndex[0], this._maxIndex[1]);
                xmlResult.push("</sheetData>" + (this._options.autoFilterEnabled ? "<autoFilter ref=\"A1:" + maxCellIndex + "\" />" : "") + "<ignoredErrors><ignoredError sqref=\"A1:" + maxCellIndex + "\" numberStoredAsText=\"1\" /></ignoredErrors></worksheet>");
                this._zip.folder(XL_FOLDER_NAME).folder(WORKSHEETS_FOLDER).file(WORKSHEET_FILE_NAME, xmlResult.join(""));
                this._colsArray = [];
                this._cellsArray = [];
                xmlResult = []
            },
            _generateCommonXML: function() {
                var relsFileContent = XML_TAG + this._createXMLRelationships(this._createXMLRelationship(1, "officeDocument", "xl/" + WORKBOOK_FILE_NAME)),
                    xmlRelationships,
                    xlFolder = this._zip.folder(XL_FOLDER_NAME),
                    relsXML = XML_TAG;
                this._zip.folder("_" + RELATIONSHIP_PART_NAME).file("." + RELATIONSHIP_PART_NAME, relsFileContent);
                xmlRelationships = this._createXMLRelationship(1, "worksheet", "worksheets/" + WORKSHEET_FILE_NAME) + this._createXMLRelationship(2, "styles", STYLE_FILE_NAME) + this._createXMLRelationship(3, "sharedStrings", SHAREDSTRING_FILE_NAME);
                relsXML += this._createXMLRelationships(xmlRelationships);
                xlFolder.folder("_" + RELATIONSHIP_PART_NAME).file(WORKBOOK_FILE_NAME + ".rels", relsXML);
                xlFolder.file(WORKBOOK_FILE_NAME, this._getWorkbookContent());
                this._zip.file(CONTENTTYPES_FILE_NAME, this._getContentTypesContent())
            },
            _generateContent: function() {
                this._prepareStyleData();
                this._prepareCellData();
                this._generateWorkXML();
                this._generateCommonXML()
            },
            _generateWorkXML: function() {
                this._generateStylesXML();
                this._generateStringsXML();
                this._generateWorksheetXML()
            },
            ctor: function(dataProvider, options) {
                this._rtlEnabled = options && !!options.rtlEnabled;
                this._options = options;
                this._maxIndex = [1, 2];
                this._stringArray = [];
                this._styleArray = [];
                this._colsArray = [];
                this._cellsArray = [];
                this._styleFormat = [];
                this._needSheetPr = false;
                this._dataProvider = dataProvider;
                this._zip = new JSZip
            },
            ready: function() {
                return this._dataProvider.ready()
            },
            getData: function(isBlob) {
                this._generateContent();
                return this._zip.generate({
                        type: isBlob ? "blob" : "base64",
                        compression: "DEFLATE",
                        mimeType: exporter.MIME_TYPES["EXCEL"]
                    })
            }
        });
        exporter.__internals = {
            CONTENTTYPES_FILE_NAME: CONTENTTYPES_FILE_NAME,
            RELATIONSHIP_PART_NAME: RELATIONSHIP_PART_NAME,
            XL_FOLDER_NAME: XL_FOLDER_NAME,
            WORKBOOK_FILE_NAME: WORKBOOK_FILE_NAME,
            STYLE_FILE_NAME: STYLE_FILE_NAME,
            WORKSHEET_FILE_NAME: WORKSHEET_FILE_NAME,
            WORKSHEETS_FOLDER: WORKSHEETS_FOLDER,
            SHAREDSTRING_FILE_NAME: SHAREDSTRING_FILE_NAME,
            GROUP_SHEET_PR_XML: GROUP_SHEET_PR_XML,
            SINGLE_SHEET_PR_XML: SINGLE_SHEET_PR_XML
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file fileSaver.js */
    (function(DX, $) {
        var exporter = DX.dxClientExporter,
            utils = DX.utils,
            FILE_EXTESIONS = {
                EXCEL: "xlsx",
                CSS: "css"
            };
        exporter.MIME_TYPES = {
            CSS: "text/css",
            EXCEL: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        };
        exporter.fileSaver = {
            _getDataUri: function(format, data) {
                return "data:" + exporter.MIME_TYPES[format] + ";base64," + data
            },
            _cordovaDownloader: function(fileName, href, callback) {
                var transfer = new FileTransfer,
                    fileAlert = function(res) {
                        navigator.notification.alert(res.nativeURL, null, Globalize.localize("dxFileSaver-fileExported"))
                    };
                transfer.download(href, window.cordova.file.externalRootDirectory + fileName, fileAlert, fileAlert)
            },
            _linkDownloader: function(fileName, href, callback) {
                var exportLinkElement = document.createElement('a'),
                    attributes = {
                        download: fileName,
                        href: href
                    };
                if (utils.isDefined(callback))
                    attributes["onclick"] = callback;
                document.body.appendChild(exportLinkElement);
                $(exportLinkElement).css({display: "none"}).text("load").attr(attributes)[0].click();
                return exportLinkElement
            },
            _formDownloader: function(proxyUrl, fileName, contentType, data, callback) {
                var formAttributes = {
                        method: "post",
                        action: proxyUrl,
                        enctype: "multipart/form-data"
                    },
                    exportForm = $("<form>").css({display: "none"}).attr(formAttributes);
                if (utils.isDefined(callback))
                    exportForm.submit(callback);
                exportForm.append("<input type=\"hidden\" name=\"fileName\" value=\"" + fileName + "\" />");
                exportForm.append("<input type=\"hidden\" name=\"contentType\" value=\"" + contentType + "\" />");
                exportForm.append("<input type=\"hidden\" name=\"data\" value=\"" + data + "\" />");
                exportForm.appendTo("body");
                exportForm.submit();
                if (exportForm.submit())
                    exportForm.remove();
                return exportForm
            },
            _saveByProxy: function(proxyUrl, fileName, format, data, callback) {
                return this._formDownloader(proxyUrl, fileName, exporter.MIME_TYPES[format], data, callback)
            },
            _winJSBlobSave: function(blob, fileName, format) {
                var storage = window.Windows.Storage,
                    savePicker = new storage.Pickers.FileSavePicker;
                savePicker.suggestedStartLocation = storage.Pickers.PickerLocationId.documentsLibrary;
                savePicker.fileTypeChoices.insert(exporter.MIME_TYPES[format], ["." + FILE_EXTESIONS[format]]);
                savePicker.suggestedFileName = fileName;
                savePicker.pickSaveFileAsync().then(function(file) {
                    if (file)
                        file.openAsync(storage.FileAccessMode.readWrite).then(function(outputStream) {
                            var inputStream = blob.msDetachStream();
                            storage.Streams.RandomAccessStream.copyAsync(inputStream, outputStream).then(function() {
                                outputStream.flushAsync().done(function() {
                                    inputStream.close();
                                    outputStream.close()
                                })
                            })
                        })
                })
            },
            _saveBlobAs: function(fileName, format, data, linkClick) {
                this._blobSaved = false;
                if (utils.isDefined(navigator.msSaveOrOpenBlob)) {
                    navigator.msSaveOrOpenBlob(data, fileName);
                    this._blobSaved = true
                }
                else if (utils.isDefined(window.WinJS)) {
                    this._winJSBlobSave(data, fileName, format);
                    this._blobSaved = true
                }
                else {
                    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL;
                    linkClick = utils.isDefined(linkClick) ? linkClick : function() {
                        var link = $('#dxExportLink');
                        URL.revokeObjectURL(link.attr('href'));
                        link.remove();
                        exporter.blobSaved = true
                    };
                    if (utils.isDefined(URL))
                        return this._linkDownloader(fileName, URL.createObjectURL(data), linkClick)
                }
            },
            saveAs: function(fileName, format, data, proxyURL, linkClick) {
                fileName += "." + FILE_EXTESIONS[format];
                if (utils.isDefined(window.cordova))
                    return this._cordovaDownloader(fileName, this._getDataUri(format, data), linkClick);
                if (utils.isFunction(window.Blob))
                    this._saveBlobAs(fileName, format, data);
                else if (utils.isDefined(proxyURL) && !utils.isDefined(navigator.userAgent.match(/iPad/i)))
                    this._saveByProxy(proxyURL, fileName, format, data);
                else {
                    if (!utils.isDefined(navigator.userAgent.match(/iPad/i)))
                        DX.log("E1034");
                    if (DX.browser.msie && parseInt(DX.browser.version) < 10)
                        return;
                    this._linkDownloader(fileName, this._getDataUri(format, data), linkClick)
                }
            }
        }
    })(DevExpress, jQuery);
    DevExpress.MOD_WIDGETS_WEB = true
}