/*! 
* DevExtreme (Web Widgets)
* Version: 15.2.10
* Build date: May 27, 2016
*
* Copyright (c) 2012 - 2016 Developer Express Inc. ALL RIGHTS RESERVED
* EULA: https://www.devexpress.com/Support/EULAs/DevExtreme.xml
*/

"use strict";
if (!window.DevExpress || !DevExpress.MOD_WIDGETS_WEB) {
    if (!window.DevExpress || !DevExpress.MOD_WIDGETS_BASE)
        throw Error('Required module is not referenced: widgets-base');
    /*! Module widgets-web, file ui.accordion.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx,
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var ACCORDION_CLASS = "dx-accordion",
            ACCORDION_WRAPPER_CLASS = "dx-accordion-wrapper",
            ACCORDION_ITEM_CLASS = "dx-accordion-item",
            ACCORDION_ITEM_OPENED_CLASS = "dx-accordion-item-opened",
            ACCORDION_ITEM_CLOSED_CLASS = "dx-accordion-item-closed",
            ACCORDION_ITEM_TITLE_CLASS = "dx-accordion-item-title",
            ACCORDION_ITEM_BODY_CLASS = "dx-accordion-item-body",
            ACCORDION_ITEM_DATA_KEY = "dxAccordionItemData";
        registerComponent("dxAccordion", ui, ui.CollectionWidget.inherit({
            _activeStateUnit: "." + ACCORDION_ITEM_CLASS,
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        hoverStateEnabled: true,
                        height: undefined,
                        itemTitleTemplate: "title",
                        onItemTitleClick: null,
                        onItemTitleHold: null,
                        selectedIndex: 0,
                        collapsible: false,
                        multiple: false,
                        animationDuration: 300,
                        deferRendering: true,
                        selectionByClick: true,
                        activeStateEnabled: true,
                        _itemAttributes: {role: "tab"}
                    })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: function(device) {
                                return devices.real().generic && !devices.isSimulator()
                            },
                            options: {focusStateEnabled: true}
                        }])
            },
            _itemElements: function() {
                return this._itemContainer().children(this._itemSelector())
            },
            _init: function() {
                this.callBase();
                this.option("selectionRequired", !this.option("collapsible"));
                this.option("selectionMode", this.option("multiple") ? "multiple" : "single");
                var $element = this.element();
                $element.addClass(ACCORDION_CLASS);
                this._$container = $("<div>").addClass(ACCORDION_WRAPPER_CLASS);
                $element.append(this._$container)
            },
            _render: function() {
                this._deferredItems = [];
                this.callBase();
                this._fireContentReadyAction();
                this.setAria({
                    role: "tablist",
                    multiselectable: this.option("multiple")
                });
                this._attachItemTitleClickAction()
            },
            _renderContent: function() {
                this._renderContentImpl()
            },
            _itemDataKey: function() {
                return ACCORDION_ITEM_DATA_KEY
            },
            _itemClass: function() {
                return ACCORDION_ITEM_CLASS
            },
            _itemContainer: function() {
                return this._$container
            },
            _itemTitles: function() {
                return this._itemElements().find("." + ACCORDION_ITEM_TITLE_CLASS)
            },
            _itemContents: function() {
                return this._itemElements().find("." + ACCORDION_ITEM_BODY_CLASS)
            },
            _getItemData: function(target) {
                return $(target).parent().data(this._itemDataKey()) || this.callBase.apply(this, arguments)
            },
            _executeItemRenderAction: function(itemData, itemElement) {
                if (itemData.type)
                    return;
                this.callBase.apply(this, arguments)
            },
            _itemSelectHandler: function(e) {
                if ($(e.target).closest(this._itemContents()).length)
                    return;
                this.callBase.apply(this, arguments)
            },
            _renderItemContent: function(args) {
                var $itemTitle = this.callBase($.extend({}, args, {
                        contentClass: ACCORDION_ITEM_TITLE_CLASS,
                        templateProperty: "titleTemplate",
                        defaultTemplateName: this.option("itemTitleTemplate")
                    }));
                var deferred = $.Deferred();
                this._deferredItems.push(deferred);
                if (!this.option("deferRendering"))
                    deferred.resolve();
                deferred.done($.proxy(this.callBase, this, $.extend({}, args, {
                    contentClass: ACCORDION_ITEM_BODY_CLASS,
                    container: $("<div>").appendTo($itemTitle.parent())
                })))
            },
            _attachItemTitleClickAction: function() {
                var itemSelector = "." + ACCORDION_ITEM_TITLE_CLASS,
                    eventName = eventUtils.addNamespace("dxclick", this.NAME);
                this._itemContainer().off(eventName, itemSelector).on(eventName, itemSelector, $.proxy(this._itemTitleClickHandler, this))
            },
            _itemTitleClickHandler: function(e) {
                this._itemJQueryEventHandler(e, "onItemTitleClick")
            },
            _renderSelection: function(addedSelection, removedSelection) {
                this._itemElements().addClass(ACCORDION_ITEM_CLOSED_CLASS);
                this.setAria("hidden", true, this._itemContents());
                this._updateItems(addedSelection, removedSelection, true)
            },
            _updateSelection: function(addedSelection, removedSelection) {
                this._updateItems(addedSelection, removedSelection, false)
            },
            _updateItems: function(addedSelection, removedSelection, skipAnimation) {
                var $items = this._itemElements(),
                    that = this;
                $.each(addedSelection, function(_, index) {
                    that._deferredItems[index].resolve();
                    var $item = $items.eq(index).addClass(ACCORDION_ITEM_OPENED_CLASS).removeClass(ACCORDION_ITEM_CLOSED_CLASS);
                    that.setAria("hidden", false, $item.find("." + ACCORDION_ITEM_BODY_CLASS))
                });
                $.each(removedSelection, function(_, index) {
                    var $item = $items.eq(index).removeClass(ACCORDION_ITEM_OPENED_CLASS);
                    that.setAria("hidden", true, $item.find("." + ACCORDION_ITEM_BODY_CLASS))
                });
                this._updateItemHeights(skipAnimation)
            },
            _updateItemHeights: function(skipAnimation) {
                var that = this,
                    deferredAnimate = that._deferredAnimate,
                    itemHeight = this._splitFreeSpace(this._calculateFreeSpace());
                return $.when.apply($, $.map(this._itemElements(), function(item) {
                        return that._updateItemHeight($(item), itemHeight, skipAnimation)
                    })).done(function() {
                        if (deferredAnimate)
                            deferredAnimate.resolveWith(that)
                    })
            },
            _updateItemHeight: function($item, itemHeight, skipAnimation) {
                var $title = $item.children("." + ACCORDION_ITEM_TITLE_CLASS);
                if (fx.isAnimating($item))
                    fx.stop($item);
                var startItemHeight = $item.outerHeight(),
                    finalItemHeight = $item.hasClass(ACCORDION_ITEM_OPENED_CLASS) ? itemHeight + $title.outerHeight() || $item.height("auto").outerHeight() : $title.outerHeight();
                return this._animateItem($item, startItemHeight, finalItemHeight, skipAnimation, !!itemHeight)
            },
            _animateItem: function($element, startHeight, endHeight, skipAnimation, fixedHeight) {
                var d;
                if (skipAnimation || startHeight === endHeight) {
                    $element.css("height", endHeight);
                    d = $.Deferred().resolve()
                }
                else
                    d = fx.animate($element, {
                        type: "custom",
                        from: {height: startHeight},
                        to: {height: endHeight},
                        duration: this.option("animationDuration")
                    });
                return d.done(function() {
                        if ($element.hasClass(ACCORDION_ITEM_OPENED_CLASS) && !fixedHeight)
                            $element.css("height", "");
                        $element.not("." + ACCORDION_ITEM_OPENED_CLASS).addClass(ACCORDION_ITEM_CLOSED_CLASS)
                    })
            },
            _splitFreeSpace: function(freeSpace) {
                if (!freeSpace)
                    return freeSpace;
                return freeSpace / this.option("selectedItems").length
            },
            _calculateFreeSpace: function() {
                var height = this.option("height");
                if (height === undefined || height === "auto")
                    return;
                var $titles = this._itemTitles(),
                    itemsHeight = 0;
                $.each($titles, function(_, title) {
                    itemsHeight += $(title).outerHeight()
                });
                return this.element().height() - itemsHeight
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this._dimensionChanged()
            },
            _dimensionChanged: function() {
                this._updateItemHeights(true)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"animationDuration":
                    case"onItemTitleClick":
                        break;
                    case"collapsible":
                        this.option("selectionRequired", !this.option("collapsible"));
                        break;
                    case"itemTitleTemplate":
                    case"onItemTitleHold":
                    case"height":
                    case"deferRendering":
                        this._invalidate();
                        break;
                    case"multiple":
                        this.option("selectionMode", args.value ? "multiple" : "single");
                        break;
                    default:
                        this.callBase(args)
                }
            },
            expandItem: function(index) {
                this._deferredAnimate = $.Deferred();
                this.selectItem(index);
                return this._deferredAnimate.promise()
            },
            collapseItem: function(index) {
                this._deferredAnimate = $.Deferred();
                this.unselectItem(index);
                return this._deferredAnimate.promise()
            },
            updateDimensions: function() {
                return this._updateItemHeights(false)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pager.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            stringUtils = DX.require("/utils/utils.string"),
            Class = DevExpress.require("/class"),
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var PAGES_LIMITER = 4,
            PAGER_CLASS = 'dx-pager',
            PAGER_PAGE_CLASS = 'dx-page',
            PAGER_PAGES_CLASS = 'dx-pages',
            PAGER_SELECTION_CLASS = 'dx-selection',
            PAGER_PAGE_SEPARATOR_CLASS = 'dx-separator',
            PAGER_PAGE_SIZES_CLASS = 'dx-page-sizes',
            PAGER_PAGE_SIZE_CLASS = 'dx-page-size',
            PAGER_NAVIGATE_BUTTON = 'dx-navigate-button',
            PAGER_PREV_BUTTON_CLASS = "dx-prev-button",
            PAGER_NEXT_BUTTON_CLASS = "dx-next-button",
            PAGER_INFO_CLASS = "dx-info",
            PAGER_BUTTON_DISABLE_CLASS = "dx-button-disable";
        var Page = Class.inherit({
                ctor: function(value, index) {
                    var that = this;
                    that.index = index;
                    that._$page = $('<div />').text(value).addClass(PAGER_PAGE_CLASS)
                },
                value: function(value) {
                    var that = this;
                    if (commonUtils.isDefined(value))
                        that._$page.text(value);
                    else {
                        var text = that._$page.text();
                        if (commonUtils.isNumber(text))
                            return parseInt(text);
                        else
                            return text
                    }
                },
                element: function() {
                    return this._$page
                },
                select: function(value) {
                    this._$page.toggleClass(PAGER_SELECTION_CLASS, value)
                },
                render: function(rootElement, rtlEnabled) {
                    rtlEnabled ? this._$page.prependTo(rootElement) : this._$page.appendTo(rootElement)
                }
            });
        registerComponent("dxPager", ui, Widget.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        visible: true,
                        pagesNavigatorVisible: "auto",
                        pageIndex: 1,
                        maxPagesCount: 10,
                        pageCount: 10,
                        totalCount: 0,
                        pageSize: 5,
                        showPageSizes: true,
                        pageSizes: [5, 10],
                        hasKnownLastPage: true,
                        showNavigationButtons: false,
                        showInfo: false,
                        infoText: Globalize.localize("dxPager-infoText"),
                        rtlEnabled: false,
                        pageIndexChanged: $.noop,
                        pageSizeChanged: $.noop
                    })
            },
            _toggleVisibility: function(value) {
                var $element = this.element();
                if ($element)
                    $element.css("display", value ? "" : "none")
            },
            _getPages: function(currentPage, count) {
                var pages = [],
                    showMoreButton = !this.option("hasKnownLastPage"),
                    firstValue,
                    i;
                this._testPagesCount = count;
                this._testShowMoreButton = showMoreButton;
                if (count > 0 || showMoreButton)
                    if (count <= this.option("maxPagesCount")) {
                        for (i = 1; i <= count; i++)
                            pages.push(new Page(i, i - 1));
                        if (showMoreButton)
                            pages.push(new Page('>', i - 1))
                    }
                    else {
                        pages.push(new Page(1, 0));
                        firstValue = currentPage ? currentPage.value() - currentPage.index : 1;
                        for (i = 1; i <= PAGES_LIMITER; i++)
                            pages.push(new Page(firstValue + i, i));
                        pages.push(new Page(count, PAGES_LIMITER + 1));
                        if (showMoreButton)
                            pages.push(new Page('>', PAGES_LIMITER + 1))
                    }
                return pages
            },
            _getPageByValue: function(value) {
                var that = this,
                    page,
                    i;
                for (i = 0; i < that._pages.length; i++) {
                    page = that._pages[i];
                    if (page.value() === value)
                        return page
                }
            },
            _processSelectedPage: function(maxPagesCount, pageIndex, pageCount) {
                var that = this,
                    isPageIndexValid = false,
                    selectedPageIndex;
                if (that._pages) {
                    $.each(that._pages, function(key, page) {
                        if (pageIndex === page.value())
                            isPageIndexValid = true
                    });
                    if (!isPageIndexValid)
                        that.selectedPage = null
                }
                if (commonUtils.isDefined(that.selectedPage)) {
                    if (pageIndex === pageCount && pageCount > maxPagesCount && that.selectedPage.index !== PAGES_LIMITER + 1)
                        that.selectedPage.index = PAGES_LIMITER + 1
                }
                else if (pageIndex > PAGES_LIMITER && pageIndex < pageCount) {
                    selectedPageIndex = pageCount - PAGES_LIMITER < pageIndex ? PAGES_LIMITER - (pageCount - pageIndex) + 1 : 2;
                    that.selectedPage = new Page(pageIndex, selectedPageIndex)
                }
            },
            _selectPageByValue: function(value) {
                var that = this,
                    i,
                    page = that._getPageByValue(value),
                    pages = that._pages,
                    pagesLength = pages.length,
                    prevPage,
                    nextPage,
                    morePage;
                if (!commonUtils.isDefined(page))
                    return;
                prevPage = that._pages[page.index - 1];
                nextPage = that._pages[page.index + 1];
                if (nextPage && nextPage.value() === '>') {
                    morePage = nextPage;
                    nextPage = undefined;
                    pagesLength--;
                    pages.pop()
                }
                if (that.selectedPage)
                    that.selectedPage.select(false);
                page.select(true);
                that.selectedPage = page;
                if (nextPage && nextPage.value() - value > 1)
                    if (page.index !== 0) {
                        prevPage.value(value + 1);
                        that._pages.splice(page.index, 1);
                        that._pages.splice(page.index - 1, 0, page);
                        that._pages[page.index].index = page.index;
                        page.index = page.index - 1;
                        for (i = page.index - 1; i > 0; i--)
                            that._pages[i].value(that._pages[i + 1].value() - 1)
                    }
                    else
                        for (i = 0; i < pagesLength - 1; i++)
                            that._pages[i].value(i + 1);
                if (prevPage && value - prevPage.value() > 1)
                    if (page.index !== pagesLength - 1) {
                        nextPage.value(value - 1);
                        that._pages.splice(page.index, 1);
                        that._pages.splice(page.index + 1, 0, page);
                        that._pages[page.index].index = page.index;
                        page.index = page.index + 1;
                        for (i = page.index + 1; i < pagesLength - 1; i++)
                            that._pages[i].value(that._pages[i - 1].value() + 1)
                    }
                    else
                        for (i = 1; i <= pagesLength - 2; i++)
                            that._pages[pagesLength - 1 - i].value(that._pages[pagesLength - 1].value() - i);
                if (morePage)
                    pages.push(morePage)
            },
            _nextPage: function(direction) {
                var pageIndex = this.selectedPage && this.selectedPage.value(),
                    pageCount = this.option("pageCount");
                if (commonUtils.isDefined(pageIndex)) {
                    pageIndex = direction === "next" ? ++pageIndex : --pageIndex;
                    if (pageIndex > 0 && pageIndex <= pageCount)
                        this.option("pageIndex", pageIndex)
                }
            },
            _renderPages: function(pages) {
                var that = this,
                    $separator,
                    pageslength = pages.length,
                    clickPagesIndexAction = that._createAction(function(args) {
                        var e = args.jQueryEvent,
                            pageNumber = $(e.target).text(),
                            pageIndex = pageNumber === '>' ? that.option("pageCount") + 1 : Number(pageNumber);
                        that._testPageIndex = pageIndex;
                        that.option("pageIndex", pageIndex)
                    }),
                    page;
                if (pageslength > 1) {
                    that._pageClickHandler = function(e) {
                        clickPagesIndexAction({jQueryEvent: e})
                    };
                    that.$pagesChooser.on(eventUtils.addNamespace("dxclick", that.Name + "Pages"), '.' + PAGER_PAGE_CLASS, that._pageClickHandler)
                }
                for (var i = 0; i < pageslength; i++) {
                    page = pages[i];
                    page.render(that.$pagesChooser, that.option('rtlEnabled'));
                    that.setAria({
                        role: "button",
                        label: "Page " + page.value()
                    }, page.element());
                    if (pages[i + 1] && pages[i + 1].value() - page.value() > 1) {
                        $separator = $("<div>. . .</div>").addClass(PAGER_PAGE_SEPARATOR_CLASS);
                        that.option('rtlEnabled') ? $separator.prependTo(that.$pagesChooser) : $separator.appendTo(that.$pagesChooser)
                    }
                }
            },
            _renderPagesChooser: function() {
                var that = this,
                    pagesNavigatorVisible = that.option("pagesNavigatorVisible"),
                    $element = that.element();
                if (!$element)
                    return;
                if (!pagesNavigatorVisible) {
                    that.$pagesChooser && that.$pagesChooser.remove();
                    return
                }
                if (that._pages.length === 0) {
                    that.selectedPage = null;
                    return
                }
                if (commonUtils.isDefined(that.$pagesChooser))
                    that.$pagesChooser.empty();
                else
                    that.$pagesChooser = $('<div />').addClass(PAGER_PAGES_CLASS);
                if (pagesNavigatorVisible === "auto")
                    that.$pagesChooser.css("visibility", that._pages.length === 1 ? "hidden" : "");
                that._renderInfo();
                that._renderNavigateButton("prev");
                that._renderPages(that._pages);
                that._renderNavigateButton("next");
                if (!commonUtils.isDefined(that.$pagesChooser[0].parentElement))
                    that.$pagesChooser.appendTo($element)
            },
            _renderPagesSizeChooser: function() {
                var that = this,
                    i,
                    $pageSize,
                    currentPageSize = that.option("pageSize"),
                    pageSizes = that.option("pageSizes"),
                    showPageSizes = that.option("showPageSizes"),
                    pageSizeValue,
                    pagesSizesLength = pageSizes && pageSizes.length,
                    $element = that.element();
                if (!$element)
                    return;
                that._clickPagesSizeAction = that._createAction(function(args) {
                    var e = args.jQueryEvent;
                    pageSizeValue = parseInt($(e.target).text());
                    that._testPageSizeIndex = pageSizeValue;
                    that.option("pageSize", pageSizeValue)
                });
                if (commonUtils.isDefined(that.pagesSizeChooserElement))
                    that.pagesSizeChooserElement.empty();
                else
                    that.pagesSizeChooserElement = $('<div />').addClass(PAGER_PAGE_SIZES_CLASS).on(eventUtils.addNamespace("dxclick", that.Name + "PageSize"), '.' + PAGER_PAGE_SIZE_CLASS, function(e) {
                        that._clickPagesSizeAction({jQueryEvent: e})
                    });
                if (!showPageSizes || !pagesSizesLength)
                    return;
                that._testCurrentPageSize = currentPageSize;
                for (i = 0; i < pagesSizesLength; i++) {
                    $pageSize = $('<div />').text(pageSizes[i]).addClass(PAGER_PAGE_SIZE_CLASS);
                    that.setAria({
                        role: "button",
                        label: "Display " + pageSizes[i] + " items on page"
                    }, $pageSize);
                    if (currentPageSize === pageSizes[i])
                        $pageSize.addClass(PAGER_SELECTION_CLASS);
                    that.pagesSizeChooserElement.append($pageSize)
                }
                if (!commonUtils.isDefined(that.pagesSizeChooserElement[0].parentElement))
                    that.pagesSizeChooserElement.appendTo($element)
            },
            _renderInfo: function() {
                var infoText = this.option("infoText");
                if (this.option("showInfo") && commonUtils.isDefined(infoText))
                    $("<div>").addClass(PAGER_INFO_CLASS).text(stringUtils.format(infoText, this.selectedPage && this.selectedPage.value(), this.option("pageCount"), this.option("totalCount"))).appendTo(this.$pagesChooser)
            },
            _renderNavigateButton: function(direction) {
                var that = this,
                    currentPageIndex,
                    clickAction = that._createAction(function(e) {
                        that._nextPage(direction)
                    }),
                    $button,
                    enabled;
                if (that.option("showNavigationButtons")) {
                    currentPageIndex = that.option("pageIndex");
                    enabled = currentPageIndex > 1 && direction === "prev" || currentPageIndex < that.option("pageCount") && direction === "next";
                    $button = $("<div>").addClass(PAGER_NAVIGATE_BUTTON).addClass(!enabled ? PAGER_BUTTON_DISABLE_CLASS : "").on(eventUtils.addNamespace("dxclick", that.Name + "Pages"), function(e) {
                        clickAction({jQueryEvent: e})
                    });
                    that.setAria({
                        role: "button",
                        label: direction === "prev" ? "Previous page" : " Next page"
                    }, $button);
                    if (that.option("rtlEnabled")) {
                        $button.addClass(direction === "prev" ? PAGER_NEXT_BUTTON_CLASS : PAGER_PREV_BUTTON_CLASS);
                        $button.prependTo(this.$pagesChooser)
                    }
                    else {
                        $button.addClass(direction === "prev" ? PAGER_PREV_BUTTON_CLASS : PAGER_NEXT_BUTTON_CLASS);
                        $button.appendTo(this.$pagesChooser)
                    }
                }
            },
            _render: function() {
                this.callBase();
                this._update();
                this.element().addClass(PAGER_CLASS);
                this._toggleVisibility(this.option("visible"));
                this._renderPagesSizeChooser();
                this._renderPagesChooser()
            },
            _update: function() {
                var pageCount = this.option("pageCount"),
                    pageIndex = this.option("pageIndex");
                this._processSelectedPage(this.option("maxPagesCount"), pageIndex, pageCount);
                this._pages = this._getPages(this.selectedPage, pageCount);
                this._selectPageByValue(pageIndex)
            },
            _optionChanged: function(args) {
                switch (args.name) {
                    case"visible":
                        this._toggleVisibility(args.value);
                        break;
                    case"pageIndex":
                        var pageIndexChanged = this.option("pageIndexChanged");
                        if (pageIndexChanged)
                            pageIndexChanged(args.value);
                        this._update();
                        this._renderPagesChooser();
                        break;
                    case"maxPagesCount":
                    case"pageCount":
                    case"totalCount":
                    case"hasKnownLastPage":
                    case"pagesNavigatorVisible":
                    case"showNavigationButtons":
                        this._update();
                        this._renderPagesChooser();
                        break;
                    case"pageSize":
                        var pageSizeChanged = this.option("pageSizeChanged");
                        if (pageSizeChanged)
                            pageSizeChanged(args.value);
                        this._renderPagesSizeChooser();
                        break;
                    case"pageSizes":
                        this._renderPagesSizeChooser();
                        break;
                    default:
                        this._invalidate()
                }
            },
            _clean: function() {
                this.$pagesChooser && this.$pagesChooser.off(eventUtils.addNamespace("dxclick", this.Name + "Pages"), '.' + PAGER_PAGE_CLASS, this._pageClickHandler)
            },
            getHeight: function() {
                return this.option("visible") ? this.element().outerHeight() : 0
            }
        }));
        ui.dxPager.__internals = {
            PAGER_CLASS: PAGER_CLASS,
            PAGER_PAGE_CLASS: PAGER_PAGE_CLASS,
            PAGER_PAGES_CLASS: PAGER_PAGES_CLASS,
            PAGER_SELECTION_CLASS: PAGER_SELECTION_CLASS,
            PAGER_PAGE_SEPARATOR_CLASS: PAGER_PAGE_SEPARATOR_CLASS,
            PAGER_PAGE_SIZES_CLASS: PAGER_PAGE_SIZES_CLASS,
            PAGER_PAGE_SIZE_CLASS: PAGER_PAGE_SIZE_CLASS,
            PAGER_NAVIGATE_BUTTON: PAGER_NAVIGATE_BUTTON,
            PAGER_PREV_BUTTON_CLASS: PAGER_PREV_BUTTON_CLASS,
            PAGER_NEXT_BUTTON_CLASS: PAGER_NEXT_BUTTON_CLASS,
            PAGER_INFO_CLASS: PAGER_INFO_CLASS,
            PAGER_BUTTON_DISABLE_CLASS: PAGER_BUTTON_DISABLE_CLASS
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.menuBase.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            commonUtils = DX.require("/utils/utils.common"),
            inkRipple = DX.require("/utils/utils.inkRipple"),
            HierarchicalCollectionWidget = DX.require("/ui/hierarchicalCollectionWidget/ui.hierarchicalCollectionWidget"),
            devices = DX.require("/devices"),
            themes = DX.require("/ui/ui.themes");
        var DX_MENU_CLASS = "dx-menu",
            DX_MENU_NO_ICONS_CLASS = DX_MENU_CLASS + "-no-icons",
            DX_MENU_BASE_CLASS = "dx-menu-base",
            ITEM_CLASS = DX_MENU_CLASS + "-item",
            DX_MENU_SELECTED_ITEM_CLASS = ITEM_CLASS + "-selected",
            DX_MENU_ITEM_WRAPPER_CLASS = ITEM_CLASS + "-wrapper",
            DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
            DX_MENU_ITEM_EXPANDED_CLASS = ITEM_CLASS + "-expanded",
            DX_MENU_SEPARATOR_CLASS = DX_MENU_CLASS + "-separator",
            DX_MENU_ITEM_LAST_GROUP_ITEM = DX_MENU_CLASS + "-last-group-item",
            DX_ITEM_HAS_TEXT = ITEM_CLASS + "-has-text",
            DX_ITEM_HAS_ICON = ITEM_CLASS + "-has-icon",
            DX_ITEM_HAS_SUBMENU = ITEM_CLASS + "-has-submenu",
            DX_MENU_ITEM_POPOUT_CLASS = ITEM_CLASS + "-popout",
            DX_MENU_ITEM_POPOUT_CONTAINER_CLASS = DX_MENU_ITEM_POPOUT_CLASS + "-container",
            DX_MENU_ITEM_CAPTION_CLASS = ITEM_CLASS + "-text",
            SINGLE_SELECTION_MODE = "single",
            DEFAULT_DELAY = {
                show: 50,
                hide: 300
            };
        var dxMenuBase = HierarchicalCollectionWidget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            items: [],
                            cssClass: "",
                            activeStateEnabled: true,
                            showSubmenuMode: {
                                name: "onHover",
                                delay: {
                                    show: 50,
                                    hide: 300
                                }
                            },
                            animation: {
                                show: {
                                    type: "fade",
                                    from: 0,
                                    to: 1,
                                    duration: 100
                                },
                                hide: {
                                    type: "fade",
                                    from: 1,
                                    to: 0,
                                    duration: 100
                                }
                            },
                            selectionByClick: false,
                            focusOnSelectedItem: false,
                            _remoteSelectionSync: false,
                            _itemAttributes: {role: "menuitem"},
                            useInkRipple: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function() {
                                    return /android5/.test(themes.current())
                                },
                                options: {useInkRipple: true}
                            }])
                },
                _activeStateUnit: "." + ITEM_CLASS,
                _itemDataKey: function() {
                    return "dxMenuItemDataKey"
                },
                _itemClass: function() {
                    return ITEM_CLASS
                },
                _setAriaSelected: $.noop,
                _selectedItemClass: function() {
                    return DX_MENU_SELECTED_ITEM_CLASS
                },
                _widgetClass: function() {
                    return DX_MENU_BASE_CLASS
                },
                _focusTarget: function() {
                    return this._itemContainer()
                },
                _supportedKeys: function() {
                    var selectItem = function(e) {
                            var $item = this.option("focusedElement");
                            if (!$item || !this._isSelectionEnabled())
                                return;
                            this.selectItem($item[0])
                        };
                    return $.extend(this.callBase(), {
                            space: selectItem,
                            pageUp: $.noop,
                            pageDown: $.noop
                        })
                },
                _isSelectionEnabled: function() {
                    return this.option("selectionMode") === SINGLE_SELECTION_MODE
                },
                _init: function() {
                    this.callBase();
                    this._renderSelectedItem();
                    this._initActions()
                },
                _useCustomExpressions: function() {
                    return this.callBase() || this.option("itemsExpr") !== "items"
                },
                _getTextContainer: function(itemData) {
                    var itemText = this._displayGetter(itemData),
                        $itemContainer = $('<span>').addClass(DX_MENU_ITEM_CAPTION_CLASS),
                        itemContent = $.isPlainObject(itemData) ? itemText : String(itemData);
                    return itemText && $itemContainer.html(itemContent)
                },
                _getPopoutContainer: function(itemData) {
                    var items = this._itemsGetter(itemData),
                        $popOutContainer;
                    if (items && items.length) {
                        var $popOutImage = $('<div>').addClass(DX_MENU_ITEM_POPOUT_CLASS);
                        $popOutContainer = $('<span>').addClass(DX_MENU_ITEM_POPOUT_CONTAINER_CLASS).append($popOutImage)
                    }
                    return $popOutContainer
                },
                _getDataAdapterOptions: function() {
                    return {
                            rootValue: 0,
                            multipleSelection: false,
                            recursiveSelection: false,
                            recursiveExpansion: false,
                            searchValue: ""
                        }
                },
                _selectByItem: function(selectedItem) {
                    if (!selectedItem)
                        return;
                    var nodeToSelect = this._dataAdapter.getNodeByItem(selectedItem);
                    this._dataAdapter.toggleSelection(nodeToSelect.internalFields.key, true)
                },
                _renderSelectedItem: function() {
                    var selectedKeys = this._dataAdapter.getSelectedNodesKeys(),
                        selectedKey = selectedKeys.length && selectedKeys[0],
                        selectedItem = this.option("selectedItem");
                    if (!selectedKey) {
                        this._selectByItem(selectedItem);
                        return
                    }
                    var node = this._dataAdapter.getNodeByKey(selectedKey);
                    if (node.selectable === false)
                        return;
                    if (!selectedItem) {
                        this.option("selectedItem", node.internalFields.item);
                        return
                    }
                    if (selectedItem !== node.internalFields.item) {
                        this._dataAdapter.toggleSelection(selectedKey, false);
                        this._selectByItem(selectedItem)
                    }
                },
                _initActions: $.noop,
                _render: function() {
                    this.callBase();
                    this._addCustomCssClass(this.element());
                    this.option("useInkRipple") && this._renderInkRipple()
                },
                _renderInkRipple: function() {
                    this._inkRipple = inkRipple.render()
                },
                _toggleActiveState: function($element, value, e) {
                    this.callBase.apply(this, arguments);
                    if (!this._inkRipple)
                        return;
                    var config = {
                            element: $element,
                            jQueryEvent: e
                        };
                    if (value)
                        this._inkRipple.showWave(config);
                    else
                        this._inkRipple.hideWave(config)
                },
                _getShowSubmenuMode: function() {
                    var defaultValue = "onClick",
                        optionValue = this.option("showSubmenuMode");
                    optionValue = commonUtils.isObject(optionValue) ? optionValue.name : optionValue;
                    return this._isDesktopDevice() ? optionValue : defaultValue
                },
                _initSelectedItems: $.noop,
                _isDesktopDevice: function() {
                    return devices.real().deviceType === "desktop"
                },
                _initEditStrategy: function() {
                    var strategy = ui.CollectionWidget.MenuBaseEditStrategy;
                    this._editStrategy = new strategy(this)
                },
                _addCustomCssClass: function($element) {
                    $element.addClass(this.option("cssClass"))
                },
                _itemWrapperSelector: function() {
                    return "." + DX_MENU_ITEM_WRAPPER_CLASS
                },
                _hoverStartHandler: function(e) {
                    var that = this,
                        $itemElement = that._getItemElementByEventArgs(e);
                    if (!$itemElement || that._isItemDisabled($itemElement))
                        return;
                    e.stopPropagation();
                    that.option("focusedElement", $itemElement);
                    if (that._getShowSubmenuMode() === "onHover")
                        this._showSubmenusTimeout = setTimeout($.proxy(that._showSubmenu, that, $itemElement), that._getSubmenuDelay("show"))
                },
                _isItemDisabled: function($item) {
                    return this._disabledGetter($item.data(this._itemDataKey()))
                },
                _showSubmenu: function($itemElement) {
                    clearTimeout(this._showSubmenusTimeout);
                    if (this._hasFocusClass($itemElement))
                        this._addExpandedClass($itemElement)
                },
                _addExpandedClass: function($itemElement) {
                    $itemElement.addClass(DX_MENU_ITEM_EXPANDED_CLASS)
                },
                _getSubmenuDelay: function(action) {
                    var delay = this.option("showSubmenuMode").delay;
                    if (!commonUtils.isDefined(delay))
                        return DEFAULT_DELAY[action];
                    return commonUtils.isObject(delay) ? delay[action] : delay
                },
                _getItemElementByEventArgs: function(eventArgs) {
                    var $target = $(eventArgs.target);
                    if ($target.hasClass(this._itemClass()) || $target.get(0) === eventArgs.currentTarget)
                        return $target;
                    while (!$target.hasClass(this._itemClass())) {
                        $target = $target.parent();
                        if ($target.hasClass("dx-submenu"))
                            return null
                    }
                    return $target
                },
                _hoverEndHandler: $.noop,
                _hasSubmenu: function(node) {
                    return node.internalFields.childrenKeys.length
                },
                _renderContentImpl: function() {
                    this._renderItems(this._dataAdapter.getRootNodes())
                },
                _renderItems: function(nodes, submenuContainer) {
                    var that = this,
                        $nodeContainer;
                    if (nodes.length) {
                        this.hasIcons = false;
                        $nodeContainer = this._renderContainer(this.element(), submenuContainer);
                        $.each(nodes, function(index, node) {
                            that._renderItem(index, node, $nodeContainer)
                        });
                        if (!this.hasIcons)
                            $nodeContainer.addClass(DX_MENU_NO_ICONS_CLASS)
                    }
                },
                _renderContainer: function($wrapper) {
                    return $("<ul>").appendTo($wrapper).addClass(DX_MENU_ITEMS_CONTAINER_CLASS)
                },
                _createDOMElement: function($nodeContainer) {
                    var $node = $("<li>").appendTo($nodeContainer).addClass(DX_MENU_ITEM_WRAPPER_CLASS);
                    return $node
                },
                _renderItem: function(index, node, $nodeContainer) {
                    var items = this.option("items"),
                        $itemFrame;
                    this._renderSeparator(node, index, $nodeContainer);
                    if (node.internalFields.item.visible === false)
                        return;
                    var $node = this._createDOMElement($nodeContainer);
                    if (items[index + 1] && items[index + 1].beginGroup)
                        $node.addClass(DX_MENU_ITEM_LAST_GROUP_ITEM);
                    $itemFrame = this.callBase(index, node.internalFields.item, $node);
                    if (node.internalFields.item === this.option("selectedItem"))
                        $itemFrame.addClass(DX_MENU_SELECTED_ITEM_CLASS);
                    this._addContentClasses(node, $itemFrame);
                    if (this._hasSubmenu(node))
                        this.setAria("haspopup", "true", $itemFrame)
                },
                _addContentClasses: function(node, $itemFrame) {
                    if (this._displayGetter(node))
                        $itemFrame.addClass(DX_ITEM_HAS_TEXT);
                    if (node.icon || node.iconSrc) {
                        $itemFrame.addClass(DX_ITEM_HAS_ICON);
                        this.hasIcons = true
                    }
                    if (this._hasSubmenu(node))
                        $itemFrame.addClass(DX_ITEM_HAS_SUBMENU)
                },
                _postprocessRenderItem: function(args) {
                    var $itemElement = $(args.itemElement),
                        selectedIndex = this._dataAdapter.getSelectedNodesKeys(),
                        node;
                    if (!selectedIndex.length || !this._selectedGetter(args.itemData) || !this._isItemSelectable(args.itemData)) {
                        this._setAriaSelected($itemElement, "false");
                        return
                    }
                    node = this._dataAdapter.getNodeByItem(args.itemData);
                    if (node.internalFields.key === selectedIndex[0]) {
                        $itemElement.addClass(this._selectedItemClass());
                        this._setAriaSelected($itemElement, "true")
                    }
                    else
                        this._setAriaSelected($itemElement, "false")
                },
                _isItemSelectable: function(item) {
                    return item.selectable !== false
                },
                _renderSeparator: function(node, index, $itemsContainer) {
                    if (node.beginGroup && index > 0)
                        this._needSeparate = true;
                    if (node.visible !== false && this._needSeparate) {
                        $("<li>").appendTo($itemsContainer).addClass(DX_MENU_SEPARATOR_CLASS);
                        this._needSeparate = false
                    }
                },
                _itemClickHandler: function(e) {
                    var itemClickActionHandler = this._createAction($.proxy(this._updateSubmenuVisibilityOnClick, this));
                    this._itemJQueryEventHandler(e, "onItemClick", {}, {afterExecute: $.proxy(itemClickActionHandler, this)})
                },
                _updateSubmenuVisibilityOnClick: function(actionArgs) {
                    this._updateSelectedItemOnClick(actionArgs);
                    if (this._getShowSubmenuMode() === "onClick")
                        this._addExpandedClass(actionArgs.args[0].itemElement)
                },
                _updateSelectedItemOnClick: function(actionArgs) {
                    var args = actionArgs.args ? actionArgs.args[0] : actionArgs,
                        selectedItemKey;
                    if (!this._isItemSelectionAllowed(args.itemData))
                        return;
                    selectedItemKey = this._dataAdapter.getSelectedNodesKeys();
                    var selectedNode = selectedItemKey.length && this._dataAdapter.getNodeByKey(selectedItemKey[0]);
                    if (selectedNode)
                        this._toggleItemSelection(selectedNode, false);
                    if (!selectedNode || selectedNode.internalFields.item !== args.itemData)
                        this.selectItem(args.itemData);
                    else {
                        this._fireSelectionChangeEvent(null, this.option("selectedItem"));
                        this._setOptionSilent("selectedItem", null)
                    }
                },
                _isItemSelectionAllowed: function(item) {
                    var isSelectionByClickEnabled = this._isSelectionEnabled() && this.option("selectionByClick");
                    return !this._isContainerEmpty() && isSelectionByClickEnabled && this._isItemSelectable(item) && !this._itemsGetter(item)
                },
                _isContainerEmpty: function() {
                    return this._itemContainer().is(':empty')
                },
                _syncSelectionOptions: $.noop,
                _optionChanged: function(args) {
                    if (this._cancelOptionChange)
                        return;
                    switch (args.name) {
                        case"showSubmenuMode":
                            break;
                        case"selectedItem":
                            var itemData = args.value,
                                node = this._dataAdapter.getNodeByItem(itemData),
                                selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
                            if (node && node.internalFields.key !== selectedKey) {
                                if (node.selectable === false)
                                    break;
                                if (selectedKey)
                                    this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false);
                                this._toggleItemSelection(node, true);
                                this._updateSelectedItems()
                            }
                            break;
                        case"_remoteSelectionSync":
                        case"cssClass":
                        case"position":
                        case"selectionByClick":
                        case"animation":
                        case"useInkRipple":
                            this._invalidate();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _toggleItemSelection: function(node, value) {
                    var itemElement = this._getElementByItem(node.internalFields.item);
                    itemElement && $(itemElement).toggleClass(DX_MENU_SELECTED_ITEM_CLASS);
                    this._dataAdapter.toggleSelection(node.internalFields.key, value)
                },
                _getElementByItem: function(itemData) {
                    var that = this,
                        result;
                    $.each(this._itemContainer().find("." + ITEM_CLASS), function(_, itemElement) {
                        if ($(itemElement).data(that._itemDataKey()) !== itemData)
                            return true;
                        result = itemElement;
                        return false
                    });
                    return result
                },
                _updateSelectedItems: function(oldSelection, newSelection) {
                    if (oldSelection || newSelection) {
                        this._updateSelection(newSelection, oldSelection);
                        this._fireSelectionChangeEvent(newSelection, oldSelection)
                    }
                },
                _fireSelectionChangeEvent: function(addedSelection, removedSelection) {
                    this._createActionByOption("onSelectionChanged", {excludeValidators: ["disabled", "readOnly"]})({
                        addedItems: [addedSelection],
                        removedItems: [removedSelection]
                    })
                },
                selectItem: function(itemElement) {
                    var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement,
                        node = this._dataAdapter.getNodeByItem(itemData),
                        selectedKey = this._dataAdapter.getSelectedNodesKeys()[0],
                        selectedItem = this.option("selectedItem");
                    if (node.internalFields.key !== selectedKey) {
                        if (selectedKey)
                            this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false);
                        this._toggleItemSelection(node, true);
                        this._updateSelectedItems(selectedItem, itemData);
                        this._setOptionSilent("selectedItem", itemData)
                    }
                },
                unselectItem: function(itemElement) {
                    var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement,
                        node = this._dataAdapter.getNodeByItem(itemData),
                        selectedItem = this.option("selectedItem");
                    if (node.internalFields.selected) {
                        this._toggleItemSelection(node, false);
                        this._updateSelectedItems(selectedItem, null);
                        this._setOptionSilent("selectedItem", null)
                    }
                }
            });
        dxMenuBase.publicName("dxMenuBase");
        ui.dxMenuBase = dxMenuBase
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.menuBase.edit.strategy.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            errors = DevExpress.require("/ui/ui.errors");
        ui.CollectionWidget.MenuBaseEditStrategy = ui.CollectionWidget.PlainEditStrategy.inherit({
            _getPlainItems: function() {
                return $.map(this._collectionWidget.option("items"), function getMenuItems(item) {
                        return item.items ? [item].concat($.map(item.items, getMenuItems)) : item
                    })
            },
            _stringifyItem: function(item) {
                var that = this;
                return JSON.stringify(item, function(key, value) {
                        if (key === "template")
                            return that._getTemplateString(value);
                        return value
                    })
            },
            _getTemplateString: function(template) {
                var result;
                if (typeof template === "object")
                    result = $(template).text();
                else
                    result = template.toString();
                return result
            },
            selectedItemIndices: function() {
                var selectedIndices = [],
                    dataAdapter = this._collectionWidget._dataAdapter,
                    items = dataAdapter.getData(),
                    selectedItem = dataAdapter.getNodeByKey(dataAdapter.getSelectedNodesKeys()[0]);
                if (selectedItem) {
                    var index = $.inArray(selectedItem, items);
                    if (index !== -1)
                        selectedIndices.push(index);
                    else
                        errors.log("W1002", selectedItem)
                }
                return selectedIndices
            },
            fetchSelectedItems: function(indices) {
                indices = indices || this._collectionWidget._selectedItemIndices;
                var items = this._getPlainItems(),
                    selectedItems = [];
                $.each(indices, function(_, index) {
                    selectedItems.push(items[index])
                });
                return selectedItems
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.contextMenu.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            fx = DX.fx,
            positionUtils = DX.require("/utils/utils.position"),
            commonUtils = DX.require("/utils/utils.common"),
            devices = DX.require("/devices"),
            registerComponent = DX.require("/componentRegistrator"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var DX_MENU_CLASS = "dx-menu",
            DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item",
            DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded",
            DX_MENU_PHONE_CLASS = "dx-menu-phone-overlay",
            DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
            DX_MENU_ITEM_WRAPPER_CLASS = DX_MENU_ITEM_CLASS + "-wrapper",
            DX_SUBMENU_CLASS = "dx-submenu",
            DX_CONTEXT_MENU_CLASS = "dx-context-menu",
            DX_HAS_CONTEXT_MENU_CLASS = "dx-has-context-menu",
            DX_STATE_DISABLED_CLASS = "dx-state-disabled",
            FOCUS_UP = "up",
            FOCUS_DOWN = "down",
            FOCUS_LEFT = "left",
            FOCUS_RIGHT = "right",
            FOCUS_FIRST = "first",
            FOCUS_LAST = "last",
            ACTIONS = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioning", "onLeftFirstItem", "onLeftLastItem", "onCloseRootSubmenu", "onExpandLastSubmenu"],
            LOCAL_SUBMENU_DIRECTIONS = [FOCUS_UP, FOCUS_DOWN, FOCUS_FIRST, FOCUS_LAST];
        registerComponent("dxContextMenu", ui, ui.dxMenuBase.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        alternativeInvocationMode: {
                            enabled: false,
                            invokingElement: null
                        },
                        position: {
                            at: "top left",
                            my: "top left"
                        },
                        onShowing: null,
                        onShown: null,
                        onHiding: null,
                        onHidden: null,
                        onPositioning: null,
                        submenuDirection: "auto",
                        visible: false,
                        target: window,
                        onLeftFirstItem: null,
                        onLeftLastItem: null,
                        onCloseRootSubmenu: null,
                        onExpandLastSubmenu: null
                    })
            },
            _initActions: function() {
                this._actions = {};
                $.each(ACTIONS, $.proxy(function(index, action) {
                    this._actions[action] = this._createActionByOption(action) || $.noop
                }, this))
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {
                    animation: true,
                    position: true,
                    selectedItem: true
                })
            },
            _itemContainer: function() {
                return this._overlay && this._overlay.content()
            },
            _eventBindingTarget: function() {
                return this._itemContainer()
            },
            _supportedKeys: function() {
                var selectItem = function(e) {
                        var $item = this.option("focusedElement");
                        this.hide();
                        if (!$item || !this._isSelectionEnabled())
                            return;
                        this.selectItem($item[0])
                    };
                return $.extend(this.callBase(), {
                        space: selectItem,
                        esc: this.hide
                    })
            },
            _moveFocus: function(location) {
                var $items = this._getItemsByLocation(location),
                    $oldTarget = this._getActiveItem(true),
                    $newTarget,
                    $focusedItem = this.option("focusedElement");
                switch (location) {
                    case FOCUS_UP:
                        $newTarget = $focusedItem ? this._prevItem($items) : $items.last();
                        if ($oldTarget.is($items.first()))
                            this._actions.onLeftFirstItem($oldTarget);
                        break;
                    case FOCUS_DOWN:
                        $newTarget = $focusedItem ? this._nextItem($items) : $items.first();
                        if ($oldTarget.is($items.last()))
                            this._actions.onLeftLastItem($oldTarget);
                        break;
                    case FOCUS_RIGHT:
                        $newTarget = this.option("rtlEnabled") ? this._hideSubmenuHandler($items) : this._expandSubmenuHandler($items, location);
                        break;
                    case FOCUS_LEFT:
                        $newTarget = this.option("rtlEnabled") ? this._expandSubmenuHandler($items, location) : this._hideSubmenuHandler($items);
                        break;
                    case FOCUS_FIRST:
                        $newTarget = $items.first();
                        break;
                    case FOCUS_LAST:
                        $newTarget = $items.last();
                        break;
                    default:
                        return this.callBase(location)
                }
                if ($newTarget.length !== 0)
                    this.option("focusedElement", $newTarget)
            },
            _getItemsByLocation: function(location) {
                var $items,
                    $activeItem = this._getActiveItem(true),
                    expandedLocation = this.option("rtlEnabled") ? FOCUS_LEFT : FOCUS_RIGHT;
                if ($.inArray(location, LOCAL_SUBMENU_DIRECTIONS) >= 0)
                    $items = $activeItem.closest("." + DX_MENU_ITEMS_CONTAINER_CLASS).children().children();
                else {
                    $items = this._itemElements();
                    if (location !== expandedLocation)
                        $items = $items.filter(":visible")
                }
                return $items
            },
            _getAriaTarget: function() {
                return this.element()
            },
            _refreshActiveDescendant: function() {
                var $target = this._overlay.content(),
                    id = this.getFocusedItemId();
                if (!$target)
                    return this.callBase();
                this.setAria("activedescendant", "", $target);
                this.setAria("activedescendant", id, $target)
            },
            _hideSubmenuHandler: function($items) {
                var $curItem = this._getActiveItem(true),
                    $parentItem = $curItem.parents("." + DX_MENU_ITEM_EXPANDED_CLASS).first();
                if ($parentItem.length) {
                    this._hideSubmenusOnSameLevel($parentItem);
                    return $parentItem
                }
                this._actions.onCloseRootSubmenu($curItem);
                return $curItem
            },
            _expandSubmenuHandler: function($items, location) {
                var $curItem = this._getActiveItem(true),
                    node = this._dataAdapter.getNodeByItem(this._getItemData($curItem)),
                    isItemHasSubmenu = this._hasSubmenu(node),
                    $submenu = $curItem.children("." + DX_SUBMENU_CLASS);
                if (isItemHasSubmenu && !$curItem.hasClass(DX_STATE_DISABLED_CLASS)) {
                    if (!$submenu.length || $submenu.css("visibility") === "hidden")
                        this._showSubmenu($curItem);
                    return this._nextItem(this._getItemsByLocation(location))
                }
                this._actions.onExpandLastSubmenu($curItem);
                return $curItem
            },
            _render: function() {
                this.element().addClass(DX_HAS_CONTEXT_MENU_CLASS);
                this.callBase();
                this.setAria("role", "menu")
            },
            _renderContentImpl: function() {
                this._renderContextMenuOverlay();
                this._detachShowContextMenuEvents(this.option("target"));
                this._attachShowContextMenuEvents();
                this._attachInvokeContextMenuEvents();
                this.callBase()
            },
            _renderContextMenuOverlay: function() {
                if (this._overlay)
                    return;
                var overlayOptions = this._getOverlayOptions(),
                    $overlayElement = $("<div>"),
                    $overlayContent;
                this._overlay = this._createComponent($overlayElement.appendTo(this._$element), "dxOverlay", overlayOptions);
                $overlayContent = this._overlay.content();
                $overlayContent.addClass(DX_CONTEXT_MENU_CLASS);
                this._addCustomCssClass($overlayContent);
                this._addPlatformDependentClass($overlayContent)
            },
            _addPlatformDependentClass: function($element) {
                if (devices.current().phone)
                    $element.addClass(DX_MENU_PHONE_CLASS)
            },
            _detachShowContextMenuEvents: function(target) {
                var eventName = eventUtils.addNamespace("dxcontextmenu", this.NAME);
                if (this._showContextMenuEventHandler)
                    $(document).off(eventName, this._getTargetSelector(target), this._showContextMenuEventHandler).off(eventName);
                else
                    $(target).off(eventName);
                this._overlay && this._overlay.content().off(eventName)
            },
            _attachShowContextMenuEvents: function() {
                var that = this,
                    eventName = eventUtils.addNamespace("dxcontextmenu", this.NAME),
                    contextMenuAction = this._createAction($.proxy(function(e) {
                        if (!that.option("alternativeInvocationMode").enabled)
                            that._show(e.jQueryEvent)
                    }, this), {validatingTargetName: "target"}),
                    handler = $.proxy(function(e) {
                        contextMenuAction({
                            jQueryEvent: e,
                            target: $(e.currentTarget)
                        })
                    }, this);
                contextMenuAction = this._createAction(contextMenuAction);
                this._overlay && this._overlay.content().on(eventName, $.noop);
                if (this.option("target") instanceof $)
                    this._attachShowEventHandler(eventName, this.option("target"), handler);
                else
                    this._attachLiveShowEventHandler(eventName, this.option("target"), handler)
            },
            _attachShowEventHandler: function(eventName, $target, handler) {
                this._showContextMenuEventHandler = undefined;
                $target.on(eventName, handler)
            },
            _attachLiveShowEventHandler: function(eventName, targetSelector, handler) {
                this._showContextMenuEventHandler = handler;
                var that = this;
                $(document).on(eventName, targetSelector, function(e) {
                    that._showContextMenuEventHandler(e);
                    e.liveEvent = true
                }).on(eventName, function(e) {
                    e._cancel = !e.liveEvent
                })
            },
            _getTargetSelector: function(target) {
                return target instanceof $ ? target.selector : target
            },
            _attachInvokeContextMenuEvents: function() {
                var that = this,
                    eventName = eventUtils.addNamespace("dxclick", this.NAME),
                    contextMenuAction = this._createAction($.proxy(function() {
                        that.toggle()
                    }, this), {validatingTargetName: "target"});
                if (this.option("alternativeInvocationMode").enabled && this._getInvokeTarget())
                    $(this._getInvokeTarget()).off(eventName).on(eventName, $.proxy(function(e) {
                        contextMenuAction({
                            jQueryEvent: e,
                            target: $(e.target)
                        })
                    }, this))
            },
            _getInvokeTarget: function() {
                return this.option("alternativeInvocationMode").invokingElement
            },
            _hoverEndHandler: function(e) {
                e.stopPropagation()
            },
            _renderDimensions: $.noop,
            _renderContainer: function($wrapper, submenuContainer) {
                var $itemsContainer,
                    $holder = submenuContainer || this._itemContainer();
                $wrapper = $("<div>");
                $wrapper.appendTo($holder).addClass(DX_SUBMENU_CLASS).css("visibility", submenuContainer ? "hidden" : "visible");
                $itemsContainer = this.callBase($wrapper);
                if (submenuContainer)
                    return $itemsContainer;
                if (this.option("width"))
                    return $itemsContainer.css("min-width", this.option("width"));
                if (this.option("height"))
                    return $itemsContainer.css("min-height", this.option("height"));
                return $itemsContainer
            },
            _renderSubmenuItems: function(node, $itemFrame) {
                this._renderItems(this._getChildNodes(node), $itemFrame)
            },
            _getOverlayOptions: function() {
                var position = this.option("position"),
                    overlayAnimation = this.option("animation"),
                    overlayOptions = {
                        focusStateEnabled: this.option("focusStateEnabled"),
                        animation: overlayAnimation,
                        closeOnOutsideClick: $.proxy(this._closeOnOutsideClickHandler, this),
                        closeOnTargetScroll: true,
                        deferRendering: false,
                        position: {
                            at: position.at,
                            my: position.my,
                            of: this.option("target"),
                            collision: "fit"
                        },
                        shading: false,
                        showTitle: false,
                        height: "auto",
                        width: "auto",
                        visible: this.option("visible"),
                        onShown: $.proxy(this._overlayShownActionHandler, this),
                        onHiding: $.proxy(this._overlayHidingActionHandler, this),
                        onHidden: $.proxy(this._overlayHiddenActionHandler, this),
                        onPositioned: $.proxy(this._overlayPositionedActionHandler, this)
                    };
                return overlayOptions
            },
            _overlayShowingActionHandler: function(arg) {
                this._actions.onShowing(arg);
                this._clearFocusedItem()
            },
            _overlayShownActionHandler: function(arg) {
                this._actions.onShown(arg);
                this._clearFocusedItem()
            },
            _clearFocusedItem: function() {
                this._removeFocusedItem();
                this.option("focusedElement", null)
            },
            _overlayHidingActionHandler: function(arg) {
                this._actions.onHiding(arg);
                if (!arg.cancel) {
                    this._hideAllShownSubmenus();
                    this._setOptionSilent("visible", false)
                }
            },
            _overlayHiddenActionHandler: function(arg) {
                this._actions.onHidden(arg)
            },
            _overlayPositionedActionHandler: $.noop,
            _closeOnOutsideClickHandler: function(e) {
                var $clickedItem,
                    $activeItemContainer,
                    $itemContainers,
                    $rootItem,
                    isRootItemClicked,
                    isInnerOverlayClicked,
                    isInvokeTarget = $(e.target).closest(this._getInvokeTarget());
                if (e.target === document)
                    return true;
                if (isInvokeTarget && isInvokeTarget.length)
                    return false;
                $activeItemContainer = this._getActiveItemsContainer(e.target);
                $itemContainers = this._getItemsContainers();
                $clickedItem = this._searchActiveItem(e.target);
                $rootItem = this.element().parents("." + DX_MENU_ITEM_CLASS);
                isRootItemClicked = $clickedItem[0] === $rootItem[0] && $clickedItem.length && $rootItem.length;
                isInnerOverlayClicked = this._isIncludeOverlay($activeItemContainer, $itemContainers) && $clickedItem.length;
                if (isInnerOverlayClicked || isRootItemClicked) {
                    if (this._getShowSubmenuMode() === "onClick")
                        this._hideAllShownChildSubmenus($clickedItem);
                    return false
                }
                return true
            },
            _getActiveItemsContainer: function(target) {
                return $(target).closest("." + DX_MENU_ITEMS_CONTAINER_CLASS)
            },
            _getItemsContainers: function() {
                return this._overlay._$content.find("." + DX_MENU_ITEMS_CONTAINER_CLASS)
            },
            _searchActiveItem: function(target) {
                return $(target).closest("." + DX_MENU_ITEM_CLASS).eq(0)
            },
            _isIncludeOverlay: function($activeOverlay, $allOverlays) {
                var isSame = false;
                $.each($allOverlays, function(index, $overlay) {
                    if ($activeOverlay.is($overlay) && !isSame)
                        isSame = true
                });
                return isSame
            },
            _hideAllShownChildSubmenus: function($clickedItem) {
                var that = this,
                    $submenuElements = $clickedItem.find("." + DX_SUBMENU_CLASS),
                    shownSubmenus = $.extend([], this._shownSubmenus),
                    $context;
                if ($submenuElements.length > 0)
                    $.each(shownSubmenus, function(index, $submenu) {
                        $context = that._searchActiveItem($submenu.context).parent();
                        if ($context.parent().is($clickedItem.parent().parent()) && !$context.is($clickedItem.parent()))
                            that._hideSubmenu($submenu)
                    })
            },
            _showSubmenu: function($item) {
                var node = this._dataAdapter.getNodeByItem(this._getItemData($item)),
                    isItemHasSubmenu = this._hasSubmenu(node),
                    isSubmenuVisible;
                this._hideSubmenusOnSameLevel($item);
                if (isItemHasSubmenu) {
                    this.callBase($item);
                    $item.closest("." + DX_MENU_ITEMS_CONTAINER_CLASS).find("." + DX_MENU_ITEM_EXPANDED_CLASS).removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                    if (!$item.children("." + DX_SUBMENU_CLASS).length)
                        this._renderSubmenuItems(node, $item, 2);
                    isSubmenuVisible = this._isSubmenuVisible($item.children("." + DX_SUBMENU_CLASS));
                    if (!isSubmenuVisible) {
                        $item.addClass(DX_MENU_ITEM_EXPANDED_CLASS);
                        this._drawSubmenu($item)
                    }
                }
            },
            _hideSubmenusOnSameLevel: function($item) {
                var $expandedItems = $item.closest("." + DX_MENU_ITEMS_CONTAINER_CLASS).find("." + DX_MENU_ITEM_EXPANDED_CLASS);
                if ($expandedItems.length) {
                    $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                    this._hideSubmenu($expandedItems.find("." + DX_SUBMENU_CLASS))
                }
            },
            _hideSubmenuGroup: function($submenu) {
                if (this._isSubmenuVisible($submenu))
                    this._hideSubmenuCore($submenu)
            },
            _isSubmenuVisible: function($submenu) {
                return $submenu.css("visibility") === "visible"
            },
            _drawSubmenu: function($itemElement) {
                var animation = this.option("animation") ? this.option("animation").show : {},
                    $submenu = $itemElement.children("." + DX_SUBMENU_CLASS);
                if (this._overlay && this._overlay.option("visible")) {
                    if (!commonUtils.isDefined(this._shownSubmenus))
                        this._shownSubmenus = [];
                    if ($.inArray($submenu, this._shownSubmenus))
                        this._shownSubmenus.push($submenu);
                    positionUtils.setup($submenu, this._getSubmenuPosition($itemElement));
                    animation && this._animate($submenu, animation);
                    $submenu.css("visibility", "visible")
                }
            },
            _animate: function($container, options) {
                fx.animate($container, options)
            },
            _getSubmenuPosition: function($rootItem) {
                var submenuDirection = this.option("submenuDirection").toLowerCase(),
                    $rootItemWrapper = $rootItem.parent("." + DX_MENU_ITEM_WRAPPER_CLASS),
                    position = {
                        collision: "flip",
                        of: $rootItemWrapper,
                        offset: {
                            h: 0,
                            v: -1
                        }
                    };
                switch (submenuDirection) {
                    case"left":
                        position.at = "left top";
                        position.my = "right top";
                        break;
                    case"right":
                        position.at = "right top";
                        position.my = "left top";
                        break;
                    default:
                        if (this.option("rtlEnabled")) {
                            position.at = "left top";
                            position.my = "right top"
                        }
                        else {
                            position.at = "right top";
                            position.my = "left top"
                        }
                        break
                }
                return position
            },
            _updateSubmenuVisibilityOnClick: function(actionArgs) {
                var $itemElement,
                    itemData,
                    node,
                    renderSubmenu,
                    $submenuElement,
                    notCloseMenuOnItemClick;
                if (!actionArgs.args.length)
                    return;
                actionArgs.args[0].jQueryEvent.stopPropagation();
                $itemElement = actionArgs.args[0].itemElement;
                itemData = actionArgs.args[0].itemData;
                node = this._dataAdapter.getNodeByItem(itemData);
                if (!node)
                    return;
                renderSubmenu = node.internalFields.childrenKeys.length && !$itemElement.find("." + DX_SUBMENU_CLASS).length;
                renderSubmenu && this._renderSubmenuItems(node, $itemElement, 2);
                notCloseMenuOnItemClick = itemData && itemData.closeMenuOnClick === false;
                $submenuElement = $itemElement.children("." + DX_SUBMENU_CLASS);
                if ($itemElement.context === $submenuElement.context && $submenuElement.css("visibility") === "visible")
                    return;
                if (!itemData || itemData.disabled || notCloseMenuOnItemClick)
                    return;
                this._updateSelectedItemOnClick(actionArgs);
                if ($submenuElement.length === 0) {
                    var $prevSubmenu = $($itemElement.parents("." + DX_SUBMENU_CLASS)[0]);
                    this._hideSubmenu($prevSubmenu);
                    if (!actionArgs.canceled && this._overlay && this._overlay.option("visible"))
                        this.option("visible", false)
                }
                else {
                    if (this._shownSubmenus && this._shownSubmenus.length > 0)
                        if (this._shownSubmenus[0].is($submenuElement) || this._shownSubmenus[0].has($submenuElement).length === 1)
                            this._hideSubmenu($submenuElement);
                        else
                            this._hideAllShownSubmenus();
                    this._showSubmenu($itemElement)
                }
            },
            _hideSubmenu: function($curSubmenu) {
                var that = this,
                    shownSubmenus = $.extend([], that._shownSubmenus);
                $.each(shownSubmenus, function(index, $submenu) {
                    if ($curSubmenu.is($submenu) || $curSubmenu.has($submenu).length) {
                        $submenu.parent().removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                        that._hideSubmenuCore($submenu)
                    }
                })
            },
            _hideSubmenuCore: function($submenu) {
                var index = $.inArray($submenu, this._shownSubmenus),
                    animation = this.option("animation") ? this.option("animation").hide : null;
                if (index >= 0)
                    this._shownSubmenus.splice(index, 1);
                this._stopAnimate($submenu);
                animation && this._animate($submenu, animation);
                $submenu.css("visibility", "hidden")
            },
            _stopAnimate: function($container) {
                fx.stop($container, true)
            },
            _hideAllShownSubmenus: function() {
                var that = this,
                    shownSubmenus = $.extend([], that._shownSubmenus),
                    $expandedItems = this._overlay.content().find("." + DX_MENU_ITEM_EXPANDED_CLASS);
                $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                $.each(shownSubmenus, function(_, $submenu) {
                    that._hideSubmenuCore($submenu)
                })
            },
            _visibilityChanged: function(visible) {
                if (visible) {
                    this._detachShowContextMenuEvents(this.option("target"));
                    this._attachShowContextMenuEvents();
                    this._attachInvokeContextMenuEvents()
                }
            },
            _optionChanged: function(args) {
                if (this._cancelOptionChange)
                    return;
                if ($.inArray(args.name, ACTIONS) > -1) {
                    this._initActions();
                    return
                }
                switch (args.name) {
                    case"visible":
                        this._toggleVisibility(args.value);
                        break;
                    case"alternativeInvocationMode":
                        this._invalidate();
                        break;
                    case"position":
                    case"submenuDirection":
                        this._invalidate();
                        break;
                    case"target":
                        args.previousValue && this._detachShowContextMenuEvents(args.previousValue);
                        this.option("position").of = null;
                        this._invalidate();
                        break;
                    case"focusedElement":
                        this.callBase(args);
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _toggleVisibility: function(showing) {
                showing ? this._show() : this._hide()
            },
            _show: function(jQEvent) {
                var args = {jQEvent: jQEvent};
                this._actions.onShowing(args);
                if (args.cancel)
                    return $.Deferred().reject().promise();
                var canShowMenu = !(this._overlay && this._positionContextMenu(jQEvent)),
                    id = new DevExpress.data.Guid,
                    promise;
                if (canShowMenu && this._overlay) {
                    this._setOptionSilent("visible", true);
                    this.option("focusedElement", this._itemElements().first());
                    promise = this._overlay.show();
                    this._overlay.content().attr({
                        id: id,
                        role: "menu"
                    });
                    this.setAria("owns", id)
                }
                return promise || $.Deferred().reject().promise()
            },
            _positionContextMenu: function(jQEvent) {
                var position = this.option("position"),
                    positioningAction = this._createActionByOption("onPositioning", actionArgs),
                    actionArgs;
                if (jQEvent && jQEvent.preventDefault)
                    position = {
                        at: "top left",
                        my: "top left",
                        of: jQEvent
                    };
                if (!position.of)
                    position.of = this.option("target");
                actionArgs = {
                    position: position,
                    jQueryEvent: jQEvent
                };
                positioningAction(actionArgs);
                if (!actionArgs.cancel && this._overlay)
                    position && !this._overlay.option("visible") && this._overlay.option("position", position);
                else if (actionArgs.jQueryEvent)
                    actionArgs.jQueryEvent.cancel = true;
                return actionArgs.cancel
            },
            _hide: function() {
                var promise;
                if (this._overlay) {
                    this._overlay.content().removeAttr("id");
                    promise = this._overlay.hide();
                    this._setOptionSilent("visible", false)
                }
                this.setAria("owns", undefined);
                return promise || $.Deferred().reject().promise()
            },
            _clean: function() {
                this._detachShowContextMenuEvents($(this.option("target")));
                this.callBase()
            },
            toggle: function(showing) {
                var visible = this.option("visible");
                showing = showing === undefined ? !visible : showing;
                return showing ? this._show() : this._hide()
            },
            show: function() {
                return this.toggle(true)
            },
            hide: function() {
                return this.toggle(false)
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.menu.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            positionUtils = DX.require("/utils/utils.position"),
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer"),
            hoverEvents = DX.require("/ui/events/ui.events.hover");
        var DX_MENU_CLASS = "dx-menu",
            DX_MENU_VERTICAL_CLASS = DX_MENU_CLASS + "-vertical",
            DX_MENU_HORIZONTAL_CLASS = DX_MENU_CLASS + "-horizontal",
            DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item",
            DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container",
            DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded",
            DX_CONTEXT_MENU_CLASS = "dx-context-menu",
            DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS = DX_CONTEXT_MENU_CLASS + "-container-border",
            DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS = "dx-context-menu-content-delimiter",
            DX_SUBMENU_CLASS = "dx-submenu",
            DX_STATE_DISABLED_CLASS = "dx-state-disabled",
            DX_STATE_FOCUSED_CLASS = "dx-state-focused",
            FOCUS_UP = "up",
            FOCUS_DOWN = "down",
            FOCUS_LEFT = "left",
            FOCUS_RIGHT = "right",
            SHOW_SUBMENU_OPERATION = "showSubmenu",
            NEXTITEM_OPERATION = "nextItem",
            PREVITEM_OPERATION = "prevItem",
            DEFAULT_DELAY = {
                show: 50,
                hide: 300
            },
            ACTIONS = ["onSubmenuShowing", "onSubmenuShown", "onSubmenuHiding", "onSubmenuHidden"],
            dxSubmenu = ui.dxContextMenu.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {orientation: "horizontal"})
                },
                _initDataAdapter: function() {
                    this._dataAdapter = this.option("_dataAdapter");
                    if (this._dataAdapter)
                        this._dataAdapter.options.rooValue = this.option("_parentKey");
                    else
                        this.callBase()
                },
                _renderContentImpl: function() {
                    this._renderContextMenuOverlay();
                    this._detachShowContextMenuEvents(this.option("target"));
                    this._attachShowContextMenuEvents();
                    this._attachInvokeContextMenuEvents();
                    var node = this._dataAdapter.getNodeByKey(this.option("_parentKey"));
                    node && this._renderItems(this._getChildNodes(node));
                    this._renderDelimiter()
                },
                _renderDelimiter: function() {
                    this.$contentDelimiter = $("<div>").appendTo(this._itemContainer()).addClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS)
                },
                _overlayPositionedActionHandler: function(arg) {
                    this._showDelimiter(arg)
                },
                _hoverEndHandler: function(e) {
                    this._toggleFocusClass(false, e.currentTarget)
                },
                _isMenuHorizontal: function() {
                    return this.option("orientation") === "horizontal"
                },
                _hoverStartHandler: function(e) {
                    this.callBase(e);
                    this._toggleFocusClass(true, e.currentTarget)
                },
                _showDelimiter: function(arg) {
                    var $submenu = this._itemContainer().children("." + DX_SUBMENU_CLASS).eq(0),
                        $rootItem = this.option("position").of,
                        position = {of: $submenu},
                        containerOffset,
                        rootOffset;
                    if (this.$contentDelimiter) {
                        containerOffset = arg.position;
                        rootOffset = $rootItem.offset();
                        this.$contentDelimiter.css("display", "block");
                        if (this._isMenuHorizontal()) {
                            this.$contentDelimiter.width($rootItem.width() < $submenu.width() ? $rootItem.width() - 2 : $submenu.width() - 2);
                            this.$contentDelimiter.height(2);
                            if (containerOffset.v.location > rootOffset.top)
                                if (Math.round(containerOffset.h.location) === Math.round(rootOffset.left)) {
                                    position.offset = "1 -1";
                                    position.at = "left top";
                                    position.my = "left top"
                                }
                                else {
                                    position.offset = "-1 -1";
                                    position.at = "right top";
                                    position.my = "right top"
                                }
                            else {
                                this.$contentDelimiter.height(5);
                                if (Math.round(containerOffset.h.location) === Math.round(rootOffset.left)) {
                                    position.offset = "1 4";
                                    position.at = "left bottom";
                                    position.my = "left bottom"
                                }
                                else {
                                    position.offset = "-1 2";
                                    position.at = "right bottom";
                                    position.my = "right bottom"
                                }
                            }
                        }
                        else {
                            this.$contentDelimiter.width(2);
                            this.$contentDelimiter.height($rootItem.height() < $submenu.height() ? $rootItem.height() - 2 : $submenu.height() - 2);
                            if (containerOffset.h.location > rootOffset.left)
                                if (Math.round(containerOffset.v.location) === Math.round(rootOffset.top)) {
                                    position.offset = "-1 1";
                                    position.at = "left top";
                                    position.my = "left top"
                                }
                                else {
                                    position.offset = "-1 -1";
                                    position.at = "left bottom";
                                    position.my = "left bottom"
                                }
                            else if (Math.round(containerOffset.v.location) === Math.round(rootOffset.top)) {
                                position.offset = "1 1";
                                position.at = "right top";
                                position.my = "right top"
                            }
                            else {
                                position.offset = "1 -1";
                                position.at = "right bottom";
                                position.my = "right bottom"
                            }
                        }
                        positionUtils.setup(this.$contentDelimiter, position)
                    }
                },
                isOverlayVisible: function() {
                    return this._overlay.option("visible")
                },
                getOverlayContent: function() {
                    return this._overlay.content()
                }
            });
        registerComponent("dxMenu", ui, ui.dxMenuBase.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        orientation: "horizontal",
                        submenuDirection: "auto",
                        showFirstSubmenuMode: {
                            name: "onClick",
                            delay: {
                                show: 50,
                                hide: 300
                            }
                        },
                        hideSubmenuOnMouseLeave: false,
                        onSubmenuShowing: null,
                        onSubmenuShown: null,
                        onSubmenuHiding: null,
                        onSubmenuHidden: null
                    })
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {
                    animation: true,
                    selectedItem: true
                })
            },
            _focusTarget: function() {
                return this.element()
            },
            _isMenuHorizontal: function() {
                return this.option("orientation") === "horizontal"
            },
            _moveFocus: function(location) {
                var $items = this._itemElements().filter(":visible"),
                    isMenuHorizontal = this._isMenuHorizontal(),
                    argument,
                    $activeItem = this._getActiveItem(true),
                    operation,
                    navigationAction,
                    $newTarget;
                switch (location) {
                    case FOCUS_UP:
                        operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(PREVITEM_OPERATION);
                        argument = isMenuHorizontal ? $activeItem : $items;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    case FOCUS_DOWN:
                        operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(NEXTITEM_OPERATION);
                        argument = isMenuHorizontal ? $activeItem : $items;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    case FOCUS_RIGHT:
                        operation = isMenuHorizontal ? this._getItemsNavigationOperation(NEXTITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
                        argument = isMenuHorizontal ? $items : $activeItem;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    case FOCUS_LEFT:
                        operation = isMenuHorizontal ? this._getItemsNavigationOperation(PREVITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
                        argument = isMenuHorizontal ? $items : $activeItem;
                        navigationAction = this._getKeyboardNavigationAction(operation, argument);
                        $newTarget = navigationAction();
                        break;
                    default:
                        return this.callBase(location)
                }
                if ($newTarget && $newTarget.length !== 0)
                    this.option("focusedElement", $newTarget)
            },
            _getItemsNavigationOperation: function(operation) {
                var navOperation = operation;
                if (this.option("rtlEnabled"))
                    navOperation = operation === PREVITEM_OPERATION ? NEXTITEM_OPERATION : PREVITEM_OPERATION;
                return navOperation
            },
            _getKeyboardNavigationAction: function(operation, argument) {
                var action = $.noop;
                switch (operation) {
                    case SHOW_SUBMENU_OPERATION:
                        if (!argument.hasClass(DX_STATE_DISABLED_CLASS))
                            action = $.proxy(this._showSubmenu, this, argument);
                        break;
                    case NEXTITEM_OPERATION:
                        action = $.proxy(this._nextItem, this, argument);
                        break;
                    case PREVITEM_OPERATION:
                        action = $.proxy(this._prevItem, this, argument);
                        break
                }
                return action
            },
            _init: function() {
                this.callBase();
                this._submenus = []
            },
            _initActions: function() {
                this._actions = {};
                $.each(ACTIONS, $.proxy(function(index, action) {
                    this._actions[action] = this._createActionByOption(action) || $.noop
                }, this))
            },
            _render: function() {
                this._visibleSubmenu = null;
                this.callBase();
                this.element().addClass(DX_MENU_CLASS);
                this.setAria("role", "menubar")
            },
            _getDelay: function(delayType) {
                var delay = this.option("showFirstSubmenuMode").delay;
                if (!commonUtils.isDefined(delay))
                    return DEFAULT_DELAY[delayType];
                return commonUtils.isObject(delay) ? delay[delayType] : delay
            },
            _renderContainer: function() {
                var $wrapper = $("<div>");
                $wrapper.appendTo(this.element()).addClass(this._isMenuHorizontal() ? DX_MENU_HORIZONTAL_CLASS : DX_MENU_VERTICAL_CLASS);
                return this.callBase($wrapper)
            },
            _renderSubmenuItems: function(node, $itemFrame) {
                var submenu = this._createSubmenu(node, $itemFrame);
                this._submenus.push(submenu);
                this._renderBorderElement($itemFrame);
                return submenu
            },
            _createSubmenu: function(node, $rootItem) {
                var $submenuContainer = $("<div>").addClass(DX_CONTEXT_MENU_CLASS).appendTo($rootItem);
                var items = this._getChildNodes(node),
                    result = this._createComponent($submenuContainer, "dxSubmenu", $.extend(this._getSubmenuOptions(), {
                        _dataAdapter: this._dataAdapter,
                        _parentKey: node.internalFields.key,
                        items: items,
                        position: this.getSubmenuPosition($rootItem)
                    }));
                this._attachSubmenuHandlers($rootItem, result);
                return result
            },
            _getSubmenuOptions: function() {
                var $submenuTarget = $("<div>"),
                    isMenuHorizontal = this._isMenuHorizontal();
                return {
                        itemTemplate: this.option("itemTemplate"),
                        templateProvider: this.option("templateProvider"),
                        target: $submenuTarget,
                        orientation: this.option("orientation"),
                        selectionMode: this.option("selectionMode"),
                        selectionByClick: this.option("selectionByClick"),
                        cssClass: this.option("cssClass"),
                        hoverStateEnabled: this.option("hoverStateEnabled"),
                        activeStateEnabled: this.option("activeStateEnabled"),
                        focusStateEnabled: this.option("focusStateEnabled"),
                        animation: this.option("animation"),
                        showSubmenuMode: this.option("showSubmenuMode"),
                        displayExpr: this.option("displayExpr"),
                        disabledExpr: this.option("disabledExpr"),
                        selectedExpr: this.option("selectedExpr"),
                        itemsExpr: this.option("itemsExpr"),
                        onSelectionChanged: $.proxy(this._nestedItemOnSelectionChangedHandler, this),
                        onItemClick: $.proxy(this._nestedItemOnItemClickHandler, this),
                        onItemRendered: this.option("onItemRendered"),
                        onLeftFirstItem: isMenuHorizontal ? null : $.proxy(this._moveMainMenuFocus, this, PREVITEM_OPERATION),
                        onLeftLastItem: isMenuHorizontal ? null : $.proxy(this._moveMainMenuFocus, this, NEXTITEM_OPERATION),
                        onCloseRootSubmenu: $.proxy(this._moveMainMenuFocus, this, isMenuHorizontal ? PREVITEM_OPERATION : null),
                        onExpandLastSubmenu: isMenuHorizontal ? $.proxy(this._moveMainMenuFocus, this, NEXTITEM_OPERATION) : null,
                        _remoteSelectionSync: true
                    }
            },
            _getShowFirstSubmenuMode: function() {
                if (!this._isDesktopDevice())
                    return "onClick";
                var optionValue = this.option("showFirstSubmenuMode");
                return commonUtils.isObject(optionValue) ? optionValue.name : optionValue
            },
            _moveMainMenuFocus: function(direction) {
                var $expandedItem = this.element().find("." + DX_MENU_ITEM_EXPANDED_CLASS).first(),
                    $parent = $expandedItem.parent(),
                    $newItem;
                switch (direction) {
                    case PREVITEM_OPERATION:
                        $newItem = $parent.prev();
                        if (!$newItem.length)
                            $newItem = $parent.siblings().last();
                        break;
                    case NEXTITEM_OPERATION:
                        $newItem = $parent.next();
                        if (!$newItem.length)
                            $newItem = $parent.siblings().first();
                        break;
                    default:
                        $newItem = $parent;
                        if (!$newItem.length)
                            $newItem = $parent.siblings().first();
                        break
                }
                $newItem = $newItem.children();
                this._visibleSubmenu && this._hideSubmenu(this._visibleSubmenu);
                this.focus();
                this.option("focusedElement", $newItem)
            },
            _nestedItemOnSelectionChangedHandler: function(args) {
                var selectedItem = args.addedItems.length && args.addedItems[0],
                    submenu = args.element.dxSubmenu("instance"),
                    onSelectionChanged = this._createActionByOption("onSelectionChanged", {});
                onSelectionChanged(args);
                selectedItem && this._clearSelectionInSubmenus(selectedItem[0], submenu);
                this._clearRootSelection();
                this._setOptionSilent("selectedItem", selectedItem)
            },
            _clearSelectionInSubmenus: function(item, targetSubmenu) {
                var that = this,
                    cleanAllSubmenus = !arguments.length;
                $.each(this._submenus, function(index, submenu) {
                    var $submenu = submenu._itemContainer(),
                        isOtherItem = !$submenu.is(targetSubmenu && targetSubmenu._itemContainer()),
                        $selectedItem = $submenu.find("." + that._selectedItemClass());
                    if (isOtherItem && $selectedItem.length || cleanAllSubmenus) {
                        var selectedItemData;
                        $selectedItem.removeClass(that._selectedItemClass());
                        selectedItemData = that._getItemData($selectedItem);
                        if (selectedItemData)
                            selectedItemData.selected = false;
                        submenu._clearSelectedItems()
                    }
                })
            },
            _clearRootSelection: function() {
                var $prevSelectedItem = this.element().find("." + DX_MENU_ITEMS_CONTAINER_CLASS).first().children().children().filter("." + this._selectedItemClass());
                if ($prevSelectedItem.length) {
                    var prevSelectedItemData;
                    prevSelectedItemData = this._getItemData($prevSelectedItem);
                    prevSelectedItemData.selected = false;
                    $prevSelectedItem.removeClass(this._selectedItemClass())
                }
            },
            _nestedItemOnItemClickHandler: function(arg) {
                var onItemClick = this._createActionByOption("onItemClick", {});
                onItemClick(arg)
            },
            _attachSubmenuHandlers: function($rootItem, submenu) {
                var that = this,
                    $submenuOverlayContent = submenu.getOverlayContent(),
                    submenus = $submenuOverlayContent.find("." + DX_SUBMENU_CLASS),
                    submenuMouseLeaveName = eventUtils.addNamespace(hoverEvents.end, this.NAME + "_submenu");
                submenu.option({
                    onShowing: $.proxy(this._submenuOnShowingHandler, this, $rootItem, submenu),
                    onShown: $.proxy(this._submenuOnShownHandler, this, $rootItem, submenu),
                    onHiding: $.proxy(this._submenuOnHidingHandler, this, $rootItem, submenu),
                    onHidden: $.proxy(this._submenuOnHiddenHandler, this, $rootItem, submenu)
                });
                $.each(submenus, function(index, submenu) {
                    $(submenu).off(submenuMouseLeaveName).on(submenuMouseLeaveName, null, $.proxy(that._submenuMouseLeaveHandler, that, $rootItem))
                })
            },
            _submenuOnShowingHandler: function($rootItem, submenu) {
                var $border = $rootItem.children("." + DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS);
                this._actions.onSubmenuShowing({
                    rootItem: $rootItem,
                    submenu: submenu
                });
                $border.show();
                $rootItem.addClass(DX_MENU_ITEM_EXPANDED_CLASS)
            },
            _submenuOnShownHandler: function($rootItem, submenu) {
                this._actions.onSubmenuShown({
                    rootItem: $rootItem,
                    submenu: submenu
                })
            },
            _submenuOnHidingHandler: function($rootItem, submenu, eventArgs) {
                var $border = $rootItem.children("." + DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS),
                    args = eventArgs;
                args.rootItem = $rootItem;
                args.submenu = submenu;
                this._actions.onSubmenuHiding(args);
                eventArgs = args;
                if (!eventArgs.cancel) {
                    if (this._visibleSubmenu === submenu)
                        this._visibleSubmenu = null;
                    $border.hide();
                    $rootItem.removeClass(DX_MENU_ITEM_EXPANDED_CLASS)
                }
            },
            _submenuOnHiddenHandler: function($rootItem, submenu) {
                this._actions.onSubmenuHidden({
                    rootItem: $rootItem,
                    submenu: submenu
                })
            },
            _submenuMouseLeaveHandler: function($rootItem, eventArgs) {
                var that = this,
                    target = $(eventArgs.relatedTarget).parents("." + DX_CONTEXT_MENU_CLASS)[0],
                    contextmenu = this._getSubmenuByRootElement($rootItem).getOverlayContent()[0];
                if (this.option("hideSubmenuOnMouseLeave") && target !== contextmenu) {
                    clearTimeout(this._showSubmenuTimer);
                    clearTimeout(this._hideSubmenuTimer);
                    setTimeout($.proxy(this._hideSubmenuAfterTimeout, this), that._getDelay("hide"))
                }
            },
            _hideSubmenuAfterTimeout: function() {
                if (!this._visibleSubmenu)
                    return;
                var isSubmenuItemFocused = this._visibleSubmenu.getOverlayContent().find("." + DX_STATE_FOCUSED_CLASS).length;
                if (!isSubmenuItemFocused)
                    this._visibleSubmenu.hide()
            },
            _getSubmenuByRootElement: function($rootItem) {
                if (!$rootItem)
                    return false;
                var $submenu = $rootItem.children("." + DX_CONTEXT_MENU_CLASS);
                return $submenu.length && $submenu.data().dxSubmenu
            },
            getSubmenuPosition: function($rootItem) {
                var isHorizontalMenu = this._isMenuHorizontal(),
                    submenuDirection = this.option("submenuDirection").toLowerCase(),
                    rtlEnabled = this.option("rtlEnabled"),
                    submenuPosition = {
                        collision: "flip",
                        of: $rootItem
                    };
                switch (submenuDirection) {
                    case"leftortop":
                        submenuPosition.at = "left top";
                        submenuPosition.my = isHorizontalMenu ? "left bottom" : "right top";
                        break;
                    case"rightorbottom":
                        submenuPosition.at = isHorizontalMenu ? "left bottom" : "right top";
                        submenuPosition.my = "left top";
                        break;
                    default:
                        if (isHorizontalMenu) {
                            submenuPosition.at = rtlEnabled ? "right bottom" : "left bottom";
                            submenuPosition.my = rtlEnabled ? "right top" : "left top"
                        }
                        else {
                            submenuPosition.at = rtlEnabled ? "left top" : "right top";
                            submenuPosition.my = rtlEnabled ? "right top" : "left top"
                        }
                        break
                }
                return submenuPosition
            },
            _renderBorderElement: function($item) {
                $("<div>").appendTo($item).addClass(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS).hide()
            },
            _hoverStartHandler: function(e) {
                var mouseMoveEventName = eventUtils.addNamespace(pointerEvents.move, this.NAME),
                    $item = this._getItemElementByEventArgs(e),
                    node = this._dataAdapter.getNodeByItem(this._getItemData($item)),
                    isSelectionActive = commonUtils.isDefined(e.buttons) && e.buttons === 1 || !commonUtils.isDefined(e.buttons) && e.which === 1;
                if (this._isItemDisabled($item))
                    return;
                $item.off(mouseMoveEventName);
                if (!this._hasChildren(node)) {
                    setTimeout($.proxy(this._hideSubmenuAfterTimeout, this), this._getDelay("hide"));
                    return
                }
                if (this._getShowFirstSubmenuMode() === "onHover" && !isSelectionActive) {
                    var submenu = this._getSubmenuByElement($item);
                    clearTimeout(this._hideSubmenuTimer);
                    clearTimeout(this._showSubmenuTimer);
                    if (!submenu.isOverlayVisible()) {
                        $item.on(mouseMoveEventName, $.proxy(this._itemMouseMoveHandler, this));
                        this._showSubmenuTimer = this._getDelay("hide")
                    }
                }
            },
            _hoverEndHandler: function(eventArg) {
                var that = this,
                    $item = this._getItemElementByEventArgs(eventArg);
                if (this._isItemDisabled($item))
                    return;
                if ($(eventArg.relatedTarget).hasClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS))
                    return;
                if (this.option("hideSubmenuOnMouseLeave") && !$(eventArg.relatedTarget).hasClass(DX_MENU_ITEMS_CONTAINER_CLASS)) {
                    clearTimeout(this._showSubmenuTimer);
                    clearTimeout(this._hideSubmenuTimer);
                    this._hideSubmenuTimer = setTimeout(function() {
                        that._hideSubmenuAfterTimeout()
                    }, that._getDelay("hide"))
                }
            },
            _hideVisibleSubmenu: function() {
                if (!this._visibleSubmenu)
                    return false;
                this._hideSubmenu(this._visibleSubmenu);
                return true
            },
            _showSubmenu: function($itemElement) {
                var submenu = this._getSubmenuByElement($itemElement);
                if (this._visibleSubmenu !== submenu)
                    this._hideVisibleSubmenu();
                submenu && submenu.show();
                this._visibleSubmenu = submenu;
                this._hoveredRootItem = $itemElement
            },
            _hideSubmenu: function(submenu) {
                submenu && submenu.hide();
                if (this._visibleSubmenu === submenu)
                    this._visibleSubmenu = null;
                this._hoveredRootItem = null
            },
            _itemMouseMoveHandler: function(e) {
                if (e.pointers && e.pointers.length)
                    return;
                var that = this,
                    $item = $(e.currentTarget);
                if (!commonUtils.isDefined(this._showSubmenuTimer))
                    return;
                clearTimeout(this._hideSubmenuTimer);
                clearTimeout(this._showSubmenuTimer);
                this._showSubmenuTimer = setTimeout(function() {
                    var submenu = that._getSubmenuByElement($item);
                    if (submenu && !submenu.isOverlayVisible())
                        that._showSubmenu($item)
                }, that._getDelay("show"))
            },
            _getSubmenuByElement: function($itemElement, itemData) {
                itemData = itemData || this._getItemData($itemElement);
                var submenu = this._getSubmenuByRootElement($itemElement);
                if (submenu)
                    return submenu;
                else {
                    var node = this._dataAdapter.getNodeByItem(itemData);
                    return this._hasChildren(node) && this._renderSubmenuItems(node, $itemElement)
                }
            },
            _updateSubmenuVisibilityOnClick: function(actionArgs) {
                var args = actionArgs.args.length && actionArgs.args[0],
                    currentSubmenu;
                if (!args || this._disabledGetter(args.itemData))
                    return;
                args.jQueryEvent.stopPropagation();
                currentSubmenu = this._getSubmenuByElement(args.itemElement, args.itemData);
                this._updateSelectedItemOnClick(actionArgs);
                if (this._visibleSubmenu)
                    if (this._visibleSubmenu === currentSubmenu) {
                        this._hideSubmenu(this._visibleSubmenu);
                        return
                    }
                    else
                        this._hideSubmenu(this._visibleSubmenu);
                if (!currentSubmenu)
                    return;
                if (!currentSubmenu.isOverlayVisible()) {
                    this._showSubmenu(args.itemElement);
                    return
                }
            },
            _optionChanged: function(args) {
                if (this._cancelOptionChange)
                    return;
                this._hideShownSubmenuOnOptionChange(args.name);
                switch (args.name) {
                    case"orientation":
                    case"submenuDirection":
                    case"hideSubmenuOnMouseLeave":
                    case"showFirstSubmenuMode":
                        this._invalidate();
                        break;
                    case"showSubmenuMode":
                        this._changeSubmenusOption(args.name, args.value);
                        break;
                    case"onSubmenuShowing":
                    case"onSubmenuShown":
                    case"onSubmenuHiding":
                    case"onSubmenuHidden":
                        this._initActions();
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _hideShownSubmenuOnOptionChange: function(optionName) {
                if (optionName !== "focusedElement" && this._visibleSubmenu)
                    this._hideSubmenu(this._visibleSubmenu)
            },
            _changeSubmenusOption: function(name, value) {
                $.each(this._submenus, function(index, submenu) {
                    submenu.option(name, value)
                })
            },
            selectItem: function(itemElement) {
                this._hideSubmenu(this._visibleSubmenu);
                this.callBase(itemElement)
            },
            unselectItem: function(itemElement) {
                this._hideSubmenu(this._visibleSubmenu);
                this.callBase(itemElement)
            }
        }));
        registerComponent("dxSubmenu", ui.dxMenu, dxSubmenu);
        ui.dxMenu.__internals = {}
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.treeView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            CheckBox = DX.require("/ui/widgets/ui.checkBox"),
            HierarchicalCollectionWidget = DX.require("/ui/hierarchicalCollectionWidget/ui.hierarchicalCollectionWidget"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer");
        var WIDGET_CLASS = "dx-treeview",
            NODE_CONTAINER_CLASS = "dx-treeview-node-container",
            OPENED_NODE_CONTAINER_CLASS = "dx-treeview-node-container-opened",
            NODE_CLASS = "dx-treeview-node",
            ITEM_CLASS = "dx-treeview-item",
            ITEM_WITH_CHECKBOX_CLASS = "dx-treeview-item-with-checkbox",
            ITEM_DATA_KEY = "dx-treeview-item-data",
            IS_LEAF = "dx-treeview-node-is-leaf",
            TOGGLE_ITEM_VISIBILITY_CLASS = "dx-treeview-toggle-item-visibility",
            TOGGLE_ITEM_VISIBILITY_OPENED_CLASS = "dx-treeview-toggle-item-visibility-opened",
            SELECT_ALL_ITEM_CLASS = "dx-treeview-select-all-item",
            DISABLED_STATE_CLASS = "dx-state-disabled",
            SELECTED_ITEM_CLASS = "dx-state-selected",
            DATA_ITEM_ID = "data-item-id",
            DBLCLICK_EVENT_NAME = "dxdblclick";
        var scrollableContainerUpdatedOnInit = $.noop;
        function normalizeKey(id) {
            var key = commonUtils.isString(id) ? id : id.toString(),
                arr = key.match(/[^a-zA-Z0-9]/g);
            arr && $.each(arr, function(_, sign) {
                key = key.replace(sign, "_" + sign.charCodeAt() + "_")
            });
            return key
        }
        registerComponent("dxTreeView", ui, HierarchicalCollectionWidget.inherit({
            _supportedKeys: function(e) {
                var click = function(e) {
                        var $itemElement = this.option("focusedElement");
                        if (!$itemElement)
                            return;
                        e.target = $itemElement;
                        e.currentTarget = $itemElement;
                        this._itemClickHandler(e, $itemElement.find(">." + ITEM_CLASS))
                    };
                var select = function(e) {
                        e.preventDefault();
                        this._changeCheckBoxState(this.option("focusedElement"))
                    };
                var toggleExpandedNestedItems = function(state, e) {
                        if (!this.option("expandAllEnabled"))
                            return;
                        e.preventDefault();
                        var $rootElement = this.option("focusedElement");
                        if (!$rootElement)
                            return;
                        var rootItem = this._getItemData($rootElement.find("." + ITEM_CLASS));
                        this._toggleExpandedNestedItems([rootItem], state)
                    };
                return $.extend(this.callBase(), {
                        enter: this._showCheckboxes() ? select : click,
                        space: this._showCheckboxes() ? select : click,
                        asterisk: $.proxy(toggleExpandedNestedItems, this, true),
                        minus: $.proxy(toggleExpandedNestedItems, this, false)
                    })
            },
            _changeCheckBoxState: function($element) {
                var checkboxInstance = this._getCheckBoxInstance($element),
                    currentState = checkboxInstance.option("value");
                if (!checkboxInstance.option("disabled"))
                    this._updateItemSelection(!currentState, $element.find("." + ITEM_CLASS).get(0), true, $element)
            },
            _toggleExpandedNestedItems: function(items, state) {
                if (!items)
                    return;
                for (var i = 0, len = items.length; i < len; i++) {
                    var item = items[i],
                        node = this._dataAdapter.getNodeByItem(item);
                    this._toggleExpandedState(node, state);
                    this._toggleExpandedNestedItems(item.items, state)
                }
            },
            _getNodeElementById: function(id) {
                return this.element().find("[" + DATA_ITEM_ID + "='" + normalizeKey(id) + "']")
            },
            _activeStateUnit: "." + ITEM_CLASS,
            _widgetClass: function() {
                return WIDGET_CLASS
            },
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        animationEnabled: true,
                        dataStructure: "tree",
                        expandAllEnabled: false,
                        hasItemsExpr: "hasItems",
                        selectNodesRecursive: true,
                        expandNodesRecursive: true,
                        showCheckBoxesMode: "none",
                        selectAllText: Globalize.localize("dxList-selectAll"),
                        onItemSelected: null,
                        onItemExpanded: null,
                        onItemCollapsed: null,
                        scrollDirection: "vertical",
                        virtualModeEnabled: false,
                        rootValue: 0,
                        searchValue: "",
                        focusStateEnabled: false,
                        selectionMode: "multiple"
                    })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    showCheckBoxes: {
                        since: "15.2",
                        message: "use 'showCheckBoxesMode' option instead"
                    },
                    selectAllEnabled: {
                        since: "15.2",
                        message: "use 'showCheckBoxesMode' option instead"
                    }
                })
            },
            _initSelectedItems: $.noop,
            _syncSelectionOptions: $.noop,
            _fireSelectionChanged: function() {
                var selectionChangePromise = this._selectionChangePromise;
                $.when(selectionChangePromise).done($.proxy(function() {
                    this._createActionByOption("onSelectionChanged", {excludeValidators: ["disabled", "readOnly"]})()
                }, this))
            },
            _checkBoxModeChange: function(value, previousValue) {
                if (previousValue === "none" || value === "none") {
                    this.repaint();
                    return
                }
                var selectAllExists = this._$selectAllItem && this._$selectAllItem.length;
                switch (value) {
                    case"selectAll":
                        !selectAllExists && this._renderSelectAllItem();
                        break;
                    case"normal":
                        if (selectAllExists) {
                            this._$selectAllItem.remove();
                            delete this._$selectAllItem
                        }
                        break
                }
            },
            _removeSelection: function() {
                var that = this;
                $.each(this._dataAdapter.getData(), function(_, node) {
                    if (!that._hasChildren(node))
                        return;
                    that._dataAdapter.toggleSelection(node.internalFields.key, false, true)
                })
            },
            _optionChanged: function(args) {
                var name = args.name,
                    value = args.value,
                    previousValue = args.previousValue;
                switch (name) {
                    case"showCheckBoxes":
                        this.option("showCheckBoxesMode", value ? "normal" : "none");
                        break;
                    case"selectAllEnabled":
                        this.option("showCheckBoxesMode", value ? "selectAll" : "normal");
                        break;
                    case"selectAllText":
                        if (this._$selectAllItem)
                            this._$selectAllItem.dxCheckBox("instance").option("text", value);
                        break;
                    case"showCheckBoxesMode":
                        this._checkBoxModeChange(value, previousValue);
                        break;
                    case"scrollDirection":
                        this._scrollableContainer.option("direction", value);
                        break;
                    case"items":
                        delete this._$selectAllItem;
                        this.callBase(args);
                        break;
                    case"hasItemsExpr":
                        this._initAccessors();
                        this.repaint();
                        break;
                    case"dataStructure":
                    case"rootValue":
                    case"searchValue":
                        if ((!value.length || args.value < args.previousValue) && this.option("showCheckBoxesMode") !== "none")
                            this._removeSelection();
                        this._initDataAdapter();
                        this.repaint();
                        break;
                    case"selectNodesRecursive":
                    case"expandNodesRecursive":
                    case"onItemSelected":
                    case"onItemExpanded":
                    case"onItemCollapsed":
                    case"expandAllEnabled":
                    case"animationEnabled":
                    case"virtualModeEnabled":
                        break;
                    default:
                        this.callBase(args)
                }
            },
            _initDataSource: function() {
                this.callBase();
                if (this._isVirtualMode()) {
                    this._customerFilters = this._dataSource.filter();
                    var filter = this._combineFilter([this.option("parentIdExpr"), this.option("rootValue")]);
                    this._dataSource.filter(filter)
                }
            },
            _combineFilter: function(filter) {
                if (!this._customerFilters || !this._customerFilters.length)
                    return filter;
                var resultFilter = [];
                resultFilter.push(this._customerFilters, filter);
                return resultFilter
            },
            _dataSourceLoadErrorHandler: function() {
                this._renderEmptyMessage()
            },
            _init: function() {
                this.callBase();
                this._initStoreChangeHandlers();
                this._initCheckBoxesMode()
            },
            _initStoreChangeHandlers: function() {
                if (this.option("dataStructure") !== "plain")
                    return;
                var that = this;
                this._dataSource && this._dataSource.store().on("inserted", function(newItem) {
                    that.option().items = that.option("items").concat(newItem);
                    that._dataAdapter.addItem(newItem);
                    if (!that._isFiltered(newItem))
                        return;
                    that._updateLevel(that._parentIdGetter(newItem))
                }).on("removed", function(removedKey) {
                    var node = that._dataAdapter.getNodeByKey(removedKey);
                    that.option("items")[that._dataAdapter.getIndexByKey(node.internalFields.key)] = 0;
                    that._markChildrenItemsToRemove(node);
                    that._removeItems();
                    that._dataAdapter.removeItem(removedKey);
                    that._updateLevel(that._parentIdGetter(node))
                })
            },
            _markChildrenItemsToRemove: function(node) {
                var that = this,
                    keys = node.internalFields.childrenKeys;
                $.each(keys, function(_, key) {
                    that.option("items")[that._dataAdapter.getIndexByKey(key)] = 0;
                    that._markChildrenItemsToRemove(that._dataAdapter.getNodeByKey(key))
                })
            },
            _removeItems: function() {
                var that = this,
                    counter = 0,
                    items = $.extend(true, [], this.option("items"));
                $.each(items, function(index, item) {
                    if (!item) {
                        that.option("items").splice(index - counter, 1);
                        counter++
                    }
                })
            },
            _isFiltered: function(item) {
                var value = this.option("searchValue"),
                    reg = new RegExp(value, 'i');
                return reg.test(this._displayGetter(item))
            },
            _updateLevel: function(parentId) {
                var $container = this._getContainerByParentKey(parentId);
                this._renderItems($container, this._dataAdapter.getChildrenNodes(parentId))
            },
            _getOldContainer: function($itemElement) {
                return $itemElement.length ? $itemElement.find(" > ." + NODE_CONTAINER_CLASS) : this._scrollableContainer.content().children()
            },
            _getContainerByParentKey: function(parentId) {
                var $container,
                    $itemElement = this._findItemElementByIndex(parentId).parent();
                this._getOldContainer($itemElement).remove();
                $container = this._renderNodeContainer($itemElement);
                this._isRootLevel(parentId) && this._scrollableContainer.content().append($container);
                return $container
            },
            _isRootLevel: function(parentId) {
                return parentId === this.option("rootValue")
            },
            _getAccessors: function() {
                return ["key", "display", "selected", "expanded", "items", "parentId", "disabled", "hasItems"]
            },
            _getDataAdapterOptions: function() {
                return {
                        rootValue: this.option("rootValue"),
                        recursiveSelection: this.option("selectNodesRecursive"),
                        recursiveExpansion: this.option("expandNodesRecursive"),
                        searchValue: this.option("searchValue"),
                        dataType: this.option("dataStructure")
                    }
            },
            _render: function() {
                this._attachPointerEventHandler();
                this.callBase();
                this.setAria("role", "tree")
            },
            _attachPointerEventHandler: function() {
                var that = this,
                    event = pointerEvents.down;
                this.element().off(event).on(event, function(e) {
                    var $target = $(e.target).closest(that._activeStateUnit);
                    if (!$target.length)
                        e.preventDefault()
                })
            },
            _renderContentImpl: function() {
                if (!this.option("items").length)
                    return;
                var $nodeContainer = this._renderNodeContainer();
                this._renderScrollableContainer();
                this._scrollableContainer.content().append($nodeContainer);
                this._renderItems($nodeContainer, this._dataAdapter.getRootNodes());
                if (this._selectAllEnabled())
                    this._renderSelectAllItem($nodeContainer)
            },
            _isVirtualMode: function() {
                return this.option("virtualModeEnabled") && this._isDataStructurePlain() && this.option("dataSource")
            },
            _isDataStructurePlain: function() {
                return this.option("dataStructure") === "plain"
            },
            _fireContentReadyAction: function() {
                this.callBase();
                if (this._scrollableContainer && this._scrollableContainer.content().height() > this.element().height()) {
                    this._scrollableContainer.update();
                    scrollableContainerUpdatedOnInit()
                }
            },
            _renderScrollableContainer: function() {
                this._scrollableContainer = this._createComponent($("<div>").appendTo(this.element()), "dxScrollable", {
                    direction: this.option("scrollDirection"),
                    useKeyboard: false
                })
            },
            _renderNodeContainer: function($parent) {
                var $container = $("<ul>").addClass(NODE_CONTAINER_CLASS);
                this.setAria("role", "group", $container);
                if ($parent && $parent.length) {
                    var itemData = this._getItemData($parent.find("> ." + ITEM_CLASS));
                    if (this._expandedGetter(itemData))
                        $container.addClass(OPENED_NODE_CONTAINER_CLASS);
                    $container.appendTo($parent)
                }
                return $container
            },
            _createDOMElement: function($nodeContainer, node) {
                var $node = $("<li>").addClass(NODE_CLASS).attr(DATA_ITEM_ID, normalizeKey(node.internalFields.key)).prependTo($nodeContainer);
                this.setAria({
                    role: "treeitem",
                    label: this._displayGetter(node.internalFields.item) || "",
                    expanded: node.internalFields.expanded || false,
                    level: this._getLevel($nodeContainer)
                }, $node);
                return $node
            },
            _getLevel: function($nodeContainer) {
                var parent = $nodeContainer.parent();
                return parent.hasClass("dx-scrollable-content") ? 1 : parseInt(parent.attr("aria-level")) + 1
            },
            _showCheckboxes: function() {
                return this.option("showCheckBoxesMode") !== "none"
            },
            _selectAllEnabled: function() {
                return this.option("showCheckBoxesMode") === "selectAll"
            },
            _initCheckBoxesMode: function() {
                if (this._showCheckboxes())
                    return;
                this._suppressDeprecatedWarnings();
                var showCheckboxes = this.option("showCheckBoxes"),
                    selectAllEnabled = this.option("selectAllEnabled");
                this._resumeDeprecatedWarnings();
                this.option("showCheckBoxesMode", showCheckboxes ? selectAllEnabled ? "selectAll" : "normal" : "none")
            },
            _renderItems: function($nodeContainer, nodes) {
                var length = nodes.length - 1;
                this._firstSelected = false;
                for (var i = length; i >= 0; i--)
                    this._renderItem(nodes[i], $nodeContainer);
                this._renderFocusTarget();
                delete this._firstSelected
            },
            _renderItem: function(node, $nodeContainer) {
                var $node = this._createDOMElement($nodeContainer, node),
                    nodeData = node.internalFields;
                this._showCheckboxes() && this._renderCheckBox($node, node);
                var $item = this.callBase(nodeData.key, nodeData.item, $node);
                this._firstSelected && this._isSingleSelection() || this._toggleSelectedClass($node, nodeData.selected);
                if (nodeData.selected)
                    this._firstSelected = true;
                this._attachDblclickToItem($item, node);
                if (nodeData.item.visible !== false)
                    this._renderChildren($node, node)
            },
            _renderChildren: function($node, node) {
                if (this._hasChildren(node)) {
                    this._renderToggleItemVisibilityIcon($node, node);
                    this._renderSublevel($node, node)
                }
                else
                    this._addLeafClass($node)
            },
            _hasChildren: function(node) {
                if (this._isVirtualMode())
                    return this._hasItemsGetter(node.internalFields.item) !== false;
                return this.callBase(node)
            },
            _renderSublevel: function($node, node) {
                var $nestedNodeContainer = this._renderNodeContainer($node, node);
                if (!node.internalFields.expanded)
                    return;
                var childrenNodes = this._getChildNodes(node);
                this._renderItems($nestedNodeContainer, childrenNodes);
                $nestedNodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS)
            },
            _executeItemRenderAction: function(index, itemData, itemElement) {
                var node = this._dataAdapter.getNodeByItem(itemData);
                this._getItemRenderAction()({
                    itemElement: itemElement,
                    itemIndex: index,
                    itemData: itemData,
                    node: node
                })
            },
            _addLeafClass: function($node) {
                $node.addClass(IS_LEAF)
            },
            _attachDblclickToItem: function($item, node) {
                var that = this,
                    eventName = eventUtils.addNamespace(DBLCLICK_EVENT_NAME, that.NAME);
                $item.off(eventName).on(eventName, function(e) {
                    that._toggleExpandedState(node, undefined, e)
                })
            },
            _getNodeByItemElement: function(itemElement) {
                if (commonUtils.isPrimitive(itemElement))
                    return this._dataAdapter.getNodeByKey(itemElement);
                itemElement = $(itemElement).get(0);
                if (!itemElement)
                    return null;
                if (itemElement.nodeType)
                    return this._dataAdapter.getNodeByItem(this._getItemData(itemElement));
                return this._dataAdapter.getNodeByItem(itemElement)
            },
            _convertItemElementToNode: function(itemElement) {
                if (!itemElement || itemElement.internalFields)
                    return itemElement;
                return this._getNodeByItemElement(itemElement)
            },
            _toggleExpandedState: function(itemElement, state, e) {
                var node = this._convertItemElementToNode(itemElement);
                if (this._isVirtualMode()) {
                    var $node = this._getNodeElementById(node.internalFields.key);
                    this._hasChildren(node) && this._createLoadIndicator($node)
                }
                var currentState = node.internalFields.expanded;
                if (node.internalFields.disabled || commonUtils.isDefined(currentState) && currentState === state)
                    return;
                if (!commonUtils.isDefined(state))
                    state = !currentState;
                this._dataAdapter.toggleExpansion(node.internalFields.key, state);
                node.internalFields.expanded = state;
                if (this._isVirtualMode() && !this._hasChildren(node))
                    return;
                this._updateExpandedItemsUI(node, state, e)
            },
            _createLoadIndicator: function($node) {
                var $icon = $node.find(">." + TOGGLE_ITEM_VISIBILITY_CLASS),
                    $nodeContainer = $node.find(" > ." + NODE_CONTAINER_CLASS);
                if ($icon.hasClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS) || $nodeContainer.not(":empty").length)
                    return;
                this._createComponent("<div>", "dxLoadIndicator", {}).element().appendTo($node);
                $icon.hide()
            },
            _renderToggleItemVisibilityIcon: function($node, node) {
                var $icon = $("<div>").addClass(TOGGLE_ITEM_VISIBILITY_CLASS).appendTo($node);
                if (node.internalFields.expanded && !this._isVirtualMode()) {
                    $icon.addClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS);
                    $node.parent().addClass(OPENED_NODE_CONTAINER_CLASS)
                }
                if (node.internalFields.disabled)
                    $icon.addClass(DISABLED_STATE_CLASS);
                this._renderToggleItemVisibilityIconClick($icon, node)
            },
            _renderToggleItemVisibilityIconClick: function($icon, node) {
                var eventName = eventUtils.addNamespace("dxclick", this.NAME),
                    that = this;
                $icon.off(eventName).on(eventName, function(e) {
                    that._toggleExpandedState(node, undefined, e)
                })
            },
            _updateExpandedItemsUI: function(node, state, e) {
                var that = this,
                    $node = that._getNodeElementById(node.internalFields.key),
                    $icon = $node.find(">." + TOGGLE_ITEM_VISIBILITY_CLASS),
                    $nodeContainer;
                $icon.toggleClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS, state);
                if (!state) {
                    that._updateExpandedItem(node, state, e);
                    return
                }
                $nodeContainer = $node.find(" > ." + NODE_CONTAINER_CLASS);
                that._renderNestedItems($nodeContainer).done(function(itemsLoaded) {
                    itemsLoaded && that._updateExpandedItem(node, state, e)
                })
            },
            _updateExpandedItem: function(node, state, e) {
                var $node = this._getNodeElementById(node.internalFields.key),
                    $nodeContainer = $node.find(" > ." + NODE_CONTAINER_CLASS);
                this._animateNodeContainer($nodeContainer, state);
                this.setAria("expanded", state, $node);
                this._fireExpandedStateUpdatedEvt(state, node, e)
            },
            _animateNodeContainer: function($nodeContainer, state) {
                var nodeHeight = $nodeContainer.height();
                DX.fx.stop($nodeContainer, true);
                DX.fx.animate($nodeContainer, {
                    type: "custom",
                    duration: this.option("animationEnabled") ? 400 : 0,
                    from: {"max-height": state ? 0 : nodeHeight},
                    to: {"max-height": state ? nodeHeight : 0},
                    start: function() {
                        $nodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS)
                    },
                    complete: $.proxy(function() {
                        $nodeContainer.css("max-height", "none");
                        $nodeContainer.toggleClass(OPENED_NODE_CONTAINER_CLASS, state);
                        this._scrollableContainer.update()
                    }, this)
                })
            },
            _fireExpandedStateUpdatedEvt: function(isExpanded, node, e) {
                var optionName = isExpanded ? "onItemExpanded" : "onItemCollapsed",
                    target;
                if (!this.option(optionName))
                    return;
                if (commonUtils.isDefined(e))
                    this._itemJQueryEventHandler(e, optionName, {node: this._dataAdapter.getPublicNode(node)});
                else {
                    target = this._getNodeElementById(node.internalFields.key);
                    this._itemEventHandler(target, optionName, {
                        jQueryEvent: e,
                        node: this._dataAdapter.getPublicNode(node)
                    })
                }
            },
            _renderNestedItems: function($container) {
                var deferred = $.Deferred();
                if (!$container.is(":empty"))
                    return deferred.resolve(true).promise();
                if (this._isVirtualMode())
                    this._renderVirtualNodes($container).done(function(items) {
                        deferred.resolve(items && items.length)
                    });
                else {
                    var itemElement = $container.parent().find(">." + ITEM_CLASS),
                        node = this._getNodeByItemElement(itemElement),
                        nestedItems = this._getChildNodes(node);
                    this._renderItems($container, nestedItems);
                    deferred.resolve(true)
                }
                return deferred.promise()
            },
            _renderVirtualNodes: function($container) {
                var $node = $container.parent(),
                    node = this._getNodeByItemElement($node.find(">." + ITEM_CLASS)),
                    that = this;
                this._dataSource.filter(this._combineFilter([this.option("parentIdExpr"), node.internalFields.key]));
                return this._dataSource.load().done(function(data) {
                        var virtualNodes = that._getVirtualNodes(data);
                        that._renderItems($container, virtualNodes);
                        if (virtualNodes.length && !node.internalFields.selected) {
                            var firstItemKey = virtualNodes[0].internalFields.key,
                                $firstChild = that._getNodeElementById(firstItemKey);
                            that._updateParentsState(that._dataAdapter.getNodeByKey(firstItemKey), $firstChild)
                        }
                        that._normalizeIconState($node, virtualNodes.length)
                    })
            },
            _getVirtualNodes: function(items) {
                var that = this,
                    virtualNodes = [];
                $.each(items, function(_, item) {
                    var virtualNode = that._dataAdapter.getNodeByItem(item);
                    virtualNode && virtualNodes.push(virtualNode)
                });
                return virtualNodes
            },
            _normalizeIconState: function($node, hasNewItems) {
                var $loadIndicator = $node.find(".dx-loadindicator"),
                    $icon;
                $loadIndicator.dxLoadIndicator("instance").option("visible", false);
                if (hasNewItems) {
                    $icon = $node.find("." + TOGGLE_ITEM_VISIBILITY_CLASS);
                    $icon.show();
                    return
                }
                $node.find("." + TOGGLE_ITEM_VISIBILITY_CLASS).removeClass(TOGGLE_ITEM_VISIBILITY_CLASS);
                $node.addClass(IS_LEAF)
            },
            _dataSourceChangedHandler: function(newItems) {
                var isInArray = $.inArray(newItems[0], this.option("items")) + 1;
                if (!this._initialized || !this._isVirtualMode() || isInArray) {
                    this.option("items", newItems);
                    return
                }
                this.option().items = this.option("items").concat(newItems);
                this._initDataAdapter();
                if (!this._contentAlreadyRendered)
                    this._renderContent()
            },
            _renderContent: function() {
                this._renderEmptyMessage();
                var items = this.option("items");
                if (!items || !items.length)
                    return;
                if (items.length)
                    this._contentAlreadyRendered = true;
                this.callBase()
            },
            _renderSelectAllItem: function($container) {
                $container = $container || this.element().find("." + NODE_CONTAINER_CLASS).first();
                this._$selectAllItem = $("<div>").addClass(SELECT_ALL_ITEM_CLASS);
                var value = this._dataAdapter.isAllSelected();
                this._createComponent(this._$selectAllItem, CheckBox, {
                    value: value,
                    text: this.option("selectAllText"),
                    onValueChanged: $.proxy(this._toggleSelectAll, this)
                });
                this._toggleSelectedClass(this._$selectAllItem, value);
                $container.before(this._$selectAllItem)
            },
            _toggleSelectAll: function(args) {
                this._dataAdapter.toggleSelectAll(args.value);
                this._updateCheckBoxes();
                this._toggleSelectedClass(this.element().find("." + NODE_CLASS), args.value);
                this._fireSelectionChanged()
            },
            _renderCheckBox: function($node, node) {
                var checkBoxValue = node.internalFields.selected;
                $node.addClass(ITEM_WITH_CHECKBOX_CLASS);
                this.setAria("selected", checkBoxValue, $node);
                var $checkbox = $("<div>").appendTo($node);
                this._createComponent($checkbox, CheckBox, {
                    value: checkBoxValue,
                    onValueChanged: $.proxy(this._changeCheckboxValue, this),
                    focusStateEnabled: false,
                    disabled: this._disabledGetter(node)
                });
                if (checkBoxValue !== false)
                    this._toggleSelectedClass($node, checkBoxValue);
                this._attachCheckboxClick($checkbox, node)
            },
            _toggleSelectedClass: function($node, value) {
                $node.toggleClass(SELECTED_ITEM_CLASS, !!value)
            },
            _attachCheckboxClick: function($checkbox, node) {
                var eventName = eventUtils.addNamespace("dxclick", this.NAME);
                var handleItemSelected = function(e) {
                        this._itemJQueryEventHandler(e, "onItemSelected", {node: this._dataAdapter.getPublicNode(node)})
                    };
                $checkbox.off(eventName).on(eventName, $.proxy(handleItemSelected, this))
            },
            _changeCheckboxValue: function(e) {
                var $node = e.element.parent("." + NODE_CLASS),
                    item = this._getItemData($node.find("> ." + ITEM_CLASS)),
                    node = this._dataAdapter.getNodeByItem(item),
                    value = e.value;
                this._toggleSelectedClass($node, value);
                this.setAria("selected", value, $node);
                if (node.internalFields.selected === value)
                    return;
                this._dataAdapter.toggleSelection(node.internalFields.key, value);
                if (e.jQueryEvent && !this.option("selectNodesRecursive"))
                    this._fireSelectionChanged();
                if (this._selectAllEnabled())
                    this._$selectAllItem.dxCheckBox("instance").option("value", this._dataAdapter.isAllSelected());
                else if (!e.jQueryEvent || !this.option("selectNodesRecursive"))
                    return;
                this._updateCheckBoxes();
                this._fireSelectionChanged()
            },
            _isSingleSelection: function() {
                return !this._showCheckboxes() || this.option("selectionMode") === "single"
            },
            _updateItemSelection: function(value, itemElement, suppressOnSelectionChanged, $node) {
                var node = this._getNodeByItemElement(itemElement);
                if (!node || node.internalFields.selected === value)
                    return;
                if (this._isSingleSelection())
                    this._toggleSelectAll({value: false});
                if (!$node) {
                    var $tmpNode = this._getNodeElementById(node.internalFields.key);
                    $node = $tmpNode.length && $tmpNode
                }
                if (this._showCheckboxes()) {
                    if ($node)
                        this._getCheckBoxInstance($node).option("value", value);
                    else
                        this._dataAdapter.toggleSelection(node.internalFields.key, value);
                    this._updateCheckBoxes()
                }
                else {
                    this._dataAdapter.toggleSelection(node.internalFields.key, value);
                    $node && this._toggleSelectedClass($node, value)
                }
                this._fireOnSelectedEvent(node);
                this._fireSelectionChanged()
            },
            _fireOnSelectedEvent: function(node) {
                var handler = this.option("onItemSelected");
                if (handler)
                    handler.call(this, {
                        itemData: node.internalFields.item,
                        node: this._dataAdapter.getPublicNode(node)
                    })
            },
            _getCheckBoxInstance: function($node) {
                return $node.find("> .dx-checkbox").dxCheckBox("instance")
            },
            _updateCheckBoxes: function() {
                if (!this._showCheckboxes())
                    return;
                var that = this;
                $.each(this._dataAdapter.getData(), function(_, node) {
                    var $node = that._getNodeElementById(node.internalFields.key);
                    if (!$node.length)
                        return;
                    var checkbox = that._getCheckBoxInstance($node),
                        nodeSelection = node.internalFields.selected;
                    if (checkbox.option("value") === nodeSelection)
                        return;
                    checkbox.option("value", nodeSelection);
                    that._toggleSelectedClass($node, nodeSelection)
                })
            },
            _updateParentsState: function(node, $node) {
                var parentNode = this._dataAdapter.getNodeByKey(node.internalFields.parentKey),
                    parentValue,
                    $parentNode;
                if ($node && this._showCheckboxes()) {
                    parentValue = parentNode.internalFields.selected;
                    $parentNode = $($node.parents("." + NODE_CLASS)[0]);
                    this._getCheckBoxInstance($parentNode).option("value", parentValue);
                    this._toggleSelectedClass($parentNode, parentValue)
                }
                if (parentNode.parentId)
                    this._updateParentsState(parentNode, $parentNode)
            },
            _itemEventHandlerImpl: function(initiator, action, actionArgs) {
                var $itemElement = $(initiator).closest("." + NODE_CLASS).find("> ." + ITEM_CLASS);
                return action($.extend(this._extendActionArgs($itemElement), actionArgs))
            },
            _itemContextMenuHandler: function(e) {
                this._createEventHandler("onItemContextMenu", e)
            },
            _itemHoldHandler: function(e) {
                this._createEventHandler("onItemHold", e)
            },
            _createEventHandler: function(eventName, e) {
                var itemData = this._getItemData(e.currentTarget),
                    node = this._dataAdapter.getNodeByItem(itemData);
                this._itemJQueryEventHandler(e, eventName, {node: this._dataAdapter.getPublicNode(node)})
            },
            _itemClass: function() {
                return ITEM_CLASS
            },
            _itemDataKey: function() {
                return ITEM_DATA_KEY
            },
            _selectionEnabled: function() {
                return true
            },
            _attachClickEvent: function() {
                var that = this,
                    itemSelector = that._itemSelector(),
                    eventName = eventUtils.addNamespace("dxclick", that.NAME),
                    pointerDownEvent = eventUtils.addNamespace(pointerEvents.down, this.NAME);
                that._itemContainer().off(eventName, itemSelector).off(pointerDownEvent, itemSelector).on(eventName, itemSelector, function(e) {
                    that._itemClickHandler(e, $(this))
                }).on(pointerDownEvent, itemSelector, $.proxy(this._itemPointerDownHandler, this))
            },
            _itemClickHandler: function(e, $item) {
                var itemData = this._getItemData($item),
                    node = this._dataAdapter.getNodeByItem(itemData);
                this._itemJQueryEventHandler(e, "onItemClick", {node: this._dataAdapter.getPublicNode(node)})
            },
            _updateSelectionToFirstItem: function($items, startIndex) {
                var itemIndex = startIndex;
                while (itemIndex >= 0) {
                    var $item = $($items[itemIndex]);
                    this._updateItemSelection(true, $item.find("." + ITEM_CLASS).get(0), true, $item);
                    itemIndex--
                }
            },
            _updateSelectionToLastItem: function($items, startIndex) {
                var itemIndex = startIndex,
                    length = $items.length;
                while (itemIndex < length) {
                    var $item = $($items[itemIndex]);
                    this._updateItemSelection(true, $item.find("." + ITEM_CLASS).get(0), true, $item);
                    itemIndex++
                }
            },
            _focusInHandler: function(e) {
                var currentTarget = e.currentTarget,
                    focusTargets = this._focusTarget();
                if ($.inArray(currentTarget, focusTargets) !== -1)
                    this._toggleFocusClass(true, currentTarget);
                if (this.option("focusedElement")) {
                    this._setFocusedItem(this.option("focusedElement"));
                    return
                }
                var $activeItem = this._getActiveItem();
                this.option("focusedElement", $activeItem.closest("." + NODE_CLASS))
            },
            _setFocusedItem: function($target) {
                if (!$target || !$target.length)
                    return;
                if (!$target.children().hasClass(DISABLED_STATE_CLASS))
                    this.callBase($target);
                this._scrollableContainer.scrollToElement($target.find("." + ITEM_CLASS).first())
            },
            _itemPointerDownHandler: function(e) {
                if (!this.option("focusStateEnabled"))
                    return;
                var $target = $(e.target).closest("." + NODE_CLASS),
                    itemElement;
                if (!$target.hasClass(NODE_CLASS))
                    return;
                itemElement = $target.hasClass(DISABLED_STATE_CLASS) ? null : $target;
                this.option("focusedElement", itemElement)
            },
            _findNonDisabledNodes: function($nodes) {
                return $nodes.not(function() {
                        return $(this).find(">." + ITEM_CLASS).hasClass(DISABLED_STATE_CLASS)
                    })
            },
            _moveFocus: function(location, e) {
                var FOCUS_UP = "up",
                    FOCUS_DOWN = "down",
                    FOCUS_FIRST = "first",
                    FOCUS_LAST = "last",
                    FOCUS_LEFT = this.option("rtlEnabled") ? "right" : "left",
                    FOCUS_RIGHT = this.option("rtlEnabled") ? "left" : "right";
                this.element().find("." + NODE_CONTAINER_CLASS).each(function() {
                    DX.fx.stop(this, true)
                });
                var $items = this._findNonDisabledNodes(this._nodeElements());
                if (!$items || !$items.length)
                    return;
                switch (location) {
                    case FOCUS_UP:
                        var $prevItem = this._prevItem($items);
                        this.option("focusedElement", $prevItem);
                        if (e.shiftKey && this._showCheckboxes())
                            this._updateItemSelection(true, $prevItem.find("." + ITEM_CLASS).get(0), true, $prevItem);
                        break;
                    case FOCUS_DOWN:
                        var $nextItem = this._nextItem($items);
                        this.option("focusedElement", $nextItem);
                        if (e.shiftKey && this._showCheckboxes())
                            this._updateItemSelection(true, $nextItem.find("." + ITEM_CLASS).get(0), true, $nextItem);
                        break;
                    case FOCUS_FIRST:
                        var $firstItem = $items.first();
                        if (e.shiftKey && this._showCheckboxes())
                            this._updateSelectionToFirstItem($items, $items.index(this._prevItem($items)));
                        this.option("focusedElement", $firstItem);
                        break;
                    case FOCUS_LAST:
                        var $lastItem = $items.last();
                        if (e.shiftKey && this._showCheckboxes())
                            this._updateSelectionToLastItem($items, $items.index(this._nextItem($items)));
                        this.option("focusedElement", $lastItem);
                        break;
                    case FOCUS_RIGHT:
                        this._expandFocusedContainer();
                        break;
                    case FOCUS_LEFT:
                        this._collapseFocusedContainer();
                        break;
                    default:
                        this.callBase.apply(this, arguments);
                        return
                }
            },
            _nodeElements: function() {
                return this.element().find("." + NODE_CLASS).not(":hidden")
            },
            _expandFocusedContainer: function() {
                var $focusedItem = this.option("focusedElement");
                if (!$focusedItem || $focusedItem.hasClass(IS_LEAF))
                    return;
                var $node = $focusedItem.find("." + NODE_CONTAINER_CLASS).eq(0);
                if ($node.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
                    this.option("focusedElement", this._nextItem(this._findNonDisabledNodes(this._nodeElements())));
                    return
                }
                var node = this._getNodeByItemElement($focusedItem.find(">." + ITEM_CLASS));
                this._toggleExpandedState(node, true)
            },
            _getClosestNonDisabledNode: function($node) {
                do
                    $node = $node.parent().closest("." + NODE_CLASS);
                while ($node.children(".dx-treeview-item.dx-state-disabled").length);
                return $node
            },
            _collapseFocusedContainer: function() {
                var $focusedItem = this.option("focusedElement");
                if (!$focusedItem)
                    return;
                var nodeElement = $focusedItem.find("." + NODE_CONTAINER_CLASS).eq(0);
                if (!$focusedItem.hasClass(IS_LEAF) && nodeElement.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
                    var node = this._getNodeByItemElement($focusedItem.find(">." + ITEM_CLASS));
                    this._toggleExpandedState(node, false)
                }
                else {
                    var collapsedNode = this._getClosestNonDisabledNode($focusedItem);
                    if (collapsedNode.length)
                        this.option("focusedElement", collapsedNode)
                }
            },
            updateDimensions: function() {
                var that = this,
                    deferred = $.Deferred();
                if (that._scrollableContainer)
                    that._scrollableContainer.update().done(function() {
                        deferred.resolveWith(that)
                    });
                else
                    deferred.resolveWith(that);
                return deferred.promise()
            },
            selectItem: function(itemElement) {
                this._updateItemSelection(true, itemElement)
            },
            unselectItem: function(itemElement) {
                this._updateItemSelection(false, itemElement)
            },
            expandItem: function(itemElement) {
                this._toggleExpandedState(itemElement, true)
            },
            collapseItem: function(itemElement) {
                this._toggleExpandedState(itemElement, false)
            },
            getNodes: function() {
                return this._dataAdapter.getTreeNodes()
            },
            selectAll: function() {
                if (this._selectAllEnabled())
                    this._$selectAllItem.dxCheckBox("instance").option("value", true);
                else
                    this._toggleSelectAll({value: true})
            },
            unselectAll: function() {
                if (this._selectAllEnabled())
                    this._$selectAllItem.dxCheckBox("instance").option("value", false);
                else
                    this._toggleSelectAll({value: false})
            }
        }));
        ui.dxTreeView.__internals = {
            WIDGET_CLASS: WIDGET_CLASS,
            NODE_CONTAINER_CLASS: NODE_CONTAINER_CLASS,
            OPENED_NODE_CONTAINER_CLASS: OPENED_NODE_CONTAINER_CLASS,
            ITEM_CLASS: ITEM_CLASS,
            NODE_CLASS: NODE_CLASS,
            ITEM_WITH_CHECKBOX_CLASS: ITEM_WITH_CHECKBOX_CLASS,
            ITEM_DATA_KEY: ITEM_DATA_KEY,
            IS_LEAF: IS_LEAF,
            TOGGLE_ITEM_VISIBILITY_CLASS: TOGGLE_ITEM_VISIBILITY_CLASS,
            TOGGLE_ITEM_VISIBILITY_OPENED_CLASS: TOGGLE_ITEM_VISIBILITY_OPENED_CLASS,
            SELECT_ALL_ITEM_CLASS: SELECT_ALL_ITEM_CLASS,
            scrollableContainerUpdatedOnInitAccessor: function(value) {
                if (value)
                    scrollableContainerUpdatedOnInit = value;
                return scrollableContainerUpdatedOnInit
            }
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.sortable.js */
    (function($, DX) {
        var ui = DX.ui,
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            addNamespace = eventUtils.addNamespace,
            registerComponent = DX.require("/componentRegistrator"),
            DOMComponent = DX.require("/domComponent");
        var SORTABLE_NAMESPACE = "dxSortable",
            SORTABLE_CLASS = "dx-sortable";
        function elementHasPoint(element, x, y) {
            var $item = $(element),
                offset = $item.offset();
            if (x >= offset.left && x <= offset.left + $item.outerWidth(true))
                if (y >= offset.top && y <= offset.top + $item.outerHeight(true))
                    return true
        }
        function getItemsOffset($elements) {
            var result = [];
            $.each($elements, function() {
                var item = this;
                if ($(item).is(':visible'))
                    result.push({
                        pos: $(item).offset().top + $(item).outerHeight(true) / 2,
                        item: $(item)
                    })
            });
            return result
        }
        registerComponent("dxSortable", ui, DOMComponent.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        onChanged: null,
                        onDragging: null,
                        itemRender: null,
                        groupSelector: null,
                        itemSelector: ".dx-sort-item",
                        itemContainerSelector: ".dx-sortable",
                        sourceClass: "dx-drag-source",
                        dragClass: "dx-drag",
                        targetClass: "dx-drag-target"
                    })
            },
            _renderItem: function($sourceItem, target) {
                var itemRender = this.option("itemRender"),
                    $item;
                if (itemRender)
                    $item = itemRender($sourceItem, target);
                else {
                    $item = $sourceItem.clone();
                    $item.css({
                        width: $sourceItem.width(),
                        height: $sourceItem.height()
                    })
                }
                return $item
            },
            _attachEventHandlers: function() {
                var that = this,
                    itemSelector = that.option("itemSelector"),
                    itemContainerSelector = that.option("itemContainerSelector"),
                    groupSelector = that.option("groupSelector"),
                    sourceClass = that.option("sourceClass"),
                    dragClass = that.option("dragClass"),
                    targetClass = that.option("targetClass"),
                    onDragging = that.option("onDragging"),
                    $sourceItem,
                    sourceIndex,
                    $targetItem,
                    $targetGroup,
                    startPosition,
                    $draggable,
                    $sourceGroup,
                    element = that.element(),
                    $groups,
                    i;
                element.off(addNamespace("dxdragstart dxdrag dxdragend dxdragenter dxdragleave dxdrop", SORTABLE_NAMESPACE)).on(addNamespace("dxdragstart", SORTABLE_NAMESPACE), itemSelector, function(e) {
                    $sourceItem = $(e.currentTarget);
                    startPosition = $sourceItem.offset();
                    startPosition.top -= element.offset().top;
                    startPosition.left -= element.offset().left;
                    sourceIndex = $sourceItem.index();
                    $groups = groupSelector ? element.find(groupSelector) : element;
                    $sourceGroup = $sourceItem.closest(groupSelector).attr("group");
                    $draggable = that._renderItem($sourceItem, 'drag').appendTo(element);
                    $targetItem = that._renderItem($sourceItem, 'target');
                    $draggable.addClass(dragClass);
                    $sourceItem.addClass(sourceClass);
                    $targetItem.addClass(targetClass)
                }).on(addNamespace("dxdrag", SORTABLE_NAMESPACE), function(e) {
                    var draggingArgs,
                        $item,
                        $itemContainer,
                        $items,
                        itemsOffset = [];
                    if (!$sourceItem)
                        return;
                    $draggable.css({
                        top: startPosition.top + e.offset.y,
                        left: startPosition.left + e.offset.x
                    });
                    $targetGroup && $targetGroup.removeClass(targetClass);
                    $targetGroup = undefined;
                    $.each($groups, function() {
                        if (elementHasPoint(this, e.pageX, e.pageY)) {
                            $targetGroup = $(this);
                            return false
                        }
                    });
                    if ($targetGroup) {
                        draggingArgs = {
                            sourceGroup: $sourceGroup,
                            sourceIndex: sourceIndex,
                            sourceElement: $sourceItem,
                            targetGroup: $targetGroup.attr("group"),
                            targetIndex: $targetItem.index()
                        };
                        onDragging && onDragging(draggingArgs)
                    }
                    if (draggingArgs && draggingArgs.cancel)
                        $targetGroup = undefined;
                    if ($targetGroup) {
                        $targetGroup.addClass(targetClass);
                        $itemContainer = $targetGroup.find(itemContainerSelector);
                        $items = $itemContainer.find(itemSelector);
                        itemsOffset = getItemsOffset($items);
                        for (i = 0; i < itemsOffset.length; i++)
                            if (e.pageY < itemsOffset[i].pos) {
                                $item = itemsOffset[i] && itemsOffset[i].item;
                                break
                            }
                        if ($item)
                            if (!$item.hasClass(sourceClass) && (!$item.prev().hasClass(sourceClass) || !$item.prev().is(":visible")))
                                $targetItem.insertBefore($item);
                            else
                                $targetItem.detach();
                        else if (!($items.last().is(":visible") && $items.last().hasClass(sourceClass)))
                            $targetItem.appendTo($itemContainer)
                    }
                    else
                        $targetItem.detach()
                }).on(addNamespace("dxdragend", SORTABLE_NAMESPACE), function() {
                    var onChanged = that.option("onChanged"),
                        changedArgs,
                        sourceGroup;
                    if ($sourceItem) {
                        if ($targetGroup) {
                            $targetGroup.removeClass(targetClass);
                            sourceGroup = $sourceItem.closest(groupSelector).attr("group");
                            changedArgs = {
                                sourceGroup: sourceGroup,
                                sourceIndex: sourceIndex,
                                sourceElement: $sourceItem,
                                targetGroup: $targetGroup.attr("group"),
                                targetIndex: $targetItem.index(),
                                removeSourceElement: true
                            };
                            if (sourceGroup !== changedArgs.targetGroup || $targetItem.parent().length) {
                                onChanged && onChanged(changedArgs);
                                if (changedArgs.removeSourceElement)
                                    $sourceItem.remove()
                            }
                        }
                        $sourceItem.removeClass(sourceClass);
                        $draggable.remove();
                        $sourceItem = null;
                        $targetItem.removeClass(targetClass);
                        $targetItem = null
                    }
                })
            },
            _init: function() {
                this.callBase();
                this._attachEventHandlers()
            },
            _render: function() {
                this.callBase();
                this.element().addClass(SORTABLE_CLASS)
            },
            _optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"onDragging":
                    case"onChanged":
                    case"itemRender":
                    case"groupSelector":
                    case"itemSelector":
                    case"itemContainerSelector":
                    case"sourceClass":
                    case"targetClass":
                    case"dragClass":
                        that._attachEventHandlers();
                        break;
                    default:
                        that.callBase(args)
                }
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.js */
    (function($, DX) {
        var ui = DX.ui,
            stringUtils = DX.require("/utils/utils.string"),
            browser = DX.require("/utils/utils.browser"),
            Class = DX.require("/class"),
            errors = DX.require("/ui/ui.errors"),
            logger = DX.require("/utils/utils.console").logger,
            formatHelper = DX.require("/utils/utils.formatHelper"),
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget");
        var DATAGRID_ROW_SELECTOR = ".dx-row",
            DATAGRID_DEPRECATED_TEMPLATE_WARNING = "Specifying grid templates with the name of a jQuery selector is now deprecated. Instead, use the jQuery object that references this selector.",
            DATE_INTERVAL_SELECTORS = {
                year: function(value) {
                    return value && value.getFullYear()
                },
                month: function(value) {
                    return value && value.getMonth() + 1
                },
                day: function(value) {
                    return value && value.getDate()
                },
                quarter: function(value) {
                    return value && Math.floor(value.getMonth() / 3) + 1
                },
                dayOfWeek: function(value) {
                    return value && value.getDay()
                },
                hour: function(value) {
                    return value && value.getHours()
                },
                minute: function(value) {
                    return value && value.getMinutes()
                },
                second: function(value) {
                    return value && value.getSeconds()
                }
            },
            DEFAULT_DATE_INTERVAL = ["year", "month", "day"];
        var ModuleItem = Class.inherit({
                _endUpdateCore: function(){},
                ctor: function(component) {
                    var that = this;
                    that._updateLockCount = 0;
                    that.component = component;
                    that._actions = {};
                    that._actionConfigs = {};
                    $.each(this.callbackNames() || [], function(index, name) {
                        var flags = that.callbackFlags(name);
                        that[this] = $.Callbacks(flags)
                    })
                },
                init: function(){},
                callbackNames: function(){},
                callbackFlags: function(name){},
                publicMethods: function(){},
                beginUpdate: function() {
                    this._updateLockCount++
                },
                endUpdate: function() {
                    if (this._updateLockCount > 0) {
                        this._updateLockCount--;
                        if (!this._updateLockCount)
                            this._endUpdateCore()
                    }
                },
                option: function(name) {
                    var component = this.component,
                        optionCache = component._optionCache;
                    if (arguments.length === 1 && optionCache) {
                        if (!(name in optionCache))
                            optionCache[name] = component.option(name);
                        return optionCache[name]
                    }
                    return component.option.apply(component, arguments)
                },
                localize: function(name) {
                    var optionCache = this.component._optionCache;
                    if (optionCache) {
                        if (!(name in optionCache))
                            optionCache[name] = Globalize.localize(name);
                        return optionCache[name]
                    }
                    return Globalize.localize(name)
                },
                on: function() {
                    return this.component.on.apply(this.component, arguments)
                },
                off: function() {
                    return this.component.off.apply(this.component, arguments)
                },
                optionChanged: function(args) {
                    if (args.name in this._actions) {
                        this.createAction(args.name, this._actionConfigs[args.name]);
                        args.handled = true
                    }
                },
                getAction: function(actionName) {
                    return this._actions[actionName]
                },
                setAria: function(name, value, $target) {
                    var target = $target.get(0),
                        prefix = name !== "role" && name !== "id" ? "aria-" : "";
                    if (target.setAttribute)
                        target.setAttribute(prefix + name, value);
                    else
                        $target.attr(prefix + name, value)
                },
                _createComponent: function() {
                    return this.component._createComponent.apply(this.component, arguments)
                },
                getController: function(name) {
                    return this.component._controllers[name]
                },
                createAction: function(actionName, config) {
                    var action;
                    if (commonUtils.isFunction(actionName)) {
                        action = this.component._createAction($.proxy(actionName, this), config);
                        return function(e) {
                                action({jQueryEvent: e})
                            }
                    }
                    else {
                        this._actions[actionName] = this.component._createActionByOption(actionName, config);
                        this._actionConfigs[actionName] = config
                    }
                },
                executeAction: function(actionName, options) {
                    var action = this._actions[actionName];
                    return action && action(options)
                },
                dispose: function() {
                    var that = this;
                    $.each(that.callbackNames() || [], function() {
                        that[this].empty()
                    })
                }
            });
        var Controller = ModuleItem;
        var ViewController = Controller.inherit({
                getView: function(name) {
                    return this.component._views[name]
                },
                getViews: function() {
                    return this.component._views
                }
            });
        var View = ModuleItem.inherit({
                _isReady: function() {
                    return this.component.isReady()
                },
                _endUpdateCore: function() {
                    this.callBase();
                    if (!this._isReady() && this._requireReady) {
                        this._requireRender = false;
                        this.component._requireResize = false
                    }
                    if (this._requireRender) {
                        this._requireRender = false;
                        this.render(this._$parent)
                    }
                },
                _invalidate: function(requireResize, requireReady) {
                    this._requireRender = true;
                    this.component._requireResize = this.component._requireResize || requireResize;
                    this._requireReady = this._requireReady || requireReady
                },
                _renderCore: function(options){},
                _resizeCore: function(){},
                _afterRender: function($root){},
                _parentElement: function() {
                    return this._$parent
                },
                ctor: function(component) {
                    this.callBase(component);
                    this.renderCompleted = $.Callbacks();
                    this.resizeCompleted = $.Callbacks()
                },
                element: function() {
                    return this._$element
                },
                isVisible: function() {
                    return true
                },
                getTemplate: function(name) {
                    return this.component._getTemplate(name)
                },
                render: function($parent, options) {
                    var $element = this._$element,
                        isVisible = this.isVisible();
                    this._requireReady = false;
                    if (!$element) {
                        $element = this._$element = $("<div />").appendTo($parent);
                        this._$parent = $parent
                    }
                    $element.toggleClass("dx-hidden", !isVisible);
                    if (isVisible) {
                        this.component._optionCache = {};
                        this._renderCore(options);
                        this.component._optionCache = undefined;
                        this._afterRender($parent);
                        this.renderCompleted.fire()
                    }
                },
                resize: function() {
                    this.isResizing = true;
                    this._resizeCore();
                    this.resizeCompleted.fire();
                    this.isResizing = false
                },
                focus: function() {
                    this.element().focus()
                }
            });
        var processModules = function(that, componentClass) {
                var modules = componentClass.modules,
                    controllerTypes = componentClass.controllerTypes || {},
                    viewTypes = componentClass.viewTypes || {};
                if (!componentClass.controllerTypes) {
                    $.each(modules, function() {
                        var controllers = this.controllers,
                            moduleName = this.name,
                            views = this.views;
                        controllers && $.each(controllers, function(name, type) {
                            if (controllerTypes[name])
                                throw errors.Error("E1001", moduleName, name);
                            else if (!(type && type.subclassOf && type.subclassOf(Controller))) {
                                type.subclassOf(Controller);
                                throw errors.Error("E1002", moduleName, name);
                            }
                            controllerTypes[name] = type
                        });
                        views && $.each(views, function(name, type) {
                            if (viewTypes[name])
                                throw errors.Error("E1003", moduleName, name);
                            else if (!(type && type.subclassOf && type.subclassOf(View)))
                                throw errors.Error("E1004", moduleName, name);
                            viewTypes[name] = type
                        })
                    });
                    $.each(modules, function() {
                        var extenders = this.extenders;
                        if (extenders) {
                            extenders.controllers && $.each(extenders.controllers, function(name, extender) {
                                if (controllerTypes[name])
                                    controllerTypes[name] = controllerTypes[name].inherit(extender)
                            });
                            extenders.views && $.each(extenders.views, function(name, extender) {
                                if (viewTypes[name])
                                    viewTypes[name] = viewTypes[name].inherit(extender)
                            })
                        }
                    });
                    componentClass.controllerTypes = controllerTypes;
                    componentClass.viewTypes = viewTypes
                }
                var registerPublicMethods = function(that, name, moduleItem) {
                        var publicMethods = moduleItem.publicMethods();
                        if (publicMethods)
                            $.each(publicMethods, function(index, methodName) {
                                if (moduleItem[methodName])
                                    if (!that[methodName])
                                        that[methodName] = function() {
                                            return moduleItem[methodName].apply(moduleItem, arguments)
                                        };
                                    else
                                        throw errors.Error("E1005", methodName);
                                else
                                    throw errors.Error("E1006", name, methodName);
                            })
                    };
                var createModuleItems = function(moduleTypes) {
                        var moduleItems = {};
                        $.each(moduleTypes, function(name, moduleType) {
                            var moduleItem = new moduleType(that);
                            moduleItem.name = name;
                            registerPublicMethods(that, name, moduleItem);
                            moduleItems[name] = moduleItem
                        });
                        return moduleItems
                    };
                that._controllers = createModuleItems(controllerTypes);
                that._views = createModuleItems(viewTypes)
            };
        var callModuleItemsMethod = function(that, methodName, args) {
                args = args || [];
                if (that._controllers)
                    $.each(that._controllers, function() {
                        this[methodName] && this[methodName].apply(this, args)
                    });
                if (that._views)
                    $.each(that._views, function() {
                        this[methodName] && this[methodName].apply(this, args)
                    })
            };
        registerComponent("dxDataGrid", ui, Widget.inherit({
            _activeStateUnit: DATAGRID_ROW_SELECTOR,
            _setDefaultOptions: function() {
                var that = this;
                that.callBase();
                $.each(ui.dxDataGrid.modules, function() {
                    if ($.isFunction(this.defaultOptions))
                        that.option(this.defaultOptions())
                })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {
                    "editing.editMode": {
                        since: "15.2",
                        alias: "editing.mode"
                    },
                    "editing.editEnabled": {
                        since: "15.2",
                        alias: "editing.allowUpdating"
                    },
                    "editing.insertEnabled": {
                        since: "15.2",
                        alias: "editing.allowAdding"
                    },
                    "editing.removeEnabled": {
                        since: "15.2",
                        alias: "editing.allowDeleting"
                    }
                })
            },
            _defaultOptionsRules: function() {
                return this.callBase().concat([{
                            device: {platform: "ios"},
                            options: {showRowLines: true}
                        }, {
                            device: function() {
                                return browser.webkit
                            },
                            options: {loadPanel: {animation: {show: {
                                            easing: "cubic-bezier(1, 0, 1, 0)",
                                            duration: 500,
                                            from: {opacity: 0},
                                            to: {opacity: 1}
                                        }}}}
                        }])
            },
            _init: function() {
                var that = this;
                that.callBase();
                processModules(that, ui.dxDataGrid);
                callModuleItemsMethod(that, "init")
            },
            _clean: $.noop,
            _optionChanged: function(args) {
                var that = this;
                callModuleItemsMethod(that, "optionChanged", [args]);
                if (!args.handled)
                    that.callBase(args)
            },
            _dimensionChanged: function() {
                this.updateDimensions(true)
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this.updateDimensions()
            },
            _renderContentImpl: function() {
                var that = this;
                that.getView("gridView").render(that.element())
            },
            _renderContent: function() {
                this._renderContentImpl()
            },
            _getTemplate: function(templateName) {
                var template = templateName;
                if (commonUtils.isString(template) && template[0] === "#") {
                    template = $(templateName);
                    logger.warn(DATAGRID_DEPRECATED_TEMPLATE_WARNING)
                }
                return this.callBase(template)
            },
            _dispose: function() {
                var that = this;
                that.callBase();
                callModuleItemsMethod(that, "dispose")
            },
            isReady: function() {
                return this.getController("data").isReady()
            },
            beginUpdate: function() {
                var that = this;
                that.callBase();
                callModuleItemsMethod(that, "beginUpdate")
            },
            endUpdate: function() {
                var that = this;
                callModuleItemsMethod(that, "endUpdate");
                that.callBase()
            },
            getController: function(name) {
                return this._controllers[name]
            },
            getView: function(name) {
                return this._views[name]
            },
            focus: function(element) {
                this.callBase();
                if (commonUtils.isDefined(element))
                    this.getController("keyboardNavigation").focus(element)
            }
        }));
        var MAX_EQUAL_KEYS_LEVEL = 3;
        $.extend(ui.dxDataGrid, function() {
            var getIntervalSelector = function() {
                    var groupInterval,
                        data = arguments[1],
                        nameIntervalSelector,
                        value = this.calculateCellValue(data);
                    if (!commonUtils.isDefined(value))
                        return null;
                    else if (this.dataType === "date") {
                        nameIntervalSelector = arguments[0];
                        return DATE_INTERVAL_SELECTORS[nameIntervalSelector](value)
                    }
                    else if (this.dataType === "number") {
                        groupInterval = arguments[0];
                        return Math.floor(Number(value) / groupInterval) * groupInterval
                    }
                };
            var getDateValues = function(dateValue) {
                    if (commonUtils.isDate(dateValue))
                        return [dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate(), dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds()];
                    return $.map(("" + dateValue).split("/"), function(value, index) {
                            return index === 1 ? Number(value) - 1 : Number(value)
                        })
                };
            var getFilterExpressionForDate = function(filterValue, selectedFilterOperation, target) {
                    var column = this,
                        selector = getFilterSelector(column, target),
                        dateStart,
                        dateEnd,
                        values = getDateValues(filterValue),
                        dateInterval = ui.dxDataGrid.getGroupInterval(column)[values.length - 1];
                    switch (dateInterval) {
                        case"year":
                            dateStart = new Date(values[0], 0, 1),
                            dateEnd = new Date(values[0] + 1, 0, 1);
                            break;
                        case"month":
                            dateStart = new Date(values[0], values[1], 1),
                            dateEnd = new Date(values[0], values[1] + 1, 1);
                            break;
                        case"quarter":
                            dateStart = new Date(values[0], 3 * values[1], 1),
                            dateEnd = new Date(values[0], 3 * values[1] + 3, 1);
                            break;
                        case"hour":
                            dateStart = new Date(values[0], values[1], values[2], values[3]),
                            dateEnd = new Date(values[0], values[1], values[2], values[3] + 1);
                            break;
                        case"minute":
                            dateStart = new Date(values[0], values[1], values[2], values[3], values[4]),
                            dateEnd = new Date(values[0], values[1], values[2], values[3], values[4] + 1);
                            break;
                        case"second":
                            dateStart = new Date(values[0], values[1], values[2], values[3], values[4], values[5]),
                            dateEnd = new Date(values[0], values[1], values[2], values[3], values[4], values[5] + 1);
                            break;
                        default:
                            dateStart = new Date(values[0], values[1], values[2]),
                            dateEnd = new Date(values[0], values[1], values[2] + 1)
                    }
                    switch (selectedFilterOperation) {
                        case"<":
                            return [selector, "<", dateStart];
                        case"<=":
                            return [selector, "<", dateEnd];
                        case">":
                            return [selector, ">=", dateEnd];
                        case">=":
                            return [selector, ">=", dateStart];
                        case"<>":
                            return [[selector, "<", dateStart], "or", [selector, ">=", dateEnd]];
                        default:
                            return [[selector, ">=", dateStart], "and", [selector, "<", dateEnd]]
                    }
                };
            var getFilterExpressionForNumber = function(filterValue, selectedFilterOperation, target) {
                    var column = this,
                        interval,
                        startFilterValue,
                        endFilterValue,
                        selector = getFilterSelector(column, target),
                        values = ("" + filterValue).split("/"),
                        value = Number(values[values.length - 1]),
                        isExclude = column.filterType === "exclude",
                        groupInterval = ui.dxDataGrid.getGroupInterval(column);
                    if (target === "headerFilter" && groupInterval && commonUtils.isDefined(filterValue)) {
                        interval = groupInterval[values.length - 1];
                        startFilterValue = [selector, isExclude ? "<" : ">=", value];
                        endFilterValue = [selector, isExclude ? ">=" : "<", value + interval];
                        return [startFilterValue, isExclude ? "or" : "and", endFilterValue]
                    }
                    return [selector, selectedFilterOperation || "=", filterValue]
                };
            var getFilterSelector = function(column, target) {
                    var selector = column.dataField || column.selector;
                    if (target === "search")
                        selector = column.displayField || column.calculateDisplayValue || selector;
                    return selector
                };
            var getFilterExpressionByRange = function(filterValue, selectedFilterOperation, target) {
                    var column = this,
                        dataField = column.dataField;
                    if (commonUtils.isArray(filterValue) && commonUtils.isDefined(filterValue[0]) && commonUtils.isDefined(filterValue[1]))
                        return [[dataField, ">=", filterValue[0]], "and", [dataField, "<=", filterValue[1]]]
                };
            return {
                    __internals: {},
                    modules: [],
                    View: View,
                    ViewController: ViewController,
                    Controller: Controller,
                    registerModule: function(name, module) {
                        var modules = this.modules,
                            i;
                        for (i = 0; i < modules.length; i++)
                            if (modules[i].name === name)
                                return;
                        module.name = name;
                        modules.push(module);
                        delete this.controllerTypes,
                        delete this.viewTypes
                    },
                    unregisterModule: function(name) {
                        this.modules = $.grep(this.modules, function(module) {
                            return module.name !== name
                        });
                        delete this.controllerTypes,
                        delete this.viewTypes
                    },
                    processModules: processModules,
                    formatValue: function(value, options) {
                        var valueText = formatHelper.format(value, options.format, options.precision) || value && value.toString() || "",
                            formatObject = {
                                value: value,
                                valueText: options.getDisplayFormat ? options.getDisplayFormat(valueText) : valueText,
                                target: options.target || "row",
                                groupInterval: options.groupInterval
                            };
                        return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText
                    },
                    getDisplayValue: function(column, value, data, rowType) {
                        if (column.displayValueMap && column.displayValueMap[value] !== undefined)
                            return column.displayValueMap[value];
                        else if (column.calculateDisplayValue && data && rowType !== "group")
                            return column.calculateDisplayValue(data);
                        else if (column.lookup)
                            return column.lookup.calculateCellValue(value);
                        return value
                    },
                    getGroupRowSummaryText: function(summaryItems, summaryTexts) {
                        var result = "(",
                            i,
                            summaryItem;
                        for (i = 0; i < summaryItems.length; i++) {
                            summaryItem = summaryItems[i];
                            result += (i > 0 ? ", " : "") + ui.dxDataGrid.getSummaryText(summaryItem, summaryTexts)
                        }
                        return result += ")"
                    },
                    getSummaryText: function(summaryItem, summaryTexts) {
                        var displayFormat = summaryItem.displayFormat || summaryItem.columnCaption && summaryTexts[summaryItem.summaryType + "OtherColumn"] || summaryTexts[summaryItem.summaryType];
                        return this.formatValue(summaryItem.value, {
                                format: summaryItem.valueFormat,
                                precision: summaryItem.precision,
                                getDisplayFormat: function(valueText) {
                                    return displayFormat ? stringUtils.format(displayFormat, valueText, summaryItem.columnCaption) : valueText
                                },
                                customizeText: summaryItem.customizeText
                            })
                    },
                    equalKeys: function(key1, key2, level) {
                        var propertyName,
                            i;
                        level = level || 0;
                        if (level < MAX_EQUAL_KEYS_LEVEL)
                            if (commonUtils.isObject(key1) && commonUtils.isObject(key2)) {
                                for (propertyName in key1)
                                    if (key1.hasOwnProperty(propertyName) && !ui.dxDataGrid.equalKeys(key1[propertyName], key2[propertyName], level + 1))
                                        return false;
                                for (propertyName in key2)
                                    if (!(propertyName in key1))
                                        return false;
                                return true
                            }
                            else if (commonUtils.isArray(key1) && commonUtils.isArray(key2)) {
                                if (key1.length !== key2.length)
                                    return false;
                                for (i = 0; i < key1.length; i++)
                                    if (!ui.dxDataGrid.equalKeys(key1[i], key2[i], level + 1))
                                        return false;
                                return true
                            }
                            else if (commonUtils.isDate(key1) && commonUtils.isDate(key2))
                                return key1.getTime() === key2.getTime();
                            else
                                return key1 === key2;
                        return true
                    },
                    getIndexByKey: function(key, items, keyName) {
                        var index = -1,
                            item;
                        if (commonUtils.isArray(items)) {
                            keyName = arguments.length <= 2 && "key" || keyName;
                            for (var i = 0; i < items.length; i++) {
                                item = commonUtils.isDefined(keyName) ? items[i][keyName] : items[i];
                                if (ui.dxDataGrid.equalKeys(key, item)) {
                                    index = i;
                                    break
                                }
                            }
                        }
                        return index
                    },
                    normalizeSortingInfo: function(sort) {
                        sort = sort || [];
                        var result,
                            i;
                        result = DX.data.utils.normalizeSortingInfo(sort);
                        for (i = 0; i < sort.length; i++) {
                            if (sort && sort[i] && sort[i].isExpanded !== undefined)
                                result[i].isExpanded = sort[i].isExpanded;
                            if (sort && sort[i] && sort[i].groupInterval !== undefined)
                                result[i].groupInterval = sort[i].groupInterval
                        }
                        return result
                    },
                    getFormatByDataType: function(dataType) {
                        switch (dataType) {
                            case"date":
                                return "shortDate"
                        }
                    },
                    defaultCalculateFilterExpression: function(filterValue, selectedFilterOperation, target) {
                        var column = this,
                            selector = getFilterSelector(column, target),
                            isSearchByDisplayValue = column.calculateDisplayValue && target === "search",
                            dataType = isSearchByDisplayValue && column.lookup && column.lookup.dataType || column.dataType,
                            filter = null;
                        if (target === "headerFilter" && filterValue === null) {
                            filter = [selector, selectedFilterOperation || "=", null];
                            if (dataType === "string")
                                filter = [filter, selectedFilterOperation === "=" ? "or" : "and", [selector, selectedFilterOperation || "=", ""]]
                        }
                        else if (dataType === "string" && (!column.lookup || isSearchByDisplayValue))
                            filter = [selector, selectedFilterOperation || "contains", filterValue];
                        else if (selectedFilterOperation === "between")
                            return getFilterExpressionByRange.apply(column, arguments);
                        else if (dataType === "date" && commonUtils.isDefined(filterValue))
                            return getFilterExpressionForDate.apply(column, arguments);
                        else if (dataType === "number")
                            return getFilterExpressionForNumber.apply(column, arguments);
                        else if (dataType !== "object")
                            filter = [selector, selectedFilterOperation || "=", filterValue];
                        return filter
                    },
                    getGroupDataSourceParameters: function(column, remoteGrouping) {
                        var result = [],
                            dataField = column.dataField || column.name,
                            groupInterval = this.getGroupInterval(column);
                        if (column.calculateGroupValue)
                            return remoteGrouping ? [{
                                        selector: column.calculateGroupValue,
                                        isExpanded: false
                                    }] : $.proxy(column.calculateGroupValue, column);
                        if (groupInterval) {
                            $.each(groupInterval, function(index, interval) {
                                result.push(remoteGrouping ? {
                                    selector: dataField,
                                    groupInterval: interval,
                                    isExpanded: false
                                } : $.proxy(getIntervalSelector, column, interval))
                            });
                            return result
                        }
                        return remoteGrouping ? [{
                                    selector: dataField,
                                    isExpanded: false
                                }] : function(data) {
                                var result = column.calculateCellValue(data);
                                if (result === undefined || result === "")
                                    result = null;
                                return result
                            }
                    },
                    getGroupInterval: function(column) {
                        var index,
                            result = [],
                            dateIntervals = ["year", "month", "day", "hour", "minute", "second"],
                            groupInterval = column.headerFilter && column.headerFilter.groupInterval,
                            interval = groupInterval === "quarter" ? "month" : groupInterval;
                        if (column.dataType === "date") {
                            result = DEFAULT_DATE_INTERVAL;
                            index = $.inArray(interval, dateIntervals);
                            if (index >= 0) {
                                result = dateIntervals.slice(0, index);
                                result.push(groupInterval);
                                return result
                            }
                            return result
                        }
                        else if (commonUtils.isDefined(groupInterval))
                            return commonUtils.isArray(groupInterval) ? groupInterval : [groupInterval]
                    },
                    getKeyHash: function(key) {
                        if (commonUtils.isObject(key) || commonUtils.isArray(key))
                            try {
                                return JSON.stringify(key)
                            }
                            catch(e) {
                                return key
                            }
                        return key
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.stateStoring.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            errors = DX.require("/ui/ui.errors"),
            browser = DX.require("/utils/utils.browser"),
            storageUtils = DX.require("/utils/utils.storage"),
            commonUtils = DX.require("/utils/utils.common");
        var DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;
        var parseDates = function(state) {
                if (!state)
                    return;
                $.each(state, function(key, value) {
                    var date;
                    if ($.isPlainObject(value) || $.isArray(value))
                        parseDates(value);
                    else if (typeof value === "string") {
                        date = DATE_REGEX.exec(value);
                        if (date)
                            state[key] = new Date(Date.UTC(+date[1], +date[2] - 1, +date[3], +date[4], +date[5], +date[6]))
                    }
                })
            };
        var processLoadState = function(that) {
                var columnsController = that.getController("columns"),
                    selectionController = that.getController("selection"),
                    exportController = that.getController("export"),
                    dataController = that.getController("data"),
                    pagerView = that.getView("pagerView");
                if (columnsController)
                    columnsController.columnsChanged.add(function() {
                        var columnsState = columnsController.getUserState(),
                            columnStateHash = dataGrid.getKeyHash(columnsState),
                            currentColumnStateHash = dataGrid.getKeyHash(that._state.columns);
                        if (!dataGrid.equalKeys(currentColumnStateHash, columnStateHash)) {
                            $.extend(that._state, {columns: columnsState});
                            that.isEnabled() && that.save()
                        }
                    });
                if (selectionController)
                    selectionController.selectionChanged.add(function(keys) {
                        $.extend(that._state, {selectedRowKeys: keys});
                        that.isEnabled() && that.save()
                    });
                if (dataController) {
                    that._initialPageSize = that.option("paging.pageSize");
                    dataController.changed.add(function() {
                        $.extend(that._state, {
                            searchText: that.option("searchPanel.text"),
                            pageIndex: dataController.pageIndex(),
                            pageSize: dataController.pageSize(),
                            allowedPageSizes: pagerView ? pagerView.getPageSizes() : undefined
                        });
                        that.isEnabled() && that.save()
                    })
                }
                if (exportController)
                    exportController.selectionOnlyChanged.add(function() {
                        $.extend(that._state, {exportSelectionOnly: exportController.selectionOnly()});
                        that.isEnabled() && that.save()
                    })
            };
        var applyState = function(that, state) {
                var allowedPageSizes = state.allowedPageSizes,
                    searchText = state.searchText,
                    selectedRowKeys = state.selectedRowKeys,
                    exportController = that.getController("export"),
                    columnsController = that.getController("columns"),
                    scrollingMode = that.option("scrolling.mode");
                that.component.beginUpdate();
                if (columnsController)
                    columnsController.setUserState(state.columns);
                if (exportController)
                    exportController.selectionOnly(state.exportSelectionOnly);
                that.option("selectedRowKeys", selectedRowKeys || []);
                if (allowedPageSizes && that.option("pager.allowedPageSizes") === "auto")
                    that.option("pager").allowedPageSizes = allowedPageSizes;
                that.option("searchPanel.text", searchText || "");
                that.option("paging.pageSize", scrollingMode !== "virtual" && scrollingMode !== "infinite" && state.pageSize ? state.pageSize : that._initialPageSize);
                that.option("paging.pageIndex", state.pageIndex || 0);
                that.component.endUpdate()
            };
        dataGrid.StateStoringController = dataGrid.ViewController.inherit(function() {
            var getStorage = function(options) {
                    var storage = options.type === "sessionStorage" ? storageUtils.sessionStorage() : localStorage;
                    if (!storage)
                        if (window.location.protocol === "file:" && browser.msie)
                            throw new Error("E1038");
                        else
                            throw new Error("E1007");
                    return storage
                };
            var getUniqueStorageKey = function(options) {
                    return commonUtils.isDefined(options.storageKey) ? options.storageKey : "storage"
                };
            return {
                    _loadState: function() {
                        var options = this.option("stateStoring");
                        if (options.type === "custom")
                            return options.customLoad && options.customLoad();
                        try {
                            return JSON.parse(getStorage(options).getItem(getUniqueStorageKey(options)))
                        }
                        catch(e) {
                            errors.log(e.message)
                        }
                    },
                    _saveState: function(state) {
                        var options = this.option("stateStoring");
                        if (options.type === "custom") {
                            options.customSave && options.customSave(state);
                            return
                        }
                        try {
                            getStorage(options).setItem(getUniqueStorageKey(options), JSON.stringify(state))
                        }
                        catch(e) {}
                    },
                    publicMethods: function() {
                        return ["state"]
                    },
                    isEnabled: function() {
                        return this.option("stateStoring.enabled")
                    },
                    init: function() {
                        var that = this;
                        that._state = {};
                        that._isLoaded = false;
                        that._isLoading = false;
                        that._windowUnloadHandler = function() {
                            if (that._savingTimeoutID !== undefined)
                                that._saveState(that.state())
                        },
                        $(window).on("unload", that._windowUnloadHandler);
                        return that
                    },
                    isLoaded: function() {
                        return this._isLoaded
                    },
                    isLoading: function() {
                        return this._isLoading
                    },
                    load: function() {
                        var that = this,
                            loadResult;
                        that._isLoading = true;
                        loadResult = that._loadState();
                        if (!loadResult || !$.isFunction(loadResult.done))
                            loadResult = $.Deferred().resolve(loadResult);
                        loadResult.done(function(state) {
                            that._isLoaded = true;
                            that._isLoading = false;
                            that.state(state)
                        });
                        return loadResult
                    },
                    state: function(state) {
                        var that = this;
                        if (!arguments.length)
                            return $.extend(true, {}, that._state);
                        else {
                            that._state = $.extend({}, state);
                            parseDates(that._state)
                        }
                    },
                    save: function() {
                        var that = this;
                        clearTimeout(that._savingTimeoutID);
                        that._savingTimeoutID = setTimeout(function() {
                            that._saveState(that.state());
                            that._savingTimeoutID = undefined
                        }, that.option("stateStoring.savingTimeout"))
                    },
                    optionChanged: function(args) {
                        var that = this;
                        switch (args.name) {
                            case"stateStoring":
                                if (that.isEnabled() && that.isLoaded())
                                    that.load();
                                args.handled = true;
                                break;
                            default:
                                that.callBase(args)
                        }
                    },
                    dispose: function() {
                        clearTimeout(this._savingTimeoutID);
                        $(window).off("unload", this._windowUnloadHandler)
                    }
                }
        }());
        dataGrid.registerModule("stateStoring", {
            defaultOptions: function() {
                return {stateStoring: {
                            enabled: false,
                            storageKey: null,
                            type: "localStorage",
                            customLoad: null,
                            customSave: null,
                            savingTimeout: 2000
                        }}
            },
            controllers: {stateStoring: ui.dxDataGrid.StateStoringController},
            extenders: {controllers: {
                    stateStoring: {
                        init: function() {
                            this.callBase.apply(this, arguments);
                            processLoadState(this)
                        },
                        state: function(state) {
                            var result = this.callBase.apply(this, arguments);
                            if (state !== undefined)
                                applyState(this, $.extend({}, state));
                            return result
                        }
                    },
                    columns: {getVisibleColumns: function() {
                            var visibleColumns = this.callBase(),
                                stateStoringController = this.getController("stateStoring");
                            return stateStoringController.isEnabled() && !stateStoringController.isLoaded() ? [] : visibleColumns
                        }},
                    data: {
                        _refreshDataSource: function() {
                            var that = this,
                                callBase = that.callBase,
                                stateStoringController = that.getController("stateStoring");
                            if (stateStoringController.isEnabled() && !stateStoringController.isLoaded()) {
                                clearTimeout(that._restoreStateTimeoutID);
                                that._restoreStateTimeoutID = setTimeout(function() {
                                    stateStoringController.load().always(function() {
                                        that._restoreStateTimeoutID = null;
                                        callBase.call(that)
                                    })
                                })
                            }
                            else if (!that._restoreStateTimeoutID)
                                callBase.call(that)
                        },
                        isLoading: function() {
                            var that = this,
                                stateStoringController = that.getController("stateStoring");
                            return this.callBase() || stateStoringController.isLoading()
                        },
                        dispose: function() {
                            clearTimeout(this._restoreStateTimeoutID);
                            this.callBase()
                        }
                    }
                }}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnsController.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            errors = DX.require("/ui/ui.errors"),
            dataGrid = ui.dxDataGrid,
            normalizeSortingInfo = dataGrid.normalizeSortingInfo,
            normalizeIndexes = DX.require("/utils/utils.array").normalizeIndexes,
            objectUtils = DX.require("/utils/utils.object"),
            inflector = DX.require("/utils/utils.inflector"),
            dateUtils = DX.require("/utils/utils.date"),
            commonUtils = DX.require("/utils/utils.common"),
            knockoutUtils = DX.require("/utils/utils.knockout"),
            dataUtils = DX.data.utils,
            isDefined = commonUtils.isDefined;
        var USER_STATE_FIELD_NAMES_15_1 = ["filterValues", "filterType", "fixed", "fixedPosition"],
            USER_STATE_FIELD_NAMES = ["visibleIndex", "dataField", "name", "dataType", "width", "visible", "sortOrder", "sortIndex", "groupIndex", "filterValue", "selectedFilterOperation"].concat(USER_STATE_FIELD_NAMES_15_1),
            DATAGRID_COMMAND_EXPAND_CLASS = "dx-command-expand";
        dataGrid.checkChanges = function(changes, changeNames) {
            var changesWithChangeNamesCount = 0,
                i;
            for (i = 0; i < changeNames.length; i++)
                if (changes[changeNames[i]])
                    changesWithChangeNamesCount++;
            return changes.length && changes.length === changesWithChangeNamesCount
        };
        var ColumnsController = dataGrid.Controller.inherit(function() {
                var DEFAULT_COLUMN_OPTIONS = {
                        visible: true,
                        showInColumnChooser: true
                    },
                    DATATYPE_OPERATIONS = {
                        number: ["=", "<>", "<", ">", "<=", ">=", "between"],
                        string: ["contains", "notcontains", "startswith", "endswith", "=", "<>"],
                        date: ["=", "<>", "<", ">", "<=", ">=", "between"]
                    },
                    COLUMN_INDEX_OPTIONS = {
                        visibleIndex: true,
                        groupIndex: true,
                        grouped: true,
                        sortIndex: true,
                        sortOrder: true
                    },
                    GROUP_LOCATION = "group",
                    COLUMN_CHOOSER_LOCATION = "columnChooser";
                var createColumn = function(that, columnOptions, userStateColumnOptions) {
                        var commonColumnOptions,
                            calculatedColumnOptions;
                        if (columnOptions) {
                            if (commonUtils.isString(columnOptions))
                                columnOptions = {dataField: columnOptions};
                            if (columnOptions.command)
                                return $.extend(true, {}, columnOptions);
                            else {
                                commonColumnOptions = that.getCommonSettings();
                                if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField)
                                    columnOptions = $.extend({}, columnOptions, {dataField: userStateColumnOptions.dataField});
                                calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions);
                                return $.extend(true, {}, DEFAULT_COLUMN_OPTIONS, commonColumnOptions, calculatedColumnOptions, columnOptions, {selector: null})
                            }
                        }
                    };
                var createColumnsFromOptions = function(that, columnsOptions) {
                        var result = [];
                        if (columnsOptions)
                            $.each(columnsOptions, function(index, columnOptions) {
                                var userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[index]) && that._columnsUserState[index],
                                    column = createColumn(that, columnOptions, userStateColumnOptions);
                                if (column)
                                    result.push(column)
                            });
                        return result
                    };
                var getValueDataType = function(value) {
                        var dataType = $.type(value);
                        if (dataType !== "string" && dataType !== "boolean" && dataType !== "number" && dataType !== "date" && dataType !== "object")
                            dataType = undefined;
                        return dataType
                    };
                var getSerializationFormat = function(dataType, value) {
                        switch (dataType) {
                            case"date":
                                return dateUtils.getDateSerializationFormat(value);
                            case"number":
                                if (commonUtils.isString(value))
                                    return "string"
                        }
                    };
                var updateSerializers = function(options, dataType) {
                        if (!options.deserializeValue) {
                            if (dataType === "date") {
                                options.deserializeValue = function(value) {
                                    return dateUtils.deserializeDate(value, this.serializationFormat)
                                };
                                options.serializeValue = function(value) {
                                    return dateUtils.serializeDate(value, this.serializationFormat)
                                }
                            }
                            if (dataType === "number") {
                                options.deserializeValue = function(value) {
                                    return commonUtils.isDefined(value) ? Number(value) : value
                                };
                                options.serializeValue = function(value) {
                                    return commonUtils.isDefined(value) && this.serializationFormat === "string" ? value.toString() : value
                                }
                            }
                        }
                    };
                var getAlignmentByDataType = function(dataType, isRTL) {
                        switch (dataType) {
                            case"number":
                                return "right";
                            case"boolean":
                                return "center";
                            default:
                                return commonUtils.getDefaultAlignment(isRTL)
                        }
                    };
                var getCustomizeTextByDataType = function(dataType) {
                        if (dataType === "boolean")
                            return function(e) {
                                    if (e.value === true)
                                        return this.trueText || "true";
                                    else if (e.value === false)
                                        return this.falseText || "false";
                                    else
                                        return e.valueText || ""
                                }
                    };
                var createColumnsFromDataSource = function(that, dataSource) {
                        var firstItems = getFirstItems(dataSource),
                            fieldName,
                            processedFields = {},
                            i,
                            result = [];
                        for (i = 0; i < firstItems.length; i++)
                            if (firstItems[i])
                                for (fieldName in firstItems[i])
                                    processedFields[fieldName] = true;
                        for (fieldName in processedFields)
                            if (fieldName.indexOf("__") !== 0) {
                                var column = createColumn(that, fieldName);
                                result.push(column)
                            }
                        return result
                    };
                var equalSortParameters = dataGrid.equalSortParameters = function(sortParameters1, sortParameters2, ignoreIsExpanded) {
                        var i;
                        sortParameters1 = normalizeSortingInfo(sortParameters1);
                        sortParameters2 = normalizeSortingInfo(sortParameters2);
                        if ($.isArray(sortParameters1) && $.isArray(sortParameters2)) {
                            if (sortParameters1.length !== sortParameters2.length)
                                return false;
                            else
                                for (i = 0; i < sortParameters1.length; i++)
                                    if (sortParameters1[i].selector !== sortParameters2[i].selector || sortParameters1[i].desc !== sortParameters2[i].desc || sortParameters1[i].groupInterval !== sortParameters2[i].groupInterval || !ignoreIsExpanded && Boolean(sortParameters1[i].isExpanded) !== Boolean(sortParameters2[i].isExpanded))
                                        return false;
                            return true
                        }
                        else
                            return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length)
                    };
                var equalFilterParameters = dataGrid.equalFilterParameters = function(filter1, filter2) {
                        var i;
                        if ($.isArray(filter1) && $.isArray(filter2)) {
                            if (filter1.length !== filter2.length)
                                return false;
                            else
                                for (i = 0; i < filter1.length; i++)
                                    if (!equalFilterParameters(filter1[i], filter2[i]))
                                        return false;
                            return true
                        }
                        else if ($.isFunction(filter1) && filter1.columnIndex >= 0 && $.isFunction(filter2) && filter2.columnIndex >= 0)
                            return filter1.columnIndex === filter2.columnIndex;
                        else
                            return dataUtils.toComparable(filter1) === dataUtils.toComparable(filter2)
                    };
                var getFirstItems = function(dataSource) {
                        var groupsCount,
                            items = [];
                        var getFirstItemsCore = function(items, groupsCount) {
                                var i,
                                    childItems;
                                if (!items || !groupsCount)
                                    return items;
                                for (i = 0; i < items.length; i++) {
                                    childItems = getFirstItemsCore(items[i].items || items[i].collapsedItems, groupsCount - 1);
                                    if (childItems && childItems.length)
                                        return childItems
                                }
                            };
                        if (dataSource && dataSource.items().length > 0) {
                            groupsCount = normalizeSortingInfo(dataSource.group()).length;
                            items = getFirstItemsCore(dataSource.items(), groupsCount) || []
                        }
                        return items
                    };
                var updateColumnIndexes = function(that) {
                        $.each(that._columns, function(index, column) {
                            column.index = index
                        });
                        $.each(that._commandColumns, function(index, column) {
                            column.index = -(index + 1)
                        })
                    };
                var updateColumnGroupIndexes = function(that, currentColumn) {
                        normalizeIndexes(that._columns, "groupIndex", currentColumn, function(column) {
                            var grouped = column.grouped;
                            delete column.grouped;
                            return grouped
                        })
                    };
                var updateColumnSortIndexes = function(that, currentColumn) {
                        $.each(that._columns, function(index, column) {
                            if (isDefined(column.sortIndex) && !isSortOrderValid(column.sortOrder))
                                delete column.sortIndex
                        });
                        normalizeIndexes(that._columns, "sortIndex", currentColumn, function(column) {
                            return !isDefined(column.groupIndex) && isSortOrderValid(column.sortOrder)
                        })
                    };
                var updateColumnVisibleIndexes = function(that, currentColumn) {
                        normalizeIndexes(that._columns, "visibleIndex", currentColumn)
                    };
                var getColumnIndexByVisibleIndex = function(that, visibleIndex, location) {
                        var columns = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getChooserColumns() : that.getVisibleColumns(),
                            column = columns[visibleIndex];
                        return column && isDefined(column.index) ? column.index : -1
                    };
                var moveColumnToGroup = function(that, column, groupIndex) {
                        var groupColumns = that.getGroupColumns(),
                            i;
                        if (groupIndex >= 0) {
                            for (i = 0; i < groupColumns.length; i++)
                                if (groupColumns[i].groupIndex >= groupIndex)
                                    groupColumns[i].groupIndex++
                        }
                        else {
                            groupIndex = 0;
                            for (i = 0; i < groupColumns.length; i++)
                                groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1)
                        }
                        column.groupIndex = groupIndex
                    };
                var checkUserStateColumn = function(column, userStateColumn) {
                        return column && userStateColumn && userStateColumn.name === column.name && (userStateColumn.dataField === column.dataField || column.name)
                    };
                var applyUserState = function(that) {
                        var columnsUserState = that._columnsUserState,
                            ignoreColumnOptionNames = that._ignoreColumnOptionNames || [],
                            columns = that._columns,
                            columnCountById = {},
                            resultColumns = [],
                            column,
                            userStateColumnIndex,
                            i;
                        function applyFieldsState(column, userStateColumn) {
                            var fieldName;
                            if (!userStateColumn)
                                return;
                            for (var index = 0; index < USER_STATE_FIELD_NAMES.length; index++) {
                                fieldName = USER_STATE_FIELD_NAMES[index];
                                if ($.inArray(fieldName, ignoreColumnOptionNames) >= 0)
                                    continue;
                                if (fieldName === "dataType")
                                    column[fieldName] = column[fieldName] || userStateColumn[fieldName];
                                else if ($.inArray(fieldName, USER_STATE_FIELD_NAMES_15_1) >= 0) {
                                    if (fieldName in userStateColumn)
                                        column[fieldName] = userStateColumn[fieldName]
                                }
                                else
                                    column[fieldName] = userStateColumn[fieldName]
                            }
                        }
                        function findUserStateColumn(columnsUserState, column, columnIndex) {
                            var id = column.name || column.dataField,
                                count = columnCountById[id] || 0;
                            for (var j = 0; j < columnsUserState.length; j++)
                                if (checkUserStateColumn(column, columnsUserState[j]))
                                    if (count)
                                        count--;
                                    else {
                                        columnCountById[id] = columnCountById[id] || 0;
                                        columnCountById[id]++;
                                        return j
                                    }
                            return -1
                        }
                        if (columnsUserState) {
                            for (i = 0; i < columns.length; i++) {
                                column = columns[i];
                                userStateColumnIndex = findUserStateColumn(columnsUserState, column, i);
                                column = $.extend({}, column);
                                applyFieldsState(column, columnsUserState[userStateColumnIndex]);
                                if (userStateColumnIndex >= 0 && isDefined(columnsUserState[userStateColumnIndex].initialIndex))
                                    resultColumns[userStateColumnIndex] = column;
                                else
                                    resultColumns.push(column)
                            }
                            assignColumns(that, resultColumns)
                        }
                    };
                var updateIndexes = function(that, column) {
                        updateColumnIndexes(that);
                        updateColumnGroupIndexes(that, column);
                        updateColumnSortIndexes(that, column);
                        updateColumnVisibleIndexes(that, column)
                    };
                var assignColumns = function(that, columns) {
                        that._columns = columns;
                        that._visibleColumns = undefined;
                        that.updateColumnDataTypes()
                    };
                var updateColumnChanges = function(that, changeType, optionName, columnIndex) {
                        var columnChanges = that._columnChanges || {
                                optionNames: {length: 0},
                                changeTypes: {length: 0},
                                columnIndex: columnIndex
                            };
                        optionName = optionName || "all";
                        var changeTypes = columnChanges.changeTypes;
                        if (changeType && !changeTypes[changeType]) {
                            changeTypes[changeType] = true;
                            changeTypes.length++
                        }
                        var optionNames = columnChanges.optionNames;
                        if (optionName && !optionNames[optionName]) {
                            optionNames[optionName] = true;
                            optionNames.length++
                        }
                        if (columnIndex === undefined || columnIndex !== columnChanges.columnIndex)
                            delete columnChanges.columnIndex;
                        that._columnChanges = columnChanges;
                        that._visibleColumns = undefined
                    };
                var fireColumnsChanged = function(that) {
                        var onColumnsChanging = that.option("onColumnsChanging"),
                            columnChanges = that._columnChanges;
                        if (that.isInitialized() && !that._updateLockCount && columnChanges) {
                            if (onColumnsChanging) {
                                that._updateLockCount++;
                                onColumnsChanging($.extend({component: that.component}, columnChanges));
                                that._updateLockCount--
                            }
                            that._columnChanges = undefined;
                            if (columnChanges.optionNames && (columnChanges.optionNames.dataField || columnChanges.optionNames.lookup))
                                that.reinit();
                            else {
                                that.columnsChanged.firing = true;
                                that.columnsChanged.fire(columnChanges);
                                that.columnsChanged.firing = false
                            }
                        }
                    };
                var columnOptionCore = function(that, column, optionName, value, notFireEvent) {
                        var optionGetter = dataUtils.compileGetter(optionName),
                            columnIndex = column.index,
                            optionSetter,
                            columns,
                            changeType;
                        if (arguments.length === 3)
                            return optionGetter(column, {functionsAsIs: true});
                        if (optionGetter(column, {functionsAsIs: true}) !== value) {
                            if (optionName === "groupIndex")
                                changeType = "grouping";
                            else if (optionName === "sortIndex" || optionName === "sortOrder")
                                changeType = "sorting";
                            else
                                changeType = "columns";
                            optionSetter = dataUtils.compileSetter(optionName);
                            optionSetter(column, value, {functionsAsIs: true});
                            if (!notFireEvent) {
                                if ($.inArray(optionName, USER_STATE_FIELD_NAMES) < 0 && optionName !== "visibleWidth") {
                                    columns = that.option("columns");
                                    column = columns && columns[columnIndex];
                                    if (commonUtils.isString(column))
                                        column = columns[columnIndex] = {dataField: column};
                                    if (column)
                                        optionSetter(column, value, {functionsAsIs: true})
                                }
                                updateColumnChanges(that, changeType, optionName, columnIndex)
                            }
                        }
                    };
                var isSortOrderValid = function(sortOrder) {
                        return sortOrder === "asc" || sortOrder === "desc"
                    };
                var addExpandColumn = function(that) {
                        that.addCommandColumn({
                            command: "expand",
                            width: "auto",
                            cssClass: DATAGRID_COMMAND_EXPAND_CLASS,
                            allowEditing: false,
                            allowGrouping: false,
                            allowSorting: false,
                            allowResizing: false,
                            allowReordering: false,
                            allowHiding: false
                        })
                    };
                var defaultSetCellValue = function(data, value) {
                        var path = this.dataField.split("."),
                            dotCount = path.length - 1,
                            name,
                            i;
                        if (this.serializeValue)
                            value = this.serializeValue(value);
                        for (i = 0; i < dotCount; i++) {
                            name = path[i];
                            data = data[name] = data[name] || {}
                        }
                        data[path[dotCount]] = value
                    };
                return {
                        _endUpdateCore: function() {
                            fireColumnsChanged(this)
                        },
                        init: function() {
                            var that = this,
                                columns = that.option("columns");
                            that._commandColumns = that._commandColumns || [];
                            that._columns = that._columns || [];
                            addExpandColumn(that);
                            that._isColumnsFromOptions = !!columns;
                            if (that._isColumnsFromOptions) {
                                assignColumns(that, columns ? createColumnsFromOptions(that, columns) : []);
                                applyUserState(that)
                            }
                            else
                                assignColumns(that, that._columnsUserState ? createColumnsFromOptions(that, that._columnsUserState) : that._columns);
                            if (that._dataSourceApplied)
                                that.applyDataSource(that._dataSource, true);
                            else
                                updateIndexes(that)
                        },
                        callbackNames: function() {
                            return ["columnsChanged"]
                        },
                        optionChanged: function(args) {
                            switch (args.name) {
                                case"adaptColumnWidthByRatio":
                                    args.handled = true;
                                    break;
                                case"columns":
                                    args.handled = true;
                                    this._columnsUserState = null;
                                    this._ignoreColumnOptionNames = null;
                                    this.init();
                                    break;
                                case"commonColumnSettings":
                                case"columnAutoWidth":
                                case"allowColumnResizing":
                                case"allowColumnReordering":
                                case"columnFixing":
                                case"grouping":
                                case"groupPanel":
                                case"regenerateColumnsByVisibleItems":
                                case"customizeColumns":
                                case"editing":
                                    args.handled = true;
                                    this.reinit();
                                    break;
                                case"rtlEnabled":
                                    this.reinit();
                                    break;
                                default:
                                    this.callBase(args)
                            }
                        },
                        publicMethods: function() {
                            return ["addColumn", "deleteColumn", "columnOption", "columnCount", "clearSorting", "clearGrouping"]
                        },
                        applyDataSource: function(dataSource, forceApplying) {
                            var that = this,
                                isDataSourceLoaded = dataSource && dataSource.isLoaded();
                            that._dataSource = dataSource;
                            if (!that._dataSourceApplied || that._dataSourceColumnsCount === 0 || forceApplying || that.option("regenerateColumnsByVisibleItems"))
                                if (isDataSourceLoaded) {
                                    if (!that._isColumnsFromOptions) {
                                        assignColumns(that, createColumnsFromDataSource(that, dataSource));
                                        that._dataSourceColumnsCount = that._columns.length;
                                        applyUserState(that)
                                    }
                                    return that.updateColumns(dataSource, forceApplying)
                                }
                        },
                        reset: function() {
                            this._dataSourceApplied = false;
                            this._dataSourceColumnsCount = undefined;
                            this.reinit()
                        },
                        reinit: function() {
                            this._columnsUserState = this.getUserState();
                            this._ignoreColumnOptionNames = null;
                            this.init()
                        },
                        isInitialized: function() {
                            return !!this._columns.length || !!this.option("columns")
                        },
                        isDataSourceApplied: function() {
                            return this._dataSourceApplied
                        },
                        getCommonSettings: function() {
                            var commonColumnSettings = this.option("commonColumnSettings") || {},
                                groupingOptions = this.option("grouping") || {},
                                groupPanelOptions = this.option("groupPanel") || {};
                            return $.extend({
                                    allowFixing: this.option("columnFixing.enabled"),
                                    allowResizing: this.option("allowColumnResizing"),
                                    allowReordering: this.option("allowColumnReordering"),
                                    autoExpandGroup: groupingOptions.autoExpandAll,
                                    allowCollapsing: groupingOptions.allowCollapsing,
                                    allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible
                                }, commonColumnSettings)
                        },
                        isColumnOptionUsed: function(optionName) {
                            for (var i = 0; i < this._columns.length; i++)
                                if (this._columns[i][optionName])
                                    return true
                        },
                        isAllDataTypesDefined: function() {
                            var columns = this._columns,
                                i;
                            if (!columns.length)
                                return false;
                            for (i = 0; i < columns.length; i++)
                                if (!columns[i].dataType)
                                    return false;
                            return true
                        },
                        getColumns: function() {
                            return this._columns
                        },
                        getGroupColumns: function() {
                            var result = [];
                            $.each(this._columns, function() {
                                var column = this;
                                if (isDefined(column.groupIndex))
                                    result[column.groupIndex] = column
                            });
                            return result
                        },
                        getVisibleColumns: function() {
                            this._visibleColumns = this._visibleColumns || this._getVisibleColumnsCore();
                            return this._visibleColumns
                        },
                        getFixedColumns: function() {
                            var that = this,
                                result = [],
                                isColumnFixing = that._isColumnFixing(),
                                notFixedColumnCount = 0,
                                transparentColumnIndex,
                                visibleColumns;
                            if (isColumnFixing) {
                                visibleColumns = that.getVisibleColumns();
                                $.each(visibleColumns, function(index, column) {
                                    if (!column.command && !column.fixed) {
                                        notFixedColumnCount++;
                                        if (!isDefined(transparentColumnIndex))
                                            transparentColumnIndex = index
                                    }
                                });
                                if (notFixedColumnCount < visibleColumns.length) {
                                    result = visibleColumns.slice(0);
                                    notFixedColumnCount > 0 && result.splice(transparentColumnIndex, notFixedColumnCount, {
                                        command: "transparent",
                                        colspan: notFixedColumnCount
                                    })
                                }
                            }
                            return result
                        },
                        _isColumnFixing: function() {
                            var isColumnFixing = this.option("columnFixing.enabled");
                            !isColumnFixing && $.each(this._columns, function(_, column) {
                                if (column.fixed) {
                                    isColumnFixing = true;
                                    return false
                                }
                            });
                            return isColumnFixing
                        },
                        _getExpandColumnsCore: function() {
                            return this.getGroupColumns()
                        },
                        getExpandColumns: function() {
                            var expandColumns = this._getExpandColumnsCore(),
                                expandColumn;
                            if (expandColumns.length)
                                expandColumn = this.columnOption("command:expand");
                            expandColumns = $.map(expandColumns, function(column) {
                                return $.extend({}, column, {visibleWidth: "auto"}, expandColumn, {index: column.index})
                            });
                            return expandColumns
                        },
                        _getVisibleColumnsCore: function() {
                            var result = this.getExpandColumns(),
                                positiveIndexedColumns = [{}, {}, {}],
                                negativeIndexedColumns = {},
                                notGroupedColumnsCount = 0,
                                isFixedToEnd,
                                rtlEnabled = this.option("rtlEnabled"),
                                columns = this._columns.length ? this._commandColumns.concat(this._columns) : [];
                            $.each(columns, function() {
                                var column = this,
                                    visibleIndex = column.visibleIndex,
                                    indexedColumns;
                                if (column.visible && (!isDefined(column.groupIndex) || column.showWhenGrouped)) {
                                    column = $.extend(true, {}, column);
                                    if (visibleIndex < 0) {
                                        visibleIndex = -visibleIndex;
                                        indexedColumns = negativeIndexedColumns
                                    }
                                    else if (column.fixed || column.command) {
                                        isFixedToEnd = column.fixedPosition === "right";
                                        if (rtlEnabled)
                                            isFixedToEnd = !isFixedToEnd;
                                        if (isFixedToEnd || column.command)
                                            indexedColumns = positiveIndexedColumns[2];
                                        else
                                            indexedColumns = positiveIndexedColumns[0]
                                    }
                                    else
                                        indexedColumns = positiveIndexedColumns[1];
                                    indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];
                                    indexedColumns[visibleIndex].push(column);
                                    notGroupedColumnsCount++
                                }
                            });
                            objectUtils.orderEach(negativeIndexedColumns, function(_, columns) {
                                result.unshift.apply(result, columns)
                            });
                            $.each(positiveIndexedColumns, function(index, positiveColumns) {
                                objectUtils.orderEach(positiveColumns, function(_, columns) {
                                    result.push.apply(result, columns)
                                })
                            });
                            if (!notGroupedColumnsCount && this._columns.length)
                                result.push({command: "empty"});
                            return result
                        },
                        getHiddenColumns: function() {
                            var result = [];
                            $.each(this._columns, function(_, column) {
                                if (!column.visible)
                                    result.push(column)
                            });
                            return result
                        },
                        getChooserColumns: function() {
                            return $.grep(this.getHiddenColumns(), function(column) {
                                    return column.showInColumnChooser
                                })
                        },
                        allowMoveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                            var that = this,
                                columnIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation),
                                sourceColumn = that._columns[columnIndex];
                            if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {
                                if (sourceLocation === targetLocation) {
                                    if (sourceLocation === COLUMN_CHOOSER_LOCATION)
                                        return false;
                                    return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex
                                }
                                else if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION)
                                    return sourceColumn && sourceColumn.allowGrouping;
                                else if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION)
                                    return sourceColumn && sourceColumn.allowHiding;
                                return true
                            }
                            return false
                        },
                        moveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                            var that = this,
                                fromIndex,
                                toIndex,
                                targetGroupIndex,
                                isGroupMoving = sourceLocation === GROUP_LOCATION || targetLocation === GROUP_LOCATION,
                                column;
                            fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation);
                            toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation);
                            if (fromIndex >= 0) {
                                column = that._columns[fromIndex];
                                targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;
                                if (isDefined(column.groupIndex) && sourceLocation === GROUP_LOCATION) {
                                    if (targetGroupIndex > column.groupIndex)
                                        targetGroupIndex--;
                                    delete column.groupIndex;
                                    delete column.sortOrder;
                                    updateColumnGroupIndexes(that)
                                }
                                if (targetLocation === GROUP_LOCATION) {
                                    moveColumnToGroup(that, column, targetGroupIndex);
                                    updateColumnGroupIndexes(that)
                                }
                                else if (toVisibleIndex >= 0) {
                                    if (toIndex < 0)
                                        column.visibleIndex = undefined;
                                    else {
                                        var targetColumn = that._columns[toIndex];
                                        if (column.fixed ^ targetColumn.fixed)
                                            column.visibleIndex = undefined;
                                        else
                                            column.visibleIndex = targetColumn.visibleIndex
                                    }
                                    updateColumnVisibleIndexes(that, column)
                                }
                                column.visible = targetLocation !== COLUMN_CHOOSER_LOCATION;
                                updateColumnChanges(that, isGroupMoving ? "grouping" : "columns");
                                fireColumnsChanged(that)
                            }
                        },
                        changeSortOrder: function(columnIndex, sortOrder) {
                            var that = this,
                                sortingOptions = that.option("sorting"),
                                sortingMode = sortingOptions && sortingOptions.mode,
                                needResetSorting = sortingMode === "single" || !sortOrder,
                                allowSorting = sortingMode === "single" || sortingMode === "multiple",
                                column = that._columns[columnIndex],
                                nextSortOrder = function(column) {
                                    if (sortOrder === "ctrl") {
                                        if (!("sortOrder" in column && "sortIndex" in column))
                                            return false;
                                        delete column.sortOrder;
                                        delete column.sortIndex
                                    }
                                    else if (isDefined(column.groupIndex) || isDefined(column.sortIndex))
                                        column.sortOrder = column.sortOrder === "desc" ? "asc" : "desc";
                                    else
                                        column.sortOrder = "asc";
                                    return true
                                },
                                isSortingChanged = false;
                            if (allowSorting && column && column.allowSorting) {
                                if (needResetSorting && !isDefined(column.groupIndex))
                                    $.each(that._columns, function(index) {
                                        if (index !== columnIndex && this.sortOrder && !isDefined(this.groupIndex)) {
                                            delete this.sortOrder;
                                            delete this.sortIndex;
                                            isSortingChanged = true
                                        }
                                    });
                                if (isSortOrderValid(sortOrder)) {
                                    if (column.sortOrder !== sortOrder) {
                                        column.sortOrder = sortOrder;
                                        isSortingChanged = true
                                    }
                                }
                                else if (sortOrder === "none") {
                                    if (column.sortOrder) {
                                        delete column.sortIndex;
                                        delete column.sortOrder;
                                        isSortingChanged = true
                                    }
                                }
                                else
                                    isSortingChanged = nextSortOrder(column)
                            }
                            if (isSortingChanged) {
                                updateColumnSortIndexes(that);
                                updateColumnChanges(that, "sorting");
                                fireColumnsChanged(that)
                            }
                        },
                        getSortDataSourceParameters: function(useLocalSelector) {
                            var that = this,
                                sortColumns = [],
                                sort = [];
                            $.each(that._columns, function() {
                                if ((this.dataField || this.selector || this.calculateCellValue) && isDefined(this.sortIndex) && !isDefined(this.groupIndex))
                                    sortColumns[this.sortIndex] = this
                            });
                            $.each(sortColumns, function() {
                                var sortOrder = this && this.sortOrder;
                                if (isSortOrderValid(sortOrder))
                                    sort.push({
                                        selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,
                                        desc: this.sortOrder === "desc"
                                    })
                            });
                            return sort.length > 0 ? sort : null
                        },
                        getGroupDataSourceParameters: function(useLocalSelector) {
                            var group = [];
                            $.each(this.getGroupColumns(), function() {
                                var selector = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;
                                if (selector)
                                    group.push({
                                        selector: selector,
                                        desc: this.sortOrder === "desc",
                                        isExpanded: !!this.autoExpandGroup
                                    })
                            });
                            return group.length > 0 ? group : null
                        },
                        refresh: function(updateNewLookupsOnly) {
                            var deferreds = [];
                            $.each(this._columns, function() {
                                var lookup = this.lookup;
                                if (lookup && !this.calculateDisplayValue) {
                                    if (updateNewLookupsOnly && lookup.valueMap)
                                        return;
                                    if (lookup.update)
                                        deferreds.push(lookup.update())
                                }
                            });
                            return $.when.apply($, deferreds)
                        },
                        updateColumnDataTypes: function(dataSource) {
                            var firstItems = getFirstItems(dataSource),
                                rtlEnabled = this.option("rtlEnabled");
                            $.each(this._columns, function(index, column) {
                                var i,
                                    value,
                                    dataType,
                                    lookupDataType,
                                    valueDataType,
                                    lookup = column.lookup;
                                if (column.calculateCellValue && firstItems.length) {
                                    if (!column.dataType || lookup && !lookup.dataType) {
                                        for (i = 0; i < firstItems.length; i++) {
                                            value = column.calculateCellValue(firstItems[i]);
                                            valueDataType = column.dataType || getValueDataType(value);
                                            dataType = dataType || valueDataType;
                                            if (dataType && valueDataType && dataType !== valueDataType)
                                                dataType = "string";
                                            if (lookup) {
                                                valueDataType = lookup.dataType || getValueDataType(dataGrid.getDisplayValue(column, value, firstItems[i]));
                                                lookupDataType = lookupDataType || valueDataType;
                                                if (lookupDataType && valueDataType && lookupDataType !== valueDataType)
                                                    lookupDataType = "string"
                                            }
                                        }
                                        column.dataType = dataType;
                                        if (lookup)
                                            lookup.dataType = lookupDataType
                                    }
                                    if (!column.serializationFormat || lookup && !lookup.serializationFormat)
                                        for (i = 0; i < firstItems.length; i++) {
                                            value = column.calculateCellValue(firstItems[i], true);
                                            column.serializationFormat = column.serializationFormat || getSerializationFormat(column.dataType, value);
                                            if (lookup)
                                                lookup.serializationFormat = lookup.serializationFormat || getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value, true))
                                        }
                                }
                                column.selector = column.selector || function(data) {
                                    return column.calculateCellValue(data)
                                };
                                $.each(["calculateSortValue", "calculateGroupValue", "calculateDisplayValue"], function(_, calculateCallbackName) {
                                    var calculateCallback = column[calculateCallbackName];
                                    if (commonUtils.isFunction(calculateCallback) && !calculateCallback.isProxy) {
                                        column[calculateCallbackName] = function(data) {
                                            return calculateCallback.call(column, data)
                                        };
                                        column[calculateCallbackName].isProxy = true
                                    }
                                });
                                if (commonUtils.isString(column.calculateDisplayValue)) {
                                    column.displayField = column.calculateDisplayValue;
                                    column.calculateDisplayValue = dataUtils.compileGetter(column.displayField)
                                }
                                if (column.calculateDisplayValue)
                                    column.displayValueMap = column.displayValueMap || {};
                                updateSerializers(column, column.dataType);
                                if (lookup)
                                    updateSerializers(lookup, lookup.dataType);
                                dataType = lookup ? lookup.dataType : column.dataType;
                                if (dataType) {
                                    column.alignment = column.alignment || getAlignmentByDataType(dataType, rtlEnabled);
                                    column.format = column.format || dataGrid.getFormatByDataType(dataType);
                                    column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);
                                    if (!isDefined(column.filterOperations))
                                        column.filterOperations = !lookup && DATATYPE_OPERATIONS[dataType] || [];
                                    column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || "=";
                                    column.defaultSelectedFilterOperation = column.selectedFilterOperation;
                                    column.showEditorAlways = isDefined(column.showEditorAlways) ? column.showEditorAlways : dataType === "boolean" && !column.cellTemplate
                                }
                            })
                        },
                        _customizeColumns: function(columns) {
                            var that = this,
                                customizeColumns = that.option("customizeColumns");
                            if (customizeColumns) {
                                customizeColumns(columns);
                                assignColumns(that, createColumnsFromOptions(that, columns))
                            }
                        },
                        updateColumns: function(dataSource, forceApplying) {
                            var that = this,
                                sortParameters,
                                groupParameters;
                            if (!forceApplying)
                                that.updateSortingGrouping(dataSource);
                            if (!dataSource || dataSource.isLoaded()) {
                                sortParameters = dataSource ? dataSource.sort() || [] : that.getSortDataSourceParameters();
                                groupParameters = dataSource ? dataSource.group() || [] : that.getGroupDataSourceParameters();
                                that._customizeColumns(that._columns);
                                updateIndexes(that);
                                return $.when(that.refresh(true)).always(function() {
                                        if (dataSource) {
                                            that.updateColumnDataTypes(dataSource);
                                            that._dataSourceApplied = true
                                        }
                                        if (!equalSortParameters(sortParameters, that.getSortDataSourceParameters()))
                                            updateColumnChanges(that, "sorting");
                                        if (!equalSortParameters(groupParameters, that.getGroupDataSourceParameters()))
                                            updateColumnChanges(that, "grouping");
                                        updateColumnChanges(that, "columns");
                                        fireColumnsChanged(that)
                                    })
                            }
                        },
                        updateSortingGrouping: function(dataSource, fromDataSource) {
                            var that = this,
                                sortParameters,
                                groupParameters,
                                columnsGroupParameters,
                                columnsSortParameters,
                                isColumnsChanged,
                                updateSortGroupParameterIndexes = function(columns, sortParameters, indexParameterName) {
                                    var i,
                                        selector,
                                        isExpanded;
                                    $.each(columns, function(index, column) {
                                        delete column[indexParameterName];
                                        if (sortParameters)
                                            for (i = 0; i < sortParameters.length; i++) {
                                                selector = sortParameters[i].selector;
                                                isExpanded = sortParameters[i].isExpanded;
                                                if (selector === column.dataField || selector === column.name || selector === column.selector || selector === column.calculateCellValue || selector === column.calculateGroupValue) {
                                                    column.sortOrder = column.sortOrder || (sortParameters[i].desc ? "desc" : "asc");
                                                    if (isExpanded !== undefined)
                                                        column.autoExpandGroup = isExpanded;
                                                    column[indexParameterName] = i;
                                                    break
                                                }
                                            }
                                    })
                                };
                            if (dataSource) {
                                sortParameters = normalizeSortingInfo(dataSource.sort());
                                groupParameters = normalizeSortingInfo(dataSource.group());
                                columnsGroupParameters = that.getGroupDataSourceParameters();
                                columnsSortParameters = that.getSortDataSourceParameters();
                                if (!that._columns.length) {
                                    $.each(groupParameters, function(index, group) {
                                        that._columns.push(group.selector)
                                    });
                                    $.each(sortParameters, function(index, sort) {
                                        that._columns.push(sort.selector)
                                    });
                                    assignColumns(that, createColumnsFromOptions(that, that._columns))
                                }
                                if ((fromDataSource || !columnsGroupParameters && !that._hasUserState) && !equalSortParameters(groupParameters, columnsGroupParameters)) {
                                    that.__groupingUpdated = true;
                                    updateSortGroupParameterIndexes(that._columns, groupParameters, "groupIndex");
                                    if (fromDataSource) {
                                        updateColumnChanges(that, "grouping");
                                        isColumnsChanged = true
                                    }
                                }
                                if ((fromDataSource || !columnsSortParameters && !that._hasUserState) && !equalSortParameters(sortParameters, columnsSortParameters)) {
                                    that.__sortingUpdated = true;
                                    updateSortGroupParameterIndexes(that._columns, sortParameters, "sortIndex");
                                    if (fromDataSource) {
                                        updateColumnChanges(that, "sorting");
                                        isColumnsChanged = true
                                    }
                                }
                                if (isColumnsChanged)
                                    fireColumnsChanged(that)
                            }
                        },
                        updateFilter: function(filter, localFiltering, columnIndex) {
                            var that = this;
                            if (!commonUtils.isArray(filter))
                                return filter;
                            var column,
                                i;
                            filter = $.extend([], filter);
                            columnIndex = filter.columnIndex || columnIndex;
                            if (localFiltering && commonUtils.isString(filter[0])) {
                                column = that.columnOption(filter[0]);
                                if (column && column.selector) {
                                    filter[0] = column.selector;
                                    filter[0].columnIndex = column.index
                                }
                            }
                            else if (commonUtils.isFunction(filter[0]))
                                filter[0].columnIndex = columnIndex;
                            for (i = 0; i < filter.length; i++)
                                filter[i] = that.updateFilter(filter[i], localFiltering, columnIndex);
                            return filter
                        },
                        columnCount: function() {
                            return this._columns.length
                        },
                        columnOption: function(identificator, option, value, notFireEvent) {
                            var that = this,
                                i,
                                identificatorOptionName = commonUtils.isString(identificator) && identificator.substr(0, identificator.indexOf(":")),
                                columns = identificator < 0 || identificatorOptionName === "command" ? that._commandColumns : that._columns,
                                needUpdateIndexes,
                                column;
                            if (identificator === undefined)
                                return;
                            if (identificatorOptionName)
                                identificator = identificator.substr(identificatorOptionName.length + 1);
                            for (i = 0; i < columns.length; i++)
                                if (identificatorOptionName) {
                                    if ("" + columns[i][identificatorOptionName] === identificator) {
                                        column = columns[i];
                                        break
                                    }
                                }
                                else if (columns[i].index === identificator || columns[i].name === identificator || columns[i].dataField === identificator || columns[i].caption === identificator) {
                                    column = columns[i];
                                    break
                                }
                            if (column) {
                                if (arguments.length === 1)
                                    return $.extend({}, column);
                                if (commonUtils.isString(option))
                                    if (arguments.length === 2)
                                        return columnOptionCore(that, column, option);
                                    else {
                                        needUpdateIndexes = needUpdateIndexes || COLUMN_INDEX_OPTIONS[option];
                                        columnOptionCore(that, column, option, value, notFireEvent)
                                    }
                                else if (commonUtils.isObject(option))
                                    $.each(option, function(optionName, value) {
                                        needUpdateIndexes = needUpdateIndexes || COLUMN_INDEX_OPTIONS[optionName];
                                        columnOptionCore(that, column, optionName, value, notFireEvent)
                                    });
                                if (needUpdateIndexes)
                                    updateIndexes(that, column);
                                fireColumnsChanged(that)
                            }
                        },
                        clearSorting: function() {
                            var that = this,
                                columnCount = this.columnCount(),
                                i;
                            that.beginUpdate();
                            for (i = 0; i < columnCount; i++)
                                that.columnOption(i, "sortOrder", undefined);
                            that.endUpdate()
                        },
                        clearGrouping: function() {
                            var that = this,
                                columnCount = this.columnCount(),
                                i;
                            that.beginUpdate();
                            for (i = 0; i < columnCount; i++)
                                that.columnOption(i, "groupIndex", undefined);
                            that.endUpdate()
                        },
                        getVisibleIndex: function(index) {
                            var i,
                                visibleColumns = this.getVisibleColumns();
                            for (i = 0; i < visibleColumns.length; i++)
                                if (visibleColumns[i].index === index)
                                    return i;
                            return -1
                        },
                        addColumn: function(options) {
                            var that = this,
                                column = createColumn(that, options);
                            that._columns.push(column);
                            updateIndexes(that, column);
                            that.updateColumns(that._dataSource)
                        },
                        deleteColumn: function(id) {
                            var that = this,
                                columnIndex = that.columnOption(id, "index");
                            if (columnIndex >= 0) {
                                that._columns.splice(columnIndex, 1);
                                updateIndexes(that);
                                that.updateColumns(that._dataSource)
                            }
                        },
                        addCommandColumn: function(options) {
                            var commandColumns = this._commandColumns,
                                i;
                            for (i = 0; i < commandColumns.length; i++)
                                if (commandColumns[i].command === options.command)
                                    return;
                            commandColumns.push(options)
                        },
                        getUserState: function() {
                            var columns = this._columns,
                                result = [],
                                i;
                            function handleStateField(index, value) {
                                if (columns[i][value] !== undefined)
                                    result[i][value] = columns[i][value]
                            }
                            for (i = 0; i < columns.length; i++) {
                                result[i] = {};
                                $.each(USER_STATE_FIELD_NAMES, handleStateField)
                            }
                            return result
                        },
                        setUserState: function(state) {
                            var that = this,
                                commonColumnSettings,
                                ignoreColumnOptionNames = that.option("stateStoring.ignoreColumnOptionNames");
                            if (!ignoreColumnOptionNames) {
                                ignoreColumnOptionNames = [];
                                commonColumnSettings = that.getCommonSettings();
                                if (!that.option("columnChooser.enabled"))
                                    ignoreColumnOptionNames.push("visible");
                                if (that.option("sorting.mode") === "none")
                                    ignoreColumnOptionNames.push("sortIndex", "sortOrder");
                                if (!commonColumnSettings.allowGrouping)
                                    ignoreColumnOptionNames.push("groupIndex");
                                if (!commonColumnSettings.allowFixing)
                                    ignoreColumnOptionNames.push("fixed", "fixedPosition");
                                if (!commonColumnSettings.allowResizing)
                                    ignoreColumnOptionNames.push("width", "visibleWidth");
                                if (!that.option("filterRow.visible"))
                                    ignoreColumnOptionNames.push("filterValue", "selectedFilterOperation");
                                if (!that.option("headerFilter.visible"))
                                    ignoreColumnOptionNames.push("filterValues", "filterType")
                            }
                            that._columnsUserState = state;
                            that._ignoreColumnOptionNames = ignoreColumnOptionNames;
                            that._hasUserState = !!state;
                            that.init()
                        },
                        _createCalculatedColumnOptions: function(columnOptions) {
                            var calculatedColumnOptions = {},
                                dataField = columnOptions.dataField,
                                getter;
                            if (dataField) {
                                if (commonUtils.isString(dataField)) {
                                    getter = dataUtils.compileGetter(dataField);
                                    calculatedColumnOptions = {
                                        caption: inflector.captionize(dataField),
                                        calculateCellValue: function(data, skipDeserialization) {
                                            var value = getter(data);
                                            return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value
                                        },
                                        setCellValue: defaultSetCellValue,
                                        parseValue: function(text) {
                                            var column = this,
                                                result,
                                                parsedValue;
                                            if (column.dataType === "number") {
                                                if (commonUtils.isString(text)) {
                                                    parsedValue = Globalize.parseFloat(text);
                                                    if (commonUtils.isNumber(parsedValue))
                                                        result = parsedValue
                                                }
                                                else if (commonUtils.isDefined(text))
                                                    result = Number(text)
                                            }
                                            else if (column.dataType === "boolean") {
                                                if (text === column.trueText)
                                                    result = true;
                                                else if (text === column.falseText)
                                                    result = false
                                            }
                                            else if (column.dataType === "date") {
                                                parsedValue = Globalize.parseDate(text);
                                                if (parsedValue)
                                                    result = parsedValue
                                            }
                                            else
                                                result = text;
                                            return result
                                        }
                                    }
                                }
                                calculatedColumnOptions.allowFiltering = true
                            }
                            else
                                calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression;
                            calculatedColumnOptions.calculateFilterExpression = function() {
                                return dataGrid.defaultCalculateFilterExpression.apply(this, arguments)
                            };
                            calculatedColumnOptions.createFilterExpression = function() {
                                var result;
                                if (this.calculateFilterExpression)
                                    result = this.calculateFilterExpression.apply(this, arguments);
                                if (result)
                                    result.columnIndex = this.index;
                                return result
                            };
                            if (!dataField || !commonUtils.isString(dataField))
                                $.extend(true, calculatedColumnOptions, {
                                    allowSorting: false,
                                    allowGrouping: false,
                                    calculateCellValue: function() {
                                        return null
                                    }
                                });
                            if (columnOptions.dataType)
                                calculatedColumnOptions.userDataType = columnOptions.dataType;
                            if (columnOptions.lookup)
                                calculatedColumnOptions.lookup = {
                                    calculateCellValue: function(value, skipDeserialization) {
                                        if (this.valueExpr)
                                            value = this.valueMap && this.valueMap[value];
                                        return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value
                                    },
                                    updateValueMap: function() {
                                        var calculateValue,
                                            calculateDisplayValue,
                                            item,
                                            i;
                                        this.valueMap = {};
                                        if (this.items) {
                                            calculateValue = dataUtils.compileGetter(this.valueExpr);
                                            calculateDisplayValue = dataUtils.compileGetter(this.displayExpr);
                                            for (i = 0; i < this.items.length; i++) {
                                                item = this.items[i];
                                                this.valueMap[calculateValue(item)] = calculateDisplayValue(item)
                                            }
                                        }
                                    },
                                    update: function() {
                                        var that = this,
                                            dataSource = that.dataSource,
                                            dataSourceOptions;
                                        if (dataSource) {
                                            if (commonUtils.isFunction(dataSource) && !knockoutUtils.isObservable(dataSource))
                                                dataSource = dataSource({});
                                            if (commonUtils.isObject(dataSource) || commonUtils.isArray(dataSource)) {
                                                if (that.valueExpr) {
                                                    dataSourceOptions = dataUtils.normalizeDataSourceOptions(dataSource);
                                                    dataSourceOptions.paginate = false;
                                                    dataSource = new DX.data.DataSource(dataSourceOptions);
                                                    return dataSource.load().done(function(data) {
                                                            that.items = data;
                                                            that.updateValueMap && that.updateValueMap()
                                                        })
                                                }
                                            }
                                            else
                                                errors.log("E1016")
                                        }
                                        else
                                            that.updateValueMap && that.updateValueMap()
                                    }
                                };
                            calculatedColumnOptions.resizedCallbacks = $.Callbacks();
                            if (columnOptions.resized)
                                calculatedColumnOptions.resizedCallbacks.add($.proxy(columnOptions.resized, columnOptions));
                            $.each(calculatedColumnOptions, function(optionName) {
                                var defaultOptionName;
                                if (commonUtils.isFunction(calculatedColumnOptions[optionName]) && optionName.indexOf("default") !== 0) {
                                    defaultOptionName = "default" + optionName.charAt(0).toUpperCase() + optionName.substr(1);
                                    calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName]
                                }
                            });
                            return calculatedColumnOptions
                        }
                    }
            }());
        ui.dxDataGrid.ColumnsController = ColumnsController;
        dataGrid.registerModule("columns", {
            defaultOptions: function() {
                return {
                        commonColumnSettings: {
                            allowFiltering: true,
                            allowHiding: true,
                            allowSorting: true,
                            allowEditing: true,
                            encodeHtml: true,
                            trueText: Globalize.localize("dxDataGrid-trueText"),
                            falseText: Globalize.localize("dxDataGrid-falseText")
                        },
                        allowColumnReordering: false,
                        allowColumnResizing: false,
                        adaptColumnWidthByRatio: true,
                        columns: undefined,
                        regenerateColumnsByVisibleItems: false,
                        customizeColumns: null
                    }
            },
            controllers: {columns: ColumnsController}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.selection.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            support = DX.require("/utils/utils.support"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            getKeyHash = dataGrid.getKeyHash;
        var DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_ROW_SELECTION_CLASS = "dx-selection",
            DATAGRID_SELECT_CHECKBOX_CLASS = "dx-select-checkbox",
            DATAGRID_CHECKBOXES_HIDDEN_CLASS = "dx-select-checkboxes-hidden",
            DATAGRID_COMMAND_SELECT_CLASS = "dx-command-select",
            DATAGRID_SELECTION_DISABLED_CLASS = "dx-selection-disabled",
            DATAGRID_DATA_ROW_CLASS = "dx-data-row";
        $.extend(dataGrid.__internals, {
            DATAGRID_ROW_SELECTION_CLASS: DATAGRID_ROW_SELECTION_CLASS,
            DATAGRID_SELECTION_DISABLED_CLASS: DATAGRID_SELECTION_DISABLED_CLASS,
            DATAGRID_COMMAND_SELECT_CLASS: DATAGRID_COMMAND_SELECT_CLASS
        });
        var SHOW_CHECKBOXES_MODE = "selection.showCheckBoxesMode";
        var SELECTION_MODE = "selection.mode";
        var isSelectable = function(selectionMode) {
                return selectionMode === "single" || selectionMode === "multiple"
            };
        var processLongTap = function(that, jQueryEvent) {
                var selectionController = that.getController("selection"),
                    rowsView = that.getView("rowsView"),
                    $row = $(jQueryEvent.target).closest("." + DATAGRID_DATA_ROW_CLASS),
                    rowIndex = rowsView.getRowIndex($row);
                if (rowIndex < 0)
                    return;
                if (that.option(SHOW_CHECKBOXES_MODE) === "onLongTap")
                    if (selectionController.isSelectionWithCheckboxes())
                        selectionController.stopSelectionWithCheckboxes();
                    else
                        selectionController.startSelectionWithCheckboxes();
                else {
                    if (that.option(SHOW_CHECKBOXES_MODE) === "onClick")
                        selectionController.startSelectionWithCheckboxes();
                    selectionController.changeItemSelection(rowIndex, {control: true})
                }
            };
        dataGrid.SelectionController = dataGrid.Controller.inherit(function() {
            var indexOfSelectedItemKey = function(that, key, isSelectAll) {
                    var index,
                        indices,
                        selectedItemKeys = isSelectAll ? that._unselectedItemKeys : that._selectedItemKeys;
                    if (commonUtils.isObject(key)) {
                        for (index = 0; index < selectedItemKeys.length; index++)
                            if (equalKeys(selectedItemKeys[index], key))
                                return index;
                        return -1
                    }
                    else {
                        indices = that._selectedItemKeyHashIndices[key];
                        return indices && indices[0] >= 0 ? indices[0] : -1
                    }
                };
            var addSelectedItem = function(that, itemData) {
                    var key = that.getController("data").keyOf(itemData),
                        keyHash = getKeyHash(key);
                    if (indexOfSelectedItemKey(that, keyHash) === -1) {
                        if (!commonUtils.isObject(keyHash))
                            that._selectedItemKeyHashIndices[keyHash] = [that._selectedItemKeys.length];
                        that._selectedItemKeys.push(key);
                        that._addedItemKeys.push(key);
                        that._selectedItems.push(itemData)
                    }
                };
            var removeSelectedItem = function(that, key) {
                    var keyHash = getKeyHash(key),
                        keyIndex = indexOfSelectedItemKey(that, keyHash),
                        currentKeyIndex,
                        currentKeyIndices,
                        keyIndices,
                        i;
                    if (keyIndex >= 0) {
                        that._selectedItemKeys.splice(keyIndex, 1);
                        that._removedItemKeys.push(key);
                        that._selectedItems.splice(keyIndex, 1);
                        if (!commonUtils.isObject(keyHash)) {
                            keyIndices = that._selectedItemKeyHashIndices[keyHash];
                            if (keyIndices) {
                                keyIndices.shift();
                                if (!keyIndices.length)
                                    delete that._selectedItemKeyHashIndices[keyHash];
                                for (currentKeyIndex = keyIndex; currentKeyIndex < that._selectedItemKeys.length; currentKeyIndex++) {
                                    currentKeyIndices = that._selectedItemKeyHashIndices[getKeyHash(that._selectedItemKeys[currentKeyIndex])];
                                    if (currentKeyIndices)
                                        for (i = 0; i < currentKeyIndices.length; i++)
                                            if (currentKeyIndices[i] > keyIndex)
                                                currentKeyIndices[i]--
                                }
                            }
                        }
                    }
                };
            var clearSelectedItems = function(that) {
                    setSelectedItems(that, [], [])
                };
            var setSelectedItems = function(that, keys, items) {
                    var i,
                        keyHash,
                        keyIndices,
                        oldSelectedItemKeys = that._selectedItemKeys;
                    that._selectedItemKeys = keys;
                    that._selectedItemKeyHashIndices = {};
                    that._selectedItems = items;
                    that._unselectedItemKeys = [];
                    for (i = 0; i < oldSelectedItemKeys.length; i++)
                        if ($.inArray(oldSelectedItemKeys[i], keys) === -1)
                            that._removedItemKeys.push(oldSelectedItemKeys[i]);
                    for (i = 0; i < keys.length; i++) {
                        keyHash = getKeyHash(keys[i]);
                        if (!commonUtils.isObject(keyHash)) {
                            keyIndices = that._selectedItemKeyHashIndices[keyHash] = that._selectedItemKeyHashIndices[keyHash] || [];
                            keyIndices.push(i)
                        }
                        if ($.inArray(keys[i], oldSelectedItemKeys) === -1)
                            that._addedItemKeys.push(keys[i])
                    }
                };
            var equalKeys = dataGrid.equalKeys;
            var resetItemSelectionWhenShiftKeyPressed = function(that) {
                    delete that._shiftFocusedItemIndex
                };
            var isDataItem = function(row) {
                    return row && row.rowType === "data" && !row.inserted
                };
            var changeItemSelectionWhenShiftKeyPressed = function(that, itemIndex, items) {
                    var isSelectedItemsChanged = false,
                        itemIndexStep,
                        index,
                        dataController = that.getController("data"),
                        isFocusedItemSelected = items[that._focusedItemIndex] && that.isRowSelected(dataController.keyOf(items[that._focusedItemIndex].data));
                    var addRemoveSelectedItem = function(that, data, isRemove) {
                            if (isRemove)
                                removeSelectedItem(that, dataController.keyOf(data));
                            else
                                addSelectedItem(that, data)
                        };
                    if (!commonUtils.isDefined(that._shiftFocusedItemIndex))
                        that._shiftFocusedItemIndex = that._focusedItemIndex;
                    if (that._shiftFocusedItemIndex !== that._focusedItemIndex) {
                        itemIndexStep = that._focusedItemIndex < that._shiftFocusedItemIndex ? 1 : -1;
                        for (index = that._focusedItemIndex; index !== that._shiftFocusedItemIndex; index += itemIndexStep)
                            if (isDataItem(items[index])) {
                                addRemoveSelectedItem(that, items[index].data, true);
                                isSelectedItemsChanged = true
                            }
                    }
                    if (itemIndex !== that._shiftFocusedItemIndex) {
                        itemIndexStep = itemIndex < that._shiftFocusedItemIndex ? 1 : -1;
                        for (index = itemIndex; index !== that._shiftFocusedItemIndex; index += itemIndexStep)
                            if (isDataItem(items[index])) {
                                addRemoveSelectedItem(that, items[index].data, false);
                                isSelectedItemsChanged = true
                            }
                    }
                    if (isDataItem(items[that._focusedItemIndex]) && !isFocusedItemSelected) {
                        addRemoveSelectedItem(that, items[that._focusedItemIndex].data, false);
                        isSelectedItemsChanged = true
                    }
                    return isSelectedItemsChanged
                };
            var createSelectedItemsFilterCriteria = function(dataSource, selectedItemKeys, isSelectAll) {
                    var keyCriteria,
                        i,
                        key = dataSource && dataSource.key(),
                        criteria = [];
                    if (dataSource)
                        if (key)
                            $.each(selectedItemKeys, function(index, keyValue) {
                                if (criteria.length > 0)
                                    criteria.push(isSelectAll ? "and" : "or");
                                if ($.isArray(key)) {
                                    keyCriteria = [];
                                    for (i = 0; i < key.length; i++) {
                                        if (i > 0)
                                            keyCriteria.push(isSelectAll ? "or" : "and");
                                        keyCriteria.push([key[i], isSelectAll ? "<>" : "=", keyValue[key[i]]])
                                    }
                                    criteria.push(keyCriteria)
                                }
                                else
                                    criteria.push([key, isSelectAll ? "<>" : "=", keyValue])
                            });
                        else
                            criteria = function(item) {
                                var i;
                                for (i = 0; i < selectedItemKeys.length; i++)
                                    if (equalKeys(selectedItemKeys[i], item))
                                        return !isSelectAll;
                                return isSelectAll
                            };
                    if (criteria.length > 0 || $.isFunction(criteria))
                        return criteria
                };
            var updateSelectedItems = function(that) {
                    var changedItemIndexes = [],
                        dataController = that.getController("data"),
                        isSelectionWithCheckboxes = that.isSelectionWithCheckboxes(),
                        addedItemKeys,
                        removedItemKeys;
                    if (dataController) {
                        $.each(dataController.items(), function(index, row) {
                            if (isDataItem(row) && row.isSelected !== that.isRowSelected(row.key))
                                changedItemIndexes.push(index)
                        });
                        if (that.option(SHOW_CHECKBOXES_MODE) === "onClick")
                            if (that._selectedItemKeys.length > 1)
                                that.startSelectionWithCheckboxes();
                            else if (that._selectedItemKeys.length === 0 && that._removedItemKeys.length)
                                that.stopSelectionWithCheckboxes();
                        if (changedItemIndexes.length || isSelectionWithCheckboxes !== that.isSelectionWithCheckboxes())
                            dataController.updateItems({
                                changeType: "updateSelection",
                                itemIndexes: changedItemIndexes
                            });
                        addedItemKeys = that._addedItemKeys;
                        removedItemKeys = that._removedItemKeys;
                        if (addedItemKeys.length || removedItemKeys.length) {
                            that._selectedItemsInternalChange = true;
                            that.option("selectedRowKeys", that._selectedItemKeys.slice(0));
                            that._selectedItemsInternalChange = false;
                            that.selectionChanged.fire(that._selectedItemKeys);
                            that._addedItemKeys = [];
                            that._removedItemKeys = [];
                            that.executeAction("onSelectionChanged", {
                                selectedRowsData: that._selectedItems,
                                selectedRowKeys: that._selectedItemKeys,
                                currentSelectedRowKeys: addedItemKeys,
                                currentDeselectedRowKeys: removedItemKeys
                            })
                        }
                    }
                };
            var updateSelectColumn = function(that) {
                    var columnsController = that.getController("columns"),
                        isSelectColumnVisible = that.isSelectColumnVisible();
                    columnsController.addCommandColumn({
                        command: "select",
                        visible: isSelectColumnVisible,
                        visibleIndex: -1,
                        dataType: "boolean",
                        alignment: "center",
                        cssClass: DATAGRID_COMMAND_SELECT_CLASS,
                        width: "auto"
                    });
                    columnsController.columnOption("command:select", "visible", isSelectColumnVisible)
                };
            return {
                    init: function() {
                        var that = this;
                        that._isSelectionWithCheckboxes = false;
                        that._focusedItemIndex = -1;
                        that._selectedItemKeys = [];
                        that._selectedItemKeyHashIndices = {};
                        that._unselectedItemKeys = [];
                        that._selectedItems = [];
                        that._addedItemKeys = [];
                        that._removedItemKeys = [];
                        updateSelectColumn(that);
                        that.createAction("onSelectionChanged", {excludeValidators: ["disabled", "readOnly"]})
                    },
                    callbackNames: function() {
                        return ["selectionChanged"]
                    },
                    optionChanged: function(args) {
                        var that = this;
                        that.callBase(args);
                        switch (args.name) {
                            case"selection":
                                that.init();
                                that.getController("columns").updateColumns();
                                args.handled = true;
                                break;
                            case"selectedRowKeys":
                                if (commonUtils.isArray(args.value) && !that._selectedItemsInternalChange)
                                    that.selectRows(args.value);
                                args.handled = true;
                                break
                        }
                    },
                    publicMethods: function() {
                        return ["selectRows", "deselectRows", "selectRowsByIndexes", "getSelectedRowKeys", "getSelectedRowsData", "clearSelection", "selectAll", "deselectAll", "startSelectionWithCheckboxes", "stopSelectionWithCheckboxes", "isRowSelected"]
                    },
                    isRowSelected: function(key) {
                        var keyHash = getKeyHash(key),
                            index = indexOfSelectedItemKey(this, keyHash);
                        return index !== -1
                    },
                    isSelectColumnVisible: function() {
                        var showCheckBoxesMode = this.option(SHOW_CHECKBOXES_MODE);
                        return this.option(SELECTION_MODE) === "multiple" && (showCheckBoxesMode === "always" || showCheckBoxesMode === "onClick" || this._isSelectionWithCheckboxes)
                    },
                    isSelectAll: function() {
                        var dataController = this.getController("data"),
                            items = dataController.items(),
                            combinedFilter = dataController.getCombinedFilter(),
                            selectedItems = this.getSelectedRowsData(),
                            i;
                        if (combinedFilter)
                            DX.data.query(selectedItems).filter(combinedFilter).enumerate().done(function(items) {
                                selectedItems = items
                            });
                        if (!selectedItems.length) {
                            for (i = 0; i < items.length; i++)
                                if (items[i].selected)
                                    return;
                            return false
                        }
                        else if (selectedItems.length >= dataController.totalCount())
                            return true
                    },
                    selectAll: function() {
                        if (this.option(SHOW_CHECKBOXES_MODE) === "onClick")
                            this.startSelectionWithCheckboxes();
                        return this.selectedItemKeys([], true, false, true)
                    },
                    deselectAll: function() {
                        return this.selectedItemKeys([], true, true, true)
                    },
                    clearSelection: function() {
                        return this.selectedItemKeys([])
                    },
                    refresh: function() {
                        return this.selectedItemKeys(this.option("selectedRowKeys") || [])
                    },
                    selectedItemKeys: function(value, preserve, isDeselect, isSelectAll) {
                        var that = this,
                            keys,
                            criteria,
                            isFunctionCriteria,
                            deferred,
                            dataController = that.getController("data"),
                            dataSource = dataController.dataSource(),
                            store = dataSource && dataSource.store(),
                            dataSourceFilter,
                            filter,
                            deselectItems = [],
                            loadOptions;
                        if (commonUtils.isDefined(value)) {
                            if (store) {
                                keys = $.isArray(value) ? $.extend([], value) : [value];
                                if (keys.length || isSelectAll) {
                                    criteria = createSelectedItemsFilterCriteria(dataSource, keys, isSelectAll);
                                    isFunctionCriteria = $.isFunction(criteria);
                                    if (isSelectAll) {
                                        dataSourceFilter = dataController.getCombinedFilter();
                                        if (isDeselect && !dataSourceFilter)
                                            return that.clearSelection()
                                    }
                                    if (criteria || isSelectAll) {
                                        if (criteria && !isFunctionCriteria && dataSourceFilter) {
                                            filter = [];
                                            filter.push(criteria);
                                            filter.push(dataSourceFilter)
                                        }
                                        else if (dataSourceFilter)
                                            filter = dataSourceFilter;
                                        else if (criteria && !isFunctionCriteria)
                                            filter = criteria;
                                        deferred = $.Deferred();
                                        if (isDeselect)
                                            new DX.data.ArrayStore(that._selectedItems).load({filter: filter}).done(function(items) {
                                                deselectItems = items
                                            });
                                        loadOptions = {
                                            filter: filter,
                                            select: dataSource.select()
                                        };
                                        new DX.data.ArrayStore(deselectItems.length ? deselectItems : dataSource.items()).load({filter: criteria}).done(function(items) {
                                            if (!isSelectAll && (deselectItems.length || items.length === keys.length))
                                                deferred.resolve(items);
                                            else
                                                dataSource.load(loadOptions).done(function(items) {
                                                    new DX.data.ArrayStore(items).load({filter: criteria}).done(deferred.resolve)
                                                }).fail($.proxy(deferred.reject, deferred))
                                        })
                                    }
                                }
                            }
                            deferred = deferred || $.Deferred().resolve([]);
                            deferred.done(function(items) {
                                var i,
                                    key,
                                    item,
                                    keys = [];
                                if (store && items.length > 0)
                                    for (i = 0; i < items.length; i++) {
                                        item = items[i];
                                        key = store.keyOf(item);
                                        if (preserve)
                                            if (isDeselect)
                                                removeSelectedItem(that, key);
                                            else
                                                addSelectedItem(that, item);
                                        else
                                            keys.push(key)
                                    }
                                if (!preserve)
                                    setSelectedItems(that, keys, items);
                                updateSelectedItems(that)
                            });
                            return deferred
                        }
                        else
                            return that._selectedItemKeys
                    },
                    getSelectedRowKeys: function() {
                        return this.selectedItemKeys()
                    },
                    selectRows: function(keys, preserve) {
                        return this.selectedItemKeys(keys, preserve)
                    },
                    deselectRows: function(keys) {
                        return this.selectedItemKeys(keys, true, true)
                    },
                    selectRowsByIndexes: function(indexes) {
                        var items = this.getController("data").items(),
                            keys = [];
                        if (!commonUtils.isArray(indexes))
                            indexes = Array.prototype.slice.call(arguments, 0);
                        $.each(indexes, function() {
                            var item = items[this];
                            if (item && item.rowType === "data")
                                keys.push(item.key)
                        });
                        return this.selectRows(keys)
                    },
                    getSelectedRowsData: function() {
                        return this._selectedItems
                    },
                    changeItemSelection: function(itemIndex, keys) {
                        var that = this,
                            dataController = that.getController("data"),
                            items = dataController.items(),
                            item = items[itemIndex],
                            itemData = item && (item.oldData || item.data),
                            selectionMode = that.option(SELECTION_MODE),
                            isSelectedItemsChanged,
                            isSelected,
                            itemKey;
                        if (isSelectable(selectionMode) && isDataItem(item)) {
                            itemKey = dataController.keyOf(itemData);
                            keys = keys || {};
                            if (that.isSelectionWithCheckboxes())
                                keys.control = true;
                            if (keys.shift && selectionMode === "multiple" && that._focusedItemIndex >= 0)
                                isSelectedItemsChanged = changeItemSelectionWhenShiftKeyPressed(that, itemIndex, items);
                            else if (keys.control) {
                                resetItemSelectionWhenShiftKeyPressed(that);
                                isSelected = that.isRowSelected(itemKey);
                                if (selectionMode === "single")
                                    clearSelectedItems(that);
                                if (isSelected)
                                    removeSelectedItem(that, itemKey);
                                else
                                    addSelectedItem(that, itemData);
                                isSelectedItemsChanged = true
                            }
                            else {
                                resetItemSelectionWhenShiftKeyPressed(that);
                                if (that._selectedItemKeys.length !== 1 || !equalKeys(that._selectedItemKeys[0], itemKey)) {
                                    setSelectedItems(that, [itemKey], [itemData]);
                                    isSelectedItemsChanged = true
                                }
                            }
                            if (isSelectedItemsChanged) {
                                that._focusedItemIndex = itemIndex;
                                updateSelectedItems(that);
                                return true
                            }
                        }
                        return false
                    },
                    focusedItemIndex: function(itemIndex) {
                        var that = this;
                        if (commonUtils.isDefined(itemIndex))
                            that._focusedItemIndex = itemIndex;
                        else
                            return that._focusedItemIndex
                    },
                    isSelectionWithCheckboxes: function() {
                        var selectionMode = this.option(SELECTION_MODE),
                            showCheckBoxesMode = this.option(SHOW_CHECKBOXES_MODE);
                        return selectionMode === "multiple" && (showCheckBoxesMode === "always" || this._isSelectionWithCheckboxes)
                    },
                    startSelectionWithCheckboxes: function() {
                        var that = this,
                            isSelectColumnVisible = that.isSelectColumnVisible();
                        if (that.option(SELECTION_MODE) === "multiple" && !that.isSelectionWithCheckboxes()) {
                            that._isSelectionWithCheckboxes = true;
                            updateSelectColumn(that);
                            if (isSelectColumnVisible === that.isSelectColumnVisible() && that.option(SHOW_CHECKBOXES_MODE) === "onClick")
                                updateSelectedItems(that);
                            return true
                        }
                        return false
                    },
                    stopSelectionWithCheckboxes: function() {
                        var that = this;
                        if (that._isSelectionWithCheckboxes) {
                            that._isSelectionWithCheckboxes = false;
                            updateSelectColumn(that);
                            return true
                        }
                        return false
                    }
                }
        }());
        $.extend(dataGrid.__internals, {DATAGRID_CHECKBOXES_HIDDEN_CLASS: DATAGRID_CHECKBOXES_HIDDEN_CLASS});
        dataGrid.registerModule("selection", {
            defaultOptions: function() {
                return {
                        selection: {
                            mode: "none",
                            showCheckBoxesMode: "onClick",
                            allowSelectAll: true
                        },
                        selectedRowKeys: []
                    }
            },
            controllers: {selection: dataGrid.SelectionController},
            extenders: {
                controllers: {
                    data: {
                        setDataSource: function(dataSource) {
                            this.callBase(dataSource);
                            if (dataSource)
                                this.getController("selection").refresh()
                        },
                        pageIndex: function(value) {
                            var that = this,
                                dataSource = that._dataSource;
                            if (dataSource && value && dataSource.pageIndex() !== value)
                                that.getController("selection").focusedItemIndex(-1);
                            return that.callBase(value)
                        },
                        _processDataItem: function(item, options) {
                            var that = this,
                                selectionController = that.getController("selection"),
                                hasSelectColumn = selectionController.isSelectColumnVisible(),
                                dataItem = this.callBase.apply(this, arguments);
                            dataItem.isSelected = selectionController.isRowSelected(dataItem.key);
                            if (hasSelectColumn && dataItem.values)
                                for (var i = 0; i < options.visibleColumns.length; i++)
                                    if (options.visibleColumns[i].command === "select") {
                                        dataItem.values[i] = dataItem.isSelected;
                                        break
                                    }
                            return dataItem
                        },
                        refresh: function() {
                            var that = this,
                                d = $.Deferred();
                            this.callBase.apply(this, arguments).done(function() {
                                that.getController("selection").refresh().done(d.resolve).fail(d.reject)
                            }).fail(d.reject);
                            return d.promise()
                        }
                    },
                    contextMenu: {_contextMenuPrepared: function(options) {
                            var jQueryEvent = options.jQueryEvent;
                            if (jQueryEvent.originalEvent.type !== "dxhold" || options.items && options.items.length > 0)
                                return;
                            processLongTap(this, jQueryEvent)
                        }}
                },
                views: {
                    columnHeadersView: {
                        init: function() {
                            var that = this;
                            that.callBase();
                            that.getController("selection").selectionChanged.add($.proxy(that._updateSelectAllValue, that))
                        },
                        _updateSelectAllValue: function() {
                            var that = this,
                                $editor = that.element().find("." + DATAGRID_SELECT_CHECKBOX_CLASS);
                            if (that.option("selection.mode") === "multiple" && $editor.length)
                                $editor.dxCheckBox("instance").option("value", that.getController("selection").isSelectAll())
                        },
                        _handleDataChanged: function(e) {
                            this.callBase(e);
                            if (!e || e.changeType === "refresh")
                                this._updateSelectAllValue()
                        },
                        _getDefaultTemplate: function(column) {
                            var that = this,
                                groupElement,
                                selectionController = that.getController("selection");
                            if (column.command === "select")
                                return function($cell, options) {
                                        var column = options.column;
                                        if (column.command === "select") {
                                            $cell.addClass(DATAGRID_EDITOR_CELL_CLASS);
                                            groupElement = $("<div />").appendTo($cell).addClass(DATAGRID_SELECT_CHECKBOX_CLASS);
                                            that.setAria("label", Globalize.localize("dxDataGrid-ariaSelectAll"), $cell);
                                            that.getController("editorFactory").createEditor(groupElement, $.extend({}, column, {
                                                parentType: "headerRow",
                                                value: selectionController.isSelectAll(),
                                                editorOptions: {visible: that.option("selection.allowSelectAll") || selectionController.isSelectAll() !== false},
                                                tabIndex: -1,
                                                setValue: function(value, e) {
                                                    var allowSelectAll = that.option("selection.allowSelectAll");
                                                    if (e.jQueryEvent && selectionController.isSelectAll() !== value) {
                                                        if (e.previousValue === undefined || e.previousValue) {
                                                            selectionController.deselectAll();
                                                            e.component.option("value", false)
                                                        }
                                                        if (e.previousValue === false)
                                                            if (allowSelectAll)
                                                                selectionController.selectAll();
                                                            else
                                                                e.component.option("value", false);
                                                        e.jQueryEvent.preventDefault()
                                                    }
                                                    e.component.option("visible", allowSelectAll || e.component.option("value") !== false)
                                                }
                                            }));
                                            $cell.on("dxclick", that.createAction(function(e) {
                                                var event = e.jQueryEvent;
                                                if (!$(event.target).closest("." + DATAGRID_SELECT_CHECKBOX_CLASS).length)
                                                    $(event.currentTarget).children().trigger("dxclick");
                                                event.preventDefault()
                                            }))
                                        }
                                    };
                            else
                                return that.callBase(column)
                        }
                    },
                    rowsView: {
                        _getDefaultTemplate: function(column) {
                            var that = this,
                                groupElement;
                            if (column.command === "select")
                                return function(container, options) {
                                        if (options.rowType === "data" && !options.row.inserted) {
                                            container.addClass(DATAGRID_EDITOR_CELL_CLASS);
                                            container.on("dxclick", that.createAction(function(e) {
                                                var selectionController = that.getController("selection"),
                                                    event = e.jQueryEvent,
                                                    rowIndex = that.getRowIndex($(event.currentTarget).closest("." + DATAGRID_ROW_CLASS));
                                                if (rowIndex >= 0) {
                                                    selectionController.startSelectionWithCheckboxes();
                                                    selectionController.changeItemSelection(rowIndex, {shift: event.shiftKey})
                                                }
                                            }));
                                            that.setAria("label", Globalize.localize("dxDataGrid-ariaSelectRow"), container);
                                            groupElement = $("<div />").addClass(DATAGRID_SELECT_CHECKBOX_CLASS).appendTo(container);
                                            that.getController("editorFactory").createEditor(groupElement, $.extend({}, column, {
                                                parentType: "dataRow",
                                                value: options.value,
                                                tabIndex: -1,
                                                setValue: function(value, e) {
                                                    if (e && e.jQueryEvent && e.jQueryEvent.type === "keydown")
                                                        container.trigger("dxclick", e)
                                                }
                                            }))
                                        }
                                    };
                            else
                                return that.callBase(column)
                        },
                        _update: function(change) {
                            var that = this,
                                tableElements = that.getTableElements();
                            if (change.changeType === "updateSelection") {
                                if (tableElements.length > 0) {
                                    $.each(tableElements, function(_, tableElement) {
                                        $.each(change.itemIndexes || [], function(_, index) {
                                            var $row,
                                                isSelected;
                                            if (change.items[index]) {
                                                $row = that._getRowElements($(tableElement)).eq(index);
                                                isSelected = !!change.items[index].isSelected;
                                                $row.toggleClass(DATAGRID_ROW_SELECTION_CLASS, isSelected).find("." + DATAGRID_SELECT_CHECKBOX_CLASS).dxCheckBox("option", "value", isSelected);
                                                that.setAria("selected", isSelected, $row)
                                            }
                                        })
                                    });
                                    that._updateCheckboxesClass()
                                }
                            }
                            else
                                that.callBase(change)
                        },
                        _createTable: function() {
                            var that = this,
                                selectionMode = that.option("selection.mode"),
                                $table = that.callBase.apply(that, arguments);
                            if (selectionMode !== "none") {
                                if (that.option(SHOW_CHECKBOXES_MODE) === "onLongTap" || !support.touch)
                                    $table.on(eventUtils.addNamespace("dxhold", "dxDataGridRowsView"), "." + DATAGRID_DATA_ROW_CLASS, that.createAction(function(e) {
                                        processLongTap(that.component, e.jQueryEvent);
                                        e.jQueryEvent.stopPropagation()
                                    }));
                                $table.on("mousedown selectstart", that.createAction(function(e) {
                                    var event = e.jQueryEvent;
                                    if (event.shiftKey)
                                        event.preventDefault()
                                }))
                            }
                            return $table
                        },
                        _createRow: function(row) {
                            var $row = this.callBase(row),
                                isSelected;
                            if (row) {
                                isSelected = !!row.isSelected;
                                $row.toggleClass(DATAGRID_ROW_SELECTION_CLASS, isSelected);
                                this.setAria("selected", isSelected, $row)
                            }
                            return $row
                        },
                        _rowClick: function(e) {
                            var that = this,
                                jQueryEvent = e.jQueryEvent,
                                isCommandSelect = $(jQueryEvent.target).closest("." + DATAGRID_COMMAND_SELECT_CLASS).length,
                                isSelectionDisabled = $(jQueryEvent.target).closest("." + DATAGRID_SELECTION_DISABLED_CLASS).length;
                            if (!isCommandSelect) {
                                if (!isSelectionDisabled && (that.option(SELECTION_MODE) !== "multiple" || that.option(SHOW_CHECKBOXES_MODE) !== "always"))
                                    if (that.getController("selection").changeItemSelection(e.rowIndex, {
                                        control: jQueryEvent.ctrlKey,
                                        shift: jQueryEvent.shiftKey
                                    })) {
                                        jQueryEvent.preventDefault();
                                        e.handled = true
                                    }
                                that.callBase(e)
                            }
                        },
                        _renderCore: function(change) {
                            this.callBase(change);
                            this._updateCheckboxesClass()
                        },
                        _updateCheckboxesClass: function() {
                            var tableElements = this.getTableElements(),
                                selectionController = this.getController("selection"),
                                isCheckBoxesHidden = selectionController.isSelectColumnVisible() && !selectionController.isSelectionWithCheckboxes();
                            $.each(tableElements, function(_, tableElement) {
                                $(tableElement).toggleClass(DATAGRID_CHECKBOXES_HIDDEN_CLASS, isCheckBoxesHidden)
                            })
                        }
                    }
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.editorFactory.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            browser = DX.require("/utils/utils.browser"),
            devices = DX.require("/devices"),
            positionUtils = DX.require("/utils/utils.position"),
            defaultDateTimeFormat = DX.require("/utils/utils.formatHelper").defaultDateTimeFormat,
            commonUtils = DX.require("/utils/utils.common"),
            knockoutUtils = DX.require("/utils/utils.knockout"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer"),
            addNamespace = eventUtils.addNamespace;
        var DATAGRID_CHECKBOX_SIZE_CLASS = "dx-datagrid-checkbox-size",
            DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
            DATAGRID_EDITOR_INLINE_BLOCK = "dx-editor-inline-block",
            DATAGRID_MODULE_NAMESPACE = "dxDataGridEditorFactory",
            DATAGRID_UPDATE_FOCUS_EVENTS = addNamespace(pointerEvents.down + " focusin dxclick", DATAGRID_MODULE_NAMESPACE),
            DATAGRID_FOCUS_OVERLAY_CLASS = "dx-datagrid-focus-overlay",
            DATAGRID_FOCUSED_ELEMENT_CLASS = "dx-focused",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target",
            DATAGRID_POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
            DX_HIDDEN = "dx-hidden",
            TAB_KEY = 9;
        dataGrid.EditorFactoryController = dataGrid.ViewController.inherit(function() {
            var getResultConfig = function(config, options) {
                    return $.extend(config, {
                            readOnly: options.readOnly,
                            placeholder: options.placeholder,
                            attr: {id: options.id}
                        }, options.editorOptions)
                };
            var getTextEditorConfig = function(options) {
                    var isEnterBug = browser.msie && parseInt(browser.version) <= 11 || devices.real().ios,
                        isValueChanged = false,
                        data = {},
                        sharedData = options.sharedData || data;
                    return getResultConfig({
                            placeholder: options.placeholder,
                            width: options.width,
                            value: options.value,
                            onValueChanged: function(e) {
                                var updateValue = function(e, notFireEvent) {
                                        isValueChanged = false;
                                        options && options.setValue(e.value, notFireEvent)
                                    };
                                window.clearTimeout(data.valueChangeTimeout);
                                if (e.jQueryEvent && e.jQueryEvent.type === "keyup")
                                    if (options.parentType === "filterRow" || options.parentType === "searchPanel")
                                        sharedData.valueChangeTimeout = data.valueChangeTimeout = window.setTimeout(function() {
                                            updateValue(e, data.valueChangeTimeout !== sharedData.valueChangeTimeout)
                                        }, commonUtils.isDefined(options.updateValueTimeout) ? options.updateValueTimeout : 0);
                                    else
                                        isValueChanged = true;
                                else
                                    updateValue(e)
                            },
                            onFocusOut: function(e) {
                                if (isEnterBug && isValueChanged) {
                                    isValueChanged = false;
                                    options.setValue(e.component.option("value"))
                                }
                            },
                            onKeyDown: function(e) {
                                if (isEnterBug && isValueChanged && e.jQueryEvent.keyCode === 13) {
                                    isValueChanged = false;
                                    options.setValue(e.component.option("value"))
                                }
                            },
                            valueChangeEvent: "change" + (options.parentType === "filterRow" || isEnterBug ? " keyup" : "")
                        }, options)
                };
            var prepareDateBox = function(options) {
                    options.editorName = "dxDateBox";
                    options.editorOptions = getResultConfig({
                        value: options.value,
                        onValueChanged: function(args) {
                            options.setValue(args.value)
                        },
                        formatString: commonUtils.isString(options.format) && defaultDateTimeFormat[options.format.toLowerCase()] || options.format,
                        formatWidthCalculator: null,
                        width: "auto"
                    }, options)
                };
            var prepareTextBox = function(options) {
                    var config = getTextEditorConfig(options),
                        isSearching = options.parentType === "searchPanel",
                        toString = function(value) {
                            return commonUtils.isDefined(value) ? value.toString() : ""
                        };
                    config.value = toString(options.value);
                    config.valueChangeEvent += isSearching ? " keyup search" : "";
                    config.mode = isSearching ? "search" : "text";
                    options.editorName = "dxTextBox";
                    options.editorOptions = config
                };
            var prepareNumberBox = function(options) {
                    var config = getTextEditorConfig(options);
                    config.value = commonUtils.isDefined(options.value) ? options.value : null;
                    options.editorName = "dxNumberBox";
                    options.editorOptions = config
                };
            var prepareBooleanEditor = function(options) {
                    if (options.parentType === "filterRow")
                        prepareSelectBox($.extend(options, {lookup: {
                                displayExpr: function(data) {
                                    if (data === true)
                                        return options.trueText || "true";
                                    else if (data === false)
                                        return options.falseText || "false"
                                },
                                dataSource: [true, false]
                            }}));
                    else
                        prepareCheckBox(options)
                };
            var prepareSelectBox = function(options) {
                    var lookup = options.lookup,
                        displayGetter,
                        dataSource,
                        postProcess,
                        isFilterRow = options.parentType === "filterRow";
                    if (lookup) {
                        displayGetter = DX.data.utils.compileGetter(lookup.displayExpr);
                        dataSource = lookup.dataSource;
                        if (commonUtils.isFunction(dataSource) && !knockoutUtils.isObservable(dataSource))
                            dataSource = dataSource(options.row || {});
                        if (commonUtils.isObject(dataSource) || commonUtils.isArray(dataSource)) {
                            dataSource = DX.data.utils.normalizeDataSourceOptions(dataSource);
                            if (isFilterRow) {
                                postProcess = dataSource.postProcess;
                                dataSource.postProcess = function(items) {
                                    if (this.pageIndex() === 0) {
                                        items = items.slice(0);
                                        items.unshift(null)
                                    }
                                    if (postProcess)
                                        return postProcess.call(this, items);
                                    return items
                                }
                            }
                        }
                        options.editorName = "dxSelectBox";
                        options.editorOptions = getResultConfig({
                            searchEnabled: true,
                            value: options.value,
                            valueExpr: options.lookup.valueExpr,
                            searchExpr: options.lookup.searchExpr || options.lookup.displayExpr,
                            showClearButton: Boolean(lookup.allowClearing && !isFilterRow),
                            displayExpr: function(data) {
                                if (data === null)
                                    return options.showAllText;
                                return displayGetter(data)
                            },
                            dataSource: dataSource,
                            onValueChanged: function(e) {
                                var params = [e.value];
                                !isFilterRow && params.push(e.component.option("text"));
                                options.setValue.apply(this, params)
                            }
                        }, options)
                    }
                };
            var prepareCheckBox = function(options) {
                    options.editorName = "dxCheckBox";
                    options.editorOptions = getResultConfig({
                        value: options.value,
                        hoverStateEnabled: !options.readOnly,
                        focusStateEnabled: !options.readOnly,
                        activeStateEnabled: false,
                        onValueChanged: function(e) {
                            options.setValue && options.setValue(e.value, e)
                        },
                        tabIndex: options.tabIndex ? options.tabIndex : 0
                    }, options)
                };
            var createEditorCore = function(that, options) {
                    if (options.editorName && options.editorOptions && options.editorElement[options.editorName]) {
                        if (options.editorName === "dxCheckBox")
                            options.editorElement.addClass(DATAGRID_CHECKBOX_SIZE_CLASS);
                        that._createComponent(options.editorElement, options.editorName, options.editorOptions);
                        if (options.editorName === "dxTextBox")
                            options.editorElement.dxTextBox("instance").registerKeyHandler("enter", $.noop)
                    }
                };
            return {
                    _getFocusedElement: function($dataGridElement) {
                        return $dataGridElement.find("[tabindex]:focus, input:focus")
                    },
                    _updateFocusCore: function() {
                        var $focus = this._$focusedElement,
                            $dataGridElement = this.component && this.component.element(),
                            $focusCell,
                            hideBorders;
                        if ($dataGridElement) {
                            $focus = this._getFocusedElement($dataGridElement);
                            if ($focus.length) {
                                if (!$focus.hasClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS)) {
                                    $focusCell = $focus.closest(".dx-row > td, ." + DATAGRID_CELL_FOCUS_DISABLED_CLASS);
                                    hideBorders = $focusCell.get(0) !== $focus.get(0) && $focusCell.hasClass(DATAGRID_EDITOR_INLINE_BLOCK);
                                    $focus = $focusCell
                                }
                                if ($focus.length && !$focus.hasClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS)) {
                                    this.focus($focus, hideBorders);
                                    return
                                }
                            }
                        }
                        this.loseFocus()
                    },
                    _updateFocus: function(e) {
                        var that = this,
                            isFocusOverlay = e && e.jQueryEvent && $(e.jQueryEvent.target).hasClass(DATAGRID_FOCUS_OVERLAY_CLASS);
                        that._isFocusOverlay = that._isFocusOverlay || isFocusOverlay;
                        clearTimeout(that._updateFocusTimeoutID);
                        that._updateFocusTimeoutID = setTimeout(function() {
                            delete that._updateFocusTimeoutID;
                            if (!that._isFocusOverlay)
                                that._updateFocusCore();
                            that._isFocusOverlay = false
                        })
                    },
                    _updateFocusOverlaySize: function($element, position) {
                        var location = positionUtils.calculate($element, $.extend({collision: "fit"}, position));
                        if (location.h.oversize > 0)
                            $element.outerWidth($element.outerWidth() - location.h.oversize);
                        if (location.v.oversize > 0)
                            $element.outerHeight($element.outerHeight() - location.v.oversize)
                    },
                    callbackNames: function() {
                        return ["focused"]
                    },
                    focus: function($element, hideBorder) {
                        var that = this;
                        if ($element === undefined)
                            return that._$focusedElement;
                        else if ($element)
                            setTimeout(function() {
                                var $focusOverlay = that._$focusOverlay = that._$focusOverlay || $("<div>").addClass(DATAGRID_FOCUS_OVERLAY_CLASS + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS),
                                    focusOverlayPosition;
                                if (hideBorder)
                                    that._$focusOverlay && that._$focusOverlay.addClass(DX_HIDDEN);
                                else {
                                    var align = browser.msie ? "left bottom" : browser.mozilla ? "right bottom" : "left top",
                                        $content = $element.closest("." + DATAGRID_CONTENT_CLASS);
                                    $focusOverlay.removeClass(DX_HIDDEN).appendTo($content).outerWidth($element.outerWidth() + 1).outerHeight($element.outerHeight() + 1);
                                    focusOverlayPosition = {
                                        my: align,
                                        at: align,
                                        of: $element,
                                        boundary: $content.length && $content
                                    };
                                    that._updateFocusOverlaySize($focusOverlay, focusOverlayPosition);
                                    positionUtils.setup($focusOverlay, focusOverlayPosition);
                                    $focusOverlay.css("visibility", "visible")
                                }
                                that._$focusedElement && that._$focusedElement.removeClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
                                $element.addClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
                                that._$focusedElement = $element;
                                that.focused.fire($element)
                            })
                    },
                    resize: function() {
                        var $focusedElement = this._$focusedElement;
                        if ($focusedElement)
                            this.focus($focusedElement)
                    },
                    loseFocus: function() {
                        this._$focusedElement && this._$focusedElement.removeClass(DATAGRID_FOCUSED_ELEMENT_CLASS);
                        this._$focusedElement = null;
                        this._$focusOverlay && this._$focusOverlay.addClass(DX_HIDDEN)
                    },
                    init: function() {
                        this.createAction("onEditorPreparing", {
                            excludeValidators: ["designMode", "disabled", "readOnly"],
                            category: "rendering"
                        });
                        this.createAction("onEditorPrepared", {
                            excludeValidators: ["designMode", "disabled", "readOnly"],
                            category: "rendering"
                        });
                        this._updateFocusHandler = this._updateFocusHandler || this.createAction($.proxy(this._updateFocus, this));
                        $(document).on(DATAGRID_UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
                        this._attachContainerEventHandlers()
                    },
                    _attachContainerEventHandlers: function() {
                        var that = this,
                            $container = that.component && that.component.element(),
                            isIE10OrLower = browser.msie && parseInt(browser.version) < 11;
                        if ($container) {
                            $container.on(addNamespace("keydown", DATAGRID_MODULE_NAMESPACE), function(e) {
                                if (e.which === TAB_KEY)
                                    that._updateFocusHandler(e)
                            });
                            isIE10OrLower && $container.on([pointerEvents.down, pointerEvents.up, "dxclick"].join(" "), "." + DATAGRID_POINTER_EVENTS_TARGET_CLASS, $.proxy(that._focusOverlayEventProxy, that))
                        }
                    },
                    _focusOverlayEventProxy: function(e) {
                        var $target = $(e.target),
                            $currentTarget = $(e.currentTarget),
                            element,
                            needProxy = $target.hasClass(DATAGRID_POINTER_EVENTS_TARGET_CLASS) || $target.hasClass(DATAGRID_POINTER_EVENTS_NONE_CLASS),
                            $focusedElement = this._$focusedElement;
                        if (!needProxy || $currentTarget.hasClass(DX_HIDDEN))
                            return;
                        $currentTarget.addClass(DX_HIDDEN);
                        element = $target.get(0).ownerDocument.elementFromPoint(e.clientX, e.clientY);
                        eventUtils.fireEvent({
                            originalEvent: e,
                            target: element
                        });
                        e.stopPropagation();
                        $currentTarget.removeClass(DX_HIDDEN);
                        $focusedElement && $focusedElement.find("input").focus()
                    },
                    dispose: function() {
                        clearTimeout(this._updateFocusTimeoutID);
                        $(document).off(DATAGRID_UPDATE_FOCUS_EVENTS, this._updateFocusHandler)
                    },
                    createEditor: function($container, options) {
                        options.cancel = false;
                        options.editorElement = $container;
                        if (options.lookup)
                            prepareSelectBox(options);
                        else
                            switch (options.dataType) {
                                case"date":
                                    prepareDateBox(options);
                                    break;
                                case"boolean":
                                    prepareBooleanEditor(options);
                                    break;
                                case"number":
                                    prepareNumberBox(options);
                                    break;
                                default:
                                    prepareTextBox(options);
                                    break
                            }
                        this.executeAction("onEditorPreparing", options);
                        if (options.cancel)
                            return;
                        createEditorCore(this, options);
                        this.executeAction("onEditorPrepared", options)
                    }
                }
        }());
        $.extend(dataGrid.__internals, {DATAGRID_FOCUSED_ELEMENT_CLASS: DATAGRID_FOCUSED_ELEMENT_CLASS});
        dataGrid.registerModule("editorFactory", {
            defaultOptions: function() {
                return {}
            },
            controllers: {editorFactory: dataGrid.EditorFactoryController},
            extenders: {controllers: {columnsResizer: {_startResizing: function(args) {
                            this.callBase(args);
                            if (this.isResizing())
                                this.getController("editorFactory").loseFocus()
                        }}}}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnsView.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            browser = DX.require("/utils/utils.browser"),
            commonUtils = DX.require("/utils/utils.common"),
            devices = DX.require("/devices"),
            dataGrid = ui.dxDataGrid;
        var DATAGRID_SCROLL_CONTAINER_CLASS = "dx-datagrid-scroll-container",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_GROUP_SPACE_CLASS = "dx-datagrid-group-space",
            DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
            DATAGRID_DETAIL_ROW_CLASS = "dx-master-detail-row",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_COLUMN_INDICATORS_CLASS = "dx-column-indicators",
            DATAGRID_TABLE_FIXED_CLASS = "dx-datagrid-table-fixed",
            DATAGRID_INDICATOR_ALIGNMENT_CLASS = "dx-indicator-alignment-",
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            DATAGRID_CELL_HINT_VISIBLE = "dxCellHintVisible",
            indicatorNamesClass = {
                sort: "dx-sort",
                headerFilter: "dx-header-filter"
            };
        var appendElementTemplate = {render: function(element, container) {
                    container.append(element)
                }};
        dataGrid.getWidths = function($tableElement) {
            var cells,
                result = [],
                width,
                clientRect;
            if ($tableElement) {
                cells = $tableElement.children("tbody").children("tr").filter(":not(." + DATAGRID_GROUP_ROW_CLASS + ")").filter(":not(." + DATAGRID_DETAIL_ROW_CLASS + ")").first().find("> td");
                $.each(cells, function(index, item) {
                    width = item.offsetWidth;
                    if (item.getBoundingClientRect) {
                        clientRect = item.getBoundingClientRect();
                        if (clientRect.width > width)
                            width = Math.ceil(clientRect.width)
                    }
                    result.push(width)
                })
            }
            return result
        };
        dataGrid.ColumnsView = dataGrid.View.inherit({
            _getColumnAlignment: function(alignment, rtlEnabled) {
                rtlEnabled = rtlEnabled || this.option("rtlEnabled");
                return alignment !== "center" ? alignment : commonUtils.getDefaultAlignment(rtlEnabled)
            },
            _applyColumnState: function(options) {
                var that = this,
                    rtlEnabled = this.option("rtlEnabled"),
                    columnAlignment = that._getColumnAlignment(options.column.alignment, rtlEnabled),
                    parameters = $.extend(true, {columnAlignment: columnAlignment}, options),
                    $indicatorsContainer = that._createIndicatorContainer(parameters),
                    $span = $("<span />").addClass(indicatorNamesClass[options.name]),
                    getIndicatorAlignment = function() {
                        if (rtlEnabled)
                            return columnAlignment === "left" ? "right" : "left";
                        return columnAlignment
                    };
                parameters.container = $indicatorsContainer;
                parameters.indicator = $span;
                that._renderIndicator(parameters);
                $indicatorsContainer[!options.showColumnLines && getIndicatorAlignment() === "left" ? "appendTo" : "prependTo"](options.rootElement).addClass(DATAGRID_INDICATOR_ALIGNMENT_CLASS + columnAlignment);
                return $span
            },
            _createIndicatorContainer: function(options) {
                var $indicatorsContainer = options.rootElement.find("." + DATAGRID_COLUMN_INDICATORS_CLASS),
                    indicatorAlignment = options.columnAlignment === "left" ? "right" : "left";
                if (!$indicatorsContainer.length)
                    $indicatorsContainer = $("<div/>").addClass(DATAGRID_COLUMN_INDICATORS_CLASS);
                return $indicatorsContainer.css("float", options.showColumnLines ? indicatorAlignment : null)
            },
            _getIndicatorContainer: function($cell) {
                return $cell && $cell.find("." + DATAGRID_COLUMN_INDICATORS_CLASS)
            },
            _renderIndicator: function(options) {
                var $container = options.container,
                    $indicator = options.indicator;
                $container && $indicator && $container.append($indicator)
            },
            _updateIndicators: function(indicatorName) {
                var that = this,
                    columns = that.getColumns(),
                    $cells = that.getColumnElements(),
                    $cell,
                    i;
                for (i = 0; i < columns.length; i++) {
                    $cell = $cells.eq(i);
                    that._updateIndicator($cell, columns[i], indicatorName)
                }
            },
            _updateIndicator: function($cell, column, indicatorName) {
                if (!column.command)
                    return this._applyColumnState({
                            name: indicatorName,
                            rootElement: $cell,
                            column: column,
                            showColumnLines: this.option("showColumnLines")
                        })
            },
            _updateCell: function($cell, parameters) {
                if (parameters.rowType)
                    this._cellPrepared($cell, parameters)
            },
            _createCell: function(column) {
                var defaultAlignment = commonUtils.getDefaultAlignment(this.option("rtlEnabled")),
                    alignment = column.alignment || defaultAlignment;
                var cell = window.document.createElement("td");
                cell.style.textAlign = alignment;
                var $cell = $(cell);
                this.setAria("role", "gridcell", $cell);
                if (!commonUtils.isDefined(column.groupIndex) && column.cssClass)
                    $cell.addClass(column.cssClass);
                if (column.command === "expand")
                    $cell.addClass(DATAGRID_GROUP_SPACE_CLASS);
                return $cell
            },
            _createRow: function(row) {
                return $("<tr />").addClass(DATAGRID_ROW_CLASS).attr("role", "row")
            },
            _createTable: function(columns) {
                var that = this,
                    $table = $("<table />").addClass(DATAGRID_TABLE_CLASS).addClass(DATAGRID_TABLE_FIXED_CLASS).attr("role", "grid");
                if (columns) {
                    $table.append(that._createColGroup(columns));
                    if (devices.real().ios)
                        $table.append("<thead><tr></tr></thead>")
                }
                if (browser.mozilla)
                    $table.on("mousedown", "td", function(e) {
                        if (e.ctrlKey)
                            e.preventDefault()
                    });
                if (that.option("cellHintEnabled"))
                    $table.on("mousemove", ".dx-row > td", this.createAction(function(args) {
                        var e = args.jQueryEvent,
                            $element = $(e.target),
                            $cell = $(e.currentTarget),
                            $row = $cell.parent(),
                            isDataRow = $row.hasClass("dx-data-row"),
                            isHeaderRow = $row.hasClass("dx-header-row"),
                            isGroupRow = $row.hasClass("dx-group-row"),
                            visibleColumns = that._columnsController.getVisibleColumns(),
                            rowOptions = $row.data("options"),
                            columnIndex = $cell.index(),
                            cellOptions = rowOptions && rowOptions.cells && rowOptions.cells[columnIndex],
                            column = cellOptions ? cellOptions.column : visibleColumns[columnIndex];
                        if ((!isDataRow || isDataRow && column && !column.cellTemplate) && (!isHeaderRow || isHeaderRow && column && !column.headerCellTemplate) && (!isGroupRow || isGroupRow && column && (column.groupIndex === undefined || !column.groupCellTemplate))) {
                            if ($element.data(DATAGRID_CELL_HINT_VISIBLE)) {
                                $element.removeAttr("title");
                                $element.data(DATAGRID_CELL_HINT_VISIBLE, false)
                            }
                            if ($element[0].scrollWidth > $element[0].clientWidth && !commonUtils.isDefined($element.attr("title"))) {
                                $element.attr("title", $element.text());
                                $element.data(DATAGRID_CELL_HINT_VISIBLE, true)
                            }
                        }
                    }));
                var getOptions = function(event) {
                        var cellElement = $(event.currentTarget),
                            rowOptions = cellElement.parent().data("options"),
                            options = rowOptions && rowOptions.cells && rowOptions.cells[cellElement.index()];
                        return $.extend({}, options, {
                                cellElement: cellElement,
                                jQueryEvent: event,
                                eventType: event.type
                            })
                    };
                if (that.option("onCellHoverChanged")) {
                    $table.on("mouseover", ".dx-row > td", function(e) {
                        that.executeAction("onCellHoverChanged", getOptions(e))
                    });
                    $table.on("mouseout", ".dx-row > td", function(e) {
                        that.executeAction("onCellHoverChanged", getOptions(e))
                    })
                }
                if (that.option("onCellClick"))
                    $table.on("dxclick", ".dx-row > td", function(e) {
                        that.executeAction("onCellClick", getOptions(e))
                    });
                $table.on("dxclick", ".dx-row", {useNative: that._isNativeClick()}, that.createAction(function(e) {
                    var jQueryEvent = e.jQueryEvent;
                    if (!$(jQueryEvent.target).closest("a").length) {
                        e.rowIndex = that.getRowIndex(jQueryEvent.currentTarget);
                        e.rowElement = $(jQueryEvent.currentTarget);
                        e.columns = that.getColumns();
                        that._rowClick(e)
                    }
                }));
                return $table
            },
            _isNativeClick: $.noop,
            _rowClick: $.noop,
            _createColGroup: function(columns) {
                var i,
                    j,
                    colgroupElement = $("<colgroup />"),
                    colspan,
                    columnsLength = columns.length;
                for (i = 0; i < columnsLength; i++) {
                    colspan = columns[i].colspan || 1;
                    for (j = 0; j < colspan; j++)
                        colgroupElement.append(this._createCol(columns[i]))
                }
                return colgroupElement
            },
            _createCol: function(column) {
                return $("<col />").width(column.visibleWidth || column.width)
            },
            renderDelayedTemplates: function() {
                var templateParameters,
                    delayedTemplates = this._delayedTemplates;
                while (delayedTemplates.length) {
                    templateParameters = delayedTemplates.shift();
                    templateParameters.template.render(templateParameters.options, templateParameters.container);
                    if (templateParameters.options.column)
                        this._updateCell(templateParameters.container, templateParameters.options)
                }
            },
            _processTemplate: function(template, options) {
                var that = this,
                    templateID,
                    renderingTemplate;
                if (template && template.render)
                    renderingTemplate = {
                        allowRenderToDetachedContainer: template.allowRenderToDetachedContainer,
                        render: function(options, container) {
                            template.render(container, options)
                        }
                    };
                else if ($.isFunction(template))
                    renderingTemplate = {render: function(options, container) {
                            template(container, options)
                        }};
                else {
                    templateID = commonUtils.isString(template) ? template : $(template).attr("id");
                    if (!templateID)
                        renderingTemplate = that.getTemplate(template);
                    else {
                        if (!that._templatesCache[templateID])
                            that._templatesCache[templateID] = that.getTemplate(template);
                        renderingTemplate = that._templatesCache[templateID]
                    }
                }
                return renderingTemplate
            },
            _renderTemplate: function(container, template, options) {
                var that = this,
                    renderingTemplate = that._processTemplate(template, options);
                if (renderingTemplate)
                    if (renderingTemplate.allowRenderToDetachedContainer) {
                        renderingTemplate.render(options, container);
                        return true
                    }
                    else
                        that._delayedTemplates.push({
                            template: renderingTemplate,
                            container: container,
                            options: options
                        });
                return false
            },
            _appendRow: function($table, $row, appendTemplate) {
                var that = this;
                if (that.option("rowTemplate") && that._delayedTemplates.length && $row)
                    that._delayedTemplates.push({
                        container: $table,
                        template: appendTemplate || appendElementTemplate,
                        options: $row
                    });
                else
                    $table.append($row)
            },
            _resizeCore: function() {
                var that = this,
                    scrollLeft = that._scrollLeft;
                that._scrollLeft = 0;
                that.scrollTo({left: scrollLeft})
            },
            _renderCore: function(change) {
                var $root = this.element().parent();
                if (!$root || $root.parent().length)
                    this.renderDelayedTemplates()
            },
            _renderTable: function(options) {
                options = options || {};
                var that = this,
                    $table;
                options.columns = that._columnsController.getVisibleColumns();
                $table = that._createTable(options.columns);
                that._renderRows($table, options);
                return $table
            },
            _renderRows: function($table, options) {
                var that = this,
                    i,
                    rows = that._getRows(options.change);
                for (i = 0; i < rows.length; i++)
                    that._renderRow($table, $.extend({row: rows[i]}, options))
            },
            _renderRow: function($table, options) {
                var that = this,
                    $row;
                options.row.cells = [];
                $row = that._createRow(options.row);
                that._renderCells($row, options);
                that._appendRow($table, $row);
                that._rowPrepared($row, $.extend({columns: options.columns}, options.row))
            },
            _renderCells: function($row, options) {
                var that = this,
                    i,
                    columnIndex = 0,
                    row = options.row,
                    columns = options.columns;
                for (i = 0; i < columns.length; i++) {
                    that._renderCell($row, $.extend({
                        column: columns[i],
                        columnIndex: columnIndex,
                        value: row.values && row.values[columnIndex]
                    }, options));
                    if (commonUtils.isDefined(columns[i].colspan))
                        columnIndex += columns[i].colspan;
                    else
                        columnIndex++
                }
            },
            _renderCell: function($row, options) {
                var that = this,
                    cellOptions = that._getCellOptions(options),
                    column = options.column,
                    $cell;
                options.row.cells.push(cellOptions);
                $cell = that._createCell(column);
                if (!commonUtils.isDefined(column.command))
                    that.setAria("label", that.localize("dxDataGrid-ariaColumn") + " " + column.caption + ", " + that.localize("dxDataGrid-ariaValue") + " " + cellOptions.text, $cell);
                that._renderCellContent($cell, cellOptions);
                $row.get(0).appendChild($cell.get(0));
                return $cell
            },
            _renderCellContent: function($cell, options) {
                var template = this._getCellTemplate(options);
                if (!template || this._renderTemplate($cell, template, options))
                    this._updateCell($cell, options)
            },
            _getCellTemplate: function(options){},
            _getRows: function() {
                return []
            },
            _getCellOptions: function(options) {
                return {
                        column: options.column,
                        columnIndex: options.columnIndex,
                        rowType: options.row.rowType
                    }
            },
            _cellPrepared: function($cell, options) {
                options.cellElement = $cell;
                this.executeAction("onCellPrepared", options)
            },
            _rowPrepared: function($row, options) {
                $row.data("options", options);
                options.rowElement = $row;
                this.executeAction("onRowPrepared", options)
            },
            _columnOptionChanged: function(e) {
                var optionNames = e.optionNames;
                if (dataGrid.checkChanges(optionNames, ["width", "visibleWidth"])) {
                    var visibleColumns = this._columnsController.getVisibleColumns();
                    var widths = $.map(visibleColumns, function(column) {
                            return column.visibleWidth || column.width || "auto"
                        });
                    this.setColumnWidths(widths);
                    return
                }
                if (!this._requireReady)
                    this.render()
            },
            getTableElements: function() {
                return this._tableElement || $()
            },
            _getTableElement: function() {
                return this._tableElement
            },
            _setTableElement: function(tableElement) {
                this._tableElement = tableElement
            },
            optionChanged: function(args) {
                this.callBase(args);
                switch (args.name) {
                    case"cellHintEnabled":
                    case"onCellPrepared":
                    case"onRowPrepared":
                    case"onCellHoverChanged":
                        this._invalidate(true, true);
                        args.handled = true;
                        break
                }
            },
            init: function() {
                var that = this;
                that._scrollLeft = 0;
                that._columnsController = that.getController("columns");
                that._dataController = that.getController("data");
                that._delayedTemplates = [];
                that._templatesCache = {};
                that.createAction("onCellClick");
                that.createAction("onRowClick");
                that.createAction("onCellHoverChanged", {excludeValidators: ["disabled", "readOnly"]});
                that.createAction("onCellPrepared", {
                    excludeValidators: ["designMode", "disabled", "readOnly"],
                    category: "rendering"
                });
                that.createAction("onRowPrepared", {
                    excludeValidators: ["designMode", "disabled", "readOnly"],
                    category: "rendering",
                    afterExecute: function(e) {
                        that._afterRowPrepared(e)
                    }
                });
                that._columnsController.columnsChanged.add($.proxy(that._columnOptionChanged, that));
                that._dataController && that._dataController.changed.add($.proxy(that._handleDataChanged, that))
            },
            _afterRowPrepared: $.noop,
            _handleDataChanged: function(e){},
            callbackNames: function() {
                return ["scrollChanged"]
            },
            scrollTo: function(pos) {
                var that = this,
                    $element = that.element(),
                    $scrollContainer = $element && $element.find("." + DATAGRID_SCROLL_CONTAINER_CLASS);
                that._skipScrollChanged = false;
                if (commonUtils.isDefined(pos) && commonUtils.isDefined(pos.left) && that._scrollLeft !== pos.left) {
                    that._scrollLeft = pos.left;
                    $scrollContainer && $scrollContainer.scrollLeft(Math.round(pos.left));
                    that._skipScrollChanged = true
                }
            },
            _wrapTableInScrollContainer: function($table) {
                var that = this,
                    $scrollContainer;
                $scrollContainer = $("<div/>").on("scroll", function() {
                    !that._skipScrollChanged && that.scrollChanged.fire({left: $scrollContainer.scrollLeft()}, that.name);
                    that._skipScrollChanged = false
                }).addClass(DATAGRID_CONTENT_CLASS).addClass(DATAGRID_SCROLL_CONTAINER_CLASS).append($table).appendTo(that.element());
                return $scrollContainer
            },
            _updateContent: function($newTableElement) {
                this._setTableElement($newTableElement);
                this._wrapTableInScrollContainer($newTableElement)
            },
            _findContentElement: $.noop,
            getColumnWidths: function() {
                var that = this,
                    result = [],
                    tableElement = that._getTableElement();
                if (tableElement)
                    result = dataGrid.getWidths(tableElement);
                return result
            },
            setColumnWidths: function(widths) {
                var $cols,
                    i,
                    j,
                    columnIndex,
                    columns,
                    tableElements = this.getTableElements(true);
                if (tableElements.length && widths)
                    for (i = 0; i < tableElements.length; i++) {
                        columnIndex = 0;
                        $cols = $(tableElements[i]).find("col");
                        columns = this.getColumns($(tableElements[i]));
                        for (j = 0; j < columns.length; j++) {
                            if (columns[j].colspan) {
                                columnIndex += columns[j].colspan;
                                continue
                            }
                            $cols.eq(columnIndex).css("width", widths[columnIndex] || "auto");
                            columnIndex++
                        }
                    }
            },
            getCellElements: function(rowIndex) {
                var $row = this._getRowElements().eq(rowIndex);
                return $row.children()
            },
            getCellElement: function(rowIndex, columnIdentificator) {
                var that = this,
                    $cells = that.getCellElements(rowIndex),
                    $cell,
                    columnsController = that._columnsController,
                    columnIndex,
                    columnVisibleIndex = columnIdentificator;
                if (commonUtils.isString(columnIdentificator)) {
                    columnIndex = columnsController.columnOption(columnIdentificator, "index");
                    columnVisibleIndex = columnsController.getVisibleIndex(columnIndex)
                }
                if ($cells.length && columnVisibleIndex >= 0)
                    $cell = $cells.eq(columnVisibleIndex);
                if ($cell && $cell.length)
                    return $cell
            },
            getColumnElements: function(){},
            getColumns: function() {
                return this._columnsController.getVisibleColumns()
            },
            getCell: function(cellPosition, rows) {
                var $rows = rows || this._getRowElements(),
                    $cells;
                if ($rows.length > 0 && cellPosition.rowIndex >= 0) {
                    cellPosition.rowIndex = cellPosition.rowIndex < $rows.length ? cellPosition.rowIndex : $rows.length - 1;
                    $cells = this.getCellElements(cellPosition.rowIndex);
                    if ($cells && $cells.length > 0)
                        return $cells.eq($cells.length > cellPosition.columnIndex ? cellPosition.columnIndex : $cells.length - 1)
                }
            },
            getRowsCount: function() {
                var tableElement = this._getTableElement();
                if (tableElement && tableElement.length === 1)
                    return tableElement[0].rows.length;
                return 0
            },
            _getRowElements: function(tableElement) {
                tableElement = tableElement || this._getTableElement();
                return tableElement && tableElement.children("tbody").children("." + DATAGRID_ROW_CLASS) || $()
            },
            getRowIndex: function($row) {
                return this._getRowElements().index($row)
            },
            getBoundingRect: function(){},
            getName: function(){},
            setScrollerSpacing: function(width) {
                var that = this,
                    $element = that.element(),
                    rtlEnabled = that.option("rtlEnabled");
                $element && $element.css(rtlEnabled ? {paddingLeft: width} : {paddingRight: width})
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_INDICATOR_ALIGNMENT_CLASS: DATAGRID_INDICATOR_ALIGNMENT_CLASS,
            DATAGRID_GROUP_SPACE_CLASS: DATAGRID_GROUP_SPACE_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_ROW_CLASS: DATAGRID_ROW_CLASS,
            DATAGRID_GROUP_ROW_CLASS: DATAGRID_GROUP_ROW_CLASS,
            DATAGRID_TABLE_CLASS: DATAGRID_TABLE_CLASS,
            DATAGRID_TABLE_FIXED_CLASS: DATAGRID_TABLE_FIXED_CLASS,
            DATAGRID_SCROLL_CONTAINER_CLASS: DATAGRID_SCROLL_CONTAINER_CLASS,
            DATAGRID_COLUMN_INDICATORS_CLASS: DATAGRID_COLUMN_INDICATORS_CLASS,
            DATAGRID_HEADER_ROW_CLASS: DATAGRID_HEADER_ROW_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnChooserModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            themes = DX.require("/ui/ui.themes"),
            Button = DX.require("/ui/widgets/ui.button");
        var DATAGRID_COLUMN_CHOOSER_CLASS = "dx-datagrid-column-chooser",
            DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS = "dx-datagrid-column-chooser-button",
            DATAGRID_COLUMN_CHOOSER_ICON_NAME = "column-chooser",
            DATAGRID_COLUMN_CHOOSER_ITEM_CLASS = "dx-column-chooser-item",
            DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS = "dx-column-chooser-message",
            DATAGRID_NOTOUCH_ACTION_CLASS = "dx-datagrid-notouch-action",
            DATAGRID_HEADERS_DRAG_ACTION_CLASS = "dx-datagrid-drag-action";
        dataGrid.ColumnChooserController = dataGrid.ViewController.inherit({
            renderShowColumnChooserButton: function($element) {
                var that = this,
                    columnChooserEnabled = that.option("columnChooser.enabled"),
                    $showColumnChooserButton = $element.find("." + DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS),
                    $columnChooserButton;
                if (columnChooserEnabled)
                    if (!$showColumnChooserButton.length) {
                        $columnChooserButton = $("<div />").addClass(DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS).appendTo($element);
                        that._createComponent($columnChooserButton, Button, {
                            icon: DATAGRID_COLUMN_CHOOSER_ICON_NAME,
                            onClick: function() {
                                that.getView("columnChooserView").showColumnChooser()
                            },
                            hint: that.option("columnChooser.title"),
                            _templates: {}
                        })
                    }
                    else
                        $showColumnChooserButton.show();
                else
                    $showColumnChooserButton.hide()
            },
            getPosition: function() {
                var rowsView = this.getView("rowsView");
                return {
                        my: "right bottom",
                        at: "right bottom",
                        of: rowsView && rowsView.element(),
                        collision: "fit",
                        offset: "-2 -2",
                        boundaryOffset: "2 2"
                    }
            }
        });
        dataGrid.ColumnChooserView = dataGrid.ColumnsView.inherit({
            _resizeCore: $.noop,
            _isWinDevice: function() {
                return !!DX.devices.real().win
            },
            _updateItems: function() {
                var chooserColumns = this._columnsController.getChooserColumns(),
                    columnChooserOptions = this.option("columnChooser"),
                    $content = this._popupContainer.content(),
                    scrollOptions = dataGrid.createScrollableOptions(this),
                    scrollableInstance;
                if (this._isWinDevice())
                    scrollOptions.useNative = false;
                scrollableInstance = this._createComponent($content, "dxScrollable", scrollOptions);
                this._renderColumnChooserItems($content, chooserColumns);
                if (!chooserColumns.length)
                    $("<span />").addClass(DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS).text(columnChooserOptions ? columnChooserOptions.emptyPanelText : "").appendTo(scrollableInstance.content())
            },
            _initializePopupContainer: function() {
                var that = this,
                    $element = that.element().addClass(DATAGRID_COLUMN_CHOOSER_CLASS),
                    columnChooserOptions = that.option("columnChooser"),
                    theme = themes.current(),
                    isGenericTheme = theme && theme.indexOf("generic") > -1,
                    isAndroid5Theme = theme && theme.indexOf("android5") > -1,
                    dxPopupOptions = {
                        visible: false,
                        shading: false,
                        showCloseButton: false,
                        dragEnabled: true,
                        buttons: [{
                                text: columnChooserOptions.title,
                                toolbar: "top",
                                location: isGenericTheme || isAndroid5Theme ? "before" : "center"
                            }],
                        position: that.getController("columnChooser").getPosition(),
                        width: columnChooserOptions.width,
                        height: columnChooserOptions.height,
                        rtlEnabled: that.option("rtlEnabled"),
                        onHidden: function() {
                            if (that._isWinDevice())
                                $(document.body).removeClass(DATAGRID_NOTOUCH_ACTION_CLASS)
                        },
                        container: columnChooserOptions.container
                    };
                if (isGenericTheme)
                    $.extend(dxPopupOptions, {showCloseButton: true});
                else
                    dxPopupOptions.buttons[dxPopupOptions.buttons.length] = {shortcut: "cancel"};
                if (!commonUtils.isDefined(this._popupContainer)) {
                    that._popupContainer = that._createComponent($element, "dxPopup", dxPopupOptions);
                    that._popupContainer.on("optionChanged", function(args) {
                        if (args.name === "visible")
                            that.renderCompleted.fire()
                    })
                }
                else
                    this._popupContainer.option(dxPopupOptions)
            },
            _renderCore: function() {
                if (this._popupContainer)
                    this._updateItems()
            },
            _renderColumnChooserItems: function($container, chooserColumns) {
                var dxScrollable = $container.dxScrollable("instance"),
                    $scrollableContainer = dxScrollable.content(),
                    $item;
                $scrollableContainer.empty();
                $.each(chooserColumns, function(index, chooserColumn) {
                    $item = $("<div />").addClass(chooserColumn.cssClass).addClass(DATAGRID_COLUMN_CHOOSER_ITEM_CLASS).toggleClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS, chooserColumn.allowHiding).text(chooserColumn.caption).appendTo($scrollableContainer)
                });
                dxScrollable.update()
            },
            getColumnElements: function() {
                var $content = this._popupContainer && this._popupContainer.content();
                return $content && $content.find("." + DATAGRID_COLUMN_CHOOSER_ITEM_CLASS)
            },
            getName: function() {
                return "columnChooser"
            },
            getColumns: function() {
                return this._columnsController.getChooserColumns()
            },
            allowDragging: function(column) {
                return this.isColumnChooserVisible() && column && column.allowHiding
            },
            getBoundingRect: function() {
                var that = this,
                    container = that._popupContainer && that._popupContainer._container(),
                    offset;
                if (container && container.is(":visible")) {
                    offset = container.offset();
                    return {
                            left: offset.left,
                            top: offset.top,
                            right: offset.left + container.outerWidth(),
                            bottom: offset.top + container.outerHeight()
                        }
                }
                return null
            },
            showColumnChooser: function() {
                this._isPopupContainerShown = true;
                if (!this._popupContainer) {
                    this._initializePopupContainer();
                    this.render()
                }
                this._popupContainer.show();
                if (this._isWinDevice())
                    $(document.body).addClass(DATAGRID_NOTOUCH_ACTION_CLASS)
            },
            hideColumnChooser: function() {
                if (this._popupContainer) {
                    this._popupContainer.hide();
                    this._isPopupContainerShown = false
                }
            },
            isColumnChooserVisible: function() {
                var popupContainer = this._popupContainer;
                return popupContainer && popupContainer.option("visible")
            },
            publicMethods: function() {
                return ["showColumnChooser", "hideColumnChooser"]
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_COLUMN_CHOOSER_CLASS: DATAGRID_COLUMN_CHOOSER_CLASS,
            DATAGRID_COLUMN_CHOOSER_ITEM_CLASS: DATAGRID_COLUMN_CHOOSER_ITEM_CLASS,
            DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS: DATAGRID_COLUMN_CHOOSER_BUTTON_CLASS,
            DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS: DATAGRID_COLUMN_CHOOSER_MESSAGE_CLASS
        });
        dataGrid.registerModule("columnChooser", {
            defaultOptions: function() {
                return {columnChooser: {
                            enabled: false,
                            width: 250,
                            height: 260,
                            title: Globalize.localize("dxDataGrid-columnChooserTitle"),
                            emptyPanelText: Globalize.localize("dxDataGrid-columnChooserEmptyText"),
                            container: undefined
                        }}
            },
            controllers: {columnChooser: dataGrid.ColumnChooserController},
            views: {columnChooserView: dataGrid.ColumnChooserView},
            extenders: {views: {headerPanel: {
                        _renderShowColumnChooserButton: function() {
                            this.getController("columnChooser").renderShowColumnChooserButton(this.element())
                        },
                        _renderCore: function() {
                            this.callBase();
                            this._renderShowColumnChooserButton()
                        },
                        optionChanged: function(args) {
                            switch (args.name) {
                                case"columnChooser":
                                    this._renderShowColumnChooserButton();
                                    args.handled = true;
                                    break;
                                default:
                                    this.callBase(args)
                            }
                        },
                        isVisible: function() {
                            var that = this,
                                columnChooserEnabled = that.option("columnChooser.enabled");
                            return that.callBase() || columnChooserEnabled
                        }
                    }}}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.dataSourceAdapter.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid;
        function cloneItems(items, groupCount) {
            if (items) {
                items = items.slice(0);
                if (groupCount)
                    for (var i = 0; i < items.length; i++) {
                        items[i] = $.extend({key: items[i].key}, items[i]);
                        items[i].items = cloneItems(items[i].items, groupCount - 1)
                    }
            }
            return items
        }
        dataGrid.DataSourceAdapter = dataGrid.Controller.inherit(function() {
            function calculateOperationTypes(loadOptions, lastLoadOptions) {
                var operationTypes = {};
                if (lastLoadOptions) {
                    operationTypes = {
                        sorting: !dataGrid.equalSortParameters(loadOptions.sort, lastLoadOptions.sort),
                        grouping: !dataGrid.equalSortParameters(loadOptions.group, lastLoadOptions.group, true),
                        filtering: !dataGrid.equalFilterParameters(loadOptions.filter, lastLoadOptions.filter),
                        skip: loadOptions.skip !== lastLoadOptions.skip,
                        take: loadOptions.take !== lastLoadOptions.take
                    };
                    operationTypes.reload = operationTypes.sorting || operationTypes.grouping || operationTypes.filtering;
                    operationTypes.paging = operationTypes.skip || operationTypes.take
                }
                return operationTypes
            }
            return {
                    init: function(dataSource, remoteOperations) {
                        var that = this;
                        that._dataSource = dataSource;
                        that._remoteOperations = remoteOperations || {};
                        that._isLastPage = !dataSource.isLastPage();
                        that._hasLastPage = false;
                        that._currentTotalCount = 0;
                        that.changed = $.Callbacks();
                        that.loadingChanged = $.Callbacks();
                        that.loadError = $.Callbacks();
                        that.customizeStoreLoadOptions = $.Callbacks();
                        that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
                        that._dataLoadingHandler = $.proxy(that._handleDataLoading, that);
                        that._dataLoadedHandler = $.proxy(that._handleDataLoaded, that);
                        that._loadingChangedHandler = $.proxy(that._handleLoadingChanged, that);
                        that._loadErrorHandler = $.proxy(that._handleLoadError, that);
                        dataSource.on("changed", that._dataChangedHandler);
                        dataSource.on("customizeStoreLoadOptions", that._dataLoadingHandler);
                        dataSource.on("customizeLoadResult", that._dataLoadedHandler);
                        dataSource.on("loadingChanged", that._loadingChangedHandler);
                        dataSource.on("loadError", that._loadErrorHandler);
                        $.each(dataSource, function(memberName, member) {
                            if (!that[memberName] && $.isFunction(member))
                                that[memberName] = function() {
                                    return this._dataSource[memberName].apply(this._dataSource, arguments)
                                }
                        })
                    },
                    remoteOperations: function() {
                        return this._remoteOperations
                    },
                    dispose: function(isSharedDataSource) {
                        var that = this,
                            dataSource = that._dataSource;
                        dataSource.off("changed", that._dataChangedHandler);
                        dataSource.off("customizeStoreLoadOptions", that._dataLoadingHandler);
                        dataSource.off("customizeLoadResult", that._dataLoadedHandler);
                        dataSource.off("loadingChanged", that._loadingChangedHandler);
                        dataSource.off("loadError", that._loadErrorHandler);
                        if (!isSharedDataSource)
                            dataSource.dispose()
                    },
                    refresh: function(options, isReload, operationTypes) {
                        var that = this,
                            dataSource = that._dataSource;
                        if (isReload || operationTypes.reload) {
                            that._currentTotalCount = 0;
                            that._isLastPage = !dataSource.paginate();
                            that._hasLastPage = that._isLastPage
                        }
                    },
                    _customizeRemoteOperations: function(){},
                    _handleDataLoading: function(options) {
                        var that = this,
                            dataSource = that._dataSource,
                            lastLoadOptions = that._lastLoadOptions,
                            loadOptions,
                            operationTypes;
                        that.customizeStoreLoadOptions.fire(options);
                        options.delay = this.option("loadingTimeout");
                        options.originalStoreLoadOptions = options.storeLoadOptions;
                        options.remoteOperations = $.extend({}, this.remoteOperations());
                        var isReload = !that.isLoaded() && !that._isRefreshing;
                        loadOptions = $.extend({}, options.storeLoadOptions);
                        operationTypes = calculateOperationTypes(loadOptions, lastLoadOptions);
                        that._customizeRemoteOperations(options, isReload, operationTypes);
                        if (options.isCustomLoading)
                            return;
                        else
                            that._lastLoadOptions = loadOptions;
                        that._isRefreshing = true;
                        $.when(that.refresh(options, isReload, operationTypes)).always(function() {
                            if (that._lastOperationId === options.operationId)
                                that.load();
                            that._isRefreshing = false
                        });
                        dataSource.cancel(that._lastOperationId);
                        that._lastOperationId = options.operationId;
                        if (that._isRefreshing)
                            dataSource.cancel(that._lastOperationId)
                    },
                    _handleDataLoaded: function(options) {
                        options.storeLoadOptions = options.originalStoreLoadOptions
                    },
                    _handleLoadingChanged: function(isLoading) {
                        this.loadingChanged.fire(isLoading)
                    },
                    _handleLoadError: function(error) {
                        this.changed.fire({
                            changeType: "loadError",
                            error: error
                        });
                        this.loadError.fire(error)
                    },
                    _handleDataChanged: function(args) {
                        var that = this,
                            currentTotalCount,
                            dataSource = that._dataSource,
                            isLoading = false,
                            itemsCount = that.itemsCount();
                        that._isLastPage = !itemsCount || !that.pageSize() || itemsCount < that.pageSize();
                        if (that._isLastPage)
                            that._hasLastPage = true;
                        if (dataSource.totalCount() >= 0) {
                            if (dataSource.pageIndex() >= that.pageCount()) {
                                dataSource.pageIndex(that.pageCount() - 1);
                                dataSource.load();
                                isLoading = true
                            }
                        }
                        else {
                            currentTotalCount = dataSource.pageIndex() * that.pageSize() + itemsCount;
                            that._currentTotalCount = Math.max(that._currentTotalCount, currentTotalCount);
                            if (itemsCount === 0 && dataSource.pageIndex() >= that.pageCount()) {
                                dataSource.pageIndex(that.pageCount() - 1);
                                dataSource.load();
                                isLoading = true
                            }
                        }
                        if (!isLoading) {
                            this.component._optionCache = {};
                            this.changed.fire(args);
                            this.component._optionCache = undefined
                        }
                    },
                    isLastPage: function() {
                        return this._isLastPage
                    },
                    totalCount: function() {
                        return parseInt(this._currentTotalCount || this._dataSource.totalCount())
                    },
                    itemsCount: function() {
                        return this._dataSource.items().length
                    },
                    totalItemsCount: function() {
                        return this.totalCount()
                    },
                    pageSize: function() {
                        var dataSource = this._dataSource;
                        if (!arguments.length && !dataSource.paginate())
                            return 0;
                        return dataSource.pageSize.apply(dataSource, arguments)
                    },
                    pageCount: function() {
                        var that = this,
                            count = that.totalItemsCount(),
                            pageSize = that.pageSize();
                        if (pageSize && count > 0)
                            return Math.max(1, Math.ceil(count / pageSize));
                        return 1
                    },
                    hasKnownLastPage: function() {
                        return this._hasLastPage || this._dataSource.totalCount() >= 0
                    },
                    load: function(options) {
                        var that = this,
                            store,
                            loadResult,
                            dataSourceLoadOptions,
                            dataSource = that._dataSource,
                            d = $.Deferred();
                        if (options) {
                            store = dataSource.store();
                            dataSourceLoadOptions = dataSource.loadOptions();
                            loadResult = {
                                storeLoadOptions: options,
                                isCustomLoading: true
                            };
                            $.each(store._customLoadOptions() || [], function(_, optionName) {
                                if (!(optionName in loadResult.storeLoadOptions))
                                    loadResult.storeLoadOptions[optionName] = dataSourceLoadOptions[optionName]
                            });
                            dataSource._scheduleLoadCallbacks(d);
                            that._handleDataLoading(loadResult);
                            $.when(loadResult.data || store.load(loadResult.storeLoadOptions)).done(function(data, extra) {
                                loadResult.data = data;
                                loadResult.extra = extra || {};
                                that._handleDataLoaded(loadResult);
                                if (options.requireTotalCount && loadResult.extra.totalCount === undefined)
                                    loadResult.extra.totalCount = store.totalCount(loadResult.storeLoadOptions);
                                $.when(loadResult.data, loadResult.extra.totalCount).done(function(data, totalCount) {
                                    loadResult.extra.totalCount = totalCount;
                                    d.resolve(data, loadResult.extra)
                                }).fail(d.reject)
                            }).fail(d.reject);
                            return d.fail(function() {
                                    that.fireEvent("loadError", arguments)
                                }).promise()
                        }
                        else
                            return dataSource.load()
                    }
                }
        }());
        dataGrid.DataSourceAdapter = dataGrid.DataSourceAdapter.inherit({
            reload: function(full) {
                return full ? this._dataSource.reload() : this._dataSource.load()
            },
            _customizeRemoteOperations: function(options, isReload, operationTypes) {
                var that = this,
                    cachedStoreData = that._cachedStoreData,
                    cachedPagingData = that._cachedPagingData;
                that.callBase.apply(that, arguments);
                if (isReload) {
                    cachedStoreData = undefined;
                    cachedPagingData = undefined
                }
                else {
                    if (operationTypes.reload)
                        cachedPagingData = undefined;
                    $.each(operationTypes, function(operationType, value) {
                        if (value && options.remoteOperations[operationType]) {
                            cachedStoreData = undefined;
                            cachedPagingData = undefined
                        }
                    })
                }
                if (cachedPagingData)
                    options.remoteOperations.paging = false;
                options.cachedStoreData = cachedStoreData;
                options.cachedPagingData = cachedPagingData;
                if (!options.isCustomLoading) {
                    that._cachedStoreData = cachedStoreData;
                    that._cachedPagingData = cachedPagingData
                }
            },
            _handleDataLoading: function(options) {
                this.callBase(options);
                this._handleDataLoadingCore(options)
            },
            _handleDataLoadingCore: function(options) {
                var remoteOperations = options.remoteOperations;
                options.loadOptions = {};
                var localLoadOptionNames = {
                        filter: !remoteOperations.filtering,
                        sort: !remoteOperations.sorting,
                        group: !remoteOperations.grouping,
                        summary: !remoteOperations.summary,
                        skip: !remoteOperations.paging,
                        take: !remoteOperations.paging,
                        requireTotalCount: !remoteOperations.paging
                    };
                $.each(options.storeLoadOptions, function(optionName, optionValue) {
                    if (localLoadOptionNames[optionName]) {
                        options.loadOptions[optionName] = optionValue;
                        delete options.storeLoadOptions[optionName]
                    }
                });
                options.data = options.cachedStoreData
            },
            _handleDataLoaded: function(options) {
                var callBase = this.callBase,
                    loadOptions = options.loadOptions,
                    localPaging = options.remoteOperations && !options.remoteOperations.paging,
                    isCaching = this.option("cacheEnabled") !== false && localPaging && options.storeLoadOptions,
                    needStoreCache = isCaching && !options.isCustomLoading;
                if (!loadOptions) {
                    this._dataSource.cancel(options.operationId);
                    return
                }
                if (localPaging) {
                    options.skip = loadOptions.skip;
                    options.take = loadOptions.take;
                    delete loadOptions.skip;
                    delete loadOptions.take
                }
                if (loadOptions.group)
                    loadOptions.group = options.group || loadOptions.group;
                var groupCount = dataGrid.normalizeSortingInfo(options.storeLoadOptions.group || loadOptions.group).length;
                if (isCaching && options.cachedPagingData)
                    options.data = cloneItems(options.cachedPagingData, groupCount);
                else {
                    if (needStoreCache && !this._cachedStoreData)
                        this._cachedStoreData = cloneItems(options.data, dataGrid.normalizeSortingInfo(options.storeLoadOptions.group).length);
                    new DX.data.ArrayStore(options.data).load(loadOptions).done(function(data) {
                        options.data = data
                    });
                    if (needStoreCache)
                        this._cachedPagingData = cloneItems(options.data, groupCount)
                }
                if (loadOptions.requireTotalCount && localPaging) {
                    options.extra = $.isPlainObject(options.extra) ? options.extra : {};
                    options.extra.totalCount = options.data.length
                }
                this._handleDataLoadedCore(options);
                callBase.apply(this, arguments)
            },
            _handleDataLoadedCore: function(options) {
                if (options.remoteOperations && !options.remoteOperations.paging) {
                    if (options.skip !== undefined)
                        options.data = options.data.slice(options.skip);
                    if (options.take !== undefined)
                        options.data = options.data.slice(0, options.take)
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.groupingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            Class = DX.require("/class"),
            normalizeSortingInfo = DX.data.utils.normalizeSortingInfo;
        var DATAGRID_GROUP_PANEL_CLASS = "dx-datagrid-group-panel",
            DATAGRID_GROUP_PANEL_MESSAGE_CLASS = "dx-group-panel-message",
            DATAGRID_GROUP_PANEL_ITEM_CLASS = "dx-group-panel-item",
            DATAGRID_GROUP_OPENED_CLASS = "dx-datagrid-group-opened",
            DATAGRID_GROUP_CLOSED_CLASS = "dx-datagrid-group-closed",
            DATAGRID_EXPAND_CLASS = "dx-datagrid-expand",
            DATAGRID_SELECTION_DISABLED_CLASS = "dx-selection-disabled";
        var GroupingDataSourceAdapterExtender = function() {
                return {
                        init: function() {
                            this.callBase.apply(this, arguments);
                            this._initGroupingHelper()
                        },
                        _initGroupingHelper: function(options) {
                            var grouping = this._grouping,
                                remoteOperations = options ? options.remoteOperations : this.remoteOperations();
                            if (remoteOperations.filtering && remoteOperations.sorting && remoteOperations.paging && !remoteOperations.grouping) {
                                if (!grouping || grouping instanceof dataGrid.CollapsedGroupingHelper)
                                    this._grouping = new dataGrid.ExpandedGroupingHelper(this)
                            }
                            else if (!grouping || grouping instanceof dataGrid.ExpandedGroupingHelper)
                                this._grouping = new dataGrid.CollapsedGroupingHelper(this)
                        },
                        totalItemsCount: function() {
                            var that = this,
                                totalCount = that.callBase();
                            return totalCount > 0 && that._dataSource.group() && that._dataSource.requireTotalCount() ? totalCount + that._grouping.totalCountCorrection() : totalCount
                        },
                        itemsCount: function() {
                            return this._dataSource.group() ? this._grouping.itemsCount() || 0 : this.callBase()
                        },
                        allowCollapseAll: function() {
                            return this._grouping.allowCollapseAll()
                        },
                        isRowExpanded: function(key) {
                            var groupInfo = this._grouping.findGroupInfo(key);
                            return groupInfo ? groupInfo.isExpanded : !this._grouping.allowCollapseAll()
                        },
                        collapseAll: function(groupIndex) {
                            return this._collapseExpandAll(groupIndex, false)
                        },
                        expandAll: function(groupIndex) {
                            return this._collapseExpandAll(groupIndex, true)
                        },
                        _collapseExpandAll: function(groupIndex, isExpand) {
                            var that = this,
                                dataSource = that._dataSource,
                                group = dataSource.group(),
                                groups = normalizeSortingInfo(group || []),
                                i;
                            if (groups.length) {
                                for (i = 0; i < groups.length; i++)
                                    if (groupIndex === undefined || groupIndex === i)
                                        groups[i].isExpanded = isExpand;
                                    else if (group && group[i])
                                        groups[i].isExpanded = group[i].isExpanded;
                                dataSource.group(groups);
                                that._grouping.foreachGroups(function(groupInfo, parents) {
                                    if (groupIndex === undefined || groupIndex === parents.length - 1)
                                        groupInfo.isExpanded = isExpand
                                }, false, true)
                            }
                            return true
                        },
                        refresh: function() {
                            this.callBase.apply(this, arguments);
                            return this._grouping.refresh.apply(this._grouping, arguments)
                        },
                        changeRowExpand: function(path) {
                            var that = this,
                                dataSource = that._dataSource;
                            if (dataSource.group()) {
                                dataSource._changeLoadingCount(1);
                                return that._changeRowExpandCore(path).always(function() {
                                        dataSource._changeLoadingCount(-1)
                                    })
                            }
                        },
                        _changeRowExpandCore: function(path) {
                            return this._grouping.changeRowExpand(path)
                        },
                        getGroupsInfo: function() {
                            return this._grouping._groupsInfo
                        },
                        _hasCollapsedGroupLevels: function(group) {
                            if (group && $.isArray(group))
                                for (var i = 0; i < group.length; i++)
                                    if (group[i].isExpanded === false)
                                        return true
                        },
                        _customizeRemoteOperations: function(options) {
                            var remoteOperations = options.remoteOperations;
                            if (options.storeLoadOptions.group) {
                                if (remoteOperations.grouping && !options.isCustomLoading)
                                    remoteOperations.paging = false;
                                if (!remoteOperations.grouping && (!remoteOperations.sorting || !remoteOperations.filtering || options.isCustomLoading || this._hasCollapsedGroupLevels(options.storeLoadOptions.group)))
                                    remoteOperations.paging = false
                            }
                            this.callBase.apply(this, arguments)
                        },
                        _handleDataLoading: function(options) {
                            this.callBase(options);
                            this._initGroupingHelper(options);
                            return this._grouping.handleDataLoading(options)
                        },
                        _handleDataLoaded: function(options) {
                            return this._grouping.handleDataLoaded(options, $.proxy(this.callBase, this))
                        },
                        _handleDataLoadedCore: function(options) {
                            return this._grouping.handleDataLoadedCore(options, $.proxy(this.callBase, this))
                        }
                    }
            }();
        dataGrid.GroupingHelper = Class.inherit(function() {
            var findGroupInfoByKey = function(groupsInfo, key) {
                    var hash = groupsInfo.hash;
                    return hash && hash[key]
                };
            var getGroupInfoIndexByOffset = function(groupsInfo, offset) {
                    var index;
                    for (index = 0; index < groupsInfo.length; index++)
                        if (groupsInfo[index].offset > offset)
                            break;
                    return index
                };
            var updateGroupInfoOffsets = function(groupsInfo, parents) {
                    var groupInfo,
                        index,
                        newIndex;
                    for (index = 0; index < groupsInfo.length; index++) {
                        groupInfo = groupsInfo[index];
                        if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {
                            groupsInfo.splice(index, 1);
                            groupInfo.offset = groupInfo.data.offset;
                            for (var parentIndex = 0; parentIndex < parents.length; parentIndex++)
                                parents[parentIndex].offset = groupInfo.offset;
                            newIndex = getGroupInfoIndexByOffset(groupsInfo, groupInfo.offset);
                            groupsInfo.splice(newIndex, 0, groupInfo);
                            if (newIndex > index)
                                index--
                        }
                    }
                };
            var cleanGroupsInfo = function(groupsInfo, groupIndex, groupsCount) {
                    var i;
                    for (i = 0; i < groupsInfo.length; i++)
                        if (groupIndex + 1 >= groupsCount)
                            groupsInfo[i].children = [];
                        else
                            cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount)
                };
            return {
                    ctor: function(dataSourceAdapter) {
                        this._dataSource = dataSourceAdapter;
                        this.reset()
                    },
                    reset: function() {
                        this._groupsInfo = [];
                        this._totalCountCorrection = 0;
                        this._itemsCount = 0
                    },
                    totalCountCorrection: function() {
                        return this._totalCountCorrection
                    },
                    updateTotalItemsCount: function(totalCountCorrection) {
                        this._totalCountCorrection = totalCountCorrection || 0
                    },
                    _isGroupItemCountable: function(item) {
                        return !this._isVirtualPaging() || !item.isContinuation
                    },
                    _isVirtualPaging: function() {
                        var scrollingMode = this._dataSource.option("scrolling.mode");
                        return scrollingMode === "virtual" || scrollingMode === "infinite"
                    },
                    itemsCount: function() {
                        return this._itemsCount
                    },
                    updateItemsCount: function(data, groupsCount) {
                        function calculateItemsCount(that, items, groupsCount) {
                            var i,
                                result = 0;
                            if (items)
                                if (!groupsCount)
                                    result = items.length;
                                else
                                    for (i = 0; i < items.length; i++) {
                                        if (that._isGroupItemCountable(items[i]))
                                            result++;
                                        result += calculateItemsCount(that, items[i].items, groupsCount - 1)
                                    }
                            return result
                        }
                        this._itemsCount = calculateItemsCount(this, data, groupsCount)
                    },
                    foreachGroups: function(callback, childrenAtFirst, foreachCollapsedGroups, updateOffsets) {
                        var that = this;
                        function foreachGroupsCore(groupsInfo, callback, childrenAtFirst, parents) {
                            var i,
                                callbackResult,
                                callbackResults = [];
                            function executeCallback(callback, data, parents, callbackResults) {
                                var callbackResult = data && callback(data, parents);
                                callbackResults.push(callbackResult);
                                return callbackResult
                            }
                            for (i = 0; i < groupsInfo.length; i++) {
                                parents.push(groupsInfo[i].data);
                                if (!childrenAtFirst && executeCallback(callback, groupsInfo[i].data, parents, callbackResults) === false)
                                    return false;
                                if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded || foreachCollapsedGroups) {
                                    callbackResult = foreachGroupsCore(groupsInfo[i].children, callback, childrenAtFirst, parents);
                                    callbackResults.push(callbackResult);
                                    if (callbackResult === false)
                                        return false
                                }
                                if (childrenAtFirst && executeCallback(callback, groupsInfo[i].data, parents, callbackResults) === false)
                                    return false;
                                if (!groupsInfo[i].data || groupsInfo[i].data.offset !== groupsInfo[i].offset)
                                    updateOffsets = true;
                                parents.pop()
                            }
                            var currentParents = parents.slice(0);
                            return updateOffsets && $.when.apply($, callbackResults).always(function() {
                                    updateGroupInfoOffsets(groupsInfo, currentParents)
                                })
                        }
                        return foreachGroupsCore(that._groupsInfo, callback, childrenAtFirst, [])
                    },
                    findGroupInfo: function(path) {
                        var that = this,
                            pathIndex,
                            groupInfo,
                            groupsInfo = that._groupsInfo;
                        for (pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {
                            groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
                            groupsInfo = groupInfo && groupInfo.children
                        }
                        return groupInfo && groupInfo.data
                    },
                    addGroupInfo: function(groupInfoData) {
                        var that = this,
                            index,
                            groupInfo,
                            path = groupInfoData.path,
                            pathIndex,
                            groupsInfo = that._groupsInfo;
                        for (pathIndex = 0; pathIndex < path.length; pathIndex++) {
                            groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
                            if (!groupInfo) {
                                groupInfo = {
                                    key: path[pathIndex],
                                    offset: groupInfoData.offset,
                                    data: {
                                        offset: groupInfoData.offset,
                                        isExpanded: true,
                                        path: path.slice(0, pathIndex + 1)
                                    },
                                    children: []
                                };
                                index = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);
                                groupsInfo.splice(index, 0, groupInfo);
                                groupsInfo.hash = groupsInfo.hash || {};
                                groupsInfo.hash[groupInfo.key] = groupInfo
                            }
                            if (pathIndex === path.length - 1) {
                                groupInfo.data = groupInfoData;
                                if (groupInfo.offset !== groupInfoData.offset)
                                    updateGroupInfoOffsets(groupsInfo)
                            }
                            groupsInfo = groupInfo.children
                        }
                    },
                    allowCollapseAll: function() {
                        return true
                    },
                    refresh: function(options) {
                        var that = this,
                            groupIndex,
                            storeLoadOptions = options.storeLoadOptions,
                            oldGroups = normalizeSortingInfo(that._group || []),
                            groups = normalizeSortingInfo(storeLoadOptions.group || []),
                            groupsCount = Math.min(oldGroups.length, groups.length);
                        that._group = storeLoadOptions.group;
                        for (groupIndex = 0; groupIndex < groupsCount; groupIndex++)
                            if (oldGroups[groupIndex].selector !== groups[groupIndex].selector) {
                                groupsCount = groupIndex;
                                break
                            }
                        if (!groupsCount)
                            that.reset();
                        else
                            cleanGroupsInfo(that._groupsInfo, 0, groupsCount)
                    },
                    handleDataLoading: function(options){},
                    handleDataLoaded: function(options, callBase) {
                        callBase(options)
                    },
                    handleDataLoadedCore: function(options, callBase) {
                        callBase(options)
                    }
                }
        }());
        dataGrid.DataSourceAdapter = dataGrid.DataSourceAdapter.inherit(GroupingDataSourceAdapterExtender);
        var GroupingDataControllerExtender = function() {
                return {
                        init: function() {
                            var that = this;
                            that.callBase();
                            that.createAction("onRowExpanding");
                            that.createAction("onRowExpanded");
                            that.createAction("onRowCollapsing");
                            that.createAction("onRowCollapsed")
                        },
                        _processItems: function(items, changeType) {
                            var groupColumns = this._columnsController.getGroupColumns();
                            if (items.length && groupColumns.length)
                                items = this._processGroupItems(items, groupColumns.length);
                            return this.callBase(items, changeType)
                        },
                        _processItem: function(item, options) {
                            if (commonUtils.isDefined(item.groupIndex) && commonUtils.isString(item.rowType) && item.rowType.indexOf("group") === 0) {
                                item = this._processGroupItem(item, options);
                                options.dataIndex = 0
                            }
                            else
                                item = this.callBase.apply(this, arguments);
                            return item
                        },
                        _processGroupItem: function(item, options) {
                            return item
                        },
                        _processGroupItems: function(items, groupsCount, options) {
                            var that = this,
                                groupedColumns = that._columnsController.getGroupColumns(),
                                column = groupedColumns[groupedColumns.length - groupsCount],
                                scrollingMode,
                                i,
                                item,
                                resultItems;
                            if (!options) {
                                scrollingMode = that.option("scrolling.mode");
                                options = {
                                    collectContinuationItems: scrollingMode !== "virtual" && scrollingMode !== "infinite",
                                    resultItems: [],
                                    path: [],
                                    values: []
                                }
                            }
                            resultItems = options.resultItems;
                            if (options.data)
                                if (options.collectContinuationItems || !options.data.isContinuation)
                                    resultItems.push({
                                        rowType: "group",
                                        data: options.data,
                                        groupIndex: options.path.length - 1,
                                        isExpanded: !!options.data.items,
                                        key: options.path.slice(0),
                                        values: options.values.slice(0)
                                    });
                            if (items)
                                if (groupsCount === 0)
                                    resultItems.push.apply(resultItems, items);
                                else
                                    for (i = 0; i < items.length; i++) {
                                        item = items[i];
                                        if (item && "items" in item) {
                                            options.data = item;
                                            options.path.push(item.key);
                                            options.values.push(column && column.deserializeValue ? column.deserializeValue(item.key) : item.key);
                                            that._processGroupItems(item.items, groupsCount - 1, options);
                                            options.data = undefined;
                                            options.path.pop();
                                            options.values.pop()
                                        }
                                        else
                                            resultItems.push(item)
                                    }
                            return resultItems
                        },
                        publicMethods: function() {
                            return this.callBase().concat(["collapseAll", "expandAll", "isRowExpanded", "expandRow", "collapseRow"])
                        },
                        collapseAll: function(groupIndex) {
                            var dataSource = this._dataSource;
                            if (dataSource && dataSource.collapseAll(groupIndex)) {
                                dataSource.pageIndex(0);
                                dataSource.reload()
                            }
                        },
                        expandAll: function(groupIndex) {
                            var dataSource = this._dataSource;
                            if (dataSource && dataSource.expandAll(groupIndex)) {
                                dataSource.pageIndex(0);
                                dataSource.reload()
                            }
                        },
                        changeRowExpand: function(key) {
                            var that = this,
                                expanded = that.isRowExpanded(key),
                                args = {
                                    key: key,
                                    expanded: expanded
                                };
                            that.executeAction(expanded ? "onRowCollapsing" : "onRowExpanding", args);
                            if (!args.cancel)
                                return $.when(that._changeRowExpandCore(key)).done(function() {
                                        args.expanded = !expanded;
                                        that.executeAction(expanded ? "onRowCollapsed" : "onRowExpanded", args)
                                    })
                        },
                        _changeRowExpandCore: function(key) {
                            var that = this,
                                dataSource = this._dataSource,
                                d;
                            if (!dataSource)
                                return;
                            d = $.Deferred();
                            $.when(dataSource.changeRowExpand(key)).done(function() {
                                that.load().done(d.resolve).fail(d.reject)
                            }).fail(d.reject);
                            return d
                        },
                        isRowExpanded: function(key) {
                            var dataSource = this._dataSource;
                            return dataSource && dataSource.isRowExpanded(key)
                        },
                        expandRow: function(key) {
                            if (!this.isRowExpanded(key))
                                return this.changeRowExpand(key);
                            return $.Deferred().resolve()
                        },
                        collapseRow: function(key) {
                            if (this.isRowExpanded(key))
                                return this.changeRowExpand(key);
                            return $.Deferred().resolve()
                        },
                        optionChanged: function(args) {
                            if (args.name === "grouping")
                                args.name = "dataSource";
                            this.callBase(args)
                        }
                    }
            }();
        var GroupingHeaderPanelExtender = function() {
                return {
                        _renderGroupPanel: function() {
                            var that = this,
                                $element = that.element(),
                                groupPanelOptions = that.option("groupPanel"),
                                $groupPanel,
                                groupColumns = that.getController("columns").getGroupColumns();
                            $groupPanel = $element.find("." + DATAGRID_GROUP_PANEL_CLASS);
                            if (groupPanelOptions && groupPanelOptions.visible) {
                                if (!$groupPanel.length)
                                    $groupPanel = $("<div />").addClass(DATAGRID_GROUP_PANEL_CLASS).prependTo($element);
                                else
                                    $groupPanel.show();
                                that._renderGroupPanelItems($groupPanel, groupColumns);
                                if (groupPanelOptions.allowColumnDragging && !groupColumns.length)
                                    $("<div />").addClass(DATAGRID_GROUP_PANEL_MESSAGE_CLASS).text(groupPanelOptions.emptyPanelText).appendTo($groupPanel)
                            }
                            else
                                $groupPanel.hide()
                        },
                        _renderGroupPanelItems: function($groupPanel, groupColumns) {
                            var that = this;
                            $groupPanel.empty();
                            $.each(groupColumns, function(index, groupColumn) {
                                that._createGroupPanelItem($groupPanel, groupColumn)
                            })
                        },
                        _createGroupPanelItem: function($rootElement, groupColumn) {
                            return $("<div />").addClass(groupColumn.cssClass).addClass(DATAGRID_GROUP_PANEL_ITEM_CLASS).appendTo($rootElement).text(groupColumn.caption)
                        },
                        _renderCore: function() {
                            this.callBase.apply(this, arguments);
                            this._renderGroupPanel()
                        },
                        allowDragging: function(column) {
                            var groupPanelOptions = this.option("groupPanel");
                            return groupPanelOptions && groupPanelOptions.visible && groupPanelOptions.allowColumnDragging && column && column.allowGrouping
                        },
                        getColumnElements: function() {
                            var $element = this.element();
                            return $element && $element.find("." + DATAGRID_GROUP_PANEL_ITEM_CLASS)
                        },
                        getColumns: function() {
                            return this.getController("columns").getGroupColumns()
                        },
                        getBoundingRect: function() {
                            var that = this,
                                $element = that.element(),
                                offset;
                            if ($element && $element.find("." + DATAGRID_GROUP_PANEL_CLASS).length) {
                                offset = $element.offset();
                                return {
                                        top: offset.top,
                                        bottom: offset.top + $element.height()
                                    }
                            }
                            return null
                        },
                        getName: function() {
                            return "group"
                        },
                        isVisible: function() {
                            return this.callBase() || this.option("groupPanel.visible")
                        },
                        optionChanged: function(args) {
                            if (args.name === "groupPanel") {
                                this._renderGroupPanel();
                                args.handled = true
                            }
                            else
                                this.callBase(args)
                        }
                    }
            }();
        dataGrid.GroupingHeaderPanelExtender = GroupingHeaderPanelExtender;
        var GroupingRowsViewExtender = function() {
                return {
                        _rowClick: function(e) {
                            var that = this,
                                dataController = that.getController("data"),
                                $expandElement = $(e.jQueryEvent.target).closest("." + DATAGRID_EXPAND_CLASS),
                                key;
                            if ($expandElement.length) {
                                key = dataController.getKeyByRowIndex(e.rowIndex);
                                dataController.changeRowExpand(key);
                                e.jQueryEvent.preventDefault();
                                e.handled = true
                            }
                            that.callBase(e)
                        },
                        _getColumnTemplate: function(options) {
                            var that = this;
                            if (options.column.command === "expand")
                                return {
                                        allowRenderToDetachedContainer: true,
                                        render: function(container, options) {
                                            if (commonUtils.isDefined(options.value) && !(options.data && options.data.isContinuation) && !options.row.inserted) {
                                                container.addClass(DATAGRID_EXPAND_CLASS).addClass(DATAGRID_SELECTION_DISABLED_CLASS);
                                                $("<div>").addClass(options.value ? DATAGRID_GROUP_OPENED_CLASS : DATAGRID_GROUP_CLOSED_CLASS).appendTo(container);
                                                that.setAria("label", options.value ? that.localize("dxDataGrid-ariaCollapse") : that.localize("dxDataGrid-ariaExpand"), container)
                                            }
                                        }
                                    };
                            return that.callBase(options)
                        }
                    }
            }();
        $.extend(dataGrid.__internals, {
            DATAGRID_GROUP_PANEL_CLASS: DATAGRID_GROUP_PANEL_CLASS,
            DATAGRID_GROUP_PANEL_MESSAGE_CLASS: DATAGRID_GROUP_PANEL_MESSAGE_CLASS,
            DATAGRID_GROUP_PANEL_ITEM_CLASS: DATAGRID_GROUP_PANEL_ITEM_CLASS,
            DATAGRID_GROUP_OPENED_CLASS: DATAGRID_GROUP_OPENED_CLASS,
            DATAGRID_GROUP_CLOSED_CLASS: DATAGRID_GROUP_CLOSED_CLASS,
            DATAGRID_EXPAND_CLASS: DATAGRID_EXPAND_CLASS,
            DATAGRID_SELECTION_DISABLED_CLASS: DATAGRID_SELECTION_DISABLED_CLASS
        });
        dataGrid.registerModule("grouping", {
            defaultOptions: function() {
                return {
                        grouping: {
                            autoExpandAll: true,
                            allowCollapsing: true,
                            groupContinuesMessage: Globalize.localize("dxDataGrid-groupContinuesMessage"),
                            groupContinuedMessage: Globalize.localize("dxDataGrid-groupContinuedMessage")
                        },
                        groupPanel: {
                            visible: false,
                            emptyPanelText: Globalize.localize("dxDataGrid-groupPanelEmptyText"),
                            allowColumnDragging: true
                        }
                    }
            },
            extenders: {
                controllers: {data: GroupingDataControllerExtender},
                views: {
                    headerPanel: GroupingHeaderPanelExtender,
                    rowsView: GroupingRowsViewExtender
                }
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.grouping.server.js */
    (function($, DX) {
        var dataUtils = DX.data.utils,
            dataGrid = DX.ui.dxDataGrid,
            normalizeSortingInfo = dataGrid.normalizeSortingInfo,
            keysEqual = dataUtils.keysEqual;
        var loadTotalCount = function(dataSource, options) {
                var d = $.Deferred(),
                    loadOptions = $.extend({
                        skip: 0,
                        take: 1,
                        requireTotalCount: true
                    }, options);
                dataSource.load(loadOptions).done(function(data, extra) {
                    d.resolve(extra && extra.totalCount)
                }).fail($.proxy(d.reject, d));
                return d
            };
        dataGrid.ExpandedGroupingHelper = dataGrid.GroupingHelper.inherit(function() {
            var foreachCollapsedGroups = function(that, callback, updateOffsets) {
                    return that.foreachGroups(function(groupInfo) {
                            if (!groupInfo.isExpanded)
                                return callback(groupInfo)
                        }, false, false, updateOffsets)
                };
            var correctSkipLoadOption = function(that, skip) {
                    var skipCorrection = 0,
                        resultSkip = skip || 0;
                    if (skip) {
                        foreachCollapsedGroups(that, function(groupInfo) {
                            if (groupInfo.offset - skipCorrection >= skip)
                                return false;
                            skipCorrection += groupInfo.count - 1
                        });
                        resultSkip += skipCorrection
                    }
                    return resultSkip
                };
            var processGroupItems = function(that, items, path, offset, skipFirstItem, take) {
                    var i,
                        item,
                        offsetInfo,
                        removeLastItemsCount = 0,
                        needRemoveFirstItem = false;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item.items !== undefined) {
                            path.push(item.key);
                            var groupInfo = that.findGroupInfo(path);
                            if (groupInfo && !groupInfo.isExpanded) {
                                item.collapsedItems = item.items;
                                item.items = null;
                                offset += groupInfo.count;
                                take--;
                                if (take < 0)
                                    removeLastItemsCount++;
                                if (skipFirstItem)
                                    needRemoveFirstItem = true
                            }
                            else if (item.items) {
                                offsetInfo = processGroupItems(that, item.items, path, offset, skipFirstItem, take);
                                if (skipFirstItem)
                                    if (offsetInfo.offset - offset > 1)
                                        item.isContinuation = true;
                                    else
                                        needRemoveFirstItem = true;
                                offset = offsetInfo.offset;
                                take = offsetInfo.take;
                                if (take < 0)
                                    if (item.items.length)
                                        item.isContinuationOnNextPage = true;
                                    else
                                        removeLastItemsCount++
                            }
                            path.pop()
                        }
                        else {
                            if (skipFirstItem)
                                needRemoveFirstItem = true;
                            offset++;
                            take--;
                            if (take < 0)
                                removeLastItemsCount++
                        }
                        skipFirstItem = false
                    }
                    if (needRemoveFirstItem)
                        items.splice(0, 1);
                    if (removeLastItemsCount)
                        items.splice(-removeLastItemsCount, removeLastItemsCount);
                    return {
                            offset: offset,
                            take: take
                        }
                };
            var pathEquals = function(path1, path2) {
                    var i;
                    if (path1.length !== path2.length)
                        return false;
                    for (i = 0; i < path1.length; i++)
                        if (!keysEqual(null, path1[i], path2[i]))
                            return false;
                    return true
                };
            var updateGroupOffsets = function(that, items, path, offset, additionalGroupInfo) {
                    var i,
                        item;
                    if (!items)
                        return;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if ("key" in item && item.items !== undefined) {
                            path.push(item.key);
                            if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation)
                                additionalGroupInfo.offset = offset;
                            var groupInfo = that.findGroupInfo(path);
                            if (groupInfo)
                                groupInfo.offset = offset;
                            if (groupInfo && !groupInfo.isExpanded)
                                offset += groupInfo.count;
                            else
                                offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo);
                            path.pop()
                        }
                        else
                            offset++
                    }
                    return offset
                };
            var removeGroupLoadOption = function(storeLoadOptions, loadOptions) {
                    var groups,
                        sorts;
                    if (loadOptions.group) {
                        groups = normalizeSortingInfo(loadOptions.group);
                        sorts = normalizeSortingInfo(storeLoadOptions.sort);
                        storeLoadOptions.sort = dataUtils.arrangeSortingInfo(groups, sorts);
                        delete loadOptions.group
                    }
                };
            var createGroupFilter = dataGrid.createGroupFilter = function(path, storeLoadOptions) {
                    var groups = normalizeSortingInfo(storeLoadOptions.group),
                        i,
                        filter = [];
                    for (i = 0; i < path.length; i++)
                        filter.push([groups[i].selector, "=", path[i]]);
                    if (storeLoadOptions.filter)
                        filter.push(storeLoadOptions.filter);
                    return dataGrid.combineFilters(filter)
                };
            var createNotGroupFilter = function(path, storeLoadOptions, group) {
                    var groups = normalizeSortingInfo(group || storeLoadOptions.group),
                        i,
                        j,
                        filterElement,
                        filter = [];
                    for (i = 0; i < path.length; i++) {
                        filterElement = [];
                        for (j = 0; j <= i; j++)
                            filterElement.push([groups[j].selector, i === j ? "<>" : "=", path[j]]);
                        filter.push(dataGrid.combineFilters(filterElement))
                    }
                    filter = dataGrid.combineFilters(filter, "or");
                    return dataGrid.combineFilters([filter, storeLoadOptions.filter])
                };
            var createOffsetFilter = function(path, storeLoadOptions) {
                    var groups = normalizeSortingInfo(storeLoadOptions.group),
                        i,
                        j,
                        filterElement,
                        filter = [];
                    for (i = 0; i < path.length; i++) {
                        filterElement = [];
                        for (j = 0; j <= i; j++)
                            filterElement.push([groups[j].selector, i === j ? groups[j].desc ? ">" : "<" : "=", path[j]]);
                        filter.push(dataGrid.combineFilters(filterElement))
                    }
                    filter = dataGrid.combineFilters(filter, "or");
                    return dataGrid.combineFilters([filter, storeLoadOptions.filter])
                };
            var getGroupCount = function(item, groupCount) {
                    var count = item.count || item.items.length,
                        i;
                    if (!item.count && groupCount > 1) {
                        count = 0;
                        for (i = 0; i < item.items.length; i++)
                            count += getGroupCount(item.items[i], groupCount - 1)
                    }
                    return count
                };
            return {
                    handleDataLoading: function(options) {
                        var that = this,
                            storeLoadOptions = options.storeLoadOptions,
                            loadOptions,
                            collapsedGroups = [],
                            collapsedItemsCount = 0,
                            skipFirstItem = false,
                            take,
                            group = options.loadOptions.group,
                            skipCorrection = 0;
                        removeGroupLoadOption(storeLoadOptions, options.loadOptions);
                        options.group = options.group || group;
                        if (options.isCustomLoading)
                            return;
                        loadOptions = $.extend({}, storeLoadOptions);
                        loadOptions.skip = correctSkipLoadOption(that, storeLoadOptions.skip);
                        if (loadOptions.skip && loadOptions.take && group) {
                            loadOptions.skip--;
                            loadOptions.take++;
                            skipFirstItem = true
                        }
                        if (loadOptions.take && group) {
                            take = loadOptions.take;
                            loadOptions.take++
                        }
                        foreachCollapsedGroups(that, function(groupInfo) {
                            if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection)
                                return false;
                            else if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {
                                skipCorrection += groupInfo.count - 1;
                                collapsedGroups.push(groupInfo);
                                collapsedItemsCount += groupInfo.count
                            }
                        });
                        $.each(collapsedGroups, function() {
                            loadOptions.filter = createNotGroupFilter(this.path, loadOptions, group)
                        });
                        options.storeLoadOptions = loadOptions;
                        options.collapsedGroups = collapsedGroups;
                        options.collapsedItemsCount = collapsedItemsCount;
                        options.skip = loadOptions.skip || 0;
                        options.skipFirstItem = skipFirstItem;
                        options.take = take
                    },
                    handleDataLoaded: function(options, callBase) {
                        var that = this,
                            data = options.data,
                            pathIndex,
                            query,
                            collapsedGroups = options.collapsedGroups,
                            groups = normalizeSortingInfo(options.group),
                            groupCount = groups.length;
                        function appendCollapsedPath(data, path, groups, collapsedGroup, offset) {
                            if (!data || !path.length || !groups.length)
                                return;
                            var i,
                                keyValue,
                                pathValue = dataUtils.toComparable(path[0], true);
                            for (i = 0; i < data.length; i++) {
                                keyValue = dataUtils.toComparable(data[i].key, true);
                                if (offset >= collapsedGroup.offset || pathValue === keyValue)
                                    break;
                                else
                                    offset += getGroupCount(data[i], groups.length)
                            }
                            if (!data.length || pathValue !== keyValue)
                                data.splice(i, 0, {
                                    key: path[0],
                                    items: [],
                                    count: path.length === 1 ? collapsedGroup.count : undefined
                                });
                            appendCollapsedPath(data[i].items, path.slice(1), groups.slice(1), collapsedGroup, offset)
                        }
                        callBase(options);
                        if (groupCount) {
                            query = DX.data.query(data);
                            DX.data.utils.multiLevelGroup(query, groups).enumerate().done(function(groupedData) {
                                data = groupedData
                            });
                            if (collapsedGroups)
                                for (pathIndex = 0; pathIndex < collapsedGroups.length; pathIndex++)
                                    appendCollapsedPath(data, collapsedGroups[pathIndex].path, groups, collapsedGroups[pathIndex], options.skip);
                            if (!options.isCustomLoading) {
                                processGroupItems(that, data, [], options.skip, options.skipFirstItem, options.take);
                                that.updateItemsCount(data, groupCount)
                            }
                            options.data = data;
                            if (options.collapsedItemsCount && options.extra && options.extra.totalCount >= 0)
                                options.extra.totalCount += options.collapsedItemsCount
                        }
                    },
                    updateTotalItemsCount: function() {
                        var itemsCountCorrection = 0;
                        foreachCollapsedGroups(this, function(groupInfo) {
                            if (groupInfo.count)
                                itemsCountCorrection -= groupInfo.count - 1
                        });
                        this.callBase(itemsCountCorrection)
                    },
                    changeRowExpand: function(path) {
                        var that = this,
                            dataSource = that._dataSource,
                            beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex(),
                            dataSourceItems = dataSource.items(),
                            offset = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize()),
                            groupInfo = that.findGroupInfo(path),
                            groupCountQuery;
                        if (groupInfo && !groupInfo.isExpanded)
                            groupCountQuery = $.Deferred().resolve(groupInfo.count);
                        else
                            groupCountQuery = loadTotalCount(dataSource, {filter: createGroupFilter(path, {
                                    filter: dataSource.filter(),
                                    group: dataSource.group()
                                })});
                        return $.when(groupCountQuery).done(function(count) {
                                count = parseInt(count.length ? count[0] : count);
                                if (groupInfo) {
                                    updateGroupOffsets(that, dataSourceItems, [], offset);
                                    groupInfo.isExpanded = !groupInfo.isExpanded;
                                    groupInfo.count = count
                                }
                                else {
                                    groupInfo = {
                                        offset: -1,
                                        count: count,
                                        path: path,
                                        isExpanded: false
                                    };
                                    updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);
                                    if (groupInfo.offset >= 0)
                                        that.addGroupInfo(groupInfo)
                                }
                                that.updateTotalItemsCount()
                            }).fail(function() {
                                dataSource.fireEvent("loadError", arguments)
                            })
                    },
                    allowCollapseAll: function() {
                        return false
                    },
                    refresh: function(options, isReload, operationTypes) {
                        var that = this,
                            storeLoadOptions = options.storeLoadOptions,
                            dataSource = that._dataSource;
                        this.callBase.apply(this, arguments);
                        if (isReload || operationTypes.reload)
                            return foreachCollapsedGroups(that, function(groupInfo) {
                                    var groupCountQuery = loadTotalCount(dataSource, {filter: createGroupFilter(groupInfo.path, storeLoadOptions)}),
                                        groupOffsetQuery = loadTotalCount(dataSource, {filter: createOffsetFilter(groupInfo.path, storeLoadOptions)});
                                    return $.when(groupOffsetQuery, groupCountQuery).done(function(offset, count) {
                                            offset = parseInt(offset.length ? offset[0] : offset);
                                            count = parseInt(count.length ? count[0] : count);
                                            groupInfo.offset = offset;
                                            if (groupInfo.count !== count) {
                                                groupInfo.count = count;
                                                that.updateTotalItemsCount()
                                            }
                                        })
                                }, true)
                    }
                }
        }());
        $.extend(DX.ui.dxDataGrid.__internals, {loadTotalCount: loadTotalCount})
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.grouping.client.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            normalizeSortingInfo = dataGrid.normalizeSortingInfo,
            errors = DX.require("/ui/ui.errors");
        dataGrid.CollapsedGroupingHelper = dataGrid.GroupingHelper.inherit(function() {
            var foreachExpandedGroups = function(that, callback) {
                    return that.foreachGroups(function(groupInfo, parents) {
                            if (groupInfo.isExpanded)
                                return callback(groupInfo, parents)
                        }, true)
                };
            var processGroupItems = function(that, items, groupsCount, expandedInfo, path, isCustomLoading, isLastGroupExpanded) {
                    var i,
                        item,
                        groupInfo,
                        isExpanded;
                    expandedInfo.items = expandedInfo.items || [];
                    expandedInfo.paths = expandedInfo.paths || [];
                    expandedInfo.count = expandedInfo.count || 0;
                    expandedInfo.lastCount = expandedInfo.lastCount || 0;
                    if (!groupsCount)
                        return;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item.items !== undefined) {
                            path.push(item.key);
                            if (isCustomLoading)
                                isExpanded = true;
                            else {
                                groupInfo = that.findGroupInfo(path);
                                isExpanded = groupInfo && groupInfo.isExpanded
                            }
                            if (!isExpanded) {
                                item.collapsedItems = item.items;
                                item.items = null
                            }
                            else if (item.items)
                                processGroupItems(that, item.items, groupsCount - 1, expandedInfo, path, isCustomLoading, isLastGroupExpanded);
                            else if (groupsCount === 1 && item.count && (!isCustomLoading || isLastGroupExpanded)) {
                                expandedInfo.items.push(item);
                                expandedInfo.paths.push(path.slice(0));
                                expandedInfo.count += expandedInfo.lastCount;
                                expandedInfo.lastCount = item.count
                            }
                            path.pop()
                        }
                    }
                };
            var updateGroupInfos = function(that, items, groupsCount, offset) {
                    return updateGroupInfosCore(that, items, 0, groupsCount, [], offset)
                };
            var updateGroupInfosCore = function(that, items, groupIndex, groupsCount, path, offset) {
                    var item,
                        totalCount = 0,
                        count,
                        i,
                        groupInfo;
                    if (groupIndex >= groupsCount)
                        return items.length;
                    for (i = 0; i < items.length; i++) {
                        item = items[i];
                        if (item) {
                            path.push(item.key);
                            if (!item.count && !item.items || item.items === undefined)
                                return -1;
                            groupInfo = that.findGroupInfo(path);
                            if (!groupInfo)
                                that.addGroupInfo({
                                    isExpanded: that._isGroupExpanded(groupIndex),
                                    path: path.slice(0),
                                    offset: offset + i,
                                    count: item.count > 0 ? item.count : item.items.length
                                });
                            else {
                                groupInfo.count = item.count > 0 ? item.count : item.items.length;
                                groupInfo.offset = offset + i
                            }
                            count = item.items || !item.count ? updateGroupInfosCore(that, item.items, groupIndex + 1, groupsCount, path, 0) : item.count;
                            if (count < 0)
                                return -1;
                            totalCount += count;
                            path.pop()
                        }
                    }
                    return totalCount
                };
            var isGroupExpanded = function(groups, groupIndex) {
                    return groups && groups.length && groups[groupIndex] && !!groups[groupIndex].isExpanded
                };
            var getTotalOffset = function(groupInfos, pageSize, offset) {
                    var groupIndex,
                        groupSize,
                        totalOffset = offset;
                    for (groupIndex = 0; groupIndex < groupInfos.length; groupIndex++) {
                        groupSize = groupInfos[groupIndex].offset + 1;
                        if (groupIndex > 0) {
                            groupSize += groupInfos[groupIndex - 1].childrenTotalCount;
                            if (pageSize)
                                groupSize += getContinuationGroupCount(totalOffset, pageSize, groupSize, groupIndex - 1) * groupIndex
                        }
                        totalOffset += groupSize
                    }
                    return totalOffset
                };
            var getContinuationGroupCount = function(groupOffset, pageSize, groupSize, groupIndex) {
                    groupIndex = groupIndex || 0;
                    if (pageSize > 1 && groupSize > 0) {
                        var pageOffset = groupOffset - Math.floor(groupOffset / pageSize) * pageSize || pageSize;
                        pageOffset += groupSize - groupIndex - 2;
                        if (pageOffset < 0)
                            pageOffset += pageSize;
                        return Math.floor(pageOffset / (pageSize - groupIndex - 1))
                    }
                    return 0
                };
            DX.ui.dxDataGrid.getContinuationGroupCount = getContinuationGroupCount;
            function loadLastLevelGroupItems(that, options, expandedInfo) {
                var expandedFilters = [],
                    data = options.data;
                $.each(expandedInfo.paths, function(_, expandedPath) {
                    expandedFilters.push(dataGrid.createGroupFilter(expandedPath, {group: options.storeLoadOptions.group}))
                });
                var filter = options.storeLoadOptions.filter;
                if (!options.storeLoadOptions.isLoadingAll)
                    filter = dataGrid.combineFilters([filter, dataGrid.combineFilters(expandedFilters, "or")]);
                options.data = $.Deferred();
                var loadOptions = $.extend({}, options.storeLoadOptions, {
                        group: null,
                        filter: filter,
                        skip: expandedInfo.skip,
                        take: expandedInfo.take
                    });
                $.when(expandedInfo.take === 0 ? [] : that._dataSource.store().load(loadOptions)).done(function(items, extra) {
                    $.each(expandedInfo.items, function(index, item) {
                        DX.data.query(items).filter(expandedFilters[index]).enumerate().done(function(expandedItems) {
                            item.items = expandedItems
                        })
                    });
                    options.data.resolve(data)
                }).fail(options.data.reject)
            }
            return {
                    updateTotalItemsCount: function(options) {
                        var totalItemsCount = 0,
                            totalCount = options.extra && options.extra.totalCount || 0,
                            totalGroupCount = options.extra && options.extra.totalGroupCount || 0,
                            pageSize = this._dataSource.pageSize(),
                            isVirtualPaging = this._isVirtualPaging();
                        foreachExpandedGroups(this, function(groupInfo, parents) {
                            groupInfo.childrenTotalCount = 0
                        });
                        foreachExpandedGroups(this, function(groupInfo, parents) {
                            var totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, totalItemsCount),
                                count = groupInfo.count + groupInfo.childrenTotalCount;
                            if (!isVirtualPaging)
                                count += getContinuationGroupCount(totalOffset, pageSize, count, parents.length - 1);
                            if (parents[parents.length - 2])
                                parents[parents.length - 2].childrenTotalCount += count;
                            else
                                totalItemsCount += count
                        });
                        this.callBase(totalItemsCount - totalCount + totalGroupCount)
                    },
                    _isGroupExpanded: function(groupIndex) {
                        var groups = this._dataSource.group();
                        return isGroupExpanded(groups, groupIndex)
                    },
                    _updatePagingOptions: function(options) {
                        var that = this,
                            isVirtualPaging = that._isVirtualPaging(),
                            pageSize = that._dataSource.pageSize(),
                            skips = [],
                            takes = [],
                            skipChildrenTotalCount = 0,
                            childrenTotalCount = 0;
                        if (options.take) {
                            foreachExpandedGroups(this, function(groupInfo) {
                                groupInfo.childrenTotalCount = 0;
                                groupInfo.skipChildrenTotalCount = 0
                            });
                            foreachExpandedGroups(that, function(groupInfo, parents) {
                                var skip,
                                    take,
                                    takeCorrection = 0,
                                    parentTakeCorrection = 0,
                                    totalOffset = getTotalOffset(parents, isVirtualPaging ? 0 : pageSize, childrenTotalCount),
                                    continuationGroupCount = 0,
                                    skipContinuationGroupCount = 0,
                                    groupInfoCount = groupInfo.count + groupInfo.childrenTotalCount,
                                    childrenGroupInfoCount = groupInfoCount;
                                skip = options.skip - totalOffset;
                                if (totalOffset <= options.skip + options.take && groupInfoCount) {
                                    take = options.take;
                                    if (!isVirtualPaging) {
                                        continuationGroupCount = getContinuationGroupCount(totalOffset, pageSize, groupInfoCount, parents.length - 1);
                                        groupInfoCount += continuationGroupCount * parents.length;
                                        childrenGroupInfoCount += continuationGroupCount;
                                        if (pageSize && skip >= 0) {
                                            takeCorrection = parents.length;
                                            parentTakeCorrection = parents.length - 1;
                                            skipContinuationGroupCount = Math.floor(skip / pageSize)
                                        }
                                    }
                                    if (skip >= 0) {
                                        if (totalOffset + groupInfoCount > options.skip)
                                            skips.unshift(skip - skipContinuationGroupCount * takeCorrection - groupInfo.skipChildrenTotalCount);
                                        if (totalOffset + groupInfoCount >= options.skip + take)
                                            takes.unshift(take - takeCorrection - groupInfo.childrenTotalCount + groupInfo.skipChildrenTotalCount)
                                    }
                                    else if (totalOffset + groupInfoCount >= options.skip + take)
                                        takes.unshift(take + skip - groupInfo.childrenTotalCount)
                                }
                                if (totalOffset <= options.skip)
                                    if (parents[parents.length - 2])
                                        parents[parents.length - 2].skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1 - skipContinuationGroupCount * parentTakeCorrection);
                                    else
                                        skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1);
                                if (totalOffset <= options.skip + take) {
                                    groupInfoCount = Math.min(childrenGroupInfoCount, skip + take - (skipContinuationGroupCount + 1) * parentTakeCorrection);
                                    if (parents[parents.length - 2])
                                        parents[parents.length - 2].childrenTotalCount += groupInfoCount;
                                    else
                                        childrenTotalCount += groupInfoCount
                                }
                            });
                            options.skip -= skipChildrenTotalCount;
                            options.take -= childrenTotalCount - skipChildrenTotalCount
                        }
                        options.skips = skips;
                        options.takes = takes
                    },
                    changeRowExpand: function(path) {
                        var that = this,
                            groupInfo = that.findGroupInfo(path);
                        if (groupInfo) {
                            groupInfo.isExpanded = !groupInfo.isExpanded;
                            return $.Deferred().resolve()
                        }
                        return $.Deferred().reject()
                    },
                    handleDataLoadedCore: function(options, callBase) {
                        var that = this,
                            groupCount = normalizeSortingInfo(options.storeLoadOptions.group || options.loadOptions.group).length,
                            totalCount,
                            expandedInfo = {};
                        if (options.isCustomLoading) {
                            callBase(options);
                            processGroupItems(that, options.data, groupCount, expandedInfo, [], options.isCustomLoading, options.storeLoadOptions.isLoadingAll)
                        }
                        else {
                            totalCount = updateGroupInfos(that, options.data, groupCount, 0);
                            if (totalCount < 0) {
                                options.data = $.Deferred().reject(errors.Error("E1037"));
                                return
                            }
                            if (!options.remoteOperations.paging)
                                if (groupCount && options.extra && options.loadOptions.requireTotalCount) {
                                    options.extra.totalCount = totalCount;
                                    options.extra.totalGroupCount = options.data.length
                                }
                            that.updateTotalItemsCount(options);
                            that._updatePagingOptions(options);
                            callBase(options);
                            that._processPaging(options, groupCount);
                            processGroupItems(that, options.data, groupCount, expandedInfo, []);
                            expandedInfo.skip = options.skips[groupCount - 1];
                            if (options.takes[groupCount - 1] !== undefined) {
                                expandedInfo.take = expandedInfo.count ? expandedInfo.count - (expandedInfo.skip || 0) : 0;
                                expandedInfo.take += options.takes[groupCount - 1]
                            }
                        }
                        if (expandedInfo.paths.length && options.storeLoadOptions.group)
                            loadLastLevelGroupItems(that, options, expandedInfo);
                        if (!options.isCustomLoading)
                            $.when(options.data).done(function(data) {
                                that.updateItemsCount(data, groupCount)
                            })
                    },
                    _processPaging: function(options, groupCount) {
                        var skips,
                            takes,
                            i,
                            item,
                            items;
                        skips = options.skips;
                        takes = options.takes;
                        items = options.data;
                        for (i = 0; items && i < groupCount; i++) {
                            item = items[0];
                            items = item && item.items;
                            if (skips[i] !== undefined) {
                                item.isContinuation = true;
                                if (items) {
                                    items = items.slice(skips[i]);
                                    item.items = items
                                }
                            }
                        }
                        items = options.data;
                        for (i = 0; items && i < groupCount; i++) {
                            item = items[items.length - 1];
                            items = item && item.items;
                            if (item) {
                                var maxTakeCount = item.count - (item.isContinuation && skips[i] || 0) || items.length;
                                if (takes[i] !== undefined && maxTakeCount > takes[i]) {
                                    item.isContinuationOnNextPage = true;
                                    if (items) {
                                        items = items.slice(0, takes[i]);
                                        item.items = items
                                    }
                                }
                            }
                        }
                    },
                    refresh: function(options) {
                        var that = this,
                            storeLoadOptions = options.storeLoadOptions,
                            oldGroups = normalizeSortingInfo(that._group),
                            isExpanded,
                            groupIndex;
                        function handleGroup(groupInfo, parents) {
                            if (parents.length === groupIndex + 1)
                                groupInfo.isExpanded = isExpanded
                        }
                        for (groupIndex = 0; groupIndex < oldGroups.length; groupIndex++) {
                            isExpanded = isGroupExpanded(storeLoadOptions.group, groupIndex);
                            if (isGroupExpanded(that._group, groupIndex) !== isExpanded)
                                that.foreachGroups(handleGroup)
                        }
                        that.callBase.apply(this, arguments);
                        that.foreachGroups(function(groupInfo) {
                            groupInfo.count = 0
                        })
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.masterDetailModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            DATAGRID_MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
            DATAGRID_MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row",
            DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
            DATAGRID_ROW_LINES_CLASS = "dx-row-lines";
        $.extend(dataGrid.__internals, {
            DATAGRID_MASTER_DETAIL_CELL_CLASS: DATAGRID_MASTER_DETAIL_CELL_CLASS,
            DATAGRID_MASTER_DETAIL_ROW_CLASS: DATAGRID_MASTER_DETAIL_ROW_CLASS,
            DATAGRID_ROW_LINES_CLASS: DATAGRID_ROW_LINES_CLASS
        });
        dataGrid.registerModule("masterDetail", {
            defaultOptions: function() {
                return {masterDetail: {
                            enabled: false,
                            autoExpandAll: false,
                            template: null
                        }}
            },
            extenders: {
                controllers: {
                    columns: {_getExpandColumnsCore: function() {
                            var expandColumns = this.callBase();
                            if (this.option("masterDetail.enabled"))
                                expandColumns.push({});
                            return expandColumns
                        }},
                    data: function() {
                        var initMasterDetail = function(that) {
                                that._expandedItems = [];
                                that._isExpandAll = that.option("masterDetail.autoExpandAll")
                            };
                        return {
                                init: function() {
                                    var that = this;
                                    initMasterDetail(that);
                                    that.callBase()
                                },
                                expandAll: function(groupIndex) {
                                    var that = this;
                                    if (groupIndex < 0) {
                                        that._isExpandAll = true;
                                        that._expandedItems = [];
                                        that.updateItems()
                                    }
                                    else
                                        that.callBase.apply(that, arguments)
                                },
                                collapseAll: function(groupIndex) {
                                    var that = this;
                                    if (groupIndex < 0) {
                                        that._isExpandAll = false;
                                        that._expandedItems = [];
                                        that.updateItems()
                                    }
                                    else
                                        that.callBase.apply(that, arguments)
                                },
                                isRowExpanded: function(key) {
                                    var that = this,
                                        expandIndex = dataGrid.getIndexByKey(key, that._expandedItems);
                                    if (commonUtils.isArray(key))
                                        return that.callBase.apply(that, arguments);
                                    else
                                        return !!(that._isExpandAll ^ (expandIndex >= 0 && that._expandedItems[expandIndex].visible))
                                },
                                _changeRowExpandCore: function(key) {
                                    var that = this,
                                        expandIndex,
                                        rowIndex;
                                    if (commonUtils.isArray(key))
                                        return that.callBase.apply(that, arguments);
                                    else {
                                        expandIndex = dataGrid.getIndexByKey(key, that._expandedItems);
                                        if (expandIndex >= 0) {
                                            var visible = that._expandedItems[expandIndex].visible;
                                            that._expandedItems[expandIndex].visible = !visible
                                        }
                                        else
                                            that._expandedItems.push({
                                                key: key,
                                                visible: true
                                            });
                                        rowIndex = that.getRowIndexByKey(key);
                                        that.updateItems({
                                            changeType: "update",
                                            rowIndices: [rowIndex, rowIndex + 1]
                                        })
                                    }
                                },
                                _processDataItem: function(data, options) {
                                    var that = this,
                                        dataItem = that.callBase.apply(that, arguments);
                                    dataItem.isExpanded = that.isRowExpanded(dataItem.key);
                                    if (options.detailColumnIndex === undefined) {
                                        options.detailColumnIndex = -1;
                                        $.each(options.visibleColumns, function(index, column) {
                                            if (column.command === "expand" && !commonUtils.isDefined(column.groupIndex)) {
                                                options.detailColumnIndex = index;
                                                return false
                                            }
                                        })
                                    }
                                    if (options.detailColumnIndex >= 0)
                                        dataItem.values[options.detailColumnIndex] = dataItem.isExpanded;
                                    return dataItem
                                },
                                _processItems: function(items, changeType) {
                                    var that = this,
                                        expandIndex,
                                        result = [];
                                    items = that.callBase.apply(that, arguments);
                                    if (changeType === "loadingAll")
                                        return items;
                                    if (changeType === "refresh")
                                        that._expandedItems = $.grep(that._expandedItems, function(item) {
                                            return item.visible
                                        });
                                    $.each(items, function(index, item) {
                                        result.push(item);
                                        expandIndex = dataGrid.getIndexByKey(item.key, that._expandedItems);
                                        if (item.rowType === "data" && (item.isExpanded || expandIndex >= 0) && !item.inserted)
                                            result.push({
                                                visible: item.isExpanded,
                                                rowType: "detail",
                                                key: item.key,
                                                data: item.data,
                                                values: []
                                            })
                                    });
                                    return result
                                },
                                optionChanged: function(args) {
                                    var that = this,
                                        value,
                                        previousValue,
                                        isEnabledChanged,
                                        isAutoExpandAllChanged;
                                    if (args.name === "masterDetail") {
                                        args.name = "dataSource";
                                        switch (args.fullName) {
                                            case"masterDetail":
                                                value = args.value || {};
                                                previousValue = args.previousValue || {};
                                                isEnabledChanged = value.enabled !== previousValue.enabled;
                                                isAutoExpandAllChanged = value.autoExpandAll !== previousValue.autoExpandAll;
                                                break;
                                            case"masterDetail.enabled":
                                                isEnabledChanged = true;
                                                break;
                                            case"masterDetail.autoExpandAll":
                                                isAutoExpandAllChanged = true;
                                                break
                                        }
                                        if (isEnabledChanged || isAutoExpandAllChanged)
                                            initMasterDetail(that)
                                    }
                                    that.callBase(args)
                                }
                            }
                    }()
                },
                views: {rowsView: function() {
                        return {
                                _getColumnTemplate: function(options) {
                                    var that = this,
                                        column = options.column,
                                        template;
                                    if (column.command === "detail")
                                        template = that.option("masterDetail.template") || that._getDefaultTemplate(column);
                                    else
                                        template = that.callBase.apply(that, arguments);
                                    return template
                                },
                                _createRow: function(row) {
                                    var $row = this.callBase(row);
                                    if (row && row.rowType === "detail") {
                                        this.option("showRowLines") && $row.addClass(DATAGRID_ROW_LINES_CLASS);
                                        $row.addClass(DATAGRID_MASTER_DETAIL_ROW_CLASS).toggle(row.visible)
                                    }
                                    return $row
                                },
                                _getGroupCellOptions: function(options) {
                                    var row = options.row,
                                        groupColumns = this._columnsController.getGroupColumns(),
                                        columnIndex = groupColumns.length + options.columnsCountBeforeGroups,
                                        emptyCellsCount = columnIndex + Number(this.option("masterDetail.enabled"));
                                    if (row && row.rowType === "detail")
                                        return {
                                                columnIndex: columnIndex,
                                                emptyCellsCount: emptyCellsCount,
                                                colspan: options.columns.length - emptyCellsCount
                                            };
                                    return this.callBase(options)
                                },
                                _renderCells: function($row, options) {
                                    var row = options.row,
                                        $detailCell,
                                        groupCellOptions,
                                        i;
                                    if (row.rowType === "detail") {
                                        groupCellOptions = this._getGroupCellOptions(options);
                                        for (i = 0; i < groupCellOptions.emptyCellsCount; i++)
                                            this._renderCell($row, {
                                                value: null,
                                                row: row,
                                                rowIndex: row.rowIndex,
                                                column: options.columns[i]
                                            });
                                        $detailCell = this._renderCell($row, {
                                            value: null,
                                            row: row,
                                            rowIndex: row.rowIndex,
                                            column: {command: "detail"},
                                            columnIndex: groupCellOptions.columnIndex
                                        });
                                        $detailCell.addClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS).addClass(DATAGRID_MASTER_DETAIL_CELL_CLASS).attr("colspan", groupCellOptions.colspan)
                                    }
                                    else
                                        this.callBase.apply(this, arguments)
                                }
                            }
                    }()}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.editing.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            addNamespace = eventUtils.addNamespace,
            objectUtils = DX.require("/utils/utils.object"),
            commonUtils = DX.require("/utils/utils.common"),
            dialog = DX.require("/ui/ui.dialog"),
            Button = DX.require("/ui/widgets/ui.button"),
            errors = DevExpress.require("/ui/ui.errors"),
            devices = DX.require("/devices"),
            getIndexByKey = dataGrid.getIndexByKey;
        var DATAGRID_LINK_CLASS = "dx-link",
            DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
            DATAGRID_ROW_SELECTED = "dx-selection",
            DATAGRID_EDIT_ROW = "dx-edit-row",
            DATAGRID_EDIT_FORM_CLASS = "dx-datagrid-edit-form",
            DATAGRID_EDIT_BUTTON_CLASS = "dx-edit-button",
            DATAGRID_INSERT_INDEX = "__DX_INSERT_INDEX__",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_ROW_REMOVED = "dx-row-removed",
            DATAGRID_ROW_INSERTED = "dx-row-inserted",
            DATAGRID_ROW_MODIFIED = "dx-row-modified",
            DATAGRID_CELL_MODIFIED = "dx-cell-modified",
            DATAGRID_CELL_HIGHLIGHT_OUTLINE = "dx-highlight-outline",
            DATAGRID_EDITING_NAMESPACE = "dxDataGridEditing",
            DATAGRID_FOCUS_OVERLAY_CLASS = "dx-datagrid-focus-overlay",
            DATAGRID_READONLY_CLASS = "dx-datagrid-readonly",
            DATAGRID_DATA_ROW_CLASS = "dx-data-row",
            CHECKBOX_CLASS = "dx-checkbox",
            DATAGRID_EDITOR_INLINE_BLOCK = "dx-editor-inline-block",
            DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
            DATAGRID_EDIT_MODE_BATCH = "batch",
            DATAGRID_EDIT_MODE_ROW = "row",
            DATAGRID_EDIT_MODE_CELL = "cell",
            DATAGRID_EDIT_MODE_FORM = "form",
            DATA_EDIT_DATA_INSERT_TYPE = "insert",
            DATA_EDIT_DATA_UPDATE_TYPE = "update",
            DATA_EDIT_DATA_REMOVE_TYPE = "remove",
            DATAGRID_POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
            DATAGRID_POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target";
        var getEditMode = function(that) {
                var editMode = that.option("editing.mode");
                if (editMode === DATAGRID_EDIT_MODE_BATCH || editMode === DATAGRID_EDIT_MODE_CELL || editMode === DATAGRID_EDIT_MODE_FORM)
                    return editMode;
                return DATAGRID_EDIT_MODE_ROW
            };
        var isRowEditMode = function(that) {
                var editMode = getEditMode(that);
                return editMode === DATAGRID_EDIT_MODE_ROW || editMode === DATAGRID_EDIT_MODE_FORM
            };
        dataGrid.EditingController = dataGrid.ViewController.inherit(function() {
            var getDefaultEditorTemplate = function(that) {
                    return function(container, options) {
                            var $editor = $("<div/>").appendTo(container);
                            that.getController("editorFactory").createEditor($editor, $.extend({}, options.column, {
                                value: options.value,
                                setValue: options.setValue,
                                row: options.row,
                                parentType: "dataRow",
                                width: null,
                                readOnly: !options.setValue,
                                id: options.id
                            }))
                        }
                };
            return {
                    init: function() {
                        var that = this;
                        that._insertIndex = 1;
                        that._editRowIndex = -1;
                        that._editData = [];
                        that._editColumnIndex = -1;
                        that._columnsController = that.getController("columns");
                        that._dataController = that.getController("data");
                        if (!that._dataChangedHandler) {
                            that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
                            that._dataController.changed.add(that._dataChangedHandler)
                        }
                        if (!that._saveEditorHandler) {
                            that.createAction("onInitNewRow", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onRowInserting", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onRowInserted", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onEditingStart", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onRowUpdating", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onRowUpdated", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onRowRemoving", {excludeValidators: ["disabled", "readOnly"]});
                            that.createAction("onRowRemoved", {excludeValidators: ["disabled", "readOnly"]});
                            that._saveEditorHandler = that.createAction(function(e) {
                                var event = e.jQueryEvent,
                                    visibleColumns,
                                    isEditorPopup,
                                    isDomElement,
                                    isFocusOverlay,
                                    $targetCell,
                                    allowEditing,
                                    columnIndex,
                                    isDataRow,
                                    rowIndex;
                                if (!isRowEditMode(that) && that.isEditing() && !that._editCellInProgress) {
                                    isEditorPopup = $(event.target).closest(".dx-dropdowneditor-overlay").length;
                                    isDomElement = $(event.target).closest(document).length;
                                    isFocusOverlay = $(event.target).hasClass(DATAGRID_FOCUS_OVERLAY_CLASS);
                                    isDataRow = $(event.target).closest("." + DATAGRID_DATA_ROW_CLASS).length;
                                    visibleColumns = that._columnsController.getVisibleColumns();
                                    $targetCell = $(event.target).closest("." + DATAGRID_ROW_CLASS + "> td");
                                    columnIndex = $targetCell[0] && $targetCell[0].cellIndex;
                                    rowIndex = that.getView("rowsView").getRowIndex($targetCell.parent());
                                    allowEditing = visibleColumns[columnIndex] && visibleColumns[columnIndex].allowEditing;
                                    if ((!isDataRow || isDataRow && !allowEditing && !that.isEditCell(rowIndex, columnIndex)) && !isEditorPopup && !isFocusOverlay && isDomElement)
                                        that.closeEditCell()
                                }
                            });
                            $(document).on("dxclick", that._saveEditorHandler)
                        }
                        that._updateEditColumn();
                        that._updateEditButtons()
                    },
                    _handleDataChanged: function(args) {
                        if (this.option("scrolling.mode") === "standard")
                            this.resetRowAndPageIndeces();
                        if (args.changeType === "prepend")
                            $.each(this._editData, function(_, editData) {
                                editData.rowIndex += args.items.length;
                                if (editData.type === DATA_EDIT_DATA_INSERT_TYPE)
                                    editData.key.rowIndex += args.items.length
                            })
                    },
                    getEditMode: function() {
                        return getEditMode(this)
                    },
                    getFirstEditableColumnIndex: function() {
                        var columnsController = this.getController("columns"),
                            visibleColumns = columnsController.getVisibleColumns(),
                            columnIndex;
                        $.each(visibleColumns, function(index, column) {
                            if (column.allowEditing) {
                                columnIndex = index;
                                return false
                            }
                        });
                        return columnIndex
                    },
                    getFirstEditableCellInRow: function(rowIndex) {
                        return this.getView("rowsView").getCellElement(rowIndex ? rowIndex : 0, this.getFirstEditableColumnIndex())
                    },
                    getFocusedCellInRow: function(rowIndex) {
                        return this.getFirstEditableCellInRow(rowIndex)
                    },
                    getIndexByKey: function(key, items) {
                        return getIndexByKey(key, items)
                    },
                    hasChanges: function() {
                        var that = this,
                            result = false;
                        for (var i = 0; i < that._editData.length; i++)
                            if (that._editData[i].type) {
                                result = true;
                                break
                            }
                        return result
                    },
                    dispose: function() {
                        this.callBase();
                        $(document).off("dxclick", this._saveEditorHandler)
                    },
                    optionChanged: function(args) {
                        if (args.name === "editing") {
                            this.init();
                            args.handled = true
                        }
                        else
                            this.callBase(args)
                    },
                    publicMethods: function() {
                        return ["insertRow", "addRow", "removeRow", "deleteRow", "undeleteRow", "editRow", "editCell", "closeEditCell", "saveEditData", "cancelEditData", "hasEditData"]
                    },
                    refresh: function() {
                        if (getEditMode(this) !== DATAGRID_EDIT_MODE_BATCH)
                            this.init();
                        else {
                            this._editRowIndex = -1;
                            this._editColumnIndex = -1
                        }
                    },
                    isEditing: function() {
                        return this._editRowIndex > -1
                    },
                    isEditRow: function(rowIndex) {
                        return (getEditMode(this) === DATAGRID_EDIT_MODE_ROW || getEditMode(this) === DATAGRID_EDIT_MODE_FORM) && this._editRowIndex === rowIndex
                    },
                    getEditFormRowIndex: function() {
                        return getEditMode(this) === DATAGRID_EDIT_MODE_FORM ? this._editRowIndex : -1
                    },
                    isEditCell: function(rowIndex, columnIndex) {
                        return this._editRowIndex === rowIndex && this._editColumnIndex === columnIndex
                    },
                    _needInsertItem: function(editData, changeType) {
                        var that = this,
                            dataSource = that._dataController.dataSource(),
                            srollingMode = that.option("scrolling.mode"),
                            pageIndex = dataSource.pageIndex(),
                            beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : pageIndex,
                            endPageIndex = dataSource.endPageIndex ? dataSource.endPageIndex() : pageIndex;
                        if (srollingMode !== "standard")
                            switch (changeType) {
                                case"append":
                                    return editData.key.pageIndex === endPageIndex;
                                case"prepend":
                                    return editData.key.pageIndex === beginPageIndex;
                                case"refresh":
                                    editData.key.rowIndex = 0;
                                    editData.key.pageIndex = 0;
                                    break;
                                default:
                                    return editData.key.pageIndex >= beginPageIndex && editData.key.pageIndex <= endPageIndex
                            }
                        return editData.key.pageIndex === pageIndex
                    },
                    processItems: function(items, changeType) {
                        var that = this,
                            i,
                            key,
                            data,
                            editData = that._editData;
                        that.update(changeType);
                        for (i = 0; i < editData.length; i++) {
                            key = editData[i].key;
                            data = {key: key};
                            if (editData[i].type === DATA_EDIT_DATA_INSERT_TYPE && that._needInsertItem(editData[i], changeType)) {
                                data[DATAGRID_INSERT_INDEX] = key[DATAGRID_INSERT_INDEX];
                                items.splice(key.rowIndex, 0, data)
                            }
                        }
                        return items
                    },
                    processDataItem: function(item, columns, generateDataValues) {
                        var that = this,
                            editIndex,
                            editData,
                            data,
                            key = item.data[DATAGRID_INSERT_INDEX] ? item.data.key : item.key,
                            editMode;
                        editIndex = getIndexByKey(key, that._editData);
                        if (editIndex >= 0) {
                            editMode = getEditMode(that);
                            editData = that._editData[editIndex];
                            data = editData.data;
                            switch (editData.type) {
                                case DATA_EDIT_DATA_INSERT_TYPE:
                                    item.inserted = true;
                                    item.key = key;
                                    item.data = data;
                                    break;
                                case DATA_EDIT_DATA_UPDATE_TYPE:
                                    item.modified = true;
                                    item.oldData = item.data;
                                    item.data = $.extend(true, {}, item.data, data);
                                    item.modifiedValues = generateDataValues(data, columns);
                                    break;
                                case DATA_EDIT_DATA_REMOVE_TYPE:
                                    if (editMode === DATAGRID_EDIT_MODE_BATCH)
                                        item.data = $.extend(true, {}, item.data, data);
                                    item.removed = true;
                                    break
                            }
                        }
                    },
                    insertRow: function() {
                        errors.log("W0002", "dxDataGrid", "insertRow", "15.2", "Use the 'addRow' method instead");
                        return this.addRow()
                    },
                    addRow: function() {
                        var that = this,
                            dataController = that._dataController,
                            store = dataController.store(),
                            key = store && store.key(),
                            rowsView = that.getView("rowsView"),
                            param = {data: {}},
                            insertKey = {
                                pageIndex: dataController.pageIndex(),
                                rowIndex: rowsView ? rowsView.getTopVisibleItemIndex() : 0
                            },
                            oldEditRowIndex = that._editRowIndex,
                            editMode = getEditMode(that),
                            $firstCell;
                        if (editMode === DATAGRID_EDIT_MODE_CELL && that.hasChanges())
                            that.saveEditData();
                        that.refresh();
                        if (editMode !== DATAGRID_EDIT_MODE_BATCH && that._insertIndex > 1)
                            return;
                        if (!key)
                            param.data.__KEY__ = String(new DX.data.Guid);
                        that.executeAction("onInitNewRow", param);
                        if (editMode !== DATAGRID_EDIT_MODE_BATCH)
                            that._editRowIndex = insertKey.rowIndex;
                        insertKey[DATAGRID_INSERT_INDEX] = that._insertIndex++;
                        that._addEditData({
                            key: insertKey,
                            data: param.data,
                            type: DATA_EDIT_DATA_INSERT_TYPE
                        });
                        dataController.updateItems({
                            changeType: "update",
                            rowIndices: [oldEditRowIndex, insertKey.rowIndex]
                        });
                        $firstCell = that.getFirstEditableCellInRow(insertKey.rowIndex);
                        that._delayedInputFocus($firstCell, function() {
                            var $cell = that.getFirstEditableCellInRow(insertKey.rowIndex);
                            $cell && $cell.trigger("dxclick")
                        });
                        that._afterInsertRow({
                            key: insertKey,
                            data: param.data
                        })
                    },
                    _isEditingStart: function(options) {
                        this.executeAction("onEditingStart", options);
                        return options.cancel
                    },
                    _beforeEditCell: function(rowIndex, columnIndex, item) {
                        if (getEditMode(this) === DATAGRID_EDIT_MODE_CELL && !item.inserted && this.hasChanges()) {
                            this.saveEditData();
                            if (this.hasChanges())
                                return true
                        }
                    },
                    editRow: function(rowIndex) {
                        var that = this,
                            dataController = that._dataController,
                            items = dataController.items(),
                            item = items[rowIndex],
                            params = {
                                data: item.data,
                                cancel: false
                            },
                            oldEditRowIndex = that._editRowIndex,
                            $editingCell;
                        if (rowIndex === oldEditRowIndex)
                            return true;
                        if (!item.inserted)
                            params.key = item.key;
                        if (that._isEditingStart(params))
                            return;
                        that.init();
                        that._pageIndex = dataController.pageIndex();
                        that._editRowIndex = items[0].inserted ? rowIndex - 1 : rowIndex;
                        that._addEditData({
                            data: {},
                            key: item.key,
                            oldData: item.data
                        });
                        dataController.updateItems({
                            changeType: "update",
                            rowIndices: [oldEditRowIndex, rowIndex]
                        });
                        if (getEditMode(that) === DATAGRID_EDIT_MODE_ROW || getEditMode(that) === DATAGRID_EDIT_MODE_FORM) {
                            $editingCell = that.getFocusedCellInRow(that._editRowIndex);
                            that._delayedInputFocus($editingCell, function() {
                                $editingCell && that.component.focus($editingCell)
                            })
                        }
                    },
                    editCell: function(rowIndex, columnIndex) {
                        var that = this,
                            $cell,
                            columnsController = that._columnsController,
                            dataController = that._dataController,
                            items = dataController.items(),
                            item = items[rowIndex],
                            params = {
                                data: item && item.data,
                                cancel: false
                            },
                            oldEditRowIndex = that._editRowIndex,
                            oldEditColumnIndex = that._editColumnIndex,
                            columns = columnsController.getVisibleColumns(),
                            showEditorAlways;
                        if (commonUtils.isString(columnIndex)) {
                            columnIndex = columnsController.columnOption(columnIndex, "index");
                            columnIndex = columnsController.getVisibleIndex(columnIndex)
                        }
                        params.column = columnsController.getVisibleColumns()[columnIndex];
                        showEditorAlways = params.column && params.column.showEditorAlways;
                        if (params.column && item && item.rowType === "data" && !item.removed && !isRowEditMode(that)) {
                            if (this.isEditCell(rowIndex, columnIndex))
                                return true;
                            if (that._beforeEditCell(rowIndex, columnIndex, item))
                                return true;
                            if (!item.inserted)
                                params.key = item.key;
                            if (that._isEditingStart(params))
                                return true;
                            that._editRowIndex = rowIndex;
                            that._editColumnIndex = columnIndex;
                            that._pageIndex = dataController.pageIndex();
                            that._addEditData({
                                data: {},
                                key: item.key,
                                oldData: item.data
                            });
                            if (!showEditorAlways || columns[oldEditColumnIndex] && !columns[oldEditColumnIndex].showEditorAlways) {
                                that._editCellInProgress = true;
                                that.getController("editorFactory").loseFocus();
                                dataController.updateItems({
                                    changeType: "update",
                                    rowIndices: [oldEditRowIndex, that._editRowIndex]
                                })
                            }
                            $cell = that.getView("rowsView").getCellElement(that._editRowIndex, that._editColumnIndex);
                            if (!$cell.find(":focus").length)
                                that._focusEditingCell(function() {
                                    that._editCellInProgress = false
                                }, $cell);
                            else
                                that._editCellInProgress = false;
                            return true
                        }
                        return false
                    },
                    _delayedInputFocus: function($cell, beforeFocusCallback) {
                        function inputFocus() {
                            if (beforeFocusCallback)
                                beforeFocusCallback();
                            $cell && $cell.find("[tabindex], input").first().focus()
                        }
                        if (devices.real().ios)
                            inputFocus();
                        else
                            setTimeout(inputFocus)
                    },
                    _focusEditingCell: function(beforeFocusCallback, $editCell) {
                        var that = this;
                        $editCell = $editCell || that.getView("rowsView").getCellElement(that._editRowIndex, that._editColumnIndex);
                        that._delayedInputFocus($editCell, beforeFocusCallback)
                    },
                    removeRow: function(rowIndex) {
                        errors.log("W0002", "dxDataGrid", "removeRow", "15.2", "Use the 'deleteRow' method instead");
                        return this.deleteRow(rowIndex)
                    },
                    deleteRow: function(rowIndex) {
                        var that = this,
                            editingOptions = that.option("editing"),
                            editingTexts = editingOptions && editingOptions.texts,
                            confirmDeleteTitle = editingTexts && editingTexts.confirmDeleteTitle,
                            isBatchMode = editingOptions && editingOptions.mode === DATAGRID_EDIT_MODE_BATCH,
                            confirmDeleteMessage = editingTexts && editingTexts.confirmDeleteMessage,
                            dataController = that._dataController,
                            removeByKey,
                            showDialogTitle,
                            oldEditRowIndex = that._editRowIndex,
                            item = dataController.items()[rowIndex],
                            key = item && item.key;
                        if (item) {
                            removeByKey = function(key) {
                                that.refresh();
                                var editIndex = getIndexByKey(key, that._editData);
                                if (editIndex >= 0)
                                    if (that._editData[editIndex].type === DATA_EDIT_DATA_INSERT_TYPE)
                                        that._editData.splice(editIndex, 1);
                                    else
                                        that._editData[editIndex].type = DATA_EDIT_DATA_REMOVE_TYPE;
                                else
                                    that._addEditData({
                                        key: key,
                                        oldData: item.data,
                                        type: DATA_EDIT_DATA_REMOVE_TYPE
                                    });
                                if (isBatchMode)
                                    dataController.updateItems({
                                        changeType: "update",
                                        rowIndices: [oldEditRowIndex, rowIndex]
                                    });
                                else
                                    that.saveEditData()
                            };
                            if (isBatchMode || !confirmDeleteMessage)
                                removeByKey(key);
                            else {
                                showDialogTitle = commonUtils.isDefined(confirmDeleteTitle) && confirmDeleteTitle.length > 0;
                                dialog.confirm(confirmDeleteMessage, confirmDeleteTitle, showDialogTitle).done(function(confirmResult) {
                                    if (confirmResult)
                                        removeByKey(key)
                                })
                            }
                        }
                    },
                    undeleteRow: function(rowIndex) {
                        var that = this,
                            dataController = that._dataController,
                            item = dataController.items()[rowIndex],
                            oldEditRowIndex = that._editRowIndex,
                            key = item && item.key;
                        if (item) {
                            var editIndex = getIndexByKey(key, that._editData),
                                editData;
                            if (editIndex >= 0) {
                                editData = that._editData[editIndex];
                                if ($.isEmptyObject(editData.data))
                                    that._editData.splice(editIndex, 1);
                                else
                                    editData.type = DATA_EDIT_DATA_UPDATE_TYPE;
                                dataController.updateItems({
                                    changeType: "update",
                                    rowIndices: [oldEditRowIndex, rowIndex]
                                })
                            }
                        }
                    },
                    _saveEditDataCore: function(deferreds, processedKeys) {
                        var that = this,
                            store = that._dataController.store(),
                            hasCanceledData = false;
                        function executeEditingAction(actionName, params, func) {
                            var deferred = $.Deferred();
                            that.executeAction(actionName, params);
                            function createFailureHandler(deferred) {
                                return function(arg) {
                                        var error = arg instanceof Error ? arg : new Error(arg && String(arg) || "Unknown error");
                                        deferred.reject(error)
                                    }
                            }
                            $.when(params.cancel).done(function(cancel) {
                                if (cancel)
                                    deferred.resolve("cancel");
                                else
                                    func(params).done(deferred.resolve).fail(createFailureHandler(deferred))
                            }).fail(createFailureHandler(deferred));
                            return deferred
                        }
                        $.each(that._editData, function(index, editData) {
                            var data = editData.data,
                                oldData = editData.oldData,
                                key = editData.key,
                                type = editData.type,
                                deferred,
                                doneDeferred,
                                params;
                            if (that._beforeSaveEditData(editData, index))
                                return;
                            switch (type) {
                                case DATA_EDIT_DATA_REMOVE_TYPE:
                                    params = {
                                        data: oldData,
                                        key: key,
                                        cancel: false
                                    };
                                    deferred = executeEditingAction("onRowRemoving", params, function() {
                                        return store.remove(key)
                                    });
                                    break;
                                case DATA_EDIT_DATA_INSERT_TYPE:
                                    params = {
                                        data: data,
                                        cancel: false
                                    };
                                    deferred = executeEditingAction("onRowInserting", params, function() {
                                        return store.insert(params.data)
                                    });
                                    break;
                                case DATA_EDIT_DATA_UPDATE_TYPE:
                                    params = {
                                        newData: data,
                                        oldData: oldData,
                                        key: key,
                                        cancel: false
                                    };
                                    deferred = executeEditingAction("onRowUpdating", params, function() {
                                        return store.update(key, params.newData)
                                    });
                                    break
                            }
                            if (deferred) {
                                doneDeferred = $.Deferred();
                                deferred.always(function() {
                                    processedKeys.push(key)
                                }).always(doneDeferred.resolve);
                                deferreds.push(doneDeferred.promise())
                            }
                        });
                        return hasCanceledData
                    },
                    _processSaveEditDataResult: function(results, processedKeys) {
                        var that = this,
                            dataController = that._dataController,
                            i,
                            arg,
                            editIndex,
                            isError,
                            editMode = getEditMode(that);
                        for (i = 0; i < results.length; i++) {
                            arg = results[i];
                            editIndex = getIndexByKey(processedKeys[i], that._editData);
                            if (that._editData[editIndex]) {
                                isError = arg && arg instanceof Error;
                                if (isError) {
                                    that._editData[editIndex].error = arg;
                                    dataController.dataErrorOccurred.fire(arg);
                                    if (editMode !== DATAGRID_EDIT_MODE_BATCH)
                                        return false
                                }
                                else if (arg !== "cancel")
                                    that._editData.splice(editIndex, 1);
                                else
                                    return false
                            }
                        }
                        return true
                    },
                    _fireSaveEditDataEvents: function(editData) {
                        var that = this;
                        $.each(editData, function(_, itemData) {
                            var data = itemData.data,
                                key = itemData.key,
                                type = itemData.type,
                                params = {
                                    key: key,
                                    data: data
                                };
                            if (itemData.error)
                                params.error = itemData.error;
                            switch (type) {
                                case DATA_EDIT_DATA_REMOVE_TYPE:
                                    that.executeAction("onRowRemoved", $.extend({}, params, {data: itemData.oldData}));
                                    break;
                                case DATA_EDIT_DATA_INSERT_TYPE:
                                    that.executeAction("onRowInserted", params);
                                    break;
                                case DATA_EDIT_DATA_UPDATE_TYPE:
                                    that.executeAction("onRowUpdated", params);
                                    break
                            }
                        })
                    },
                    saveEditData: function() {
                        var that = this,
                            processedKeys = [],
                            deferreds = [],
                            dataController = that._dataController,
                            editData = $.extend({}, that._editData),
                            editMode = getEditMode(that),
                            result = $.Deferred();
                        var resetEditIndices = function(that) {
                                that._editColumnIndex = -1;
                                that._editRowIndex = -1
                            };
                        if (that._beforeSaveEditData()) {
                            that._afterSaveEditData();
                            return
                        }
                        that._saveEditDataCore(deferreds, processedKeys);
                        if (deferreds.length) {
                            $.when.apply($, deferreds).done(function() {
                                if (that._processSaveEditDataResult(arguments, processedKeys)) {
                                    resetEditIndices(that);
                                    $.when(dataController.refresh()).always(function() {
                                        that._fireSaveEditDataEvents(editData);
                                        that._afterSaveEditData();
                                        result.resolve()
                                    })
                                }
                            }).fail(result.resolve);
                            return result.promise()
                        }
                        if (isRowEditMode(that)) {
                            if (!that.hasChanges())
                                that.cancelEditData()
                        }
                        else if (editMode === DATAGRID_EDIT_MODE_BATCH || editMode === DATAGRID_EDIT_MODE_CELL) {
                            resetEditIndices(that);
                            dataController.updateItems()
                        }
                        else
                            that._focusEditingCell();
                        that._afterSaveEditData();
                        return result.resolve().promise()
                    },
                    _updateEditColumn: function() {
                        var that = this,
                            editing = that.option("editing"),
                            editMode = getEditMode(that),
                            isEditColumnVisible = editing && ((editing.allowUpdating || editing.allowAdding) && editMode === DATAGRID_EDIT_MODE_ROW || editing.allowUpdating && editMode === DATAGRID_EDIT_MODE_FORM || editing.allowDeleting);
                        that._columnsController.addCommandColumn({
                            command: "edit",
                            visible: isEditColumnVisible,
                            cssClass: "dx-command-edit",
                            width: "auto"
                        });
                        that._columnsController.columnOption("command:edit", "visible", isEditColumnVisible)
                    },
                    _updateEditButtons: function() {
                        var that = this,
                            saveChangesButton = that._saveChangesButton,
                            cancelChangesButton = that._cancelChangesButton,
                            hasChanges = that.hasChanges();
                        if (saveChangesButton)
                            saveChangesButton.option("disabled", !hasChanges);
                        if (cancelChangesButton)
                            cancelChangesButton.option("disabled", !hasChanges)
                    },
                    cancelEditData: function() {
                        var that = this,
                            dataController = that._dataController;
                        that._beforeCancelEditData();
                        that.init();
                        dataController.updateItems()
                    },
                    hasEditData: function() {
                        return this.hasChanges()
                    },
                    closeEditCell: function() {
                        var that = this,
                            editMode = getEditMode(that),
                            oldEditRowIndex = that._editRowIndex,
                            dataController = that._dataController;
                        if (!isRowEditMode(that))
                            setTimeout(function() {
                                if (editMode === DATAGRID_EDIT_MODE_CELL && that.hasChanges())
                                    that.saveEditData();
                                else if (oldEditRowIndex >= 0) {
                                    that._editRowIndex = -1;
                                    that._editColumnIndex = -1;
                                    dataController.updateItems({
                                        changeType: "update",
                                        rowIndices: [oldEditRowIndex]
                                    })
                                }
                            })
                    },
                    update: function(changeType) {
                        var that = this,
                            dataController = that._dataController;
                        if (dataController && that._pageIndex !== dataController.pageIndex()) {
                            if (changeType === "refresh")
                                that.refresh();
                            that._pageIndex = dataController.pageIndex()
                        }
                        that._updateEditButtons()
                    },
                    updateFieldValue: function(options, value, text) {
                        var that = this,
                            data = {},
                            rowKey = options.key,
                            $cellElement = options.cellElement,
                            editMode = getEditMode(that),
                            params;
                        if (rowKey !== undefined && options.column.setCellValue) {
                            if (editMode === DATAGRID_EDIT_MODE_BATCH && $cellElement)
                                $cellElement.addClass(DATAGRID_CELL_MODIFIED);
                            options.value = value;
                            options.column.setCellValue(data, value, text);
                            if (text && options.column.displayValueMap)
                                options.column.displayValueMap[value] = text;
                            params = {
                                data: data,
                                key: rowKey,
                                oldData: options.data,
                                type: DATA_EDIT_DATA_UPDATE_TYPE
                            };
                            that._addEditData(params);
                            that._updateEditButtons();
                            if (options.column.showEditorAlways && getEditMode(that) === DATAGRID_EDIT_MODE_CELL && options.row && !options.row.inserted)
                                that.saveEditData().always(function() {
                                    that._editColumnIndex = options.columnIndex;
                                    that._editRowIndex = options.row.rowIndex;
                                    that._focusEditingCell()
                                });
                            else if (options.row && (text !== undefined || options.column.setCellValue !== options.column.defaultSetCellValue))
                                that._dataController.updateItems({
                                    changeType: "update",
                                    rowIndices: [options.row.rowIndex]
                                })
                        }
                    },
                    _addEditData: function(options) {
                        var that = this,
                            editDataIndex = getIndexByKey(options.key, that._editData);
                        if (editDataIndex < 0) {
                            editDataIndex = that._editData.length;
                            that._editData.push(options)
                        }
                        if (that._editData[editDataIndex]) {
                            options.type = that._editData[editDataIndex].type || options.type;
                            objectUtils.deepExtendArraySafe(that._editData[editDataIndex], {
                                data: options.data,
                                type: options.type
                            })
                        }
                        return editDataIndex
                    },
                    _formEditorPrepared: function(){},
                    getFormEditorTemplate: function(detailCellOptions, column, item) {
                        var that = this;
                        return function(options, $container) {
                                var cellOptions = $.extend({}, detailCellOptions, {
                                        value: column.calculateCellValue(detailCellOptions.data),
                                        column: $.extend({}, column, {editorOptions: item.editorOptions}),
                                        id: options.component.getItemID(item.name || item.dataField),
                                        columnIndex: column.index,
                                        setValue: column.allowEditing && function(value) {
                                            that.updateFieldValue(cellOptions, value)
                                        }
                                    });
                                var template = column.editCellTemplate || getDefaultEditorTemplate(that);
                                template($container, cellOptions);
                                that._formEditorPrepared(cellOptions, $container)
                            }
                    },
                    getEditFormTemplate: function(options) {
                        var that = this;
                        return function($container, detailOptions) {
                                var editFormOptions = that.option("editing.form"),
                                    items = that.option("editing.form.items"),
                                    userCustomizeItem = that.option("editing.form.customizeItem");
                                if (!items) {
                                    var columns = that.getController("columns").getColumns();
                                    items = [];
                                    $.each(columns, function(_, column) {
                                        items.push({
                                            column: column,
                                            name: column.name,
                                            dataField: column.dataField
                                        })
                                    })
                                }
                                that._createComponent($("<div>").appendTo($container), "dxForm", $.extend({}, editFormOptions, {
                                    items: items,
                                    formID: new DX.data.Guid,
                                    customizeItem: function(item) {
                                        var column = item.column || that._columnsController.columnOption(item.name || item.dataField);
                                        if (column) {
                                            item.label = item.label || {};
                                            item.label.text = item.label.text || column.caption;
                                            item.template = item.template || that.getFormEditorTemplate(detailOptions, column, item);
                                            item.column = column;
                                            if (column.formItem)
                                                $.extend(item, column.formItem)
                                        }
                                        userCustomizeItem && userCustomizeItem.call(this, item)
                                    }
                                }));
                                var $buttonsContainer = $("<div>").addClass("dx-datagrid-form-buttons-container").appendTo($container);
                                that._createComponent($("<div>").appendTo($buttonsContainer), Button, {
                                    text: that.option("editing.texts.saveRowChanges"),
                                    onClick: $.proxy(that.saveEditData, that)
                                });
                                that._createComponent($("<div>").appendTo($buttonsContainer), Button, {
                                    text: that.option("editing.texts.cancelRowChanges"),
                                    onClick: $.proxy(that.cancelEditData, that)
                                })
                            }
                    },
                    getColumnTemplate: function(options) {
                        var that = this,
                            column = options.column,
                            rowIndex = options.row && options.row.rowIndex,
                            template,
                            editingOptions,
                            editingTexts,
                            allowUpdating,
                            isRowMode = isRowEditMode(that),
                            isRowEditing = that.isEditRow(rowIndex),
                            isCellEditing = that.isEditCell(rowIndex, options.columnIndex),
                            editingStartOptions;
                        if ((column.showEditorAlways || column.setCellValue && (isRowEditing && column.allowEditing || isCellEditing)) && options.rowType === "data" && !commonUtils.isDefined(column.command)) {
                            allowUpdating = that.option("editing.allowUpdating");
                            if (((allowUpdating || isRowEditing) && column.allowEditing || isCellEditing) && (isRowMode && isRowEditing || !isRowMode)) {
                                if (column.showEditorAlways && !isRowMode) {
                                    editingStartOptions = {
                                        cancel: false,
                                        key: options.row.key,
                                        data: options.row.data,
                                        column: column
                                    };
                                    that._isEditingStart(editingStartOptions)
                                }
                                if (!editingStartOptions || !editingStartOptions.cancel)
                                    options.setValue = function(value, text) {
                                        that.updateFieldValue(options, value, text)
                                    }
                            }
                            template = column.editCellTemplate || getDefaultEditorTemplate(that)
                        }
                        else if (column.command === "edit" && options.rowType === "data")
                            template = function(container, options) {
                                var createLink = function(container, text, methodName, options) {
                                        var $link = $("<a />").addClass(DATAGRID_LINK_CLASS).text(text).on(addNamespace("dxclick", DATAGRID_EDITING_NAMESPACE), that.createAction(function(params) {
                                                var e = params.jQueryEvent;
                                                e.stopPropagation();
                                                setTimeout(function() {
                                                    options.row && that[methodName](options.row.rowIndex)
                                                })
                                            }));
                                        options.rtlEnabled ? container.prepend($link, "&nbsp;") : container.append($link, "&nbsp;")
                                    };
                                container.css("text-align", "center");
                                options.rtlEnabled = that.option("rtlEnabled");
                                editingOptions = that.option("editing") || {};
                                editingTexts = editingOptions.texts || {};
                                if (options.row && options.row.rowIndex === that._editRowIndex && isRowMode) {
                                    createLink(container, editingTexts.saveRowChanges, "saveEditData", options);
                                    createLink(container, editingTexts.cancelRowChanges, "cancelEditData", options)
                                }
                                else {
                                    if (editingOptions.allowUpdating && isRowMode)
                                        createLink(container, editingTexts.editRow, "editRow", options);
                                    if (editingOptions.allowDeleting)
                                        if (options.row.removed)
                                            createLink(container, editingTexts.undeleteRow, "undeleteRow", options);
                                        else
                                            createLink(container, editingTexts.deleteRow, "deleteRow", options)
                                }
                            };
                        else if (column.command === "detail" && options.rowType === "detail" && isRowEditing)
                            template = that.getEditFormTemplate(options);
                        return template
                    },
                    renderEditButtons: function(rootElement) {
                        var that = this,
                            insertButton = rootElement.find("." + DATAGRID_EDIT_BUTTON_CLASS),
                            editingOptions = that.option("editing") || {},
                            editingTexts = that.option("editing.texts") || {},
                            titleButtonTextByClassNames = {
                                cancel: editingTexts.cancelAllChanges,
                                save: editingTexts.saveAllChanges,
                                addrow: editingTexts.addRow
                            };
                        var createEditButton = function(rootElement, className, methodName) {
                                return that._createComponent($("<div />").addClass(DATAGRID_EDIT_BUTTON_CLASS).addClass("dx-datagrid-" + className + "-button").appendTo(rootElement), Button, {
                                        icon: "edit-button-" + className,
                                        onClick: function(options) {
                                            var e = options.jQueryEvent;
                                            e.stopPropagation();
                                            that[methodName]()
                                        },
                                        hint: titleButtonTextByClassNames && titleButtonTextByClassNames[className]
                                    })
                            };
                        if (insertButton.length)
                            insertButton.remove();
                        if ((editingOptions.allowUpdating || editingOptions.allowAdding || editingOptions.allowDeleting) && getEditMode(that) === DATAGRID_EDIT_MODE_BATCH) {
                            that._cancelChangesButton = createEditButton(rootElement, "cancel", "cancelEditData");
                            that._saveChangesButton = createEditButton(rootElement, "save", "saveEditData");
                            that._updateEditButtons()
                        }
                        if (editingOptions.allowAdding)
                            createEditButton(rootElement, "addrow", "addRow")
                    },
                    createHighlightCell: function($cell) {
                        var $highlight = $cell.find("." + DATAGRID_CELL_HIGHLIGHT_OUTLINE);
                        if (!$highlight.length)
                            $cell.wrapInner($("<div>").addClass(DATAGRID_CELL_HIGHLIGHT_OUTLINE + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS))
                    },
                    resetRowAndPageIndeces: function(alwaysRest) {
                        var that = this;
                        $.each(that._editData, function(_, editData) {
                            if (editData.pageIndex !== that._pageIndex || alwaysRest) {
                                delete editData.pageIndex;
                                delete editData.rowIndex
                            }
                        })
                    },
                    _afterInsertRow: function(options){},
                    _beforeSaveEditData: function(editData, editIndex){},
                    _afterSaveEditData: function(){},
                    _beforeCancelEditData: function(){}
                }
        }());
        dataGrid.registerModule("editing", {
            defaultOptions: function() {
                return {editing: {
                            mode: "row",
                            allowAdding: false,
                            allowUpdating: false,
                            allowDeleting: false,
                            texts: {
                                editRow: Globalize.localize("dxDataGrid-editingEditRow"),
                                saveAllChanges: Globalize.localize("dxDataGrid-editingSaveAllChanges"),
                                saveRowChanges: Globalize.localize("dxDataGrid-editingSaveRowChanges"),
                                cancelAllChanges: Globalize.localize("dxDataGrid-editingCancelAllChanges"),
                                cancelRowChanges: Globalize.localize("dxDataGrid-editingCancelRowChanges"),
                                addRow: Globalize.localize("dxDataGrid-editingAddRow"),
                                deleteRow: Globalize.localize("dxDataGrid-editingDeleteRow"),
                                undeleteRow: Globalize.localize("dxDataGrid-editingUndeleteRow"),
                                confirmDeleteMessage: Globalize.localize("dxDataGrid-editingConfirmDeleteMessage"),
                                confirmDeleteTitle: Globalize.localize("dxDataGrid-editingConfirmDeleteTitle")
                            },
                            form: {colCount: 2}
                        }}
            },
            controllers: {editing: dataGrid.EditingController},
            extenders: {
                controllers: {
                    data: {
                        init: function() {
                            this._editingController = this.getController("editing");
                            this.callBase()
                        },
                        reload: function(full) {
                            var d,
                                editingController = this.getController("editing");
                            this._editingController.refresh();
                            d = this.callBase(full);
                            return d && d.done(function() {
                                    editingController.resetRowAndPageIndeces(true)
                                })
                        },
                        _updateItemsCore: function(change) {
                            this.callBase(change);
                            var editFormItem = this.items()[this.getController("editing").getEditFormRowIndex()];
                            if (editFormItem)
                                editFormItem.rowType = "detail"
                        },
                        _processItems: function(items, changeType) {
                            items = this._editingController.processItems(items, changeType);
                            return this.callBase(items, changeType)
                        },
                        _processDataItem: function(dataItem, options) {
                            this._editingController.processDataItem(dataItem, options.visibleColumns, this.generateDataValues);
                            return this.callBase(dataItem, options)
                        },
                        _processItem: function(item, options) {
                            item = this.callBase(item, options);
                            if (item.inserted) {
                                options.dataIndex--;
                                delete item.dataIndex
                            }
                            return item
                        }
                    },
                    columnsResizer: {_startResizing: function(args) {
                            var that = this,
                                editingController = that.getController("editing"),
                                isCellEditing = function() {
                                    var editingOptions = that.option("editing");
                                    return editingOptions && editingOptions.mode !== DATAGRID_EDIT_MODE_ROW && editingController.isEditing()
                                };
                            that.callBase(args);
                            if (that.isResizing() && isCellEditing())
                                editingController.closeEditCell()
                        }}
                },
                views: {
                    rowsView: {
                        publicMethods: function() {
                            return this.callBase().concat(["cellValue"])
                        },
                        _getColumnTemplate: function(options) {
                            var that = this,
                                template = that.getController("editing").getColumnTemplate(options);
                            return template || that.callBase(options)
                        },
                        _isNativeClick: function() {
                            return devices.real().ios && this.option("editing.allowUpdating")
                        },
                        _createTable: function() {
                            var that = this,
                                $table = that.callBase.apply(that, arguments);
                            if (!isRowEditMode(that) && that.option("editing.allowUpdating"))
                                $table.on(addNamespace("dxhold", "dxDataGridRowsView"), "td:not(." + DATAGRID_EDITOR_CELL_CLASS + ")", that.createAction(function(e) {
                                    var editingController = that.getController("editing");
                                    if (editingController.isEditing())
                                        editingController.closeEditCell()
                                }));
                            return $table
                        },
                        _createRow: function(row) {
                            var $row = this.callBase(row),
                                editingController,
                                isEditRow,
                                isRowRemoved,
                                isRowInserted,
                                isRowModified;
                            if (row) {
                                editingController = this.getController("editing");
                                isEditRow = editingController.isEditRow(row.rowIndex);
                                isRowRemoved = !!row.removed;
                                isRowInserted = !!row.inserted;
                                isRowModified = !!row.modified;
                                if (getEditMode(this) === DATAGRID_EDIT_MODE_BATCH)
                                    isRowRemoved && $row.addClass(DATAGRID_ROW_REMOVED);
                                else
                                    isEditRow && $row.addClass(DATAGRID_EDIT_ROW);
                                isRowInserted && $row.addClass(DATAGRID_ROW_INSERTED);
                                isRowModified && $row.addClass(DATAGRID_ROW_MODIFIED);
                                if (isEditRow || isRowInserted || isRowRemoved)
                                    $row.removeClass(DATAGRID_ROW_SELECTED);
                                if (isEditRow && row.rowType === "detail")
                                    $row.addClass(DATAGRID_EDIT_FORM_CLASS)
                            }
                            return $row
                        },
                        _rowClick: function(e) {
                            var that = this,
                                editingController = that.getController("editing"),
                                $targetCell = $(e.jQueryEvent.target).closest("." + DATAGRID_ROW_CLASS + "> td"),
                                columnIndex = that.getCellIndex($targetCell),
                                allowUpdating = that.option("editing.allowUpdating"),
                                column = that._columnsController.getVisibleColumns()[columnIndex],
                                allowEditing = column && (column.allowEditing || editingController.isEditCell(e.rowIndex, columnIndex));
                            if ($targetCell.hasClass(DATAGRID_POINTER_EVENTS_NONE_CLASS))
                                return;
                            if (!(allowUpdating && allowEditing && editingController.editCell(e.rowIndex, columnIndex)) && !editingController.isEditRow(e.rowIndex))
                                that.callBase(e)
                        },
                        _cellPrepared: function($cell, parameters) {
                            var columnIndex = parameters.columnIndex,
                                editingController = this.getController("editing"),
                                isCommandCell = !!parameters.column.command,
                                isEditableCell = parameters.setValue;
                            parameters.isEditing = editingController.isEditCell(parameters.rowIndex, parameters.columnIndex) || editingController.isEditRow(parameters.rowIndex) && parameters.column.allowEditing;
                            if (!commonUtils.isDefined(parameters.column.command) && (parameters.isEditing || parameters.column.showEditorAlways)) {
                                var alignment = parameters.column.alignment;
                                $cell.addClass(DATAGRID_EDITOR_CELL_CLASS).toggleClass(DATAGRID_READONLY_CLASS, !isEditableCell).toggleClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS, !isEditableCell);
                                if (alignment)
                                    $cell.find("input").first().css("text-align", alignment)
                            }
                            var firstChild = $cell.get(0).firstChild;
                            if (firstChild && firstChild.className && firstChild.className.indexOf(CHECKBOX_CLASS) >= 0)
                                $cell.addClass(DATAGRID_EDITOR_INLINE_BLOCK).toggleClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS, isCommandCell || !isEditableCell);
                            var modifiedValues = parameters.row && (parameters.row.inserted ? parameters.row.values : parameters.row.modifiedValues);
                            if (modifiedValues && modifiedValues[columnIndex] !== undefined && parameters.column && !isCommandCell) {
                                editingController.createHighlightCell($cell);
                                $cell.addClass(DATAGRID_CELL_MODIFIED)
                            }
                            else if (isEditableCell)
                                editingController.createHighlightCell($cell, true);
                            this.callBase.apply(this, arguments)
                        },
                        _update: function(change) {
                            this.callBase(change);
                            if (change.changeType === "updateSelection")
                                this.getTableElements().children("tbody").children("." + DATAGRID_EDIT_ROW).removeClass(DATAGRID_ROW_SELECTED)
                        },
                        cellValue: function(rowIndex, columnIdentificator, value, text) {
                            var cellOptions = this.getCellOptions(rowIndex, columnIdentificator);
                            if (cellOptions)
                                if (value === undefined)
                                    return cellOptions.value;
                                else
                                    this.getController("editing").updateFieldValue(cellOptions, value, text || '')
                        }
                    },
                    headerPanel: {
                        _renderCore: function() {
                            this.callBase();
                            this.getController("editing").renderEditButtons(this.element())
                        },
                        isVisible: function() {
                            var that = this,
                                editingOptions = that.getController("editing").option("editing");
                            return that.callBase() || editingOptions && (editingOptions.allowAdding || (editingOptions.allowUpdating || editingOptions.allowDeleting) && editingOptions.mode === DATAGRID_EDIT_MODE_BATCH)
                        }
                    }
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_LINK_CLASS: DATAGRID_LINK_CLASS,
            DATAGRID_EDITOR_CELL_CLASS: DATAGRID_EDITOR_CELL_CLASS,
            DATAGRID_EDIT_ROW: DATAGRID_EDIT_ROW,
            DATAGRID_EDIT_BUTTON_CLASS: DATAGRID_EDIT_BUTTON_CLASS,
            DATAGRID_CELL_MODIFIED: DATAGRID_CELL_MODIFIED,
            DATAGRID_ROW_REMOVED: DATAGRID_ROW_REMOVED,
            DATAGRID_ROW_INSERTED: DATAGRID_ROW_INSERTED,
            DATAGRID_ROW_MODIFIED: DATAGRID_ROW_MODIFIED,
            DATAGRID_CELL_HIGHLIGHT_OUTLINE: DATAGRID_CELL_HIGHLIGHT_OUTLINE,
            DATAGRID_FOCUS_OVERLAY_CLASS: DATAGRID_FOCUS_OVERLAY_CLASS,
            DATAGRID_READONLY_CLASS: DATAGRID_READONLY_CLASS,
            DATAGRID_CELL_FOCUS_DISABLED_CLASS: DATAGRID_CELL_FOCUS_DISABLED_CLASS,
            DATAGRID_EDIT_FORM_CLASS: DATAGRID_EDIT_FORM_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.validationModule.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            Button = DX.require("/ui/widgets/ui.button"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer"),
            Validator = DX.require("/ui/widgets/ui.validator"),
            ValidationEngine = DX.require("/validationEngine");
        var DATAGRID_INVALIDATE_CLASS = "dx-datagrid-invalid",
            DATAGRID_INVALID_MESSAGE_CLASS = "dx-invalid-message",
            DATAGRID_INVALID_MESSAGE_ALWAYS_CLASS = "dx-invalid-message-always",
            DATAGRID_REVERT_BUTTON_CLASS = "dx-revert-button",
            DATAGRID_REVERT_TOOLTIP_CLASS = "dx-datagrid-revert-tooltip",
            DATAGRID_CELL_HIGHLIGHT_OUTLINE = "dx-highlight-outline",
            DATAGRID_INSERT_INDEX = "__DX_INSERT_INDEX__",
            DATAGRID_EDIT_MODE_ROW = "row",
            DATAGRID_EDIT_MODE_FORM = "form",
            DATAGRID_EDIT_MODE_BATCH = "batch",
            DATAGRID_EDIT_MODE_CELL = "cell";
        dataGrid.ValidatingController = dataGrid.Controller.inherit(function() {
            return {
                    init: function() {
                        this._editingController = this.getController("editing");
                        this.createAction("onRowValidating")
                    },
                    _rowValidating: function(editData, validate) {
                        var that = this,
                            brokenRules = validate ? validate.brokenRules || validate.brokenRule && [validate.brokenRule] : [],
                            isValid = validate ? validate.isValid : editData.isValid,
                            parameters = {
                                brokenRules: brokenRules,
                                isValid: isValid,
                                key: editData.key,
                                newData: editData.data,
                                oldData: editData.oldData,
                                errorText: null
                            };
                        that.executeAction("onRowValidating", parameters);
                        editData.isValid = parameters.isValid;
                        editData.errorText = parameters.errorText;
                        return parameters
                    },
                    validate: function(isFull) {
                        var that = this,
                            isValid = true,
                            editingController = that._editingController;
                        isFull = isFull || editingController.getEditMode() === DATAGRID_EDIT_MODE_ROW;
                        if (that._isValidationInProgress)
                            return false;
                        that._isValidationInProgress = true;
                        if (isFull)
                            $.each(editingController._editData, function(index, editData) {
                                var validationResult;
                                if (editData.type && editData.type !== "remove") {
                                    validationResult = that.validateGroup(editData);
                                    if (!validationResult.isValid)
                                        $.each(validationResult.brokenRules, function() {
                                            var value = this.validator.option("adapter").getValue();
                                            if (value === undefined)
                                                value = null;
                                            if (this.column)
                                                editingController.updateFieldValue({
                                                    key: editData.key,
                                                    column: this.column
                                                }, value, true)
                                        });
                                    isValid = isValid && validationResult.isValid
                                }
                            });
                        else if (that._currentCellValidator)
                            isValid = that.validateGroup(that._currentCellValidator._findGroup()).isValid;
                        that._isValidationInProgress = false;
                        return isValid
                    },
                    validateGroup: function(editData) {
                        var that = this,
                            validateGroup = ValidationEngine.getGroupConfig(editData),
                            validationResults;
                        if (validateGroup && validateGroup.validators.length)
                            validationResults = ValidationEngine.validateGroup(editData);
                        return that._rowValidating(editData, validationResults)
                    },
                    updateEditData: function(editData) {
                        if (this._editingController.getEditMode() !== DATAGRID_EDIT_MODE_FORM) {
                            this.setDisableApplyValidationResults(true);
                            editData.isValid = ValidationEngine.getGroupConfig(editData) ? ValidationEngine.validateGroup(editData).isValid : true;
                            this.setDisableApplyValidationResults(false)
                        }
                        else
                            editData.isValid = true
                    },
                    setValidator: function(validator) {
                        this._currentCellValidator = validator
                    },
                    getValidator: function() {
                        return this._currentCellValidator
                    },
                    removeValidators: function(editIndex) {
                        var that = this,
                            editingController = that._editingController;
                        $.each(editingController._editData, function(index, editData) {
                            var validateGroup = ValidationEngine.getGroupConfig(editData);
                            if (!commonUtils.isDefined(editIndex) || editIndex === index)
                                if (validateGroup)
                                    for (var i = 0; i < validateGroup.validators.length; i++) {
                                        validateGroup.validators[i]._dispose();
                                        i--
                                    }
                        })
                    },
                    createValidator: function(parameters, $container) {
                        var that = this,
                            editingController = that._editingController,
                            column = parameters.column,
                            editData,
                            editIndex = editingController.getIndexByKey(parameters.key, editingController._editData),
                            defaultValidationResult = function(options) {
                                if (options.brokenRule) {
                                    options.brokenRule.columnIndex = column.index;
                                    options.brokenRule.column = column
                                }
                                if ($container && !that.getDisableApplyValidationResults()) {
                                    if (!options.isValid) {
                                        var $focus = $container.find(":focus");
                                        editingController.createHighlightCell($container, true);
                                        if (!$focus.is(":focus"))
                                            $focus.focus().trigger(pointerEvents.down)
                                    }
                                    $container.toggleClass(DATAGRID_INVALIDATE_CLASS, !options.isValid)
                                }
                            };
                        if (!commonUtils.isArray(column.validationRules))
                            return;
                        if (editIndex < 0 && column.showEditorAlways)
                            editIndex = editingController._addEditData({key: parameters.key});
                        if (editIndex >= 0) {
                            editData = editingController._editData[editIndex];
                            return new Validator($container || {}, {
                                    name: column.caption,
                                    validationRules: $.extend(true, [], column.validationRules),
                                    validationGroup: editData,
                                    adapter: $container && $container.hasClass("dx-widget") ? null : {
                                        getValue: function() {
                                            var value = column.calculateCellValue(editData.data || {});
                                            return value !== undefined ? value : parameters.value
                                        },
                                        applyValidationResults: defaultValidationResult
                                    }
                                })
                        }
                    },
                    setDisableApplyValidationResults: function(flag) {
                        this._disableApplyValidationResults = flag
                    },
                    getDisableApplyValidationResults: function() {
                        return this._disableApplyValidationResults
                    }
                }
        }());
        dataGrid.registerModule("validating", {
            defaultOptions: function() {
                return {editing: {texts: {validationCancelChanges: Globalize.localize("dxDataGrid-validationCancelChanges")}}}
            },
            controllers: {validating: dataGrid.ValidatingController},
            extenders: {
                controllers: {
                    editing: {
                        _addEditData: function(options) {
                            var that = this,
                                validatingController = that.getController("validating"),
                                editDataIndex = that.callBase(options),
                                editData;
                            if (editDataIndex >= 0) {
                                editData = that._editData[editDataIndex];
                                validatingController.updateEditData(editData)
                            }
                            return editDataIndex
                        },
                        _updateRowAndPageIndices: function() {
                            var that = this,
                                startInsertIndex = that.getView("rowsView").getTopVisibleItemIndex(),
                                rowIndex = startInsertIndex;
                            $.each(that._editData, function(_, editData) {
                                if (!editData.isValid && editData.pageIndex !== that._pageIndex) {
                                    editData.pageIndex = that._pageIndex;
                                    if (editData.type === "insert")
                                        editData.rowIndex = startInsertIndex;
                                    else
                                        editData.rowIndex = rowIndex;
                                    rowIndex++
                                }
                            })
                        },
                        _needInsertItem: function(editData, changeType) {
                            var result = this.callBase.apply(this, arguments);
                            if (result && !editData.isValid)
                                result = editData.key.pageIndex === this._pageIndex;
                            return result
                        },
                        processItems: function(items, changeType) {
                            var that = this,
                                i,
                                itemsCount,
                                insertCount = 0,
                                editData = that._editData,
                                dataController = that.getController("data"),
                                getIndexByEditData = function(editData, items) {
                                    var index = -1,
                                        isInsert = editData.type === "insert",
                                        key = editData.key;
                                    $.each(items, function(i, item) {
                                        if (dataGrid.equalKeys(key, isInsert ? item : dataController.keyOf(item))) {
                                            index = i;
                                            return false
                                        }
                                    });
                                    return index
                                },
                                addInValidItem = function(editData) {
                                    var data = {key: editData.key},
                                        index = getIndexByEditData(editData, items),
                                        rowIndex;
                                    if (index >= 0)
                                        return;
                                    editData.rowIndex = editData.rowIndex > itemsCount ? editData.rowIndex % itemsCount : editData.rowIndex;
                                    rowIndex = editData.rowIndex;
                                    data[DATAGRID_INSERT_INDEX] = 1;
                                    if (index >= 0) {
                                        items.splice(index, 1);
                                        rowIndex -= insertCount
                                    }
                                    items.splice(rowIndex, 0, data);
                                    insertCount++
                                };
                            items = that.callBase(items, changeType);
                            itemsCount = items.length;
                            if (that.getEditMode() === DATAGRID_EDIT_MODE_BATCH && changeType !== "prepend" && changeType !== "append")
                                for (i = 0; i < editData.length; i++)
                                    if (editData[i].type && editData[i].pageIndex === that._pageIndex && editData[i].key.pageIndex !== that._pageIndex)
                                        addInValidItem(editData[i]);
                            return items
                        },
                        processDataItem: function(item, columns, generateDataValues) {
                            var that = this,
                                editIndex,
                                editData,
                                isInserted = item.data[DATAGRID_INSERT_INDEX],
                                key = isInserted ? item.data.key : item.key,
                                editMode = that.getEditMode();
                            if (editMode === DATAGRID_EDIT_MODE_BATCH && isInserted && key) {
                                editIndex = dataGrid.getIndexByKey(key, that._editData);
                                if (editIndex >= 0) {
                                    editData = that._editData[editIndex];
                                    if (editData.type !== "insert") {
                                        item.data = $.extend(true, {}, editData.oldData, editData.data);
                                        item.key = key
                                    }
                                }
                            }
                            that.callBase.apply(that, arguments)
                        },
                        _afterInsertRow: function(options) {
                            var validatingController = this.getController("validating"),
                                hiddenColumns = this.getController("columns").getHiddenColumns();
                            $.each(hiddenColumns, function(_, column) {
                                validatingController.createValidator({
                                    column: column,
                                    key: options.key,
                                    value: column.calculateCellValue(options.data)
                                })
                            });
                            this.callBase(options)
                        },
                        _beforeSaveEditData: function(editData, editIndex) {
                            var that = this,
                                isValid,
                                isFullValid,
                                result = that.callBase.apply(that, arguments),
                                validatingController = that.getController("validating");
                            if (editData) {
                                isValid = editData.type === "remove" || editData.isValid;
                                if (isValid)
                                    validatingController.removeValidators(editIndex);
                                result = result || !isValid
                            }
                            else {
                                isFullValid = validatingController.validate(true);
                                that._updateRowAndPageIndices();
                                if (that.getEditMode() === DATAGRID_EDIT_MODE_CELL) {
                                    if (!isFullValid) {
                                        that._focusEditingCell();
                                        result = true
                                    }
                                }
                                else if (that.getEditMode() === DATAGRID_EDIT_MODE_ROW)
                                    result = !isFullValid
                            }
                            return result
                        },
                        _beforeEditCell: function(rowIndex, columnIndex, item) {
                            var result = this.callBase(rowIndex, columnIndex, item),
                                $cell = this.component.getCellElement(rowIndex, columnIndex),
                                validator = $cell.data("dxValidator");
                            if (this.getEditMode(this) === DATAGRID_EDIT_MODE_CELL && (!validator || validator.validate().isValid))
                                return result
                        },
                        _afterSaveEditData: function() {
                            var that = this;
                            $.each(that._editData, function(_, editData) {
                                that._showErrorRow(editData)
                            })
                        },
                        _beforeCancelEditData: function() {
                            var validatingController = this.getController("validating");
                            validatingController.removeValidators();
                            this.callBase()
                        },
                        _showErrorRow: function(editData) {
                            var errorHandling = this.getController("errorHandling"),
                                items = this.getController("data").items(),
                                rowIndex = this.getIndexByKey(editData.key, items);
                            if (!editData.isValid && editData.errorText && rowIndex >= 0)
                                errorHandling && errorHandling.renderErrorRow(editData.errorText, rowIndex)
                        },
                        updateFieldValue: function(options, value) {
                            var that = this;
                            that.callBase.apply(that, arguments);
                            if (that.getEditMode() === DATAGRID_EDIT_MODE_ROW) {
                                var currentValidator = that.getController("validating").getValidator();
                                currentValidator && currentValidator.validate()
                            }
                        },
                        createHighlightCell: function($cell, skipValidation) {
                            var isValid = true,
                                validator;
                            if (!skipValidation) {
                                validator = $cell.data("dxValidator");
                                if (validator)
                                    isValid = validator.validate().isValid
                            }
                            if (isValid)
                                this.callBase($cell)
                        },
                        getEditDataByKey: function(key) {
                            return this._editData[dataGrid.getIndexByKey(key, this._editData)]
                        },
                        _formEditorPrepared: function(cellOptions, $container) {
                            this.callBase.apply(this, arguments);
                            this.getController("validating").createValidator(cellOptions, $container.children(".dx-widget"))
                        }
                    },
                    editorFactory: {
                        _showRevertButton: function($cell) {
                            var that = this,
                                $targetElement = $cell.find("." + DATAGRID_CELL_HIGHLIGHT_OUTLINE).first();
                            if ($targetElement.length)
                                $("<div>").addClass(DATAGRID_REVERT_TOOLTIP_CLASS).appendTo($cell).dxTooltip({
                                    animation: null,
                                    visible: true,
                                    target: $targetElement,
                                    closeOnOutsideClick: false,
                                    closeOnTargetScroll: false,
                                    boundary: that._rowsView.element(),
                                    contentTemplate: function() {
                                        return new Button($("<div>").addClass(DATAGRID_REVERT_BUTTON_CLASS), {
                                                icon: "revert",
                                                hint: that.option("editing.texts.validationCancelChanges"),
                                                onClick: function() {
                                                    that._editingController.cancelEditData()
                                                }
                                            }).element()
                                    },
                                    position: {
                                        my: "left top",
                                        at: "right top",
                                        of: $targetElement,
                                        offset: "1 0",
                                        collision: "flip"
                                    }
                                })
                        },
                        _showValidationMessage: function($cell, message, alignment) {
                            var that = this,
                                $highlightContainer = $cell.find("." + DATAGRID_CELL_HIGHLIGHT_OUTLINE);
                            $("<div/>").addClass(DATAGRID_INVALID_MESSAGE_CLASS).addClass(DATAGRID_INVALID_MESSAGE_ALWAYS_CLASS).text(message).appendTo($cell).dxOverlay({
                                target: $highlightContainer.length ? $highlightContainer : $cell,
                                container: $cell,
                                shading: false,
                                width: 'auto',
                                height: 'auto',
                                visible: true,
                                animation: false,
                                closeOnOutsideClick: false,
                                closeOnTargetScroll: false,
                                position: {
                                    collision: "fit flip",
                                    boundary: that._rowsView.element(),
                                    boundaryOffset: "0 0",
                                    my: "top " + alignment,
                                    at: "bottom " + alignment
                                },
                                onPositioned: function() {
                                    that._rowsView.element() && that._rowsView.updateFreeSpaceRowHeight()
                                }
                            })
                        },
                        init: function() {
                            this.callBase();
                            this._editingController = this.getController("editing");
                            this._rowsView = this.getView("rowsView")
                        },
                        loseFocus: function(skipValidator) {
                            if (!skipValidator)
                                this.getController("validating").setValidator(null);
                            this.callBase()
                        },
                        focus: function($element, hideBorder) {
                            var that = this,
                                $cell = $element && $element.closest("td"),
                                validator = $cell && $cell.data("dxValidator"),
                                rowOptions = $cell && $cell.parent().data("options"),
                                editData = rowOptions ? that.getController("editing").getEditDataByKey(rowOptions.key) : null,
                                validationResult,
                                $tooltips = $cell && $cell.closest(".dx-datagrid-rowsview").find(".dx-editor-cell .dx-tooltip, .dx-editor-cell .dx-invalid-message"),
                                column = $cell && that.getController("columns").getVisibleColumns()[$cell.index()];
                            $tooltips && $tooltips.remove();
                            if (validator && column) {
                                that.getController("validating").setValidator(validator);
                                if (validator.option("adapter").getValue() !== undefined) {
                                    validationResult = validator.validate();
                                    if (!validationResult.isValid) {
                                        hideBorder = true;
                                        that._showValidationMessage($cell, validationResult.brokenRule.message, column.alignment)
                                    }
                                }
                            }
                            if (validationResult && !validationResult.isValid || editData && editData.type === "update")
                                if (that._editingController.getEditMode() === DATAGRID_EDIT_MODE_CELL)
                                    that._showRevertButton($cell);
                            !hideBorder && that._rowsView.element() && that._rowsView.updateFreeSpaceRowHeight();
                            return that.callBase($element, hideBorder)
                        }
                    }
                },
                views: {rowsView: {
                        updateFreeSpaceRowHeight: function($table) {
                            var that = this,
                                $rowElements = that._getRowElements(),
                                $freeSpaceRowElements = that._getFreeSpaceRowElements($table),
                                $freeSpaceRowElement = $freeSpaceRowElements.first(),
                                $tooltipContent = that.element().find(".dx-invalid-message .dx-overlay-content");
                            that.callBase($table);
                            if ($tooltipContent.length && $freeSpaceRowElement && $rowElements.length === 1 && (!$freeSpaceRowElement.is(":visible") || $tooltipContent.outerHeight() > $freeSpaceRowElement.outerHeight())) {
                                $freeSpaceRowElements.show();
                                $freeSpaceRowElements.height($tooltipContent.outerHeight())
                            }
                        },
                        _cellPrepared: function($cell, parameters) {
                            this.getController("validating").createValidator(parameters, $cell);
                            this.callBase.apply(this, arguments)
                        }
                    }}
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_REVERT_TOOLTIP_CLASS: DATAGRID_REVERT_TOOLTIP_CLASS,
            DATAGRID_REVERT_BUTTON_CLASS: DATAGRID_REVERT_BUTTON_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.dataController.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            errors = DevExpress.require("/ui/ui.errors"),
            commonUtils = DX.require("/utils/utils.common"),
            DataHelperMixin = DX.require("/ui/ui.dataHelper");
        dataGrid.proxyMethod = function(instance, methodName, defaultResult) {
            if (!instance[methodName])
                instance[methodName] = function() {
                    var dataSource = this._dataSource;
                    return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult
                }
        };
        dataGrid.combineFilters = function(filters, operation) {
            var resultFilter = [],
                i;
            operation = operation || "and";
            for (i = 0; i < filters.length; i++) {
                if (!filters[i])
                    continue;
                if (resultFilter.length)
                    resultFilter.push(operation);
                resultFilter.push(filters[i])
            }
            if (resultFilter.length === 1)
                resultFilter = resultFilter[0];
            if (resultFilter.length)
                return resultFilter
        };
        dataGrid.DataController = dataGrid.Controller.inherit({}).include(DataHelperMixin).inherit(function() {
            var members = {
                    init: function() {
                        var that = this;
                        that._items = [];
                        that._columnsController = that.getController("columns");
                        that._columnsChangedHandler = $.proxy(that._handleColumnsChanged, that);
                        that._dataChangedHandler = $.proxy(that._handleDataChanged, that);
                        that._loadingChangedHandler = $.proxy(that._handleLoadingChanged, that);
                        that._loadErrorHandler = $.proxy(that._handleLoadError, that);
                        that._customizeStoreLoadOptionsHandler = $.proxy(that._handleCustomizeStoreLoadOptions, that);
                        that._columnsController.columnsChanged.add(that._columnsChangedHandler);
                        that._isLoading = false;
                        that._isCustomLoading = false;
                        that.createAction("onDataErrorOccurred");
                        that.dataErrorOccurred.add(function(error) {
                            return that.executeAction("onDataErrorOccurred", {error: error})
                        });
                        that._refreshDataSource()
                    },
                    callbackNames: function() {
                        return ["changed", "loadingChanged", "dataErrorOccurred", "pageChanged", "dataSourceChanged"]
                    },
                    callbackFlags: function(name) {
                        if (name === "dataErrorOccurred")
                            return "stopOnFalse"
                    },
                    publicMethods: function() {
                        return ["beginCustomLoading", "endCustomLoading", "refresh", "filter", "clearFilter", "getCombinedFilter", "keyOf", "byKey", "getDataByKeys", "pageIndex", "pageSize", "pageCount", "totalCount", "_disposeDataSource", "getKeyByRowIndex", "getRowIndexByKey"]
                    },
                    optionChanged: function(args) {
                        var that = this;
                        function handled() {
                            args.handled = true
                        }
                        function reload() {
                            that._columnsController.reset();
                            that._refreshDataSource()
                        }
                        if (args.name === "dataSource" && args.name === args.fullName && args.value === args.previousValue) {
                            handled();
                            that.refresh();
                            return
                        }
                        switch (args.name) {
                            case"cacheEnabled":
                            case"loadingTimeout":
                            case"remoteOperations":
                                handled();
                                break;
                            case"dataSource":
                            case"scrolling":
                            case"paging":
                                handled();
                                reload();
                                break;
                            case"rtlEnabled":
                                reload();
                                break;
                            default:
                                that.callBase(args)
                        }
                    },
                    isReady: function() {
                        return !this._isLoading
                    },
                    getCombinedFilter: function() {
                        return this.combinedFilter()
                    },
                    combinedFilter: function(filter) {
                        var that = this,
                            dataSource = that._dataSource,
                            columnsController = that._columnsController,
                            additionalFilter;
                        if (dataSource) {
                            if (filter === undefined)
                                filter = dataSource.filter();
                            additionalFilter = that._calculateAdditionalFilter();
                            if (additionalFilter)
                                if (columnsController.isDataSourceApplied() || columnsController.isAllDataTypesDefined())
                                    filter = dataGrid.combineFilters([additionalFilter, filter]);
                            filter = columnsController.updateFilter(filter, !dataSource.remoteOperations().filtering)
                        }
                        return filter
                    },
                    _handleCustomizeStoreLoadOptions: function(e) {
                        var columnsController = this._columnsController,
                            dataSource = this._dataSource,
                            storeLoadOptions = e.storeLoadOptions;
                        if (e.isCustomLoading && !storeLoadOptions.isLoadingAll)
                            return;
                        storeLoadOptions.filter = this.combinedFilter(storeLoadOptions.filter);
                        if (!columnsController.isDataSourceApplied())
                            columnsController.updateColumnDataTypes(dataSource);
                        this._columnsUpdating = true;
                        columnsController.updateSortingGrouping(dataSource, !this._isFirstLoading);
                        this._columnsUpdating = false;
                        storeLoadOptions.sort = columnsController.getSortDataSourceParameters();
                        storeLoadOptions.group = columnsController.getGroupDataSourceParameters();
                        dataSource.sort(storeLoadOptions.sort);
                        dataSource.group(storeLoadOptions.group);
                        storeLoadOptions.sort = columnsController.getSortDataSourceParameters(!dataSource.remoteOperations().sorting);
                        e.group = columnsController.getGroupDataSourceParameters(true);
                        this._isFirstLoading = false
                    },
                    _handleColumnsChanged: function(e) {
                        var that = this,
                            changeTypes = e.changeTypes,
                            optionNames = e.optionNames,
                            filterValue,
                            filterValues;
                        var updateItemsHandler = function() {
                                that._columnsController.columnsChanged.remove(updateItemsHandler);
                                that.updateItems()
                            };
                        if (changeTypes.sorting || changeTypes.grouping) {
                            if (that._dataSource && !that._columnsUpdating) {
                                that._dataSource.group(that._columnsController.getGroupDataSourceParameters());
                                that._dataSource.sort(that._columnsController.getSortDataSourceParameters());
                                that.reload()
                            }
                            that.pageChanged.fire()
                        }
                        else if (changeTypes.columns) {
                            if (optionNames.filterValues || optionNames.filterValue || optionNames.selectedFilterOperation)
                                if (this.option("filterRow.applyFilter") !== "onClick" || optionNames.filterValues) {
                                    filterValue = that._columnsController.columnOption(e.columnIndex, "filterValue");
                                    filterValues = that._columnsController.columnOption(e.columnIndex, "filterValues");
                                    if (commonUtils.isArray(filterValues) || e.columnIndex === undefined || commonUtils.isDefined(filterValue) || !optionNames.selectedFilterOperation || optionNames.filterValue)
                                        that._applyFilter()
                                }
                            if (!that._needApplyFilter && !dataGrid.checkChanges(optionNames, ["width", "visibleWidth", "filterValue", "selectedFilterOperation", "filterValues", "filterType"]))
                                that._columnsController.columnsChanged.add(updateItemsHandler)
                        }
                    },
                    _handleDataChanged: function(e) {
                        var that = this,
                            dataSource = that._dataSource,
                            columnsController = that._columnsController,
                            isAllDataTypesDefined = columnsController.isAllDataTypesDefined();
                        if (dataSource && !that._isDataSourceApplying) {
                            that._isDataSourceApplying = true;
                            $.when(that._columnsController.applyDataSource(dataSource)).done(function() {
                                if (that._isLoading)
                                    that._handleLoadingChanged(false);
                                that._isDataSourceApplying = false;
                                var additionalFilter = that._calculateAdditionalFilter(),
                                    needApplyFilter = that._needApplyFilter;
                                that._needApplyFilter = false;
                                if (needApplyFilter && additionalFilter && additionalFilter.length && !isAllDataTypesDefined) {
                                    errors.log("W1005", that.component.NAME);
                                    that._applyFilter()
                                }
                                else
                                    that.updateItems(e)
                            });
                            if (that._isDataSourceApplying)
                                that._handleLoadingChanged(true);
                            that._needApplyFilter = !that._columnsController.isDataSourceApplied()
                        }
                    },
                    _handleLoadingChanged: function(isLoading) {
                        this._isLoading = isLoading;
                        this._fireLoadingChanged()
                    },
                    _handleLoadError: function(e) {
                        this.dataErrorOccurred.fire(e)
                    },
                    _initDataSource: function() {
                        var that = this,
                            dataSource = this.option("dataSource"),
                            pageIndex = this.option("paging.pageIndex"),
                            pageSize = this.option("paging.pageSize"),
                            scrollingMode = that.option("scrolling.mode"),
                            pagingEnabled = this.option("paging.enabled"),
                            appendMode = scrollingMode === "infinite",
                            virtualMode = scrollingMode === "virtual",
                            oldDataSource = this._dataSource;
                        that.callBase();
                        dataSource = that._dataSource;
                        that._isFirstLoading = true;
                        if (dataSource) {
                            dataSource.requireTotalCount(!appendMode);
                            if (pagingEnabled !== undefined)
                                dataSource.paginate(pagingEnabled || virtualMode || appendMode);
                            if (pageSize !== undefined)
                                dataSource.pageSize(pageSize);
                            if (pageIndex !== undefined)
                                dataSource.pageIndex(pageIndex);
                            that.setDataSource(dataSource)
                        }
                        else if (oldDataSource)
                            that.updateItems()
                    },
                    _loadDataSource: function() {
                        var dataSource = this._dataSource;
                        dataSource && dataSource.load()
                    },
                    _processItems: function(items) {
                        var that = this,
                            visibleColumns = that._columnsController.getVisibleColumns(),
                            options = {
                                visibleColumns: visibleColumns,
                                dataIndex: 0
                            },
                            result = [];
                        $.each(items, function(index, item) {
                            if (commonUtils.isDefined(item)) {
                                item = that._processItem(item, options);
                                result.push(item)
                            }
                        });
                        return result
                    },
                    _processItem: function(item, options) {
                        item = this._generateDataItem(item);
                        item = this._processDataItem(item, options);
                        item.dataIndex = options.dataIndex++;
                        return item
                    },
                    _generateDataItem: function(data) {
                        return {
                                rowType: "data",
                                data: data,
                                key: this.keyOf(data)
                            }
                    },
                    _processDataItem: function(dataItem, options) {
                        dataItem.values = this.generateDataValues(dataItem.data, options.visibleColumns);
                        return dataItem
                    },
                    generateDataValues: function(data, columns) {
                        var values = [],
                            column,
                            value;
                        for (var i = 0; i < columns.length; i++) {
                            column = columns[i];
                            value = null;
                            if (column.command)
                                value = null;
                            else if (column.calculateCellValue)
                                value = column.calculateCellValue(data);
                            else if (column.dataField)
                                value = data[column.dataField];
                            values.push(value)
                        }
                        return values
                    },
                    _updateItemsCore: function(change) {
                        var that = this,
                            items,
                            dataSource = that._dataSource,
                            changeType = change.changeType || "refresh";
                        change.changeType = changeType;
                        if (dataSource) {
                            items = change.items || dataSource.items();
                            items = that._processItems(items.slice(0), changeType);
                            change.items = items;
                            switch (changeType) {
                                case"prepend":
                                    that._items.unshift.apply(that._items, items);
                                    break;
                                case"append":
                                    that._items.push.apply(that._items, items);
                                    break;
                                case"update":
                                    var prevIndex = -1,
                                        rowIndices = change.rowIndices.slice(0),
                                        rowIndexCorrection = 0;
                                    rowIndices.sort(function(a, b) {
                                        return a - b
                                    });
                                    for (var i = 0; i < rowIndices.length; i++)
                                        if (rowIndices[i] < 0) {
                                            rowIndices.splice(i, 1);
                                            i--
                                        }
                                    change.items = [];
                                    change.rowIndices = [];
                                    change.changeTypes = [];
                                    var equalItems = function(item1, item2) {
                                            return dataGrid.equalKeys(item1.key, item2.key)
                                        };
                                    $.each(rowIndices, function(index, rowIndex) {
                                        var oldItem,
                                            newItem,
                                            oldNextItem,
                                            newNextItem;
                                        rowIndex += rowIndexCorrection;
                                        if (prevIndex === rowIndex)
                                            return;
                                        change.rowIndices.push(rowIndex);
                                        prevIndex = rowIndex;
                                        oldItem = that._items[rowIndex];
                                        oldNextItem = that._items[rowIndex + 1];
                                        newItem = items[rowIndex];
                                        newNextItem = items[rowIndex + 1];
                                        if (newItem)
                                            change.items.push(newItem);
                                        if (oldItem && newItem && equalItems(oldItem, newItem)) {
                                            changeType = "update";
                                            that._items[rowIndex] = newItem;
                                            if (oldItem.visible !== newItem.visible)
                                                change.items.splice(-1, 1, {visible: newItem.visible})
                                        }
                                        else if (newItem && !oldItem || newNextItem && equalItems(oldItem, newNextItem)) {
                                            changeType = "insert";
                                            that._items.splice(rowIndex, 0, newItem);
                                            rowIndexCorrection++
                                        }
                                        else if (oldItem && !newItem || oldNextItem && equalItems(newItem, oldNextItem)) {
                                            changeType = "remove";
                                            that._items.splice(rowIndex, 1);
                                            rowIndexCorrection--;
                                            prevIndex = -1
                                        }
                                        change.changeTypes.push(changeType)
                                    });
                                    break;
                                default:
                                    that._items = items.slice(0);
                                    break
                            }
                            $.each(that._items, function(index, item) {
                                item.rowIndex = index
                            })
                        }
                        else
                            that._items = []
                    },
                    updateItems: function(change) {
                        change = change || {};
                        this._updateItemsCore(change);
                        this.changed.fire(change)
                    },
                    isLoading: function() {
                        return this._isLoading || this._isCustomLoading
                    },
                    _fireLoadingChanged: function(messageText) {
                        this.loadingChanged.fire(this.isLoading(), messageText)
                    },
                    _calculateAdditionalFilter: function() {
                        return null
                    },
                    _applyFilter: function() {
                        var that = this,
                            dataSource = that._dataSource;
                        if (dataSource) {
                            dataSource.pageIndex(0);
                            return that.reload().done($.proxy(that.pageChanged, "fire"))
                        }
                    },
                    filter: function(filterExpr) {
                        var dataSource = this._dataSource;
                        if (arguments.length === 0)
                            return dataSource ? dataSource.filter() : undefined;
                        filterExpr = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0) : filterExpr;
                        if (dataSource)
                            dataSource.filter(filterExpr);
                        this._applyFilter()
                    },
                    clearFilter: function(filterName) {
                        var that = this,
                            columnsController = that._columnsController,
                            clearColumnOption = function(optionName) {
                                var columnCount = columnsController.columnCount(),
                                    index;
                                for (index = 0; index < columnCount; index++)
                                    columnsController.columnOption(index, optionName, undefined)
                            };
                        that.component.beginUpdate();
                        if (arguments.length > 0)
                            switch (filterName) {
                                case"dataSource":
                                    that.filter(null);
                                    break;
                                case"search":
                                    that.searchByText("");
                                    break;
                                case"header":
                                    clearColumnOption("filterValues");
                                    break;
                                case"row":
                                    clearColumnOption("filterValue");
                                    break
                            }
                        else {
                            that.filter(null);
                            that.searchByText("");
                            clearColumnOption("filterValue");
                            clearColumnOption("filterValues")
                        }
                        that.component.endUpdate()
                    },
                    _fireDataSourceChanged: function() {
                        var that = this;
                        var changedHandler = function() {
                                that.changed.remove(changedHandler);
                                that.dataSourceChanged.fire()
                            };
                        that.changed.add(changedHandler)
                    },
                    _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
                        var dataSourceAdapter = new dataGrid.DataSourceAdapter(this.component);
                        dataSourceAdapter.init(dataSource, remoteOperations);
                        return dataSourceAdapter
                    },
                    _createDataSourceAdapter: function(dataSource) {
                        var remoteOperations = this.option("remoteOperations");
                        if (remoteOperations === "auto")
                            remoteOperations = dataSource.store() instanceof DX.data.ArrayStore ? {} : {
                                filtering: true,
                                sorting: true,
                                paging: true
                            };
                        if (remoteOperations === true)
                            remoteOperations = {
                                filtering: true,
                                sorting: true,
                                paging: true,
                                grouping: true,
                                summary: true
                            };
                        return this._createDataSourceAdapterCore(dataSource, remoteOperations)
                    },
                    setDataSource: function(dataSource) {
                        var that = this,
                            oldDataSource = that._dataSource;
                        if (!dataSource && oldDataSource) {
                            oldDataSource.changed.remove(that._dataChangedHandler);
                            oldDataSource.loadingChanged.remove(that._loadingChangedHandler);
                            oldDataSource.loadError.remove(that._loadErrorHandler);
                            oldDataSource.customizeStoreLoadOptions.remove(that._customizeStoreLoadOptionsHandler);
                            oldDataSource.dispose(that._isSharedDataSource)
                        }
                        if (dataSource)
                            dataSource = that._createDataSourceAdapter(dataSource);
                        that._dataSource = dataSource;
                        if (dataSource) {
                            that._fireDataSourceChanged();
                            that._isLoading = !dataSource.isLoaded();
                            that._needApplyFilter = true;
                            dataSource.changed.add(that._dataChangedHandler);
                            dataSource.loadingChanged.add(that._loadingChangedHandler);
                            dataSource.loadError.add(that._loadErrorHandler);
                            dataSource.customizeStoreLoadOptions.add(that._customizeStoreLoadOptionsHandler)
                        }
                    },
                    items: function() {
                        return this._items
                    },
                    isEmpty: function() {
                        return !this.items().length
                    },
                    pageCount: function() {
                        return this._dataSource ? this._dataSource.pageCount() : 1
                    },
                    dataSource: function() {
                        return this._dataSource
                    },
                    store: function() {
                        var dataSource = this._dataSource;
                        return dataSource && dataSource.store()
                    },
                    loadAll: function(data) {
                        var that = this,
                            d = $.Deferred(),
                            dataSource = that._dataSource;
                        if (dataSource)
                            if (data) {
                                var options = {
                                        data: data,
                                        isCustomLoading: true,
                                        storeLoadOptions: {},
                                        loadOptions: {
                                            group: dataSource.group(),
                                            sort: dataSource.sort()
                                        }
                                    };
                                dataSource._handleDataLoaded(options);
                                d.resolve(that._processItems(options.data, "loadingAll"), options.extra && options.extra.summary)
                            }
                            else if (!that.isLoading()) {
                                var loadOptions = $.extend({isLoadingAll: true}, dataSource.loadOptions());
                                loadOptions.requireTotalCount = false;
                                dataSource.load(loadOptions).done(function(items, extra) {
                                    items = that._processItems(items.slice(0), "loadingAll");
                                    d.resolve(items, extra && extra.summary)
                                }).fail(d.reject)
                            }
                            else
                                d.reject();
                        else
                            d.resolve([]);
                        return d
                    },
                    getKeyByRowIndex: function(rowIndex) {
                        var item = this.items()[rowIndex];
                        if (item)
                            return item.key
                    },
                    getRowIndexByKey: function(key) {
                        return dataGrid.getIndexByKey(key, this.items())
                    },
                    keyOf: function(data) {
                        var store = this.store();
                        if (store)
                            return store.keyOf(data)
                    },
                    byKey: function(key) {
                        var store = this.store(),
                            rowIndex = this.getRowIndexByKey(key),
                            result;
                        if (!store)
                            return;
                        if (rowIndex >= 0)
                            result = $.Deferred().resolve(this.items()[rowIndex].data);
                        return result || store.byKey(key)
                    },
                    getDataByKeys: function(rowKeys) {
                        var that = this,
                            result = $.Deferred(),
                            deferreds = [],
                            data = [];
                        $.each(rowKeys, function(index, key) {
                            deferreds.push(that.byKey(key).done(function(keyData) {
                                data[index] = keyData
                            }))
                        });
                        $.when.apply($, deferreds).always(function() {
                            result.resolve(data)
                        });
                        return result
                    },
                    pageIndex: function(value) {
                        var that = this,
                            pagingOptions = that.option("paging"),
                            dataSource = that._dataSource;
                        if (dataSource) {
                            if (value !== undefined)
                                if (dataSource.pageIndex() !== value) {
                                    dataSource.pageIndex(value);
                                    if (pagingOptions)
                                        pagingOptions.pageIndex = value;
                                    return dataSource.load().done($.proxy(that.pageChanged, "fire"))
                                }
                            return dataSource.pageIndex()
                        }
                        return 0
                    },
                    pageSize: function(value) {
                        var that = this,
                            pagingOptions = that.option("paging"),
                            dataSource = that._dataSource;
                        if (value === undefined)
                            return dataSource ? dataSource.pageSize() : 0;
                        if (dataSource)
                            if (dataSource.pageSize() !== value) {
                                dataSource.pageIndex(0);
                                dataSource.pageSize(value);
                                if (pagingOptions)
                                    pagingOptions.pageSize = value;
                                return dataSource.reload().done($.proxy(that.pageChanged, "fire"))
                            }
                    },
                    beginCustomLoading: function(messageText) {
                        this._isCustomLoading = true;
                        this._fireLoadingChanged(messageText)
                    },
                    endCustomLoading: function() {
                        this._isCustomLoading = false;
                        this._fireLoadingChanged()
                    },
                    refresh: function() {
                        var that = this,
                            d = $.Deferred();
                        $.when(this._columnsController.refresh()).always(function() {
                            $.when(that.reload(true)).done(d.resolve).fail(d.reject)
                        });
                        return d
                    },
                    _disposeDataSource: function() {
                        this.setDataSource(null)
                    }
                };
            dataGrid.proxyMethod(members, "load");
            dataGrid.proxyMethod(members, "reload");
            dataGrid.proxyMethod(members, "itemsCount", 0);
            dataGrid.proxyMethod(members, "totalItemsCount", 0);
            dataGrid.proxyMethod(members, "hasKnownLastPage", true);
            dataGrid.proxyMethod(members, "isLoaded", true);
            dataGrid.proxyMethod(members, "totalCount", 0);
            return members
        }());
        dataGrid.registerModule("data", {
            defaultOptions: function() {
                return {
                        loadingTimeout: 0,
                        dataSource: null,
                        cacheEnabled: true,
                        onDataErrorOccurred: null,
                        remoteOperations: "auto",
                        paging: {
                            enabled: true,
                            pageSize: undefined,
                            pageIndex: undefined
                        }
                    }
            },
            controllers: {data: ui.dxDataGrid.DataController}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.virtualScrollingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            translator = DX.require("/utils/utils.translator"),
            browser = DX.require("/utils/utils.browser"),
            Class = DevExpress.require("/class");
        var DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_FREESPACE_CLASS = "dx-freespace-row",
            DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
            DATAGRID_BOTTOM_LOAD_PANEL_CLASS = "dx-datagrid-bottom-load-panel",
            DATAGRID_TABLE_CONTENT_CLASS = "dx-datagrid-table-content",
            DATAGRID_GROUP_SPACE_CLASS = "dx-datagrid-group-space",
            DATAGRID_SCROLLABLE_CONTAINER = "dx-scrollable-container",
            DATAGRID_SCROLLABLE_CONTENT = "dx-scrollable-content",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            SCROLLING_MODE_INFINITE = "infinite",
            SCROLLING_MODE_VIRTUAL = "virtual",
            PIXELS_LIMIT = 250000,
            CONTENT_HEIHGT_LIMIT = browser.msie ? 4000000 : 15000000;
        dataGrid.__MAX_VIRTUAL_CONTENT_SIZE = CONTENT_HEIHGT_LIMIT;
        var isVirtualMode = function(that) {
                return that.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL
            };
        var isAppendMode = function(that) {
                return that.option("scrolling.mode") === SCROLLING_MODE_INFINITE
            };
        function subscribeToExternalScrollers($element, scrollChangedHandler, $targetElement) {
            var $scrollElement,
                scrollableArray = [],
                scrollToArray = [],
                disposeArray = [];
            $targetElement = $targetElement || $element;
            function getElementOffset(scrollable) {
                var $scrollableElement = scrollable.element ? scrollable.element() : scrollable,
                    scrollableOffset = $scrollableElement.offset();
                if (!scrollableOffset)
                    return $element.offset().top;
                return scrollable.scrollTop() - (scrollableOffset.top - $element.offset().top)
            }
            function createWindowScrollHandler(scrollable) {
                return function(e) {
                        var scrollTop = scrollable.scrollTop() - getElementOffset(scrollable);
                        scrollTop = scrollTop > 0 ? scrollTop : 0;
                        scrollChangedHandler(scrollTop)
                    }
            }
            function subscribeToScrollEvents($scrollElement) {
                var isDocument = $scrollElement.get(0).nodeName === "#document",
                    scrollable = $scrollElement.data("dxScrollable") || isDocument && $(window) || $scrollElement.css("overflow-y") === "auto" && $scrollElement,
                    handler;
                if (scrollable) {
                    handler = createWindowScrollHandler(scrollable);
                    scrollable.on("scroll", handler);
                    scrollToArray.push(function(pos) {
                        var topOffset = getElementOffset(scrollable),
                            scrollMethod = scrollable.scrollTo ? "scrollTo" : "scrollTop";
                        if (pos - topOffset >= 0)
                            scrollable[scrollMethod](pos + topOffset)
                    });
                    scrollableArray.push(scrollable);
                    disposeArray.push(function() {
                        scrollable.off("scroll", handler)
                    })
                }
            }
            for ($scrollElement = $targetElement.parent(); $scrollElement.length; $scrollElement = $scrollElement.parent())
                subscribeToScrollEvents($scrollElement);
            return {
                    scrollTo: function(pos) {
                        $.each(scrollToArray, function(_, scrollTo) {
                            scrollTo(pos)
                        })
                    },
                    dispose: function() {
                        $.each(disposeArray, function(_, dispose) {
                            dispose()
                        })
                    }
                }
        }
        var VirtualScrollController = Class.inherit(function() {
                var getViewportPageCount = function(that) {
                        var pageSize = that._dataSource.pageSize();
                        return pageSize && that._viewportSize >= 0 ? Math.ceil(that._viewportSize / pageSize) : 1
                    };
                var getPreloadPageCount = function(that) {
                        var preloadEnabled = that.option('scrolling.preloadEnabled'),
                            pageCount = getViewportPageCount(that);
                        if (pageCount) {
                            if (preloadEnabled)
                                pageCount++;
                            if (isAppendMode(that))
                                pageCount--
                        }
                        return pageCount
                    };
                var getBeginPageIndex = function(that) {
                        return that._cache.length ? that._cache[0].pageIndex : -1
                    };
                var getEndPageIndex = function(that) {
                        return that._cache.length ? that._cache[that._cache.length - 1].pageIndex : -1
                    };
                var fireChanged = function(that, changed, args) {
                        that._isChangedFiring = true;
                        changed(args);
                        that._isChangedFiring = false
                    };
                var processDelayChanged = function(that, changed) {
                        if (that._isDelayChanged) {
                            that._isDelayChanged = false;
                            fireChanged(that, changed);
                            return true
                        }
                    };
                var processChanged = function(that, changed, changeType, isDelayChanged) {
                        var dataSource = that._dataSource,
                            items = dataSource.items(),
                            change;
                        if (changeType && !that._isDelayChanged)
                            change = {
                                changeType: changeType,
                                items: items
                            };
                        var viewportItems = that._dataSource.viewportItems();
                        if (changeType === "append")
                            viewportItems.push.apply(viewportItems, items);
                        else if (changeType === "prepend")
                            viewportItems.unshift.apply(viewportItems, items);
                        else
                            that._dataSource.viewportItems(items);
                        dataSource.updateLoading();
                        that._lastPageIndex = that.pageIndex();
                        that._isDelayChanged = isDelayChanged;
                        if (!isDelayChanged)
                            fireChanged(that, changed, change)
                    };
                return {
                        ctor: function(component, dataSource) {
                            var that = this;
                            that._dataSource = dataSource;
                            that.component = component;
                            that._pageIndex = that._lastPageIndex = dataSource.pageIndex();
                            that._viewportSize = 0;
                            that._viewportItemSize = 20;
                            that._viewportItemIndex = -1;
                            that._sizeRatio = 1;
                            that._items = [];
                            that._cache = []
                        },
                        option: function(name) {
                            return this.component.option.apply(this.component, arguments)
                        },
                        virtualItemsCount: function() {
                            var that = this,
                                pageIndex,
                                itemsCount = 0,
                                beginItemsCount,
                                endItemsCount;
                            if (isVirtualMode(that)) {
                                pageIndex = getBeginPageIndex(that);
                                if (pageIndex < 0)
                                    pageIndex = 0;
                                beginItemsCount = pageIndex * that._dataSource.pageSize();
                                itemsCount = that._cache.length * that._dataSource.pageSize();
                                endItemsCount = Math.max(0, that._dataSource.totalItemsCount() - itemsCount - beginItemsCount);
                                return {
                                        begin: beginItemsCount,
                                        end: endItemsCount
                                    }
                            }
                        },
                        _setViewportPositionCore: function(position, isNear) {
                            var that = this,
                                scrollingTimeout = Math.min(that.option("scrolling.timeout") || 0, that._dataSource.changingDuration());
                            if (isNear && scrollingTimeout < that.option("scrolling.renderingTreshold"))
                                scrollingTimeout = 10;
                            clearTimeout(that._scrollTimeoutID);
                            if (scrollingTimeout > 0)
                                that._scrollTimeoutID = setTimeout(function() {
                                    that.setViewportItemIndex(position)
                                }, scrollingTimeout);
                            else
                                that.setViewportItemIndex(position)
                        },
                        getViewportPosition: function() {
                            return this._position || 0
                        },
                        setViewportPosition: function(position) {
                            var that = this,
                                virtualItemsCount = that.virtualItemsCount(),
                                sizeRatio = that._sizeRatio || 1,
                                itemSize = that._viewportItemSize,
                                offset = virtualItemsCount ? Math.floor(virtualItemsCount.begin * itemSize * sizeRatio) : 0;
                            that._position = position;
                            if (virtualItemsCount && position >= offset && position <= offset + that._contentSize)
                                that._setViewportPositionCore(virtualItemsCount.begin + (position - offset) / itemSize, true);
                            else
                                that._setViewportPositionCore(position / (itemSize * sizeRatio))
                        },
                        setContentSize: function(size) {
                            var that = this,
                                virtualItemsCount = that.virtualItemsCount();
                            that._contentSize = size;
                            if (virtualItemsCount) {
                                var virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + that.itemsCount()) * that._viewportItemSize;
                                if (virtualContentSize > CONTENT_HEIHGT_LIMIT)
                                    that._sizeRatio = CONTENT_HEIHGT_LIMIT / virtualContentSize;
                                else
                                    that._sizeRatio = 1
                            }
                        },
                        getContentOffset: function() {
                            var that = this,
                                virtualItemsCount = that.virtualItemsCount();
                            return virtualItemsCount ? Math.floor(virtualItemsCount.begin * that._viewportItemSize * that._sizeRatio) : 0
                        },
                        getVirtualContentSize: function() {
                            var that = this,
                                virtualItemsCount = that.virtualItemsCount();
                            return virtualItemsCount ? (virtualItemsCount.begin + virtualItemsCount.end) * that._viewportItemSize * that._sizeRatio + that._contentSize : 0
                        },
                        getViewportItemIndex: function() {
                            return this._viewportItemIndex
                        },
                        setViewportItemIndex: function(itemIndex) {
                            var that = this,
                                pageSize = that._dataSource.pageSize(),
                                pageCount = that._dataSource.pageCount(),
                                virtualMode = isVirtualMode(that),
                                appendMode = isAppendMode(that),
                                totalItemsCount = that._dataSource.totalItemsCount(),
                                needLoad = that._viewportItemIndex < 0,
                                lastPageSize,
                                maxPageIndex,
                                newPageIndex;
                            that._viewportItemIndex = itemIndex;
                            if (pageSize && (virtualMode || appendMode) && totalItemsCount >= 0) {
                                if (that._viewportSize && itemIndex + that._viewportSize >= totalItemsCount)
                                    if (that._dataSource.hasKnownLastPage()) {
                                        newPageIndex = pageCount - 1;
                                        lastPageSize = totalItemsCount % pageSize;
                                        if (newPageIndex > 0 && lastPageSize > 0 && lastPageSize < pageSize / 2)
                                            newPageIndex--
                                    }
                                    else
                                        newPageIndex = pageCount;
                                else {
                                    newPageIndex = Math.floor(itemIndex / pageSize);
                                    maxPageIndex = pageCount - 1;
                                    newPageIndex = Math.max(newPageIndex, 0);
                                    newPageIndex = Math.min(newPageIndex, maxPageIndex)
                                }
                                if (that.pageIndex() !== newPageIndex || needLoad) {
                                    that.pageIndex(newPageIndex);
                                    that.load()
                                }
                            }
                        },
                        viewportItemSize: function(size) {
                            if (size !== undefined)
                                this._viewportItemSize = size;
                            return this._viewportItemSize
                        },
                        viewportSize: function(size) {
                            if (size !== undefined)
                                this._viewportSize = size;
                            return this._viewportSize
                        },
                        pageIndex: function(pageIndex) {
                            if (isVirtualMode(this) || isAppendMode(this)) {
                                if (pageIndex !== undefined)
                                    this._pageIndex = pageIndex;
                                return this._pageIndex
                            }
                            else
                                return this._dataSource.pageIndex(pageIndex)
                        },
                        beginPageIndex: function(defaultPageIndex) {
                            var beginPageIndex = getBeginPageIndex(this);
                            if (beginPageIndex < 0)
                                beginPageIndex = defaultPageIndex !== undefined ? defaultPageIndex : this.pageIndex();
                            return beginPageIndex
                        },
                        endPageIndex: function() {
                            var endPageIndex = getEndPageIndex(this);
                            return endPageIndex > 0 ? endPageIndex : this._lastPageIndex
                        },
                        load: function() {
                            var beginPageIndex = getBeginPageIndex(this),
                                pageIndexForLoad = -1,
                                dataSource = this._dataSource,
                                result;
                            var loadCore = function(that, pageIndex) {
                                    var dataSource = that._dataSource;
                                    if (pageIndex === that.pageIndex() || !dataSource.isLoading() && pageIndex < dataSource.pageCount() || !dataSource.hasKnownLastPage() && pageIndex === dataSource.pageCount()) {
                                        dataSource.pageIndex(pageIndex);
                                        return dataSource.load()
                                    }
                                };
                            if (isVirtualMode(this) || isAppendMode(this)) {
                                if (beginPageIndex < 0 || !this._cache[this._pageIndex - beginPageIndex])
                                    pageIndexForLoad = this._pageIndex;
                                if (beginPageIndex >= 0 && pageIndexForLoad < 0 && this._viewportSize >= 0)
                                    if (beginPageIndex > 0 && getEndPageIndex(this) + 1 === dataSource.pageCount() && this._cache.length < getPreloadPageCount(this) + 1)
                                        pageIndexForLoad = beginPageIndex - 1;
                                    else if (beginPageIndex + this._cache.length <= this._pageIndex + getPreloadPageCount(this))
                                        pageIndexForLoad = beginPageIndex + this._cache.length;
                                if (pageIndexForLoad >= 0)
                                    result = loadCore(this, pageIndexForLoad);
                                dataSource.updateLoading()
                            }
                            else
                                result = dataSource.load();
                            if (!result && this._lastPageIndex !== this.pageIndex())
                                this._dataSource.onChanged({changeType: "pageIndex"});
                            return result || $.Deferred().resolve()
                        },
                        loadIfNeed: function() {
                            var that = this;
                            if ((isVirtualMode(that) || isAppendMode(that)) && !that._dataSource.isLoading() && !that._isChangedFiring)
                                that.load()
                        },
                        handleDataChanged: function(callBase) {
                            var that = this,
                                beginPageIndex,
                                dataSource = that._dataSource,
                                lastCacheLength = that._cache.length,
                                changeType,
                                removeInvisiblePages,
                                cacheItem;
                            if (isVirtualMode(that) || isAppendMode(that)) {
                                beginPageIndex = getBeginPageIndex(that);
                                if (beginPageIndex >= 0) {
                                    if (isVirtualMode(that) && beginPageIndex + that._cache.length !== dataSource.pageIndex() && beginPageIndex - 1 !== dataSource.pageIndex())
                                        that._cache = [];
                                    if (isAppendMode(that) && dataSource.pageIndex() === 0)
                                        that._cache = []
                                }
                                cacheItem = {
                                    pageIndex: dataSource.pageIndex(),
                                    itemsCount: that.itemsCount(true)
                                };
                                if (that.option("scrolling.removeInvisiblePages"))
                                    removeInvisiblePages = that._cache.length > Math.max(getPreloadPageCount(this), 2);
                                else
                                    processDelayChanged(that, callBase);
                                if (beginPageIndex === dataSource.pageIndex() + 1) {
                                    if (removeInvisiblePages)
                                        that._cache.pop();
                                    else
                                        changeType = "prepend";
                                    that._cache.unshift(cacheItem)
                                }
                                else {
                                    if (removeInvisiblePages)
                                        that._cache.shift();
                                    else
                                        changeType = "append";
                                    that._cache.push(cacheItem)
                                }
                                processChanged(that, callBase, that._cache.length > 1 ? changeType : undefined, lastCacheLength === 0);
                                that.load().done(function() {
                                    if (processDelayChanged(that, callBase))
                                        that.load()
                                })
                            }
                            else
                                processChanged(that, callBase)
                        },
                        itemsCount: function(isBase) {
                            var itemsCount = 0;
                            if (!isBase && isVirtualMode(this))
                                $.each(this._cache, function() {
                                    itemsCount += this.itemsCount
                                });
                            else
                                itemsCount = this._dataSource.itemsCount();
                            return itemsCount
                        },
                        reset: function() {
                            this._cache = []
                        },
                        subscribeToWindowScrollEvents: function($element) {
                            var that = this;
                            that._windowScroll = that._windowScroll || subscribeToExternalScrollers($element, function(scrollTop) {
                                if (that.viewportItemSize())
                                    that.setViewportPosition(scrollTop)
                            })
                        },
                        dispose: function() {
                            clearTimeout(this._scrollTimeoutID);
                            this._windowScroll && this._windowScroll.dispose();
                            this._windowScroll = null
                        },
                        scrollTo: function(pos) {
                            this._windowScroll && this._windowScroll.scrollTo(pos)
                        }
                    }
            }());
        ui.dxDataGrid.VirtualScrollController = VirtualScrollController;
        var VirtualScrollingDataSourceAdapterExtender = function() {
                var updateLoading = function(that) {
                        var beginPageIndex = that._virtualScrollController.beginPageIndex(-1);
                        if (isVirtualMode(that))
                            if (beginPageIndex < 0 || that.viewportSize() >= 0 && that.getViewportItemIndex() >= 0 && (beginPageIndex * that.pageSize() > that.getViewportItemIndex() || beginPageIndex * that.pageSize() + that.itemsCount() < that.getViewportItemIndex() + that.viewportSize()) && that._dataSource.isLoading()) {
                                if (!that._isLoading) {
                                    that._isLoading = true;
                                    that.loadingChanged.fire(true)
                                }
                            }
                            else if (that._isLoading) {
                                that._isLoading = false;
                                that.loadingChanged.fire(false)
                            }
                    };
                return {
                        init: function(dataSource) {
                            var that = this;
                            that.callBase.apply(that, arguments);
                            that._isLoading = true;
                            that._items = [];
                            that._isLoaded = true;
                            that._virtualScrollController = new VirtualScrollController(that.component, {
                                pageSize: function() {
                                    return that.pageSize()
                                },
                                totalItemsCount: function() {
                                    return that.totalItemsCount()
                                },
                                hasKnownLastPage: function() {
                                    return that.hasKnownLastPage()
                                },
                                pageIndex: function(index) {
                                    return dataSource.pageIndex(index)
                                },
                                isLoading: function() {
                                    return dataSource.isLoading()
                                },
                                pageCount: function() {
                                    return that.pageCount()
                                },
                                load: function() {
                                    return dataSource.load()
                                },
                                updateLoading: function() {
                                    updateLoading(that)
                                },
                                itemsCount: function() {
                                    return that.itemsCount(true)
                                },
                                items: function() {
                                    return dataSource.items()
                                },
                                viewportItems: function(items) {
                                    if (items)
                                        that._items = items;
                                    return that._items
                                },
                                onChanged: function(e) {
                                    that.changed.fire(e)
                                }
                            })
                        },
                        _handleLoadingChanged: function(isLoading) {
                            var that = this;
                            if (!isVirtualMode(that)) {
                                that._isLoading = isLoading;
                                that.callBase.apply(that, arguments)
                            }
                        },
                        _handleLoadError: function() {
                            var that = this;
                            that._isLoading = false;
                            that.loadingChanged.fire(false);
                            that.callBase.apply(that, arguments)
                        },
                        _handleDataChanged: function() {
                            var callBase = $.proxy(this.callBase, this);
                            this._virtualScrollController.handleDataChanged(callBase)
                        },
                        items: function() {
                            return this._items
                        },
                        itemsCount: function(isBase) {
                            if (isBase)
                                return this.callBase();
                            return this._virtualScrollController.itemsCount()
                        },
                        virtualItemsCount: function() {
                            return this._virtualScrollController.virtualItemsCount()
                        },
                        getViewportItemIndex: function() {
                            return this._virtualScrollController.getViewportItemIndex()
                        },
                        setViewportItemIndex: function(itemIndex) {
                            return this._virtualScrollController.setViewportItemIndex(itemIndex)
                        },
                        viewportSize: function(size) {
                            return this._virtualScrollController.viewportSize(size)
                        },
                        pageIndex: function(pageIndex) {
                            return this._virtualScrollController.pageIndex(pageIndex)
                        },
                        beginPageIndex: function() {
                            return this._virtualScrollController.beginPageIndex()
                        },
                        endPageIndex: function() {
                            return this._virtualScrollController.endPageIndex()
                        },
                        load: function(loadOptions) {
                            if (loadOptions)
                                return this.callBase(loadOptions);
                            return this._virtualScrollController.load()
                        },
                        loadIfNeed: function() {
                            return this._virtualScrollController.loadIfNeed()
                        },
                        isLoading: function() {
                            return this._isLoading
                        },
                        isLoaded: function() {
                            return this._dataSource.isLoaded() && this._isLoaded
                        },
                        _changeRowExpandCore: function() {
                            var result = this.callBase.apply(this, arguments);
                            this._virtualScrollController.reset();
                            updateLoading(this);
                            return result
                        },
                        refresh: function(options, isReload, operationTypes) {
                            var that = this,
                                storeLoadOptions = options.storeLoadOptions,
                                dataSource = that._dataSource;
                            if (isReload || operationTypes.reload) {
                                that._virtualScrollController.reset();
                                that._isLoaded = false;
                                updateLoading(that);
                                that._isLoaded = true;
                                if (isAppendMode(that)) {
                                    that.pageIndex(0);
                                    dataSource.pageIndex(0);
                                    storeLoadOptions.pageIndex = 0;
                                    storeLoadOptions.skip = 0
                                }
                                else {
                                    dataSource.pageIndex(that.pageIndex());
                                    if (dataSource.paginate())
                                        storeLoadOptions.skip = that.pageIndex() * that.pageSize()
                                }
                            }
                            return that.callBase.apply(that, arguments)
                        }
                    }
            }();
        dataGrid.DataSourceAdapter = dataGrid.DataSourceAdapter.inherit(VirtualScrollingDataSourceAdapterExtender);
        var VirtualScrollingRowsViewExtender = function() {
                return {
                        init: function() {
                            var that = this,
                                dataController = that.getController("data");
                            that.callBase();
                            dataController.pageChanged.add(function() {
                                that.scrollToPage(dataController.pageIndex())
                            })
                        },
                        scrollToPage: function(pageIndex) {
                            var that = this,
                                dataController = that._dataController,
                                pageSize = dataController ? dataController.pageSize() : 0,
                                scrollPosition;
                            if (isVirtualMode(that) || isAppendMode(that))
                                scrollPosition = pageIndex * that._rowHeight * pageSize;
                            else
                                scrollPosition = 0;
                            that.scrollTo({
                                y: scrollPosition,
                                x: that._scrollLeft
                            })
                        },
                        _renderCore: function() {
                            var that = this,
                                startRenderDate = new Date;
                            that.callBase.apply(that, arguments);
                            that._updateContentPosition();
                            that._renderTime = new Date - startRenderDate
                        },
                        _renderContent: function(contentElement, tableElement) {
                            var that = this,
                                virtualItemsCount = that._dataController.virtualItemsCount();
                            if (virtualItemsCount) {
                                tableElement.addClass(DATAGRID_TABLE_CONTENT_CLASS);
                                if (!contentElement.children().length)
                                    contentElement.append(tableElement);
                                else
                                    contentElement.children().first().replaceWith(tableElement);
                                if (contentElement.children("table").length === 1) {
                                    contentElement.append(that._createTable());
                                    that._contentHeight = 0
                                }
                                return contentElement
                            }
                            else
                                return that.callBase.apply(that, arguments)
                        },
                        _updateContent: function(tableElement, change) {
                            var that = this,
                                contentTable,
                                contentElement = that._findContentElement(),
                                changeType = change && change.changeType;
                            if (changeType === "append" || changeType === "prepend") {
                                contentTable = contentElement.children().first();
                                tableElement.children("tbody").children("tr")[changeType === "append" ? "appendTo" : "prependTo"](contentTable);
                                tableElement.remove();
                                that._getFreeSpaceRowElements().not(":last").remove()
                            }
                            else
                                that.callBase.apply(that, arguments);
                            that._updateBottomLoading()
                        },
                        _updateContentPosition: function() {
                            var that = this,
                                contentElement,
                                contentHeight,
                                $tables,
                                $contentTable,
                                virtualTable,
                                rowHeight = that._rowHeight || 20,
                                virtualItemsCount = that._dataController.virtualItemsCount(),
                                isRenderVirtualTableContentRequired;
                            if (virtualItemsCount) {
                                contentElement = that._findContentElement();
                                $tables = contentElement.children();
                                $contentTable = $tables.eq(0);
                                virtualTable = $tables.eq(1);
                                that._contentTableHeight = $contentTable.outerHeight();
                                contentHeight = (virtualItemsCount.begin + virtualItemsCount.end + that._dataController.itemsCount()) * that._rowHeight;
                                if (contentHeight > CONTENT_HEIHGT_LIMIT)
                                    that._heightRatio = CONTENT_HEIHGT_LIMIT / contentHeight;
                                else
                                    that._heightRatio = 1;
                                contentHeight = (virtualItemsCount.begin + virtualItemsCount.end) * rowHeight * that._heightRatio + that._contentTableHeight;
                                var top = Math.floor(virtualItemsCount.begin * rowHeight * that._heightRatio);
                                translator.move($contentTable, {top: top});
                                isRenderVirtualTableContentRequired = that._contentHeight !== contentHeight || contentHeight === 0 || !that._isTableLinesDisplaysCorrect(virtualTable) || !that._isColumnElementsEqual($contentTable.find("col"), virtualTable.find("col"));
                                if (isRenderVirtualTableContentRequired) {
                                    that._contentHeight = contentHeight;
                                    that._renderVirtualTableContent(virtualTable, contentHeight)
                                }
                                if (that._scrollTop < top && that._dataController.pageIndex() > 0)
                                    that.scrollTo({
                                        top: top,
                                        left: that._scrollLeft
                                    });
                                return true
                            }
                            return false
                        },
                        _isTableLinesDisplaysCorrect: function(table) {
                            var hasColumnLines = table.find("." + DATAGRID_COLUMN_LINES_CLASS).length > 0;
                            return hasColumnLines === this.option("showColumnLines")
                        },
                        _isColumnElementsEqual: function($columns, $virtualColumns) {
                            var result = $columns.length === $virtualColumns.length;
                            if (result)
                                $.each($columns, function(index, element) {
                                    if (element.style.width !== $virtualColumns[index].style.width) {
                                        result = false;
                                        return result
                                    }
                                });
                            return result
                        },
                        _renderVirtualTableContent: function(container, height) {
                            var that = this,
                                columns = that._columnsController.getVisibleColumns(),
                                html = that._createColGroup(columns).prop("outerHTML"),
                                freeSpaceCellsHtml = "",
                                i,
                                columnLinesClass = that.option("showColumnLines") ? DATAGRID_COLUMN_LINES_CLASS : "",
                                createFreeSpaceRowHtml = function(height) {
                                    return "<tr style='height:" + height + "px;' class='" + DATAGRID_FREESPACE_CLASS + " " + DATAGRID_ROW_CLASS + " " + columnLinesClass + "' >" + freeSpaceCellsHtml + "</tr>"
                                };
                            for (i = 0; i < columns.length; i++)
                                freeSpaceCellsHtml += columns[i].command === "expand" ? "<td class='" + DATAGRID_GROUP_SPACE_CLASS + "'/>" : "<td />";
                            while (height > PIXELS_LIMIT) {
                                html += createFreeSpaceRowHtml(PIXELS_LIMIT);
                                height -= PIXELS_LIMIT
                            }
                            html += createFreeSpaceRowHtml(height);
                            container.addClass(DATAGRID_TABLE_CLASS);
                            container.html(html)
                        },
                        _findBottomLoadPanel: function() {
                            var $element = this.element();
                            var $bottomLoadPanel = $element && $element.find("." + DATAGRID_BOTTOM_LOAD_PANEL_CLASS);
                            if ($bottomLoadPanel && $bottomLoadPanel.length)
                                return $bottomLoadPanel
                        },
                        _updateBottomLoading: function() {
                            var that = this,
                                scrollingMode = that.option("scrolling.mode"),
                                virtualMode = scrollingMode === SCROLLING_MODE_VIRTUAL,
                                appendMode = scrollingMode === SCROLLING_MODE_INFINITE,
                                showBottomLoading = !that._dataController.hasKnownLastPage() && that._dataController.isLoaded() && (virtualMode || appendMode),
                                bottomLoadPanelElement = that._findBottomLoadPanel();
                            if (showBottomLoading) {
                                if (!bottomLoadPanelElement)
                                    $("<div>").addClass(DATAGRID_BOTTOM_LOAD_PANEL_CLASS).append(that._createComponent($("<div>"), "dxLoadIndicator").element()).appendTo(that._findContentElement())
                            }
                            else if (bottomLoadPanelElement)
                                bottomLoadPanelElement.remove()
                        },
                        _handleScroll: function(e) {
                            var that = this;
                            if (that._hasHeight && that._rowHeight)
                                that._setViewportScrollTop(e.scrollOffset.top);
                            that.callBase.apply(that, arguments)
                        },
                        _setViewportScrollTop: function(scrollTop) {
                            var that = this,
                                scrollingTimeout = Math.min(that.option("scrolling.timeout") || 0, that._renderTime || 0);
                            clearTimeout(that._scrollTimeoutID);
                            if (scrollingTimeout > 0)
                                that._scrollTimeoutID = setTimeout(function() {
                                    that._setViewportScrollTopCore(scrollTop)
                                }, scrollingTimeout);
                            else
                                that._setViewportScrollTopCore(scrollTop)
                        },
                        _setViewportScrollTopCore: function(scrollTop) {
                            var that = this,
                                virtualItemsCount = that._dataController.virtualItemsCount(),
                                heightRatio = that._heightRatio || 1,
                                rowHeight = that._rowHeight,
                                beginHeight = virtualItemsCount ? Math.floor(virtualItemsCount.begin * rowHeight * heightRatio) : 0;
                            if (virtualItemsCount && scrollTop >= beginHeight && scrollTop <= beginHeight + that._contentTableHeight)
                                that._dataController.setViewportItemIndex(virtualItemsCount.begin + (scrollTop - beginHeight) / rowHeight);
                            else
                                that._dataController.setViewportItemIndex(scrollTop / (rowHeight * heightRatio))
                        },
                        _needUpdateRowHeight: function(itemsCount) {
                            var that = this;
                            return that.callBase.apply(that, arguments) || itemsCount > 0 && that.option("scrolling.mode") === SCROLLING_MODE_INFINITE
                        },
                        _updateRowHeight: function() {
                            var that = this,
                                viewportHeight;
                            that.callBase.apply(that, arguments);
                            if (that._rowHeight) {
                                that._updateContentPosition();
                                viewportHeight = that._hasHeight ? that.element().outerHeight() : $(window).outerHeight();
                                that._dataController.viewportSize(Math.round(viewportHeight / that._rowHeight))
                            }
                        },
                        setLoading: function(isLoading, messageText) {
                            var that = this,
                                callBase = that.callBase,
                                hasBottomLoadPanel = !!that._findBottomLoadPanel() && that._dataController.isLoaded();
                            if (hasBottomLoadPanel)
                                isLoading = false;
                            callBase.call(that, isLoading, messageText)
                        },
                        _resizeCore: function() {
                            var that = this,
                                $element = that.element();
                            that.callBase();
                            if (that.component.element() && !that._windowScroll && $element.closest(document).length) {
                                that._windowScroll = subscribeToExternalScrollers($element, function(scrollPos) {
                                    if (!that._hasHeight && that._rowHeight)
                                        that._setViewportScrollTop(scrollPos)
                                }, that.component.element());
                                that.on("disposing", function() {
                                    that._windowScroll.dispose()
                                })
                            }
                            var dataSource = that._dataController.dataSource();
                            if (dataSource && dataSource.loadIfNeed)
                                dataSource.loadIfNeed()
                        },
                        getTableElements: function(isVirtualTable) {
                            var result = this.callBase();
                            if (isVirtualTable && this.option("scrolling.mode") === "virtual")
                                result = result.add(this.element().find("> ." + DATAGRID_SCROLLABLE_CONTAINER + " > ." + DATAGRID_SCROLLABLE_CONTENT + "> ." + DATAGRID_CONTENT_CLASS).children(":not(." + DATAGRID_TABLE_CONTENT_CLASS + ")"));
                            return result
                        },
                        dispose: function() {
                            clearTimeout(this._scrollTimeoutID);
                            this.callBase()
                        }
                    }
            }();
        $.extend(dataGrid.__internals, {
            DATAGRID_BOTTOM_LOAD_PANEL_CLASS: DATAGRID_BOTTOM_LOAD_PANEL_CLASS,
            DATAGRID_TABLE_CONTENT_CLASS: DATAGRID_TABLE_CONTENT_CLASS
        });
        dataGrid.registerModule("virtualScrolling", {
            defaultOptions: function() {
                return {scrolling: {
                            timeout: 300,
                            mode: "standard",
                            preloadEnabled: false,
                            useNative: "auto"
                        }}
            },
            extenders: {
                controllers: {data: function() {
                        var members = {};
                        dataGrid.proxyMethod(members, "virtualItemsCount");
                        dataGrid.proxyMethod(members, "viewportSize");
                        dataGrid.proxyMethod(members, "setViewportItemIndex");
                        return members
                    }()},
                views: {rowsView: VirtualScrollingRowsViewExtender}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnHeadersView.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common");
        var DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_HEADERS_CLASS = "dx-datagrid-headers",
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            DATAGRID_NOWRAP_CLASS = "dx-datagrid-nowrap",
            DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
            DATAGRID_CONTEXT_MENU_SORT_ASC_ICON = "context-menu-sort-asc",
            DATAGRID_CONTEXT_MENU_SORT_DESC_ICON = "context-menu-sort-desc",
            DATAGRID_CONTEXT_MENU_SORT_NONE_ICON = "context-menu-sort-none",
            DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
            DATAGRID_COLUMN_INDICATORS_CLASS = "dx-column-indicators";
        var createCellContent = function($cell, showColumnLines) {
                return $("<div />").addClass(DATAGRID_CELL_CONTENT_CLASS).appendTo($cell)
            };
        dataGrid.ColumnHeadersView = dataGrid.ColumnsView.inherit({
            _getDefaultTemplate: function(column) {
                var that = this,
                    template,
                    showColumnLines = that.option("showColumnLines");
                if (column.command)
                    template = function($container, options) {
                        var column = options.column;
                        $container.html("&nbsp;");
                        $container.addClass(column.cssClass)
                    };
                else
                    template = function($container, options) {
                        var $content = createCellContent($container, showColumnLines);
                        $content.text(column.caption)
                    };
                return template
            },
            _getHeaderTemplate: function(column) {
                return !commonUtils.isDefined(column.command) && column.headerCellTemplate || {
                        allowRenderToDetachedContainer: true,
                        render: this._getDefaultTemplate(column)
                    }
            },
            _processTemplate: function(template, options) {
                var that = this,
                    resultTemplate,
                    column = options.column,
                    renderingTemplate = this.callBase(template);
                if (renderingTemplate && column.headerCellTemplate)
                    resultTemplate = {render: function(options, $container) {
                            var $content = createCellContent($container, that.option("showColumnLines"));
                            renderingTemplate.render(options, $content)
                        }};
                else
                    resultTemplate = renderingTemplate;
                return resultTemplate
            },
            _handleDataChanged: function(e) {
                if (this._isGroupingChanged || this._requireReady) {
                    this._isGroupingChanged = false;
                    this.render()
                }
            },
            _renderCell: function($row, options) {
                var $cell = this.callBase($row, options);
                if (options.row.rowType === "header") {
                    $cell.addClass(DATAGRID_CELL_FOCUS_DISABLED_CLASS);
                    if (!commonUtils.isDefined(options.column.command)) {
                        this.setAria("role", "columnheader", $cell);
                        this.setAria("label", options.column.caption + " " + Globalize.localize("dxDataGrid-ariaColumn"), $cell)
                    }
                }
                return $cell
            },
            _createRow: function(row) {
                var $row = this.callBase(row).toggleClass(DATAGRID_COLUMN_LINES_CLASS, this.option("showColumnLines"));
                if (row.rowType === "header")
                    $row.addClass(DATAGRID_HEADER_ROW_CLASS);
                return $row
            },
            _renderCore: function() {
                var that = this,
                    $container = that.element();
                if (that._tableElement && !that._dataController.isLoaded())
                    return;
                $container.addClass(DATAGRID_HEADERS_CLASS).toggleClass(DATAGRID_NOWRAP_CLASS, !that.option("wordWrapEnabled")).empty();
                that._updateContent(that._renderTable());
                that.callBase.apply(that, arguments)
            },
            _renderRows: function() {
                var that = this;
                if (that._dataController.isLoaded())
                    that.callBase.apply(that, arguments)
            },
            _getRows: function() {
                var result = [];
                if (this.option("showColumnHeaders"))
                    result.push({rowType: "header"});
                return result
            },
            _getCellTemplate: function(options) {
                if (options.rowType === "header")
                    return this._getHeaderTemplate(options.column)
            },
            _columnOptionChanged: function(e) {
                var changeTypes = e.changeTypes,
                    optionNames = e.optionNames,
                    showColumnLines = this.option("showColumnLines");
                if (changeTypes.grouping) {
                    this._isGroupingChanged = true;
                    return
                }
                this.callBase(e);
                if (optionNames.width || optionNames.visibleWidth) {
                    !showColumnLines && this._updateColumnTextWidths();
                    this.resizeCompleted.fire()
                }
            },
            _updateColumnTextWidths: function() {
                var that = this,
                    widths = [],
                    indicatorWidth,
                    $indicatorContainer,
                    columns = that.getColumns(),
                    $cells = that.getColumnElements();
                if (!$cells)
                    return;
                $.each(columns, function(index, column) {
                    indicatorWidth = 0;
                    $indicatorContainer = that._getIndicatorContainer($($cells[index]));
                    if ($indicatorContainer.length)
                        indicatorWidth = $indicatorContainer.outerWidth();
                    widths[index] = $($cells[index]).width() - (column.alignment === "center" ? indicatorWidth * 2 : indicatorWidth)
                });
                $.each($cells, function(index, cell) {
                    if (widths.length && widths[index] > 0)
                        $(cell).find("." + DATAGRID_CELL_CONTENT_CLASS).css("max-width", widths[index])
                })
            },
            _isElementVisible: function(elementOptions) {
                return elementOptions && elementOptions.visible
            },
            getHeadersRowHeight: function() {
                var tableElement = this._getTableElement();
                if (tableElement) {
                    var $headerRow = tableElement.find("." + DATAGRID_HEADER_ROW_CLASS).first();
                    return $headerRow && $headerRow.height()
                }
                return 0
            },
            getHeaderElement: function(index) {
                var columnElements = this.getColumnElements();
                return columnElements && columnElements.eq(index)
            },
            getColumnElements: function() {
                if (this.option("showColumnHeaders"))
                    return this.getCellElements(0)
            },
            getColumnWidths: function() {
                var that = this,
                    indicatorWidth,
                    $indicatorElements,
                    columns = that.getColumns(),
                    $columnElements = that.getColumnElements(),
                    resultWidths = that.callBase();
                if ($columnElements && resultWidths && $columnElements.length === resultWidths.length)
                    $.each($columnElements, function(index, columnElement) {
                        $indicatorElements = $(columnElement).find("." + DATAGRID_COLUMN_INDICATORS_CLASS);
                        if ($indicatorElements.length) {
                            indicatorWidth = $indicatorElements.outerWidth(true);
                            resultWidths[index] += columns[index].alignment === "center" ? indicatorWidth * 2 : indicatorWidth
                        }
                    });
                return resultWidths
            },
            allowDragging: function(column, draggingPanels) {
                var i,
                    columns = this.getColumns(),
                    draggableColumnCount = 0,
                    draggingPanel,
                    allowDrag = function(column) {
                        return column.allowReordering || column.allowGrouping || column.allowHiding
                    };
                for (i = 0; i < columns.length; i++)
                    if (allowDrag(columns[i]))
                        draggableColumnCount++;
                if (draggableColumnCount <= 1)
                    return false;
                else if (!draggingPanels)
                    return (this.option("allowColumnReordering") || this._columnsController.isColumnOptionUsed("allowReordering")) && column && column.allowReordering;
                for (i = 0; i < draggingPanels.length; i++) {
                    draggingPanel = draggingPanels[i];
                    if (draggingPanel && draggingPanel.allowDragging(column))
                        return true
                }
                return false
            },
            getBoundingRect: function() {
                var that = this,
                    offset,
                    $columnElements = that.getColumnElements();
                if ($columnElements && $columnElements.length) {
                    offset = that._getTableElement().offset();
                    return {top: offset.top}
                }
                return null
            },
            getName: function() {
                return "headers"
            },
            getColumnCount: function() {
                var $columnElements = this.getColumnElements();
                return $columnElements ? $columnElements.length : 0
            },
            isVisible: function() {
                return this.option("showColumnHeaders")
            },
            optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"showColumnHeaders":
                    case"wordWrapEnabled":
                    case"showColumnLines":
                        that._invalidate(true, true);
                        args.handled = true;
                        break;
                    default:
                        that.callBase(args)
                }
            },
            getHeight: function() {
                var that = this,
                    $element = that.element();
                return $element ? $element.height() : 0
            },
            getContextMenuItems: function($targetElement) {
                var that = this,
                    $cell,
                    column,
                    onItemClick,
                    sortingOptions;
                if ($targetElement.closest("." + DATAGRID_HEADER_ROW_CLASS).length) {
                    $cell = $targetElement.closest("td");
                    column = $cell.length && that.getColumns($targetElement)[$cell[0].cellIndex];
                    sortingOptions = that.option("sorting");
                    if (sortingOptions && sortingOptions.mode !== "none" && column && column.allowSorting) {
                        onItemClick = function(params) {
                            setTimeout(function() {
                                that._columnsController.changeSortOrder(column.index, params.itemData.value)
                            })
                        };
                        return [{
                                    text: sortingOptions.ascendingText,
                                    value: "asc",
                                    disabled: column.sortOrder === "asc",
                                    icon: DATAGRID_CONTEXT_MENU_SORT_ASC_ICON,
                                    onItemClick: onItemClick
                                }, {
                                    text: sortingOptions.descendingText,
                                    value: "desc",
                                    disabled: column.sortOrder === "desc",
                                    icon: DATAGRID_CONTEXT_MENU_SORT_DESC_ICON,
                                    onItemClick: onItemClick
                                }, {
                                    text: sortingOptions.clearText,
                                    value: "none",
                                    disabled: !column.sortOrder,
                                    icon: DATAGRID_CONTEXT_MENU_SORT_NONE_ICON,
                                    onItemClick: onItemClick
                                }]
                    }
                    return []
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_HEADERS_CLASS: DATAGRID_HEADERS_CLASS,
            DATAGRID_HEADER_ROW_CLASS: DATAGRID_HEADER_ROW_CLASS,
            DATAGRID_NOWRAP_CLASS: DATAGRID_NOWRAP_CLASS
        });
        dataGrid.registerModule("columnHeaders", {
            defaultOptions: function() {
                return {
                        showColumnHeaders: true,
                        cellHintEnabled: true
                    }
            },
            views: {columnHeadersView: dataGrid.ColumnHeadersView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.filterRow.js */
    (function($, DX) {
        var ui = DX.ui,
            commonUtils = DX.require("/utils/utils.common"),
            dataGrid = ui.dxDataGrid,
            Editor = DX.require("/ui/ui.editor");
        var OPERATION_ICONS = {
                "=": "filter-operation-equals",
                "<>": "filter-operation-not-equals",
                "<": "filter-operation-less",
                "<=": "filter-operation-less-equal",
                ">": "filter-operation-greater",
                ">=": "filter-operation-greater-equal",
                "default": "filter-operation-default",
                notcontains: "filter-operation-not-contains",
                contains: "filter-operation-contains",
                startswith: "filter-operation-starts-with",
                endswith: "filter-operation-ends-with",
                between: "filter-operation-between"
            };
        var FILTERING_TIMEOUT = 700,
            CORRECT_FILTER_RANGE_OVERLAY_WIDTH = 1,
            DATAGRID_CLASS = "dx-datagrid",
            DATAGRID_FIRST_CELL_CLASS = "dx-first-cell",
            DATAGRID_FILTER_ROW_CLASS = "dx-datagrid-filter-row",
            DATAGRID_MENU_CLASS = "dx-menu",
            DATAGRID_MENU_IMAGE_CLASS = "dx-menu-image",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_EDITOR_WITH_MENU_CLASS = "dx-editor-with-menu",
            DATAGRID_EDITOR_CONTAINER_CLASS = "dx-editor-container",
            DATAGRID_EDITOR_CELL_CLASS = "dx-editor-cell",
            DATAGRID_FILTER_MENU = "dx-filter-menu",
            DATAGRID_APPLY_BUTTON_CLASS = "dx-apply-button",
            DATAGRID_HIGHLIGHT_OUTLINE_CLASS = "dx-highlight-outline",
            DATAGRID_FOCUSED_CLASS = "dx-focused",
            DATAGRID_CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled",
            DATAGRID_FILTER_RANGE_OVERLAY_CLASS = "dx-datagrid-filter-range-overlay",
            DATAGRID_FILTER_RANGE_CONTENT_CLASS = "dx-filter-range-content",
            DATAGRID_FILTER_RANGE_START_CLASS = "dx-datagrid-filter-range-start",
            DATAGRID_FILTER_RANGE_END_CLASS = "dx-datagrid-filter-range-end";
        var ColumnHeadersViewFilterRowExtender = function() {
                var getEditorInstance = function($editorContainer) {
                        var $editor = $editorContainer && $editorContainer.children(),
                            componentNames = $editor && $editor.data("dxComponents"),
                            editor = componentNames && componentNames.length && $editor.data(componentNames[0]);
                        if (editor instanceof Editor)
                            return editor
                    };
                var getRangeTextByFilterValue = function(column) {
                        var filterValue = column.filterValue,
                            result = "";
                        if (commonUtils.isArray(filterValue)) {
                            result = dataGrid.formatValue(filterValue[0], column);
                            if (dataGrid.formatValue(filterValue[1], column) !== "")
                                result += " - " + dataGrid.formatValue(filterValue[1], column)
                        }
                        else if (commonUtils.isDefined(filterValue))
                            result = dataGrid.formatValue(filterValue, column);
                        return result
                    };
                var getFilterValue = function(that, columnIndex, $editorContainer) {
                        var column = that._columnsController.columnOption(columnIndex),
                            filterValue = column && column.filterValue,
                            isFiltrerRange = $editorContainer.closest("." + DATAGRID_FILTER_RANGE_OVERLAY_CLASS).length,
                            isRangeStart = $editorContainer.hasClass(DATAGRID_FILTER_RANGE_START_CLASS);
                        if (filterValue && commonUtils.isArray(filterValue))
                            if (isRangeStart)
                                return filterValue[0];
                            else
                                return filterValue[1];
                        return !isFiltrerRange ? filterValue : undefined
                    };
                var normalizeFilterValue = function(filterValue, column, $editorContainer) {
                        if (column.selectedFilterOperation === "between")
                            if ($editorContainer.hasClass(DATAGRID_FILTER_RANGE_START_CLASS))
                                return [filterValue, commonUtils.isArray(column.filterValue) ? column.filterValue[1] : undefined];
                            else
                                return [commonUtils.isArray(column.filterValue) ? column.filterValue[0] : column.filterValue, filterValue];
                        return filterValue
                    };
                var updateFilterValue = function(that, options) {
                        var value = options.value === "" ? undefined : options.value,
                            $editorContainer = options.container,
                            column = that._columnsController.columnOption(options.column.index),
                            filterValue = getFilterValue(that, column.index, $editorContainer);
                        if (!commonUtils.isDefined(filterValue) && !commonUtils.isDefined(value))
                            return;
                        that._applyFilterViewController.setHighLight($editorContainer, filterValue !== value);
                        that._columnsController.columnOption(column.index, "filterValue", normalizeFilterValue(value, column, $editorContainer), options.notFireEvent)
                    };
                return {
                        _updateEditorValue: function(column, $editorContainer) {
                            var that = this,
                                editor = getEditorInstance($editorContainer);
                            editor && editor.option("value", getFilterValue(that, column.index, $editorContainer))
                        },
                        _columnOptionChanged: function(e) {
                            var that = this,
                                optionNames = e.optionNames,
                                overlayInstance,
                                visibleIndex,
                                column,
                                $cell,
                                $editorContainer,
                                $editorRangeElements,
                                $rangeContent,
                                $menu;
                            if (dataGrid.checkChanges(optionNames, ["filterValue", "selectedFilterOperation"]) && e.columnIndex !== undefined) {
                                visibleIndex = that.getController("columns").getVisibleIndex(e.columnIndex);
                                column = that.getController("columns").columnOption(e.columnIndex);
                                $cell = that.getCellElement(that.element().find("." + DATAGRID_FILTER_ROW_CLASS).index(), visibleIndex) || $();
                                $rangeContent = $cell.find("." + DATAGRID_FILTER_RANGE_CONTENT_CLASS);
                                $editorContainer = $cell.find("." + DATAGRID_EDITOR_CONTAINER_CLASS).first();
                                if (optionNames.filterValue) {
                                    that._updateEditorValue(column, $editorContainer);
                                    overlayInstance = $cell.find("." + DATAGRID_FILTER_RANGE_OVERLAY_CLASS).data("dxOverlay");
                                    if (overlayInstance) {
                                        $editorRangeElements = overlayInstance.content().find("." + DATAGRID_EDITOR_CONTAINER_CLASS);
                                        that._updateEditorValue(column, $editorRangeElements.first());
                                        that._updateEditorValue(column, $editorRangeElements.last())
                                    }
                                    if (!overlayInstance || !overlayInstance.option("visible"))
                                        that._updateFilterRangeContent($cell, getRangeTextByFilterValue(column))
                                }
                                if (optionNames.selectedFilterOperation)
                                    if (visibleIndex >= 0 && column) {
                                        $menu = $cell.find("." + DATAGRID_MENU_CLASS);
                                        if ($menu.length) {
                                            that._updateFilterOperationChooser($menu, column, $editorContainer);
                                            if (column.selectedFilterOperation === "between") {
                                                that._renderFilterRangeContent($cell, column);
                                                that._showFilterRange($cell, column)
                                            }
                                            else if ($editorContainer.find("." + DATAGRID_FILTER_RANGE_CONTENT_CLASS).length) {
                                                that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, column));
                                                that._hideFilterRange()
                                            }
                                        }
                                    }
                                return
                            }
                            that.callBase(e)
                        },
                        _resizeCore: function() {
                            this.callBase.apply(this, arguments);
                            this._filterRangeOverlayInstance && this._filterRangeOverlayInstance.repaint()
                        },
                        isFilterRowVisible: function() {
                            return this._isElementVisible(this.option("filterRow"))
                        },
                        isVisible: function() {
                            return this.callBase() || this.isFilterRowVisible()
                        },
                        init: function() {
                            this.callBase();
                            this._applyFilterViewController = this.getController("applyFilter")
                        },
                        _initFilterRangeOverlay: function($cell, column) {
                            var that = this,
                                sharedData = {},
                                $editorContainer = $cell.find(".dx-editor-container"),
                                $overlay = $("<div/>").addClass(DATAGRID_FILTER_RANGE_OVERLAY_CLASS).appendTo($cell);
                            return that._createComponent($overlay, "dxOverlay", {
                                    height: "auto",
                                    shading: false,
                                    showTitle: false,
                                    focusStateEnabled: false,
                                    closeOnTargetScroll: true,
                                    closeOnOutsideClick: true,
                                    animation: false,
                                    position: {
                                        my: "top",
                                        at: "top",
                                        of: $editorContainer.length && $editorContainer || $cell,
                                        offset: "0 -1"
                                    },
                                    contentTemplate: function(contentElement) {
                                        var $editor = $("<div/>").addClass(DATAGRID_EDITOR_CONTAINER_CLASS + " " + DATAGRID_FILTER_RANGE_START_CLASS).appendTo(contentElement),
                                            editorOptions = that._getEditorOptions($editor, column);
                                        editorOptions.sharedData = sharedData;
                                        that._renderEditor($editor, editorOptions);
                                        $editor.find("input").on("keydown", function(e) {
                                            var $prevElement = $cell.find("[tabindex]").not(e.target).first();
                                            if (e.which === 9 && e.shiftKey) {
                                                e.preventDefault();
                                                that._hideFilterRange();
                                                if (!$prevElement.length)
                                                    $prevElement = $cell.prev().find("[tabindex]").last();
                                                $prevElement.focus()
                                            }
                                        });
                                        $editor = $("<div/>").addClass(DATAGRID_EDITOR_CONTAINER_CLASS + " " + DATAGRID_FILTER_RANGE_END_CLASS).appendTo(contentElement);
                                        editorOptions = that._getEditorOptions($editor, column);
                                        editorOptions.sharedData = sharedData;
                                        that._renderEditor($editor, editorOptions);
                                        $editor.find("input").on("keydown", function(e) {
                                            if (e.which === 9 && !e.shiftKey) {
                                                e.preventDefault();
                                                that._hideFilterRange();
                                                $cell.next().find("[tabindex]").first().focus()
                                            }
                                        });
                                        return contentElement.addClass(DATAGRID_CLASS)
                                    },
                                    onShown: function(e) {
                                        var $editor = e.component.content().find("." + DATAGRID_EDITOR_CONTAINER_CLASS).first();
                                        $editor.find("input").focus()
                                    },
                                    onHidden: function() {
                                        var updatedColumn = that._columnsController.columnOption(column.index);
                                        $cell.find("." + DATAGRID_MENU_CLASS).parent().addClass(DATAGRID_EDITOR_WITH_MENU_CLASS);
                                        if (updatedColumn.selectedFilterOperation === "between") {
                                            that._updateFilterRangeContent($cell, getRangeTextByFilterValue(updatedColumn));
                                            that.component.updateDimensions()
                                        }
                                    }
                                })
                        },
                        _updateFilterRangeOverlay: function(options) {
                            var overlayInstance = this._filterRangeOverlayInstance;
                            overlayInstance && overlayInstance.option(options)
                        },
                        _showFilterRange: function($cell, column) {
                            var that = this,
                                $overlay = $cell.children("." + DATAGRID_FILTER_RANGE_OVERLAY_CLASS),
                                overlayInstance = $overlay.length && $overlay.data("dxOverlay");
                            if (!overlayInstance && column)
                                overlayInstance = that._initFilterRangeOverlay($cell, column);
                            if (!overlayInstance.option("visible")) {
                                that._filterRangeOverlayInstance && that._filterRangeOverlayInstance.hide();
                                that._filterRangeOverlayInstance = overlayInstance;
                                that._updateFilterRangeOverlay({width: $cell.outerWidth(true) + CORRECT_FILTER_RANGE_OVERLAY_WIDTH});
                                that._filterRangeOverlayInstance && that._filterRangeOverlayInstance.show()
                            }
                        },
                        _hideFilterRange: function() {
                            var overlayInstance = this._filterRangeOverlayInstance;
                            overlayInstance && overlayInstance.hide()
                        },
                        getFilterRangeOverlayInstance: function() {
                            return this._filterRangeOverlayInstance
                        },
                        _createRow: function(row) {
                            var $row = this.callBase(row);
                            if (row.rowType === "filter")
                                $row.addClass(DATAGRID_FILTER_ROW_CLASS);
                            return $row
                        },
                        _getRows: function() {
                            var result = this.callBase();
                            if (this.isFilterRowVisible())
                                result.push({rowType: "filter"});
                            return result
                        },
                        _renderCellContent: function($cell, options) {
                            var that = this,
                                column = options.column,
                                $container,
                                $editorContainer;
                            if (options.rowType === "filter") {
                                $cell.toggleClass(DATAGRID_FIRST_CELL_CLASS, options.columnIndex === 0);
                                if (column.command)
                                    $cell.html("&nbsp;");
                                else if (column.allowFiltering) {
                                    that.setAria("label", Globalize.localize("dxDataGrid-ariaColumn") + " " + column.caption + ", " + Globalize.localize("dxDataGrid-ariaFilterCell"), $cell);
                                    $cell.addClass(DATAGRID_EDITOR_CELL_CLASS);
                                    $container = $("<div />").appendTo($cell);
                                    $editorContainer = $("<div />").addClass(DATAGRID_EDITOR_CONTAINER_CLASS).appendTo($container);
                                    if (column.selectedFilterOperation === "between")
                                        that._renderFilterRangeContent($cell, column);
                                    else
                                        that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, column));
                                    if (column.alignment)
                                        $cell.find("input").first().css("text-align", column.alignment);
                                    if (column.filterOperations && column.filterOperations.length)
                                        that._renderFilterOperationChooser($container, column, $editorContainer)
                                }
                            }
                            that.callBase($cell, options)
                        },
                        _getEditorOptions: function($editorContainer, column) {
                            var that = this,
                                result = $.extend({}, column, {
                                    value: getFilterValue(that, column.index, $editorContainer),
                                    parentType: "filterRow",
                                    showAllText: that.option("filterRow.showAllText"),
                                    updateValueTimeout: that.option("filterRow.applyFilter") === "onClick" ? 0 : FILTERING_TIMEOUT,
                                    width: null,
                                    setValue: function(value, notFireEvent) {
                                        updateFilterValue(that, {
                                            column: column,
                                            value: value,
                                            container: $editorContainer,
                                            notFireEvent: notFireEvent
                                        })
                                    }
                                });
                            if (column.selectedFilterOperation === "between")
                                if ($editorContainer.hasClass(DATAGRID_FILTER_RANGE_START_CLASS))
                                    result.placeholder = that.option("filterRow.betweenStartText");
                                else
                                    result.placeholder = that.option("filterRow.betweenEndText");
                            return result
                        },
                        _renderEditor: function($editorContainer, options) {
                            $editorContainer.empty();
                            return this.getController("editorFactory").createEditor($("<div />").appendTo($editorContainer), options)
                        },
                        _renderFilterRangeContent: function($cell, column) {
                            var that = this,
                                $editorContainer = $cell.find("." + DATAGRID_EDITOR_CONTAINER_CLASS).first();
                            $editorContainer.empty();
                            $("<div/>").addClass(DATAGRID_FILTER_RANGE_CONTENT_CLASS).attr("tabindex", 0).on("focusin", function(e) {
                                that._showFilterRange($cell, column)
                            }).appendTo($editorContainer);
                            that._updateFilterRangeContent($cell, getRangeTextByFilterValue(column))
                        },
                        _updateFilterRangeContent: function($cell, value) {
                            var $filterRangeContent = $cell.find("." + DATAGRID_FILTER_RANGE_CONTENT_CLASS);
                            if ($filterRangeContent.length)
                                if (value === "")
                                    $filterRangeContent.html("&nbsp;");
                                else
                                    $filterRangeContent.text(value)
                        },
                        _updateFilterOperationChooser: function($menu, column, $editorContainer) {
                            var that = this,
                                isCellWasFocused;
                            that._createComponent($menu, "dxMenu", {
                                _templates: {},
                                activeStateEnabled: false,
                                selectionMode: "single",
                                cssClass: DATAGRID_CLASS + " " + DATAGRID_CELL_FOCUS_DISABLED_CLASS + " " + DATAGRID_FILTER_MENU,
                                showFirstSubmenuMode: "onHover",
                                hideSubmenuOnMouseLeave: true,
                                items: [{
                                        disabled: column.filterOperations && column.filterOperations.length ? false : true,
                                        icon: OPERATION_ICONS[column.selectedFilterOperation || "default"],
                                        selectable: false,
                                        items: that._getFilterOperationMenuItems(column)
                                    }],
                                onItemClick: function(properties) {
                                    var selectedFilterOperation = properties.itemData.name,
                                        notFocusEditor = false,
                                        options = {};
                                    if (properties.itemData.items || selectedFilterOperation === column.selectedFilterOperation)
                                        return;
                                    if (selectedFilterOperation) {
                                        options.selectedFilterOperation = selectedFilterOperation;
                                        if (selectedFilterOperation === "between" || column.selectedFilterOperation === "between") {
                                            notFocusEditor = selectedFilterOperation === "between";
                                            options.filterValue = undefined
                                        }
                                    }
                                    else
                                        options = {
                                            selectedFilterOperation: column.defaultSelectedFilterOperation,
                                            filterValue: undefined
                                        };
                                    that._columnsController.columnOption(column.index, options);
                                    that._applyFilterViewController.setHighLight($editorContainer, true);
                                    !notFocusEditor && that._focusEditor($editorContainer)
                                },
                                onSubmenuShown: function() {
                                    isCellWasFocused = that._isEditorFocused($editorContainer);
                                    that.getController("editorFactory").loseFocus()
                                },
                                onSubmenuHiding: function(e) {
                                    $menu.blur();
                                    $menu.dxMenu("instance").option("focusedElement", null);
                                    isCellWasFocused && that._focusEditor($editorContainer)
                                },
                                rtlEnabled: that.option("rtlEnabled")
                            })
                        },
                        _isEditorFocused: function($container) {
                            return $container.hasClass(DATAGRID_FOCUSED_CLASS) || $container.parents("." + DATAGRID_FOCUSED_CLASS).length
                        },
                        _focusEditor: function($container) {
                            this.getController("editorFactory").focus($container);
                            $container.find("input").focus()
                        },
                        _renderFilterOperationChooser: function($container, column, $editorContainer) {
                            var that = this,
                                $menu;
                            if (that.option("filterRow.showOperationChooser")) {
                                $container.addClass(DATAGRID_EDITOR_WITH_MENU_CLASS);
                                $menu = $("<div />").prependTo($container);
                                that._updateFilterOperationChooser($menu, column, $editorContainer)
                            }
                        },
                        _getFilterOperationMenuItems: function(column) {
                            var that = this,
                                result = [{}],
                                filterRowOptions = that.option("filterRow"),
                                operationDescriptions = filterRowOptions && filterRowOptions.operationDescriptions || {};
                            if (column.filterOperations && column.filterOperations.length) {
                                result = $.map(column.filterOperations, function(value) {
                                    return {
                                            name: value,
                                            selected: (column.selectedFilterOperation || column.defaultFilterOperation) === value,
                                            text: operationDescriptions[value],
                                            icon: OPERATION_ICONS[value]
                                        }
                                });
                                result.push({
                                    name: null,
                                    text: filterRowOptions && filterRowOptions.resetOperationText,
                                    icon: OPERATION_ICONS["default"]
                                })
                            }
                            return result
                        },
                        optionChanged: function(args) {
                            var that = this;
                            switch (args.name) {
                                case"filterRow":
                                case"showColumnLines":
                                    this._invalidate(true, true);
                                    args.handled = true;
                                    break;
                                default:
                                    that.callBase(args);
                                    break
                            }
                        }
                    }
            }();
        var DataControllerFilterRowExtender = {_calculateAdditionalFilter: function() {
                    var that = this,
                        filters = [that.callBase()],
                        columns = that._columnsController.getVisibleColumns();
                    $.each(columns, function() {
                        var filter;
                        if (this.allowFiltering && this.calculateFilterExpression && commonUtils.isDefined(this.filterValue)) {
                            filter = this.createFilterExpression(this.filterValue, this.selectedFilterOperation || this.defaultFilterOperation, "filterRow");
                            filters.push(filter)
                        }
                    });
                    return dataGrid.combineFilters(filters)
                }};
        dataGrid.ApplyFilterViewController = dataGrid.ViewController.inherit({
            _isOnClick: function() {
                return this.option("filterRow.applyFilter") === "onClick"
            },
            _getHeaderPanel: function() {
                if (!this._headerPanel)
                    this._headerPanel = this.getView("headerPanel");
                return this._headerPanel
            },
            setHighLight: function($element, value) {
                if (this._isOnClick()) {
                    $element && $element.toggleClass(DATAGRID_HIGHLIGHT_OUTLINE_CLASS, value);
                    this._getHeaderPanel().enableApplyButton(value)
                }
            },
            removeHighLights: function() {
                if (this._isOnClick()) {
                    var columnHeadersView = this.getView("columnHeadersView");
                    columnHeadersView.element().find("." + DATAGRID_FILTER_ROW_CLASS + " ." + DATAGRID_HIGHLIGHT_OUTLINE_CLASS).removeClass(DATAGRID_HIGHLIGHT_OUTLINE_CLASS);
                    this._getHeaderPanel().enableApplyButton(false)
                }
            }
        });
        dataGrid.registerModule("filterRow", {
            defaultOptions: function() {
                return {filterRow: {
                            visible: false,
                            showOperationChooser: true,
                            showAllText: Globalize.localize("dxDataGrid-filterRowShowAllText"),
                            resetOperationText: Globalize.localize("dxDataGrid-filterRowResetOperationText"),
                            applyFilter: "auto",
                            applyFilterText: Globalize.localize("dxDataGrid-applyFilterText"),
                            operationDescriptions: {
                                "=": Globalize.localize("dxDataGrid-filterRowOperationEquals"),
                                "<>": Globalize.localize("dxDataGrid-filterRowOperationNotEquals"),
                                "<": Globalize.localize("dxDataGrid-filterRowOperationLess"),
                                "<=": Globalize.localize("dxDataGrid-filterRowOperationLessOrEquals"),
                                ">": Globalize.localize("dxDataGrid-filterRowOperationGreater"),
                                ">=": Globalize.localize("dxDataGrid-filterRowOperationGreaterOrEquals"),
                                startswith: Globalize.localize("dxDataGrid-filterRowOperationStartsWith"),
                                contains: Globalize.localize("dxDataGrid-filterRowOperationContains"),
                                notcontains: Globalize.localize("dxDataGrid-filterRowOperationNotContains"),
                                endswith: Globalize.localize("dxDataGrid-filterRowOperationEndsWith"),
                                between: Globalize.localize("dxDataGrid-filterRowOperationBetween")
                            },
                            betweenStartText: Globalize.localize("dxDataGrid-filterRowOperationBetweenStartText"),
                            betweenEndText: Globalize.localize("dxDataGrid-filterRowOperationBetweenEndText")
                        }}
            },
            controllers: {applyFilter: dataGrid.ApplyFilterViewController},
            extenders: {
                controllers: {
                    data: DataControllerFilterRowExtender,
                    columnsResizer: {
                        _startResizing: function() {
                            var that = this,
                                cellIndex,
                                overlayInstance;
                            that.callBase.apply(that, arguments);
                            if (that.isResizing()) {
                                overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
                                if (overlayInstance) {
                                    cellIndex = overlayInstance.element().closest("td").index();
                                    if (cellIndex === that._targetPoint.columnIndex || cellIndex === that._targetPoint.columnIndex + 1)
                                        overlayInstance.content().hide()
                                }
                            }
                        },
                        _endResizing: function(args) {
                            var that = this,
                                $cell,
                                overlayInstance;
                            if (that.isResizing()) {
                                overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
                                if (overlayInstance) {
                                    $cell = overlayInstance.element().closest("td");
                                    that._columnHeadersView._updateFilterRangeOverlay({width: $cell.outerWidth(true) + CORRECT_FILTER_RANGE_OVERLAY_WIDTH});
                                    overlayInstance.content().show()
                                }
                            }
                            that.callBase.apply(that, arguments)
                        }
                    }
                },
                views: {
                    columnHeadersView: ColumnHeadersViewFilterRowExtender,
                    headerPanel: {
                        _isShowApplyFilterButton: function() {
                            var filterRowOptions = this.option("filterRow");
                            return filterRowOptions && filterRowOptions.visible && filterRowOptions.applyFilter === "onClick"
                        },
                        _renderCore: function() {
                            var that = this,
                                disabled = that._applyButton ? that._applyButton.option("disabled") : true;
                            that.callBase();
                            that._$applyButton && that._$applyButton.remove();
                            if (that._isShowApplyFilterButton()) {
                                that._applyButton = that._createComponent($("<div>").addClass(DATAGRID_APPLY_BUTTON_CLASS).appendTo(that.element()), "dxButton", {
                                    disabled: disabled,
                                    hint: that.option("filterRow.applyFilterText"),
                                    icon: "apply-filter",
                                    onClick: function() {
                                        that._dataController._applyFilter();
                                        that._applyFilterViewController.removeHighLights()
                                    }
                                });
                                that._$applyButton = that._applyButton.element()
                            }
                        },
                        init: function() {
                            this.callBase();
                            this._dataController = this.getController("data");
                            this._applyFilterViewController = this.getController("applyFilter")
                        },
                        enableApplyButton: function(value) {
                            this._applyButton && this._applyButton.option("disabled", !value)
                        },
                        isVisible: function() {
                            return this.callBase() || this._isShowApplyFilterButton()
                        },
                        optionChanged: function(args) {
                            if (args.name === "filterRow") {
                                this._invalidate();
                                args.handled = true
                            }
                            else
                                this.callBase(args)
                        }
                    }
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_FILTER_ROW_CLASS: DATAGRID_FILTER_ROW_CLASS,
            DATAGRID_MENU_CLASS: DATAGRID_MENU_CLASS,
            DATAGRID_MENU_IMAGE_CLASS: DATAGRID_MENU_IMAGE_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_EDITOR_WITH_MENU_CLASS: DATAGRID_EDITOR_WITH_MENU_CLASS,
            DATAGRID_EDITOR_CONTAINER_CLASS: DATAGRID_EDITOR_CONTAINER_CLASS,
            DATAGRID_HIGHLIGHT_OUTLINE_CLASS: DATAGRID_HIGHLIGHT_OUTLINE_CLASS,
            DATAGRID_APPLY_BUTTON_CLASS: DATAGRID_APPLY_BUTTON_CLASS
        });
        dataGrid.ColumnHeadersViewFilterRowExtender = ColumnHeadersViewFilterRowExtender;
        dataGrid.DataControllerFilterRowExtender = DataControllerFilterRowExtender
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.headerPanel.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_HEADER_PANEL_CLASS = "dx-datagrid-header-panel";
        dataGrid.HeaderPanel = dataGrid.ColumnsView.inherit({
            _resizeCore: $.noop,
            _renderCore: function() {
                this.element().addClass(DATAGRID_HEADER_PANEL_CLASS)
            },
            getHeaderPanel: function() {
                return this.element()
            },
            getHeight: function() {
                var $element = this.element();
                return $element ? $element.outerHeight(true) : 0
            },
            isVisible: function() {
                return false
            }
        });
        $.extend(dataGrid.__internals, {DATAGRID_HEADER_PANEL_CLASS: DATAGRID_HEADER_PANEL_CLASS});
        dataGrid.registerModule("headerPanel", {
            defaultOptions: function() {
                return {}
            },
            views: {headerPanel: dataGrid.HeaderPanel}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.headerFilter.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            dataUtils = DX.data.utils,
            commonUtils = DX.require("/utils/utils.common");
        var DATAGRID_HEADER_FILTER_CLASS = "dx-header-filter",
            DATAGRID_HEADER_FILTER_MENU_CLASS = "dx-header-filter-menu",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATE_INTERVAL_FORMATS = {
                month: {
                    format: 'month',
                    dateType: 'full'
                },
                quarter: {
                    format: 'quarter',
                    dateType: 'full'
                },
                dayOfWeek: {
                    format: 'dayOfWeek',
                    dateType: 'full'
                }
            };
        var allowHeaderFiltering = function(column) {
                return commonUtils.isDefined(column.allowHeaderFiltering) ? column.allowHeaderFiltering : column.allowFiltering
            };
        function resetChildrenItemSelection(items) {
            items = items || [];
            for (var i = 0; i < items.length; i++) {
                items[i].selected = false;
                resetChildrenItemSelection(items[i].items)
            }
        }
        dataGrid.updateHeaderFilterItemSelectionState = function(item, filterValuesMatch, isExcludeFilter) {
            if (filterValuesMatch ^ isExcludeFilter) {
                item.selected = true;
                if (isExcludeFilter && item.items)
                    for (var j = 0; j < item.items.length; j++)
                        if (!item.items[j].selected) {
                            item.selected = undefined;
                            break
                        }
            }
            else if (isExcludeFilter) {
                item.selected = false;
                resetChildrenItemSelection(item.items)
            }
        };
        dataGrid.HeaderFilterController = dataGrid.ViewController.inherit(function() {
            var getFormatOptions = function(value, column, currentLevel) {
                    var groupInterval = dataGrid.getGroupInterval(column),
                        result = $.extend({target: "headerFilter"}, column);
                    if (groupInterval) {
                        result.groupInterval = groupInterval[currentLevel];
                        if (column.dataType === "date")
                            result.format = DATE_INTERVAL_FORMATS[groupInterval[currentLevel]];
                        else if (column.dataType === "number")
                            result.getDisplayFormat = function() {
                                var formatOptions = {
                                        format: column.format,
                                        precision: column.precision
                                    },
                                    firstValueText = dataGrid.formatValue(value, formatOptions),
                                    secondValue = value + groupInterval[currentLevel],
                                    secondValueText = dataGrid.formatValue(secondValue, formatOptions);
                                return firstValueText && secondValueText ? firstValueText + " - " + secondValueText : ""
                            }
                    }
                    return result
                };
            return {
                    init: function() {
                        this._columnsController = this.getController("columns");
                        this._dataController = this.getController("data");
                        this._headerFilterView = this.getView("headerFilterView")
                    },
                    _updateSelectedState: function(items, column, parent) {
                        var i = items.length,
                            isExclude = column.filterType === "exclude";
                        while (i--) {
                            if ("items" in items[i])
                                this._updateSelectedState(items[i].items, column, items[i]);
                            dataGrid.updateHeaderFilterItemSelectionState(items[i], dataGrid.getIndexByKey(items[i].value, column.filterValues, null) > -1, isExclude)
                        }
                    },
                    _normalizeGroupItem: function(item, currentLevel, options) {
                        var value,
                            displayValue,
                            path = options.path,
                            valueSelector = options.valueSelector,
                            displaySelector = options.displaySelector,
                            column = options.column;
                        if (valueSelector && displaySelector) {
                            value = valueSelector(item);
                            displayValue = displaySelector(item)
                        }
                        else {
                            value = item.key;
                            displayValue = value
                        }
                        item = commonUtils.isObject(item) ? item : {};
                        path.push(value);
                        if (path.length === 1)
                            item.value = path[0];
                        else
                            item.value = path.join("/");
                        item.text = dataGrid.formatValue(displayValue, getFormatOptions(displayValue, column, currentLevel));
                        if (!item.text)
                            item.text = options.headerFilterOptions.texts.emptyValue;
                        delete item.key;
                        return item
                    },
                    _processGroupItems: function(groupItems, currentLevel, path, options) {
                        var that = this,
                            displaySelector,
                            valueSelector,
                            column = options.column,
                            lookup = column.lookup,
                            level = options.level;
                        path = path || [];
                        currentLevel = currentLevel || 0;
                        if (lookup) {
                            displaySelector = DX.data.utils.compileGetter(lookup.displayExpr);
                            valueSelector = DX.data.utils.compileGetter(lookup.valueExpr)
                        }
                        for (var i = 0; i < groupItems.length; i++) {
                            groupItems[i] = that._normalizeGroupItem(groupItems[i], currentLevel, {
                                column: options.column,
                                headerFilterOptions: options.headerFilterOptions,
                                displaySelector: displaySelector,
                                valueSelector: valueSelector,
                                path: path
                            });
                            if ("items" in groupItems[i])
                                if (currentLevel === level || !commonUtils.isDefined(groupItems[i].value))
                                    delete groupItems[i].items;
                                else
                                    that._processGroupItems(groupItems[i].items, currentLevel + 1, path, options);
                            path.pop()
                        }
                    },
                    getDataSource: function(column) {
                        var that = this,
                            filter,
                            cutoffLevel,
                            origPostProcess,
                            dataSource = that._dataController.dataSource(),
                            group = dataGrid.getGroupDataSourceParameters(column, dataSource.remoteOperations().grouping),
                            headerFilterDataSource = column.headerFilter && column.headerFilter.dataSource,
                            headerFilterOptions = that.option("headerFilter"),
                            options = {component: that.component};
                        if (commonUtils.isDefined(headerFilterDataSource) && !commonUtils.isFunction(headerFilterDataSource)) {
                            dataSource = DX.data.utils.normalizeDataSourceOptions(headerFilterDataSource);
                            dataSource.postProcess = function(items) {
                                that._updateSelectedState(items, column);
                                return items
                            };
                            return dataSource
                        }
                        if (column.lookup) {
                            dataSource = DX.data.utils.normalizeDataSourceOptions(column.lookup.dataSource);
                            dataSource.postProcess = function(items) {
                                if (this.pageIndex() === 0) {
                                    items = items.slice(0);
                                    items.unshift(null)
                                }
                                that._processGroupItems(items, null, null, {
                                    level: 0,
                                    column: column,
                                    headerFilterOptions: headerFilterOptions
                                });
                                that._updateSelectedState(items, column);
                                return items
                            };
                            options.dataSource = dataSource
                        }
                        else {
                            cutoffLevel = commonUtils.isArray(group) ? group.length - 1 : 0;
                            that._currentColumn = column;
                            filter = that._dataController.getCombinedFilter();
                            that._currentColumn = null;
                            options.dataSource = {
                                filter: filter,
                                group: group,
                                load: function(options) {
                                    var d = $.Deferred();
                                    options.dataField = column.dataField || column.name;
                                    dataSource.load(options).done(function(data) {
                                        that._processGroupItems(data, null, null, {
                                            level: cutoffLevel,
                                            column: column,
                                            headerFilterOptions: headerFilterOptions
                                        });
                                        that._updateSelectedState(data, column);
                                        d.resolve(data)
                                    }).fail(d.reject);
                                    return d
                                }
                            }
                        }
                        if (commonUtils.isFunction(headerFilterDataSource)) {
                            headerFilterDataSource.call(column, options);
                            origPostProcess = options.dataSource.postProcess;
                            options.dataSource.postProcess = function(data) {
                                var items = origPostProcess && origPostProcess.apply(this, arguments) || data;
                                that._updateSelectedState(items, column);
                                return items
                            }
                        }
                        return options.dataSource
                    },
                    getCurrentColumn: function() {
                        return this._currentColumn
                    },
                    showHeaderFilterMenu: function(columnIndex) {
                        var that = this,
                            column = $.extend(true, {}, that._columnsController.getColumns()[columnIndex]);
                        if (column) {
                            var visibleIndex = that._columnsController.getVisibleIndex(columnIndex),
                                isGroupColumn = column && commonUtils.isDefined(column.groupIndex),
                                view = isGroupColumn ? that.getView("headerPanel") : that.getView("columnHeadersView"),
                                $columnElement = view.getColumnElements().eq(isGroupColumn ? column.groupIndex : visibleIndex),
                                groupInterval = dataGrid.getGroupInterval(column);
                            var options = $.extend(column, {
                                    type: groupInterval && groupInterval.length > 1 ? "tree" : "list",
                                    apply: function() {
                                        that._columnsController.columnOption(columnIndex, {
                                            filterValues: this.filterValues,
                                            filterType: this.filterType
                                        })
                                    },
                                    onShowing: function(e) {
                                        var dxResizableInstance = e.component.overlayContent().dxResizable("instance");
                                        dxResizableInstance && dxResizableInstance.option("onResizeEnd", function(e) {
                                            var columnsController = that.getController("columns"),
                                                headerFilterByColumn = columnsController.columnOption(options.dataField, "headerFilter");
                                            headerFilterByColumn = headerFilterByColumn || {};
                                            headerFilterByColumn.width = e.width;
                                            headerFilterByColumn.height = e.height;
                                            columnsController.columnOption(options.dataField, "headerFilter", headerFilterByColumn, true)
                                        })
                                    }
                                });
                            options.dataSource = that.getDataSource(options);
                            that._headerFilterView.showHeaderFilterMenu($columnElement, options)
                        }
                    },
                    hideHeaderFilterMenu: function() {
                        this._headerFilterView.hideHeaderFilterMenu()
                    }
                }
        }());
        dataGrid.HeaderFilterView = dataGrid.View.inherit({
            getPopupContainer: function() {
                return this._popupContainer
            },
            getListContainer: function() {
                return this._listContainer
            },
            applyHeaderFilter: function(options) {
                var that = this,
                    list = that.getListContainer(),
                    isSelectAll = list.element().find(".dx-checkbox").eq(0).hasClass("dx-checkbox-checked"),
                    filterValues = [];
                var fillSelectedItemKeys = function(filterValues, items, isExclude) {
                        $.each(items, function(_, item) {
                            if (item.selected !== undefined && !!item.selected ^ isExclude)
                                filterValues.push(item.value);
                            else if (item.items && item.items.length)
                                fillSelectedItemKeys(filterValues, item.items, isExclude)
                        })
                    };
                if (!isSelectAll) {
                    if (options.type === "tree") {
                        fillSelectedItemKeys(filterValues, list.option("items"), options.filterType === "exclude");
                        options.filterValues = filterValues
                    }
                }
                else if (commonUtils.isArray(options.filterValues))
                    options.filterValues = [];
                if (options.filterValues && !options.filterValues.length)
                    options.filterValues = undefined;
                options.apply();
                that.hideHeaderFilterMenu()
            },
            showHeaderFilterMenu: function($columnElement, options) {
                var that = this,
                    popupContainer;
                if (options) {
                    that._initializePopupContainer(options);
                    popupContainer = that.getPopupContainer();
                    that.hideHeaderFilterMenu();
                    that.updatePopup($columnElement, options);
                    popupContainer.show()
                }
            },
            hideHeaderFilterMenu: function() {
                var headerFilterMenu = this.getPopupContainer();
                headerFilterMenu && headerFilterMenu.hide()
            },
            updatePopup: function($element, options) {
                var that = this,
                    alignment = options.alignment === "right" ? "left" : "right";
                if (that._popupContainer) {
                    that._cleanPopupContent();
                    that._popupContainer.option("position", {
                        my: alignment + " top",
                        at: alignment + " bottom",
                        of: $element,
                        collision: "flip fit"
                    })
                }
            },
            _cleanPopupContent: function() {
                this._popupContainer && this._popupContainer.content().empty()
            },
            _initializePopupContainer: function(options) {
                var that = this,
                    $element = that.element(),
                    headerFilterOptions = that.option("headerFilter"),
                    width = options.headerFilter && options.headerFilter.width || headerFilterOptions && headerFilterOptions.width,
                    height = options.headerFilter && options.headerFilter.height || headerFilterOptions && headerFilterOptions.height,
                    dxPopupOptions = {
                        width: width,
                        height: height,
                        visible: false,
                        shading: false,
                        showTitle: false,
                        showCloseButton: false,
                        closeOnTargetScroll: true,
                        closeOnOutsideClick: true,
                        buttons: [{
                                toolbar: "bottom",
                                location: "after",
                                widget: "button",
                                options: {
                                    text: headerFilterOptions.texts.ok,
                                    onClick: function() {
                                        that.applyHeaderFilter(options)
                                    }
                                }
                            }, {
                                toolbar: "bottom",
                                location: "after",
                                widget: "button",
                                options: {
                                    text: headerFilterOptions.texts.cancel,
                                    onClick: function() {
                                        that.hideHeaderFilterMenu()
                                    }
                                }
                            }],
                        resizeEnabled: true,
                        onShowing: function(e) {
                            that._initializeListContainer(options);
                            options.onShowing && options.onShowing(e)
                        },
                        onInitialized: function(e) {
                            var component = e.component;
                            component.option("animation", component._getDefaultOptions().animation)
                        }
                    };
                if (!commonUtils.isDefined(that._popupContainer))
                    that._popupContainer = that._createComponent($element, "dxPopup", dxPopupOptions);
                else
                    that._popupContainer.option(dxPopupOptions)
            },
            _initializeListContainer: function(options) {
                var that = this,
                    $content = that._popupContainer.content(),
                    widgetOptions = {
                        dataSource: options.dataSource,
                        onContentReady: function() {
                            that.renderCompleted.fire()
                        }
                    };
                if (options.type === "tree")
                    that._listContainer = that._createComponent($("<div/>").appendTo($content), "dxTreeView", $.extend(widgetOptions, {
                        showCheckBoxesMode: 'selectAll',
                        keyExpr: "id"
                    }));
                else
                    that._listContainer = that._createComponent($("<div/>").appendTo($content), "dxList", $.extend(widgetOptions, {
                        pageLoadMode: "scrollBottom",
                        showSelectionControls: true,
                        selectionMode: "all",
                        itemTemplate: function(data, _, elem) {
                            return elem.text(data.text)
                        },
                        onSelectionChanged: function(e) {
                            var items = e.component.option("items"),
                                selectedItems = e.component.option("selectedItems");
                            if (!e.component._selectedItemsUpdating)
                                if (selectedItems.length === 0 && items.length) {
                                    options.filterType = "include";
                                    options.filterValues = []
                                }
                                else if (selectedItems.length === items.length) {
                                    options.filterType = "exclude";
                                    options.filterValues = []
                                }
                            $.each(items, function(index, item) {
                                var selected = dataGrid.getIndexByKey(item, selectedItems, null) >= 0,
                                    oldSelected = !!item.selected,
                                    filterValueIndex;
                                if (oldSelected !== selected) {
                                    item.selected = selected;
                                    options.filterValues = options.filterValues || [];
                                    filterValueIndex = dataGrid.getIndexByKey(item.value, options.filterValues, null);
                                    if (filterValueIndex >= 0)
                                        options.filterValues.splice(filterValueIndex, 1);
                                    if (selected ^ options.filterType === "exclude")
                                        options.filterValues.push(item.value)
                                }
                            })
                        },
                        onContentReady: function(e) {
                            var component = e.component,
                                items = component.option("items"),
                                selectedItems = [],
                                selectAllCheckBox = e.element.find(".dx-list-select-all-checkbox").dxCheckBox("instance");
                            $.each(items, function() {
                                if (this.selected)
                                    selectedItems.push(this)
                            });
                            component._selectedItemsUpdating = true;
                            component.option("selectedItems", selectedItems);
                            component._selectedItemsUpdating = false;
                            if (options.filterValues && options.filterValues.length)
                                selectAllCheckBox.option("value", undefined)
                        }
                    }))
            },
            _renderCore: function(options) {
                this.element().addClass(DATAGRID_HEADER_FILTER_MENU_CLASS)
            },
            init: function() {
                this._headerFilterController = this.getController("headerFilter")
            }
        });
        var headerFilterMixin = dataGrid.headerFilterMixin = {
                _applyColumnState: function(options) {
                    var $headerFilterIndicator,
                        rootElement = options.rootElement,
                        column = options.column;
                    if (options.name === "headerFilter") {
                        rootElement.find("." + DATAGRID_HEADER_FILTER_CLASS).remove();
                        if (allowHeaderFiltering(column))
                            $headerFilterIndicator = this.callBase(options).toggleClass("dx-header-filter-empty", !column.filterValues || !column.filterValues.length);
                        return $headerFilterIndicator
                    }
                    return this.callBase(options)
                },
                _renderIndicator: function(options) {
                    var rtlEnabled,
                        $container = options.container,
                        $indicator = options.indicator;
                    if (options.name === "headerFilter") {
                        rtlEnabled = this.option("rtlEnabled");
                        if ($container.children().length && (!rtlEnabled && options.columnAlignment === "right" || rtlEnabled && options.columnAlignment === "left")) {
                            $container.prepend($indicator);
                            return
                        }
                    }
                    this.callBase(options)
                },
                optionChanged: function(args) {
                    if (args.name === "headerFilter") {
                        this._invalidate();
                        args.handled = true
                    }
                    else
                        this.callBase(args)
                }
            };
        var ColumnHeadersViewHeaderFilterExtender = $.extend({}, headerFilterMixin, {
                _renderCellContent: function($cell, options) {
                    var that = this,
                        $headerFilterIndicator,
                        column = options.column;
                    that.callBase($cell, options);
                    if (!column.command && !commonUtils.isDefined(column.groupIndex) && allowHeaderFiltering(column) && that.option("headerFilter.visible") && options.rowType === "header") {
                        $headerFilterIndicator = that._applyColumnState({
                            name: "headerFilter",
                            rootElement: $cell,
                            column: column,
                            showColumnLines: that.option("showColumnLines")
                        });
                        $headerFilterIndicator && that._subscribeToIndicatorEvent($headerFilterIndicator, column, "headerFilter")
                    }
                },
                _subscribeToIndicatorEvent: function($indicator, column, indicatorName) {
                    var that = this;
                    if (indicatorName === "headerFilter")
                        $indicator.on("dxclick", that.createAction(function(e) {
                            var event = e.jQueryEvent;
                            event.stopPropagation();
                            that.getController("headerFilter").showHeaderFilterMenu(column.index)
                        }))
                },
                _updateIndicator: function($cell, column, indicatorName) {
                    var $indicator = this.callBase($cell, column, indicatorName);
                    $indicator && this._subscribeToIndicatorEvent($indicator, column, indicatorName)
                },
                _columnOptionChanged: function(e) {
                    var optionNames = e.optionNames;
                    if (dataGrid.checkChanges(optionNames, ["filterValues", "filterType"])) {
                        if (this.option("headerFilter.visible"))
                            this._updateIndicators("headerFilter");
                        return
                    }
                    this.callBase(e)
                }
            });
        var HeaderPanelHeaderFilterExtender = $.extend({}, headerFilterMixin, {_createGroupPanelItem: function($rootElement, groupColumn) {
                    var that = this,
                        $item = that.callBase.apply(that, arguments),
                        $headerFilterIndicator;
                    if (!groupColumn.command && allowHeaderFiltering(groupColumn) && that.option("headerFilter.visible")) {
                        $headerFilterIndicator = that._applyColumnState({
                            name: "headerFilter",
                            rootElement: $item,
                            column: {
                                alignment: commonUtils.getDefaultAlignment(that.option("rtlEnabled")),
                                filterValues: groupColumn.filterValues,
                                allowHeaderFiltering: true
                            },
                            showColumnLines: true
                        });
                        $headerFilterIndicator && $headerFilterIndicator.on("dxclick", that.createAction(function(e) {
                            var event = e.jQueryEvent;
                            event.stopPropagation();
                            that.getController("headerFilter").showHeaderFilterMenu(groupColumn.index)
                        }))
                    }
                    return $item
                }});
        var INVERTED_BINARY_OPERATIONS = {
                "=": "<>",
                "<>": "=",
                ">": "<=",
                ">=": "<",
                "<": ">=",
                "<=": ">",
                contains: "notcontains",
                notcontains: "contains",
                startswith: "notcontains",
                endswith: "notcontains"
            };
        function invertFilterExpression(filter) {
            var i,
                currentGroupOperation,
                result;
            if ($.isArray(filter[0])) {
                result = [];
                for (i = 0; i < filter.length; i++)
                    if ($.isArray(filter[i])) {
                        if (currentGroupOperation)
                            result.push(currentGroupOperation);
                        result.push(invertFilterExpression(filter[i]));
                        currentGroupOperation = "or"
                    }
                    else
                        currentGroupOperation = dataUtils.isConjunctiveOperator(filter[i]) ? "or" : "and";
                return result
            }
            result = dataUtils.normalizeBinaryCriterion(filter);
            result[1] = INVERTED_BINARY_OPERATIONS[result[1]] || result[1];
            return result
        }
        dataGrid.invertFilterExpression = invertFilterExpression;
        var DataControllerFilterRowExtender = {_calculateAdditionalFilter: function() {
                    var that = this,
                        filters = [that.callBase()],
                        columns = that._columnsController.getVisibleColumns(),
                        headerFilterController = that.getController("headerFilter"),
                        currentColumn = headerFilterController.getCurrentColumn();
                    $.each(columns, function(_, column) {
                        var filter;
                        if (currentColumn && currentColumn.index === column.index)
                            return;
                        if (allowHeaderFiltering(column) && column.calculateFilterExpression && commonUtils.isArray(column.filterValues) && column.filterValues.length) {
                            var filterValues = [],
                                isExclude = column.filterType === "exclude";
                            $.each(column.filterValues, function(_, filterValue) {
                                if (commonUtils.isArray(filterValue))
                                    filter = isExclude ? invertFilterExpression(filterValue) : filterValue;
                                else {
                                    if (column.deserializeValue && column.dataType !== "date" && column.dataType !== "number")
                                        filterValue = column.deserializeValue(filterValue);
                                    filter = column.createFilterExpression(filterValue, isExclude ? "<>" : "=", "headerFilter")
                                }
                                if (filter)
                                    filter.columnIndex = column.index;
                                filterValues.push(filter)
                            });
                            filterValues = dataGrid.combineFilters(filterValues, isExclude ? "and" : "or");
                            filters.push(filterValues)
                        }
                    });
                    return dataGrid.combineFilters(filters)
                }};
        dataGrid.registerModule("headerFilter", {
            defaultOptions: function() {
                return {headerFilter: {
                            visible: false,
                            width: 252,
                            height: 300,
                            texts: {
                                emptyValue: Globalize.localize("dxDataGrid-headerFilterEmptyValue"),
                                ok: Globalize.localize("dxDataGrid-headerFilterOK"),
                                cancel: Globalize.localize("dxDataGrid-headerFilterCancel")
                            }
                        }}
            },
            controllers: {headerFilter: dataGrid.HeaderFilterController},
            views: {headerFilterView: dataGrid.HeaderFilterView},
            extenders: {
                controllers: {data: DataControllerFilterRowExtender},
                views: {
                    columnHeadersView: ColumnHeadersViewHeaderFilterExtender,
                    headerPanel: HeaderPanelHeaderFilterExtender
                }
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_HEADER_FILTER_CLASS: DATAGRID_HEADER_FILTER_CLASS,
            DATAGRID_HEADER_FILTER_MENU_CLASS: DATAGRID_HEADER_FILTER_MENU_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.sortingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            eventUtils = DX.require("/ui/events/ui.events.utils");
        var DATAGRID_SORT_CLASS = "dx-sort",
            DATAGRID_SORTUP_CLASS = "dx-sort-up",
            DATAGRID_SORTDOWN_CLASS = "dx-sort-down",
            DATAGRID_HEADERS_ACTION_CLASS = "dx-datagrid-action",
            DATAGRID_COLUMN_INDICATORS_CLASS = "dx-column-indicators",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            COLUMN_HEADERS_VIEW_NAMESPACE = "dxDataGridColumnHeadersView";
        var sortingMixin = dataGrid.sortingMixin = {
                _applyColumnState: function(options) {
                    var that = this,
                        side,
                        sortingMode = that.option("sorting.mode"),
                        rootElement = options.rootElement,
                        column = options.column,
                        $indicatorsContainer = rootElement.find("." + DATAGRID_COLUMN_INDICATORS_CLASS);
                    if (options.name === "sort") {
                        side = that.option("rtlEnabled") ? "right" : "left";
                        if ((sortingMode === "single" || sortingMode === "multiple") && column.allowSorting)
                            options.rootElement.addClass(DATAGRID_HEADERS_ACTION_CLASS);
                        rootElement.find("." + DATAGRID_SORT_CLASS).remove();
                        !$indicatorsContainer.children().length && $indicatorsContainer.remove();
                        rootElement.children("." + DATAGRID_CELL_CONTENT_CLASS).css("margin-" + side, "");
                        if (commonUtils.isDefined(column.sortOrder)) {
                            var ariaSortState = column.sortOrder === "asc" ? "ascending" : "descending";
                            that.setAria("sort", ariaSortState, rootElement);
                            var $sortIndicator = that.callBase(options).toggleClass(DATAGRID_SORTUP_CLASS, column.sortOrder === "asc").toggleClass(DATAGRID_SORTDOWN_CLASS, column.sortOrder === "desc");
                            if (column.alignment === "center")
                                rootElement.children("." + DATAGRID_CELL_CONTENT_CLASS).css("margin-" + side, $sortIndicator.outerWidth(true));
                            return $sortIndicator
                        }
                        else
                            that.setAria("sort", "none", rootElement)
                    }
                    else
                        return that.callBase(options)
                },
                _renderIndicator: function(options) {
                    var rtlEnabled,
                        $container = options.container,
                        $indicator = options.indicator;
                    if (options.name === "sort") {
                        rtlEnabled = this.option("rtlEnabled");
                        if ($container.children().length && (!rtlEnabled && options.columnAlignment === "left" || rtlEnabled && options.columnAlignment === "right")) {
                            $container.prepend($indicator);
                            return
                        }
                    }
                    this.callBase(options)
                },
                _updateIndicator: function($cell, column, indicatorName) {
                    if (indicatorName === "sort" && commonUtils.isDefined(column.groupIndex))
                        return;
                    this.callBase.apply(this, arguments)
                }
            };
        var ColumnHeadersViewSortingExtender = $.extend({}, sortingMixin, {
                _createRow: function(row) {
                    var that = this,
                        $row = that.callBase(row);
                    if (row.rowType === "header")
                        $row.on(eventUtils.addNamespace("dxclick", COLUMN_HEADERS_VIEW_NAMESPACE), "> td", that.createAction(function(e) {
                            var keyName = null,
                                event = e.jQueryEvent,
                                $cellElement = $(event.currentTarget),
                                columnIndex = $cellElement.index(),
                                visibleColumns = that._columnsController.getVisibleColumns(),
                                column = visibleColumns[columnIndex];
                            if (column && !commonUtils.isDefined(column.groupIndex) && !column.command) {
                                if (event.shiftKey)
                                    keyName = "shift";
                                else if (event.ctrlKey)
                                    keyName = "ctrl";
                                setTimeout(function() {
                                    that._columnsController.changeSortOrder(column.index, keyName)
                                })
                            }
                        }));
                    return $row
                },
                _renderCellContent: function($cell, options) {
                    var that = this,
                        column = options.column;
                    that.callBase($cell, options);
                    if (!column.command && options.rowType === "header")
                        that._applyColumnState({
                            name: "sort",
                            rootElement: $cell,
                            column: column,
                            showColumnLines: that.option("showColumnLines")
                        })
                },
                _columnOptionChanged: function(e) {
                    var changeTypes = e.changeTypes;
                    if (changeTypes.length === 1 && changeTypes.sorting) {
                        this._updateIndicators("sort");
                        return
                    }
                    this.callBase(e)
                },
                optionChanged: function(args) {
                    var that = this;
                    switch (args.name) {
                        case"sorting":
                            that._invalidate();
                            args.handled = true;
                            break;
                        default:
                            that.callBase(args)
                    }
                }
            });
        var HeaderPanelSortingExtender = $.extend({}, sortingMixin, {
                _createGroupPanelItem: function($rootElement, groupColumn) {
                    var that = this,
                        $item = that.callBase.apply(that, arguments);
                    $item.on(eventUtils.addNamespace("dxclick", "dxDataGridHeaderPanel"), that.createAction(function(e) {
                        setTimeout(function() {
                            that.getController("columns").changeSortOrder(groupColumn.index)
                        })
                    }));
                    that._applyColumnState({
                        name: "sort",
                        rootElement: $item,
                        column: {
                            alignment: that.option("rtlEnabled") ? "right" : "left",
                            allowSorting: groupColumn.allowSorting,
                            sortOrder: groupColumn.sortOrder === "desc" ? "desc" : "asc"
                        },
                        showColumnLines: true
                    });
                    return $item
                },
                optionChanged: function(args) {
                    var that = this;
                    switch (args.name) {
                        case"sorting":
                            that._invalidate();
                            args.handled = true;
                            break;
                        default:
                            that.callBase(args)
                    }
                }
            });
        dataGrid.registerModule("sorting", {
            defaultOptions: function() {
                return {sorting: {
                            mode: "single",
                            ascendingText: Globalize.localize("dxDataGrid-sortingAscendingText"),
                            descendingText: Globalize.localize("dxDataGrid-sortingDescendingText"),
                            clearText: Globalize.localize("dxDataGrid-sortingClearText")
                        }}
            },
            extenders: {views: {
                    columnHeadersView: ColumnHeadersViewSortingExtender,
                    headerPanel: HeaderPanelSortingExtender
                }}
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_SORT_CLASS: DATAGRID_SORT_CLASS,
            DATAGRID_SORTUP_CLASS: DATAGRID_SORTUP_CLASS,
            DATAGRID_SORTDOWN_CLASS: DATAGRID_SORTDOWN_CLASS,
            DATAGRID_HEADERS_ACTION_CLASS: DATAGRID_HEADERS_ACTION_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.search.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            selectors = DX.require("/integration/jquery/jquery.selectors");
        var DATAGRID_SEARCH_PANEL_CLASS = "dx-datagrid-search-panel",
            DATAGRID_SEARCH_TEXT_CLASS = "dx-datagrid-search-text",
            FILTERING_TIMEOUT = 700;
        function allowSearch(column) {
            return commonUtils.isDefined(column.allowSearch) ? column.allowSearch : column.allowFiltering
        }
        function parseValue(column, text) {
            var lookup = column.lookup;
            if (lookup)
                return column.parseValue.call(lookup, text);
            else
                return column.parseValue ? column.parseValue(text) : text
        }
        dataGrid.registerModule("search", {
            defaultOptions: function() {
                return {searchPanel: {
                            visible: false,
                            width: 160,
                            placeholder: Globalize.localize("dxDataGrid-searchPanelPlaceholder"),
                            highlightSearchText: true,
                            text: ""
                        }}
            },
            extenders: {
                controllers: {data: function() {
                        var calculateSearchFilter = function(that, text) {
                                var i,
                                    column,
                                    columns = that._columnsController.getColumns(),
                                    filterValue,
                                    lookup,
                                    filters = [];
                                if (!text)
                                    return null;
                                function onQueryDone(items) {
                                    var i,
                                        valueGetter = DX.data.utils.compileGetter(lookup.valueExpr),
                                        value;
                                    for (i = 0; i < items.length; i++) {
                                        value = valueGetter(items[i]);
                                        filters.push(column.createFilterExpression(value, null, "search"))
                                    }
                                }
                                for (i = 0; i < columns.length; i++) {
                                    column = columns[i];
                                    if (allowSearch(column) && column.calculateFilterExpression) {
                                        lookup = column.lookup;
                                        filterValue = parseValue(column, text);
                                        if (lookup && lookup.items)
                                            DX.data.query(lookup.items).filter(column.createFilterExpression.call({
                                                dataField: lookup.displayExpr,
                                                dataType: lookup.dataType,
                                                calculateFilterExpression: column.calculateFilterExpression
                                            }, filterValue, null, "search")).enumerate().done(onQueryDone);
                                        else if (filterValue !== undefined)
                                            filters.push(column.createFilterExpression(filterValue, null, "search"))
                                    }
                                }
                                return dataGrid.combineFilters(filters, "or")
                            };
                        return {
                                publicMethods: function() {
                                    return this.callBase().concat(["searchByText"])
                                },
                                _calculateAdditionalFilter: function() {
                                    var that = this,
                                        filter = that.callBase(),
                                        searchFilter = calculateSearchFilter(that, that.option("searchPanel.text"));
                                    return dataGrid.combineFilters([filter, searchFilter])
                                },
                                searchByText: function(text) {
                                    this.option("searchPanel.text", text)
                                },
                                optionChanged: function(args) {
                                    var that = this;
                                    switch (args.fullName) {
                                        case"searchPanel.text":
                                        case"searchPanel":
                                            that._applyFilter();
                                            args.handled = true;
                                            break;
                                        default:
                                            that.callBase(args)
                                    }
                                }
                            }
                    }()},
                views: {
                    headerPanel: function() {
                        var getSearchPanelOptions = function(that) {
                                return that.option("searchPanel")
                            };
                        return {
                                _renderSearchPanel: function() {
                                    var that = this,
                                        $element = that.element(),
                                        dataController = that.getController("data"),
                                        searchPanelOptions = getSearchPanelOptions(that);
                                    if (searchPanelOptions && searchPanelOptions.visible) {
                                        if (!that._$searchPanel) {
                                            that._$searchPanel = $("<div/>").addClass(DATAGRID_SEARCH_PANEL_CLASS).prependTo($element);
                                            that.setAria("label", Globalize.localize("dxDataGrid-ariaSearchInGrid"), that._$searchPanel)
                                        }
                                        else
                                            that._$searchPanel.show();
                                        that.getController("editorFactory").createEditor(that._$searchPanel, {
                                            width: searchPanelOptions.width,
                                            placeholder: searchPanelOptions.placeholder,
                                            parentType: "searchPanel",
                                            value: that.option("searchPanel.text"),
                                            updateValueTimeout: FILTERING_TIMEOUT,
                                            setValue: function(value) {
                                                dataController.searchByText(value)
                                            }
                                        });
                                        that.resize()
                                    }
                                    else
                                        that._$searchPanel && that._$searchPanel.hide()
                                },
                                _renderCore: function() {
                                    this.callBase();
                                    this._renderSearchPanel()
                                },
                                focus: function() {
                                    var textBox = this._$searchPanel.dxTextBox("instance");
                                    if (textBox)
                                        textBox.focus()
                                },
                                isVisible: function() {
                                    var searchPanelOptions = getSearchPanelOptions(this);
                                    return this.callBase() || searchPanelOptions && searchPanelOptions.visible
                                },
                                optionChanged: function(args) {
                                    if (args.name === "searchPanel") {
                                        this._renderSearchPanel();
                                        args.handled = true
                                    }
                                    else
                                        this.callBase(args)
                                }
                            }
                    }(),
                    rowsView: {
                        _highlightSearchText: function(cellElement, isEquals, column) {
                            var that = this,
                                $parent,
                                searchHTML,
                                searchText = that.option("searchPanel.text");
                            if (searchText && that.option("searchPanel.highlightSearchText")) {
                                if (isEquals && column) {
                                    var value = parseValue(column, searchText);
                                    searchText = dataGrid.formatValue(value, column);
                                    if (!searchText)
                                        return
                                }
                                searchHTML = $("<div>").text(searchText).html();
                                $parent = cellElement.parent();
                                if (!$parent.length)
                                    $parent = $("<div>").append(cellElement);
                                $.each($parent.find(selectors.icontains + "('" + searchText + "')"), function(index, element) {
                                    $.each($(element).contents(), function(index, content) {
                                        if (content.nodeType !== 3)
                                            return;
                                        var highlightSearchTextInTextNode = function($content, searchText) {
                                                var $searchTextSpan = $("<span />").addClass(DATAGRID_SEARCH_TEXT_CLASS),
                                                    text = $content.text(),
                                                    index = text.toLowerCase().indexOf(searchText.toLowerCase());
                                                if (index >= 0) {
                                                    if ($content[0].textContent)
                                                        $content[0].textContent = text.substr(0, index);
                                                    else
                                                        $content[0].nodeValue = text.substr(0, index);
                                                    $content.after($searchTextSpan.text(text.substr(index, searchText.length)));
                                                    $content = $(document.createTextNode(text.substr(index + searchText.length))).insertAfter($searchTextSpan);
                                                    return highlightSearchTextInTextNode($content, searchText)
                                                }
                                            };
                                        if (isEquals) {
                                            if ($(content).text().toLowerCase() === searchText.toLowerCase())
                                                $(this).replaceWith($("<span />").addClass(DATAGRID_SEARCH_TEXT_CLASS).text($(content).text()))
                                        }
                                        else
                                            highlightSearchTextInTextNode($(content), searchText)
                                    })
                                })
                            }
                        },
                        _renderCore: function($table, options) {
                            this.callBase.apply(this, arguments);
                            if (this.option("rowTemplate"))
                                this._highlightSearchText(this._getTableElement())
                        },
                        _updateCell: function($cell, parameters) {
                            var that = this,
                                column = parameters.column,
                                isEquals = column.dataType !== "string";
                            if (allowSearch(column))
                                that._highlightSearchText($cell, isEquals, column);
                            that.callBase($cell, parameters)
                        }
                    }
                }
            }
        });
        dataGrid.__internals = $.extend({}, dataGrid.__internals, {
            DATAGRID_SEARCH_PANEL_CLASS: DATAGRID_SEARCH_PANEL_CLASS,
            DATAGRID_SEARCH_TEXT_CLASS: DATAGRID_SEARCH_TEXT_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.rowsView.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            support = DX.require("/utils/utils.support"),
            removeEvent = DX.require("/ui/events/ui.events.remove"),
            stringUtils = DX.require("/utils/utils.string"),
            isDefined = commonUtils.isDefined,
            ko = window.ko;
        var DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
            DATAGRID_GROUP_CELL_CLASS = "dx-group-cell",
            DATAGRID_ROWS_VIEW_CLASS = "dx-datagrid-rowsview",
            DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_DATA_ROW_CLASS = "dx-data-row",
            DATAGRID_FREESPACE_CLASS = "dx-freespace-row",
            DATAGRID_NODATA_TEXT_CLASS = "dx-datagrid-nodata",
            DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_NOWRAP_CLASS = "dx-datagrid-nowrap",
            DATAGRID_ROW_LINES_CLASS = "dx-row-lines",
            DATAGRID_COLUMN_LINES_CLASS = "dx-column-lines",
            DATAGRID_ROW_ALTERNATION_CLASS = "dx-row-alt",
            DATAGRID_LAST_ROW_BORDER = "dx-last-row-border",
            DATAGRID_LOADPANEL_HIDE_TIMEOUT = 200;
        var createScrollableOptions = function(that) {
                var scrollingOptions = that.option("scrolling"),
                    useNativeScrolling = that.option("scrolling.useNative");
                var options = $.extend({}, scrollingOptions, {
                        direction: "both",
                        bounceEnabled: false,
                        useKeyboard: false
                    });
                if (useNativeScrolling === undefined)
                    useNativeScrolling = true;
                if (useNativeScrolling === "auto") {
                    delete options.useNative;
                    delete options.useSimulatedScrollbar
                }
                else {
                    options.useNative = !!useNativeScrolling;
                    options.useSimulatedScrollbar = !useNativeScrolling
                }
                return options
            },
            appendFreeSpaceRowTemplate = {render: function(element, container) {
                    var $tbody = container.find("tbody");
                    if ($tbody.length)
                        $tbody.last().append(element);
                    else
                        container.append(element)
                }};
        dataGrid.createScrollableOptions = createScrollableOptions;
        dataGrid.RowsView = dataGrid.ColumnsView.inherit({
            _getDefaultTemplate: function(column) {
                switch (column.command) {
                    case"empty":
                        return function(container) {
                                container.html("&nbsp;")
                            };
                    default:
                        return function($container, options) {
                                var isDataTextEmpty = stringUtils.isEmpty(options.text) && options.rowType === "data",
                                    text = isDataTextEmpty ? "&nbsp;" : options.text,
                                    container = $container.get(0);
                                if (column.encodeHtml && !isDataTextEmpty)
                                    if ("textContent" in container)
                                        container.textContent = text;
                                    else
                                        container.innerText = text;
                                else
                                    container.innerHTML = text
                            }
                }
            },
            _getDefaultGroupTemplate: function() {
                var that = this,
                    summaryTexts = that.option("summary.texts");
                return function(container, options) {
                        var data = options.data,
                            text = options.column.caption + ": " + options.text;
                        if (options.summaryItems && options.summaryItems.length)
                            text += " " + dataGrid.getGroupRowSummaryText(options.summaryItems, summaryTexts);
                        if (data)
                            if (options.groupContinuedMessage && options.groupContinuesMessage)
                                text += " (" + options.groupContinuedMessage + ". " + options.groupContinuesMessage + ")";
                            else if (options.groupContinuesMessage)
                                text += " (" + options.groupContinuesMessage + ")";
                            else if (options.groupContinuedMessage)
                                text += " (" + options.groupContinuedMessage + ")";
                        container.addClass(DATAGRID_GROUP_CELL_CLASS);
                        container.text(text)
                    }
            },
            _update: function(change){},
            _getColumnTemplate: function(options) {
                var that = this,
                    column = options.column,
                    template;
                if (options.rowType === "group" && isDefined(column.groupIndex) && !column.showWhenGrouped)
                    template = column.groupCellTemplate || {
                        allowRenderToDetachedContainer: true,
                        render: that._getDefaultGroupTemplate()
                    };
                else
                    template = column.cellTemplate || {
                        allowRenderToDetachedContainer: true,
                        render: that._getDefaultTemplate(column)
                    };
                return template
            },
            _getCellTemplate: function(options) {
                return this._getColumnTemplate(options)
            },
            _createRow: function(row) {
                var $row = this.callBase(row),
                    isGroup,
                    isDataRow,
                    isRowExpanded;
                if (row) {
                    isGroup = row.rowType === "group";
                    isDataRow = row.rowType === "data";
                    isDataRow && $row.addClass(DATAGRID_DATA_ROW_CLASS);
                    isDataRow && row.dataIndex % 2 === 1 && this.option("rowAlternationEnabled") && $row.addClass(DATAGRID_ROW_ALTERNATION_CLASS);
                    isDataRow && this.option("showRowLines") && $row.addClass(DATAGRID_ROW_LINES_CLASS);
                    this.option("showColumnLines") && $row.addClass(DATAGRID_COLUMN_LINES_CLASS);
                    if (isGroup) {
                        $row.addClass(DATAGRID_GROUP_ROW_CLASS);
                        isRowExpanded = row.isExpanded;
                        this.setAria("role", "rowgroup", $row);
                        this.setAria("expanded", isDefined(isRowExpanded) && isRowExpanded.toString(), $row)
                    }
                }
                return $row
            },
            _afterRowPrepared: function(e) {
                var arg = e.args[0],
                    context = e.context,
                    dataController = this._dataController,
                    values;
                if (!arg.data || arg.rowType !== "data" || arg.inserted || !this.option("twoWayBindingEnabled"))
                    return;
                if (context.$watch) {
                    var watcher = context.$watch(function() {
                            return dataController.generateDataValues(arg.data, arg.columns)
                        }, function(oldValue, newValue) {
                            if (oldValue !== newValue) {
                                watcher();
                                dataController.updateItems({
                                    changeType: "update",
                                    rowIndices: [arg.rowIndex]
                                })
                            }
                        }, true);
                    arg.rowElement.on(removeEvent.name, function() {
                        watcher()
                    })
                }
                else if (support.hasKo)
                    ko.computed(function() {
                        if (values)
                            dataController.updateItems({
                                changeType: "update",
                                rowIndices: [arg.rowIndex]
                            });
                        values = dataController.generateDataValues(arg.data, arg.columns)
                    }, null, {disposeWhenNodeIsRemoved: arg.rowElement.get(0)})
            },
            _renderScrollable: function($table) {
                var that = this,
                    $element = that.element();
                if (!$element.children().length)
                    $element.append("<div />");
                that._renderLoadPanel($element, $element.parent());
                that._renderScrollableCore($element)
            },
            _handleScroll: function(e) {
                var that = this;
                that._scrollTop = e.scrollOffset.top;
                that._scrollLeft = e.scrollOffset.left;
                that.scrollChanged.fire(e.scrollOffset, that.name)
            },
            _renderScrollableCore: function($element) {
                var that = this,
                    dxScrollableOptions = createScrollableOptions(that),
                    scrollHandler = $.proxy(that._handleScroll, that);
                dxScrollableOptions.onScroll = scrollHandler;
                dxScrollableOptions.onStop = scrollHandler;
                that._scrollable = that._createComponent($element, "dxScrollable", dxScrollableOptions);
                that._scrollableContainer = that._scrollable && that._scrollable._$container
            },
            _renderLoadPanel: function($element, $container) {
                var that = this,
                    loadPanelOptions;
                that._loadPanel && that._loadPanel.element().remove();
                loadPanelOptions = that.option("loadPanel");
                if (loadPanelOptions && loadPanelOptions.enabled) {
                    loadPanelOptions = $.extend({
                        shading: false,
                        message: loadPanelOptions.text,
                        position: {of: $element},
                        container: $container
                    }, loadPanelOptions);
                    that._loadPanel = that._createComponent($("<div>").appendTo($container), "dxLoadPanel", loadPanelOptions)
                }
                else
                    that._loadPanel = null
            },
            _renderContent: function(contentElement, tableElement) {
                contentElement.replaceWith($("<div>").addClass(DATAGRID_CONTENT_CLASS).append(tableElement));
                return this._findContentElement()
            },
            _updateContent: function(newTableElement, change) {
                var that = this,
                    tableElement = that._getTableElement(),
                    contentElement = that._findContentElement(),
                    changeType = change && change.changeType,
                    executors = [];
                switch (changeType) {
                    case"update":
                        $.each(change.rowIndices, function(index, rowIndex) {
                            var $newRowElement = that._getRowElements(newTableElement).eq(index),
                                changeType = change.changeTypes[index],
                                item = change.items && change.items[index];
                            if (!item)
                                return;
                            executors.push(function() {
                                var $rowsElement = that._getRowElements(),
                                    $rowElement = $rowsElement.eq(rowIndex);
                                switch (changeType) {
                                    case"update":
                                        if (isDefined(item.visible) && item.visible !== $rowElement.is(":visible"))
                                            $rowElement.toggle(item.visible);
                                        else
                                            $rowElement.replaceWith($newRowElement);
                                        break;
                                    case"insert":
                                        if (!$rowsElement.length)
                                            $newRowElement.prependTo(tableElement);
                                        else if ($rowElement.length)
                                            $newRowElement.insertBefore($rowElement);
                                        else
                                            $newRowElement.insertAfter($rowsElement.last());
                                        break;
                                    case"remove":
                                        $rowElement.remove();
                                        break
                                }
                            })
                        });
                        $.each(executors, function() {
                            this()
                        });
                        newTableElement.remove();
                        break;
                    default:
                        that._setTableElement(newTableElement);
                        contentElement.addClass(DATAGRID_CONTENT_CLASS);
                        that._renderContent(contentElement, newTableElement);
                        break
                }
            },
            _renderFreeSpaceRow: function(tableElement) {
                var that = this,
                    i,
                    freeSpaceRowElement = that._createRow(),
                    columns = this.getColumns();
                freeSpaceRowElement.addClass(DATAGRID_FREESPACE_CLASS).toggleClass(DATAGRID_COLUMN_LINES_CLASS, that.option("showColumnLines"));
                for (i = 0; i < columns.length; i++)
                    freeSpaceRowElement.append(that._createCell(columns[i]));
                that._appendRow(tableElement, freeSpaceRowElement, appendFreeSpaceRowTemplate)
            },
            _needUpdateRowHeight: function(itemsCount) {
                return itemsCount > 0 && !this._rowHeight
            },
            _updateRowHeight: function() {
                var that = this,
                    tableElement = that._getTableElement(),
                    tableHeight,
                    freeSpaceRowHeight,
                    itemsCount = that._dataController.items().length,
                    $freeSpaceRowElement;
                if (tableElement && that._needUpdateRowHeight(itemsCount)) {
                    tableHeight = tableElement.outerHeight();
                    $freeSpaceRowElement = that._getFreeSpaceRowElements().first();
                    if ($freeSpaceRowElement && $freeSpaceRowElement.is(":visible")) {
                        freeSpaceRowHeight = parseFloat($freeSpaceRowElement[0].style.height) || 0;
                        tableHeight -= freeSpaceRowHeight
                    }
                    that._rowHeight = tableHeight / itemsCount
                }
            },
            _findContentElement: function() {
                var $element = this.element(),
                    $scrollableContent;
                if ($element) {
                    $scrollableContent = $element.find(".dx-scrollable-content");
                    if (!$scrollableContent)
                        $scrollableContent = $element;
                    return $scrollableContent.children().first()
                }
            },
            _getRowElements: function(tableElement) {
                var $rows = this.callBase(tableElement);
                return $rows && $rows.not("." + DATAGRID_FREESPACE_CLASS)
            },
            _getFreeSpaceRowElements: function($table) {
                var tableElements = $table || this.getTableElements();
                return tableElements && tableElements.children("tbody").children("." + DATAGRID_FREESPACE_CLASS)
            },
            _getNoDataText: function() {
                return this.option("noDataText")
            },
            _updateNoDataText: function($element) {
                $element = $element || this.element();
                var noDataElement = $element.find("." + DATAGRID_NODATA_TEXT_CLASS),
                    isVisible = this._dataController.isEmpty(),
                    isLoading = this._dataController.isLoading(),
                    rtlEnabled = this.option("rtlEnabled");
                if (!noDataElement.length)
                    noDataElement = $("<span>").addClass(DATAGRID_NODATA_TEXT_CLASS).appendTo($element);
                if (isVisible && !isLoading)
                    noDataElement.text(this._getNoDataText()).css({
                        marginTop: -Math.floor(noDataElement.height() / 2),
                        marginRight: rtlEnabled ? -Math.floor(noDataElement.width() / 2) : 0,
                        marginLeft: rtlEnabled ? 0 : -Math.floor(noDataElement.width() / 2)
                    }).removeClass("dx-hidden");
                else
                    noDataElement.addClass("dx-hidden")
            },
            _rowClick: function(e) {
                var item = this._dataController.items()[e.rowIndex] || {};
                this.executeAction("onRowClick", $.extend({evaluate: function(expr) {
                        var getter = DX.data.utils.compileGetter(expr);
                        return getter(item.data)
                    }}, e, item))
            },
            _getGroupCellOptions: function(options) {
                var columnIndex = (options.row.groupIndex || 0) + options.columnsCountBeforeGroups;
                return {
                        columnIndex: columnIndex,
                        colspan: options.columns.length - columnIndex - 1
                    }
            },
            _renderCells: function($row, options) {
                if (options.row.rowType === "group")
                    this._renderGroupedCells($row, options);
                else if (options.row.values)
                    this.callBase($row, options)
            },
            _renderGroupedCells: function($row, options) {
                var $groupCell,
                    row = options.row,
                    i,
                    columns = options.columns,
                    rowIndex = row.rowIndex,
                    isExpanded,
                    groupColumn,
                    groupColumnAlignment,
                    groupCellOptions = this._getGroupCellOptions(options);
                for (i = 0; i <= groupCellOptions.columnIndex; i++) {
                    if (i === groupCellOptions.columnIndex && columns[i].allowCollapsing && options.scrollingMode !== "infinite")
                        isExpanded = !!row.isExpanded;
                    else
                        isExpanded = null;
                    this._renderCell($row, {
                        value: isExpanded,
                        row: row,
                        rowIndex: rowIndex,
                        column: {
                            command: "expand",
                            cssClass: columns[i].cssClass
                        },
                        columnIndex: i
                    })
                }
                groupColumnAlignment = commonUtils.getDefaultAlignment(this.option("rtlEnabled"));
                groupColumn = $.extend({}, columns[groupCellOptions.columnIndex], {
                    command: null,
                    cssClass: null,
                    showWhenGrouped: false,
                    alignment: groupColumnAlignment
                });
                $groupCell = this._renderCell($row, {
                    value: row.values[row.groupIndex],
                    row: row,
                    rowIndex: rowIndex,
                    column: groupColumn,
                    columnIndex: groupCellOptions.columnIndex
                });
                $groupCell.attr("colspan", groupCellOptions.colspan)
            },
            _renderRows: function($table, options) {
                var that = this,
                    i,
                    columns = options.columns,
                    columnsCountBeforeGroups = 0,
                    scrollingMode = that.option("scrolling.mode");
                for (i = 0; i < columns.length; i++)
                    if (columns[i].command === "expand") {
                        columnsCountBeforeGroups = i;
                        break
                    }
                that.callBase($table, $.extend({
                    scrollingMode: scrollingMode,
                    columnsCountBeforeGroups: columnsCountBeforeGroups
                }, options));
                that._renderFreeSpaceRow($table);
                if (!that._hasHeight)
                    that.updateFreeSpaceRowHeight($table)
            },
            _renderRow: function($table, options) {
                var that = this,
                    row = options.row,
                    rowTemplate = that.option("rowTemplate");
                if ((row.rowType === "data" || row.rowType === "group") && !isDefined(row.groupIndex) && rowTemplate)
                    that._renderTemplate($table, rowTemplate, $.extend({columns: options.columns}, row));
                else
                    that.callBase($table, options)
            },
            _renderTable: function(options) {
                var $table = this.callBase(options);
                if (!isDefined(this._getTableElement())) {
                    this._setTableElement($table);
                    this._renderScrollable($table)
                }
                return $table
            },
            _renderCore: function(change) {
                var that = this,
                    $table,
                    $element = that.element();
                $element.addClass(DATAGRID_ROWS_VIEW_CLASS).toggleClass(DATAGRID_NOWRAP_CLASS, !that.option("wordWrapEnabled"));
                $table = that._renderTable({change: change});
                that._updateContent($table, change);
                that.callBase(change);
                that._lastColumnWidths = null
            },
            _getRows: function(change) {
                return change && change.items || this._dataController.items()
            },
            _getCellOptions: function(options) {
                var that = this,
                    parameters,
                    column = options.column,
                    row = options.row,
                    data = row.data,
                    summaryCells = row && row.summaryCells,
                    value = options.value,
                    displayValue = dataGrid.getDisplayValue(column, value, data, row.rowType),
                    groupingOptions = that.option("grouping"),
                    scrollingMode = that.option("scrolling.mode");
                parameters = $.extend(this.callBase(options), {
                    value: value,
                    displayValue: displayValue,
                    row: row,
                    key: row.key,
                    data: data,
                    rowType: row.rowType,
                    values: row.values,
                    text: !isDefined(column.command) ? dataGrid.formatValue(displayValue, column) : "",
                    rowIndex: row.rowIndex,
                    summaryItems: summaryCells && summaryCells[options.columnIndex],
                    resized: column.resizedCallbacks
                });
                if (isDefined(column.groupIndex) && scrollingMode !== "virtual" && scrollingMode !== "infinite") {
                    parameters.groupContinuesMessage = data && data.isContinuationOnNextPage && groupingOptions && groupingOptions.groupContinuesMessage;
                    parameters.groupContinuedMessage = data && data.isContinuation && groupingOptions && groupingOptions.groupContinuedMessage
                }
                return parameters
            },
            getCellOptions: function(rowIndex, columnIdentificator) {
                var rowOptions = this._dataController.items()[rowIndex],
                    cellOptions,
                    column;
                if (rowOptions) {
                    column = this._columnsController.columnOption(columnIdentificator);
                    if (column)
                        cellOptions = this._getCellOptions({
                            value: column.calculateCellValue(rowOptions.data),
                            rowIndex: rowOptions.rowIndex,
                            row: rowOptions,
                            column: column
                        })
                }
                return cellOptions
            },
            getRow: function(index) {
                var rows = this._getRowElements();
                if (rows.length > index)
                    return $(rows[index])
            },
            getCellIndex: function($cell) {
                var cellIndex = $cell.length ? $cell[0].cellIndex : -1;
                return cellIndex
            },
            updateFreeSpaceRowHeight: function($table) {
                var that = this,
                    elementHeight,
                    contentElement = that._findContentElement(),
                    freeSpaceRowElements = that._getFreeSpaceRowElements($table),
                    contentHeight = 0,
                    freespaceRowCount,
                    scrollingMode,
                    resultHeight;
                if (freeSpaceRowElements && contentElement)
                    if (that._dataController.items().length > 0)
                        if (!that._hasHeight) {
                            freespaceRowCount = that._dataController.pageSize() - that._dataController.items().length;
                            scrollingMode = that.option("scrolling.mode");
                            if (freespaceRowCount > 0 && that._dataController.pageCount() > 1 && scrollingMode !== "virtual" && scrollingMode !== "infinite") {
                                freeSpaceRowElements.height(freespaceRowCount * that._rowHeight);
                                freeSpaceRowElements.show()
                            }
                            else if ($table)
                                freeSpaceRowElements.height(0);
                            else
                                freeSpaceRowElements.hide()
                        }
                        else {
                            freeSpaceRowElements.hide();
                            elementHeight = that.element().height();
                            contentHeight = contentElement.outerHeight();
                            resultHeight = elementHeight - contentHeight - that.getScrollbarWidth(true);
                            if (resultHeight > 0) {
                                freeSpaceRowElements.height(resultHeight);
                                freeSpaceRowElements.show()
                            }
                        }
                    else {
                        freeSpaceRowElements.height(0);
                        freeSpaceRowElements.show()
                    }
            },
            _columnOptionChanged: function(e) {
                var optionNames = e.optionNames;
                if (e.changeTypes.grouping)
                    return;
                if (optionNames.width || optionNames.visibleWidth) {
                    this.callBase(e);
                    this._fireColumnResizedCallbacks()
                }
            },
            getScrollable: function() {
                return this._scrollable
            },
            init: function() {
                var that = this,
                    dataController = that.getController("data");
                that.callBase();
                that._editorFactoryController = that.getController("editorFactory");
                that._rowHeight = 0;
                that._scrollTop = 0;
                that._scrollLeft = 0;
                that._hasHeight = false;
                dataController.loadingChanged.add(function(isLoading, messageText) {
                    that.setLoading(isLoading, messageText)
                });
                dataController.dataSourceChanged.add(function() {
                    that._handleScroll({scrollOffset: {
                            top: that._scrollTop,
                            left: that._scrollLeft
                        }})
                })
            },
            _handleDataChanged: function(change) {
                var that = this;
                switch (change.changeType) {
                    case"refresh":
                    case"prepend":
                    case"append":
                    case"update":
                        that.render(null, change);
                        break;
                    default:
                        that._update(change);
                        break
                }
            },
            publicMethods: function() {
                return ["isScrollbarVisible", "getTopVisibleRowData", "getScrollbarWidth", "getCellElement"]
            },
            contentWidth: function() {
                return this.element().width() - this.getScrollbarWidth()
            },
            getScrollbarWidth: function(isHorizontal) {
                var scrollableContainer = this._scrollableContainer && this._scrollableContainer.get(0),
                    scrollbarWidth = 0;
                if (scrollableContainer)
                    if (!isHorizontal)
                        scrollbarWidth = scrollableContainer.offsetWidth - scrollableContainer.clientWidth;
                    else
                        scrollbarWidth = scrollableContainer.offsetHeight - scrollableContainer.clientHeight;
                return scrollbarWidth > 0 ? scrollbarWidth : 0
            },
            _fireColumnResizedCallbacks: function() {
                var that = this,
                    lastColumnWidths = that._lastColumnWidths || [],
                    columnWidths = [],
                    columns = that.getColumns(),
                    i;
                for (i = 0; i < columns.length; i++) {
                    columnWidths[i] = columns[i].visibleWidth;
                    if (columns[i].resizedCallbacks && !isDefined(columns[i].groupIndex) && lastColumnWidths[i] !== columnWidths[i])
                        columns[i].resizedCallbacks.fire(columnWidths[i])
                }
                that._lastColumnWidths = columnWidths
            },
            _updateLastRowBorder: function() {
                var $freeSpaceRow = this._getFreeSpaceRowElements().first(),
                    isFreeSpaceRowHidden = $freeSpaceRow.css("display") === "none";
                if (this.option("showBorders") && this.option("showRowLines") && isFreeSpaceRowHidden)
                    this.element().addClass(DATAGRID_LAST_ROW_BORDER);
                else
                    this.element().removeClass(DATAGRID_LAST_ROW_BORDER)
            },
            _updateScrollable: function() {
                var dxScrollable = this.element().data("dxScrollable");
                if (dxScrollable) {
                    dxScrollable._visibilityChanged(true);
                    this._updateHorizontalScrollPosition()
                }
            },
            _updateLoadPanel: function() {
                var loadPanel = this._loadPanel;
                if (loadPanel && loadPanel.option("visible"))
                    loadPanel.repaint()
            },
            _updateHorizontalScrollPosition: function() {
                var scrollable = this.getScrollable(),
                    scrollLeft = scrollable && scrollable.scrollOffset().left;
                if (scrollLeft === 0 && scrollLeft !== this._scrollLeft)
                    scrollable.scrollTo({x: this._scrollLeft})
            },
            _resizeCore: function() {
                var that = this;
                that._fireColumnResizedCallbacks();
                that._updateRowHeight();
                that._updateNoDataText();
                that.updateFreeSpaceRowHeight();
                that._updateLastRowBorder();
                that._updateScrollable();
                that._updateLoadPanel();
                that.setLoading(that._dataController.isLoading())
            },
            scrollTo: function(location) {
                var $element = this.element(),
                    dxScrollable = $element && $element.data("dxScrollable");
                if (dxScrollable)
                    dxScrollable.scrollTo(location)
            },
            height: function(height) {
                var that = this,
                    $element = this.element();
                if (isDefined(height)) {
                    that._hasHeight = height !== "auto";
                    if ($element)
                        $element.height(height)
                }
                else
                    return $element ? $element.height() : 0
            },
            setLoading: function(isLoading, messageText) {
                var that = this,
                    loadPanel = that._loadPanel,
                    dataController = that._dataController,
                    loadPanelOptions = that.option("loadPanel") || {},
                    animation = dataController.isLoaded() ? loadPanelOptions.animation : null,
                    visibilityOptions;
                if (loadPanel) {
                    visibilityOptions = {
                        message: messageText || loadPanelOptions.text,
                        animation: animation,
                        visible: isLoading
                    };
                    clearTimeout(that._hideLoadingTimeoutID);
                    if (loadPanel.option("visible") && !isLoading)
                        that._hideLoadingTimeoutID = setTimeout(function() {
                            loadPanel.option(visibilityOptions)
                        }, DATAGRID_LOADPANEL_HIDE_TIMEOUT);
                    else
                        loadPanel.option(visibilityOptions);
                    that._updateNoDataText()
                }
            },
            isScrollbarVisible: function() {
                var $element = this.element();
                return $element ? this._findContentElement().outerHeight() - $element.height() > 0 : false
            },
            setRowsOpacity: function(columnIndex, value) {
                var that = this,
                    $rows = that._getRowElements().not("." + DATAGRID_GROUP_ROW_CLASS) || [];
                $.each($rows, function(rowIndex, row) {
                    if (!$(row).hasClass(DATAGRID_GROUP_ROW_CLASS))
                        that.getCellElements(rowIndex).eq(columnIndex).css({opacity: value})
                })
            },
            getCellElements: function(rowIndex) {
                var $cells = this.callBase(rowIndex),
                    groupCellIndex;
                if ($cells) {
                    groupCellIndex = $cells.filter("." + DATAGRID_GROUP_CELL_CLASS).index();
                    if (groupCellIndex >= 0 && $cells.length > groupCellIndex + 1)
                        $cells.length = groupCellIndex + 1
                }
                return $cells
            },
            getTopVisibleItemIndex: function() {
                var that = this,
                    itemIndex = 0,
                    prevOffsetTop = 0,
                    offsetTop = 0,
                    rowElements,
                    rowElelemnt,
                    scrollPosition = that._scrollTop,
                    contentElementOffsetTop = that._findContentElement().offset().top,
                    items = that._dataController.items(),
                    tableElement = that._getTableElement();
                if (items.length && tableElement) {
                    rowElements = tableElement.children("tbody").children(".dx-row:visible, .dx-error-row").not("." + DATAGRID_FREESPACE_CLASS);
                    for (itemIndex = 0; itemIndex < items.length; itemIndex++) {
                        prevOffsetTop = offsetTop;
                        rowElelemnt = rowElements.eq(itemIndex);
                        if (rowElelemnt.length) {
                            offsetTop = rowElelemnt.offset().top - contentElementOffsetTop;
                            if (offsetTop > scrollPosition) {
                                if (scrollPosition * 2 < offsetTop + prevOffsetTop && itemIndex)
                                    itemIndex--;
                                break
                            }
                        }
                    }
                    if (itemIndex && itemIndex === items.length)
                        itemIndex--
                }
                return itemIndex
            },
            getTopVisibleRowData: function() {
                var itemIndex = this.getTopVisibleItemIndex(),
                    items = this._dataController.items();
                if (items[itemIndex])
                    return items[itemIndex].data
            },
            optionChanged: function(args) {
                var that = this;
                that.callBase(args);
                switch (args.name) {
                    case"wordWrapEnabled":
                    case"showColumnLines":
                    case"showRowLines":
                    case"rowAlternationEnabled":
                    case"rowTemplate":
                    case"twoWayBindingEnabled":
                        that._invalidate(true, true);
                        args.handled = true;
                        break;
                    case"scrolling":
                        that._rowHeight = null;
                        that._tableElement = null;
                        args.handled = true;
                        break;
                    case"rtlEnabled":
                        that._rowHeight = null;
                        that._tableElement = null;
                        break;
                    case"loadPanel":
                        that._tableElement = null;
                        that._invalidate(true, true);
                        args.handled = true;
                        break;
                    case"noDataText":
                        that._updateNoDataText();
                        args.handled = true;
                        break
                }
            },
            dispose: function() {
                clearTimeout(this._hideLoadingTimeoutID)
            },
            setScrollerSpacing: function(){}
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_GROUP_ROW_CLASS: DATAGRID_GROUP_ROW_CLASS,
            DATAGRID_ROWS_VIEW_CLASS: DATAGRID_ROWS_VIEW_CLASS,
            DATAGRID_TABLE_CLASS: DATAGRID_TABLE_CLASS,
            DATAGRID_FREESPACE_CLASS: DATAGRID_FREESPACE_CLASS,
            DATAGRID_NODATA_TEXT_CLASS: DATAGRID_NODATA_TEXT_CLASS,
            DATAGRID_NOWRAP_CLASS: DATAGRID_NOWRAP_CLASS,
            DATAGRID_ROW_LINES_CLASS: DATAGRID_ROW_LINES_CLASS,
            DATAGRID_COLUMN_LINES_CLASS: DATAGRID_COLUMN_LINES_CLASS,
            DATAGRID_ROW_ALTERNATION_CLASS: DATAGRID_ROW_ALTERNATION_CLASS,
            DATAGRID_LAST_ROW_BORDER: DATAGRID_LAST_ROW_BORDER
        });
        dataGrid.registerModule("rows", {
            defaultOptions: function() {
                return {
                        hoverStateEnabled: false,
                        loadPanel: {
                            enabled: true,
                            text: Globalize.localize("Loading"),
                            width: 200,
                            height: 70,
                            showIndicator: true,
                            indicatorSrc: "",
                            showPane: true
                        },
                        rowTemplate: null,
                        columnAutoWidth: false,
                        noDataText: Globalize.localize("dxDataGrid-noDataText"),
                        wordWrapEnabled: false,
                        showColumnLines: true,
                        showRowLines: false,
                        rowAlternationEnabled: false,
                        activeStateEnabled: false,
                        twoWayBindingEnabled: true
                    }
            },
            views: {rowsView: dataGrid.RowsView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.pager.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common");
        var DATAGRID_PAGER_CLASS = "dx-datagrid-pager";
        var MAX_PAGES_COUNT = 10;
        dataGrid.PagerView = dataGrid.View.inherit({
            init: function() {
                var that = this,
                    dataController = that.getController("data");
                that._isVisible = false;
                dataController.changed.add(function(e) {
                    if (!e || e.changeType !== "update")
                        that.render()
                })
            },
            _getPager: function() {
                var $element = this.element();
                return $element && $element.data("dxPager")
            },
            _renderCore: function() {
                var that = this,
                    $element = that.element().addClass(DATAGRID_PAGER_CLASS),
                    pagerOptions = that.option("pager") || {},
                    dataController = that.getController("data"),
                    options = {
                        maxPagesCount: MAX_PAGES_COUNT,
                        pageIndex: 1 + (parseInt(dataController.pageIndex()) || 0),
                        pageCount: dataController.pageCount(),
                        pageSize: dataController.pageSize(),
                        showPageSizes: pagerOptions.showPageSizeSelector,
                        showInfo: pagerOptions.showInfo,
                        pagesNavigatorVisible: pagerOptions.visible,
                        showNavigationButtons: pagerOptions.showNavigationButtons,
                        pageSizes: that.getPageSizes(),
                        totalCount: dataController.totalCount(),
                        hasKnownLastPage: dataController.hasKnownLastPage(),
                        pageIndexChanged: function(pageIndex) {
                            if (dataController.pageIndex() !== pageIndex - 1)
                                setTimeout(function() {
                                    dataController.pageIndex(pageIndex - 1)
                                })
                        },
                        pageSizeChanged: function(pageSize) {
                            setTimeout(function() {
                                dataController.pageSize(pageSize)
                            })
                        }
                    };
                if (commonUtils.isDefined(pagerOptions.infoText))
                    options.infoText = pagerOptions.infoText;
                that._createComponent($element, "dxPager", options)
            },
            getPageSizes: function() {
                var that = this,
                    dataController = that.getController("data"),
                    pagerOptions = that.option("pager"),
                    allowedPageSizes = pagerOptions && pagerOptions.allowedPageSizes,
                    pageSize = dataController.pageSize();
                if (!commonUtils.isDefined(that._pageSizes) || $.inArray(pageSize, that._pageSizes) === -1) {
                    that._pageSizes = [];
                    if (pagerOptions)
                        if ($.isArray(allowedPageSizes))
                            that._pageSizes = allowedPageSizes;
                        else if (allowedPageSizes && pageSize > 1)
                            that._pageSizes = [Math.floor(pageSize / 2), pageSize, pageSize * 2]
                }
                return that._pageSizes
            },
            isVisible: function() {
                var that = this,
                    dataController = that.getController("data"),
                    pagerOptions = that.option("pager"),
                    pagerVisible = pagerOptions && pagerOptions.visible,
                    scrolling = that.option("scrolling");
                if (that._isVisible)
                    return true;
                if (pagerVisible === "auto")
                    if (scrolling && (scrolling.mode === "virtual" || scrolling.mode === "infinite"))
                        pagerVisible = false;
                    else
                        pagerVisible = dataController.pageCount() > 1 || dataController.isLoaded() && !dataController.hasKnownLastPage();
                that._isVisible = pagerVisible;
                return pagerVisible
            },
            getHeight: function() {
                var pager = this._getPager();
                return pager && this.isVisible() ? pager.getHeight() : 0
            },
            optionChanged: function(args) {
                var that = this,
                    name = args.name,
                    isPager = name === "pager",
                    isPaging = name === "paging",
                    isDataSource = name === "dataSource",
                    isScrolling = name === "scrolling";
                if (isPager || isPaging || isScrolling || isDataSource) {
                    if (isPager || isPaging)
                        that._pageSizes = null;
                    if (isPager || isPaging || isScrolling)
                        that._isVisible = false;
                    if (!isDataSource) {
                        that._invalidate();
                        if (isPager && that.component)
                            that.component.resize()
                    }
                    args.handled = true
                }
            }
        });
        dataGrid.registerModule("pager", {
            defaultOptions: function() {
                return {pager: {
                            visible: "auto",
                            showPageSizeSelector: false,
                            allowedPageSizes: "auto"
                        }}
            },
            views: {pagerView: dataGrid.PagerView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.columnsResizingReorderingModule.js */
    (function($, DX) {
        var ui = DX.ui,
            commonUtils = DX.require("/utils/utils.common"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer"),
            addNamespace = eventUtils.addNamespace,
            dataGrid = ui.dxDataGrid,
            fx = DX.fx;
        var DATAGRID_COLUMNS_SEPARATOR_CLASS = "dx-datagrid-columns-separator",
            DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT = "dx-datagrid-columns-separator-transparent",
            DATAGRID_DRAGGING_HEADER_CLASS = "dx-datagrid-drag-header",
            DATAGRID_CELL_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_HEADERS_DRAG_ACTION_CLASS = "dx-datagrid-drag-action",
            DATAGRID_TRACKER_CLASS = "dx-datagrid-tracker",
            DATAGRID_BLOCK_SEPARATOR_CLASS = "dx-block-separator",
            DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS = "dx-datagrid-drop-highlight",
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            WIDGET_CLASS = "dx-widget",
            DATAGRID_MODULE_NAMESPACE = "dxDataGridResizingReordering",
            COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH = 10,
            DRAGGING_DELTA = 5;
        var allowResizing = function(that) {
                return that.option("allowColumnResizing") || that.getController("columns").isColumnOptionUsed("allowResizing")
            };
        var allowReordering = function(that) {
                return that.option("allowColumnReordering") || that.getController("columns").isColumnOptionUsed("allowReordering")
            };
        dataGrid.getPointsByColumns = function(items, pointCreated, isVertical) {
            var cellsLength = items.length,
                notCreatePoint = false,
                point,
                i,
                item,
                offset,
                result = [],
                rtlEnabled,
                columnIndex = 0;
            for (i = 0; i <= cellsLength; i++) {
                if (i < cellsLength) {
                    item = items.eq(columnIndex);
                    offset = item.offset();
                    rtlEnabled = item.css("direction") === "rtl"
                }
                point = {
                    index: i,
                    x: offset ? offset.left + (!isVertical && rtlEnabled ^ i === cellsLength ? item.outerWidth() : 0) : 0,
                    y: offset ? offset.top + (isVertical && i === cellsLength ? item.outerHeight() : 0) : 0,
                    columnIndex: columnIndex
                };
                if (pointCreated)
                    notCreatePoint = pointCreated(point);
                if (!notCreatePoint)
                    result.push(point);
                columnIndex++
            }
            return result
        };
        dataGrid.TrackerView = dataGrid.View.inherit({
            _renderCore: function() {
                this.callBase();
                this.element().addClass(DATAGRID_TRACKER_CLASS);
                this.hide()
            },
            _unsubscribeFromCallback: function() {
                if (this._positionChanged)
                    this._tablePositionController.positionChanged.remove(this._positionChanged)
            },
            _subscribeToCallback: function() {
                var that = this;
                that._positionChanged = function(position) {
                    var $element = that.element();
                    if ($element && $element.hasClass(DATAGRID_TRACKER_CLASS)) {
                        $element.css({top: position.top});
                        $element.height(position.height)
                    }
                };
                this._tablePositionController.positionChanged.add(that._positionChanged)
            },
            optionChanged: function(args) {
                if (args.name === "allowColumnResizing") {
                    this._unsubscribeFromCallback();
                    if (args.value) {
                        this._subscribeToCallback();
                        this._invalidate()
                    }
                }
                this.callBase(args)
            },
            init: function() {
                this.callBase();
                this._tablePositionController = this.getController("tablePosition");
                this._subscribeToCallback()
            },
            isVisible: function() {
                return allowResizing(this)
            },
            show: function() {
                this.element().show()
            },
            hide: function() {
                this.element().hide()
            },
            setHeight: function(value) {
                this.element().height(value)
            },
            dispose: function() {
                this._unsubscribeFromCallback();
                this.callBase()
            }
        });
        dataGrid.SeparatorView = dataGrid.View.inherit({
            _renderSeparator: function(){},
            _renderCore: function(options) {
                this.callBase(options);
                this._isShown = true;
                this._renderSeparator();
                this.hide()
            },
            show: function() {
                this._isShown = true
            },
            hide: function() {
                this._isShown = false
            },
            height: function(value) {
                var $element = this.element();
                if ($element)
                    if (commonUtils.isDefined(value))
                        $element.height(value);
                    else
                        return $element.height()
            },
            width: function(value) {
                var $element = this.element();
                if ($element)
                    if (commonUtils.isDefined(value))
                        $element.width(value);
                    else
                        return $element.width()
            }
        });
        dataGrid.ColumnsSeparatorView = dataGrid.SeparatorView.inherit({
            _renderSeparator: function() {
                this.callBase();
                var $element = this.element();
                $element.addClass(DATAGRID_COLUMNS_SEPARATOR_CLASS)
            },
            _subscribeToCallback: function() {
                var that = this,
                    $element;
                that._positionChanged = function(position) {
                    $element = that.element();
                    if ($element) {
                        $element.css({top: position.top});
                        $element.height(position.height)
                    }
                };
                that._tablePositionController.positionChanged.add(that._positionChanged)
            },
            _unsubscribeFromCallback: function() {
                this._positionChanged && this._tablePositionController.positionChanged.remove(this._positionChanged)
            },
            _init: function() {
                this._isTransparent = allowResizing(this);
                if (this.isVisible())
                    this._subscribeToCallback()
            },
            isVisible: function() {
                return this.option("showColumnHeaders") && (allowReordering(this) || allowResizing(this))
            },
            optionChanged: function(args) {
                if (args.name === "allowColumnResizing")
                    if (args.value) {
                        this._init();
                        this._invalidate();
                        this.hide(true)
                    }
                    else {
                        this._unsubscribeFromCallback();
                        this._isTransparent = allowResizing(this);
                        this.hide(true)
                    }
                this.callBase(args)
            },
            init: function() {
                this.callBase();
                this._tablePositionController = this.getController("tablePosition");
                this._init()
            },
            show: function() {
                var that = this,
                    $element = this.element();
                if ($element && !that._isShown)
                    if (that._isTransparent)
                        $element.removeClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT);
                    else
                        $element.show();
                this.callBase()
            },
            hide: function(force) {
                var $element = this.element();
                if ($element && (this._isShown || force))
                    if (this._isTransparent) {
                        $element.addClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT);
                        if ($element.css("display") === "none")
                            $element.show()
                    }
                    else {
                        if ($element.hasClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT))
                            $element.removeClass(DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT);
                        $element.hide()
                    }
                this.callBase()
            },
            moveByX: function(outerX) {
                var $element = this.element();
                if ($element) {
                    $element.css("left", outerX - this._parentElement().offset().left);
                    this._testPosx = outerX
                }
            },
            changeCursor: function(cursorName) {
                cursorName = commonUtils.isDefined(cursorName) ? cursorName : "";
                var $element = this.element();
                if ($element) {
                    $element.css("cursor", cursorName);
                    this._testCursorName = cursorName
                }
            },
            dispose: function() {
                this._unsubscribeFromCallback();
                this.callBase()
            }
        });
        dataGrid.BlockSeparatorView = dataGrid.SeparatorView.inherit({
            init: function() {
                var that = this;
                this.callBase();
                this.getController("data").loadingChanged.add(function(isLoading, messageText) {
                    var element = that.element();
                    if (!isLoading && element && element.css("display") !== "none")
                        that.hide()
                })
            },
            _renderSeparator: function() {
                this.callBase();
                this.element().addClass(DATAGRID_BLOCK_SEPARATOR_CLASS).html("&nbsp;")
            },
            hide: function() {
                var that = this,
                    $parent = this._parentElement(),
                    $element = this.element();
                if ($element && this._isShown)
                    $element.hide();
                if ($parent && !$parent.children("." + DATAGRID_BLOCK_SEPARATOR_CLASS).length)
                    $parent.prepend(that.element());
                that.callBase()
            },
            isVisible: function() {
                var groupPanelOptions = this.option("groupPanel"),
                    columnChooserOptions = this.option("columnChooser");
                return groupPanelOptions && groupPanelOptions.visible || columnChooserOptions && columnChooserOptions.enabled
            },
            show: function(targetLocation) {
                var that = this,
                    $element = this.element(),
                    startAnimate = function(toOptions) {
                        fx.stop($element, true);
                        fx.animate($element, {
                            type: "slide",
                            from: {
                                width: 0,
                                display: toOptions.display
                            },
                            to: toOptions,
                            duration: 300,
                            easing: "swing"
                        })
                    };
                if ($element && !that._isShown)
                    switch (targetLocation) {
                        case"group":
                            startAnimate({
                                width: "50px",
                                display: "inline-block"
                            });
                            break;
                        case"columnChooser":
                            startAnimate({
                                width: "100%",
                                display: "block"
                            });
                            break;
                        default:
                            $element.show()
                    }
                that.callBase()
            }
        });
        dataGrid.DraggingHeaderView = dataGrid.View.inherit({
            _isDragging: false,
            _getDropOptions: function() {
                var that = this;
                if (that._dragOptions)
                    return {
                            sourceColumnIndex: that._dragOptions.columnIndex,
                            sourceColumnElement: that._dragOptions.columnElement,
                            sourceLocation: that._dragOptions.sourceLocation,
                            targetColumnIndex: that._dropColumnIndex,
                            targetLocation: that._dropLocation
                        }
            },
            _getDraggingPanelByPos: function(pos) {
                var that = this,
                    result;
                $.each(that._dragOptions.draggingPanels, function(index, draggingPanel) {
                    if (draggingPanel) {
                        var boundingRect = draggingPanel.getBoundingRect();
                        if (boundingRect && (boundingRect.bottom === undefined || pos.y < boundingRect.bottom) && (boundingRect.top === undefined || pos.y > boundingRect.top) && (boundingRect.left === undefined || pos.x > boundingRect.left) && (boundingRect.right === undefined || pos.x < boundingRect.right)) {
                            result = draggingPanel;
                            return false
                        }
                    }
                });
                return result
            },
            _renderCore: function() {
                this.element().addClass(DATAGRID_DRAGGING_HEADER_CLASS + " " + DATAGRID_CELL_CONTENT_CLASS + " " + WIDGET_CLASS).css("display", "none")
            },
            dispose: function() {
                var element = this.element();
                this._dragOptions = null;
                element && element.parent().find("." + DATAGRID_DRAGGING_HEADER_CLASS).remove()
            },
            isVisible: function() {
                var columnsController = this.getController("columns"),
                    commonColumnSettings = columnsController.getCommonSettings();
                return this.option("showColumnHeaders") && (allowReordering(this) || commonColumnSettings.allowGrouping || commonColumnSettings.allowHiding)
            },
            init: function() {
                var that = this;
                this.callBase();
                this._controller = this.getController("draggingHeader");
                this._columnsResizerViewController = this.getController("columnsResizer");
                this.getController("data").loadingChanged.add(function(isLoading, messageText) {
                    var element = that.element();
                    if (!isLoading && element && element.css("display") !== "none")
                        element.hide()
                })
            },
            dragHeader: function(options) {
                var that = this,
                    columnElement = options.columnElement;
                that._dragOptions = options;
                that._isDragging = true;
                that._dropColumnIndex = options.columnIndex;
                that._dropLocation = options.sourceLocation;
                that._onSelectStart = document.onselectstart;
                document.onselectstart = function() {
                    return false
                };
                that.element().css({
                    textAlign: columnElement && columnElement.css("text-align"),
                    height: columnElement && columnElement.height(),
                    width: columnElement && columnElement.width(),
                    whiteSpace: columnElement && columnElement.css("white-space")
                }).addClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS).text(options.sourceColumn.caption);
                that.element().appendTo($(document.body))
            },
            moveHeader: function(args) {
                var e = args.jQueryEvent,
                    that = e.data.that,
                    newLeft,
                    newTop,
                    moveDeltaX,
                    moveDeltaY,
                    eventData = eventUtils.eventData(e),
                    isResizing = that._columnsResizerViewController ? that._columnsResizerViewController.isResizing() : false,
                    dragOptions = that._dragOptions;
                if (that._isDragging && !isResizing) {
                    moveDeltaX = Math.abs(eventData.x - dragOptions.columnElement.offset().left - dragOptions.deltaX);
                    moveDeltaY = Math.abs(eventData.y - dragOptions.columnElement.offset().top - dragOptions.deltaY);
                    if (that.element().is(":visible") || moveDeltaX > DRAGGING_DELTA || moveDeltaY > DRAGGING_DELTA) {
                        that.element().show();
                        newLeft = eventData.x - dragOptions.deltaX;
                        newTop = eventData.y - dragOptions.deltaY;
                        that.element().offset({
                            left: newLeft,
                            top: newTop
                        });
                        that.dockHeader(eventData)
                    }
                    e.preventDefault()
                }
            },
            dockHeader: function(eventData) {
                var that = this,
                    targetDraggingPanel = that._getDraggingPanelByPos(eventData),
                    controller = that._controller,
                    i,
                    params,
                    centerPosition;
                if (targetDraggingPanel) {
                    var rtlEnabled = that.option("rtlEnabled"),
                        isVerticalOrientation = targetDraggingPanel.getName() === "columnChooser",
                        axisName = isVerticalOrientation ? "y" : "x",
                        columnElements = targetDraggingPanel.getColumnElements() || [],
                        pointsByColumns = controller._generatePointsByColumns($.extend({}, that._dragOptions, {
                            targetDraggingPanel: targetDraggingPanel,
                            columns: targetDraggingPanel.getColumns(),
                            columnElements: columnElements,
                            isVerticalOrientation: isVerticalOrientation
                        }));
                    that._dropLocation = targetDraggingPanel.getName();
                    if (pointsByColumns.length > 0)
                        for (i = 0; i < pointsByColumns.length; i++) {
                            centerPosition = pointsByColumns[i + 1] && (pointsByColumns[i][axisName] + pointsByColumns[i + 1][axisName]) / 2;
                            if (centerPosition === undefined || (rtlEnabled && axisName === "x" ? eventData[axisName] > centerPosition : eventData[axisName] < centerPosition)) {
                                that._dropColumnIndex = pointsByColumns[i].columnIndex;
                                params = that._getDropOptions();
                                if (columnElements[i])
                                    params.targetColumnElement = columnElements.eq(i);
                                else {
                                    params.targetColumnElement = columnElements.last();
                                    params.isLast = true
                                }
                                params.posX = pointsByColumns[i].x;
                                controller.dock(params);
                                break
                            }
                        }
                    else {
                        that._dropColumnIndex = -1;
                        params = that._getDropOptions();
                        controller.dock(params)
                    }
                }
            },
            dropHeader: function(args) {
                var e = args.jQueryEvent,
                    that = e.data.that,
                    controller = that._controller;
                that.element().hide();
                if (controller && that._isDragging)
                    controller.drop(that._getDropOptions());
                that.element().appendTo(that._parentElement());
                that._dragOptions = null;
                that._isDragging = false;
                document.onselectstart = that._onSelectStart || null
            }
        });
        dataGrid.ColumnsResizerViewController = dataGrid.ViewController.inherit({
            _isHeadersRowArea: function(posY) {
                if (this._columnHeadersView) {
                    var element = this._columnHeadersView.element(),
                        headersRowHeight,
                        offsetTop;
                    if (element) {
                        offsetTop = element.offset().top;
                        headersRowHeight = this._columnHeadersView.getHeadersRowHeight();
                        return posY >= offsetTop && posY <= offsetTop + headersRowHeight
                    }
                }
                return false
            },
            _pointCreated: function(point, cellsLength, columns) {
                var currentColumn,
                    nextColumn;
                if (point.index > 0 && point.index < cellsLength) {
                    point.columnIndex -= 1;
                    currentColumn = columns[point.columnIndex] || {};
                    nextColumn = columns[point.columnIndex + 1] || {};
                    return !(currentColumn.allowResizing && nextColumn.allowResizing)
                }
                return true
            },
            _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
                if (pointsByColumns)
                    for (var i = 0; i < pointsByColumns.length; i++)
                        if (pointsByColumns[i].x - deltaX <= currentX && currentX <= pointsByColumns[i].x + deltaX)
                            return pointsByColumns[i];
                return null
            },
            _moveSeparator: function(args) {
                var e = args.jQueryEvent,
                    that = e.data,
                    columnsSeparatorWidth = that._columnsSeparatorView.width(),
                    columnsSeparatorOffset = that._columnsSeparatorView.element().offset(),
                    deltaX = columnsSeparatorWidth / 2,
                    parentOffset = that._$parentContainer.offset(),
                    parentOffsetLeft = parentOffset.left,
                    eventData = eventUtils.eventData(e);
                if (that._isResizing) {
                    if (parentOffsetLeft <= eventData.x && eventData.x <= parentOffsetLeft + that._$parentContainer.width())
                        if (that._updateColumnsWidthIfNeeded(that._targetPoint.columnIndex, eventData.x)) {
                            that._columnsSeparatorView.moveByX(that._targetPoint.x + (eventData.x - that._resizingInfo.startPosX));
                            that._tablePositionController.update();
                            e.preventDefault()
                        }
                }
                else if (that._isHeadersRowArea(eventData.y)) {
                    if (that._previousParentOffset)
                        if (that._previousParentOffset.left !== parentOffset.left || that._previousParentOffset.top !== parentOffset.top)
                            that.pointsByColumns(null);
                    that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData.x, columnsSeparatorWidth);
                    that._previousParentOffset = parentOffset;
                    that._isReadyResizing = false;
                    that._columnsSeparatorView.changeCursor();
                    if (that._targetPoint && columnsSeparatorOffset.top <= eventData.y && columnsSeparatorOffset.top + that._columnsSeparatorView.height() >= eventData.y) {
                        that._columnsSeparatorView.changeCursor("col-resize");
                        that._columnsSeparatorView.moveByX(that._targetPoint.x - deltaX);
                        that._isReadyResizing = true;
                        e.preventDefault()
                    }
                }
                else {
                    that.pointsByColumns(null);
                    that._isReadyResizing = false;
                    that._columnsSeparatorView.changeCursor()
                }
            },
            _endResizing: function(args) {
                var e = args.jQueryEvent,
                    that = e.data;
                if (that._isResizing) {
                    that.pointsByColumns(null);
                    that._resizingInfo = null;
                    that._columnsSeparatorView.hide();
                    that._columnsSeparatorView.changeCursor();
                    that._trackerView.hide();
                    that._isReadyResizing = false;
                    that._isResizing = false
                }
            },
            _setupResizingInfo: function(posX) {
                var that = this,
                    currentHeader = that._columnHeadersView.getHeaderElement(that._targetPoint.columnIndex),
                    nextHeader = that._columnHeadersView.getHeaderElement(that._targetPoint.columnIndex + 1);
                that._resizingInfo = {
                    startPosX: posX,
                    currentColumnWidth: currentHeader && currentHeader.length > 0 ? currentHeader.outerWidth() : 0,
                    nextColumnWidth: nextHeader && nextHeader.length > 0 ? nextHeader.outerWidth() : 0
                }
            },
            _startResizing: function(args) {
                var e = args.jQueryEvent,
                    that = e.data,
                    eventData = eventUtils.eventData(e);
                if (eventUtils.isTouchEvent(e))
                    if (that._isHeadersRowArea(eventData.y)) {
                        that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData.x, COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH);
                        if (that._targetPoint) {
                            that._columnsSeparatorView.moveByX(that._targetPoint.x - that._columnsSeparatorView.width() / 2);
                            that._isReadyResizing = true
                        }
                    }
                    else
                        that._isReadyResizing = false;
                if (that._isReadyResizing) {
                    if (that._targetPoint)
                        that._testColumnIndex = that._targetPoint.columnIndex;
                    that._setupResizingInfo(eventData.x);
                    that._columnsSeparatorView.show();
                    that._trackerView.show();
                    that._isResizing = true;
                    e.preventDefault();
                    e.stopPropagation()
                }
            },
            _generatePointsByColumns: function() {
                var that = this,
                    columns = that._columnsController ? that._columnsController.getVisibleColumns() : [],
                    cells = that._columnHeadersView.getColumnElements(),
                    pointsByColumns = [];
                if (cells && cells.length > 0)
                    pointsByColumns = dataGrid.getPointsByColumns(cells, function(point) {
                        return that._pointCreated(point, cells.length, columns)
                    });
                that._pointsByColumns = pointsByColumns
            },
            _unsubscribeFromEvents: function() {
                this._moveSeparatorHandler && this._$parentContainer.off(addNamespace(pointerEvents.move, DATAGRID_MODULE_NAMESPACE), this._moveSeparatorHandler);
                this._startResizingHandler && this._$parentContainer.off(addNamespace(pointerEvents.down, DATAGRID_MODULE_NAMESPACE), this._startResizingHandler);
                if (this._endResizingHandler) {
                    this._columnsSeparatorView.element().off(addNamespace(pointerEvents.up, DATAGRID_MODULE_NAMESPACE), this._endResizingHandler);
                    $(document).off(addNamespace(pointerEvents.up, DATAGRID_MODULE_NAMESPACE), this._endResizingHandler)
                }
            },
            _subscribeToEvents: function() {
                this._moveSeparatorHandler = this.createAction(this._moveSeparator);
                this._startResizingHandler = this.createAction(this._startResizing);
                this._endResizingHandler = this.createAction(this._endResizing);
                this._$parentContainer.on(addNamespace(pointerEvents.move, DATAGRID_MODULE_NAMESPACE), this, this._moveSeparatorHandler);
                this._$parentContainer.on(addNamespace(pointerEvents.down, DATAGRID_MODULE_NAMESPACE), this, this._startResizingHandler);
                this._columnsSeparatorView.element().on(addNamespace(pointerEvents.up, DATAGRID_MODULE_NAMESPACE), this, this._endResizingHandler);
                $(document).on(addNamespace(pointerEvents.up, DATAGRID_MODULE_NAMESPACE), this, this._endResizingHandler)
            },
            _updateColumnsWidthIfNeeded: function(columnIndex, posX) {
                var deltaX,
                    isUpdated = false,
                    nextCellWidth,
                    columnsController = this._columnsController,
                    visibleColumns = columnsController.getVisibleColumns(),
                    columnsSeparatorWidth = this._columnsSeparatorView.width(),
                    contentWidth = this._rowsView.contentWidth(),
                    adaptColumnWidthByRatio = this.option("adaptColumnWidthByRatio") && !this.option("columnAutoWidth"),
                    column,
                    nextColumn,
                    cellWidth;
                function setColumnWidth(column, columnWidth, contentWidth, adaptColumnWidthByRatio) {
                    if (column) {
                        var oldColumnWidth = column.width;
                        if (oldColumnWidth)
                            adaptColumnWidthByRatio = commonUtils.isString(oldColumnWidth) && oldColumnWidth.slice(-1) === "%";
                        if (adaptColumnWidthByRatio) {
                            column && columnsController.columnOption(column.index, "visibleWidth", columnWidth);
                            column && columnsController.columnOption(column.index, "width", (columnWidth / contentWidth * 100).toFixed(3) + "%")
                        }
                        else {
                            column && columnsController.columnOption(column.index, "visibleWidth", undefined);
                            column && columnsController.columnOption(column.index, "width", columnWidth)
                        }
                    }
                }
                deltaX = posX - this._resizingInfo.startPosX;
                if (this.option("rtlEnabled"))
                    deltaX = -deltaX;
                cellWidth = this._resizingInfo.currentColumnWidth + deltaX;
                nextCellWidth = this._resizingInfo.nextColumnWidth - deltaX;
                isUpdated = !(cellWidth <= columnsSeparatorWidth || nextCellWidth <= columnsSeparatorWidth);
                if (isUpdated) {
                    column = visibleColumns[columnIndex];
                    nextColumn = visibleColumns[columnIndex + 1];
                    columnsController.beginUpdate();
                    cellWidth = Math.floor(cellWidth);
                    nextCellWidth = Math.floor(nextCellWidth);
                    setColumnWidth(column, cellWidth, contentWidth, adaptColumnWidthByRatio);
                    setColumnWidth(nextColumn, nextCellWidth, contentWidth, adaptColumnWidthByRatio);
                    columnsController.endUpdate()
                }
                return isUpdated
            },
            _subscribeToCallback: function(callback, handler) {
                callback.add(handler);
                this._subscribesToCallbacks.push({
                    callback: callback,
                    handler: handler
                })
            },
            _unsubscribeFromCallbacks: function() {
                var i,
                    subscribe;
                for (i = 0; i < this._subscribesToCallbacks.length; i++) {
                    subscribe = this._subscribesToCallbacks[i];
                    subscribe.callback.remove(subscribe.handler)
                }
                this._subscribesToCallbacks = []
            },
            _unsubscribes: function() {
                this._unsubscribeFromEvents();
                this._unsubscribeFromCallbacks()
            },
            _init: function() {
                var that = this,
                    gridView,
                    generatePointsByColumnsHandler = function() {
                        if (!that._isResizing)
                            that.pointsByColumns(null)
                    },
                    generatePointsByColumnsScrollHandler = function(offset) {
                        if (that._scrollLeft !== offset.left) {
                            that._scrollLeft = offset.left;
                            that.pointsByColumns(null)
                        }
                    },
                    previousScrollbarVisibility;
                that._columnsSeparatorView = that.getView("columnsSeparatorView");
                that._columnHeadersView = that.getView("columnHeadersView");
                that._trackerView = that.getView("trackerView");
                that._rowsView = that.getView("rowsView");
                that._columnsController = that.getController("columns");
                that._tablePositionController = that.getController("tablePosition");
                that._$parentContainer = that._columnsSeparatorView.component.element();
                that._subscribeToCallback(that._columnHeadersView.renderCompleted, generatePointsByColumnsHandler);
                that._subscribeToCallback(that._columnHeadersView.resizeCompleted, generatePointsByColumnsHandler);
                that._subscribeToCallback(that._columnsSeparatorView.renderCompleted, function() {
                    that._unsubscribeFromEvents();
                    that._subscribeToEvents()
                });
                that._subscribeToCallback(that._rowsView.renderCompleted, function() {
                    that._rowsView.scrollChanged.remove(generatePointsByColumnsScrollHandler);
                    that._rowsView.scrollChanged.add(generatePointsByColumnsScrollHandler)
                });
                gridView = that.getView("gridView");
                previousScrollbarVisibility = that._rowsView.getScrollbarWidth() !== 0;
                that._subscribeToCallback(that.getController("tablePosition").positionChanged, function() {
                    if (that._isResizing && !that._rowsView.isResizing) {
                        var scrollbarVisibility = that._rowsView.getScrollbarWidth() !== 0;
                        if (previousScrollbarVisibility !== scrollbarVisibility) {
                            previousScrollbarVisibility = scrollbarVisibility;
                            gridView.resize()
                        }
                        else
                            that._rowsView.updateFreeSpaceRowHeight()
                    }
                })
            },
            optionChanged: function(args) {
                this.callBase(args);
                if (args.name === "allowColumnResizing")
                    if (args.value) {
                        this._init();
                        this._subscribeToEvents()
                    }
                    else
                        this._unsubscribes()
            },
            isResizing: function() {
                return this._isResizing
            },
            init: function() {
                this._subscribesToCallbacks = [];
                if (allowResizing(this))
                    this._init()
            },
            pointsByColumns: function(value) {
                if (value !== undefined)
                    this._pointsByColumns = value;
                else {
                    if (!this._pointsByColumns)
                        this._generatePointsByColumns();
                    return this._pointsByColumns
                }
            },
            dispose: function() {
                this._unsubscribes();
                this.callBase()
            }
        });
        dataGrid.TablePositionViewController = dataGrid.ViewController.inherit({
            update: function() {
                var $element = this._columnHeadersView.element(),
                    columnsHeadersHeight = this._columnHeadersView ? this._columnHeadersView.getHeight() : 0,
                    rowsHeight = this._rowsView ? this._rowsView.height() - this._rowsView.getScrollbarWidth(true) : 0;
                this.positionChanged.fire({
                    height: columnsHeadersHeight + rowsHeight,
                    top: $element && $element.length > 0 ? Math.floor($element[0].offsetTop) : 0
                })
            },
            init: function() {
                var that = this;
                that.callBase();
                that._columnHeadersView = this.getView("columnHeadersView");
                that._rowsView = this.getView("rowsView");
                that._pagerView = this.getView("pagerView");
                that._rowsView.resizeCompleted.add(function() {
                    that.update()
                })
            },
            ctor: function(component) {
                this.callBase(component);
                this.positionChanged = $.Callbacks()
            }
        });
        dataGrid.DraggingHeaderViewController = dataGrid.ViewController.inherit({
            _generatePointsByColumns: function(options) {
                var that = this;
                return dataGrid.getPointsByColumns(options.columnElements, function(point) {
                        return that._pointCreated(point, options.columns, options.targetDraggingPanel.getName(), options.sourceColumn)
                    }, options.isVerticalOrientation)
            },
            _pointCreated: function(point, columns, location, sourceColumn) {
                var targetColumn = columns[point.columnIndex],
                    prevColumn = columns[point.columnIndex - 1];
                switch (location) {
                    case"columnChooser":
                        return true;
                    case"headers":
                        return sourceColumn && !sourceColumn.allowReordering || (!targetColumn || !targetColumn.allowReordering) && (!prevColumn || !prevColumn.allowReordering);
                    default:
                        return columns.length === 0
                }
            },
            _subscribeToEvents: function(draggingHeader, draggingPanels) {
                var that = this;
                $.each(draggingPanels, function(_, draggingPanel) {
                    if (draggingPanel) {
                        var columnElements = draggingPanel.getColumnElements() || [],
                            nameDraggingPanel = draggingPanel.getName(),
                            columns = draggingPanel.getColumns() || [];
                        $.each(columnElements, function(index, columnElement) {
                            var $columnElement = $(columnElement);
                            if (draggingPanel.allowDragging(columns[index], draggingPanels)) {
                                $columnElement.addClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS);
                                $columnElement.on(addNamespace("dxdragstart", DATAGRID_MODULE_NAMESPACE), that.createAction(function(args) {
                                    var e = args.jQueryEvent,
                                        eventData = eventUtils.eventData(e);
                                    draggingHeader.dragHeader({
                                        deltaX: eventData.x - $(e.currentTarget).offset().left,
                                        deltaY: eventData.y - $(e.currentTarget).offset().top,
                                        sourceColumn: columns[index],
                                        columnIndex: index,
                                        columnElement: $columnElement,
                                        sourceLocation: nameDraggingPanel,
                                        draggingPanels: draggingPanels
                                    })
                                }));
                                $columnElement.on(addNamespace("dxdrag", DATAGRID_MODULE_NAMESPACE), {that: draggingHeader}, that.createAction(draggingHeader.moveHeader));
                                $columnElement.on(addNamespace("dxdragend", DATAGRID_MODULE_NAMESPACE), {that: draggingHeader}, that.createAction(draggingHeader.dropHeader))
                            }
                        })
                    }
                })
            },
            _unsubscribeFromEvents: function(draggingHeader, draggingPanels) {
                $.each(draggingPanels, function(_, draggingPanel) {
                    if (draggingPanel) {
                        var columnElements = draggingPanel.getColumnElements() || [];
                        $.each(columnElements, function(index, columnElement) {
                            var $columnElement = $(columnElement);
                            $columnElement.off(addNamespace("dxdragstart", DATAGRID_MODULE_NAMESPACE));
                            $columnElement.off(addNamespace("dxdrag", DATAGRID_MODULE_NAMESPACE));
                            $columnElement.off(addNamespace("dxdragend", DATAGRID_MODULE_NAMESPACE));
                            $columnElement.removeClass(DATAGRID_HEADERS_DRAG_ACTION_CLASS)
                        })
                    }
                })
            },
            _getSeparator: function(targetLocation) {
                return targetLocation === "headers" ? this._columnsSeparatorView : this._blockSeparatorView
            },
            hideSeparators: function() {
                var blockSeparator = this._blockSeparatorView,
                    columnsSeparator = this._columnsSeparatorView;
                this._animationColumnIndex = null;
                blockSeparator && blockSeparator.hide();
                columnsSeparator && columnsSeparator.hide()
            },
            init: function() {
                var that = this,
                    subscribeToEvents;
                that.callBase();
                that._columnsController = that.getController("columns");
                that._columnHeadersView = that.getView("columnHeadersView");
                that._columnsSeparatorView = that.getView("columnsSeparatorView");
                that._draggingHeaderView = that.getView("draggingHeaderView");
                that._rowsView = that.getView("rowsView");
                that._blockSeparatorView = that.getView("blockSeparatorView");
                that._headerPanelView = that.getView("headerPanel");
                that._columnChooserView = that.getView("columnChooserView");
                subscribeToEvents = function() {
                    if (that._draggingHeaderView) {
                        var draggingPanels = [that._columnChooserView, that._columnHeadersView, that._headerPanelView];
                        that._unsubscribeFromEvents(that._draggingHeaderView, draggingPanels);
                        that._subscribeToEvents(that._draggingHeaderView, draggingPanels)
                    }
                };
                that._columnHeadersView.renderCompleted.add(subscribeToEvents);
                that._headerPanelView && that._headerPanelView.renderCompleted.add(subscribeToEvents);
                that._columnChooserView && that._columnChooserView.renderCompleted.add(subscribeToEvents)
            },
            allowDrop: function(parameters) {
                return this._columnsController.allowMoveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
            },
            dock: function(parameters) {
                var that = this,
                    targetColumnIndex = parameters.targetColumnIndex,
                    sourceLocation = parameters.sourceLocation,
                    sourceColumnIndex = parameters.sourceColumnIndex,
                    sourceColumnElement = parameters.sourceColumnElement,
                    targetLocation = parameters.targetLocation,
                    separator = that._getSeparator(targetLocation),
                    hasTargetColumnIndex = targetColumnIndex >= 0;
                var showSeparator = function() {
                        if (that._animationColumnIndex !== targetColumnIndex) {
                            that.hideSeparators();
                            separator.element()[parameters.isLast ? "insertAfter" : "insertBefore"](parameters.targetColumnElement);
                            that._animationColumnIndex = targetColumnIndex;
                            separator.show(targetLocation)
                        }
                    };
                that._columnHeadersView.element().find("." + DATAGRID_HEADER_ROW_CLASS).toggleClass(DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS, sourceLocation !== "headers" && targetLocation === "headers" && !hasTargetColumnIndex);
                if (separator) {
                    if (sourceColumnElement) {
                        sourceColumnElement.css({opacity: 0.5});
                        if (sourceLocation === "headers")
                            that._rowsView.setRowsOpacity(sourceColumnIndex, 0.5)
                    }
                    if (that.allowDrop(parameters) && hasTargetColumnIndex)
                        if (targetLocation === "group" || targetLocation === "columnChooser")
                            showSeparator();
                        else {
                            that.hideSeparators();
                            separator.moveByX(parameters.posX - separator.width());
                            separator.show()
                        }
                    else
                        that.hideSeparators()
                }
            },
            drop: function(parameters) {
                var sourceColumnElement = parameters.sourceColumnElement;
                if (sourceColumnElement) {
                    sourceColumnElement.css({opacity: ""});
                    this._rowsView.setRowsOpacity(parameters.sourceColumnIndex, "");
                    this._columnHeadersView.element().find("." + DATAGRID_HEADER_ROW_CLASS).removeClass(DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS)
                }
                if (this.allowDrop(parameters)) {
                    var separator = this._getSeparator(parameters.targetLocation);
                    if (separator)
                        separator.hide();
                    this._columnsController.moveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
                }
            },
            dispose: function() {
                if (this._draggingHeaderView)
                    this._unsubscribeFromEvents(this._draggingHeaderView, [this._columnChooserView, this._columnHeadersView, this._headerPanelView])
            }
        });
        dataGrid.__internals = $.extend({}, dataGrid.__internals, {
            DATAGRID_COLUMNS_SEPARATOR_CLASS: DATAGRID_COLUMNS_SEPARATOR_CLASS,
            DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT: DATAGRID_COLUMNS_SEPARATOR_TRANSPARENT,
            DATAGRID_DRAGGING_HEADER_CLASS: DATAGRID_DRAGGING_HEADER_CLASS,
            DATAGRID_HEADERS_DRAG_ACTION_CLASS: DATAGRID_HEADERS_DRAG_ACTION_CLASS,
            DATAGRID_CELL_CONTENT_CLASS: DATAGRID_CELL_CONTENT_CLASS,
            DATAGRID_TRACKER_CLASS: DATAGRID_TRACKER_CLASS,
            DATAGRID_MODULE_NAMESPACE: DATAGRID_MODULE_NAMESPACE,
            DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS: DATAGRID_HEADERS_DROP_HIGHLIGHT_CLASS,
            WIDGET_CLASS: WIDGET_CLASS
        });
        dataGrid.registerModule("columnsResizingReordering", {
            views: {
                columnsSeparatorView: dataGrid.ColumnsSeparatorView,
                blockSeparatorView: dataGrid.BlockSeparatorView,
                draggingHeaderView: dataGrid.DraggingHeaderView,
                trackerView: dataGrid.TrackerView
            },
            controllers: {
                draggingHeader: dataGrid.DraggingHeaderViewController,
                tablePosition: dataGrid.TablePositionViewController,
                columnsResizer: dataGrid.ColumnsResizerViewController
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.contextMenuView.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_CLASS = "dx-datagrid",
            DATAGRID_CONTEXT_MENU = "dx-context-menu",
            viewName = {
                columnHeadersView: "header",
                rowsView: "content",
                footerView: "footer"
            },
            VIEW_NAMES = ["columnHeadersView", "rowsView", "footerView"];
        dataGrid.ContextMenuController = dataGrid.ViewController.inherit({
            init: function() {
                this.createAction("onContextMenuPreparing")
            },
            getContextMenuItems: function(jQueryEvent) {
                if (!jQueryEvent)
                    return false;
                var that = this,
                    $targetElement = $(jQueryEvent.target),
                    view,
                    options,
                    rowIndex,
                    columnIndex,
                    rowOptions,
                    $targetRowElement,
                    $targetCellElement,
                    menuItems;
                $.each(VIEW_NAMES, function() {
                    view = that.getView(this);
                    if (view && view.element() && view.element().find($targetElement).length) {
                        $targetCellElement = $targetElement.closest("td");
                        $targetRowElement = $targetCellElement.closest(".dx-row");
                        rowIndex = view.getRowIndex($targetRowElement);
                        columnIndex = $targetCellElement[0] && $targetCellElement[0].cellIndex;
                        rowOptions = $targetRowElement.data("options");
                        options = {
                            jQueryEvent: jQueryEvent,
                            targetElement: $targetElement,
                            target: viewName[this],
                            rowIndex: rowIndex,
                            row: view._getRows()[rowIndex],
                            columnIndex: columnIndex,
                            column: rowOptions && rowOptions.cells[columnIndex].column,
                            items: view.getContextMenuItems && view.getContextMenuItems($targetElement)
                        };
                        that.executeAction("onContextMenuPreparing", options);
                        that._contextMenuPrepared(options);
                        menuItems = options.items;
                        if (menuItems)
                            return false
                    }
                });
                return menuItems
            },
            _contextMenuPrepared: $.noop
        });
        dataGrid.ContextMenuView = dataGrid.View.inherit({_renderCore: function() {
                var that = this;
                this._createComponent(that.element().addClass(DATAGRID_CONTEXT_MENU), "dxContextMenu", {
                    onPositioning: function(actionArgs) {
                        var event = actionArgs.jQueryEvent,
                            contextMenuInstance = actionArgs.component,
                            items = that.getController("contextMenu").getContextMenuItems(event);
                        if (items) {
                            contextMenuInstance.option("items", items);
                            event.stopPropagation()
                        }
                        else
                            actionArgs.cancel = true
                    },
                    onItemClick: function(params) {
                        params.itemData.onItemClick && params.itemData.onItemClick(params)
                    },
                    cssClass: DATAGRID_CLASS,
                    target: that.component.element()
                })
            }});
        dataGrid.registerModule("contextMenu", {
            defaultOptions: function() {
                return {onContextMenuPreparing: null}
            },
            controllers: {contextMenu: dataGrid.ContextMenuController},
            views: {contextMenuView: dataGrid.ContextMenuView}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.keyboardNavigation.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common"),
            KeyboardProcessor = DX.require("/ui/ui.keyboardProcessor"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            pointerEvents = DX.require("/ui/events/pointer/ui.events.pointer");
        var DATAGRID_ROW_CLASS = "dx-row",
            DATAGRID_DATA_ROW_CLASS = "dx-data-row",
            DATAGRID_GROUP_ROW_CLASS = "dx-group-row",
            DATAGRID_ROWS_VIEW_CLASS = "dx-datagrid-rowsview",
            DATAGRID_MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row",
            DATAGRID_MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
            DATAGRID_EDIT_FORM_CLASS = "dx-datagrid-edit-form",
            DATAGRID_GROUP_FOOTER_CLASS = "dx-datagrid-group-footer",
            DATAGRID_COMMAND_EXPAND_CLASS = "dx-command-expand",
            DATAGRID_CLASS_SELECTOR = ".dx-datagrid",
            DATAGRID_INTERACTIVE_ELEMENTS_SELECTOR = ".dx-checkbox, .dx-menu, input, textarea, [tabindex]",
            DATAGRID_VIEWS = ["rowsView"],
            DATAGRID_EDIT_MODE_ROW = "row",
            DATAGRID_EDIT_MODE_FORM = "form";
        function isGroupRow($row) {
            return $row && $row.hasClass(DATAGRID_GROUP_ROW_CLASS)
        }
        function isDetailRow($row) {
            return $row && $row.hasClass(DATAGRID_MASTER_DETAIL_ROW_CLASS)
        }
        dataGrid.KeyboardNavigationController = dataGrid.ViewController.inherit({
            _isRowEditMode: function() {
                var editMode = this._editingController.getEditMode();
                return editMode === DATAGRID_EDIT_MODE_ROW || editMode === DATAGRID_EDIT_MODE_FORM
            },
            _focusView: function(view, viewIndex) {
                this._focusedViews.viewIndex = viewIndex;
                this._focusedView = view
            },
            _focusInteractiveElement: function($cell, isLast) {
                var $focusedElement = $cell.find(DATAGRID_INTERACTIVE_ELEMENTS_SELECTOR);
                $focusedElement = isLast ? $focusedElement.last() : $focusedElement.first();
                this._testInteractiveElement = $focusedElement;
                $focusedElement.focus()
            },
            _updateFocus: function() {
                var that = this,
                    $cell = that._getFocusedCell();
                if ($cell) {
                    if (that._hasSkipRow($cell.parent()))
                        $cell = that._getNextCell(this._focusedCellPosition && this._focusedCellPosition.rowIndex > 0 ? "upArrow" : "downArrow");
                    if ($cell && $cell.length > 0)
                        setTimeout(function() {
                            if (that.getController("editorFactory").focus())
                                that._focus($cell);
                            that._editingController.isEditing() && $.proxy(that._focusInteractiveElement, that)($cell)
                        })
                }
            },
            _clickHandler: function(e) {
                var event = e.jQueryEvent,
                    $cell = $(event.currentTarget),
                    $grid = $(event.target).closest(DATAGRID_CLASS_SELECTOR).parent();
                if ($grid.is(this.component.element()) && this._isCellValid($cell, true)) {
                    this._focusView(event.data.view, event.data.viewIndex);
                    this._updateFocusedCellPosition($cell);
                    if (!this._editingController.isEditing())
                        $cell.focus()
                }
                else
                    this._resetFocusedCell()
            },
            _initFocusedViews: function() {
                var that = this,
                    clickAction = that.createAction(that._clickHandler);
                that._focusedViews = [];
                $.each(DATAGRID_VIEWS, function(key, viewName) {
                    var view = that.getView(viewName);
                    if (view && view.isVisible())
                        that._focusedViews.push(view)
                });
                $.each(that._focusedViews, function(index, view) {
                    if (view)
                        view.renderCompleted.add(function() {
                            var $element = view.element();
                            $element.off(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), clickAction);
                            $element.on(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), "." + DATAGRID_ROW_CLASS + " td", {
                                viewIndex: index,
                                view: view
                            }, clickAction);
                            that._initKeyDownProcessor(that, $element, that._keyDownHandler);
                            if (that._focusedView && that._focusedView.name === view.name && that._isNeedFocus)
                                that._updateFocus()
                        })
                })
            },
            _initKeyDownProcessor: function(context, element, handler) {
                if (this._keyDownProcessor) {
                    this._keyDownProcessor.dispose();
                    this._keyDownProcessor = null
                }
                this._keyDownProcessor = new KeyboardProcessor({
                    element: element,
                    context: context,
                    handler: handler
                })
            },
            _getFocusedCell: function() {
                if (this._focusedView && this._focusedCellPosition)
                    return this._focusedView.getCell(this._focusedCellPosition)
            },
            _updateFocusedCellPosition: function($cell) {
                var that = this,
                    rowsView = that.getView("rowsView");
                if ($cell.length > 0)
                    this._focusedCellPosition = {
                        columnIndex: rowsView.getCellIndex($cell),
                        rowIndex: $cell.parent().length > 0 && that._focusedView ? that._focusedView.getRowIndex($cell.parent()) : null
                    }
            },
            _isCellValid: function($cell, allCommandColumns) {
                if (commonUtils.isDefined($cell)) {
                    var rowsView = this.getView("rowsView"),
                        visibleColumns = this._columnsController.getVisibleColumns(),
                        rowIndex = rowsView.getRowIndex($cell.parent()),
                        columnIndex = rowsView.getCellIndex($cell),
                        column = visibleColumns[columnIndex],
                        visibleColumnCount = this._getVisibleColumnCount(rowIndex),
                        editMode = this._editingController.getEditMode(),
                        isEditingCurrentRow = editMode === DATAGRID_EDIT_MODE_ROW ? this._editingController.isEditRow(rowIndex) : this._editingController.isEditing(),
                        isMasterDetailRow = isDetailRow($cell.parent()),
                        isValidGroupSpaceColumn = function() {
                            return !isMasterDetailRow && column && !commonUtils.isDefined(column.groupIndex) || parseInt($cell.attr("colspan")) > 1
                        };
                    if (visibleColumnCount > columnIndex && isValidGroupSpaceColumn()) {
                        var isExpandColumn = !allCommandColumns ? column.command === "expand" : false;
                        return column && !commonUtils.isDefined(column.command) && (!isEditingCurrentRow || column.allowEditing) || isExpandColumn
                    }
                }
            },
            _isCellByPositionValid: function(cellPosition, allCommandColumns) {
                var $cell = this._focusedView && this._focusedView.getCell(cellPosition);
                return this._isCellValid($cell, allCommandColumns)
            },
            _focus: function($cell) {
                var $row = $cell.parent(),
                    $focusedCell = this._getFocusedCell(),
                    $focusElement;
                $focusedCell && $focusedCell.attr("tabindex", null);
                if (isGroupRow($row)) {
                    $focusElement = $row;
                    this._focusedCellPosition.rowIndex = this._focusedView.getRowIndex($row)
                }
                else {
                    $focusElement = $cell;
                    this._updateFocusedCellPosition($cell)
                }
                $focusElement.attr("tabindex", 0);
                $focusElement.focus();
                this.getController("editorFactory").focus($focusElement)
            },
            _hasSkipRow: function($row) {
                return $row && ($row.css("display") === "none" || $row.hasClass(DATAGRID_GROUP_FOOTER_CLASS) || isDetailRow($row) && !$row.hasClass(DATAGRID_EDIT_FORM_CLASS))
            },
            _enterKeyHandler: function(eventArgs, isEditing) {
                var $cell = this._getFocusedCell(),
                    editingOptions = this.option("editing"),
                    rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
                    $row = this._focusedView && this._focusedView.getRow(rowIndex);
                if (this.option("grouping.allowCollapsing") && isGroupRow($row) || this.option("masterDetail.enabled") && $cell && $cell.hasClass(DATAGRID_COMMAND_EXPAND_CLASS)) {
                    var key = this._dataController.getKeyByRowIndex(rowIndex),
                        item = this._dataController.items()[rowIndex];
                    if (key !== undefined && item && item.data && !item.data.isContinuation)
                        this._dataController.changeRowExpand(key)
                }
                else if (isEditing) {
                    $cell = this._getCellElementFromTarget(eventArgs.originalEvent.target);
                    this._updateFocusedCellPosition($cell);
                    if (this._isRowEditMode()) {
                        this._focusEditFormCell($cell);
                        setTimeout($.proxy(this._editingController.saveEditData, this._editingController))
                    }
                    else
                        this._editingController.closeEditCell()
                }
                else {
                    var column = this._columnsController.getVisibleColumns()[this._focusedCellPosition.columnIndex];
                    if (editingOptions.allowUpdating && column && column.allowEditing)
                        if (this._isRowEditMode())
                            this._editingController.editRow(rowIndex);
                        else
                            this._focusedCellPosition && this._editingController.editCell(rowIndex, this._focusedCellPosition.columnIndex)
                }
            },
            _leftRightKeysHandler: function(eventArgs, isEditing) {
                var rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
                    $row = this._focusedView && this._focusedView.getRow(rowIndex),
                    directionCode,
                    $cell;
                if (!isEditing && $row && !isGroupRow($row) && !isDetailRow($row)) {
                    directionCode = this._getDirectionCodeByKey(eventArgs.key);
                    $cell = this._getNextCell(directionCode);
                    if ($cell && this._isCellValid($cell))
                        this._focus($cell);
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _getDirectionCodeByKey: function(key) {
                var directionCode;
                if (this.option("rtlEnabled"))
                    directionCode = key === "leftArrow" ? "nextInRow" : "previousInRow";
                else
                    directionCode = key === "leftArrow" ? "previousInRow" : "nextInRow";
                return directionCode
            },
            _upDownKeysHandler: function(eventArgs, isEditing) {
                var rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
                    $row = this._focusedView && this._focusedView.getRow(rowIndex),
                    $cell;
                if (!isEditing && !isDetailRow($row)) {
                    if (rowIndex === 0 || this._focusedView && rowIndex === this._focusedView.getRowsCount() - 1);
                    $cell = this._getNextCell(eventArgs.key);
                    if ($cell && this._isCellValid($cell))
                        this._focus($cell);
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _pageUpKeyHandler: function(eventArgs) {
                var scrollingMode = this.option("scrolling.mode"),
                    pageIndex = this._dataController.pageIndex(),
                    isVirtualScrolling = scrollingMode === "virtual" || scrollingMode === "infinite";
                if (pageIndex > 0 && !isVirtualScrolling) {
                    this._dataController.pageIndex(pageIndex - 1);
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _pageDownKeyHandler: function(eventArgs) {
                var scrollingMode = this.option("scrolling.mode"),
                    isVirtualScrolling = scrollingMode === "virtual" || scrollingMode === "infinite",
                    pageIndex = this._dataController.pageIndex(),
                    pageCount = this._dataController.pageCount();
                if (pageIndex < pageCount - 1 && !isVirtualScrolling) {
                    this._dataController.pageIndex(pageIndex + 1);
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _spaceKeyHandler: function(eventArgs, isEditing) {
                var rowIndex = this._focusedCellPosition ? this._focusedCellPosition.rowIndex : null,
                    $target = $(eventArgs.originalEvent && eventArgs.originalEvent.target);
                if (this.option("selection") && this.option("selection").mode !== "none" && !isEditing && ($target.parent().hasClass(DATAGRID_DATA_ROW_CLASS) || $target.hasClass(DATAGRID_ROWS_VIEW_CLASS))) {
                    this._selectionController.changeItemSelection(rowIndex, {
                        shift: eventArgs.shift,
                        control: eventArgs.ctrl
                    });
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _crtlAKeyHandler: function(eventArgs, isEditing) {
                if (!isEditing && eventArgs.ctrl && this.option("selection.mode") === "multiple" && this.option("selection.allowSelectAll")) {
                    this._selectionController.selectAll();
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _tabKeyHandler: function(eventArgs, isEditing) {
                var editingOptions = this.option("editing"),
                    direction = eventArgs.shift ? "previous" : "next",
                    isOriginalHandlerRequired = !eventArgs.shift && this._isLastValidCell(this._focusedCellPosition) || eventArgs.shift && this._isFirstValidCell(this._focusedCellPosition),
                    eventTarget = eventArgs.originalEvent.target,
                    $masterDetailCell = $(eventTarget).closest("." + DATAGRID_MASTER_DETAIL_CELL_CLASS),
                    $masterDetailGrid = $masterDetailCell.closest(DATAGRID_CLASS_SELECTOR).parent(),
                    $cell;
                if ($masterDetailCell.length && $masterDetailGrid.is(this.component.element())) {
                    this._updateFocusedCellPosition($masterDetailCell);
                    $cell = this._getNextCell(direction, null, null, true);
                    $cell.attr("tabindex", 0);
                    return
                }
                if (editingOptions && eventTarget && !isOriginalHandlerRequired) {
                    if ($(eventTarget).hasClass(DATAGRID_ROWS_VIEW_CLASS))
                        this._resetFocusedCell();
                    if (isEditing) {
                        var column,
                            isEditingAllowed;
                        this._updateFocusedCellPosition(this._getCellElementFromTarget(eventTarget));
                        $cell = this._getNextCell(direction);
                        column = this._columnsController.getVisibleColumns()[this.getView("rowsView").getCellIndex($cell)];
                        isEditingAllowed = editingOptions.allowUpdating && column.allowEditing;
                        if (!isEditingAllowed)
                            this._editingController.closeEditCell();
                        if (this._focusCell($cell))
                            if (!this._isRowEditMode() && isEditingAllowed)
                                this._editingController.editCell(this._focusedCellPosition.rowIndex, this._focusedCellPosition.columnIndex);
                            else
                                this._focusInteractiveElement($cell, eventArgs.shift)
                    }
                    else {
                        $cell = this._getNextCell(direction, this._getElementType(eventTarget));
                        this._focusCell($cell)
                    }
                }
                if (isOriginalHandlerRequired) {
                    this.getController("editorFactory").loseFocus();
                    if (this._editingController.isEditing() && !this._isRowEditMode()) {
                        this._resetFocusedCell();
                        this._editingController.closeEditCell()
                    }
                }
                else
                    eventArgs.originalEvent.preventDefault()
            },
            _focusCell: function($cell) {
                if (this._isCellValid($cell)) {
                    this._focus($cell);
                    return true
                }
            },
            _getElementType: function(target) {
                return $(target).is("tr") ? "row" : "cell"
            },
            _focusEditFormCell: function($cell) {
                if ($cell.hasClass(DATAGRID_MASTER_DETAIL_CELL_CLASS))
                    this.getController("editorFactory").focus($cell, true)
            },
            _escapeKeyHandler: function(eventArgs, isEditing) {
                if (isEditing) {
                    var $cell = this._getCellElementFromTarget(eventArgs.originalEvent.target);
                    this._updateFocusedCellPosition($cell);
                    if (!this._isRowEditMode())
                        this._editingController.closeEditCell();
                    else {
                        this._focusEditFormCell($cell);
                        this._editingController.cancelEditData()
                    }
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _ctrlFKeyHandler: function(eventArgs) {
                if (eventArgs.ctrl && this.option("searchPanel") && this.option("searchPanel").visible) {
                    this._testHeaderPanelFocused = true;
                    this._headerPanel.focus();
                    eventArgs.originalEvent.preventDefault()
                }
            },
            _keyDownHandler: function(e) {
                var isEditing = this._editingController.isEditing(),
                    args = {
                        handled: false,
                        jQueryEvent: e.originalEvent
                    };
                this.executeAction("onKeyDown", args);
                if (e.originalEvent.isDefaultPrevented())
                    return;
                this._isNeedFocus = true;
                this._isNeedScroll = true;
                if (!args.handled) {
                    switch (e.key) {
                        case"leftArrow":
                        case"rightArrow":
                            this._leftRightKeysHandler(e, isEditing);
                            break;
                        case"upArrow":
                        case"downArrow":
                            this._upDownKeysHandler(e, isEditing);
                            break;
                        case"pageUp":
                            this._pageUpKeyHandler(e);
                            break;
                        case"pageDown":
                            this._pageDownKeyHandler(e);
                            break;
                        case"space":
                            this._spaceKeyHandler(e, isEditing);
                            break;
                        case"A":
                            this._crtlAKeyHandler(e, isEditing);
                            break;
                        case"tab":
                            this._tabKeyHandler(e, isEditing);
                            break;
                        case"enter":
                            this._enterKeyHandler(e, isEditing);
                            break;
                        case"escape":
                            this._escapeKeyHandler(e, isEditing);
                            break;
                        case"F":
                            this._ctrlFKeyHandler(e);
                            break
                    }
                    e.originalEvent.stopPropagation()
                }
            },
            _isLastRow: function(rowIndex) {
                return rowIndex === this.getController("data").items().length - 1
            },
            _getNextCell: function(keyCode, elementType, cellPosition) {
                var focusedCellPosition = cellPosition || this._focusedCellPosition,
                    includeCommandCells = $.inArray(keyCode, ["next", "previous"]) > -1,
                    rowIndex,
                    newFocusedCellPosition,
                    $cell,
                    $row;
                if (this._focusedView && focusedCellPosition) {
                    newFocusedCellPosition = this._getNewPositionByCode({
                        columnIndex: focusedCellPosition.columnIndex,
                        rowIndex: focusedCellPosition.rowIndex
                    }, elementType, keyCode);
                    $cell = this._focusedView.getCell(newFocusedCellPosition);
                    if (!this._isCellValid($cell) && this._isCellInRow(newFocusedCellPosition, includeCommandCells))
                        $cell = this._getNextCell(keyCode, "cell", newFocusedCellPosition);
                    $row = $cell && $cell.parent();
                    if (this._hasSkipRow($row)) {
                        rowIndex = this._focusedView.getRowIndex($row);
                        if (!this._isLastRow(rowIndex))
                            $cell = this._getNextCell(keyCode, "row", {
                                columnIndex: focusedCellPosition.columnIndex,
                                rowIndex: rowIndex
                            });
                        else
                            return null
                    }
                    return $cell
                }
                return null
            },
            _getNewPositionByCode: function(cellPosition, elementType, code) {
                var columnIndex = cellPosition.columnIndex,
                    rowIndex = cellPosition.rowIndex,
                    visibleColumnsCount;
                if (cellPosition.rowIndex === undefined && code === "next")
                    return {
                            columnIndex: 0,
                            rowIndex: 0
                        };
                switch (code) {
                    case"nextInRow":
                    case"next":
                        visibleColumnsCount = this._getVisibleColumnCount(rowIndex);
                        if (columnIndex < visibleColumnsCount - 1 && !this._isLastValidCell({
                            columnIndex: columnIndex,
                            rowIndex: rowIndex
                        }) && elementType !== "row")
                            columnIndex++;
                        else if (!this._isLastRow(rowIndex) && code === "next") {
                            columnIndex = 0;
                            rowIndex++
                        }
                        break;
                    case"previousInRow":
                    case"previous":
                        if (columnIndex > 0 && !this._isFirstValidCell({
                            columnIndex: columnIndex,
                            rowIndex: rowIndex
                        }) && elementType !== "row")
                            columnIndex--;
                        else if (rowIndex > 0 && code === "previous") {
                            rowIndex--;
                            visibleColumnsCount = this._getVisibleColumnCount(rowIndex);
                            columnIndex = visibleColumnsCount - 1
                        }
                        break;
                    case"upArrow":
                        rowIndex = rowIndex > 0 ? rowIndex - 1 : rowIndex;
                        break;
                    case"downArrow":
                        rowIndex = !this._isLastRow(rowIndex) ? rowIndex + 1 : rowIndex;
                        break
                }
                return {
                        columnIndex: columnIndex,
                        rowIndex: rowIndex
                    }
            },
            _isFirstValidCell: function(cellPosition) {
                var isFirstValidCell = false;
                if (cellPosition.rowIndex === 0 && cellPosition.columnIndex >= 0)
                    isFirstValidCell = isFirstValidCell || !this._haveValidCellBeforePosition(cellPosition);
                return isFirstValidCell
            },
            _haveValidCellBeforePosition: function(cellPosition) {
                var columnIndex = cellPosition.columnIndex,
                    hasValidCells = false;
                while (columnIndex > 0 && !hasValidCells) {
                    var checkingPosition = {
                            columnIndex: --columnIndex,
                            rowIndex: cellPosition.rowIndex
                        };
                    hasValidCells = this._isCellByPositionValid(checkingPosition)
                }
                return hasValidCells
            },
            _isLastValidCell: function(cellPosition) {
                var checkingPosition = {
                        columnIndex: cellPosition.columnIndex + 1,
                        rowIndex: cellPosition.rowIndex
                    },
                    visibleColumnsCount = this._getVisibleColumnCount(cellPosition.rowIndex),
                    isCheckingCellValid = this._isCellByPositionValid(checkingPosition);
                if (!this._isLastRow(cellPosition.rowIndex))
                    return false;
                if (cellPosition.columnIndex === visibleColumnsCount - 1)
                    return true;
                if (isCheckingCellValid)
                    return false;
                return this._isLastValidCell(checkingPosition)
            },
            _getVisibleColumnCount: function(rowIndex) {
                var row = this.getController("data").items()[rowIndex],
                    visibleColumns = this.getController("columns").getVisibleColumns(),
                    visibleColumnCount = 0;
                if (row && row.rowType === "detail") {
                    while (visibleColumns[visibleColumnCount] && visibleColumns[visibleColumnCount].command)
                        visibleColumnCount++;
                    visibleColumnCount++
                }
                else
                    visibleColumnCount = visibleColumns.length;
                return visibleColumnCount
            },
            _isCellInRow: function(cellPosition, includeCommandCells) {
                var columnIndex = cellPosition.columnIndex,
                    visibleColumnsCount = this._getVisibleColumnCount(cellPosition.rowIndex);
                return includeCommandCells ? columnIndex >= 0 && columnIndex <= visibleColumnsCount - 1 : columnIndex > 0 && columnIndex < visibleColumnsCount - 1
            },
            _resetFocusedCell: function() {
                var that = this,
                    $cell = that._getFocusedCell();
                $cell && $cell.attr("tabindex", null);
                that._isNeedFocus = false;
                that._isNeedScroll = false;
                that._focusedCellPosition = {}
            },
            _getCellElementFromTarget: function(target) {
                return $(target).closest("." + DATAGRID_ROW_CLASS + "> td")
            },
            init: function() {
                var that = this;
                if (that.option("useKeyboard")) {
                    that._dataController = that.getController("data");
                    that._selectionController = that.getController("selection");
                    that._editingController = that.getController("editing");
                    that._headerPanel = that.getView("headerPanel");
                    that._columnsController = that.getController("columns");
                    that.getController("editorFactory").focused.add(function($element) {
                        that.setupFocusedView();
                        if (that._isNeedScroll)
                            if ($element.is(":visible") && that._focusedView && that._focusedView.getScrollable) {
                                that._scrollToElement($element);
                                that._isNeedScroll = false
                            }
                    });
                    that._focusedCellPosition = {};
                    that._dataController.changed.add(function(change) {
                        if (that._focusedCellPosition && change && change.changeType === "prepend")
                            that._focusedCellPosition.rowIndex += change.items.length
                    });
                    that._initFocusedViews();
                    that._documentClickHandler = that.createAction(function(e) {
                        if (!$(e.jQueryEvent.target).closest("." + DATAGRID_ROWS_VIEW_CLASS).length)
                            that._resetFocusedCell()
                    });
                    that.createAction("onKeyDown");
                    $(document).on(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), that._documentClickHandler)
                }
            },
            _scrollToElement: function($element, offset) {
                this._focusedView.getScrollable().scrollToElement($element, offset)
            },
            focus: function($element) {
                var focusView = this._getFocusedViewByElement($element);
                if (focusView) {
                    this._focusView(focusView.view, focusView.viewIndex);
                    this._isNeedFocus = true;
                    this._isNeedScroll = true;
                    this._focus($element);
                    this._isHeaderView(focusView.view.name) && this._focusInteractiveElement($element)
                }
            },
            getFocusedView: function() {
                return this._focusedView
            },
            _getFocusedViewByElement: function($element) {
                var condition = function(view) {
                        return $element.closest(view._$element).length
                    };
                return this._getFocusedViewByCondition(condition)
            },
            _getFocusedViewByCondition: function(conditionFunction) {
                var focusView;
                $.each(this._focusedViews, function(index, view) {
                    if (conditionFunction(view)) {
                        focusView = {
                            viewIndex: index,
                            view: view
                        };
                        return false
                    }
                });
                return focusView
            },
            _isHeaderView: function(viewName) {
                return viewName === "columnHeadersView"
            },
            focusViewByName: function(viewName) {
                var view = this._getFocusedViewByName(viewName);
                this._focusView(view.view, view.viewIndex)
            },
            setupFocusedView: function() {
                if (!commonUtils.isDefined(this._focusedView))
                    this.focusViewByName("rowsView")
            },
            _getFocusedViewByName: function(viewName) {
                var condition = function(view) {
                        return view.name === viewName
                    };
                return this._getFocusedViewByCondition(condition)
            },
            optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"useKeyboard":
                        args.handled = true;
                        break;
                    default:
                        that.callBase(args)
                }
            },
            dispose: function() {
                this.callBase();
                this._focusedView = null;
                this._focusedViews = null;
                this._keyDownProcessor && this._keyDownProcessor.dispose();
                $(document).off(eventUtils.addNamespace(pointerEvents.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler)
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_GROUP_ROW_CLASS: DATAGRID_GROUP_ROW_CLASS,
            DATAGRID_ROW_CLASS: DATAGRID_ROW_CLASS
        });
        dataGrid.registerModule("keyboardNavigation", {
            defaultOptions: function() {
                return {useKeyboard: true}
            },
            controllers: {keyboardNavigation: dataGrid.KeyboardNavigationController},
            extenders: {
                views: {rowsView: {_renderCore: function(change) {
                            this.callBase(change);
                            this.element().attr("tabindex", this.option("useKeyboard") ? 0 : null)
                        }}},
                controllers: {editing: {
                        editCell: function(rowIndex, columnIndex) {
                            var isCellEditing = this.callBase(rowIndex, columnIndex),
                                keyboardNavigationController = this.getController("keyboardNavigation");
                            if (isCellEditing)
                                keyboardNavigationController.setupFocusedView();
                            return isCellEditing
                        },
                        getFocusedCellInRow: function(rowIndex) {
                            var keyboardNavigationController = this.getController("keyboardNavigation"),
                                $cell = this.callBase(rowIndex);
                            if (this.option("useKeyboard") && keyboardNavigationController._focusedCellPosition.rowIndex === rowIndex)
                                $cell = keyboardNavigationController._getFocusedCell() || $cell;
                            return $cell
                        }
                    }}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.errorHandling.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid;
        var DATAGRID_ERROR_ROW_CLASS = "dx-error-row",
            DATAGRID_ERROR_MESSAGE_CLASS = "dx-error-message",
            DATAGRID_ERROR_CLOSEBUTTON_CLASS = "dx-closebutton",
            DATAGRID_ACTION_CLASS = "dx-datagrid-action";
        dataGrid.ErrorHandlingController = dataGrid.ViewController.inherit({
            init: function() {
                var that = this;
                that._columnHeadersView = that.getView("columnHeadersView");
                that._rowsView = that.getView("rowsView")
            },
            _createErrorRow: function(message, $tableElements) {
                var that = this,
                    $errorRow = $("<tr />").addClass(DATAGRID_ERROR_ROW_CLASS),
                    $errorMessage = $("<div/>").addClass(DATAGRID_ERROR_MESSAGE_CLASS).text(message),
                    $closeButton = $("<div/>").addClass(DATAGRID_ERROR_CLOSEBUTTON_CLASS).addClass(DATAGRID_ACTION_CLASS);
                $closeButton.on("dxclick", that.createAction(function(args) {
                    var e = args.jQueryEvent,
                        $errorRow,
                        errorRowIndex = $(e.currentTarget).closest("." + DATAGRID_ERROR_ROW_CLASS).index();
                    e.stopPropagation();
                    $.each($tableElements, function(_, tableElement) {
                        $errorRow = $(tableElement).find("tbody > tr").eq(errorRowIndex);
                        that.removeErrorRow($errorRow)
                    })
                }));
                $("<td/>").attr({
                    colspan: that.getController("columns").getVisibleColumns().length,
                    role: "presentation"
                }).prepend($closeButton).append($errorMessage).appendTo($errorRow);
                return $errorRow
            },
            renderErrorRow: function(message, rowIndex) {
                var that = this,
                    $row,
                    $errorRow,
                    rowElements,
                    viewElement = rowIndex >= 0 ? that._rowsView : that._columnHeadersView,
                    $tableElements = viewElement.getTableElements();
                $.each($tableElements, function(_, tableElement) {
                    $errorRow = that._createErrorRow(message, $tableElements);
                    rowElements = $(tableElement).find("tr");
                    if (rowIndex >= 0) {
                        $row = viewElement._getRowElements($(tableElement)).eq(rowIndex);
                        that.removeErrorRow(rowElements.eq($row.index() + 1));
                        $errorRow.insertAfter($row)
                    }
                    else {
                        that.removeErrorRow(rowElements.last());
                        $(tableElement).append($errorRow)
                    }
                })
            },
            removeErrorRow: function($row) {
                var $columnHeaders = this._columnHeadersView && this._columnHeadersView.element();
                $row = $row || $columnHeaders && $columnHeaders.find("." + DATAGRID_ERROR_ROW_CLASS);
                $row && $row.hasClass(DATAGRID_ERROR_ROW_CLASS) && $row.remove()
            },
            optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"errorRowEnabled":
                        args.handled = true;
                        break;
                    default:
                        that.callBase(args)
                }
            }
        });
        dataGrid.registerModule("errorHandling", {
            defaultOptions: function() {
                return {errorRowEnabled: true}
            },
            controllers: {errorHandling: dataGrid.ErrorHandlingController},
            extenders: {controllers: {data: {init: function() {
                            var that = this,
                                errorHandlingController = that.getController("errorHandling");
                            that.callBase();
                            that.dataErrorOccurred.add(function(error) {
                                var message = error && error.message || error;
                                if (that.option("errorRowEnabled"))
                                    errorHandlingController.renderErrorRow(message)
                            });
                            that.changed.add(function() {
                                var errorHandlingController = that.getController("errorHandling"),
                                    editingController = that.getController("editing");
                                if (editingController && !editingController.hasChanges())
                                    errorHandlingController && errorHandlingController.removeErrorRow()
                            })
                        }}}}
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.summaryModule.js */
    (function($, DX) {
        var ui = DX.ui,
            errors = DevExpress.require("/ui/ui.errors"),
            commonUtils = DX.require("/utils/utils.common"),
            dataGrid = ui.dxDataGrid,
            normalizeSortingInfo = DX.data.utils.normalizeSortingInfo;
        var DATAGRID_TOTAL_FOOTER_CLASS = "dx-datagrid-total-footer",
            DATAGRID_SUMMARY_ITEM_CLASS = "dx-datagrid-summary-item",
            DATAGRID_TEXT_CONTENT_CLASS = "dx-datagrid-text-content",
            DATAGRID_GROUP_FOOTER_CLASS = "dx-datagrid-group-footer",
            DATAGRID_GROUP_TEXT_CONTENT_CLASS = "dx-datagrid-group-text-content",
            DATAGRID_GROUP_FOOTER_ROW_TYPE = "groupFooter";
        var renderSummaryCell = function($cell, options) {
                var i,
                    column = options.column,
                    summaryItems = options.summaryItems,
                    summaryItem,
                    $summaryItems = [];
                if (!column.command && summaryItems) {
                    for (i = 0; i < summaryItems.length; i++) {
                        summaryItem = summaryItems[i];
                        $summaryItems.push($("<div>").css("text-align", summaryItem.alignment || column.alignment).addClass(DATAGRID_SUMMARY_ITEM_CLASS).addClass(DATAGRID_TEXT_CONTENT_CLASS).addClass(summaryItem.cssClass).toggleClass(DATAGRID_GROUP_TEXT_CONTENT_CLASS, options.rowType === "group").text(dataGrid.getSummaryText(summaryItem, options.summaryTexts)))
                    }
                    $cell.append($summaryItems)
                }
            },
            getSummaryCellOptions = function(that, options) {
                var summaryTexts = that.option("summary.texts") || {};
                return {
                        totalItem: options.row,
                        summaryItems: options.row.summaryCells[options.columnIndex],
                        summaryTexts: summaryTexts
                    }
            };
        var getGroupAggregates = function(data) {
                return data.summary || data.aggregates || []
            };
        dataGrid.FooterView = dataGrid.ColumnsView.inherit(function() {
            return {
                    _getRows: function() {
                        return this._dataController.footerItems()
                    },
                    _getCellOptions: function(options) {
                        return $.extend(this.callBase(options), getSummaryCellOptions(this, options))
                    },
                    _renderCellContent: function($cell, options) {
                        renderSummaryCell($cell, options);
                        this.callBase($cell, options)
                    },
                    _renderCore: function() {
                        var totalItem = this._dataController.footerItems()[0];
                        this.element().empty().addClass(DATAGRID_TOTAL_FOOTER_CLASS);
                        if (totalItem && totalItem.summaryCells && totalItem.summaryCells.length)
                            this._updateContent(this._renderTable())
                    },
                    _rowClick: function(e) {
                        var item = this._dataController.footerItems()[e.rowIndex] || {};
                        this.executeAction("onRowClick", $.extend({}, e, item))
                    },
                    _columnOptionChanged: function(e) {
                        var optionNames = e.optionNames;
                        if (e.changeTypes.grouping)
                            return;
                        if (optionNames.width || optionNames.visibleWidth)
                            this.callBase(e)
                    },
                    _handleDataChanged: function(e) {
                        if (e.changeType === "refresh")
                            this.render()
                    },
                    getHeight: function() {
                        var $element = this.element();
                        return $element ? $element.outerHeight() : 0
                    },
                    isVisible: function() {
                        return !!this._dataController.footerItems().length
                    }
                }
        }());
        var SummaryDataSourceAdapterExtender = function() {
                return {
                        init: function() {
                            this.callBase.apply(this, arguments);
                            this._totalAggregates = []
                        },
                        summary: function(summary) {
                            if (!arguments.length)
                                return this._summary;
                            this._summary = summary
                        },
                        totalAggregates: function() {
                            return this._totalAggregates
                        }
                    }
            }();
        var SummaryDataSourceAdapterClientExtender = function() {
                var calculateAggregates = function(that, summary, data, groupLevel) {
                        var calculator;
                        if (summary) {
                            calculator = new DX.data.AggregateCalculator({
                                totalAggregates: summary.totalAggregates,
                                groupAggregates: summary.groupAggregates,
                                data: data,
                                groupLevel: groupLevel
                            });
                            calculator.calculate()
                        }
                        return calculator ? calculator.totalAggregates() : []
                    };
                var sortGroupsBySummaryCore = function(items, groups, sortByGroups) {
                        if (!items || !groups.length)
                            return items;
                        var group = groups[0],
                            sorts = sortByGroups[0],
                            query;
                        if (group && sorts && sorts.length) {
                            query = DX.data.query(items);
                            $.each(sorts, function(index) {
                                if (index === 0)
                                    query = query.sortBy(this.selector, this.desc);
                                else
                                    query = query.thenBy(this.selector, this.desc)
                            });
                            query.enumerate().done(function(sortedItems) {
                                items = sortedItems
                            })
                        }
                        groups = groups.slice(1);
                        sortByGroups = sortByGroups.slice(1);
                        if (groups.length && sortByGroups.length)
                            $.each(items, function() {
                                this.items = sortGroupsBySummaryCore(this.items, groups, sortByGroups)
                            });
                        return items
                    };
                var sortGroupsBySummary = function(data, group, summary) {
                        var sortByGroups = summary && summary.sortByGroups && summary.sortByGroups();
                        if (sortByGroups && sortByGroups.length)
                            return sortGroupsBySummaryCore(data, group, sortByGroups);
                        return data
                    };
                return {
                        _customizeRemoteOperations: function(options) {
                            var summary = this.summary();
                            if (summary)
                                if (options.remoteOperations.summary) {
                                    if (!options.isCustomLoading || options.storeLoadOptions.isLoadingAll) {
                                        if (options.storeLoadOptions.group)
                                            if (options.remoteOperations.grouping)
                                                options.storeLoadOptions.groupSummary = summary.groupAggregates;
                                            else if (summary.groupAggregates.length)
                                                options.remoteOperations.paging = false;
                                        options.storeLoadOptions.totalSummary = summary.totalAggregates
                                    }
                                }
                                else if (summary.totalAggregates.length || summary.groupAggregates.length && options.storeLoadOptions.group)
                                    options.remoteOperations.paging = false;
                            this.callBase.apply(this, arguments)
                        },
                        _handleDataLoadedCore: function(options) {
                            var that = this,
                                groups = normalizeSortingInfo(options.loadOptions.group || []),
                                summary = that.summary(),
                                totalAggregates,
                                remoteOperations = options.remoteOperations || {};
                            if (remoteOperations.summary) {
                                if (!remoteOperations.paging && !remoteOperations.grouping && groups.length && summary) {
                                    calculateAggregates(that, {groupAggregates: summary.groupAggregates}, options.data, groups.length);
                                    options.data = sortGroupsBySummary(options.data, groups, summary)
                                }
                                that._totalAggregates = options.extra && options.extra.summary || that._totalAggregates
                            }
                            else if (!remoteOperations.paging) {
                                totalAggregates = calculateAggregates(that, summary, options.data, groups.length);
                                options.data = sortGroupsBySummary(options.data, groups, summary);
                                options.extra = options.extra || {};
                                that._totalAggregates = options.extra.summary = totalAggregates
                            }
                            that.callBase(options)
                        }
                    }
            }();
        dataGrid.DataSourceAdapter = dataGrid.DataSourceAdapter.inherit(SummaryDataSourceAdapterExtender).inherit(SummaryDataSourceAdapterClientExtender);
        dataGrid.renderSummaryCell = renderSummaryCell;
        $.extend(dataGrid.__internals, {
            DATAGRID_TOTAL_FOOTER_CLASS: DATAGRID_TOTAL_FOOTER_CLASS,
            DATAGRID_SUMMARY_ITEM_CLASS: DATAGRID_SUMMARY_ITEM_CLASS,
            DATAGRID_GROUP_FOOTER_CLASS: DATAGRID_GROUP_FOOTER_CLASS
        });
        dataGrid.registerModule("summary", {
            defaultOptions: function() {
                return {
                        summary: {
                            groupItems: undefined,
                            totalItems: undefined,
                            calculateCustomSummary: undefined,
                            skipEmptyValues: true,
                            texts: {
                                sum: Globalize.localize("dxDataGrid-summarySum"),
                                sumOtherColumn: Globalize.localize("dxDataGrid-summarySumOtherColumn"),
                                min: Globalize.localize("dxDataGrid-summaryMin"),
                                minOtherColumn: Globalize.localize("dxDataGrid-summaryMinOtherColumn"),
                                max: Globalize.localize("dxDataGrid-summaryMax"),
                                maxOtherColumn: Globalize.localize("dxDataGrid-summaryMaxOtherColumn"),
                                avg: Globalize.localize("dxDataGrid-summaryAvg"),
                                avgOtherColumn: Globalize.localize("dxDataGrid-summaryAvgOtherColumn"),
                                count: Globalize.localize("dxDataGrid-summaryCount")
                            }
                        },
                        sortByGroupSummaryInfo: undefined
                    }
            },
            views: {footerView: dataGrid.FooterView},
            extenders: {
                controllers: {data: function() {
                        return {
                                _isDataColumn: function(column) {
                                    return column && (!commonUtils.isDefined(column.groupIndex) || column.showWhenGrouped)
                                },
                                _isGroupFooterVisible: function() {
                                    var groupItems = this.option("summary.groupItems") || [],
                                        groupItem,
                                        column,
                                        i;
                                    for (i = 0; i < groupItems.length; i++) {
                                        groupItem = groupItems[i];
                                        column = this._columnsController.columnOption(groupItem.showInColumn || groupItem.column);
                                        if (groupItem.showInGroupFooter && this._isDataColumn(column))
                                            return true
                                    }
                                    return false
                                },
                                _processGroupItems: function(items, groupCount, options) {
                                    var result = this.callBase.apply(this, arguments);
                                    if (options) {
                                        if (options.isGroupFooterVisible === undefined)
                                            options.isGroupFooterVisible = this._isGroupFooterVisible();
                                        if (options.data && options.data.items && options.isGroupFooterVisible && (options.collectContinuationItems || !options.data.isContinuationOnNextPage))
                                            result.push({
                                                rowType: DATAGRID_GROUP_FOOTER_ROW_TYPE,
                                                data: options.data,
                                                groupIndex: options.path.length - 1,
                                                values: []
                                            })
                                    }
                                    return result
                                },
                                _processGroupItem: function(groupItem, options) {
                                    var that = this;
                                    if (!options.summaryGroupItems)
                                        options.summaryGroupItems = that.option("summary.groupItems") || [];
                                    if (groupItem.rowType === "group") {
                                        var groupColumnIndex = -1,
                                            afterGroupColumnIndex = -1;
                                        $.each(options.visibleColumns, function(visibleIndex) {
                                            var prevColumn = options.visibleColumns[visibleIndex - 1];
                                            if (groupItem.groupIndex === this.groupIndex)
                                                groupColumnIndex = this.index;
                                            if (visibleIndex > 0 && prevColumn.command === "expand" && this.command !== "expand")
                                                afterGroupColumnIndex = this.index
                                        });
                                        groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, getGroupAggregates(groupItem.data), options.visibleColumns, function(summaryItem, column) {
                                            if (summaryItem.showInGroupFooter)
                                                return -1;
                                            if (summaryItem.alignByColumn && column && !commonUtils.isDefined(column.groupIndex) && column.index !== afterGroupColumnIndex)
                                                return column.index;
                                            else
                                                return groupColumnIndex
                                        })
                                    }
                                    if (groupItem.rowType === DATAGRID_GROUP_FOOTER_ROW_TYPE)
                                        groupItem.summaryCells = this._calculateSummaryCells(options.summaryGroupItems, getGroupAggregates(groupItem.data), options.visibleColumns, function(summaryItem, column) {
                                            return summaryItem.showInGroupFooter && that._isDataColumn(column) ? column.index : -1
                                        });
                                    return groupItem
                                },
                                _calculateSummaryCells: function(summaryItems, aggregates, visibleColumns, calculateTargetColumnIndex) {
                                    var that = this,
                                        summaryCells = [],
                                        summaryCellsByColumns = {};
                                    $.each(summaryItems, function(summaryIndex, summaryItem) {
                                        var column = that._columnsController.columnOption(summaryItem.column),
                                            showInColumn = summaryItem.showInColumn && that._columnsController.columnOption(summaryItem.showInColumn) || column,
                                            columnIndex = calculateTargetColumnIndex(summaryItem, showInColumn),
                                            aggregate;
                                        if (columnIndex >= 0) {
                                            if (!summaryCellsByColumns[columnIndex])
                                                summaryCellsByColumns[columnIndex] = [];
                                            aggregate = aggregates[summaryIndex];
                                            if (aggregate === aggregate)
                                                summaryCellsByColumns[columnIndex].push($.extend({}, summaryItem, {
                                                    value: aggregate,
                                                    valueFormat: !commonUtils.isDefined(summaryItem.valueFormat) ? dataGrid.getFormatByDataType(column && column.dataType) : summaryItem.valueFormat,
                                                    columnCaption: column && column.index !== columnIndex ? column.caption : undefined
                                                }))
                                        }
                                    });
                                    if (!$.isEmptyObject(summaryCellsByColumns))
                                        $.each(visibleColumns, function() {
                                            summaryCells.push(summaryCellsByColumns[this.index] || [])
                                        });
                                    return summaryCells
                                },
                                _getSummaryCells: function(summaryTotalItems, totalAggregates) {
                                    var that = this,
                                        columnsController = that._columnsController;
                                    return that._calculateSummaryCells(summaryTotalItems, totalAggregates, columnsController.getVisibleColumns(), function(summaryItem, column) {
                                            return that._isDataColumn(column) ? column.index : -1
                                        })
                                },
                                _updateItemsCore: function(change) {
                                    var that = this,
                                        summaryCells,
                                        totalAggregates,
                                        dataSource = that._dataSource,
                                        summaryTotalItems = that.option("summary.totalItems");
                                    that.callBase(change);
                                    that._footerItems = [];
                                    if (dataSource && summaryTotalItems && summaryTotalItems.length) {
                                        totalAggregates = dataSource.totalAggregates();
                                        summaryCells = this._getSummaryCells(summaryTotalItems, totalAggregates);
                                        if (summaryCells.length)
                                            that._footerItems.push({
                                                rowType: "totalFooter",
                                                summaryCells: summaryCells
                                            })
                                    }
                                },
                                _getAggregates: function(summaryItems, remoteOperations) {
                                    var that = this,
                                        columnsController = that.getController("columns"),
                                        calculateCustomSummary = that.option("summary.calculateCustomSummary"),
                                        commonSkipEmptyValues = that.option("summary.skipEmptyValues");
                                    return $.map(summaryItems || [], function(summaryItem) {
                                            var column = columnsController.columnOption(summaryItem.column),
                                                calculateCellValue = column && column.calculateCellValue ? $.proxy(column, "calculateCellValue") : DX.data.utils.compileGetter(column ? column.dataField : summaryItem.column),
                                                aggregator = summaryItem.summaryType || "count",
                                                selector = summaryItem.column,
                                                skipEmptyValues = commonUtils.isDefined(summaryItem.skipEmptyValues) ? summaryItem.skipEmptyValues : commonSkipEmptyValues,
                                                options;
                                            if (remoteOperations)
                                                return {
                                                        selector: summaryItem.column,
                                                        summaryType: summaryItem.summaryType
                                                    };
                                            else {
                                                if (aggregator === "avg" || aggregator === "sum")
                                                    selector = function(data) {
                                                        var value = calculateCellValue(data);
                                                        return commonUtils.isDefined(value) ? Number(value) : value
                                                    };
                                                else
                                                    selector = calculateCellValue;
                                                if (aggregator === "custom") {
                                                    if (!calculateCustomSummary) {
                                                        errors.log("E1026");
                                                        calculateCustomSummary = function(){}
                                                    }
                                                    options = {
                                                        component: that.component,
                                                        name: summaryItem.name
                                                    };
                                                    calculateCustomSummary(options);
                                                    options.summaryProcess = "calculate";
                                                    aggregator = {
                                                        seed: function() {
                                                            options.summaryProcess = "start";
                                                            options.totalValue = undefined;
                                                            delete options.value;
                                                            calculateCustomSummary(options);
                                                            return options.totalValue
                                                        },
                                                        step: function(totalValue, value) {
                                                            options.summaryProcess = "calculate";
                                                            options.totalValue = totalValue;
                                                            options.value = value;
                                                            calculateCustomSummary(options);
                                                            return options.totalValue
                                                        },
                                                        finalize: function(totalValue) {
                                                            options.summaryProcess = "finalize";
                                                            options.totalValue = totalValue;
                                                            delete options.value;
                                                            calculateCustomSummary(options);
                                                            return options.totalValue
                                                        }
                                                    }
                                                }
                                                return {
                                                        selector: selector,
                                                        aggregator: aggregator,
                                                        skipEmptyValues: skipEmptyValues
                                                    }
                                            }
                                        })
                                },
                                _addSortInfo: function(sortByGroups, groupColumn, selector, sortOrder) {
                                    var groupIndex;
                                    if (groupColumn) {
                                        groupIndex = groupColumn.groupIndex;
                                        sortOrder = sortOrder || groupColumn.sortOrder;
                                        if (commonUtils.isDefined(groupIndex)) {
                                            sortByGroups[groupIndex] = sortByGroups[groupIndex] || [];
                                            sortByGroups[groupIndex].push({
                                                selector: selector,
                                                desc: sortOrder === "desc"
                                            })
                                        }
                                    }
                                },
                                _findSummaryItem: function(summaryItems, name) {
                                    var summaryItemIndex = -1;
                                    var getFullName = function(summaryItem) {
                                            var summaryType = summaryItem.summaryType,
                                                column = summaryItem.column;
                                            return summaryType && column && summaryType + "_" + column
                                        };
                                    if (commonUtils.isDefined(name))
                                        $.each(summaryItems || [], function(index) {
                                            if (this.name === name || index === name || this.summaryType === name || this.column === name || getFullName(this) === name) {
                                                summaryItemIndex = index;
                                                return false
                                            }
                                        });
                                    return summaryItemIndex
                                },
                                _getSummarySortByGroups: function(sortByGroupSummaryInfo, groupSummaryItems) {
                                    var that = this,
                                        columnsController = that._columnsController,
                                        groupColumns = columnsController.getGroupColumns(),
                                        sortByGroups = [];
                                    if (!groupSummaryItems || !groupSummaryItems.length)
                                        return;
                                    $.each(sortByGroupSummaryInfo || [], function() {
                                        var sortOrder = this.sortOrder,
                                            groupColumn = this.groupColumn,
                                            summaryItemIndex = that._findSummaryItem(groupSummaryItems, this.summaryItem);
                                        if (summaryItemIndex < 0)
                                            return;
                                        var selector = function(data) {
                                                return getGroupAggregates(data)[summaryItemIndex]
                                            };
                                        if (commonUtils.isDefined(groupColumn)) {
                                            groupColumn = columnsController.columnOption(groupColumn);
                                            that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder)
                                        }
                                        else
                                            $.each(groupColumns, function(groupIndex, groupColumn) {
                                                that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder)
                                            })
                                    });
                                    return sortByGroups
                                },
                                _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
                                    var summary = this._getSummaryOptions(remoteOperations),
                                        dataSourceAdapter = this.callBase(dataSource, remoteOperations);
                                    dataSourceAdapter.summary(summary);
                                    return dataSourceAdapter
                                },
                                _getSummaryOptions: function(remoteOperations) {
                                    var that = this,
                                        groupSummaryItems = that.option("summary.groupItems"),
                                        totalSummaryItems = that.option("summary.totalItems"),
                                        sortByGroupSummaryInfo = that.option("sortByGroupSummaryInfo"),
                                        groupAggregates = that._getAggregates(groupSummaryItems, remoteOperations && remoteOperations.grouping && remoteOperations.summary),
                                        totalAggregates = that._getAggregates(totalSummaryItems, remoteOperations && remoteOperations.summary),
                                        sortByGroups = function() {
                                            return that._getSummarySortByGroups(sortByGroupSummaryInfo, groupSummaryItems)
                                        };
                                    if (groupAggregates.length || totalAggregates.length)
                                        return {
                                                groupAggregates: groupAggregates,
                                                totalAggregates: totalAggregates,
                                                sortByGroups: sortByGroups
                                            }
                                },
                                publicMethods: function() {
                                    var methods = this.callBase();
                                    methods.push("getTotalSummaryValue");
                                    return methods
                                },
                                getTotalSummaryValue: function(summaryItemName) {
                                    var summaryItemIndex = this._findSummaryItem(this.option("summary.totalItems"), summaryItemName),
                                        aggregates = this._dataSource.totalAggregates();
                                    if (aggregates.length && summaryItemIndex > -1)
                                        return aggregates[summaryItemIndex]
                                },
                                optionChanged: function(args) {
                                    if (args.name === "summary" || args.name === "sortByGroupSummaryInfo")
                                        args.name = "dataSource";
                                    this.callBase(args)
                                },
                                init: function() {
                                    this._footerItems = [];
                                    this.callBase()
                                },
                                footerItems: function() {
                                    return this._footerItems
                                }
                            }
                    }()},
                views: {rowsView: function() {
                        return {
                                _createRow: function(row) {
                                    var $row = this.callBase(row);
                                    row && $row.addClass(row.rowType === DATAGRID_GROUP_FOOTER_ROW_TYPE ? DATAGRID_GROUP_FOOTER_CLASS : "");
                                    return $row
                                },
                                _renderCells: function($row, options) {
                                    this.callBase.apply(this, arguments);
                                    if (options.row.rowType === "group" && options.row.summaryCells && options.row.summaryCells.length)
                                        this._renderGroupSummaryCells($row, options)
                                },
                                _hasAlignByColumnSummaryItems: function(columnIndex, options) {
                                    return !commonUtils.isDefined(options.columns[columnIndex].groupIndex) && options.row.summaryCells[columnIndex].length
                                },
                                _getAlignByColumnCellCount: function(groupCellColSpan, options) {
                                    var alignByColumnCellCount = 0,
                                        columnIndex;
                                    for (var i = 1; i < groupCellColSpan; i++) {
                                        columnIndex = options.row.summaryCells.length - i;
                                        alignByColumnCellCount = this._hasAlignByColumnSummaryItems(columnIndex, options) ? i : alignByColumnCellCount
                                    }
                                    return alignByColumnCellCount
                                },
                                _renderGroupSummaryCells: function($row, options) {
                                    var $groupCell = $row.children().last(),
                                        groupCellColSpan = Number($groupCell.attr("colspan")) || 1,
                                        alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);
                                    this._renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount)
                                },
                                _renderGroupSummaryCellsCore: function($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
                                    if (alignByColumnCellCount > 0) {
                                        $groupCell.attr("colspan", groupCellColSpan - alignByColumnCellCount);
                                        for (var i = 0; i < alignByColumnCellCount; i++) {
                                            var columnIndex = options.columns.length - alignByColumnCellCount + i;
                                            this._renderCell($groupCell.parent(), $.extend({
                                                column: options.columns[columnIndex],
                                                columnIndex: columnIndex
                                            }, options))
                                        }
                                    }
                                },
                                _getColumnTemplate: function(options) {
                                    if (!options.column.command && !commonUtils.isDefined(options.column.groupIndex) && options.summaryItems && options.summaryItems.length)
                                        return renderSummaryCell;
                                    else
                                        return this.callBase(options)
                                },
                                _getCellOptions: function(options) {
                                    var that = this,
                                        parameters = that.callBase(options);
                                    if (options.row.summaryCells)
                                        return $.extend(parameters, getSummaryCellOptions(that, options));
                                    else
                                        return parameters
                                }
                            }
                    }()}
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.fixedColumns.js */
    (function($, DX, undefined) {
        var ui = DX.ui,
            browser = DX.require("/utils/utils.browser"),
            commonUtils = DX.require("/utils/utils.common"),
            wheelEvent = DX.require("/ui/events/ui.events.wheel"),
            dataGrid = ui.dxDataGrid;
        var DATAGRID_CONTENT_CLASS = "dx-datagrid-content",
            DATAGRID_MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell",
            DATAGRID_FIRST_CELL_CLASS = "dx-first-cell",
            DATAGRID_HOVER_STATE_CLASS = "dx-state-hover",
            DATAGRID_HEADER_ROW_CLASS = "dx-header-row",
            DATAGRID_CONTENT_FIXED_CLASS = "dx-datagrid-content-fixed",
            DATAGRID_FIXED_COL_CLASS = "dx-col-fixed",
            DATAGRID_POINTER_EVENTS_TARGET_CLASS = "dx-pointer-events-target",
            DATAGRID_POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none",
            getTransparentColumnIndex = function(fixedColumns) {
                var transparentColumnIndex = -1;
                $.each(fixedColumns, function(index, column) {
                    if (column.command === "transparent") {
                        transparentColumnIndex = index;
                        return false
                    }
                });
                return transparentColumnIndex
            };
        var baseFixedColumns = {
                init: function() {
                    this.callBase();
                    this._isFixedTableRendering = false;
                    this._isFixedColumns = false
                },
                _createCol: function(column) {
                    return this.callBase(column).toggleClass(DATAGRID_FIXED_COL_CLASS, this._isFixedTableRendering && (column.fixed || column.command && column.command !== "transparent"))
                },
                _createCell: function(column) {
                    var $cell = this.callBase(column);
                    if (column.colspan)
                        $cell.attr("colspan", column.colspan);
                    if (column.command === "transparent")
                        $cell.addClass(DATAGRID_POINTER_EVENTS_NONE_CLASS);
                    return $cell
                },
                _renderTable: function(options) {
                    var that = this,
                        $fixedTable,
                        $table,
                        fixedColumns = that._columnsController.getFixedColumns();
                    that._isFixedColumns = !!fixedColumns.length;
                    $table = that.callBase(options);
                    if (that._isFixedColumns) {
                        that._isFixedTableRendering = true;
                        $fixedTable = that._createTable(fixedColumns);
                        that._renderRows($fixedTable, $.extend({}, options, {columns: fixedColumns}));
                        that._updateContent($fixedTable, options && options.change);
                        that._isFixedTableRendering = false
                    }
                    else {
                        that._fixedTableElement && that._fixedTableElement.remove();
                        that._fixedTableElement = null
                    }
                    return $table
                },
                _wrapTableInScrollContainer: function() {
                    var $scrollContainer = this.callBase.apply(this, arguments);
                    if (this._isFixedTableRendering)
                        $scrollContainer.addClass(DATAGRID_CONTENT_FIXED_CLASS + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS);
                    return $scrollContainer
                },
                _renderCellContent: function($cell, options) {
                    var that = this,
                        trasparentColumnIndex,
                        column = options.column;
                    if (!that._isFixedTableRendering && that._isFixedColumns && (options.rowType !== "group" || !commonUtils.isDefined(column.groupIndex))) {
                        if (column.fixed || column.command) {
                            $cell.html("&nbsp;").addClass(column.cssClass);
                            return
                        }
                        if (options.rowType === "filter") {
                            that.callBase($cell, options);
                            trasparentColumnIndex = getTransparentColumnIndex(that._columnsController.getFixedColumns());
                            $cell.toggleClass(DATAGRID_FIRST_CELL_CLASS, options.columnIndex === trasparentColumnIndex);
                            return
                        }
                    }
                    if (column.command !== "transparent")
                        that.callBase($cell, options)
                },
                getCellElements: function(rowIndex) {
                    var that = this,
                        fixedColumns,
                        fixedColumnIndex = 0,
                        fixedCellElements,
                        cellElements = that.callBase(rowIndex);
                    if (that._fixedTableElement && cellElements) {
                        fixedColumns = that._columnsController.getFixedColumns(),
                        fixedCellElements = that._getRowElements(that._fixedTableElement).eq(rowIndex).children("td");
                        $.each(fixedColumns, function(index, column) {
                            if (column.command === "transparent") {
                                if (fixedCellElements.eq(index).hasClass(DATAGRID_MASTER_DETAIL_CELL_CLASS))
                                    cellElements[fixedColumnIndex] = fixedCellElements.get(index);
                                fixedColumnIndex += column.colspan
                            }
                            else {
                                cellElements[fixedColumnIndex] = fixedCellElements.get(index);
                                fixedColumnIndex++
                            }
                        })
                    }
                    return cellElements
                },
                getColumnWidths: function() {
                    var that = this,
                        i,
                        fixedColumnIndex = 0,
                        widths,
                        result = that.callBase(),
                        fixedColumns = that._columnsController.getFixedColumns();
                    if (that._fixedTableElement && result.length) {
                        widths = dataGrid.getWidths(that._fixedTableElement);
                        for (i = 0; i < fixedColumns.length; i++)
                            if (fixedColumns[i].command === "transparent")
                                fixedColumnIndex += fixedColumns[i].colspan;
                            else {
                                if (result[fixedColumnIndex] < widths[i])
                                    result[fixedColumnIndex] = widths[i];
                                fixedColumnIndex++
                            }
                    }
                    return result
                },
                _getTableElement: function() {
                    var tableElement = this._isFixedTableRendering ? this._fixedTableElement : this.callBase();
                    return tableElement
                },
                _setTableElement: function(tableElement) {
                    if (this._isFixedTableRendering)
                        this._fixedTableElement = tableElement.addClass(DATAGRID_POINTER_EVENTS_NONE_CLASS);
                    else
                        this.callBase(tableElement)
                },
                getColumns: function($tableElement) {
                    $tableElement = $tableElement || this._getTableElement();
                    if (this._isFixedTableRendering || $tableElement && $tableElement.closest("table").parent("." + DATAGRID_CONTENT_FIXED_CLASS).length)
                        return this._columnsController.getFixedColumns();
                    return this.callBase($tableElement)
                },
                getRowIndex: function($row) {
                    var $fixedTable = this._fixedTableElement;
                    if ($fixedTable && $fixedTable.find($row).length)
                        return this._getRowElements($fixedTable).index($row);
                    return this.callBase($row)
                },
                getTableElements: function() {
                    var result = this.callBase.apply(this, arguments);
                    if (this._fixedTableElement)
                        result = result.add(this._fixedTableElement);
                    return result
                },
                getFixedColumns: function() {
                    return this._columnsController.getFixedColumns()
                },
                getFixedColumnsOffset: function() {
                    var offset = {
                            left: 0,
                            right: 0
                        },
                        $transparentColumn,
                        positionTransparentColumn;
                    if (this._fixedTableElement) {
                        $transparentColumn = this.getTransparentColumnElement();
                        positionTransparentColumn = $transparentColumn.position();
                        offset = {
                            left: positionTransparentColumn.left,
                            right: this.element().outerWidth(true) - ($transparentColumn.outerWidth(true) + positionTransparentColumn.left)
                        }
                    }
                    return offset
                },
                getTransparentColumnElement: function() {
                    return this._fixedTableElement && this._fixedTableElement.find("." + DATAGRID_POINTER_EVENTS_NONE_CLASS).first()
                },
                getFixedTableElement: function() {
                    return this._fixedTableElement
                },
                isFixedColumns: function() {
                    return this._isFixedColumns
                },
                _resizeCore: function() {
                    this.callBase();
                    this.synchronizeRows()
                },
                setColumnWidths: function(widths) {
                    this.callBase(widths);
                    this.synchronizeRows()
                },
                _getClientHeight: function(element) {
                    var boundingClientRectElement = element.getBoundingClientRect && element.getBoundingClientRect();
                    return boundingClientRectElement && boundingClientRectElement.height ? boundingClientRectElement.height : element.clientHeight
                },
                synchronizeRows: function() {
                    var that = this,
                        rowHeight,
                        fixedRowHeight,
                        rowHeights = [],
                        fixedRowHeights = [],
                        rowIndex,
                        heightTable,
                        heightFixedTable,
                        $rowElements,
                        $fixedRowElements;
                    if (that._isFixedColumns && that._tableElement && that._fixedTableElement) {
                        heightTable = that._getClientHeight(that._tableElement.get(0));
                        heightFixedTable = that._getClientHeight(that._fixedTableElement.get(0));
                        $rowElements = that._getRowElements(that._tableElement);
                        $fixedRowElements = that._getRowElements(that._fixedTableElement);
                        if (heightTable !== heightFixedTable) {
                            $rowElements.css("height", "");
                            $fixedRowElements.css("height", "");
                            for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
                                rowHeights.push(that._getClientHeight($rowElements.get(rowIndex)));
                                fixedRowHeights.push(that._getClientHeight($fixedRowElements.get(rowIndex)))
                            }
                            for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
                                rowHeight = rowHeights[rowIndex];
                                fixedRowHeight = fixedRowHeights[rowIndex];
                                if (rowHeight > fixedRowHeight)
                                    $fixedRowElements.eq(rowIndex).css("height", rowHeight);
                                else if (rowHeight < fixedRowHeight)
                                    $rowElements.eq(rowIndex).css("height", fixedRowHeight)
                            }
                        }
                    }
                }
            };
        var ColumnHeadersViewFixedColumnsExtender = $.extend({}, baseFixedColumns, {
                getContextMenuItems: function($targetElement) {
                    var that = this,
                        $cell,
                        column,
                        onItemClick,
                        columnFixingOptions = that.option("columnFixing"),
                        items = that.callBase($targetElement);
                    if ($targetElement.closest("." + DATAGRID_HEADER_ROW_CLASS).length) {
                        $cell = $targetElement.closest("td");
                        column = $cell.length && that.getColumns($targetElement)[$cell[0].cellIndex];
                        if (column.allowFixing) {
                            onItemClick = function(params) {
                                switch (params.itemData.value) {
                                    case"none":
                                        that._columnsController.columnOption(column.index, "fixed", false);
                                        break;
                                    case"left":
                                        that._columnsController.columnOption(column.index, {
                                            fixed: true,
                                            fixedPosition: "left"
                                        });
                                        break;
                                    case"right":
                                        that._columnsController.columnOption(column.index, {
                                            fixed: true,
                                            fixedPosition: "right"
                                        });
                                        break
                                }
                            };
                            items.push({
                                text: columnFixingOptions.texts.fix,
                                beginGroup: true,
                                items: [{
                                        text: columnFixingOptions.texts.leftPosition,
                                        value: "left",
                                        disabled: column.fixed && (!column.fixedPosition || column.fixedPosition === "left"),
                                        onItemClick: onItemClick
                                    }, {
                                        text: columnFixingOptions.texts.rightPosition,
                                        value: "right",
                                        disabled: column.fixed && column.fixedPosition === "right",
                                        onItemClick: onItemClick
                                    }]
                            }, {
                                text: columnFixingOptions.texts.unfix,
                                value: "none",
                                disabled: !column.fixed,
                                onItemClick: onItemClick
                            })
                        }
                    }
                    return items
                },
                setScrollerSpacing: function(width) {
                    var that = this,
                        rtlEnabled = that.option("rtlEnabled");
                    that.callBase(width);
                    that.element().children("." + DATAGRID_CONTENT_FIXED_CLASS).css(rtlEnabled ? {paddingLeft: width} : {paddingRight: width})
                },
                getFixedColumnElements: function() {
                    return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(0).children()
                }
            });
        var RowsViewFixedColumnsExtender = $.extend({}, baseFixedColumns, {
                _detachHoverEvents: function() {
                    this._fixedTableElement && this._fixedTableElement.off("mouseover mouseout", ".dx-data-row");
                    this._tableElement && this._tableElement.off("mouseover mouseout", ".dx-data-row")
                },
                _attachHoverEvents: function() {
                    var that = this,
                        attachHoverEvent = function($table) {
                            $table.on("mouseover mouseout", ".dx-data-row", that.createAction(function(args) {
                                var event = args.jQueryEvent,
                                    rowIndex = that.getRowIndex($(event.target).closest(".dx-row")),
                                    isHover = event.type === "mouseover";
                                if (rowIndex >= 0) {
                                    that._tableElement && that._getRowElements(that._tableElement).eq(rowIndex).toggleClass(DATAGRID_HOVER_STATE_CLASS, isHover);
                                    that._fixedTableElement && that._getRowElements(that._fixedTableElement).eq(rowIndex).toggleClass(DATAGRID_HOVER_STATE_CLASS, isHover)
                                }
                            }))
                        };
                    if (that._fixedTableElement && that._tableElement) {
                        attachHoverEvent(that._fixedTableElement);
                        attachHoverEvent(that._tableElement)
                    }
                },
                _findContentElement: function() {
                    var that = this,
                        $content,
                        scrollable,
                        scrollTop,
                        element = that.element();
                    if (element && that._isFixedTableRendering) {
                        $content = element.children("." + DATAGRID_CONTENT_CLASS);
                        if (!$content.length) {
                            scrollable = that.getScrollable();
                            $content = $("<div/>").addClass(DATAGRID_CONTENT_CLASS).on("scroll", function(e) {
                                scrollTop = $(e.target).scrollTop();
                                if (scrollTop) {
                                    $(e.target).scrollTop(0);
                                    scrollable.scrollTo({y: that._scrollTop + scrollTop})
                                }
                            }).on(wheelEvent.name, function(e) {
                                if (scrollable) {
                                    scrollTop = scrollable.scrollTop();
                                    scrollable.scrollTo({y: scrollTop - e.delta});
                                    if (scrollable.scrollTop() > 0 && scrollable.scrollTop() + scrollable.clientHeight() < scrollable.scrollHeight() + that.getScrollbarWidth())
                                        return false
                                }
                            }).appendTo(element)
                        }
                        return $content
                    }
                    return that.callBase()
                },
                _updateBottomLoading: function() {
                    if (!this._isFixedTableRendering)
                        this.callBase()
                },
                _updateScrollable: function() {
                    var scrollable = this.getScrollable(),
                        scrollTop = scrollable && scrollable.scrollOffset().top;
                    this.callBase();
                    this._updateFixedTablePosition(-scrollTop)
                },
                _renderContent: function(contentElement, tableElement) {
                    if (this._isFixedTableRendering)
                        return contentElement.empty().addClass(DATAGRID_CONTENT_CLASS + " " + DATAGRID_CONTENT_FIXED_CLASS + " " + DATAGRID_POINTER_EVENTS_TARGET_CLASS).append(tableElement);
                    return this.callBase(contentElement, tableElement)
                },
                _getGroupCellOptions: function(options) {
                    if (this._isFixedTableRendering)
                        return this.callBase($.extend({}, options, {columns: this._columnsController.getVisibleColumns()}));
                    return this.callBase(options)
                },
                _renderGroupSummaryCells: function($row, options) {
                    if (this._isFixedTableRendering)
                        this.callBase($row, $.extend({}, options, {columns: this._columnsController.getVisibleColumns()}));
                    else
                        this.callBase($row, options)
                },
                _hasAlignByColumnSummaryItems: function(columnIndex, options) {
                    var result = this.callBase.apply(this, arguments);
                    return result && Boolean(options.columns[columnIndex].fixed) === Boolean(options.isFixed)
                },
                _renderGroupSummaryCellsCore: function($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
                    if (this._isFixedTableRendering) {
                        if (alignByColumnCellCount > 0)
                            if (browser.mozilla)
                                $groupCell.css("display", "none");
                            else
                                $groupCell.css("visibility", "hidden");
                        options.isFixed = true;
                        alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);
                        options.isFixed = false
                    }
                    this.callBase($groupCell, options, groupCellColSpan, alignByColumnCellCount)
                },
                _renderCore: function(change) {
                    this._detachHoverEvents();
                    this.callBase(change);
                    if (this.option("hoverStateEnabled") && this._isFixedColumns)
                        this._attachHoverEvents()
                },
                optionChanged: function(args) {
                    var that = this;
                    that.callBase(args);
                    if (args.name === "hoverStateEnabled" && that._isFixedColumns)
                        args.value ? this._attachHoverEvents() : this._detachHoverEvents()
                },
                getCellIndex: function($cell) {
                    var $fixedTable = this._fixedTableElement,
                        columns,
                        cellIndex = 0;
                    if ($fixedTable && $fixedTable.find($cell).length) {
                        columns = this._columnsController.getFixedColumns();
                        $.each(columns, function(index, column) {
                            if (index === $cell[0].cellIndex)
                                return false;
                            if (column.colspan) {
                                cellIndex += column.colspan;
                                return
                            }
                            cellIndex++
                        });
                        return cellIndex
                    }
                    return this.callBase($cell)
                },
                _updateFixedTablePosition: function(scrollTop) {
                    if (this._fixedTableElement && this._tableElement) {
                        var editorFactory = this.getController("editorFactory"),
                            $focusedElement = editorFactory.focus();
                        this._fixedTableElement.css("top", scrollTop + this._tableElement.position().top);
                        if ($focusedElement)
                            editorFactory.focus($focusedElement)
                    }
                },
                setScrollerSpacing: function(vWidth, hWidth) {
                    var that = this,
                        styles;
                    var $fixedContent = that.element().children("." + DATAGRID_CONTENT_FIXED_CLASS);
                    if ($fixedContent.length) {
                        styles = that.option("rtlEnabled") ? {marginLeft: vWidth} : {marginRight: vWidth};
                        styles.marginBottom = hWidth;
                        $fixedContent.css(styles)
                    }
                },
                _handleScroll: function(e) {
                    this._updateFixedTablePosition(-e.scrollOffset.top);
                    this.callBase(e)
                },
                _updateContentPosition: function() {
                    var isUpdated = this.callBase();
                    if (isUpdated)
                        this._updateFixedTablePosition(-this._scrollTop);
                    return isUpdated
                },
                _afterRowPrepared: function(e) {
                    if (this._isFixedTableRendering)
                        return;
                    this.callBase(e)
                }
            });
        var FooterViewFixedColumnsExtender = baseFixedColumns;
        dataGrid.registerModule("fixedColumns", {
            defaultOptions: function() {
                return {columnFixing: {
                            enabled: false,
                            texts: {
                                fix: Globalize.localize("dxDataGrid-columnFixingFix"),
                                unfix: Globalize.localize("dxDataGrid-columnFixingUnfix"),
                                leftPosition: Globalize.localize("dxDataGrid-columnFixingLeftPosition"),
                                rightPosition: Globalize.localize("dxDataGrid-columnFixingRightPosition")
                            }
                        }}
            },
            extenders: {
                views: {
                    columnHeadersView: ColumnHeadersViewFixedColumnsExtender,
                    rowsView: RowsViewFixedColumnsExtender,
                    footerView: FooterViewFixedColumnsExtender
                },
                controllers: function() {
                    var normalizeColumnIndicesByPoints = function(columns, pointsByColumns) {
                            var transparentColumnIndex = getTransparentColumnIndex(columns);
                            if (transparentColumnIndex >= 0)
                                $.each(pointsByColumns, function(_, point) {
                                    if (point.index > transparentColumnIndex) {
                                        point.columnIndex += columns[transparentColumnIndex].colspan - 1;
                                        point.index += columns[transparentColumnIndex].colspan - 1
                                    }
                                });
                            return pointsByColumns
                        };
                    return {
                            draggingHeader: {
                                _generatePointsByColumns: function(options) {
                                    var pointsByColumns,
                                        targetDraggingPanel = options.targetDraggingPanel;
                                    if (targetDraggingPanel && targetDraggingPanel.getName() === "headers" && targetDraggingPanel.isFixedColumns())
                                        if (options.sourceColumn.fixed) {
                                            options.columnElements = targetDraggingPanel.getFixedColumnElements();
                                            options.columns = targetDraggingPanel.getFixedColumns();
                                            pointsByColumns = this.callBase(options);
                                            return normalizeColumnIndicesByPoints(options.columns, pointsByColumns)
                                        }
                                    return this.callBase(options)
                                },
                                _pointCreated: function(point, columns, location, sourceColumn) {
                                    var result = this.callBase.apply(this, arguments),
                                        $transparentColumn = this._columnHeadersView.getTransparentColumnElement(),
                                        boundingRect;
                                    if (!result && location === "headers" && $transparentColumn) {
                                        boundingRect = $transparentColumn.get(0).getBoundingClientRect();
                                        if (sourceColumn && sourceColumn.fixed)
                                            return sourceColumn.fixedPosition === "right" ? point.x < boundingRect.right : point.x > boundingRect.left;
                                        else
                                            return point.x < boundingRect.left || point.x > boundingRect.right
                                    }
                                    return result
                                }
                            },
                            columnsResizer: {
                                _generatePointsByColumns: function() {
                                    var that = this,
                                        columns = that._columnsController ? that._columnsController.getFixedColumns() : [],
                                        cells = that._columnHeadersView.getFixedColumnElements(),
                                        pointsByFixedColumns = [];
                                    that.callBase();
                                    if (cells && cells.length > 0) {
                                        pointsByFixedColumns = dataGrid.getPointsByColumns(cells, function(point) {
                                            return that._pointCreated(point, cells.length, columns)
                                        });
                                        that._pointsByFixedColumns = normalizeColumnIndicesByPoints(columns, pointsByFixedColumns)
                                    }
                                },
                                _pointCreated: function(point, cellsLength, columns) {
                                    var currentColumn,
                                        nextColumn;
                                    if (point.index > 0 && point.index < cellsLength) {
                                        currentColumn = columns[point.columnIndex - 1] || {};
                                        nextColumn = columns[point.columnIndex] || {};
                                        if (currentColumn.fixed || nextColumn.fixed) {
                                            point.columnIndex -= 1;
                                            return !((currentColumn.allowResizing || currentColumn.command === "transparent") && (nextColumn.allowResizing || nextColumn.command === "transparent"))
                                        }
                                    }
                                    return this.callBase.apply(this, arguments)
                                },
                                _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
                                    var $transparentColumn = this._columnHeadersView.getTransparentColumnElement(),
                                        boundingRect;
                                    if ($transparentColumn) {
                                        boundingRect = $transparentColumn.get(0).getBoundingClientRect();
                                        if (currentX <= boundingRect.left || currentX >= boundingRect.right)
                                            return this.callBase(this._pointsByFixedColumns, currentX, deltaX)
                                    }
                                    return this.callBase(pointsByColumns, currentX, deltaX)
                                }
                            },
                            keyboardNavigation: {_scrollToElement: function($element) {
                                    var focusedView = this.getFocusedView();
                                    this.callBase($element, focusedView && focusedView.getFixedColumnsOffset())
                                }}
                        }
                }()
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.exportController.js */
    (function($, DX) {
        var ui = DX.ui,
            dataGrid = ui.dxDataGrid,
            Class = DevExpress.require("/class"),
            commonUtils = DX.require("/utils/utils.common"),
            CheckBox = DX.require("/ui/widgets/ui.checkBox"),
            DATAGRID_CHECKBOX_SIZE = "dx-datagrid-checkbox-size",
            DATAGRID_EXPORT_MENU_CLASS = "dx-datagrid-export-menu",
            DATAGRID_EXPORT_BUTTON_CLASS = "dx-datagrid-export-button",
            DATAGRID_EXPORT_ICON = "export-to",
            DATAGRID_EXPORT_EXCEL_ICON = "exportxlsx",
            DATAGRID_EXPORT_EXCEL_BUTTON_ICON = "export-excel-button";
        dataGrid.DataProvider = Class.inherit({
            _getGroupValue: function(item) {
                var groupColumn = this._options.groupColumns[item.groupIndex],
                    value = dataGrid.getDisplayValue(groupColumn, item.values[item.groupIndex], item.data, item.rowType),
                    result = groupColumn.caption + ": " + dataGrid.formatValue(value, groupColumn),
                    visibleIndex;
                visibleIndex = this._options.getVisibleIndex(groupColumn.index);
                if (item.summaryCells && item.summaryCells.length && item.summaryCells[visibleIndex].length)
                    result += " " + dataGrid.getGroupRowSummaryText(item.summaryCells[visibleIndex], this._options.summaryTexts);
                return result
            },
            _correctCellIndex: function(cellIndex) {
                var startIndex = this._options.startValueIndex,
                    endIndex = this._options.endValueIndex;
                return cellIndex <= endIndex ? startIndex + cellIndex : null
            },
            ctor: function(options) {
                this._options = options
            },
            getColumns: function() {
                return this._options.columns
            },
            getRowsCount: function() {
                return this._options.items.length
            },
            isGroupRow: function(rowIndex) {
                return rowIndex < this._options.items.length && this._options.items[rowIndex].rowType === "group"
            },
            getGroupLevel: function(rowIndex) {
                var item = this._options.items[rowIndex],
                    groupIndex = item.groupIndex;
                if (item.isTotalSummary)
                    return 0;
                return commonUtils.isDefined(groupIndex) ? groupIndex : this._options.groupColumns.length
            },
            getCellType: function(rowIndex, cellIndex) {
                if (cellIndex < this._options.columns.length) {
                    var item = this._options.items.length && this._options.items[rowIndex],
                        column = this._options.columns[cellIndex];
                    if (item && item.rowType === "data")
                        if (isFinite(item.values[this._correctCellIndex(cellIndex)]) && !commonUtils.isDefined(column.customizeText))
                            return commonUtils.isDefined(column.lookup) ? column.lookup.dataType : column.dataType;
                    return "string"
                }
            },
            ready: function() {
                var options = this._options;
                return $.when(options.items).done(function(items) {
                        options.items = items
                    })
            },
            getCellValue: function(rowIndex, cellIndex) {
                var column,
                    value,
                    i,
                    summaryItems,
                    correctedCellIndex = this._correctCellIndex(cellIndex),
                    itemValues,
                    item = this._options.items.length && this._options.items[rowIndex];
                if (item) {
                    itemValues = item.values;
                    switch (item.rowType) {
                        case"summaryFooter":
                            if (correctedCellIndex < itemValues.length) {
                                value = itemValues[correctedCellIndex];
                                if (commonUtils.isDefined(value))
                                    return dataGrid.getSummaryText(value, this._options.summaryTexts)
                            }
                            break;
                        case"group":
                            if (cellIndex < 1)
                                return this._getGroupValue(item);
                            else {
                                summaryItems = item.values[correctedCellIndex];
                                if (commonUtils.isArray(summaryItems)) {
                                    value = "";
                                    for (i = 0; i < summaryItems.length; i++)
                                        value += (i > 0 ? " \n " : "") + dataGrid.getSummaryText(summaryItems[i], this._options.summaryTexts);
                                    return value
                                }
                            }
                            break;
                        default:
                            column = this._options.columns[cellIndex];
                            if (column) {
                                value = dataGrid.getDisplayValue(column, itemValues[correctedCellIndex], item.data, item.rowType);
                                return !isFinite(value) || column.customizeText ? dataGrid.formatValue(value, column) : value
                            }
                    }
                }
            },
            isHeadersVisible: function() {
                return this._options.isHeadersVisible
            },
            isTotalCell: function(rowIndex, cellIndex) {
                var items = this._options.items,
                    item = items[rowIndex],
                    correctCellIndex = this._correctCellIndex(cellIndex),
                    isSummaryAlignByColumn = item.summaryCells && item.summaryCells[correctCellIndex] && item.summaryCells[correctCellIndex].length > 0 && item.summaryCells[correctCellIndex][0].alignByColumn;
                return item && item.rowType === "summaryFooter" || isSummaryAlignByColumn
            }
        });
        dataGrid.ExportController = dataGrid.ViewController.inherit({
            _getColumns: function() {
                var result = [],
                    visibleColumns = this._columnsController.getVisibleColumns(),
                    columnWidths = this._headersView && this._headersView.isVisible() ? this._headersView.getColumnWidths() : this._rowsView.getColumnWidths(),
                    column,
                    i;
                for (i = 0; i < visibleColumns.length; i++) {
                    column = visibleColumns[i];
                    if (!commonUtils.isDefined(column.command))
                        result.push($.extend({}, column, {width: columnWidths[i]}))
                }
                return result
            },
            _getFooterSummaryItems: function(summaryCells, isTotal) {
                var result = [],
                    estimatedItemsCount = 1,
                    values,
                    itemslength,
                    summaryCell,
                    j,
                    i = 0;
                do {
                    values = [];
                    for (j = 0; j < summaryCells.length; j++) {
                        summaryCell = summaryCells[j];
                        itemslength = summaryCell.length;
                        if (estimatedItemsCount < itemslength)
                            estimatedItemsCount = itemslength;
                        values.push(summaryCell[i])
                    }
                    result.push({
                        values: values,
                        rowType: "summaryFooter",
                        isTotalSummary: isTotal
                    })
                } while (i++ < estimatedItemsCount - 1);
                return result
            },
            _hasSummaryGroupFooters: function() {
                var i,
                    groupItems = this.option("summary.groupItems");
                if (commonUtils.isDefined(groupItems))
                    for (i = 0; i < groupItems.length; i++)
                        if (groupItems[i].showInGroupFooter)
                            return true;
                return false
            },
            _getItemsWithSummaryGroupFooters: function(sourceItems) {
                var item,
                    result = [],
                    beforeGroupFooterItems = [],
                    groupFooterItems = [],
                    i;
                for (i = 0; i < sourceItems.length; i++) {
                    item = sourceItems[i];
                    if (item.rowType === "groupFooter") {
                        groupFooterItems = this._getFooterSummaryItems(item.summaryCells);
                        result = result.concat(beforeGroupFooterItems, groupFooterItems);
                        beforeGroupFooterItems = []
                    }
                    else
                        beforeGroupFooterItems.push(item)
                }
                return result.length ? result : beforeGroupFooterItems
            },
            _updateGroupValuesWithSummaryByColumn: function(sourceItems) {
                var item,
                    summaryCells,
                    summaryItem,
                    summaryValues = [],
                    groupColumnCount,
                    k,
                    j,
                    i;
                for (i = 0; i < sourceItems.length; i++) {
                    item = sourceItems[i];
                    summaryCells = item.summaryCells;
                    if (item.rowType === "group" && summaryCells && summaryCells.length > 1) {
                        groupColumnCount = item.values.length;
                        for (j = 1; j < summaryCells.length; j++)
                            for (k = 0; k < summaryCells[j].length; k++) {
                                summaryItem = summaryCells[j][k];
                                if (summaryItem && summaryItem.alignByColumn) {
                                    if (!commonUtils.isArray(summaryValues[j - groupColumnCount]))
                                        summaryValues[j - groupColumnCount] = [];
                                    summaryValues[j - groupColumnCount].push(summaryItem)
                                }
                            }
                        if (summaryValues.length > 0) {
                            $.merge(item.values, summaryValues);
                            summaryValues = []
                        }
                    }
                }
            },
            _getAllItems: function(data) {
                var that = this,
                    d = $.Deferred(),
                    dataController = this.getController("data"),
                    footerItems = dataController.footerItems(),
                    totalItem = footerItems.length && footerItems[0],
                    summaryTotalItems = that.option("summary.totalItems"),
                    summaryCells,
                    summaryItems;
                dataController.loadAll(data).done(function(sourceItems, totalAggregates) {
                    that._updateGroupValuesWithSummaryByColumn(sourceItems);
                    if (that._hasSummaryGroupFooters())
                        sourceItems = that._getItemsWithSummaryGroupFooters(sourceItems);
                    summaryCells = totalItem && totalItem.summaryCells;
                    if (commonUtils.isDefined(totalAggregates) && summaryTotalItems)
                        summaryCells = dataController._getSummaryCells(summaryTotalItems, totalAggregates);
                    summaryItems = totalItem && that._getFooterSummaryItems(summaryCells, true);
                    if (summaryItems)
                        sourceItems = sourceItems.concat(summaryItems);
                    d.resolve(sourceItems)
                }).fail(d.reject);
                return d
            },
            _getSelectedItems: function() {
                var selectionController = this.getController("selection"),
                    selectedRowData = selectionController.getSelectedRowsData();
                return this._getAllItems(selectedRowData)
            },
            _getStartEndValueIndexces: function(visibleColumns) {
                var i,
                    startIndex,
                    endIndex,
                    visibleColumnslength = visibleColumns.length;
                for (i = 0; i < visibleColumnslength; i++)
                    if (!commonUtils.isDefined(visibleColumns[i].command)) {
                        startIndex = i;
                        break
                    }
                for (i = visibleColumnslength - 1; i >= 0; i--)
                    if (!commonUtils.isDefined(visibleColumns[i].command)) {
                        endIndex = i;
                        break
                    }
                return {
                        startIndex: startIndex,
                        endIndex: endIndex
                    }
            },
            init: function() {
                this._columnsController = this.getController("columns");
                this._rowsView = this.getView("rowsView");
                this._headersView = this.getView("columnHeadersView");
                this.createAction("onExporting", {excludeValidators: ["disabled", "readOnly"]});
                this.createAction("onExported", {excludeValidators: ["disabled", "readOnly"]});
                this.createAction("onFileSaving", {excludeValidators: ["disabled", "readOnly"]});
                this._clientExporter = new DX.dxClientExporter({
                    exportingAction: this.getAction("onExporting"),
                    exportedAction: this.getAction("onExported"),
                    fileSavingAction: this.getAction("onFileSaving")
                })
            },
            optionChanged: function(args) {
                this.callBase(args);
                if (args.name === "onExporting")
                    this._clientExporter.option("exportingAction", this.getAction(args.name));
                if (args.name === "onExported")
                    this._clientExporter.option("exportedAction", this.getAction(args.name));
                if (args.name === "onFileSaving")
                    this._clientExporter.option("fileSavingAction", this.getAction(args.name))
            },
            callbackNames: function() {
                return ["selectionOnlyChanged"]
            },
            getExportFormat: function() {
                return ["EXCEL"]
            },
            getDataProvider: function() {
                var groupColumns = this._columnsController.getGroupColumns(),
                    startEndIndexces = this._getStartEndValueIndexces(this._columnsController.getVisibleColumns());
                return new dataGrid.DataProvider({
                        columns: this._getColumns(),
                        groupColumns: groupColumns,
                        items: !!this._selectionOnly ? this._getSelectedItems() : this._getAllItems(),
                        getVisibleIndex: $.proxy(this._columnsController.getVisibleIndex, this._columnsController),
                        startValueIndex: startEndIndexces.startIndex,
                        endValueIndex: startEndIndexces.endIndex,
                        isHeadersVisible: this.option("showColumnHeaders"),
                        summaryTexts: this.option("summary.texts")
                    })
            },
            exportToExcel: function(selectionOnly) {
                this._selectionOnly = selectionOnly;
                var excelWrapTextEnabled = this.option("export.excelWrapTextEnabled");
                commonUtils.isDefined(this._clientExporter) && this._clientExporter.exportTo({
                    fileName: this.option("export.fileName"),
                    proxyUrl: this.option("export.proxyUrl"),
                    format: "EXCEL",
                    wrapTextEnabled: commonUtils.isDefined(excelWrapTextEnabled) ? excelWrapTextEnabled : !!this.option("wordWrapEnabled"),
                    autoFilterEnabled: !!this.option("export.excelFilterEnabled"),
                    component: this.component
                })
            },
            publicMethods: function() {
                return ["getDataProvider", "getExportFormat", "exportToExcel"]
            },
            selectionOnly: function(value) {
                if (commonUtils.isDefined(value)) {
                    this._isSelectedRows = value;
                    this.selectionOnlyChanged.fire()
                }
                else
                    return this._isSelectedRows
            }
        });
        dataGrid.registerModule("export", {
            defaultOptions: function() {
                return {"export": {
                            enabled: false,
                            fileName: "DataGrid",
                            excelFilterEnabled: false,
                            excelWrapTextEnabled: undefined,
                            proxyUrl: undefined,
                            allowExportSelectedData: false,
                            texts: {
                                exportTo: Globalize.localize("dxDataGrid-exportTo"),
                                exportToExcel: Globalize.localize("dxDataGrid-exportToExcel"),
                                excelFormat: Globalize.localize("dxDataGrid-excelFormat"),
                                selectedRows: Globalize.localize("dxDataGrid-selectedRows")
                            }
                        }}
            },
            controllers: {"export": dataGrid.ExportController},
            extenders: {
                controllers: {editing: {
                        callbackNames: function() {
                            var callbackList = this.callBase();
                            return commonUtils.isDefined(callbackList) ? callbackList.push("editingChanged") : ["editingChanged"]
                        },
                        _updateEditButtons: function() {
                            this.callBase();
                            this.editingChanged.fire(this.hasChanges())
                        }
                    }},
                views: {headerPanel: {
                        _isExportButtonVisible: function() {
                            return this.option("export.enabled")
                        },
                        _getButtonOptions: function() {
                            var that = this,
                                texts = that.option("export.texts");
                            return that.option("export.allowExportSelectedData") ? {
                                    hint: texts.exportTo,
                                    icon: DATAGRID_EXPORT_ICON,
                                    onClick: null
                                } : {
                                    hint: texts.exportToExcel,
                                    icon: DATAGRID_EXPORT_EXCEL_BUTTON_ICON,
                                    onClick: function() {
                                        that._exportController.exportToExcel()
                                    }
                                }
                        },
                        _renderExportButton: function() {
                            var that = this;
                            if (that.option("export.enabled"))
                                if (!that._$exportButton) {
                                    that._$exportButton = $("<div>").addClass(DATAGRID_EXPORT_BUTTON_CLASS).appendTo(that.element());
                                    that._exportButton = that._createComponent(that._$exportButton, "dxButton", that._getButtonOptions())
                                }
                                else {
                                    that._exportButton.option(that._getButtonOptions());
                                    that._$exportButton.show()
                                }
                            else
                                that._$exportButton && that._$exportButton.hide()
                        },
                        _renderExportMenu: function() {
                            var that = this,
                                texts = that.option("export.texts"),
                                menuItems = [{
                                        text: texts.excelFormat,
                                        exportAction: true,
                                        icon: DATAGRID_EXPORT_EXCEL_ICON
                                    }];
                            commonUtils.isDefined(that._exportContextMenu) && that._exportContextMenu.element().remove();
                            if (that.option("export.enabled") && that.option("export.allowExportSelectedData")) {
                                menuItems.push({
                                    value: "selectionOnly",
                                    template: function() {
                                        var $selectionOnlyEditor = that._createComponent($("<div>").addClass(DATAGRID_CHECKBOX_SIZE), CheckBox, {
                                                text: texts.selectedRows,
                                                value: !!that._exportController.selectionOnly(),
                                                onValueChanged: function(e) {
                                                    that._exportController.selectionOnly(e.value)
                                                }
                                            }).element();
                                        return $selectionOnlyEditor
                                    },
                                    beginGroup: true,
                                    closeMenuOnClick: false
                                });
                                that._exportContextMenu = that._createComponent($("<div>").appendTo(that.component.element()), "dxContextMenu", {
                                    alternativeInvocationMode: {
                                        enabled: true,
                                        invokingElement: that._$exportButton
                                    },
                                    items: menuItems,
                                    cssClass: DATAGRID_EXPORT_MENU_CLASS,
                                    onItemClick: function(e) {
                                        if (e.itemData.exportAction)
                                            that._exportController.exportToExcel(that._exportController.selectionOnly())
                                    },
                                    target: this._$exportButton,
                                    position: {
                                        at: "left bottom",
                                        my: "left top",
                                        offset: "0 3",
                                        collision: "fit",
                                        boundary: that._$parent,
                                        boundaryOffset: "1 1"
                                    }
                                })
                            }
                        },
                        _renderCore: function() {
                            this.callBase();
                            this._renderExportButton();
                            this._renderExportMenu()
                        },
                        optionChanged: function(args) {
                            this.callBase(args);
                            if (args.name === "export") {
                                args.handled = true;
                                this._invalidate()
                            }
                        },
                        init: function() {
                            var that = this;
                            this.callBase();
                            this._exportController = this.getController("export");
                            this._editingController = this.getController("editing");
                            this._editingController.editingChanged.add(function(hasChanges) {
                                if (commonUtils.isDefined(that._exportButton))
                                    that._exportButton.option("disabled", hasChanges)
                            })
                        },
                        isVisible: function() {
                            return this.callBase() || this._isExportButtonVisible()
                        }
                    }}
            }
        });
        $.extend(dataGrid.__internals, {
            DATAGRID_EXPORT_MENU_CLASS: DATAGRID_EXPORT_MENU_CLASS,
            DATAGRID_EXPORT_BUTTON_CLASS: DATAGRID_EXPORT_BUTTON_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.dataGrid.gridView.js */
    (function($, DX) {
        var dataGrid = DX.ui.dxDataGrid,
            commonUtils = DX.require("/utils/utils.common");
        var DATAGRID_CLASS = "dx-datagrid",
            DATAGRID_HIDDEN_CLASS = "dx-hidden",
            DATAGRID_TABLE_CLASS = "dx-datagrid-table",
            DATAGRID_BORDERS_CLASS = "dx-datagrid-borders",
            DATAGRID_TABLE_FIXED_CLASS = "dx-datagrid-table-fixed",
            DATAGRID_COLUMN_HEADERS_HIDDEN = "dx-datagrid-headers-hidden",
            DATAGRID_IMPORTANT_MARGIN_CLASS = "dx-datagrid-important-margin",
            EMPTY_GRID_ROWS_HEIGHT = 100,
            LOADPANEL_MARGIN = 50,
            VIEW_NAMES = ["columnsSeparatorView", "blockSeparatorView", "trackerView", "headerPanel", "columnHeadersView", "rowsView", "footerView", "columnChooserView", "pagerView", "draggingHeaderView", "contextMenuView", "errorView", "headerFilterView"];
        var isPercentWidth = function(width) {
                return commonUtils.isString(width) && width.slice(-1) === "%"
            };
        var mergeArraysByMaxValue = function(values1, values2) {
                var result = [],
                    i;
                if (values1 && values2 && values1.length && values1.length === values2.length)
                    for (i = 0; i < values1.length; i++)
                        result.push(values1[i] > values2[i] ? values1[i] : values2[i]);
                else if (values1 && values1.length)
                    result = values1;
                else if (values2)
                    result = values2;
                return result
            };
        dataGrid.ResizingController = dataGrid.ViewController.inherit({
            _initPostRenderHandlers: function() {
                var that = this;
                if (!that._refreshSizesHandler) {
                    that._refreshSizesHandler = function(e) {
                        that._dataController.changed.remove(that._refreshSizesHandler);
                        if (that._columnsController.columnsChanged.firing) {
                            (window.setImmediate || setTimeout)($.proxy(that._refreshSizesHandler, that, e));
                            return
                        }
                        var changeType = e && e.changeType;
                        if (!e || changeType === "refresh" || changeType === "prepend" || changeType === "append")
                            that.resize();
                        else if (changeType === "update")
                            if (that._dataController.items().length > 1)
                                that._rowsView.resize();
                            else
                                that.resize();
                        if (changeType && changeType !== "updateSelection")
                            that.component._fireContentReadyAction()
                    };
                    that._dataController.changed.add(function() {
                        that._dataController.changed.add(that._refreshSizesHandler)
                    })
                }
            },
            _getBestFitWidths: function() {
                var that = this,
                    rowsColumnWidths,
                    headerColumnWidths,
                    footerColumnWidths,
                    resultWidths;
                rowsColumnWidths = that._rowsView.getColumnWidths();
                headerColumnWidths = that._columnHeadersView && that._columnHeadersView.getColumnWidths();
                footerColumnWidths = that._footerView && that._footerView.getColumnWidths();
                resultWidths = mergeArraysByMaxValue(rowsColumnWidths, headerColumnWidths);
                resultWidths = mergeArraysByMaxValue(resultWidths, footerColumnWidths);
                return resultWidths
            },
            _setVisibleWidths: function(visibleColumns, widths) {
                var columnsController = this._columnsController;
                columnsController.beginUpdate();
                $.each(visibleColumns, function(index, column) {
                    var columnId = column.command ? "command:" + column.command : column.index;
                    columnsController.columnOption(columnId, "visibleWidth", widths[index])
                });
                columnsController.endUpdate()
            },
            _toggleBestFitMode: function(isBestFit) {
                var $element = this.component.element();
                $element.find("." + DATAGRID_TABLE_CLASS).toggleClass(DATAGRID_TABLE_FIXED_CLASS, !isBestFit);
                $element.find("input").toggleClass(DATAGRID_HIDDEN_CLASS, isBestFit);
                $element.find(".dx-group-cell").toggleClass(DATAGRID_HIDDEN_CLASS, isBestFit);
                $element.find(".dx-header-row .dx-datagrid-text-content").css("max-width", "")
            },
            _synchronizeColumns: function() {
                var that = this,
                    columnsController = that._columnsController,
                    visibleColumns = columnsController.getVisibleColumns(),
                    columnAutoWidth = that.option("columnAutoWidth"),
                    needBestFit = columnAutoWidth,
                    lastWidthReseted = false,
                    resultWidths = [],
                    normalizeWidthsByExpandColumns = function() {
                        var expandColumnWidth;
                        $.each(visibleColumns, function(index, column) {
                            if (column.command === "expand")
                                expandColumnWidth = resultWidths[index]
                        });
                        $.each(visibleColumns, function(index, column) {
                            if (column.command === "expand" && expandColumnWidth)
                                resultWidths[index] = expandColumnWidth
                        })
                    };
                !needBestFit && $.each(visibleColumns, function(index, column) {
                    if (column.width === "auto") {
                        needBestFit = true;
                        return false
                    }
                });
                that._setVisibleWidths(visibleColumns, []);
                if (needBestFit) {
                    that._toggleBestFitMode(true);
                    resultWidths = that._getBestFitWidths();
                    $.each(visibleColumns, function(index, column) {
                        var columnId = column.command ? "command:" + column.command : column.index;
                        columnsController.columnOption(columnId, "bestFitWidth", resultWidths[index], true)
                    })
                }
                $.each(visibleColumns, function(index) {
                    if (this.width !== "auto")
                        if (this.width)
                            resultWidths[index] = this.width;
                        else if (!columnAutoWidth)
                            resultWidths[index] = undefined
                });
                lastWidthReseted = that._correctColumnWidths(resultWidths, visibleColumns);
                if (columnAutoWidth) {
                    normalizeWidthsByExpandColumns();
                    that._processStretch(resultWidths, visibleColumns)
                }
                if (needBestFit)
                    that._toggleBestFitMode(false);
                if (needBestFit || lastWidthReseted)
                    that._setVisibleWidths(visibleColumns, resultWidths)
            },
            _correctColumnWidths: function(resultWidths, visibleColumns) {
                var that = this,
                    hasPercentWidth = false,
                    hasAutoWidth = false,
                    lastWidthReseted = false,
                    $element = that.component.element(),
                    hasWidth = that._hasWidth,
                    lastColumnIndex;
                $.each(visibleColumns, function(index) {
                    if (this.width !== "auto")
                        if (this.width)
                            resultWidths[index] = this.width;
                        else
                            hasAutoWidth = true;
                    if (isPercentWidth(this.width))
                        hasPercentWidth = true
                });
                if ($element && that._maxWidth) {
                    delete that._maxWidth;
                    $element.css("max-width", "")
                }
                if (!hasAutoWidth && resultWidths.length) {
                    var contentWidth = that._rowsView.contentWidth();
                    var totalWidth = that._getTotalWidth(resultWidths, contentWidth);
                    if (totalWidth <= contentWidth) {
                        lastColumnIndex = resultWidths.length - 1;
                        while (lastColumnIndex >= 0 && visibleColumns[lastColumnIndex] && visibleColumns[lastColumnIndex].command)
                            lastColumnIndex--;
                        if (lastColumnIndex >= 0) {
                            resultWidths[lastColumnIndex] = "auto";
                            lastWidthReseted = true;
                            if (!hasWidth && !hasPercentWidth) {
                                that._maxWidth = that.option("showBorders") ? totalWidth + 2 : totalWidth;
                                $element.css("max-width", that._maxWidth)
                            }
                        }
                    }
                }
                return lastWidthReseted
            },
            _processStretch: function(resultSizes, visibleColumns) {
                var groupSize = this._rowsView.contentWidth(),
                    tableSize = this._getTotalWidth(resultSizes, groupSize),
                    unusedIndexes = {length: 0},
                    diff,
                    diffElement,
                    onePixelElementsCount,
                    i;
                if (!resultSizes.length)
                    return;
                $.each(visibleColumns, function(index) {
                    if (this.width) {
                        unusedIndexes[index] = true;
                        unusedIndexes.length++
                    }
                });
                diff = groupSize - tableSize;
                diffElement = Math.floor(diff / (resultSizes.length - unusedIndexes.length));
                onePixelElementsCount = diff - diffElement * (resultSizes.length - unusedIndexes.length);
                if (diff >= 0)
                    for (i = 0; i < resultSizes.length; i++) {
                        if (unusedIndexes[i])
                            continue;
                        resultSizes[i] += diffElement;
                        if (onePixelElementsCount) {
                            resultSizes[i]++;
                            onePixelElementsCount--
                        }
                    }
            },
            _getTotalWidth: function(widths, groupWidth) {
                var result = 0,
                    width,
                    i;
                for (i = 0; i < widths.length; i++) {
                    width = widths[i];
                    if (width)
                        result += isPercentWidth(width) ? parseInt(width) * groupWidth / 100 : parseInt(width)
                }
                return Math.round(result)
            },
            updateSize: function($rootElement) {
                var that = this,
                    $groupElement,
                    width;
                if (that._hasHeight === undefined && $rootElement && $rootElement.is(":visible")) {
                    $groupElement = $rootElement.children("." + DATAGRID_CLASS);
                    if ($groupElement.length)
                        $groupElement.detach();
                    that._hasHeight = !!$rootElement.height();
                    width = $rootElement.width();
                    $rootElement.addClass(DATAGRID_IMPORTANT_MARGIN_CLASS);
                    that._hasWidth = $rootElement.width() === width;
                    $rootElement.removeClass(DATAGRID_IMPORTANT_MARGIN_CLASS);
                    if ($groupElement.length)
                        $groupElement.appendTo($rootElement)
                }
            },
            publicMethods: function() {
                return ["resize", "updateDimensions"]
            },
            resize: function() {
                !this.component._requireResize && this.updateDimensions()
            },
            updateDimensions: function(checkSize) {
                var that = this,
                    dataController = that._dataController,
                    $rootElement = that.component.element(),
                    rootElementHeight = $rootElement && ($rootElement.get(0).clientHeight || $rootElement.height()),
                    loadPanelOptions = that.option("loadPanel"),
                    height = that.option("height"),
                    rowsViewHeight,
                    editorFactory = that.getController("editorFactory"),
                    rowsView = that._rowsView,
                    columnHeadersView = that._columnHeadersView,
                    footerView = that._footerView,
                    $testDiv;
                that._initPostRenderHandlers();
                if (checkSize && (this._lastWidth === $rootElement.width() && this._lastHeight === $rootElement.height() || !$rootElement.is(":visible")))
                    return;
                that.updateSize($rootElement);
                if (height && that._hasHeight ^ height !== "auto") {
                    $testDiv = $("<div>").height(height).appendTo($rootElement);
                    that._hasHeight = !!$testDiv.height();
                    $testDiv.remove()
                }
                if (that._hasHeight && rootElementHeight > 0 && that.option("scrolling")) {
                    rowsViewHeight = rootElementHeight;
                    $.each(that.getViews(), function() {
                        if (this.isVisible() && this.getHeight)
                            rowsViewHeight -= this.getHeight()
                    })
                }
                else if (!that._hasHeight && dataController.items().length === 0)
                    rowsViewHeight = loadPanelOptions && loadPanelOptions.visible ? loadPanelOptions.height + LOADPANEL_MARGIN : EMPTY_GRID_ROWS_HEIGHT;
                else
                    rowsViewHeight = "auto";
                rowsView.height(rowsViewHeight);
                if (!dataController.isLoaded()) {
                    rowsView.setLoading(true);
                    return
                }
                var vScrollbarWidth = rowsView.getScrollbarWidth();
                var hScrollbarWidth = rowsView.getScrollbarWidth(true);
                columnHeadersView && columnHeadersView.setScrollerSpacing(vScrollbarWidth);
                footerView && footerView.setScrollerSpacing(vScrollbarWidth);
                rowsView.setScrollerSpacing(vScrollbarWidth, hScrollbarWidth);
                that._synchronizeColumns();
                $.each(VIEW_NAMES, function(index, viewName) {
                    var view = that.getView(viewName);
                    if (view)
                        view.resize()
                });
                editorFactory && editorFactory.resize();
                this._lastWidth = $rootElement.width();
                this._lastHeight = $rootElement.height()
            },
            optionChanged: function(args) {
                switch (args.name) {
                    case"width":
                    case"height":
                        this.component._renderDimensions();
                        this.resize();
                    default:
                        this.callBase(args)
                }
            },
            init: function() {
                var that = this;
                that._dataController = that.getController("data");
                that._columnsController = that.getController("columns");
                that._columnHeadersView = that.getView("columnHeadersView");
                that._footerView = that.getView("footerView");
                that._rowsView = that.getView("rowsView")
            }
        });
        dataGrid.SynchronizeScrollingController = dataGrid.ViewController.inherit({
            _scrollChangedHandler: function(views, pos, viewName) {
                for (var j = 0; j < views.length; j++)
                    if (views[j].name !== viewName)
                        views[j].scrollTo({
                            left: pos.left,
                            top: pos.top
                        })
            },
            init: function() {
                var view,
                    views = [this.getView("columnHeadersView"), this.getView("footerView"), this.getView("rowsView")],
                    i;
                for (i = 0; i < views.length; i++) {
                    view = views[i];
                    if (view)
                        view.scrollChanged.add($.proxy(this._scrollChangedHandler, this, views))
                }
            }
        });
        dataGrid.GridView = dataGrid.View.inherit({
            _endUpdateCore: function() {
                if (this.component._requireResize) {
                    this.component._requireResize = false;
                    this._resizingController.resize()
                }
            },
            init: function() {
                var that = this;
                that._resizingController = this.getController("resizing");
                that._dataController = that.getController("data")
            },
            getView: function(name) {
                return this.component._views[name]
            },
            element: function() {
                return this._groupElement
            },
            optionChanged: function(args) {
                var that = this;
                if (commonUtils.isDefined(that._groupElement) && args.name === "showBorders") {
                    that._groupElement.toggleClass(DATAGRID_BORDERS_CLASS, !!args.value);
                    args.handled = true
                }
                else
                    that.callBase(args)
            },
            render: function($rootElement) {
                var that = this,
                    groupElement = that._groupElement || $("<div />").addClass(DATAGRID_CLASS).toggleClass(DATAGRID_BORDERS_CLASS, !!that.option("showBorders"));
                that.component.setAria({
                    role: "application",
                    label: Globalize.localize("dxDataGrid-ariaDataGrid")
                }, $rootElement);
                that._rootElement = $rootElement || that._rootElement;
                that._groupElement = groupElement;
                $.each(VIEW_NAMES, function(index, viewName) {
                    var view = that.getView(viewName);
                    if (view)
                        view.render(groupElement)
                });
                that.update()
            },
            update: function() {
                var that = this,
                    $rootElement = that._rootElement,
                    $groupElement = that._groupElement,
                    resizingController = that.getController("resizing");
                if ($rootElement && $groupElement) {
                    if (!$groupElement.parent().length) {
                        resizingController.updateSize($rootElement);
                        $groupElement.appendTo($rootElement);
                        that.getView("columnHeadersView").renderDelayedTemplates();
                        that.getView("rowsView").renderDelayedTemplates()
                    }
                    resizingController.resize();
                    if (that._dataController.isLoaded())
                        that.component._fireContentReadyAction()
                }
            }
        });
        dataGrid.registerModule("gridView", {
            defaultOptions: function() {
                return {showBorders: false}
            },
            controllers: {
                resizing: dataGrid.ResizingController,
                synchronizeScrolling: dataGrid.SynchronizeScrollingController
            },
            views: {gridView: dataGrid.GridView}
        });
        $.extend(dataGrid.__internals, {
            viewNames: VIEW_NAMES,
            DATAGRID_CLASS: DATAGRID_CLASS,
            DATAGRID_COLUMN_HEADERS_HIDDEN: DATAGRID_COLUMN_HEADERS_HIDDEN,
            DATAGRID_BORDERS_CLASS: DATAGRID_BORDERS_CLASS
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.js */
    (function($, DX) {
        var ui = DX.ui,
            stringUtils = DX.require("/utils/utils.string"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget"),
            eventUtils = DX.require("/ui/events/ui.events.utils"),
            isDefined = DX.require("/utils/utils.common").isDefined,
            DATA_AREA_CELL_CLASS_NAME = "dx-area-data-cell",
            ROW_AREA_CELL_CLASS_NAME = "dx-area-row-cell",
            COLUMN_AREA_CELL_CLASS_NAME = "dx-area-column-cell",
            DESCRIPTION_AREA_CELL_CLASS_NAME = "dx-area-description-cell",
            BORDERS_CLASS_NAME = "dx-pivotgrid-border",
            TEST_HEIGHT = 66666;
        function mergeArraysByMaxValue(values1, values2) {
            var result = [],
                i;
            for (i = 0; i < values1.length; i++)
                result.push(Math.max(values1[i] || 0, values2[i] || 0));
            return result
        }
        function getArraySum(array) {
            var sum = 0;
            $.each(array, function(_, value) {
                sum += value || 0
            });
            return sum
        }
        function adjustSizeArray(sizeArray, space) {
            var delta = space / sizeArray.length;
            for (var i = 0; i < sizeArray.length; i++)
                sizeArray[i] -= delta
        }
        function subscribeToScrollEvent(area, handler) {
            area.off("scroll").off("stop").on('scroll', handler).on("stop", handler)
        }
        var scrollBarInfoCache = {};
        function getScrollBarInfo(rootElement, useNativeScrolling) {
            if (scrollBarInfoCache[useNativeScrolling])
                return scrollBarInfoCache[useNativeScrolling];
            var scrollBarWidth = 0,
                scrollBarUseNative,
                options = {};
            var container = $('<div>').css({
                    position: 'absolute',
                    visibility: 'hidden',
                    width: 100,
                    height: 100
                }).appendTo(rootElement);
            var content = $('<p>').css({
                    width: '100%',
                    height: 200
                }).appendTo(container);
            if (useNativeScrolling !== 'auto') {
                options.useNative = !!useNativeScrolling;
                options.useSimulatedScrollbar = !useNativeScrolling
            }
            container.dxScrollable(options);
            scrollBarUseNative = container.dxScrollable('instance').option('useNative');
            scrollBarWidth = scrollBarUseNative ? container.width() - content.width() : 0;
            container.remove();
            scrollBarInfoCache[useNativeScrolling] = {
                scrollBarWidth: scrollBarWidth,
                scrollBarUseNative: scrollBarUseNative
            };
            return scrollBarInfoCache[useNativeScrolling]
        }
        registerComponent("dxPivotGrid", ui, Widget.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        scrolling: {
                            timeout: 300,
                            renderingTreshold: 150,
                            mode: "standard",
                            useNative: "auto",
                            removeInvisiblePages: true
                        },
                        encodeHtml: true,
                        dataSource: null,
                        activeStateEnabled: false,
                        fieldChooser: {
                            minWidth: 250,
                            minHeight: 250,
                            enabled: true,
                            layout: 0,
                            title: Globalize.localize("dxPivotGrid-fieldChooserTitle"),
                            width: 600,
                            height: 600
                        },
                        onContextMenuPreparing: null,
                        allowSorting: false,
                        allowSortingBySummary: false,
                        allowFiltering: false,
                        allowExpandAll: false,
                        "export": {
                            enabled: false,
                            fileName: "PivotGrid",
                            proxyUrl: undefined
                        },
                        showRowTotals: true,
                        showRowGrandTotals: true,
                        showColumnTotals: true,
                        showColumnGrandTotals: true,
                        hideEmptySummaryCells: true,
                        showTotalsPrior: "none",
                        loadPanel: {
                            enabled: true,
                            text: Globalize.localize("Loading"),
                            width: 200,
                            height: 70,
                            showIndicator: true,
                            indicatorSrc: "",
                            showPane: true
                        },
                        texts: {
                            grandTotal: Globalize.localize("dxPivotGrid-grandTotal"),
                            total: Globalize.localize("dxPivotGrid-total"),
                            noData: Globalize.localize("dxDataGrid-noDataText"),
                            showFieldChooser: Globalize.localize("dxPivotGrid-showFieldChooser"),
                            expandAll: Globalize.localize("dxPivotGrid-expandAll"),
                            collapseAll: Globalize.localize("dxPivotGrid-collapseAll"),
                            sortColumnBySummary: Globalize.localize("dxPivotGrid-sortColumnBySummary"),
                            sortRowBySummary: Globalize.localize("dxPivotGrid-sortRowBySummary"),
                            removeAllSorting: Globalize.localize("dxPivotGrid-removeAllSorting"),
                            exportToExcel: Globalize.localize("dxDataGrid-exportToExcel")
                        },
                        onCellClick: null,
                        onCellPrepared: null,
                        showBorders: false,
                        stateStoring: {
                            enabled: false,
                            storageKey: null,
                            type: "localStorage",
                            customLoad: null,
                            customSave: null,
                            savingTimeout: 2000
                        },
                        onExpandValueChanging: null,
                        renderCellCountLimit: 20000,
                        onExporting: null,
                        onExported: null,
                        onFileSaving: null
                    })
            },
            _setDeprecatedOptions: function() {
                this.callBase();
                $.extend(this._deprecatedOptions, {useNativeScrolling: {
                        since: "15.2",
                        alias: "scrolling.useNative"
                    }})
            },
            _getDataControllerOptions: function() {
                var that = this;
                return {
                        component: that,
                        dataSource: that.option('dataSource'),
                        texts: that.option('texts'),
                        showRowTotals: that.option('showRowTotals'),
                        showRowGrandTotals: that.option('showRowGrandTotals'),
                        showColumnTotals: that.option('showColumnTotals'),
                        showTotalsPrior: that.option('showTotalsPrior'),
                        showColumnGrandTotals: that.option('showColumnGrandTotals'),
                        hideEmptySummaryCells: that.option("hideEmptySummaryCells"),
                        onFieldsPrepared: function(fields) {
                            $.each(fields, function(index, field) {
                                $.each(["allowSorting", "allowSortingBySummary", "allowFiltering", "allowExpandAll"], function(_, optionName) {
                                    if (field[optionName] === undefined)
                                        pivotGrid.setFieldProperty(field, optionName, that.option(optionName))
                                })
                            })
                        }
                    }
            },
            _initDataController: function() {
                var that = this;
                if (that._dataController)
                    that._dataController.dispose();
                that._dataController = new pivotGrid.DataController(that._getDataControllerOptions());
                that._dataController.changed.add(function() {
                    that._render()
                });
                that._dataController.scrollChanged.add(function(options) {
                    that._scrollLeft = options.left;
                    that._scrollTop = options.top
                });
                that._dataController.loadingChanged.add(function() {
                    that._updateLoading()
                });
                var expandValueChanging = that.option('onExpandValueChanging');
                if (expandValueChanging)
                    that._dataController.expandValueChanging.add(function(e) {
                        expandValueChanging(e)
                    })
            },
            _init: function() {
                var that = this;
                that.callBase();
                that._initDataController();
                that._scrollLeft = that._scrollTop = null;
                that._initActions();
                that._clientExporter = new DX.dxClientExporter({
                    exportingAction: that._actions.onExporting,
                    exportedAction: that._actions.onExported,
                    fileSavingAction: that._actions.onFileSaving
                })
            },
            _initActions: function() {
                this._actions = {
                    onContextMenuPreparing: this._createActionByOption("onContextMenuPreparing"),
                    onCellClick: this._createActionByOption("onCellClick"),
                    onExporting: this._createActionByOption("onExporting"),
                    onExported: this._createActionByOption("onExported"),
                    onFileSaving: this._createActionByOption("onFileSaving")
                }
            },
            _trigger: function(eventName, eventArg) {
                this._actions[eventName](eventArg)
            },
            _optionValuesEqual: function(name, oldValue, newValue) {
                if (name === "dataSource" && newValue instanceof DX.data.PivotGridDataSource && oldValue instanceof DX.data.PivotGridDataSource)
                    return newValue === oldValue;
                return this.callBase.apply(this, arguments)
            },
            _optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"dataSource":
                    case"allowSorting":
                    case"allowFiltering":
                    case"allowExpandAll":
                    case"allowSortingBySummary":
                    case"scrolling":
                    case"stateStoring":
                        that._initDataController();
                        that._fieldChooserPopup.hide();
                        that._invalidate();
                        break;
                    case"texts":
                    case"showTotalsPrior":
                    case"showRowTotals":
                    case"showRowGrandTotals":
                    case"showColumnTotals":
                    case"showColumnGrandTotals":
                    case"hideEmptySummaryCells":
                        that._dataController.updateViewOptions(that._getDataControllerOptions());
                        break;
                    case"useNativeScrolling":
                    case"encodeHtml":
                    case"renderCellCountLimit":
                        that._invalidate();
                        break;
                    case"rtlEnabled":
                        that.callBase(args);
                        that._renderFieldChooser();
                        that._renderContextMenu();
                        that._renderLoadPanel(that._dataArea.groupElement(), that.element());
                        that._invalidate();
                        break;
                    case"export":
                        that._renderDescriptionArea();
                        break;
                    case"onExpandValueChanging":
                    case"onCellPrepared":
                        break;
                    case"onCellClick":
                    case"onContextMenuPreparing":
                        that._actions[args.name] = that._createActionByOption(args.name);
                        break;
                    case"fieldChooser":
                        that._renderFieldChooser();
                        that._renderDescriptionArea();
                        break;
                    case"loadPanel":
                        that._renderLoadPanel(that._dataArea.groupElement(), that.element());
                        that._invalidate();
                        break;
                    case"showBorders":
                        that._tableElement().toggleClass(BORDERS_CLASS_NAME, args.value);
                        that.updateDimensions();
                        break;
                    case"onExporting":
                        that._actions.onExporting = that._createActionByOption(args.name);
                        that._clientExporter.option("exportingAction", that._actions.onExporting);
                        break;
                    case"onExported":
                        that._actions.onExported = that._createActionByOption(args.name);
                        that._clientExporter.option("exportedAction", that._actions.onExported);
                        break;
                    case"onFileSaving":
                        that._actions.onFileSaving = that._createActionByOption(args.name);
                        that._clientExporter.option("fileSavingAction", that._actions.onFileSaving);
                        break;
                    default:
                        that.callBase(args)
                }
            },
            _updateScrollPosition: function(columnsArea, rowsArea, dataArea) {
                var that = this,
                    scrollTop,
                    scrollLeft,
                    scrolled = that._scrollTop || that._scrollLeft;
                if (rowsArea && !rowsArea.hasScroll() && that._hasHeight)
                    that._scrollTop = null;
                if (columnsArea && !columnsArea.hasScroll())
                    that._scrollLeft = null;
                if (that._scrollTop !== null || that._scrollLeft !== null || scrolled) {
                    scrollTop = that._scrollTop || 0;
                    scrollLeft = that._scrollLeft || 0;
                    dataArea.scrollTo({
                        x: scrollLeft,
                        y: scrollTop
                    });
                    columnsArea.scrollTo(scrollLeft);
                    rowsArea.scrollTo(scrollTop);
                    that._dataController.updateWindowScrollPosition(that._scrollTop)
                }
                else
                    $.each([columnsArea, rowsArea, dataArea], function(_, area) {
                        if (area)
                            area.updateScrollable()
                    })
            },
            _subscribeToEvents: function(columnsArea, rowsArea, dataArea) {
                var that = this,
                    scrollHandler = function(e) {
                        var scrollOffset = e.scrollOffset,
                            leftOffset = isDefined(scrollOffset.left) ? scrollOffset.left : that._scrollLeft,
                            topOffset = isDefined(scrollOffset.top) && that._hasHeight ? scrollOffset.top : that._scrollTop;
                        if ((that._scrollLeft || 0) !== (leftOffset || 0) || (that._scrollTop || 0) !== (topOffset || 0)) {
                            that._scrollLeft = leftOffset;
                            that._scrollTop = topOffset;
                            that._updateScrollPosition(columnsArea, rowsArea, dataArea);
                            if (that.option("scrolling.mode") === "virtual")
                                that._dataController.setViewportPosition(that._scrollLeft, that._scrollTop)
                        }
                    };
                subscribeToScrollEvent(dataArea, scrollHandler);
                subscribeToScrollEvent(rowsArea, scrollHandler);
                subscribeToScrollEvent(columnsArea, scrollHandler);
                if (!that._hasHeight)
                    that._dataController.subscribeToWindowScrollEvents(dataArea.groupElement())
            },
            _clean: $.noop,
            _needDelayResizing: function(cellsInfo) {
                var cellsCount = cellsInfo.length * (cellsInfo.length ? cellsInfo[0].length : 0);
                return cellsCount > this.option("renderCellCountLimit")
            },
            _renderFieldChooser: function() {
                var that = this,
                    container = that._pivotGridContainer,
                    fieldChooserOptions = that.option("fieldChooser") || {};
                var popupOptions = {
                        visible: false,
                        shading: false,
                        title: fieldChooserOptions.title,
                        width: fieldChooserOptions.width,
                        height: fieldChooserOptions.height,
                        showCloseButton: true,
                        onShown: function(e) {
                            var popup = e.component,
                                $content = e.component.content();
                            that._createComponent($content, "dxPivotGridFieldChooser", {
                                layout: fieldChooserOptions.layout,
                                texts: fieldChooserOptions.texts || {},
                                dataSource: that.getDataSource(),
                                width: undefined,
                                height: undefined
                            });
                            that._createComponent($content.parent(), "dxResizable", {
                                handles: that.option('rtlEnabled') ? "left bottom" : "right bottom",
                                onResize: function(e) {
                                    popup._setContentHeight();
                                    $content.dxPivotGridFieldChooser("updateDimensions")
                                },
                                minWidth: fieldChooserOptions.minWidth,
                                minHeight: fieldChooserOptions.minHeight
                            })
                        }
                    };
                if (that._fieldChooserPopup)
                    that._fieldChooserPopup.option(popupOptions);
                else
                    that._fieldChooserPopup = that._createComponent($('<div>').addClass('dx-fieldchooser-popup').appendTo(container), "dxPopup", popupOptions)
            },
            _renderContextMenu: function() {
                var that = this,
                    $container = that._pivotGridContainer;
                if (that._contextMenu)
                    that._contextMenu.element().remove();
                that._contextMenu = that._createComponent($("<div>").appendTo($container), "dxContextMenu", {
                    onPositioning: function(actionArgs) {
                        var event = actionArgs.jQueryEvent,
                            cellElement = event.target.cellIndex >= 0 ? event.target : $(event.target).closest('td').get(0),
                            cellArgs,
                            items;
                        if (cellElement) {
                            cellArgs = that._createCellArgs(cellElement, event);
                            items = that._getContextMenuItems(cellArgs);
                            if (items) {
                                actionArgs.component.option('items', items);
                                return
                            }
                        }
                        actionArgs.cancel = true
                    },
                    onItemClick: function(params) {
                        params.itemData.onItemClick && params.itemData.onItemClick(params)
                    },
                    cssClass: pivotGrid.cssClassNames.pivotGrid,
                    target: that.element()
                })
            },
            _getContextMenuItems: function(e) {
                var that = this,
                    items = [];
                if (e.area === "row" || e.area === "column") {
                    var areaFields = e[e.area + "Fields"],
                        oppositeAreaFields = e[e.area === "column" ? "rowFields" : "columnFields"],
                        field = e.cell.path && areaFields[e.cell.path.length - 1],
                        dataSource = that.getDataSource();
                    if (field && field.allowExpandAll && e.cell.path.length < e[e.area + "Fields"].length && e.cell.type === "D") {
                        items.push({
                            beginGroup: true,
                            icon: "none",
                            text: that.option("texts.expandAll"),
                            onItemClick: function() {
                                dataSource.expandAll(field.index)
                            }
                        });
                        items.push({
                            text: that.option("texts.collapseAll"),
                            icon: "none",
                            onItemClick: function() {
                                dataSource.collapseAll(field.index)
                            }
                        })
                    }
                    if (e.cell.isLast) {
                        var sortingBySummaryItemCount = 0;
                        $.each(oppositeAreaFields, function(index, field) {
                            if (field.allowSortingBySummary)
                                $.each(e.dataFields, function(dataIndex, dataField) {
                                    if (isDefined(e.cell.dataIndex) && e.cell.dataIndex !== dataIndex)
                                        return;
                                    var showDataFieldCaption = !isDefined(e.cell.dataIndex) && e.dataFields.length > 1,
                                        textFormat = that.option(e.area === "column" ? "texts.sortColumnBySummary" : "texts.sortRowBySummary"),
                                        checked = pivotGrid.findField(e.dataFields, field.sortBySummaryField) === dataIndex && (e.cell.path || []).join("/") === (field.sortBySummaryPath || []).join("/"),
                                        text = stringUtils.format(textFormat, showDataFieldCaption ? field.caption + " - " + dataField.caption : field.caption);
                                    items.push({
                                        beginGroup: sortingBySummaryItemCount === 0,
                                        icon: checked ? field.sortOrder === "desc" ? "desc" : "asc" : "none",
                                        text: text,
                                        onItemClick: function() {
                                            dataSource.field(field.index, {
                                                sortBySummaryField: dataField.caption || dataField.dataField,
                                                sortBySummaryPath: e.cell.path,
                                                sortOrder: field.sortOrder === "desc" ? "asc" : "desc"
                                            });
                                            dataSource.load()
                                        }
                                    });
                                    sortingBySummaryItemCount++
                                })
                        });
                        $.each(oppositeAreaFields, function(index, field) {
                            if (field.allowSortingBySummary && isDefined(field.sortBySummaryField)) {
                                items.push({
                                    beginGroup: sortingBySummaryItemCount === 0,
                                    icon: "none",
                                    text: that.option("texts.removeAllSorting"),
                                    onItemClick: function() {
                                        $.each(oppositeAreaFields, function(index, field) {
                                            dataSource.field(field.index, {
                                                sortBySummaryField: undefined,
                                                sortBySummaryPath: undefined,
                                                sortOrder: undefined
                                            })
                                        });
                                        dataSource.load()
                                    }
                                });
                                return false
                            }
                        })
                    }
                }
                if (that.option("fieldChooser.enabled"))
                    items.push({
                        beginGroup: true,
                        icon: "column-chooser",
                        text: that.option("texts.showFieldChooser"),
                        onItemClick: function() {
                            that._fieldChooserPopup.show()
                        }
                    });
                e.items = items;
                if (that.option("export.enabled"))
                    items.push({
                        beginGroup: true,
                        icon: "exportxlsx",
                        text: that.option("texts.exportToExcel"),
                        onItemClick: function() {
                            that.exportToExcel()
                        }
                    });
                that._trigger("onContextMenuPreparing", e);
                items = e.items;
                if (items && items.length)
                    return items
            },
            _createCellArgs: function(cellElement, jQueryEvent) {
                var that = this,
                    $cellElement = $(cellElement),
                    columnIndex = cellElement.cellIndex,
                    rowIndex = cellElement.parentElement.rowIndex,
                    $table = $cellElement.closest('table'),
                    dataSource = that.getDataSource(),
                    data = $table.data("data"),
                    cell = data && data[rowIndex] && data[rowIndex][columnIndex],
                    args = {
                        area: $table.data("area"),
                        rowFields: dataSource.getAreaFields("row"),
                        columnFields: dataSource.getAreaFields("column"),
                        dataFields: dataSource.getAreaFields("data"),
                        rowIndex: rowIndex,
                        columnIndex: columnIndex,
                        cellElement: $cellElement,
                        cell: cell,
                        jQueryEvent: jQueryEvent
                    };
                return args
            },
            _handleCellClick: function(e) {
                var that = this,
                    args = that._createCellArgs(e.currentTarget, e),
                    cell = args.cell;
                if (!args.area && (args.rowIndex || args.columnIndex))
                    return;
                that._trigger("onCellClick", args);
                if (cell && isDefined(cell.expanded))
                    setTimeout(function() {
                        that._dataController[cell.expanded ? "collapseHeaderItem" : "expandHeaderItem"](args.area, cell.path)
                    })
            },
            _getNoDataText: function() {
                return this.option("texts.noData")
            },
            _updateNoDataText: DX.ui.dxDataGrid.RowsView.prototype._updateNoDataText,
            _renderLoadPanel: DX.ui.dxDataGrid.RowsView.prototype._renderLoadPanel,
            _updateLoading: function() {
                var that = this;
                that._loadPanel && that._loadPanel.option("visible", that._dataController.isLoading())
            },
            _renderDescriptionArea: function() {
                var that = this;
                var $descriptionCell = that.element().find("." + DESCRIPTION_AREA_CELL_CLASS_NAME);
                $descriptionCell.empty();
                if (that.option("fieldChooser.enabled"))
                    that._createComponent($("<div>").appendTo($descriptionCell).addClass("dx-pivotgrid-field-chooser-button"), "dxButton", {
                        icon: "column-chooser",
                        hint: that.option("texts.showFieldChooser"),
                        onClick: function() {
                            that.getFieldChooserPopup().show()
                        }
                    });
                if (that.option("export.enabled"))
                    that._createComponent($("<div>").appendTo($descriptionCell).addClass("dx-pivotgrid-export-button"), "dxButton", {
                        icon: "exportxlsx",
                        hint: that.option("texts.exportToExcel"),
                        onClick: function() {
                            that.exportToExcel()
                        }
                    })
            },
            _detectHasContainerHeight: function() {
                var that = this,
                    element = that.element(),
                    testElement;
                if (that._hasHeight === undefined && element.is(":visible")) {
                    testElement = $("<div>").height(TEST_HEIGHT);
                    that._pivotGridContainer.addClass("dx-hidden");
                    element.append(testElement);
                    that._hasHeight = element.height() !== TEST_HEIGHT;
                    that._pivotGridContainer.removeClass("dx-hidden");
                    testElement.remove()
                }
            },
            _renderContentImpl: function() {
                var that = this,
                    columnsAreaElement,
                    rowsAreaElement,
                    dataAreaElement,
                    tableElement,
                    dataArea = that._dataArea || new pivotGrid.DataArea(that),
                    rowsArea = that._rowsArea || new pivotGrid.VerticalHeadersArea(that),
                    columnsArea = that._columnsArea || new pivotGrid.HorizontalHeadersArea(that),
                    scrollBarInfo = getScrollBarInfo(that.element(), that.option("scrolling.useNative")),
                    isFirstDrawing = !that._pivotGridContainer,
                    cellsInfo = that._dataController.getCellsInfo();
                that._scrollBarWidth = scrollBarInfo.scrollBarWidth;
                that._scrollBarUseNative = scrollBarInfo.scrollBarUseNative;
                if (isFirstDrawing) {
                    that.element().addClass(pivotGrid.cssClassNames.pivotGrid).addClass(pivotGrid.cssClassNames.rowLines);
                    that._pivotGridContainer = $('<div>');
                    that._renderFieldChooser();
                    that._renderContextMenu();
                    columnsAreaElement = $('<td>').addClass(COLUMN_AREA_CELL_CLASS_NAME);
                    rowsAreaElement = $('<td>').addClass(ROW_AREA_CELL_CLASS_NAME);
                    dataAreaElement = $('<td>').addClass(DATA_AREA_CELL_CLASS_NAME);
                    tableElement = $('<table>').css({width: "100%"}).toggleClass(BORDERS_CLASS_NAME, !!that.option("showBorders")).on(eventUtils.addNamespace("dxclick", "dxPivotGrid"), 'td', $.proxy(that, "_handleCellClick"));
                    $('<tr>').append($('<td>').addClass(DESCRIPTION_AREA_CELL_CLASS_NAME)).append(columnsAreaElement).appendTo(tableElement);
                    $('<tr>').addClass(pivotGrid.cssClassNames.bottomAraesRow).append(rowsAreaElement).append(dataAreaElement).appendTo(tableElement);
                    that._pivotGridContainer.append(tableElement);
                    that.element().append(that._pivotGridContainer)
                }
                else
                    tableElement = that._tableElement();
                that._rowsArea = rowsArea;
                that._columnsArea = columnsArea;
                that._dataArea = dataArea;
                columnsArea.render(columnsAreaElement, that._dataController.getColumnsInfo());
                rowsArea.render(rowsAreaElement, that._dataController.getRowsInfo());
                dataArea.render(dataAreaElement, cellsInfo);
                dataArea.tableElement().prepend(columnsArea.headElement());
                var updateHandler = function() {
                        that.updateDimensions();
                        that._subscribeToEvents(columnsArea, rowsArea, dataArea)
                    };
                if (isFirstDrawing) {
                    that._renderLoadPanel(dataArea.groupElement().parent(), that.element());
                    that._renderDescriptionArea();
                    rowsArea.processScroll();
                    columnsArea.processScroll()
                }
                that._needDelayResizing(cellsInfo) && isFirstDrawing ? setTimeout(updateHandler) : updateHandler()
            },
            _fireContentReadyAction: function() {
                if (!this._dataController.isLoading())
                    this.callBase()
            },
            getScrollPath: function(area) {
                var that = this;
                if (area === 'column')
                    return that._columnsArea.getScrollPath(that._scrollLeft);
                else
                    return that._rowsArea.getScrollPath(that._scrollTop)
            },
            getDataSource: function() {
                return this._dataController.getDataSource()
            },
            getFieldChooserPopup: function() {
                return this._fieldChooserPopup
            },
            hasScroll: function(area) {
                var that = this;
                if (area === 'column')
                    return that._columnsArea.hasScroll();
                else
                    return that._rowsArea.hasScroll()
            },
            _dimensionChanged: function() {
                this.updateDimensions()
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this.updateDimensions()
            },
            _dispose: function() {
                var that = this;
                that.callBase.apply(that, arguments);
                if (that._dataController)
                    that._dataController.dispose()
            },
            _tableElement: function() {
                return this.element().find('table').first()
            },
            resize: function() {
                this.updateDimensions()
            },
            isReady: function() {
                return this.callBase() && !this._dataController.isLoading()
            },
            updateDimensions: function() {
                var that = this,
                    groupWidth,
                    groupHeight,
                    tableElement = that._tableElement(),
                    rowsArea = that._rowsArea,
                    columnsArea = that._columnsArea,
                    dataArea = that._dataArea,
                    dataAreaHeights,
                    rowsAreaHeights,
                    resultHeights,
                    resultWidths,
                    rowsAreaColumnWidths,
                    bordersWidth,
                    totalWidth = 0,
                    totalHeight = 0,
                    rowsAreaWidth = 0,
                    hasRowsScroll,
                    hasColumnsScroll,
                    scrollBarWidth = that._scrollBarWidth || 0,
                    dataAreaCell = tableElement.find("." + DATA_AREA_CELL_CLASS_NAME),
                    rowAreaCell = tableElement.find("." + ROW_AREA_CELL_CLASS_NAME),
                    columnAreaCell = tableElement.find("." + COLUMN_AREA_CELL_CLASS_NAME),
                    descriptionCell = tableElement.find("." + DESCRIPTION_AREA_CELL_CLASS_NAME),
                    elementWidth,
                    columnsAreaHeight,
                    descriptionCellHeight,
                    columnsAreaRowHeights,
                    columnsAreaRowCount;
                that._detectHasContainerHeight();
                if (!dataArea.headElement().length) {
                    dataArea.tableElement().prepend(columnsArea.headElement());
                    dataArea.resetColumnsWidth()
                }
                dataArea.reset();
                rowsArea.reset();
                columnsArea.reset();
                resultWidths = dataArea.getColumnsWidth();
                rowsAreaHeights = rowsArea.getRowsHeight();
                dataAreaHeights = dataArea.getRowsHeight();
                descriptionCellHeight = descriptionCell.outerHeight();
                columnsAreaRowCount = that._dataController.getColumnsInfo().length;
                resultHeights = mergeArraysByMaxValue(rowsAreaHeights, dataAreaHeights.slice(columnsAreaRowCount));
                columnsAreaRowHeights = dataAreaHeights.slice(0, columnsAreaRowCount);
                columnsAreaHeight = getArraySum(columnsAreaRowHeights);
                rowsAreaColumnWidths = rowsArea.getColumnsWidth();
                if (that._hasHeight) {
                    bordersWidth = columnAreaCell.outerHeight() - columnAreaCell.height() + dataAreaCell.outerHeight() - dataAreaCell.height() + tableElement.outerHeight() - tableElement.height();
                    groupHeight = that.element().height() - (Math.max(dataArea.headElement().height(), columnAreaCell.height()) + bordersWidth)
                }
                totalWidth = dataArea.tableElement().width();
                totalHeight = getArraySum(resultHeights);
                rowsAreaWidth = getArraySum(rowsAreaColumnWidths);
                elementWidth = that.element().width();
                bordersWidth = rowAreaCell.outerWidth() - rowAreaCell.width() + dataAreaCell.outerWidth() - dataAreaCell.width() + tableElement.outerWidth() - tableElement.width();
                groupWidth = elementWidth - rowsAreaWidth - bordersWidth;
                hasRowsScroll = that._hasHeight && totalHeight - groupHeight >= 1;
                hasColumnsScroll = totalWidth - groupWidth >= 1;
                if (!hasRowsScroll)
                    groupHeight = totalHeight + (hasColumnsScroll ? scrollBarWidth : 0);
                columnsArea.tableElement().append(dataArea.headElement());
                if (!hasColumnsScroll && hasRowsScroll && scrollBarWidth)
                    adjustSizeArray(resultWidths, scrollBarWidth);
                if (descriptionCellHeight > columnsAreaHeight) {
                    adjustSizeArray(columnsAreaRowHeights, columnsAreaHeight - descriptionCellHeight);
                    columnsArea.setRowsHeight(columnsAreaRowHeights)
                }
                columnsArea.groupWidth(groupWidth);
                columnsArea.processScrollBarSpacing(hasRowsScroll ? scrollBarWidth : 0);
                columnsArea.setColumnsWidth(resultWidths);
                rowsArea.groupHeight(that._hasHeight ? groupHeight : "auto");
                rowsArea.processScrollBarSpacing(hasColumnsScroll ? scrollBarWidth : 0);
                rowsArea.setColumnsWidth(rowsAreaColumnWidths);
                rowsArea.setRowsHeight(resultHeights);
                dataArea.setColumnsWidth(resultWidths);
                dataArea.setRowsHeight(resultHeights);
                dataArea.groupWidth(groupWidth);
                dataArea.groupHeight(that._hasHeight ? groupHeight : "auto");
                dataAreaCell.toggleClass("dx-bottom-border", !(hasRowsScroll || scrollBarWidth));
                rowAreaCell.toggleClass("dx-bottom-border", !(hasRowsScroll && !scrollBarWidth));
                if (!that._hasHeight && elementWidth !== that.element().width()) {
                    var diff = elementWidth - that.element().width();
                    if (!hasColumnsScroll) {
                        adjustSizeArray(resultWidths, diff);
                        columnsArea.setColumnsWidth(resultWidths);
                        dataArea.setColumnsWidth(resultWidths)
                    }
                    dataArea.groupWidth(groupWidth - diff);
                    columnsArea.groupWidth(groupWidth - diff)
                }
                if (that.option("scrolling.mode") === "virtual" && !that._dataController.isLoading()) {
                    var virtualContentParams = that._dataController.calculateVirtualContentParams({
                            contentWidth: totalWidth,
                            contentHeight: totalHeight,
                            rowCount: resultHeights.length,
                            columnCount: resultWidths.length,
                            viewportWidth: groupWidth,
                            viewportHeight: that._hasHeight ? groupHeight : $(window).outerHeight()
                        });
                    dataArea.setVirtualContentParams({
                        top: virtualContentParams.contentTop,
                        left: virtualContentParams.contentLeft,
                        width: virtualContentParams.width,
                        height: virtualContentParams.height
                    });
                    rowsArea.setVirtualContentParams({
                        top: virtualContentParams.contentTop,
                        width: rowsAreaWidth,
                        height: virtualContentParams.height
                    });
                    columnsArea.setVirtualContentParams({
                        left: virtualContentParams.contentLeft,
                        width: virtualContentParams.width,
                        height: columnsArea.groupElement().height()
                    })
                }
                that._updateScrollPosition(columnsArea, rowsArea, dataArea);
                dataArea.processScroll(that._scrollBarUseNative);
                that._updateLoading();
                that._updateNoDataText(dataArea.groupElement());
                that._testResultWidths = resultWidths;
                that._testResultHeights = resultHeights
            },
            applyPartialDataSource: function(area, path, dataSource) {
                this._dataController.applyPartialDataSource(area, path, dataSource)
            }
        }));
        var pivotGrid = $.extend(ui.dxPivotGrid, {
                cssClassNames: {
                    pivotGrid: 'dx-pivotgrid',
                    rowLines: 'dx-row-lines',
                    area: 'dx-pivotgrid-area',
                    areaData: 'dx-pivotgrid-area-data',
                    splitter: 'dx-pivotgrid-splitter',
                    splitterButton: 'dx-button',
                    splitterButtonDisable: 'dx-button-disable',
                    splitterExpand: 'dx-expand',
                    splitterCollapse: 'dx-collapse',
                    bottomAraesRow: 'dx-bottom-row',
                    verticalScroll: 'dx-vertical-scroll',
                    headersVertical: 'dx-pivotgrid-vertical-headers',
                    headersHorizontal: 'dx-pivotgrid-horizontal-headers',
                    headersVerticalLastCell: 'dx-last-cell',
                    headersVerticalExpandBorder: 'dx-expand-border',
                    headersExpandCollapseImage: 'dx-expand',
                    headersExpanded: 'dx-pivotgrid-expanded',
                    headersCollapsed: 'dx-pivotgrid-collapsed',
                    bottomBorder: 'dx-pivotgrid-bottom-border',
                    total: 'dx-total',
                    grandTotal: 'dx-grandtotal',
                    rowTotal: 'dx-row-total'
                },
                mergeArraysByMaxValue: mergeArraysByMaxValue
            })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.dataSource.js */
    (function($, DX) {
        var pivotGrid = DX.ui.dxPivotGrid,
            commonUtils = DX.require("/utils/utils.common"),
            isDefined = commonUtils.isDefined,
            each = $.each,
            Class = DevExpress.require("/class"),
            EventsMixin = DX.require("/eventsMixin"),
            inflector = DX.require("/utils/utils.inflector"),
            normalizeIndexes = DX.require("/utils/utils.array").normalizeIndexes,
            formatHelper = DX.require("/utils/utils.formatHelper"),
            DESCRIPTION_NAME_BY_AREA = {
                row: "rows",
                column: "columns",
                data: "values",
                filter: "filters"
            },
            STATE_PROPERTIES = ["area", "areaIndex", "sortOrder", "filterType", "filterValues", "sortBy", "sortBySummaryField", "sortBySummaryPath", "expanded"],
            CALCULATED_PROPERTIES = ["format", "selector", "customizeText", "caption"];
        function findField(fields, id) {
            var i,
                field;
            if (fields && commonUtils.isDefined(id))
                for (i = 0; i < fields.length; i++) {
                    field = fields[i];
                    if (field.name === id || field.caption === id || field.dataField === id || field.index === id)
                        return i
                }
            return -1
        }
        function foreachTree(items, callback, parentAtFirst, members) {
            members = members || [];
            items = items || [];
            var item,
                i;
            for (i = 0; i < items.length; i++) {
                item = items[i];
                members.unshift(item);
                if (parentAtFirst && callback(members, i) === false)
                    return;
                if (item.children)
                    foreachTree(item.children, callback, parentAtFirst, members);
                if (!parentAtFirst && callback(members, i) === false)
                    return;
                members.shift();
                if (items[i] !== item)
                    i--
            }
        }
        function setFieldProperty(field, property, value, isInitialization) {
            var initProperties = field._initProperties = field._initProperties || {},
                initValue = isInitialization ? value : field[property];
            if (!initProperties.hasOwnProperty(property) || isInitialization)
                initProperties[property] = initValue;
            field[property] = value
        }
        function createCaption(field) {
            var caption = field.dataField || field.groupName || "",
                summaryType = (field.summaryType || "").toLowerCase();
            if (commonUtils.isString(field.groupInterval))
                caption += "_" + field.groupInterval;
            if (summaryType && summaryType !== "custom") {
                summaryType = summaryType.replace(/^./, summaryType[0].toUpperCase());
                if (caption.length)
                    summaryType = " (" + summaryType + ")"
            }
            else
                summaryType = "";
            return inflector.titleize(caption) + summaryType
        }
        function resetFieldState(field, properties) {
            var initialProperties = field._initProperties || {};
            $.each(properties, function(_, prop) {
                if (initialProperties.hasOwnProperty(prop))
                    field[prop] = initialProperties[prop]
            })
        }
        function updateCalculatedFieldProperties(field, calculatedProperties) {
            resetFieldState(field, calculatedProperties);
            if (!isDefined(field.caption))
                setFieldProperty(field, "caption", createCaption(field))
        }
        function createPath(items) {
            var result = [],
                i;
            for (i = items.length - 1; i >= 0; i--)
                result.push(items[i].key || items[i].value);
            return result
        }
        function formatValue(value, options) {
            var formatObject = {
                    value: value,
                    valueText: formatHelper.format(value, options.format, options.precision) || ''
                };
            return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText
        }
        function foreachDataLevel(data, callback, index, childrenField) {
            var item,
                i;
            index = index || 0;
            childrenField = childrenField || "children";
            if (data.length)
                callback(data, index);
            for (i = 0; i < data.length; i++) {
                item = data[i];
                if (item[childrenField] && item[childrenField].length)
                    foreachDataLevel(item[childrenField], callback, index + 1, childrenField)
            }
        }
        function getCompareFunction(valueSelector) {
            return function(a, b) {
                    var result = 0;
                    if (valueSelector(a) > valueSelector(b))
                        result = 1;
                    else if (valueSelector(a) < valueSelector(b))
                        result = -1;
                    return result
                }
        }
        function areExpressionsUsed(descriptions) {
            var expressionsUsed = false;
            each(descriptions.values, function(_, field) {
                if (field.summaryDisplayMode || field.calculateSummaryValue || field.runningTotal) {
                    expressionsUsed = true;
                    return false
                }
            });
            return expressionsUsed
        }
        DX.data.PivotGridDataSource = pivotGrid.DataSource = Class.inherit(function() {
            var findHeaderItem = function(headerItems, path) {
                    if (headerItems._cacheByPath)
                        return headerItems._cacheByPath[path.join(".")] || null
                };
            var getHeaderItemsLastIndex = function(headerItems, grandTotalIndex) {
                    var i,
                        lastIndex = -1,
                        headerItem;
                    if (headerItems)
                        for (i = 0; i < headerItems.length; i++) {
                            headerItem = headerItems[i];
                            lastIndex = Math.max(lastIndex, headerItem.index);
                            if (headerItem.children)
                                lastIndex = Math.max(lastIndex, getHeaderItemsLastIndex(headerItem.children));
                            else if (headerItem.collapsedChildren)
                                lastIndex = Math.max(lastIndex, getHeaderItemsLastIndex(headerItem.collapsedChildren))
                        }
                    if (isDefined(grandTotalIndex))
                        lastIndex = Math.max(lastIndex, grandTotalIndex);
                    return lastIndex
                };
            var updateHeaderItemChildren = function(headerItems, headerItem, children, grandTotalIndex) {
                    var applyingHeaderItemsCount = getHeaderItemsLastIndex(children) + 1,
                        emptyIndex = getHeaderItemsLastIndex(headerItems, grandTotalIndex) + 1,
                        index,
                        applyingItemIndexesToCurrent = [];
                    for (index = 0; index < applyingHeaderItemsCount; index++)
                        applyingItemIndexesToCurrent[index] = emptyIndex++;
                    headerItem.children = children;
                    foreachTree(headerItem.children, function(items) {
                        items[0].index = applyingItemIndexesToCurrent[items[0].index]
                    });
                    return applyingItemIndexesToCurrent
                };
            var updateHeaderItems = function(headerItems, newHeaderItems) {
                    var applyingItemIndexesToCurrent = [];
                    foreachTree(headerItems, function(items) {
                        delete items[0].collapsedChildren
                    });
                    foreachTree(newHeaderItems, function(items) {
                        var headerItem = findHeaderItem(headerItems, createPath(items));
                        if (headerItem)
                            applyingItemIndexesToCurrent[items[0].index] = headerItem.index
                    });
                    return applyingItemIndexesToCurrent
                };
            var updateDataSourceCells = function(dataSource, newDataSourceCells, newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent) {
                    var newRowIndex,
                        newColumnIndex,
                        newRowCells,
                        newCell,
                        rowIndex,
                        columnIndex,
                        dataSourceCells = dataSource.values;
                    if (newDataSourceCells)
                        for (newRowIndex = 0; newRowIndex <= newDataSourceCells.length; newRowIndex++) {
                            newRowCells = newDataSourceCells[newRowIndex];
                            rowIndex = newRowItemIndexesToCurrent[newRowIndex];
                            if (!isDefined(rowIndex))
                                rowIndex = dataSource.grandTotalRowIndex;
                            if (newRowCells && isDefined(rowIndex)) {
                                if (!dataSourceCells[rowIndex])
                                    dataSourceCells[rowIndex] = [];
                                for (newColumnIndex = 0; newColumnIndex <= newRowCells.length; newColumnIndex++) {
                                    newCell = newRowCells[newColumnIndex];
                                    columnIndex = newColumnItemIndexesToCurrent[newColumnIndex];
                                    if (!isDefined(columnIndex))
                                        columnIndex = dataSource.grandTotalColumnIndex;
                                    if (isDefined(newCell) && isDefined(columnIndex))
                                        dataSourceCells[rowIndex][columnIndex] = newCell
                                }
                            }
                        }
                };
            function createStore(dataSourceOptions) {
                var store,
                    storeOptions;
                if ($.isPlainObject(dataSourceOptions) && dataSourceOptions.load)
                    store = new pivotGrid.LocalStore(dataSourceOptions);
                else {
                    if (dataSourceOptions && !dataSourceOptions.store)
                        dataSourceOptions = {store: dataSourceOptions};
                    storeOptions = dataSourceOptions.store;
                    if (storeOptions.type === "xmla")
                        store = new pivotGrid.XmlaStore(storeOptions);
                    else if ($.isPlainObject(storeOptions) && storeOptions.type || storeOptions instanceof DX.data.Store || $.isArray(storeOptions))
                        store = new pivotGrid.LocalStore(dataSourceOptions);
                    else if (storeOptions instanceof Class)
                        store = storeOptions
                }
                return store
            }
            function getExpandedPaths(dataSource, loadOptions, dimentionName) {
                var result = [],
                    fields = loadOptions && loadOptions[dimentionName] || [];
                foreachTree(dataSource[dimentionName], function(items) {
                    var item = items[0],
                        path = createPath(items);
                    if (item.children && fields[path.length - 1] && !fields[path.length - 1].expanded)
                        path.length < fields.length && result.push(path.slice())
                }, true);
                return result
            }
            function setStateProperties(field, srcField, skipInitPropertySave) {
                if (srcField)
                    each(STATE_PROPERTIES, function(_, name) {
                        if (skipInitPropertySave)
                            field[name] = srcField[name];
                        else
                            setFieldProperty(field, name, srcField[name])
                    });
                else
                    resetFieldState(field, STATE_PROPERTIES);
                return field
            }
            function getFieldsState(fields) {
                var result = [];
                each(fields, function(_, field) {
                    result.push(setStateProperties({}, field, true))
                });
                return result
            }
            function setFieldsState(stateFields, fields) {
                stateFields = stateFields || [];
                each(fields, function(index, field) {
                    setStateProperties(field, stateFields[index])
                });
                return fields
            }
            function getFieldsByGroup(fields, grouppingField) {
                return $.map(fields, function(field) {
                        if (field.groupName === grouppingField.groupName && commonUtils.isNumber(field.groupIndex) && field.visible !== false)
                            return $.extend(field, {
                                    areaIndex: grouppingField.areaIndex,
                                    area: grouppingField.area,
                                    expanded: isDefined(field.expanded) ? field.expanded : grouppingField.expanded,
                                    dataField: field.dataField || grouppingField.dataField,
                                    dataType: field.dataType || grouppingField.dataType,
                                    sortBy: field.sortBy || grouppingField.sortBy,
                                    sortOrder: field.sortOrder || grouppingField.sortOrder,
                                    sortBySummaryField: field.sortBySummaryField || grouppingField.sortBySummaryField,
                                    sortBySummaryPath: field.sortBySummaryPath || grouppingField.sortBySummaryPath,
                                    visible: field.visible || grouppingField.visible,
                                    showTotals: isDefined(field.showTotals) ? field.showTotals : grouppingField.showTotals,
                                    showGrandTotals: isDefined(field.showGrandTotals) ? field.showGrandTotals : grouppingField.showGrandTotals
                                });
                        return null
                    }).sort(function(a, b) {
                        return a.groupIndex - b.groupIndex
                    })
            }
            function sortFieldsByAreaIndex(fields) {
                fields.sort(function(field1, field2) {
                    return field1.areaIndex - field2.areaIndex
                })
            }
            function isAreaField(field, area) {
                return field.area === area && !isDefined(field.groupIndex) && field.visible !== false
            }
            function createDescriptions(currentField) {
                var that = this,
                    fields = that.fields(),
                    descriptions = {
                        rows: [],
                        columns: [],
                        values: [],
                        filters: []
                    };
                each(["row", "column", "data", "filter"], function(_, areaName) {
                    var areaFields = [];
                    each(fields, function(index, field) {
                        if (isAreaField(field, areaName))
                            areaFields.push(field)
                    });
                    normalizeIndexes(areaFields, 'areaIndex', currentField)
                });
                each(fields || [], function(_, field) {
                    var descriptionName = DESCRIPTION_NAME_BY_AREA[field.area],
                        dimension = descriptions[descriptionName],
                        groupName = field.groupName;
                    if (groupName && !commonUtils.isNumber(field.groupIndex))
                        field.levels = getFieldsByGroup(fields, field);
                    if (!dimension || groupName && commonUtils.isNumber(field.groupIndex) || field.visible === false)
                        return;
                    if (field.levels && dimension !== descriptions.filters && dimension !== descriptions.values) {
                        dimension.push.apply(dimension, field.levels);
                        if (field.filterValues && field.filterValues.length)
                            descriptions.filters.push(field)
                    }
                    else
                        dimension.push(field)
                });
                each(descriptions, function(_, fields) {
                    sortFieldsByAreaIndex(fields)
                });
                return descriptions
            }
            function getFieldId(field) {
                return (field.dataField || field.groupName || '') + (field.groupInterval ? field.groupName || '' : "NOGROUP") + (field.groupInterval || '')
            }
            function mergeFields(fields, storeFields, retrieveFieldsOptionValue) {
                var result = [],
                    fieldsDictionary = {},
                    removedFields = {},
                    mergedGroups = [],
                    dataTypes = getFieldsDataType(fields);
                if (storeFields) {
                    each(storeFields, function(_, field) {
                        fieldsDictionary[getFieldId(field)] = field
                    });
                    each(fields, function(_, field) {
                        var fieldKey = getFieldId(field),
                            storeField = fieldsDictionary[fieldKey] || removedFields[fieldKey],
                            mergedField;
                        if (storeField)
                            mergedField = $.extend({}, storeField, field);
                        else
                            fieldsDictionary[fieldKey] = mergedField = field;
                        $.extend(mergedField, {dataType: dataTypes[field.dataField]});
                        delete fieldsDictionary[fieldKey];
                        removedFields[fieldKey] = storeField;
                        result.push(mergedField)
                    });
                    if (retrieveFieldsOptionValue)
                        each(fieldsDictionary, function(_, field) {
                            result.push(field)
                        })
                }
                else
                    result = fields;
                result.push.apply(result, mergedGroups);
                return result
            }
            function getFieldsDataType(fields) {
                var result = {};
                each(fields, function(_, field) {
                    result[field.dataField] = result[field.dataField] || field.dataType
                });
                return result
            }
            function getFields(that) {
                var result = $.Deferred(),
                    store = that._store,
                    storeFields = store && store.getFields(getFieldsDataType(that._fields)),
                    mergedFields;
                $.when(storeFields).done(function(storeFields) {
                    that._storeFields = storeFields;
                    mergedFields = mergeFields(that._fields, storeFields, that._retrieveFields);
                    result.resolve(mergedFields)
                }).fail(function() {
                    result.resolve(that._fields)
                });
                return result
            }
            function getSliceIndex(items, path) {
                var index = null,
                    pathValue = (path || []).join(".");
                if (pathValue.length)
                    foreachTree(items, function(items) {
                        var item = items[0],
                            itemPath = createPath(items).join("."),
                            textPath = $.map(items, function(item) {
                                return item.text
                            }).reverse().join(".");
                        if (pathValue === itemPath || item.key && textPath === pathValue) {
                            index = items[0].index;
                            return false
                        }
                    });
                return index
            }
            function getFieldSummaryValueSelector(field, dataSource, loadOptions, dimensionName) {
                var values = dataSource.values,
                    sortBySummaryFieldIndex = findField(loadOptions.values, field.sortBySummaryField),
                    areRows = dimensionName === "rows",
                    sortByDimension = areRows ? dataSource.columns : dataSource.rows,
                    grandTotalIndex = areRows ? dataSource.grandTotalRowIndex : dataSource.grandTotalColumnIndex,
                    sortBySummaryPath = field.sortBySummaryPath || [],
                    sliceIndex = sortBySummaryPath.length ? getSliceIndex(sortByDimension, sortBySummaryPath) : grandTotalIndex;
                if (values && values.length && sortBySummaryFieldIndex >= 0 && isDefined(sliceIndex))
                    return function(field) {
                            var rowIndex = areRows ? field.index : sliceIndex,
                                columnIndex = areRows ? sliceIndex : field.index;
                            return ((values[rowIndex] || [[]])[columnIndex] || [])[sortBySummaryFieldIndex] || null
                        }
            }
            function getSortingMethod(field, dataSource, loadOptions, dimensionName, getAscOrder) {
                var sortOrder = getAscOrder ? "asc" : field.sortOrder,
                    sortBy = getAscOrder ? "value" : field.sortBy === "displayText" ? "text" : "value",
                    defaultCompare = field.sortingMethod || getCompareFunction(function(item) {
                        return item[sortBy]
                    }),
                    summaryValueSelector = !getAscOrder && getFieldSummaryValueSelector(field, dataSource, loadOptions, dimensionName),
                    summaryCompare = summaryValueSelector && getCompareFunction(summaryValueSelector),
                    sortingMethod = function(a, b) {
                        var result = summaryCompare && summaryCompare(a, b) || 0;
                        if (result === 0)
                            result = defaultCompare(a, b);
                        return sortOrder === "desc" ? -result : result
                    };
                return sortingMethod
            }
            function sortDimension(dataSource, loadOptions, dimensionName, getAscOrder) {
                var fields = loadOptions[dimensionName] || [],
                    baseIndex = loadOptions.headerName === dimensionName ? loadOptions.path.length : 0,
                    sortingMetodByLevel = [];
                foreachDataLevel(dataSource[dimensionName], function(item, index) {
                    var field = fields[index] || {},
                        sortingMethod = sortingMetodByLevel[index] = sortingMetodByLevel[index] || getSortingMethod(field, dataSource, loadOptions, dimensionName, getAscOrder);
                    item.sort(sortingMethod)
                }, baseIndex)
            }
            function sort(loadOptions, dataSource, getAscOrder) {
                sortDimension(dataSource, loadOptions, "rows", getAscOrder);
                sortDimension(dataSource, loadOptions, "columns", getAscOrder)
            }
            function formatHeaderItems(data, loadOptions, headerName) {
                foreachTree(data[headerName], function(items) {
                    var item = items[0];
                    item.text = item.text || formatValue(item.value, loadOptions[headerName][createPath(items).length - 1])
                })
            }
            function formatHeaders(loadOptions, data) {
                formatHeaderItems(data, loadOptions, "columns");
                formatHeaderItems(data, loadOptions, "rows")
            }
            function updateCache(headerItems) {
                var cacheByPath = {};
                foreachTree(headerItems, function(items) {
                    var path = createPath(items).join(".");
                    cacheByPath[path] = items[0]
                });
                headerItems._cacheByPath = cacheByPath
            }
            pivotGrid._sort = sort;
            return {
                    ctor: function(options) {
                        options = options || {};
                        var that = this,
                            store = createStore(options);
                        that._store = store;
                        that._loadedData = {
                            rows: [],
                            columns: [],
                            values: []
                        };
                        that._data = $.extend(true, {}, that._loadedData);
                        that._loadingCount = 0;
                        each(["changed", "loadError", "loadingChanged", "fieldsPrepared", "expandValueChanging"], $.proxy(function(_, eventName) {
                            var optionName = "on" + eventName[0].toUpperCase() + eventName.slice(1);
                            if (options.hasOwnProperty(optionName))
                                this.on(eventName, options[optionName])
                        }, this));
                        that._retrieveFields = isDefined(options.retrieveFields) ? options.retrieveFields : true;
                        that._fields = options.fields || [];
                        that._descriptions = options.descriptions ? $.extend(that._createDescriptions(), options.descriptions) : undefined;
                        if (!store) {
                            $.extend(true, that._loadedData, options.store || options);
                            that._data = $.extend(true, {}, that._loadedData)
                        }
                    },
                    getData: function() {
                        return this._data
                    },
                    getAreaFields: function(area, collectGroups) {
                        var areaFields = [],
                            descriptions;
                        if (collectGroups || area === "data") {
                            each(this._fields, function() {
                                if (isAreaField(this, area))
                                    areaFields.push(this)
                            });
                            sortFieldsByAreaIndex(areaFields)
                        }
                        else {
                            descriptions = this._descriptions || {};
                            areaFields = descriptions[DESCRIPTION_NAME_BY_AREA[area]] || []
                        }
                        return areaFields
                    },
                    fields: function(fields) {
                        var that = this;
                        if (fields) {
                            that._fields = mergeFields(fields, that._storeFields, that._retrieveFields);
                            that._fieldsPrepared(that._fields)
                        }
                        return that._fields
                    },
                    field: function(id, options) {
                        var that = this,
                            fields = that._fields,
                            field = fields && fields[commonUtils.isNumber(id) ? id : findField(fields, id)],
                            levels;
                        if (field && options) {
                            each(options, function(optionName, optionValue) {
                                var isInitialization = $.inArray(optionName, STATE_PROPERTIES) < 0;
                                setFieldProperty(field, optionName, optionValue, isInitialization);
                                if (optionName === "sortOrder") {
                                    levels = field.levels || [];
                                    for (var i = 0; i < levels.length; i++)
                                        levels[i][optionName] = optionValue
                                }
                            });
                            updateCalculatedFieldProperties(field, CALCULATED_PROPERTIES);
                            that._descriptions = that._createDescriptions(field)
                        }
                        return field
                    },
                    getFieldValues: function(index) {
                        var that = this,
                            field = this._fields && this._fields[index],
                            store = this.store(),
                            loadFields = [],
                            loadOptions = {
                                columns: loadFields,
                                rows: [],
                                values: this.getAreaFields("data"),
                                filters: []
                            },
                            d = $.Deferred();
                        if (field && store) {
                            each(field.levels || [field], function() {
                                loadFields.push($.extend({}, this, {
                                    expanded: true,
                                    filterValues: null,
                                    sortOrder: 'asc',
                                    sortBySummaryField: null
                                }))
                            });
                            store.load(loadOptions).done(function(data) {
                                formatHeaders(loadOptions, data);
                                that._sort(loadOptions, data);
                                d.resolve(data.columns)
                            }).fail(d)
                        }
                        else
                            d.reject();
                        return d
                    },
                    reload: function() {
                        return this.load({reload: true})
                    },
                    filter: function() {
                        var store = this._store;
                        return store.filter.apply(store, arguments)
                    },
                    load: function(options) {
                        var that = this,
                            d = $.Deferred();
                        options = options || {};
                        that._changeLoadingCount(1);
                        d.fail(function(e) {
                            that.fireEvent("loadError", [e])
                        }).always(function() {
                            that._changeLoadingCount(-1)
                        });
                        function loadTask() {
                            that._delayedLoadTask = undefined;
                            if (!that._descriptions)
                                $.when(getFields(that)).done(function(fields) {
                                    that._fieldsPrepared(fields);
                                    that._loadCore(options, d)
                                }).fail(d.reject).fail(that._loadErrorHandler);
                            else
                                that._loadCore(options, d)
                        }
                        if (that.store())
                            that._delayedLoadTask = commonUtils.executeAsync(loadTask);
                        else
                            loadTask();
                        return d
                    },
                    createDrillDownDataSource: function(params) {
                        function createCustomStoreMethod(methodName) {
                            return function(options) {
                                    var d;
                                    if (arrayStore)
                                        d = arrayStore[methodName](options);
                                    else {
                                        d = $.Deferred();
                                        $.when(items).done(function(data) {
                                            arrayStore = new DevExpress.data.ArrayStore(data);
                                            arrayStore[methodName](options).done(d.resolve).fail(d.reject)
                                        }).fail(d.reject)
                                    }
                                    return d
                                }
                        }
                        var items = this._store.getDrillDownItems(this._descriptions, params),
                            arrayStore,
                            dataSource = new DevExpress.data.DataSource({
                                load: createCustomStoreMethod("load"),
                                totalCount: createCustomStoreMethod("totalCount"),
                                key: this._store.key()
                            });
                        return dataSource
                    },
                    _createDescriptions: createDescriptions,
                    _fieldsPrepared: function(fields) {
                        var that = this;
                        that._fields = fields;
                        each(fields, function(index, field) {
                            field.index = index;
                            updateCalculatedFieldProperties(field, CALCULATED_PROPERTIES.concat(["allowSorting", "allowSortingBySummary", "allowFiltering", "allowExpandAll"]))
                        });
                        that.fireEvent("fieldsPrepared", [fields]);
                        that._descriptions = that._createDescriptions()
                    },
                    isLoading: function() {
                        return this._loadingCount > 0
                    },
                    state: function(state) {
                        var that = this;
                        if (arguments.length) {
                            state = $.extend({
                                rowExpandedPaths: [],
                                columnExpandedPaths: []
                            }, state);
                            if (!that._descriptions) {
                                that._changeLoadingCount(1);
                                $.when(getFields(that)).done(function(fields) {
                                    that._fields = setFieldsState(state.fields, fields);
                                    that._fieldsPrepared(fields);
                                    that.load(state)
                                }).always(function() {
                                    that._changeLoadingCount(-1)
                                })
                            }
                            else {
                                that._fields = setFieldsState(state.fields, that._fields);
                                that._descriptions = that._createDescriptions();
                                that.load(state)
                            }
                        }
                        else
                            return {
                                    fields: getFieldsState(that._fields),
                                    columnExpandedPaths: getExpandedPaths(that._loadedData, that._descriptions, "columns"),
                                    rowExpandedPaths: getExpandedPaths(that._loadedData, that._descriptions, "rows")
                                }
                    },
                    _changeLoadingCount: function(increment) {
                        var oldLoading = this.isLoading(),
                            newLoading;
                        this._loadingCount += increment;
                        newLoading = this.isLoading();
                        if (oldLoading ^ newLoading)
                            this.fireEvent("loadingChanged", [newLoading])
                    },
                    _loadCore: function(options, deferred) {
                        var that = this,
                            store = this._store,
                            descriptions = this._descriptions,
                            headerName = DESCRIPTION_NAME_BY_AREA[options.area];
                        options = options || {};
                        if (store) {
                            $.extend(options, descriptions);
                            options.columnExpandedPaths = options.columnExpandedPaths || getExpandedPaths(this._loadedData, options, "columns");
                            options.rowExpandedPaths = options.rowExpandedPaths || getExpandedPaths(this._loadedData, options, "rows");
                            if (headerName)
                                options.headerName = headerName;
                            $.when(store.load(options)).done(function(data) {
                                if (options.path)
                                    that.applyPartialDataSource(options.area, options.path, data, deferred);
                                else {
                                    $.extend(that._loadedData, data);
                                    that._update(deferred)
                                }
                                deferred.resolve(that._data)
                            }).fail(deferred.reject)
                        }
                        else {
                            that._update(deferred);
                            deferred.resolve(that._data)
                        }
                    },
                    _sort: function(descriptions, data, getAscOrder) {
                        var store = this._store;
                        if (store)
                            sort(descriptions, data, getAscOrder)
                    },
                    _update: function(deferred) {
                        var that = this,
                            descriptions = that._descriptions,
                            loadedData = that._loadedData,
                            expressionsUsed = areExpressionsUsed(descriptions);
                        formatHeaders(descriptions, loadedData);
                        updateCache(loadedData.rows);
                        updateCache(loadedData.columns);
                        if (expressionsUsed) {
                            that._sort(descriptions, loadedData, expressionsUsed);
                            pivotGrid.applyDisplaySummaryMode(descriptions, loadedData)
                        }
                        that._sort(descriptions, loadedData);
                        that._data = loadedData;
                        $.when(deferred).done(function() {
                            that.fireEvent("changed");
                            if (isDefined(that._data.grandTotalRowIndex))
                                loadedData.grandTotalRowIndex = that._data.grandTotalRowIndex;
                            if (isDefined(that._data.grandTotalColumnIndex))
                                loadedData.grandTotalColumnIndex = that._data.grandTotalColumnIndex
                        })
                    },
                    store: function() {
                        return this._store
                    },
                    collapseHeaderItem: function(area, path) {
                        var that = this,
                            headerItems = area === 'column' ? that._loadedData.columns : that._loadedData.rows,
                            headerItem = findHeaderItem(headerItems, path),
                            field = that.getAreaFields(area)[path.length - 1];
                        if (headerItem && headerItem.children) {
                            that.fireEvent("expandValueChanging", [{
                                    area: area,
                                    path: path,
                                    expanded: false
                                }]);
                            if (field)
                                field.expanded = false;
                            headerItem.collapsedChildren = headerItem.children;
                            delete headerItem.children;
                            that._update();
                            return true
                        }
                        return false
                    },
                    collapseAll: function(id) {
                        var dataChanged = false,
                            field = this.field(id) || {},
                            areaOffset = $.inArray(field, this.getAreaFields(field.area));
                        field.expanded = false;
                        foreachTree(this._loadedData[field.area + "s"], function(items) {
                            var item = items[0],
                                path = createPath(items);
                            if (item && item.children && areaOffset === path.length - 1) {
                                item.collapsedChildren = item.children;
                                delete item.children;
                                dataChanged = true
                            }
                        }, true);
                        dataChanged && this._update()
                    },
                    expandAll: function(id) {
                        var field = this.field(id);
                        if (field && field.area) {
                            field.expanded = true;
                            this.load()
                        }
                    },
                    expandHeaderItem: function(area, path) {
                        var that = this,
                            hasCache,
                            headerItems = area === 'column' ? that._loadedData.columns : that._loadedData.rows,
                            headerItem = findHeaderItem(headerItems, path),
                            options;
                        if (headerItem && !headerItem.children) {
                            hasCache = !!headerItem.collapsedChildren;
                            options = {
                                area: area,
                                path: path,
                                expanded: true,
                                needExpandData: !hasCache
                            };
                            that.fireEvent("expandValueChanging", [options]);
                            if (hasCache) {
                                headerItem.children = headerItem.collapsedChildren;
                                delete headerItem.collapsedChildren;
                                that._update()
                            }
                            else
                                that.load(options);
                            return hasCache
                        }
                        return false
                    },
                    applyPartialDataSource: function(area, path, dataSource, deferred) {
                        var that = this,
                            loadedData = that._loadedData,
                            headerItems = area === 'column' ? loadedData.columns : loadedData.rows,
                            headerItem,
                            newRowItemIndexesToCurrent,
                            newColumnItemIndexesToCurrent;
                        if (dataSource && dataSource.values) {
                            dataSource.rows = dataSource.rows || [];
                            dataSource.columns = dataSource.columns || [];
                            headerItem = findHeaderItem(headerItems, path);
                            if (headerItem) {
                                if (area === 'column') {
                                    newColumnItemIndexesToCurrent = updateHeaderItemChildren(headerItems, headerItem, dataSource.columns, loadedData.grandTotalColumnIndex);
                                    newRowItemIndexesToCurrent = updateHeaderItems(loadedData.rows, dataSource.rows)
                                }
                                else {
                                    newRowItemIndexesToCurrent = updateHeaderItemChildren(headerItems, headerItem, dataSource.rows, loadedData.grandTotalRowIndex);
                                    newColumnItemIndexesToCurrent = updateHeaderItems(loadedData.columns, dataSource.columns)
                                }
                                updateDataSourceCells(loadedData, dataSource.values, newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent);
                                that._update(deferred)
                            }
                        }
                    },
                    dispose: function() {
                        var that = this,
                            delayedLoadTask = that._delayedLoadTask;
                        this._disposeEvents();
                        if (delayedLoadTask)
                            delayedLoadTask.abort();
                        this._isDisposed = true
                    },
                    isDisposed: function() {
                        return !!this._isDisposed
                    }
                }
        }()).include(EventsMixin);
        pivotGrid.foreachTree = foreachTree;
        pivotGrid.createPath = createPath;
        pivotGrid.foreachDataLevel = foreachDataLevel;
        pivotGrid.getCompareFunction = getCompareFunction;
        pivotGrid.findField = findField;
        pivotGrid.formatValue = formatValue;
        pivotGrid.setFieldProperty = setFieldProperty
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.dataController.js */
    (function($, DX) {
        var pivotGrid = DX.ui.dxPivotGrid,
            stringUtils = DX.require("/utils/utils.string"),
            commonUtils = DX.require("/utils/utils.common"),
            Class = DevExpress.require("/class"),
            createPath = pivotGrid.createPath,
            foreachTree = pivotGrid.foreachTree,
            formatValue = pivotGrid.formatValue,
            math = Math,
            dxDataGrid = DX.ui.dxDataGrid,
            GRAND_TOTAL_TYPE = "GT",
            TOTAL_TYPE = "T",
            DATA_TYPE = "D";
        pivotGrid.proxyMethod = function(instance, methodName, defaultResult) {
            if (!instance[methodName])
                instance[methodName] = function() {
                    var dataSource = this._dataSource;
                    return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult
                }
        };
        pivotGrid.DataController = Class.inherit(function() {
            function getHeaderItemText(item, description, options) {
                var text = item.text;
                if (commonUtils.isDefined(item.displayText))
                    text = item.displayText;
                else if (commonUtils.isDefined(item.caption))
                    text = item.caption;
                else if (item.type === GRAND_TOTAL_TYPE)
                    text = options.texts.grandTotal;
                if (item.isAdditionalTotal)
                    text = stringUtils.format(options.texts.total || '', text);
                return text
            }
            var createHeaderInfo = function() {
                    var getHeaderItemsDepth = function(headerItems) {
                            var depth = 0;
                            foreachTree(headerItems, function(items) {
                                depth = math.max(depth, items.length)
                            });
                            return depth
                        };
                    var createInfoItem = function(headerItem, breadth, isHorizontal) {
                            var infoItem = {
                                    type: headerItem.type,
                                    text: headerItem.text
                                };
                            if (headerItem.path)
                                infoItem.path = headerItem.path;
                            if (headerItem.width)
                                infoItem.width = headerItem.width;
                            if (headerItem.isLast)
                                infoItem.isLast = true;
                            if (headerItem.sorted)
                                infoItem.sorted = true;
                            if (headerItem.isMetric)
                                infoItem.dataIndex = headerItem.dataIndex;
                            if (commonUtils.isDefined(headerItem.expanded))
                                infoItem.expanded = headerItem.expanded;
                            if (breadth > 1)
                                infoItem[isHorizontal ? 'colspan' : 'rowspan'] = breadth;
                            if (headerItem.depthSize && headerItem.depthSize > 1)
                                infoItem[isHorizontal ? 'rowspan' : 'colspan'] = headerItem.depthSize;
                            if (headerItem.index >= 0)
                                infoItem.dataSourceIndex = headerItem.index;
                            return infoItem
                        };
                    var addInfoItem = function(info, options) {
                            var itemInfo,
                                breadth = options.lastIndex - options.index || 1,
                                addInfoItemCore = function(info, infoItem, itemIndex, depthIndex, isHorizontal) {
                                    var index = isHorizontal ? depthIndex : itemIndex;
                                    while (!info[index])
                                        info.push([]);
                                    if (isHorizontal)
                                        info[index].push(infoItem);
                                    else
                                        info[index].unshift(infoItem)
                                };
                            itemInfo = createInfoItem(options.headerItem, breadth, options.isHorizontal);
                            addInfoItemCore(info, itemInfo, options.index, options.depth, options.isHorizontal);
                            if (!options.headerItem.children || options.headerItem.children.length === 0)
                                return options.lastIndex + 1;
                            return options.lastIndex
                        };
                    var isItemSorted = function(items, sortBySummaryPath) {
                            var path,
                                item = items[0],
                                stringValuesUsed = commonUtils.isString(sortBySummaryPath[0]),
                                headerItem = item.dataIndex >= 0 ? items[1] : item;
                            if (stringValuesUsed && sortBySummaryPath[0].indexOf("&[") !== -1 && headerItem.key || !headerItem.key)
                                path = createPath(items);
                            else
                                path = $.map(items, function(item) {
                                    return item.dataIndex >= 0 ? item.value : item.text
                                }).reverse();
                            if (item.type === GRAND_TOTAL_TYPE)
                                path = path.slice(1);
                            return path.join("/") === sortBySummaryPath.join("/")
                        };
                    var getViewHeaderItems = function(headerItems, headerDescriptions, cellDescriptions, depthSize, options) {
                            var cellDescriptionsCount = cellDescriptions.length,
                                viewHeaderItems = options.showData ? createViewHeaderItems(headerItems, headerDescriptions) : [];
                            if (options.showGrandTotals || headerDescriptions.length === 0)
                                viewHeaderItems[!options.showTotalsPrior ? "push" : "unshift"]({
                                    type: GRAND_TOTAL_TYPE,
                                    isEmpty: options.isEmptyGrandTotal
                                });
                            if (options.showTotals !== false)
                                addAdditionalTotalHeaderItems(viewHeaderItems, headerDescriptions, options.showTotalsPrior);
                            foreachTree(viewHeaderItems, function(items) {
                                var item = items[0];
                                if (!item.children || item.children.length === 0)
                                    item.depthSize = depthSize - items.length + 1
                            });
                            if (cellDescriptionsCount > 1)
                                addMetricHeaderItems(viewHeaderItems, cellDescriptions, options.hiddenGrandTotals, options.hiddenTotals);
                            !options.showEmpty && removeHiddenItems(viewHeaderItems);
                            var columnIndex = 0;
                            foreachTree(viewHeaderItems, function(items) {
                                var item = items[0],
                                    field = headerDescriptions[items.length - 1] || {};
                                if (item.type === DATA_TYPE && !item.isMetric)
                                    item.width = field.width;
                                item.isLast = !item.children || !item.children.length;
                                if (item.isLast) {
                                    $.each(options.sortBySummaryPaths, function(index, sortBySummaryPath) {
                                        if (!commonUtils.isDefined(item.dataIndex)) {
                                            sortBySummaryPath = sortBySummaryPath.slice(0);
                                            sortBySummaryPath.pop()
                                        }
                                        if (isItemSorted(items, sortBySummaryPath)) {
                                            item.sorted = true;
                                            return false
                                        }
                                    });
                                    columnIndex++
                                }
                                item.text = getHeaderItemText(item, field, options)
                            });
                            if (!viewHeaderItems.length)
                                viewHeaderItems.push({});
                            return viewHeaderItems
                        };
                    function createHeaderItem(childrenStack, depth, index) {
                        var parent = childrenStack[depth] = childrenStack[depth] || [],
                            node = parent[index] = {};
                        if (childrenStack[depth + 1]) {
                            node.children = childrenStack[depth + 1];
                            childrenStack.length = depth + 1
                        }
                        return node
                    }
                    function createViewHeaderItems(headerItems, headerDescriptions) {
                        var headerDescriptionsCount = headerDescriptions && headerDescriptions.length || 0,
                            childrenStack = [],
                            headerItem;
                        foreachTree(headerItems, function(items, index) {
                            var item = items[0],
                                path = createPath(items);
                            headerItem = createHeaderItem(childrenStack, path.length, index);
                            headerItem.type = DATA_TYPE;
                            headerItem.value = item.value;
                            headerItem.path = path;
                            headerItem.text = item.text;
                            headerItem.index = item.index;
                            headerItem.displayText = item.displayText;
                            headerItem.key = item.key;
                            headerItem.isEmpty = item.isEmpty;
                            if (path.length < headerDescriptionsCount && (!item.children || item.children.length !== 0))
                                headerItem.expanded = !!item.children
                        });
                        return createHeaderItem(childrenStack, 0, 0).children || []
                    }
                    var addMetricHeaderItems = function(headerItems, cellDescriptions, hiddenGrandTotals, hiddenTotals) {
                            foreachTree(headerItems, function(items) {
                                var item = items[0],
                                    i;
                                if (!item.children || item.children.length === 0) {
                                    item.children = [];
                                    for (i = 0; i < cellDescriptions.length; i++) {
                                        if (cellDescriptions.length)
                                            if (item.type === GRAND_TOTAL_TYPE && $.inArray(i, hiddenGrandTotals) !== -1 || item.type !== GRAND_TOTAL_TYPE && $.inArray(i, hiddenTotals) !== -1)
                                                continue;
                                        item.children.push({
                                            caption: cellDescriptions[i].caption,
                                            path: item.path,
                                            type: item.type,
                                            value: i,
                                            index: item.index,
                                            dataIndex: i,
                                            isMetric: true,
                                            isEmpty: item.isEmpty && item.isEmpty[i]
                                        })
                                    }
                                }
                            })
                        };
                    var addAdditionalTotalHeaderItems = function(headerItems, headerDescriptions, showTotalsPrior) {
                            foreachTree(headerItems, function(items, index) {
                                var item = items[0],
                                    parentChildren = (items[1] ? items[1].children : headerItems) || [],
                                    dataField = headerDescriptions[items.length - 1];
                                if (item.type === DATA_TYPE && item.expanded && dataField.showTotals !== false) {
                                    index !== -1 && parentChildren.splice(showTotalsPrior ? index : index + 1, 0, $.extend({}, item, {
                                        children: null,
                                        type: TOTAL_TYPE,
                                        expanded: showTotalsPrior ? true : null,
                                        isAdditionalTotal: true
                                    }));
                                    if (showTotalsPrior)
                                        item.expanded = null
                                }
                            })
                        };
                    var removeEmptyParent = function(items, index) {
                            var parent = items[index + 1];
                            if (!items[index].children.length && parent && parent.children) {
                                parent.children.splice($.inArray(items[index], parent.children), 1);
                                removeEmptyParent(items, index + 1)
                            }
                        };
                    var removeHiddenItems = function(headerItems) {
                            foreachTree([{children: headerItems}], function(items, index) {
                                var item = items[0],
                                    parentChildren = (items[1] ? items[1].children : headerItems) || [];
                                if (item && !item.children && (item.isEmpty && item.isEmpty.length ? item.isEmpty[0] : item.isEmpty)) {
                                    parentChildren.splice(index, 1);
                                    removeEmptyParent(items, 1)
                                }
                            })
                        };
                    var fillHeaderInfo = function(info, viewHeaderItems, depthSize, isHorizontal) {
                            var lastIndex = 0,
                                index,
                                depth,
                                indexesByDepth = [0];
                            foreachTree(viewHeaderItems, function(items) {
                                var headerItem = items[0];
                                depth = headerItem.isMetric ? depthSize : items.length - 1;
                                while (indexesByDepth.length - 1 < depth)
                                    indexesByDepth.push(indexesByDepth[indexesByDepth.length - 1]);
                                index = indexesByDepth[depth] || 0;
                                lastIndex = addInfoItem(info, {
                                    headerItem: headerItem,
                                    index: index,
                                    lastIndex: lastIndex,
                                    depth: depth,
                                    isHorizontal: isHorizontal
                                });
                                indexesByDepth.length = depth;
                                indexesByDepth.push(lastIndex)
                            })
                        };
                    return function(headerItems, headerDescriptions, cellDescriptions, isHorizontal, options) {
                            var info = [],
                                viewHeaderItems,
                                depthSize = getHeaderItemsDepth(headerItems) || 1;
                            viewHeaderItems = getViewHeaderItems(headerItems, headerDescriptions, cellDescriptions, depthSize, options);
                            fillHeaderInfo(info, viewHeaderItems, depthSize, isHorizontal);
                            return info
                        }
                }();
            function createSortPaths(headerFields, dataFields) {
                var sortBySummaryPaths = [];
                $.each(headerFields, function(index, headerField) {
                    var fieldIndex = pivotGrid.findField(dataFields, headerField.sortBySummaryField);
                    if (fieldIndex >= 0)
                        sortBySummaryPaths.push((headerField.sortBySummaryPath || []).concat([fieldIndex]))
                });
                return sortBySummaryPaths
            }
            function foreachRowInfo(rowsInfo, callback) {
                var columnOffset = 0,
                    columnOffsetResetIndexes = [];
                for (var i = 0; i < rowsInfo.length; i++)
                    for (var j = 0; j < rowsInfo[i].length; j++) {
                        var rowSpanOffset = (rowsInfo[i][j].rowspan || 1) - 1,
                            visibleIndex = i + rowSpanOffset;
                        if (columnOffsetResetIndexes[i]) {
                            columnOffset -= columnOffsetResetIndexes[i];
                            columnOffsetResetIndexes[i] = 0
                        }
                        if (callback(rowsInfo[i][j], visibleIndex, i, j, columnOffset) === false)
                            break;
                        columnOffsetResetIndexes[i + (rowsInfo[i][j].rowspan || 1)] = (columnOffsetResetIndexes[i + (rowsInfo[i][j].rowspan || 1)] || 0) + 1;
                        columnOffset++
                    }
            }
            function foreachColumnInfo(info, callback, rowIndex, offsets, columnCount, lastProcessedIndexes) {
                rowIndex = rowIndex || 0;
                offsets = offsets || [];
                lastProcessedIndexes = lastProcessedIndexes || [];
                offsets[rowIndex] = offsets[rowIndex] || 0;
                var row = info[rowIndex],
                    startIndex = lastProcessedIndexes[rowIndex] + 1 || 0,
                    processedColumnCount = 0;
                if (!row)
                    return;
                for (var colIndex = startIndex; colIndex < row.length; colIndex++) {
                    var cell = row[colIndex],
                        visibleIndex = colIndex + offsets[rowIndex],
                        colspan = cell.colspan || 1;
                    foreachColumnInfo(info, callback, rowIndex + (cell.rowspan || 1), offsets, colspan, lastProcessedIndexes);
                    offsets[rowIndex] += colspan - 1;
                    processedColumnCount += colspan;
                    if (cell.rowspan)
                        for (var i = rowIndex + 1; i < rowIndex + cell.rowspan; i++) {
                            offsets[i] = offsets[i] || 0;
                            offsets[i] += cell.colspan || 1
                        }
                    if (callback(cell, visibleIndex, rowIndex, colIndex) === false)
                        break;
                    if (columnCount !== undefined && processedColumnCount >= columnCount)
                        break
                }
                lastProcessedIndexes[rowIndex] = colIndex
            }
            function createCellsInfo(rowsInfo, columnsInfo, data, dataFields) {
                var info = [],
                    dataSourceCells = data.values;
                dataSourceCells.length && foreachRowInfo(rowsInfo, function(rowInfo, rowIndex) {
                    var row = info[rowIndex] = [],
                        dataRow = dataSourceCells[rowInfo.dataSourceIndex >= 0 ? rowInfo.dataSourceIndex : data.grandTotalRowIndex] || [];
                    rowInfo.isLast && foreachColumnInfo(columnsInfo, function(columnInfo, columnIndex) {
                        var dataIndex = columnInfo.dataIndex || 0,
                            dataField = dataFields[dataIndex];
                        if (columnInfo.isLast && dataField) {
                            var cell = dataRow[columnInfo.dataSourceIndex >= 0 ? columnInfo.dataSourceIndex : data.grandTotalColumnIndex],
                                cellValue;
                            if (!$.isArray(cell))
                                cell = [cell];
                            cellValue = cell[dataIndex];
                            row[columnIndex] = {
                                text: formatValue(cellValue, dataField),
                                value: cellValue,
                                format: dataField.format,
                                precision: dataField.precision,
                                dataType: dataField.dataType,
                                columnType: columnInfo.type,
                                rowType: rowInfo.type,
                                rowPath: rowInfo.path || [],
                                columnPath: columnInfo.path || [],
                                dataIndex: dataIndex
                            };
                            if (dataField.width)
                                row[columnIndex].width = dataField.width
                        }
                    })
                });
                return info
            }
            function getHeaderIndexedItems(headerItems, maxDepth, options) {
                var visibleIndex = 0,
                    indexedItems = [];
                foreachTree(headerItems, function(items) {
                    var headerItem = items[0],
                        path = createPath(items);
                    if (headerItem.children && options.showTotals === false)
                        return;
                    var indexedItem = $.extend(true, {}, headerItem, {
                            visibleIndex: visibleIndex++,
                            path: path
                        });
                    if (commonUtils.isDefined(indexedItem.index))
                        indexedItems[indexedItem.index] = indexedItem;
                    else
                        indexedItems.push(indexedItem)
                });
                return indexedItems
            }
            function createScollController(dataController, component, dataAdapter) {
                if (component && component.option("scrolling.mode") === "virtual")
                    return new dxDataGrid.VirtualScrollController(component, $.extend({
                            hasKnownLastPage: function() {
                                return true
                            },
                            pageCount: function() {
                                return math.ceil(this.totalItemsCount() / this.pageSize())
                            },
                            updateLoading: function(){},
                            itemsCount: function() {
                                if (this.pageIndex() < this.pageCount() - 1)
                                    return this.pageSize();
                                else
                                    this.totalItemsCount() % this.pageSize()
                            },
                            items: function() {
                                return []
                            },
                            viewportItems: function(items) {
                                return []
                            },
                            onChanged: function(e){},
                            isLoading: function() {
                                return dataController.isLoading()
                            },
                            changingDuration: function() {
                                return dataController._changingDuration || 0
                            }
                        }, dataAdapter))
            }
            function getHiddenTotals(dataFields) {
                var result = [];
                $.each(dataFields, function(index, field) {
                    if (field.showTotals === false)
                        result.push(index)
                });
                return result
            }
            function getHiddenGrandTotalsTotals(dataFields, columnFields) {
                var result = [];
                $.each(dataFields, function(index, field) {
                    if (field.showGrandTotals === false)
                        result.push(index)
                });
                if (columnFields.length === 0 && result.length === dataFields.length)
                    result = [];
                return result
            }
            var members = {
                    ctor: function(options) {
                        var that = this,
                            virtualScrollControllerChanged = $.proxy(that._fireChanged, that);
                        options = that._options = options || {};
                        that._dataSource = that._createDataSource(options);
                        that._rowsScrollController = createScollController(that, options.component, {
                            totalItemsCount: function() {
                                return that.totalRowCount()
                            },
                            pageIndex: function(index) {
                                return that.rowPageIndex(index)
                            },
                            pageSize: function() {
                                return that.rowPageSize()
                            },
                            load: function() {
                                if (that._rowsScrollController.pageIndex() >= this.pageCount())
                                    that._rowsScrollController.pageIndex(this.pageCount() - 1);
                                return that._rowsScrollController.handleDataChanged(virtualScrollControllerChanged)
                            }
                        });
                        that._columnsScrollController = createScollController(that, options.component, {
                            totalItemsCount: function() {
                                return that.totalColumnCount()
                            },
                            pageIndex: function(index) {
                                return that.columnPageIndex(index)
                            },
                            pageSize: function() {
                                return that.columnPageSize()
                            },
                            load: function() {
                                if (that._columnsScrollController.pageIndex() >= this.pageCount())
                                    that._columnsScrollController.pageIndex(this.pageCount() - 1);
                                return that._columnsScrollController.handleDataChanged(virtualScrollControllerChanged)
                            }
                        });
                        that._stateStoringController = new dxDataGrid.StateStoringController(options.component).init();
                        that._columnsInfo = [];
                        that._rowsInfo = [];
                        that._cellsInfo = [];
                        that.expandValueChanging = $.Callbacks();
                        that.loadingChanged = $.Callbacks();
                        that.scrollChanged = $.Callbacks();
                        that.load();
                        that._update();
                        that.changed = $.Callbacks()
                    },
                    _fireChanged: function() {
                        var that = this,
                            startChanging = new Date;
                        that.changed && !that._lockChanged && that.changed.fire();
                        that._changingDuration = new Date - startChanging
                    },
                    load: function() {
                        var that = this,
                            stateStoringController = this._stateStoringController;
                        if (stateStoringController.isEnabled() && !stateStoringController.isLoaded())
                            stateStoringController.load().always(function(state) {
                                if (state)
                                    that._dataSource.state(state);
                                else
                                    that._dataSource.load()
                            });
                        else
                            that._dataSource.load()
                    },
                    calculateVirtualContentParams: function(contentParams) {
                        var that = this,
                            rowsScrollController = that._rowsScrollController,
                            columnsScrollController = that._columnsScrollController,
                            rowViewportItemSize = contentParams.contentHeight / contentParams.rowCount,
                            columnViewportItemSize = contentParams.contentWidth / contentParams.columnCount,
                            oldColumnViewportItemSize,
                            oldRowViewportItemSize,
                            newLeftPosition,
                            newTopPosition;
                        if (rowsScrollController && columnsScrollController) {
                            oldColumnViewportItemSize = columnsScrollController.viewportItemSize();
                            oldRowViewportItemSize = rowsScrollController.viewportItemSize();
                            rowsScrollController.viewportItemSize(rowViewportItemSize);
                            columnsScrollController.viewportItemSize(columnViewportItemSize);
                            rowsScrollController.viewportSize(contentParams.viewportHeight / rowsScrollController.viewportItemSize());
                            rowsScrollController.setContentSize(contentParams.contentHeight);
                            columnsScrollController.viewportSize(contentParams.viewportWidth / columnsScrollController.viewportItemSize());
                            columnsScrollController.setContentSize(contentParams.contentWidth);
                            columnsScrollController.loadIfNeed();
                            rowsScrollController.loadIfNeed();
                            newLeftPosition = columnsScrollController.getViewportPosition() * columnViewportItemSize / oldColumnViewportItemSize;
                            newTopPosition = rowsScrollController.getViewportPosition() * rowViewportItemSize / oldRowViewportItemSize;
                            that.setViewportPosition(newLeftPosition, newTopPosition);
                            that.scrollChanged.fire({
                                left: newLeftPosition,
                                top: newTopPosition
                            });
                            return {
                                    contentTop: rowsScrollController.getContentOffset(),
                                    contentLeft: columnsScrollController.getContentOffset(),
                                    width: columnsScrollController.getVirtualContentSize(),
                                    height: rowsScrollController.getVirtualContentSize()
                                }
                        }
                    },
                    setViewportPosition: function(left, top) {
                        this._rowsScrollController.setViewportPosition(top || 0);
                        this._columnsScrollController.setViewportPosition(left || 0)
                    },
                    subscribeToWindowScrollEvents: function($element) {
                        this._rowsScrollController && this._rowsScrollController.subscribeToWindowScrollEvents($element)
                    },
                    updateWindowScrollPosition: function(position) {
                        this._rowsScrollController && this._rowsScrollController.scrollTo(position)
                    },
                    updateViewOptions: function(options) {
                        $.extend(this._options, options);
                        this._update()
                    },
                    _handleExpandValueChanging: function(e) {
                        this.expandValueChanging.fire(e)
                    },
                    _handleLoadingChanged: function(e) {
                        this.loadingChanged.fire(e)
                    },
                    _handleFieldsPrepared: function(e) {
                        this._options.onFieldsPrepared && this._options.onFieldsPrepared(e)
                    },
                    _createDataSource: function(options) {
                        var that = this,
                            dataSourceOptions = options.dataSource,
                            dataSource;
                        that._isSharedDataSource = dataSourceOptions instanceof pivotGrid.DataSource;
                        if (that._isSharedDataSource)
                            dataSource = dataSourceOptions;
                        else
                            dataSource = new pivotGrid.DataSource(dataSourceOptions);
                        that._changedHandler = $.proxy(that, "_update");
                        that._expandValueChangingHandler = $.proxy(that, "_handleExpandValueChanging");
                        that._loadingChangedHandler = $.proxy(that, "_handleLoadingChanged");
                        that._fieldsPreparedHandler = $.proxy(that, "_handleFieldsPrepared");
                        dataSource.on("changed", that._changedHandler);
                        dataSource.on("expandValueChanging", that._expandValueChangingHandler);
                        dataSource.on("loadingChanged", that._loadingChangedHandler);
                        dataSource.on("fieldsPrepared", that._fieldsPreparedHandler);
                        return dataSource
                    },
                    getDataSource: function() {
                        return this._dataSource
                    },
                    isLoading: function() {
                        return this._dataSource.isLoading()
                    },
                    beginLoading: function() {
                        this._dataSource._changeLoadingCount(1)
                    },
                    endLoading: function() {
                        this._dataSource._changeLoadingCount(-1)
                    },
                    isEmpty: function() {
                        var dataFields = this._dataSource.getAreaFields("data"),
                            data = this._dataSource.getData();
                        return !dataFields.length || !data.values.length
                    },
                    _update: function() {
                        var that = this,
                            dataSource = that._dataSource,
                            options = that._options,
                            columnFields = dataSource.getAreaFields("column"),
                            rowFields = dataSource.getAreaFields("row"),
                            dataFields = dataSource.getAreaFields("data"),
                            data = dataSource.getData(),
                            hiddenTotals = getHiddenTotals(dataFields),
                            hiddenGrandTotals = getHiddenGrandTotalsTotals(dataFields, columnFields),
                            grandTotalsAreHiddenForNotAllDataFields = dataFields.length > 0 ? hiddenGrandTotals.length !== dataFields.length : true,
                            dataIsHiddenForNotAllDataFields = dataFields.length > 0 ? hiddenTotals.length !== dataFields.length : true,
                            rowOptions = {
                                isEmptyGrandTotal: data.isEmptyGrandTotalRow,
                                texts: options.texts || {},
                                hiddenTotals: hiddenTotals,
                                hiddenGrandTotals: [],
                                showTotals: options.showRowTotals,
                                showData: dataIsHiddenForNotAllDataFields,
                                showGrandTotals: options.showRowGrandTotals !== false && grandTotalsAreHiddenForNotAllDataFields,
                                sortBySummaryPaths: createSortPaths(columnFields, dataFields),
                                showTotalsPrior: options.showTotalsPrior === "rows" || options.showTotalsPrior === "both",
                                showEmpty: !options.hideEmptySummaryCells,
                                fields: rowFields
                            },
                            columnOptions = {
                                isEmptyGrandTotal: data.isEmptyGrandTotalColumn,
                                texts: options.texts || {},
                                hiddenTotals: hiddenTotals,
                                showData: dataIsHiddenForNotAllDataFields,
                                hiddenGrandTotals: hiddenGrandTotals,
                                showTotals: options.showColumnTotals,
                                showTotalsPrior: options.showTotalsPrior === "columns" || options.showTotalsPrior === "both",
                                showGrandTotals: options.showColumnGrandTotals !== false && grandTotalsAreHiddenForNotAllDataFields,
                                sortBySummaryPaths: createSortPaths(rowFields, dataFields),
                                showEmpty: !options.hideEmptySummaryCells,
                                fields: columnFields
                            };
                        if (!commonUtils.isDefined(data.grandTotalRowIndex))
                            data.grandTotalRowIndex = getHeaderIndexedItems(data.rows, rowFields.length - 1, rowOptions).length;
                        if (!commonUtils.isDefined(data.grandTotalColumnIndex))
                            data.grandTotalColumnIndex = getHeaderIndexedItems(data.columns, columnFields.length - 1, columnOptions).length;
                        that._columnsInfo = createHeaderInfo(data.columns, columnFields, dataFields, true, columnOptions);
                        that._rowsInfo = createHeaderInfo(data.rows, rowFields, [], false, rowOptions);
                        if (that._rowsScrollController && that._columnsScrollController && that.changed) {
                            that._rowsScrollController.reset();
                            that._columnsScrollController.reset();
                            that._lockChanged = true;
                            that._rowsScrollController.load();
                            that._columnsScrollController.load();
                            that._lockChanged = false
                        }
                        that._fireChanged();
                        if (that._stateStoringController.isEnabled() && !that._dataSource.isLoading()) {
                            that._stateStoringController.state(that._dataSource.state());
                            that._stateStoringController.save()
                        }
                    },
                    getRowsInfo: function(getAllData) {
                        var that = this,
                            rowsInfo = that._rowsInfo,
                            scrollController = that._rowsScrollController,
                            rowspan,
                            i;
                        if (scrollController && !getAllData) {
                            var startIndex = scrollController.beginPageIndex() * that.rowPageSize(),
                                endIndex = scrollController.endPageIndex() * that.rowPageSize() + that.rowPageSize(),
                                newRowsInfo = [],
                                maxDepth = 1;
                            foreachRowInfo(rowsInfo, function(rowInfo, visibleIndex, rowIndex, _, columnIndex) {
                                var isVisible = visibleIndex >= startIndex && rowIndex < endIndex,
                                    index = rowIndex < startIndex ? 0 : rowIndex - startIndex,
                                    cell = rowInfo;
                                if (isVisible) {
                                    newRowsInfo[index] = newRowsInfo[index] || [];
                                    rowspan = rowIndex < startIndex ? rowInfo.rowspan - (startIndex - rowIndex) || 1 : rowInfo.rowspan;
                                    if (startIndex + index + rowspan > endIndex)
                                        rowspan = endIndex - (index + startIndex) || 1;
                                    if (rowspan !== rowInfo.rowspan)
                                        cell = $.extend({}, cell, {rowspan: rowspan});
                                    newRowsInfo[index].push(cell);
                                    maxDepth = math.max(maxDepth, columnIndex + 1)
                                }
                                else if (i > endIndex)
                                    return false
                            });
                            foreachRowInfo(newRowsInfo, function(rowInfo, visibleIndex, rowIndex, columnIndex, realColumnIndex) {
                                var colspan = rowInfo.colspan || 1;
                                if (realColumnIndex + colspan > maxDepth)
                                    newRowsInfo[rowIndex][columnIndex] = $.extend({}, rowInfo, {colspan: maxDepth - realColumnIndex || 1})
                            });
                            return newRowsInfo
                        }
                        return rowsInfo
                    },
                    getColumnsInfo: function(getAllData) {
                        var that = this,
                            info = that._columnsInfo,
                            scrollController = that._columnsScrollController;
                        if (scrollController && !getAllData) {
                            var startIndex = scrollController.beginPageIndex() * that.columnPageSize(),
                                endIndex = scrollController.endPageIndex() * that.columnPageSize() + that.columnPageSize(),
                                newInfo = [];
                            foreachColumnInfo(info, function(columnInfo, visibleIndex, rowIndex) {
                                var cell = columnInfo,
                                    colspan,
                                    isVisible = visibleIndex + (cell.colspan - 1 || 0) >= startIndex && visibleIndex < endIndex;
                                newInfo[rowIndex] = newInfo[rowIndex] || [];
                                if (isVisible) {
                                    if (visibleIndex < startIndex) {
                                        colspan = cell.colspan - (startIndex - visibleIndex);
                                        visibleIndex = startIndex
                                    }
                                    else
                                        colspan = cell.colspan;
                                    if (visibleIndex + colspan > endIndex)
                                        colspan = endIndex - visibleIndex;
                                    if (colspan !== cell.colspan)
                                        cell = $.extend({}, cell, {colspan: colspan});
                                    newInfo[rowIndex].push(cell)
                                }
                                else if (visibleIndex > endIndex)
                                    return false
                            });
                            info = newInfo
                        }
                        return info
                    },
                    totalRowCount: function() {
                        return this._rowsInfo.length
                    },
                    rowPageIndex: function(index) {
                        if (index !== undefined)
                            this._rowPageIndex = index;
                        return this._rowPageIndex || 0
                    },
                    totalColumnCount: function() {
                        var count = 0;
                        if (this._columnsInfo && this._columnsInfo.length)
                            for (var i = 0; i < this._columnsInfo[0].length; i++)
                                count += this._columnsInfo[0][i].colspan || 1;
                        return count
                    },
                    rowPageSize: function(size) {
                        if (size !== undefined)
                            this._rowPageSize = size;
                        return this._rowPageSize || 20
                    },
                    columnPageSize: function(size) {
                        if (size !== undefined)
                            this._columnPageSize = size;
                        return this._columnPageSize || 20
                    },
                    columnPageIndex: function(index) {
                        if (index !== undefined)
                            this._columnPageIndex = index;
                        return this._columnPageIndex || 0
                    },
                    getCellsInfo: function(getAllData) {
                        var rowsInfo = this.getRowsInfo(getAllData),
                            columnsInfo = this.getColumnsInfo(getAllData),
                            data = this._dataSource.getData();
                        return createCellsInfo(rowsInfo, columnsInfo, data, this._dataSource.getAreaFields("data"))
                    },
                    dispose: function() {
                        var that = this;
                        if (that._isSharedDataSource) {
                            that._dataSource.off("changed", that._changedHandler);
                            that._dataSource.off("expandValueChanging", that._expandValueChangingHandler);
                            that._dataSource.off("loadingChanged", that._loadingChangedHandler)
                        }
                        else
                            that._dataSource.dispose();
                        that._columnsScrollController && that._columnsScrollController.dispose();
                        that._rowsScrollController && that._rowsScrollController.dispose();
                        that._stateStoringController.dispose();
                        that.expandValueChanging.empty();
                        that.changed.empty();
                        that.loadingChanged.empty();
                        that.scrollChanged.empty()
                    }
                };
            pivotGrid.proxyMethod(members, "applyPartialDataSource");
            pivotGrid.proxyMethod(members, "collapseHeaderItem");
            pivotGrid.proxyMethod(members, "expandHeaderItem");
            pivotGrid.proxyMethod(members, "getData");
            return members
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.store.xmla.js */
    (function($, DX) {
        var Class = DevExpress.require("/class"),
            errors = DX.require("/data/data.errors"),
            commonUtils = DX.require("/utils/utils.common");
        DX.data.XmlaStore = DX.ui.dxPivotGrid.XmlaStore = Class.inherit(function() {
            var discover = '<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"><Body><Discover xmlns="urn:schemas-microsoft-com:xml-analysis"><RequestType>{2}</RequestType><Restrictions><RestrictionList><CATALOG_NAME>{0}</CATALOG_NAME><CUBE_NAME>{1}</CUBE_NAME></RestrictionList></Restrictions><Properties><PropertyList><Catalog>{0}</Catalog></PropertyList></Properties></Discover></Body></Envelope>',
                execute = '<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"><Body><Execute xmlns="urn:schemas-microsoft-com:xml-analysis"><Command><Statement>{0}</Statement></Command><Properties><PropertyList><Catalog>{1}</Catalog><ShowHiddenCubes>True</ShowHiddenCubes><SspropInitAppName>Microsoft SQL Server Management Studio</SspropInitAppName><Timeout>3600</Timeout></PropertyList></Properties></Execute></Body></Envelope>',
                mdx = "SELECT {2} FROM {0} {1} CELL PROPERTIES VALUE, FORMAT_STRING, LANGUAGE, BACK_COLOR, FORE_COLOR, FONT_FLAGS",
                mdxFilterSelect = "(SELECT {0} FROM {1})",
                mdxWith = "{0} {1} as {2}",
                mdxSlice = "WHERE ({0})",
                mdxNonEmpty = "NonEmpty({0}, {1})",
                mdxAxis = "{0} DIMENSION PROPERTIES PARENT_UNIQUE_NAME,HIERARCHY_UNIQUE_NAME, MEMBER_VALUE ON {1}",
                mdxCrossJoin = "CrossJoin({0})",
                mdxSet = "{{0}}",
                stringFormat = DX.require("/utils/utils.string").format,
                each = $.each,
                MEASURE_DEMENSION_KEY = "DX_MEASURES",
                MD_DIMTYPE_MEASURE = "2";
            DX.ui.dxPivotGrid.sendRequest = function(options) {
                return $.ajax(options)
            };
            function execXMLA(requestOptions, data) {
                var deferred = $.Deferred(),
                    beforeSend = requestOptions.beforeSend,
                    ajaxSettings = {
                        url: requestOptions.url,
                        dataType: "text",
                        data: data,
                        headers: {'Content-Type': 'text/xml'},
                        xhrFields: {},
                        method: "POST"
                    };
                if (commonUtils.isFunction(beforeSend))
                    beforeSend(ajaxSettings);
                DX.ui.dxPivotGrid.sendRequest(ajaxSettings).fail(function() {
                    deferred.reject(arguments)
                }).done(function(text) {
                    var xml;
                    try {
                        xml = $.parseXML(text)
                    }
                    catch(e) {
                        deferred.reject({
                            statusText: e.message,
                            stack: e.stack,
                            responseText: text
                        })
                    }
                    deferred.resolve(xml)
                });
                return deferred
            }
            function mdxDescendants(level, levelMember, nextLevel) {
                levelMember = levelMember ? "." + levelMember : "";
                return "Descendants({" + level + levelMember + "}, " + nextLevel + ", SELF_AND_BEFORE)"
            }
            function getAllMember(dimention) {
                return (dimention.hierarchyName || dimention.dataField) + ".[All]"
            }
            function getAllMembers(field) {
                return field.dataField + ".allMembers"
            }
            function crossJoinElements(elements) {
                var elementsString = elements.join(",");
                return elements.length > 1 ? stringFormat(mdxCrossJoin, elementsString) : elementsString
            }
            function generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName) {
                var crossJoinArgs = [],
                    dimensions = options[axisName],
                    dataField,
                    allMember,
                    fields = [],
                    hierarchyName,
                    arg,
                    prevDimension,
                    prevHierarchyName,
                    isLastDimesionInGroup,
                    isFirstDimesionInGroup,
                    expandAllIndex,
                    field,
                    member,
                    i;
                for (i = expandIndex; i <= expandLevel; i++) {
                    field = dimensions[i];
                    dataField = field.dataField;
                    prevHierarchyName = dimensions[i - 1] && dimensions[i - 1].hierarchyName;
                    hierarchyName = field.hierarchyName;
                    isLastDimesionInGroup = !hierarchyName || !dimensions[i + 1] || dimensions[i + 1].hierarchyName !== hierarchyName;
                    expandAllIndex = path.length + expandAllCount + expandIndex;
                    arg = null;
                    fields.push(field);
                    if (i < path.length) {
                        if (isLastDimesionInGroup)
                            arg = "(" + dataField + "." + preparePathValue(path[i]) + ")"
                    }
                    else if (i <= expandAllIndex)
                        if (i === 0 && expandAllCount === 0) {
                            allMember = getAllMember(dimensions[expandIndex]);
                            if (!hierarchyName)
                                arg = getAllMembers(dimensions[expandIndex]);
                            else
                                arg = allMember + "," + dimensions[expandIndex].dataField
                        }
                        else if (hierarchyName) {
                            member = preparePathValue(slicePath[slicePath.length - 1]);
                            if (isLastDimesionInGroup || i === expandAllIndex)
                                if (prevHierarchyName === hierarchyName) {
                                    if (slicePath.length)
                                        prevDimension = dimensions[slicePath.length - 1];
                                    if (!prevDimension || prevDimension.hierarchyName !== hierarchyName) {
                                        prevDimension = dimensions[i - 1];
                                        member = ""
                                    }
                                    arg = mdxDescendants(prevDimension.dataField, member, dataField)
                                }
                                else
                                    arg = getAllMembers(field)
                        }
                        else
                            arg = getAllMembers(field);
                    else {
                        isFirstDimesionInGroup = !hierarchyName || prevHierarchyName !== hierarchyName;
                        if (isFirstDimesionInGroup)
                            arg = "(" + getAllMember(field) + ")"
                    }
                    if (arg) {
                        arg = stringFormat(mdxSet, arg);
                        crossJoinArgs.push(arg)
                    }
                }
                return crossJoinElements(crossJoinArgs)
            }
            function fillCrossJoins(crossJoins, path, expandLevel, expandIndex, slicePath, options, axisName) {
                var expandAllCount = -1,
                    dimensions = options[axisName],
                    dimestionIndex;
                do {
                    expandAllCount++;
                    dimestionIndex = path.length + expandAllCount + expandIndex;
                    crossJoins.push(generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName))
                } while (dimensions[dimestionIndex] && dimensions[dimestionIndex + 1] && dimensions[dimestionIndex].expanded)
            }
            function declare(expression, withArray, name, type) {
                name = name || "[DX_Set_" + withArray.length + "]";
                type = type || "set";
                withArray.push(stringFormat(mdxWith, type, name, expression));
                return name
            }
            function generateAxisMdx(options, axisName, cells, withArray, parseOptions) {
                var dimensions = options[axisName],
                    crossJoins = [],
                    path = [],
                    expandedPaths = [],
                    expandIndex = 0,
                    expandLevel = 0,
                    result = [],
                    cellsString = stringFormat(mdxSet, cells.join(","));
                if (dimensions && dimensions.length) {
                    if (options.headerName === axisName) {
                        path = options.path;
                        expandLevel = expandIndex = path.length
                    }
                    else {
                        expandedPaths = (axisName === "columns" ? options.columnExpandedPaths : options.rowExpandedPaths) || expandedPaths;
                        each(expandedPaths, function(_, path) {
                            expandLevel = Math.max(expandLevel, path.length)
                        })
                    }
                    while (dimensions[expandLevel + 1] && dimensions[expandLevel].expanded)
                        expandLevel++;
                    fillCrossJoins(crossJoins, [], expandLevel, expandIndex, path, options, axisName);
                    each(expandedPaths, function(_, expandedPath) {
                        fillCrossJoins(crossJoins, expandedPath, expandLevel, expandIndex, expandedPath, options, axisName)
                    });
                    for (var i = expandLevel; i >= path.length; i--)
                        if (dimensions[i].hierarchyName) {
                            parseOptions.visibleLevels[dimensions[i].hierarchyName] = parseOptions.visibleLevels[dimensions[i].hierarchyName] || [];
                            parseOptions.visibleLevels[dimensions[i].hierarchyName].push(dimensions[i].dataField)
                        }
                }
                crossJoins.length && result.push(stringFormat(mdxNonEmpty, declare(stringFormat(mdxSet, crossJoins.join(",")), withArray, "[" + "DX_" + axisName + "]"), cellsString));
                if (axisName === "columns" && cells.length)
                    result.push(cellsString);
                return stringFormat(mdxAxis, crossJoinElements(result), axisName)
            }
            function generateAxisFieldsFilter(fields) {
                var filterMembers = [];
                each(fields, function(_, field) {
                    var dataField = field.dataField,
                        filterExpression = [],
                        filterValues = field.filterValues || [],
                        filterStringExpression;
                    if (field.hierarchyName && commonUtils.isNumber(field.groupIndex))
                        return;
                    each(filterValues, function(_, filterValue) {
                        var filterMdx = dataField + "." + preparePathValue(commonUtils.isArray(filterValue) ? filterValue[filterValue.length - 1] : filterValue);
                        if (field.filterType === "exclude") {
                            filterExpression.push(filterMdx + ".parent");
                            filterMdx = "Descendants(" + filterMdx + ")"
                        }
                        filterExpression.push(filterMdx)
                    });
                    if (filterValues.length) {
                        filterStringExpression = stringFormat(mdxSet, filterExpression.join(","));
                        if (field.filterType === "exclude")
                            filterStringExpression = "Except(" + getAllMembers(field) + "," + filterStringExpression + ")";
                        filterMembers.push(filterStringExpression)
                    }
                });
                return filterMembers.length ? crossJoinElements(filterMembers) : ""
            }
            function generateFrom(columnsFilter, rowsFilter, filter, cubeName) {
                var from = "[" + cubeName + "]";
                each([columnsFilter, rowsFilter, filter], function(_, filter) {
                    if (filter)
                        from = stringFormat(mdxFilterSelect, filter + "on 0", from)
                });
                return from
            }
            function generateMdxCore(axisStrings, withArray, columns, rows, filters, slice, cubeName) {
                var mdxString = "",
                    withString = (withArray.length ? "with " + withArray.join(" ") : "") + " ";
                if (axisStrings.length)
                    mdxString = withString + stringFormat(mdx, generateFrom(generateAxisFieldsFilter(columns), generateAxisFieldsFilter(rows), generateAxisFieldsFilter(filters || []), cubeName), slice.length ? stringFormat(mdxSlice, slice.join(",")) : "", axisStrings.join(","));
                return mdxString
            }
            function prepareDataFields(withArray, valueFields) {
                return $.map(valueFields, function(cell) {
                        if (commonUtils.isString(cell.expression))
                            declare(cell.expression, withArray, cell.dataField, "member");
                        return cell.dataField
                    })
            }
            function generateMDX(options, cubeName, parseOptions) {
                var columns = options.columns || [],
                    rows = options.rows || [],
                    values = options.values && options.values.length ? options.values : [{dataField: '[Measures]'}],
                    slice = [],
                    withArray = [],
                    axisStrings = [],
                    dataFields = prepareDataFields(withArray, values);
                parseOptions.measureCount = values.length;
                parseOptions.visibleLevels = {};
                if (options.headerName && options.path)
                    each(options.path, function(index, value) {
                        var dimention = options[options.headerName][index];
                        if (!dimention.hierarchyName || dimention.hierarchyName !== options[options.headerName][index + 1].hierarchyName)
                            slice.push(dimention.dataField + "." + preparePathValue(value))
                    });
                if (columns.length || dataFields.length)
                    axisStrings.push(generateAxisMdx(options, "columns", dataFields, withArray, parseOptions));
                if (rows.length)
                    axisStrings.push(generateAxisMdx(options, "rows", dataFields, withArray, parseOptions));
                return generateMdxCore(axisStrings, withArray, columns, rows, options.filters, slice, cubeName)
            }
            function createDrillDownAxisSlice(slice, fields, path) {
                each(path, function(index, value) {
                    var field = fields[index];
                    if (field.hierarchyName && (fields[index + 1] || {}).hierarchyName === field.hierarchyName)
                        return;
                    slice.push(field.dataField + "." + preparePathValue(value))
                })
            }
            function generateDrillDownMDX(options, cubeName, params) {
                var columns = options.columns || [],
                    rows = options.rows || [],
                    values = options.values && options.values.length ? options.values : [{dataField: '[Measures]'}],
                    slice = [],
                    withArray = [],
                    axisStrings = [],
                    dataFields = prepareDataFields(withArray, values),
                    maxRowCount = params.maxRowCount,
                    customColumns = params.customColumns || [],
                    customColumnsString = customColumns.length > 0 ? " return " + customColumns.join(",") : "",
                    coreMDX;
                createDrillDownAxisSlice(slice, columns, params.columnPath || []);
                createDrillDownAxisSlice(slice, rows, params.rowPath || []);
                if (columns.length || columns.length || dataFields.length)
                    axisStrings.push([(dataFields[params.dataIndex] || dataFields[0]) + " on 0"]);
                coreMDX = generateMdxCore(axisStrings, withArray, columns, rows, options.filters, slice, cubeName);
                return coreMDX ? "drillthrough" + (maxRowCount > 0 ? " maxrows " + maxRowCount : "") + coreMDX + customColumnsString : coreMDX
            }
            function getNumber(str) {
                return parseInt(str, 10)
            }
            function parseValue(valueText) {
                return $.isNumeric(valueText) ? parseFloat(valueText) : valueText
            }
            function getFirstChild(node, tagName) {
                return (node.getElementsByTagName(tagName) || [])[0]
            }
            function getFirstChildText(node, childTagName) {
                return getNodeText(getFirstChild(node, childTagName))
            }
            function parseAxes(xml) {
                var axes = [];
                each(xml.getElementsByTagName("Axis"), function(_, axisElement) {
                    var name = axisElement.getAttribute("name"),
                        axis = [],
                        index = 0;
                    if (name.indexOf("Axis") === 0 && commonUtils.isNumber(getNumber(name.substr(4)))) {
                        axes.push(axis);
                        each(axisElement.getElementsByTagName("Tuple"), function(_, tupleElement) {
                            var tupleMembers = tupleElement.childNodes,
                                tuple,
                                levelSum = 0,
                                members = [],
                                level,
                                membersCount = tupleMembers.length - 1,
                                isAxisWithMeasure = axes.length === 1,
                                i;
                            if (isAxisWithMeasure)
                                membersCount--;
                            axis.push(members);
                            for (i = membersCount; i >= 0; i--) {
                                tuple = tupleMembers[i];
                                level = getNumber(getFirstChildText(tuple, "LNum"));
                                members[i] = {
                                    caption: getFirstChildText(tuple, "Caption"),
                                    value: parseValue(getFirstChildText(tuple, "MEMBER_VALUE")),
                                    level: level,
                                    index: index++,
                                    hasValue: !levelSum && (!!level || i === 0),
                                    name: getFirstChildText(tuple, "UName"),
                                    hierarchyName: tupleMembers[i].getAttribute("Hierarchy"),
                                    parentName: getFirstChildText(tuple, "PARENT_UNIQUE_NAME"),
                                    levelName: getFirstChildText(tuple, "LName")
                                };
                                levelSum += level
                            }
                        })
                    }
                });
                while (axes.length < 2)
                    axes.push([[{level: 0}]]);
                return axes
            }
            function getNodeText(node) {
                return node && node && (node.textContent || node.text || node.innerHTML) || ""
            }
            function parseCells(xml, axes, measureCount) {
                var cells = [],
                    cell = [],
                    index = 0,
                    measureIndex,
                    cellsOriginal = [],
                    cellElements = xml.getElementsByTagName("Cell"),
                    row;
                for (var i = 0; i < cellElements.length; i++) {
                    var xmlCell = cellElements[i],
                        valueElement = xmlCell.getElementsByTagName("Value")[0],
                        value = parseFloat(getNodeText(valueElement));
                    cellsOriginal[getNumber(xmlCell.getAttribute("CellOrdinal"))] = {value: isNaN(value) ? null : value}
                }
                each(axes[1], function() {
                    row = [];
                    cells.push(row);
                    each(axes[0], function() {
                        measureIndex = index % measureCount;
                        if (measureIndex === 0) {
                            cell = [];
                            row.push(cell)
                        }
                        cell.push(cellsOriginal[index] ? cellsOriginal[index].value : null);
                        index++
                    })
                });
                return cells
            }
            function preparePathValue(pathValue) {
                if (pathValue)
                    return commonUtils.isString(pathValue) && pathValue.indexOf("&[") !== -1 ? pathValue : "[" + pathValue + "]"
            }
            function getItem(hash, name, member, index) {
                var item = hash[name];
                if (!item) {
                    item = {};
                    hash[name] = item
                }
                if (!item.value && member) {
                    item.text = member.caption;
                    item.value = member.value;
                    item.key = name ? name.slice(name.indexOf('&[')) : '';
                    item.levelName = member.levelName;
                    item.hierarchyName = member.hierarchyName;
                    item.parentName = member.parentName;
                    item.index = index;
                    item.level = member.level
                }
                return item
            }
            function getVisibleChildren(item, visibleLevels) {
                var result = [],
                    children = item.children && (item.children.length ? item.children : $.map(item.children.grandTotalHash || [], function(e) {
                        return e.children
                    })),
                    firstChild = children && children[0];
                if (firstChild && (visibleLevels[firstChild.hierarchyName] && $.inArray(firstChild.levelName, visibleLevels[firstChild.hierarchyName]) !== -1 || !visibleLevels[firstChild.hierarchyName] || firstChild.level === 0)) {
                    var newChildren = $.map(children, function(child) {
                            return child.hierarchyName === firstChild.hierarchyName ? child : null
                        });
                    newChildren.grandTotalHash = children.grandTotalHash;
                    return newChildren
                }
                else if (firstChild)
                    for (var i = 0; i < children.length; i++)
                        if (children[i].hierarchyName === firstChild.hierarchyName)
                            result.push.apply(result, getVisibleChildren(children[i], visibleLevels));
                return result
            }
            function processMember(dataIndex, member, parentItem) {
                var currentItem,
                    children = parentItem.children = parentItem.children || [],
                    hash = children.hash = children.hash || {},
                    grandTotalHash = children.grandTotalHash = children.grandTotalHash || {};
                if (member.parentName) {
                    parentItem = getItem(hash, member.parentName);
                    children = parentItem.children = parentItem.children || []
                }
                currentItem = getItem(hash, member.name, member, dataIndex);
                if (member.hasValue && !currentItem.added) {
                    currentItem.index = dataIndex;
                    currentItem.added = true;
                    children.push(currentItem)
                }
                if ((!parentItem.value || !parentItem.parentName) && member.parentName)
                    grandTotalHash[member.parentName] = parentItem;
                else if (grandTotalHash[parentItem.name])
                    delete grandTotalHash[member.parentName];
                return currentItem
            }
            function getGrandTotalIndex(parentItem, visibleLevels) {
                var grandTotalIndex;
                if (parentItem.children.length === 1 && parentItem.children[0].parentName === "") {
                    grandTotalIndex = parentItem.children[0].index;
                    var grandTotalHash = parentItem.children.grandTotalHash;
                    parentItem.children = parentItem.children[0].children || [];
                    parentItem.children.grandTotalHash = grandTotalHash;
                    parentItem.children = getVisibleChildren(parentItem, visibleLevels)
                }
                else if (parentItem.children.length === 0)
                    grandTotalIndex = 0;
                return grandTotalIndex
            }
            function fillDataSourceAxes(dataSourceAxis, axisTuples, measureCount, visibleLevels) {
                var grandTotalIndex,
                    result = [];
                each(axisTuples, function(tupleIndex, members) {
                    var parentItem = {children: result},
                        dataIndex = commonUtils.isDefined(measureCount) ? Math.floor(tupleIndex / measureCount) : tupleIndex;
                    each(members, function(_, member) {
                        parentItem = processMember(dataIndex, member, parentItem)
                    })
                });
                var parentItem = {children: result};
                parentItem.children = getVisibleChildren(parentItem, visibleLevels);
                grandTotalIndex = getGrandTotalIndex(parentItem, visibleLevels);
                DX.ui.dxPivotGrid.foreachTree(parentItem.children, function(items) {
                    var item = items[0],
                        children = getVisibleChildren(item, visibleLevels);
                    if (children.length)
                        item.children = children;
                    else
                        delete item.children;
                    delete item.levelName;
                    delete item.hierarchyName;
                    delete item.added;
                    delete item.parentName;
                    delete item.level
                }, true);
                each(parentItem.children || [], function(_, e) {
                    dataSourceAxis.push(e)
                });
                return grandTotalIndex
            }
            function checkError(xml) {
                var errorElement = $(xml).find("Error"),
                    description,
                    error;
                if (errorElement.length) {
                    description = errorElement.attr("Description");
                    error = new errors.Error("E4000", description);
                    errors.log("E4000", description);
                    return error
                }
                return null
            }
            function parseResult(xml, parseOptions) {
                var dataSource = {
                        columns: [],
                        rows: []
                    },
                    axes,
                    measureCount = parseOptions.measureCount;
                axes = parseAxes(xml);
                dataSource.grandTotalColumnIndex = fillDataSourceAxes(dataSource.columns, axes[0], measureCount, parseOptions.visibleLevels);
                dataSource.grandTotalRowIndex = fillDataSourceAxes(dataSource.rows, axes[1], undefined, parseOptions.visibleLevels);
                dataSource.values = parseCells(xml, axes, measureCount);
                return dataSource
            }
            function parseDiscoverRowSet(xml, schema, dimensions) {
                var result = [],
                    isMeasure = schema === "MEASURE",
                    displayFolderField = isMeasure ? "MEASUREGROUP_NAME" : schema + "_DISPLAY_FOLDER";
                each(xml.getElementsByTagName("row"), function(_, row) {
                    var hierarchyName = schema === "LEVEL" ? getFirstChildText(row, "HIERARCHY_UNIQUE_NAME") : undefined,
                        levelNumber = getFirstChildText(row, "LEVEL_NUMBER");
                    if ((levelNumber !== "0" || getFirstChildText(row, schema + "_IS_VISIBLE") !== "true") && getFirstChildText(row, "DIMENSION_TYPE") !== MD_DIMTYPE_MEASURE) {
                        var dimension = isMeasure ? MEASURE_DEMENSION_KEY : getFirstChildText(row, "DIMENSION_UNIQUE_NAME"),
                            dataField = getFirstChildText(row, schema + "_UNIQUE_NAME");
                        result.push({
                            dimension: dimensions.names[dimension] || dimension,
                            groupIndex: levelNumber ? getNumber(levelNumber) - 1 : undefined,
                            dataField: dataField,
                            caption: getFirstChildText(row, schema + "_CAPTION"),
                            hierarchyName: hierarchyName,
                            groupName: hierarchyName,
                            displayFolder: getFirstChildText(row, displayFolderField),
                            isMeasure: isMeasure,
                            isDefault: !!dimensions.defaultHierarhies[dataField]
                        })
                    }
                });
                return result
            }
            function parseDimensionsDiscoverRowSet(xml) {
                var result = {
                        names: {},
                        defaultHierarhies: {}
                    };
                each($(xml).find("row"), function() {
                    var $row = $(this),
                        type = $row.children("DIMENSION_TYPE").text(),
                        dimensionName = type === MD_DIMTYPE_MEASURE ? MEASURE_DEMENSION_KEY : $row.children("DIMENSION_UNIQUE_NAME").text();
                    result.names[dimensionName] = $row.children("DIMENSION_CAPTION").text();
                    result.defaultHierarhies[$row.children("DEFAULT_HIERARCHY").text()] = true
                });
                return result
            }
            function parseStringWithUnicodeSymbols(str) {
                str = str.replace(/_x(....)_/g, function(whole, group1) {
                    return String.fromCharCode(parseInt(group1, 16))
                });
                var stringArray = str.match(/\[.+?\]/gi);
                if (stringArray && stringArray.length)
                    str = stringArray[stringArray.length - 1];
                return str.replace(/\[/gi, "").replace(/\]/gi, "").replace(/\$/gi, "").replace(/\./gi, " ")
            }
            function parseDrillDownRowset(xml) {
                var rows = xml.getElementsByTagName("row"),
                    result = [],
                    columnNames = {};
                for (var i = 0; i < rows.length; i++) {
                    var children = rows[i].childNodes,
                        item = {};
                    for (var j = 0; j < children.length; j++) {
                        var tagName = children[j].tagName,
                            name = columnNames[tagName] = columnNames[tagName] || parseStringWithUnicodeSymbols(tagName);
                        item[name] = getNodeText(children[j])
                    }
                    result.push(item)
                }
                return result
            }
            function sendQuery(storeOptions, mdxString) {
                mdxString = $("<div>").text(mdxString).html();
                return execXMLA(storeOptions, stringFormat(execute, mdxString, storeOptions.catalog))
            }
            return {
                    ctor: function(options) {
                        this._options = options
                    },
                    getFields: function() {
                        var options = this._options,
                            catalog = options.catalog,
                            cube = options.cube,
                            dimensionsRequest = execXMLA(options, stringFormat(discover, catalog, cube, "MDSCHEMA_DIMENSIONS")),
                            measuresRequest = execXMLA(options, stringFormat(discover, catalog, cube, "MDSCHEMA_MEASURES")),
                            hierarchiesRequest = execXMLA(options, stringFormat(discover, catalog, cube, "MDSCHEMA_HIERARCHIES")),
                            levelsRequest = execXMLA(options, stringFormat(discover, catalog, cube, "MDSCHEMA_LEVELS")),
                            result = $.Deferred();
                        $.when(dimensionsRequest, measuresRequest, hierarchiesRequest, levelsRequest).done(function(dimensionsResponse, measuresResponse, hierarhiesResponse, levelsResponse) {
                            var dimensions = parseDimensionsDiscoverRowSet(dimensionsResponse),
                                hierarchies = parseDiscoverRowSet(hierarhiesResponse, "HIERARCHY", dimensions),
                                levels = parseDiscoverRowSet(levelsResponse, "LEVEL", dimensions),
                                fields = parseDiscoverRowSet(measuresResponse, "MEASURE", dimensions).concat(hierarchies),
                                levelsByHierarchy = {};
                            each(levels, function(_, level) {
                                levelsByHierarchy[level.hierarchyName] = levelsByHierarchy[level.hierarchyName] || [];
                                levelsByHierarchy[level.hierarchyName].push(level)
                            });
                            each(hierarchies, function(_, hierarchy) {
                                if (levelsByHierarchy[hierarchy.dataField] && levelsByHierarchy[hierarchy.dataField].length > 1) {
                                    hierarchy.groupName = hierarchy.hierarchyName = hierarchy.dataField;
                                    fields.push.apply(fields, levelsByHierarchy[hierarchy.hierarchyName])
                                }
                            });
                            result.resolve(fields)
                        }).fail(result.reject);
                        return result
                    },
                    load: function(options) {
                        var result = $.Deferred(),
                            storeOptions = this._options,
                            parseOptions = {},
                            mdxString = generateMDX(options, storeOptions.cube, parseOptions);
                        if (mdxString)
                            $.when(sendQuery(storeOptions, mdxString)).done(function(executeXml) {
                                var error = checkError(executeXml);
                                if (!error)
                                    result.resolve(parseResult(executeXml, parseOptions));
                                else
                                    result.reject(error)
                            }).fail(result.reject);
                        else
                            result.resolve({
                                columns: [],
                                rows: [],
                                values: [],
                                grandTotalColumnIndex: 0,
                                grandTotalRowIndex: 0
                            });
                        return result
                    },
                    supportSorting: function() {
                        return true
                    },
                    getDrillDownItems: function(options, params) {
                        var result = $.Deferred(),
                            storeOptions = this._options,
                            mdxString = generateDrillDownMDX(options, storeOptions.cube, params);
                        if (mdxString)
                            $.when(sendQuery(storeOptions, mdxString)).done(function(executeXml) {
                                var error = checkError(executeXml);
                                if (!error)
                                    result.resolve(parseDrillDownRowset(executeXml));
                                else
                                    result.reject(error)
                            }).fail(result.reject);
                        else
                            result.resolve([]);
                        return result
                    },
                    key: $.noop,
                    filter: $.noop
                }
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.store.local.js */
    (function($, DX) {
        var dataUtils = DX.data.utils,
            pivotGrid = DX.ui.dxPivotGrid,
            Class = DevExpress.require("/class"),
            formatHelper = DX.require("/utils/utils.formatHelper"),
            commonUtils = DX.require("/utils/utils.common"),
            setFieldProperty = pivotGrid.setFieldProperty;
        pivotGrid.LocalStore = Class.inherit(function() {
            var DATE_INTERVAL_SELECTORS = {
                    year: function(date) {
                        return date && date.getFullYear()
                    },
                    quarter: function(date) {
                        return date && Math.floor(date.getMonth() / 3) + 1
                    },
                    month: function(date) {
                        return date && date.getMonth() + 1
                    },
                    day: function(date) {
                        return date && date.getDate()
                    },
                    dayOfWeek: function(date) {
                        return date && date.getDay()
                    }
                };
            var DATE_INTERVAL_FORMATS = {
                    month: {
                        format: 'month',
                        dateType: 'full'
                    },
                    quarter: {
                        format: 'quarter',
                        dateType: 'full'
                    },
                    dayOfWeek: {
                        format: 'dayOfWeek',
                        dateType: 'full'
                    }
                };
            function prepareFields(fields) {
                $.each(fields || [], function(_, field) {
                    var fieldSelector,
                        intervalSelector,
                        dataField = field.dataField,
                        groupInteval,
                        levels = field.levels,
                        dataSelector;
                    if (!field.selector) {
                        if (!dataField)
                            dataSelector = function(data) {
                                return data
                            };
                        else
                            dataSelector = dataField.indexOf(".") !== -1 ? dataUtils.compileGetter(dataField) : function(data) {
                                return data[dataField]
                            };
                        if (levels)
                            prepareFields(levels);
                        if (field.dataType === 'date') {
                            intervalSelector = DATE_INTERVAL_SELECTORS[field.groupInterval];
                            fieldSelector = function(data) {
                                var value = dataSelector(data);
                                if (value && !(value instanceof Date))
                                    value = new Date(value);
                                return intervalSelector ? intervalSelector(value) : value
                            };
                            if (!field.format)
                                setFieldProperty(field, "format", DATE_INTERVAL_FORMATS[field.groupInterval])
                        }
                        else if (field.dataType === 'number') {
                            groupInteval = commonUtils.isNumber(field.groupInterval) && field.groupInterval > 0 && field.groupInterval;
                            if (groupInteval && !field.customizeText)
                                setFieldProperty(field, "customizeText", function(formatObject) {
                                    var secondValue = formatObject.value + groupInteval,
                                        secondValueText = formatHelper.format(secondValue, field.format, field.precision);
                                    return formatObject.valueText && secondValueText ? formatObject.valueText + " - " + secondValueText : ""
                                });
                            fieldSelector = function(data) {
                                var value = dataSelector(data);
                                if (commonUtils.isString(value))
                                    value = Number(value);
                                return groupInteval ? Math.floor(value / groupInteval) * groupInteval : value
                            }
                        }
                        else
                            fieldSelector = dataSelector;
                        setFieldProperty(field, "selector", fieldSelector)
                    }
                })
            }
            var addHierarchyItem = function(value, hierarchyItems, pathHash, childrenHash) {
                    var hierarchyItem = childrenHash[pathHash];
                    if (!hierarchyItem) {
                        hierarchyItem = {
                            value: value,
                            index: childrenHash.length++
                        };
                        childrenHash[pathHash] = hierarchyItem;
                        hierarchyItems.push(hierarchyItem)
                    }
                    return hierarchyItem
                };
            function fillHierarchyItemIndexesCore(indexes, options, children, expandIndex, pathHash) {
                var dimension = options.dimensions[expandIndex],
                    expandedPathsHash = options.expandedPathsHash,
                    dimensionValue,
                    hierarchyItem;
                if (dimension) {
                    dimensionValue = dimension.selector(options.data);
                    pathHash = pathHash !== undefined ? pathHash + "." + dimensionValue : dimensionValue + "";
                    hierarchyItem = addHierarchyItem(dimensionValue, children, pathHash, options.childrenHash);
                    indexes.push(hierarchyItem.index);
                    if (expandedPathsHash && expandedPathsHash[pathHash] || dimension.expanded) {
                        if (!hierarchyItem.children)
                            hierarchyItem.children = [];
                        fillHierarchyItemIndexesCore(indexes, options, hierarchyItem.children, expandIndex + 1, pathHash)
                    }
                }
            }
            function generateHierarchyItems(data, loadOptions, headers, headerName) {
                var result = [0],
                    expandIndex = loadOptions.headerName === headerName ? loadOptions.path.length : 0,
                    expandedPaths = headerName === "rows" ? loadOptions.rowExpandedPaths : loadOptions.columnExpandedPaths,
                    options = {
                        data: data,
                        childrenHash: headers[headerName + "Hash"],
                        dimensions: loadOptions[headerName],
                        expandedPathsHash: loadOptions.headerName !== headerName && expandedPaths && expandedPaths.hash
                    };
                fillHierarchyItemIndexesCore(result, options, headers[headerName], expandIndex);
                return result
            }
            function generateAggregationCells(data, cells, headers, options) {
                var cellSet = [],
                    x,
                    y,
                    rowIndex,
                    columnIndex;
                var rowIndexes = generateHierarchyItems(data, options, headers, "rows");
                var columnIndexes = generateHierarchyItems(data, options, headers, "columns");
                for (y = 0; y < rowIndexes.length; y++) {
                    rowIndex = rowIndexes[y];
                    cells[rowIndex] = cells[rowIndex] || [];
                    for (x = 0; x < columnIndexes.length; x++) {
                        columnIndex = columnIndexes[x];
                        cellSet.push(cells[rowIndex][columnIndex] = cells[rowIndex][columnIndex] || [])
                    }
                }
                return cellSet
            }
            function fillHashExpandedPath(expandedPaths) {
                if (expandedPaths) {
                    expandedPaths.hash = {};
                    $.each(expandedPaths, function() {
                        expandedPaths.hash[this.join(".")] = true
                    })
                }
            }
            function prepareLoadOption(options) {
                options.rows = options.rows || [];
                options.columns = options.columns || [];
                options.filters = options.filters || [];
                fillHashExpandedPath(options.columnExpandedPaths);
                fillHashExpandedPath(options.rowExpandedPaths);
                prepareFields(options.columns);
                prepareFields(options.rows);
                prepareFields(options.values);
                prepareFields(options.filters)
            }
            function getAggregator(field) {
                if (field.summaryType === "custom") {
                    field.calculateCustomSummary = field.calculateCustomSummary || $.noop;
                    return {
                            seed: function() {
                                var options = {
                                        summaryProcess: "start",
                                        totalValue: undefined
                                    };
                                field.calculateCustomSummary(options);
                                return options
                            },
                            step: function(options, value) {
                                options.summaryProcess = "calculate";
                                options.value = value;
                                field.calculateCustomSummary(options);
                                return options
                            },
                            finalize: function(options) {
                                options.summaryProcess = "finalize";
                                delete options.value;
                                field.calculateCustomSummary(options);
                                return options.totalValue
                            }
                        }
                }
                return dataUtils.aggregators[field.summaryType] || dataUtils.aggregators.count
            }
            function aggregationStep(measures, aggregationCells, data) {
                for (var aggregatorIndex = 0; aggregatorIndex < measures.length; aggregatorIndex++) {
                    var cellField = measures[aggregatorIndex];
                    var cellValue = cellField.selector(data);
                    var aggregator = getAggregator(cellField);
                    for (var cellSetIndex = 0; cellSetIndex < aggregationCells.length; cellSetIndex++) {
                        var cell = aggregationCells[cellSetIndex];
                        if (cell.length <= aggregatorIndex)
                            cell[aggregatorIndex] = commonUtils.isFunction(aggregator.seed) ? aggregator.seed() : aggregator.seed;
                        if (cell[aggregatorIndex] === undefined)
                            cell[aggregatorIndex] = cellValue;
                        else if (commonUtils.isDefined(cellValue))
                            cell[aggregatorIndex] = aggregator.step(cell[aggregatorIndex], cellValue)
                    }
                }
            }
            function aggregationFinalize(measures, cells) {
                $.each(measures, function(aggregatorIndex, cellField) {
                    var aggregator = getAggregator(cellField);
                    if (aggregator.finalize)
                        $.each(cells, function(_, row) {
                            $.each(row, function(_, cell) {
                                if (cell && cell[aggregatorIndex] !== undefined)
                                    cell[aggregatorIndex] = aggregator.finalize(cell[aggregatorIndex])
                            })
                        })
                })
            }
            function areValuesEqual(filterValue, fieldValue) {
                if (commonUtils.isArray(filterValue)) {
                    fieldValue = fieldValue || [];
                    for (var i = 0; i < filterValue.length; i++)
                        if (filterValue[i] !== fieldValue[i])
                            return false;
                    return true
                }
                else
                    return filterValue === fieldValue
            }
            function getGroupValue(levels, data) {
                var value = [];
                $.each(levels, function(_, field) {
                    value.push(field.selector(data))
                });
                return value
            }
            function createDimensionFilters(dimention) {
                var filters = [];
                $.each(dimention, function(_, field) {
                    var filterValues = field.filterValues || [],
                        groupName = field.groupName,
                        filter;
                    if (groupName && commonUtils.isNumber(field.groupIndex))
                        return;
                    filter = function(dataItem) {
                        var value = field.levels ? getGroupValue(field.levels, dataItem) : field.selector(dataItem),
                            result = false;
                        for (var i = 0; i < filterValues.length; i++)
                            if (areValuesEqual(filterValues[i], value)) {
                                result = true;
                                break
                            }
                        return field.filterType === "exclude" ? !result : result
                    };
                    filterValues.length && filters.push(filter)
                });
                return filters
            }
            function createFilter(options) {
                var filters = createDimensionFilters(options.rows).concat(createDimensionFilters(options.columns)).concat(createDimensionFilters(options.filters)),
                    expandedDimensions = options[options.headerName],
                    path = options.path;
                if (expandedDimensions)
                    filters.push(function(dataItem) {
                        var expandValue;
                        for (var i = 0; i < path.length; i++) {
                            expandValue = expandedDimensions[i].selector(dataItem);
                            if (expandValue !== path[i])
                                return false
                        }
                        return true
                    });
                return function(dataItem) {
                        for (var i = 0; i < filters.length; i++)
                            if (!filters[i](dataItem))
                                return false;
                        return true
                    }
            }
            function loadCore(items, options) {
                var headers = {
                        columns: [],
                        rows: [],
                        columnsHash: {length: 1},
                        rowsHash: {length: 1}
                    },
                    values = [[[]]],
                    aggregationCells,
                    filter,
                    data,
                    i;
                prepareLoadOption(options);
                filter = createFilter(options);
                for (i = 0; i < items.length; i++) {
                    data = items[i];
                    if (filter(data)) {
                        aggregationCells = generateAggregationCells(data, values, headers, options);
                        aggregationStep(options.values, aggregationCells, data)
                    }
                }
                aggregationFinalize(options.values, values);
                return {
                        rows: headers.rows,
                        columns: headers.columns,
                        values: values,
                        grandTotalRowIndex: 0,
                        grandTotalColumnIndex: 0
                    }
            }
            function createGroupFields(item) {
                return $.map(["year", "quarter", "month"], function(value, index) {
                        return $.extend({}, item, {
                                groupInterval: value,
                                groupIndex: index
                            })
                    })
            }
            function parseFields(dataSource, fieldsList, path, fieldsDataType) {
                var result = [];
                $.each(fieldsList || [], function(field, value) {
                    var dataIndex = 1,
                        currentPath = path.length ? path + "." + field : field,
                        dataType = fieldsDataType[currentPath],
                        getter = dataUtils.compileGetter(currentPath),
                        items;
                    while (!commonUtils.isDefined(value) && dataSource[dataIndex]) {
                        value = getter(dataSource[dataIndex]);
                        dataIndex++
                    }
                    if (!dataType && commonUtils.isDefined(value))
                        dataType = $.type(value);
                    items = [{
                            dataField: currentPath,
                            dataType: dataType,
                            groupName: dataType === "date" ? field : undefined,
                            groupInterval: undefined,
                            displayFolder: path
                        }];
                    if (dataType === "date")
                        items = items.concat(createGroupFields(items[0]));
                    else if (dataType === "object")
                        items = parseFields(dataSource, value, currentPath, fieldsDataType);
                    result.push.apply(result, items)
                });
                return result
            }
            function discover(items, fieldsDataType) {
                fieldsDataType = fieldsDataType || {};
                return parseFields(items, items[0], "", fieldsDataType)
            }
            function loadDataSource(dataSource, reload) {
                var d = $.Deferred();
                if (!dataSource.isLoaded() || reload) {
                    var loadDeferred = reload ? dataSource.load() : dataSource.reload();
                    $.when(loadDeferred).always(function() {
                        loadDataSource(dataSource).done(d.resolve).fail(d.reject)
                    })
                }
                else
                    d.resolve(dataSource.items());
                return d
            }
            function getFilterPathFields(fields, path) {
                var result = [];
                path = path || [];
                for (var i = 0; i < path.length; i++)
                    result.push($.extend({}, fields[i], {
                        groupIndex: null,
                        groupName: null,
                        filterType: "include",
                        filterValues: [path[i]]
                    }));
                return result
            }
            return {
                    ctor: function(options) {
                        options = $.extend(dataUtils.normalizeDataSourceOptions(options), {
                            paginate: false,
                            onChanged: null
                        });
                        this._dataSource = new DX.data.DataSource(options)
                    },
                    getFields: function(fieldsDataType) {
                        var that = this,
                            dataSource = that._dataSource,
                            d = $.Deferred();
                        loadDataSource(dataSource).done(function(data) {
                            d.resolve(discover(data, fieldsDataType))
                        }).fail(d.reject);
                        return d
                    },
                    key: function() {
                        return this._dataSource.key()
                    },
                    load: function(options) {
                        var that = this,
                            dataSource = that._dataSource,
                            d = $.Deferred();
                        loadDataSource(dataSource, options.reload).done(function(data) {
                            var parsedData = loadCore(data, options);
                            d.resolve(parsedData)
                        }).fail(d.reject);
                        return d
                    },
                    filter: function() {
                        var dataSource = this._dataSource;
                        return dataSource.filter.apply(dataSource, arguments)
                    },
                    supportSorting: function() {
                        return false
                    },
                    getDrillDownItems: function(loadOptions, params) {
                        loadOptions = loadOptions || {};
                        params = params || {};
                        prepareLoadOption(loadOptions);
                        var drillDownItems = [],
                            items = this._dataSource.items(),
                            item,
                            maxRowCount = params.maxRowCount,
                            customColumns = params.customColumns,
                            filter = createFilter(loadOptions),
                            pathFilter = createFilter({
                                rows: getFilterPathFields(loadOptions.rows, params.rowPath),
                                columns: getFilterPathFields(loadOptions.columns, params.columnPath),
                                filters: []
                            });
                        for (var i = 0; i < items.length; i++) {
                            if (pathFilter(items[i]) && filter(items[i])) {
                                if (customColumns) {
                                    item = {};
                                    for (var j = 0; j < customColumns.length; j++)
                                        item[customColumns[j]] = items[i][customColumns[j]]
                                }
                                else
                                    item = items[i];
                                drillDownItems.push(item)
                            }
                            if (maxRowCount > 0 && drillDownItems.length === maxRowCount)
                                break
                        }
                        return drillDownItems
                    }
                }
        }())
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.areaItem.js */
    (function($, DX) {
        var pivotGrid = DX.ui.dxPivotGrid,
            Class = DevExpress.require("/class"),
            commonUtils = DX.require("/utils/utils.common"),
            cssClassNames = pivotGrid.cssClassNames;
        var getRealElementWidth = function(element) {
                var width = 0,
                    clientRect;
                if (element.getBoundingClientRect) {
                    clientRect = element.getBoundingClientRect();
                    width = clientRect.width;
                    if (!width)
                        width = clientRect.right - clientRect.left
                }
                if (width > 0)
                    return width;
                else
                    return element.offsetWidth
            };
        function getFakeTableOffset(scrollPos, elementOffset, tableSize, viewPortSize) {
            var offset = 0,
                halfTableCount = 0,
                halfTableSize = tableSize / 2;
            if (scrollPos + viewPortSize - (elementOffset + tableSize) > 1) {
                if (scrollPos >= elementOffset + tableSize + halfTableSize)
                    halfTableCount = parseInt((scrollPos - (elementOffset + tableSize)) / halfTableSize, 10);
                offset = elementOffset + tableSize + halfTableSize * halfTableCount
            }
            else if (scrollPos < elementOffset) {
                if (scrollPos <= elementOffset - halfTableSize)
                    halfTableCount = parseInt((scrollPos - (elementOffset - halfTableSize)) / halfTableSize, 10);
                offset = elementOffset - (tableSize - halfTableSize * halfTableCount)
            }
            else
                offset = elementOffset;
            return offset
        }
        pivotGrid.getRealElementWidth = getRealElementWidth;
        pivotGrid.AreaItem = Class.inherit({
            _getRowElement: function(index) {
                var that = this;
                if (that._tableElement && that._tableElement.length > 0)
                    return that._tableElement[0].rows[index];
                return null
            },
            _createGroupElement: function() {
                return $('<div>')
            },
            _createTableElement: function() {
                return $('<table>')
            },
            _getCellText: function(cell, encodeHtml) {
                var cellText = cell.text || '';
                if (encodeHtml && (cellText.indexOf("<") !== -1 || cellText.indexOf(">") !== -1))
                    cellText = $("<div>").text(cellText).html();
                return cellText
            },
            _getRowClassNames: function(){},
            _applyCustomStyles: function(options) {
                if (options.cell.width)
                    options.cssArray.push("min-width:" + options.cell.width + "px")
            },
            _getMainElementMarkup: function() {
                return "<tbody>"
            },
            _getCloseMainElementMarkup: function() {
                return "</tbody>"
            },
            _renderTableContent: function(tableElement, data) {
                var that = this,
                    rowsCount = data.length,
                    row,
                    cell,
                    i,
                    j,
                    rowElement,
                    cellElement,
                    cellText,
                    rtlEnabled = that.option("rtlEnabled"),
                    markupArray = [],
                    encodeHtml = that.option("encodeHtml"),
                    rowClassNames,
                    colspan = "colspan='",
                    rowspan = "rowspan='";
                tableElement.data("area", that._getAreaName());
                tableElement.data("data", data);
                tableElement.width('auto');
                markupArray.push(that._getMainElementMarkup());
                for (i = 0; i < rowsCount; i++) {
                    row = data[i];
                    var columnMarkupArray = [];
                    rowClassNames = [];
                    markupArray.push("<tr ");
                    for (j = 0; j < row.length; j++) {
                        cell = row[j];
                        this._getRowClassNames(i, cell, rowClassNames);
                        columnMarkupArray.push("<td ");
                        if (cell) {
                            cell.rowspan && columnMarkupArray.push(rowspan + (cell.rowspan || 1) + "'");
                            cell.colspan && columnMarkupArray.push(colspan + (cell.colspan || 1) + "'");
                            var styleOptions = {
                                    cellElement: cellElement,
                                    cell: cell,
                                    cellsCount: row.length,
                                    cellIndex: j,
                                    rowElement: rowElement,
                                    rowIndex: i,
                                    rowsCount: rowsCount,
                                    rtlEnabled: rtlEnabled,
                                    classArray: [],
                                    cssArray: []
                                };
                            that._applyCustomStyles(styleOptions);
                            if (styleOptions.cssArray.length) {
                                columnMarkupArray.push("style='");
                                columnMarkupArray.push(styleOptions.cssArray.join(";"));
                                columnMarkupArray.push("'")
                            }
                            if (styleOptions.classArray.length) {
                                columnMarkupArray.push("class='");
                                columnMarkupArray.push(styleOptions.classArray.join(" "));
                                columnMarkupArray.push("'")
                            }
                            columnMarkupArray.push(">");
                            if (commonUtils.isDefined(cell.expanded))
                                columnMarkupArray.push("<span class='" + cssClassNames.headersExpandCollapseImage + "'></span>");
                            cellText = this._getCellText(cell, encodeHtml)
                        }
                        else
                            cellText = "";
                        columnMarkupArray.push("<span>" + cellText + "</span>");
                        if (cell && cell.sorted)
                            columnMarkupArray.push("<span class='dx-icon-sorted'></span>");
                        columnMarkupArray.push("</td>")
                    }
                    if (rowClassNames.length) {
                        markupArray.push("class='");
                        markupArray.push(rowClassNames.join(" "));
                        markupArray.push("'")
                    }
                    markupArray.push(">");
                    markupArray.push(columnMarkupArray.join(""));
                    markupArray.push("</tr>")
                }
                markupArray.push(this._getCloseMainElementMarkup());
                tableElement.append(markupArray.join(""));
                this._triggerOnCellPrepared(tableElement, data)
            },
            _triggerOnCellPrepared: function(tableElement, data) {
                var that = this,
                    rowElements = tableElement.find("tr"),
                    areaName = that._getAreaName(),
                    onCellPrepared = that.option("onCellPrepared"),
                    rowElement,
                    cellElement,
                    row,
                    cell,
                    rowIndex,
                    columnIndex;
                if (onCellPrepared)
                    for (rowIndex = 0; rowIndex < data.length; rowIndex++) {
                        row = data[rowIndex];
                        rowElement = rowElements.eq(rowIndex);
                        for (columnIndex = 0; columnIndex < row.length; columnIndex++) {
                            cell = row[columnIndex];
                            cellElement = rowElement.children().eq(columnIndex);
                            onCellPrepared({
                                area: areaName,
                                rowIndex: rowIndex,
                                columnIndex: columnIndex,
                                cellElement: cellElement,
                                cell: cell
                            })
                        }
                    }
            },
            _getRowHeight: function(index) {
                var row = this._getRowElement(index),
                    clientRect,
                    height = 0;
                if (row && row.lastChild) {
                    if (row.getBoundingClientRect) {
                        clientRect = row.getBoundingClientRect();
                        height = clientRect.height
                    }
                    if (height > 0)
                        return height;
                    else
                        return row.offsetHeight
                }
                return 0
            },
            _setRowHeight: function(index, value) {
                var row = this._getRowElement(index);
                if (row)
                    row.style.height = value + 'px'
            },
            ctor: function(component) {
                this.component = component
            },
            option: function() {
                return this.component.option.apply(this.component, arguments)
            },
            getRowsLength: function() {
                var that = this;
                if (that._tableElement && that._tableElement.length > 0)
                    return that._tableElement[0].rows.length;
                return 0
            },
            getRowsHeight: function() {
                var that = this,
                    result = [],
                    rowsLength = that.getRowsLength(),
                    i;
                for (i = 0; i < rowsLength; i++)
                    result.push(that._getRowHeight(i));
                return result
            },
            setRowsHeight: function(values) {
                var that = this,
                    totalHeight = 0,
                    valuesLength = values.length,
                    i;
                for (i = 0; i < valuesLength; i++) {
                    totalHeight += values[i];
                    that._setRowHeight(i, values[i])
                }
                this._tableHeight = totalHeight;
                this._tableElement[0].style.height = totalHeight + 'px'
            },
            getColumnsWidth: function() {
                var rowsLength = this.getRowsLength(),
                    rowIndex,
                    row,
                    i,
                    columnIndex,
                    processedCells = [],
                    result = [],
                    fillCells = function(cells, rowIndex, columnIndex, rowSpan, colSpan) {
                        var rowOffset,
                            columnOffset;
                        for (rowOffset = 0; rowOffset < rowSpan; rowOffset++)
                            for (columnOffset = 0; columnOffset < colSpan; columnOffset++) {
                                cells[rowIndex + rowOffset] = cells[rowIndex + rowOffset] || [];
                                cells[rowIndex + rowOffset][columnIndex + columnOffset] = true
                            }
                    };
                if (rowsLength)
                    for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
                        processedCells[rowIndex] = processedCells[rowIndex] || [];
                        row = this._getRowElement(rowIndex);
                        for (i = 0; i < row.cells.length; i++) {
                            for (columnIndex = 0; processedCells[rowIndex][columnIndex]; columnIndex++);;
                            fillCells(processedCells, rowIndex, columnIndex, row.cells[i].rowSpan, row.cells[i].colSpan);
                            if (row.cells[i].colSpan === 1)
                                result[columnIndex] = result[columnIndex] || getRealElementWidth(row.cells[i])
                        }
                    }
                return result
            },
            setColumnsWidth: function(values) {
                var i,
                    totalWidth = 0,
                    tableElement = this._tableElement[0],
                    colgroupElementHTML = '';
                for (i = 0; i < values.length; i++) {
                    totalWidth += values[i];
                    colgroupElementHTML += '<col style="width: ' + values[i] + 'px"/>'
                }
                this._colgroupElement.html(colgroupElementHTML);
                this._tableWidth = totalWidth;
                tableElement.style.width = totalWidth + 'px';
                tableElement.style.tableLayout = 'fixed'
            },
            resetColumnsWidth: function() {
                this._colgroupElement.find('col').width('auto');
                this._tableElement.css({
                    width: '',
                    tableLayout: ''
                })
            },
            groupWidth: function(value) {
                if (value === undefined)
                    return this._groupElement.width();
                else if (value >= 0) {
                    this._groupWidth = value;
                    return this._groupElement[0].style.width = value + 'px'
                }
                else
                    return this._groupElement[0].style.width = value
            },
            groupHeight: function(value) {
                if (value === undefined)
                    return this._groupElement.height();
                else if (value >= 0) {
                    this._groupHeight = value;
                    this._groupElement[0].style.height = value + 'px'
                }
                else
                    this._groupElement[0].style.height = value
            },
            groupElement: function() {
                return this._groupElement
            },
            tableElement: function() {
                return this._tableElement
            },
            element: function() {
                return this._rootElement
            },
            headElement: function() {
                return this._tableElement.find('thead')
            },
            setVirtualContentParams: function(params) {
                this._virtualContent.css({
                    width: params.width,
                    height: params.height
                });
                this.groupElement().addClass("dx-virtual-mode")
            },
            disableVirtualMode: function() {
                this.groupElement().removeClass("dx-virtual-mode")
            },
            _renderVirtualContent: function() {
                var that = this;
                if (!that._virtualContent && that.option("scrolling.mode") === "virtual")
                    that._virtualContent = $("<div>").addClass("dx-virtual-content").insertBefore(that._tableElement)
            },
            reset: function() {
                var that = this,
                    tableElement = that._tableElement[0];
                that._fakeTable && that._fakeTable.detach();
                that._fakeTable = null;
                that.disableVirtualMode();
                that.groupWidth("100%");
                that.groupHeight("auto");
                that.resetColumnsWidth();
                if (tableElement) {
                    for (var i = 0; i < tableElement.rows.length; i++)
                        tableElement.rows[i].style.height = "";
                    tableElement.style.height = "";
                    tableElement.style.width = "100%"
                }
            },
            _updateFakeTableVisibility: function() {
                var that = this,
                    tableElement = that.tableElement()[0],
                    fakeTableElement = that._fakeTable[0];
                if (tableElement.style.top === fakeTableElement.style.top && fakeTableElement.style.left === tableElement.style.left)
                    that._fakeTable.addClass("dx-hidden");
                else
                    that._fakeTable.removeClass("dx-hidden")
            },
            _moveFakeTableLeft: function(scrollPos) {
                var that = this,
                    tableElementOffsetLeft = parseFloat(that.tableElement()[0].style.left),
                    offsetLeft = getFakeTableOffset(scrollPos, tableElementOffsetLeft, that._tableWidth, that._groupWidth);
                if (parseFloat(that._fakeTable[0].style.left) !== offsetLeft)
                    that._fakeTable[0].style.left = offsetLeft + "px"
            },
            _moveFakeTableTop: function(scrollPos) {
                var that = this,
                    tableElementOffsetTop = parseFloat(that.tableElement()[0].style.top),
                    offsetTop = getFakeTableOffset(scrollPos, tableElementOffsetTop, that._tableHeight, that._groupHeight);
                if (parseFloat(that._fakeTable[0].style.top) !== offsetTop)
                    that._fakeTable[0].style.top = offsetTop + "px"
            },
            _moveFakeTable: function(scrollPos) {
                this._updateFakeTableVisibility()
            },
            _createFakeTable: function(scrollPos) {
                var that = this;
                if (!that._fakeTable)
                    that._fakeTable = that.tableElement().clone().addClass("dx-pivot-grid-fake-table").appendTo(that._virtualContent)
            },
            render: function(rootElement, data) {
                var that = this,
                    tableElement = that._createTableElement();
                if (commonUtils.isDefined(that._tableElement)) {
                    try {
                        that._tableElement[0].innerHTML = ''
                    }
                    catch(e) {
                        that._tableElement.empty()
                    }
                    that._tableElement.attr('style', '');
                    that._colgroupElement = $('<colgroup>').appendTo(that._tableElement);
                    that._renderTableContent(that._tableElement, data)
                }
                else {
                    that._groupElement = that._createGroupElement();
                    that._tableElement = tableElement;
                    that._colgroupElement = $('<colgroup>').appendTo(that._tableElement);
                    that._tableElement.appendTo(that._groupElement);
                    that._groupElement.appendTo(rootElement);
                    that._rootElement = rootElement;
                    that._renderTableContent(that._tableElement, data)
                }
                that._renderVirtualContent()
            },
            _getScrollable: function() {
                return this.groupElement().data('dxScrollable')
            },
            on: function(eventName, handler) {
                var scrollable = this._getScrollable();
                if (scrollable)
                    scrollable.on(eventName, handler);
                return this
            },
            off: function() {
                var scrollable = this._getScrollable();
                if (scrollable)
                    scrollable.off.apply(scrollable, arguments);
                return this
            },
            scrollTo: function(pos) {
                var scrollable = this._getScrollable();
                if (scrollable) {
                    scrollable.scrollTo(pos);
                    scrollable.update();
                    if (this._virtualContent) {
                        this._createFakeTable();
                        this._moveFakeTable(pos)
                    }
                }
            },
            updateScrollable: function() {
                var scrollable = this._getScrollable();
                if (scrollable)
                    scrollable.update()
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.headersArea.js */
    (function($, DX) {
        var ui = DX.ui,
            pivotGrid = ui.dxPivotGrid,
            commonUtils = DX.require("/utils/utils.common"),
            cssClassNames = pivotGrid.cssClassNames;
        function getCellPath(tableElement, cell) {
            if (cell) {
                var data = tableElement.data().data,
                    rowIndex = cell.parentNode.rowIndex,
                    cellIndex = cell.cellIndex;
                return data[rowIndex] && data[rowIndex][cellIndex] && data[rowIndex][cellIndex].path
            }
        }
        pivotGrid.HorizontalHeadersArea = pivotGrid.AreaItem.inherit({
            _getAreaName: function() {
                return "column"
            },
            _getAreaClassName: function() {
                return cssClassNames.headersHorizontal
            },
            _createGroupElement: function() {
                return $('<div>').addClass(this._getAreaClassName()).addClass(cssClassNames.area)
            },
            _applyCustomStyles: function(options) {
                var cssArray = options.cssArray,
                    cell = options.cell,
                    rowsCount = options.rowsCount,
                    classArray = options.classArray;
                if (options.cellIndex === options.cellsCount - 1)
                    cssArray.push((options.rtlEnabled ? 'border-left:' : 'border-right:') + "0px");
                if (cell.rowspan === rowsCount - options.rowIndex || options.rowIndex + 1 === rowsCount)
                    cssArray.push('border-bottom-width:0px');
                if (cell.type === 'T' || cell.type === 'GT')
                    classArray.push(cssClassNames.rowTotal);
                if (options.cell.type === 'T')
                    classArray.push(cssClassNames.total);
                if (options.cell.type === 'GT')
                    classArray.push(cssClassNames.grandTotal);
                if (commonUtils.isDefined(cell.expanded))
                    classArray.push(cell.expanded ? cssClassNames.headersExpanded : cssClassNames.headersCollapsed);
                this.callBase(options)
            },
            _getMainElementMarkup: function() {
                return "<thead class='" + this._getAreaClassName() + "'>"
            },
            _getCloseMainElementMarkup: function() {
                return "</thead>"
            },
            setVirtualContentParams: function(params) {
                this.callBase(params);
                this.tableElement().css({
                    left: params.left,
                    top: 0
                });
                this._virtualContentWidth = params.width
            },
            hasScroll: function() {
                var tableWidth = this._virtualContent ? this._virtualContentWidth : this._tableWidth;
                if (this._groupWidth && tableWidth)
                    return tableWidth - this._groupWidth >= 1;
                return false
            },
            processScroll: function() {
                if (!this._getScrollable())
                    this._groupElement.dxScrollable({
                        useNative: false,
                        useSimulatedScrollbar: false,
                        showScrollbar: false,
                        bounceEnabled: false,
                        direction: "horizontal"
                    })
            },
            processScrollBarSpacing: function(scrollBarWidth) {
                var that = this;
                if (that._groupWidth)
                    that.groupWidth(that._groupWidth - scrollBarWidth);
                if (that._scrollBarWidth)
                    that._groupElement.next().remove();
                that._groupElement.toggleClass(cssClassNames.verticalScroll, scrollBarWidth > 0);
                that._groupElement.css('float', 'left').width(that._groupHeight);
                that._scrollBarWidth = scrollBarWidth
            },
            ctor: function(component) {
                this.callBase(component);
                this._scrollBarWidth = 0
            },
            getScrollPath: function(offset) {
                var tableElement = this.tableElement(),
                    cell;
                offset -= parseInt(tableElement[0].style.left, 10) || 0;
                $.each(tableElement.find("td"), function(_, td) {
                    if (td.colSpan === 1 && td.offsetLeft < offset && td.offsetWidth + td.offsetLeft > offset) {
                        cell = td;
                        return false
                    }
                });
                return getCellPath(tableElement, cell)
            },
            _moveFakeTable: function(scrollPos) {
                this._moveFakeTableLeft(scrollPos);
                this.callBase()
            }
        });
        pivotGrid.VerticalHeadersArea = pivotGrid.HorizontalHeadersArea.inherit({
            _getAreaClassName: function() {
                return cssClassNames.headersVertical
            },
            _applyCustomStyles: function(options) {
                this.callBase(options);
                if (options.cellIndex === options.cellsCount - 1)
                    options.classArray.push(cssClassNames.headersVerticalLastCell);
                if (options.rowIndex === options.rowsCount - 1)
                    options.cssArray.push('border-bottom: 0px')
            },
            _getAreaName: function() {
                return "row"
            },
            setVirtualContentParams: function(params) {
                this.callBase(params);
                this.tableElement().css({
                    top: params.top,
                    left: 0
                });
                this._virtualContentHeight = params.height
            },
            hasScroll: function() {
                var tableHeight = this._virtualContent ? this._virtualContentHeight : this._tableHeight;
                if (this._groupHeight && tableHeight)
                    return tableHeight - this._groupHeight >= 1;
                return false
            },
            processScroll: function() {
                if (!this._getScrollable())
                    this._groupElement.dxScrollable({
                        useNative: false,
                        useSimulatedScrollbar: false,
                        showScrollbar: false,
                        bounceEnabled: false,
                        direction: "vertical"
                    })
            },
            processScrollBarSpacing: function(scrollBarWidth) {
                var that = this;
                if (that._groupHeight)
                    that.groupHeight(that._groupHeight - scrollBarWidth);
                if (that._scrollBarWidth)
                    that._groupElement.next().remove();
                if (scrollBarWidth)
                    that._groupElement.after($('<div>').width('100%').height(scrollBarWidth - 1));
                that._scrollBarWidth = scrollBarWidth
            },
            getScrollPath: function(offset) {
                var tableElement = this.tableElement(),
                    cell;
                offset -= parseInt(tableElement[0].style.top, 10) || 0;
                $.each(tableElement.find("tr"), function(_, tr) {
                    var td = tr.childNodes[tr.childNodes.length - 1];
                    if (td && td.rowSpan === 1 && td.offsetTop < offset && td.offsetHeight + td.offsetTop > offset) {
                        cell = td;
                        return false
                    }
                });
                return getCellPath(tableElement, cell)
            },
            _moveFakeTable: function(scrollPos) {
                this._moveFakeTableTop(scrollPos);
                this.callBase()
            },
            _getRowClassNames: function(rowIndex, cell, rowClassNames) {
                if (rowIndex !== 0 & cell.expanded && $.inArray(cssClassNames.headersVerticalExpandBorder, rowClassNames) === -1)
                    rowClassNames.push(cssClassNames.headersVerticalExpandBorder)
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.dataArea.js */
    (function($, DX) {
        var pivotGrid = DX.ui.dxPivotGrid,
            cssClassNames = pivotGrid.cssClassNames;
        pivotGrid.DataArea = pivotGrid.AreaItem.inherit({
            _getAreaName: function() {
                return "data"
            },
            _createGroupElement: function() {
                return $('<div>').addClass(cssClassNames.area).addClass(cssClassNames.areaData)
            },
            _applyCustomStyles: function(options) {
                var cell = options.cell,
                    classArray = options.classArray;
                if (cell.rowType === 'T' || cell.columnType === 'T')
                    classArray.push(cssClassNames.total);
                if (cell.rowType === 'GT' || cell.columnType === 'GT')
                    classArray.push(cssClassNames.grandTotal);
                if (cell.rowType === 'T' || cell.rowType === 'GT')
                    classArray.push(cssClassNames.rowTotal);
                if (options.rowIndex === options.rowsCount - 1)
                    options.cssArray.push('border-bottom: 0px');
                this.callBase(options)
            },
            _moveFakeTable: function(scrollPos) {
                this._moveFakeTableLeft(scrollPos.x);
                this._moveFakeTableTop(scrollPos.y);
                this.callBase()
            },
            processScroll: function(useNativeScrolling) {
                this._groupElement.css('border-top-width', 0).dxScrollable({
                    useNative: !!useNativeScrolling,
                    useSimulatedScrollbar: !useNativeScrolling,
                    direction: "both",
                    bounceEnabled: false
                })
            },
            setVirtualContentParams: function(params) {
                this.callBase(params);
                this._virtualContent.parent().height(params.height);
                this.tableElement().css({
                    top: params.top,
                    left: params.left
                })
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.fieldChooser.js */
    (function($, DX) {
        var ui = DX.ui,
            iconUtils = DX.require("/utils/utils.icon"),
            commonUtils = DX.require("/utils/utils.common"),
            registerComponent = DX.require("/componentRegistrator"),
            Widget = DX.require("/ui/ui.widget"),
            pivotGrid = ui.dxPivotGrid,
            dataGrid = ui.dxDataGrid,
            inArray = $.inArray,
            each = $.each,
            DIV = "<div>";
        var ColumnsView = dataGrid.ColumnsView.inherit(dataGrid.sortingMixin).inherit(dataGrid.headerFilterMixin);
        var HeaderFilterView = dataGrid.HeaderFilterView;
        var FIELDCHOOSER_CLASS = "dx-pivotgridfieldchooser",
            FIELDCHOOSER_CONTAINER_CLASS = "dx-pivotgridfieldchooser-container";
        var processItems = function(groupItems, field) {
                var filterValues = [],
                    isTree = !!field.groupName,
                    isExcludeFilterType = field.filterType === "exclude";
                if (field.filterValues)
                    each(field.filterValues, function(_, filterValue) {
                        filterValues.push(commonUtils.isArray(filterValue) ? filterValue.join("/") : filterValue)
                    });
                pivotGrid.foreachTree(groupItems, function(items) {
                    var item = items[0],
                        path = pivotGrid.createPath(items),
                        preparedFilterValueByText = isTree ? $.map(items, function(item) {
                            return item.text
                        }).reverse().join("/") : item.text,
                        preparedFilterValue;
                    item.value = isTree ? path.slice(0) : item.key || item.value;
                    preparedFilterValue = isTree ? path.join("/") : item.value;
                    if (item.children) {
                        item.items = item.children;
                        item.children = null
                    }
                    dataGrid.updateHeaderFilterItemSelectionState(item, item.key && inArray(preparedFilterValueByText, filterValues) > -1 || inArray(preparedFilterValue, filterValues) > -1, isExcludeFilterType)
                })
            };
        function getDimensionFields(item, fields) {
            var result = [];
            if (item.items)
                for (var i = 0; i < item.items.length; i++)
                    result.push.apply(result, getDimensionFields(item.items[i], fields));
            else if (commonUtils.isDefined(item.index))
                result.push(fields[item.index]);
            return result
        }
        function getFirstItem(item, condition) {
            if (item.items)
                for (var i = 0; i < item.items.length; i++) {
                    var childrenItem = getFirstItem(item.items[i], condition);
                    if (childrenItem)
                        return childrenItem
                }
            if (condition(item))
                return item
        }
        var compareOrder = [function(a, b) {
                    var aValue = -!!a.isMeasure,
                        bValue = +!!b.isMeasure;
                    return aValue + bValue
                }, function(a, b) {
                    var aValue = -!!(a.items && a.items.length),
                        bValue = +!!(b.items && b.items.length);
                    return aValue + bValue
                }, function(a, b) {
                    var aValue = +!!(a.field && a.field.levels && a.field.levels.length),
                        bValue = -!!(b.field && b.field.levels && b.field.levels.length);
                    return aValue + bValue
                }, pivotGrid.getCompareFunction(function(item) {
                    return item.text
                })];
        function compareItems(a, b) {
            var result = 0,
                i = 0;
            while (!result && compareOrder[i])
                result = compareOrder[i++](a, b);
            return result
        }
        function getScrollable(container) {
            return container.find(".dx-scrollable").dxScrollable("instance")
        }
        registerComponent("dxPivotGridFieldChooser", ui, Widget.inherit({
            _getDefaultOptions: function() {
                return $.extend(this.callBase(), {
                        height: 400,
                        layout: 0,
                        dataSource: null,
                        texts: {
                            columnFields: Globalize.localize("dxPivotGrid-columnFields"),
                            rowFields: Globalize.localize("dxPivotGrid-rowFields"),
                            dataFields: Globalize.localize("dxPivotGrid-dataFields"),
                            filterFields: Globalize.localize("dxPivotGrid-filterFields"),
                            allFields: Globalize.localize("dxPivotGrid-allFields")
                        },
                        headerFilter: {
                            width: 252,
                            height: 300,
                            texts: {
                                emptyValue: Globalize.localize("dxDataGrid-headerFilterEmptyValue"),
                                ok: Globalize.localize("dxDataGrid-headerFilterOK"),
                                cancel: Globalize.localize("dxDataGrid-headerFilterCancel")
                            }
                        }
                    })
            },
            _refreshDataSource: function() {
                var that = this;
                that._expandedPaths = [];
                that._changedHandler = that._changedHandler || function() {
                    each(that._dataChangedHandlers, function(_, func) {
                        func()
                    })
                };
                if (that._dataSource) {
                    that._dataSource.off("changed", that._changedHandler);
                    that._dataSource = undefined
                }
                var dataSource = this.option("dataSource");
                if (dataSource && dataSource.fields && dataSource.load)
                    that._dataSource = dataSource;
                that._dataSource && that._dataSource.on("changed", that._changedHandler)
            },
            _init: function() {
                this.callBase();
                this._columnsView = new ColumnsView(this);
                this._headerFilterView = new HeaderFilterView(this);
                this._subscribeToEvents();
                this._refreshDataSource();
                this._dataChangedHandlers = []
            },
            _subscribeToEvents: function() {
                var that = this;
                that.element().on("dxclick", ".dx-area-field.dx-area-box", function(e) {
                    var field = $.extend(true, {}, $(e.currentTarget).data("field")),
                        isHeaderFilter = $(e.target).hasClass("dx-header-filter");
                    if (isHeaderFilter)
                        that._headerFilterView.showHeaderFilterMenu($(e.currentTarget), $.extend(field, {
                            type: field.groupName ? 'tree' : 'list',
                            dataSource: {
                                load: function(options) {
                                    var userData = options.userData;
                                    if (userData.store)
                                        return userData.store.load(options);
                                    else {
                                        var d = $.Deferred();
                                        that._dataSource.getFieldValues(field.index).done(function(data) {
                                            userData.store = new DX.data.ArrayStore(data);
                                            userData.store.load(options).done(d.resolve).fail(d.reject)
                                        }).fail(d.reject);
                                        return d
                                    }
                                },
                                postProcess: function(data) {
                                    processItems(data, field);
                                    return data
                                }
                            },
                            apply: function() {
                                that._dataSource.field(field.index, {
                                    filterValues: this.filterValues,
                                    filterType: this.filterType
                                });
                                that._dataSource.load()
                            }
                        }));
                    else if (field.allowSorting && field.area !== "data") {
                        that._dataSource.field(field.index, {sortOrder: field.sortOrder === "desc" ? "asc" : "desc"});
                        that._dataSource.load()
                    }
                })
            },
            _setOptionsByReference: function() {
                this.callBase();
                $.extend(this._optionsByReference, {dataSource: true})
            },
            _optionChanged: function(args) {
                var that = this;
                switch (args.name) {
                    case"dataSource":
                        that._refreshDataSource();
                        that._invalidate();
                        break;
                    case"layout":
                    case"texts":
                    case"headerFilter":
                        that._invalidate();
                        break;
                    default:
                        that.callBase(args)
                }
            },
            _clean: function() {
                this.element().children("." + FIELDCHOOSER_CONTAINER_CLASS).remove()
            },
            _renderContentImpl: function() {
                var that = this,
                    element = this.element(),
                    $col1,
                    $col2;
                element.addClass(FIELDCHOOSER_CLASS);
                that._dataChangedHandlers = [];
                that._renderSortable(element);
                that._headerFilterView.render(element);
                var $container = $(DIV).addClass(FIELDCHOOSER_CONTAINER_CLASS).appendTo(element);
                if (this.option("layout") === 0) {
                    $col1 = $(DIV).addClass("dx-col").appendTo($container);
                    $col2 = $(DIV).addClass("dx-col").appendTo($container);
                    this._renderArea($col1, "all");
                    this._renderArea($col1, "filter");
                    this._renderArea($col2, "row");
                    this._renderArea($col2, "column");
                    this._renderArea($col2, "data")
                }
                else if (this.option("layout") === 1) {
                    $col1 = $(DIV).addClass("dx-col").appendTo($container);
                    $col2 = $(DIV).addClass("dx-col").appendTo($container);
                    this._renderArea($col1, "all");
                    this._renderArea($col2, "filter");
                    this._renderArea($col2, "row");
                    this._renderArea($col2, "column");
                    this._renderArea($col2, "data")
                }
                else {
                    this._renderArea($container, "all");
                    $col1 = $(DIV).addClass("dx-col").appendTo($container);
                    $col2 = $(DIV).addClass("dx-col").appendTo($container);
                    this._renderArea($col1, "filter");
                    this._renderArea($col1, "row");
                    this._renderArea($col2, "column");
                    this._renderArea($col2, "data")
                }
                this.updateDimensions()
            },
            _renderSortable: function(element) {
                var that = this;
                that._createComponent(element, "dxSortable", {
                    itemSelector: ".dx-area-field",
                    itemContainerSelector: ".dx-area-field-container",
                    groupSelector: ".dx-area-fields",
                    itemRender: function($sourceItem, target) {
                        var $item;
                        if ($sourceItem.hasClass("dx-area-box")) {
                            $item = $sourceItem.clone();
                            $item.insertBefore($sourceItem)
                        }
                        else
                            $item = $(DIV).addClass("dx-area-field").addClass("dx-area-box").text($sourceItem.text());
                        if (target === "drag")
                            $item.width(element.find(".dx-area-field-container").first().width());
                        return $item
                    },
                    onDragging: function(e) {
                        var field = e.sourceElement.data("field"),
                            targetGroup = e.targetGroup;
                        e.cancel = false;
                        if (field.isMeasure === true) {
                            if (targetGroup === "column" || targetGroup === "row" || targetGroup === "filter")
                                e.cancel = true
                        }
                        else if (field.isMeasure === false && targetGroup === "data")
                            e.cancel = true
                    },
                    onChanged: function(e) {
                        var dataSource = that._dataSource,
                            field = e.sourceElement.data("field");
                        e.removeSourceElement = !!e.sourceGroup;
                        if (field) {
                            dataSource.field(field.index, {
                                area: e.targetGroup,
                                areaIndex: e.targetIndex
                            });
                            dataSource.load()
                        }
                    }
                })
            },
            _createTreeItems: function(fields, groupFieldNames, path) {
                var that = this,
                    isMeasure,
                    resultItems = [],
                    groupedItems = [],
                    groupFieldName = groupFieldNames[0],
                    fieldsByGroup = {};
                if (!groupFieldName)
                    each(fields, function(index, field) {
                        var icon;
                        if (field.isMeasure === true)
                            icon = "measure";
                        if (field.isMeasure === false)
                            icon = field.groupName ? "hierarchy" : "dimension";
                        resultItems.push({
                            index: field.index,
                            field: field,
                            key: field.dataField,
                            selected: commonUtils.isDefined(field.area),
                            text: field.caption || field.dataField,
                            icon: icon,
                            isMeasure: field.isMeasure,
                            isDefault: field.isDefault
                        })
                    });
                else {
                    each(fields, function(index, field) {
                        var groupName = field[groupFieldName] || "";
                        fieldsByGroup[groupName] = fieldsByGroup[groupName] || [];
                        fieldsByGroup[groupName].push(field);
                        if (isMeasure === undefined)
                            isMeasure = true;
                        isMeasure = isMeasure && field.isMeasure === true
                    });
                    each(fieldsByGroup, function(groupName, fields) {
                        var currentPath = path ? path + '.' + groupName : groupName;
                        var items = that._createTreeItems(fields, groupFieldNames.slice(1), currentPath);
                        if (groupName)
                            groupedItems.push({
                                key: groupName,
                                text: groupName,
                                path: currentPath,
                                isMeasure: items.isMeasure,
                                expanded: inArray(currentPath, that._expandedPaths) >= 0,
                                items: items
                            });
                        else
                            resultItems = items
                    });
                    resultItems = groupedItems.concat(resultItems);
                    resultItems.isMeasure = isMeasure
                }
                return resultItems
            },
            _createFieldsDataSource: function(dataSource) {
                var fields = dataSource && dataSource.fields() || [],
                    treeItems;
                fields = $.map(fields, function(field) {
                    return field.visible === false || commonUtils.isDefined(field.groupIndex) ? null : field
                });
                treeItems = this._createTreeItems(fields, ["dimension", "displayFolder"]);
                pivotGrid.foreachDataLevel(treeItems, function(items) {
                    items.sort(compareItems)
                }, 0, "items");
                return treeItems
            },
            _renderFieldsTreeView: function(container) {
                var that = this,
                    dataSource = that._dataSource,
                    treeView = that._createComponent(container, "dxTreeView", {
                        dataSource: that._createFieldsDataSource(dataSource),
                        showCheckBoxesMode: 'normal',
                        itemTemplate: function(itemData, itemIndex, itemElement) {
                            if (itemData.icon)
                                iconUtils.getImageContainer(itemData.icon).appendTo(itemElement);
                            $('<span>').toggleClass("dx-area-field", !itemData.items).data("field", itemData.field).text(itemData.text).appendTo(itemElement)
                        },
                        onItemCollapsed: function(e) {
                            var index = inArray(e.itemData.path, that._expandedPaths);
                            if (index >= 0)
                                that._expandedPaths.splice(index, 1)
                        },
                        onItemExpanded: function(e) {
                            var index = inArray(e.itemData.path, that._expandedPaths);
                            if (index < 0)
                                that._expandedPaths.push(e.itemData.path)
                        },
                        onItemSelected: function(e) {
                            var data = e.itemData,
                                field,
                                fields,
                                needSelectDefaultItem = true,
                                area;
                            if (data.items) {
                                if (data.selected) {
                                    treeView.unselectItem(data);
                                    return
                                }
                                fields = getDimensionFields(data, dataSource.fields());
                                for (var i = 0; i < fields.length; i++)
                                    if (fields[i].area) {
                                        needSelectDefaultItem = false;
                                        break
                                    }
                                if (needSelectDefaultItem) {
                                    var item = getFirstItem(data, function(item) {
                                            return item.isDefault
                                        }) || getFirstItem(data, function(item) {
                                            return commonUtils.isDefined(item.index)
                                        });
                                    item && treeView.selectItem(item);
                                    return
                                }
                            }
                            else {
                                field = dataSource.fields()[data.index];
                                if (data.selected)
                                    area = field.isMeasure ? "data" : "column";
                                if (field)
                                    fields = [field]
                            }
                            each(fields, function(_, field) {
                                dataSource.field(field.index, {
                                    area: area,
                                    areaIndex: undefined
                                })
                            });
                            dataSource.load()
                        }
                    }),
                    dataChanged = function() {
                        var scrollable = getScrollable(container),
                            scrollTop = scrollable ? scrollable.scrollTop() : 0;
                        treeView.option({dataSource: that._createFieldsDataSource(dataSource)});
                        scrollable = getScrollable(container);
                        if (scrollable) {
                            scrollable.scrollTo({y: scrollTop});
                            scrollable.update()
                        }
                    };
                that._dataChangedHandlers.push(dataChanged)
            },
            _renderField: function(field) {
                var that = this,
                    $fieldContent = $(DIV).addClass("dx-area-field-content").text(field.caption || field.dataField),
                    $fieldElement = $(DIV).addClass("dx-area-field").addClass("dx-area-box").data("field", field).append($fieldContent);
                if (field.area !== "data") {
                    if (field.allowSorting)
                        that._columnsView._applyColumnState({
                            name: 'sort',
                            rootElement: $fieldElement,
                            column: {
                                alignment: that.option("rtlEnabled") ? 'right' : 'left',
                                sortOrder: field.sortOrder === 'desc' ? 'desc' : 'asc'
                            },
                            showColumnLines: true
                        });
                    that._columnsView._applyColumnState({
                        name: 'headerFilter',
                        rootElement: $fieldElement,
                        column: {
                            alignment: that.option("rtlEnabled") ? 'right' : 'left',
                            filterValues: field.filterValues,
                            allowFiltering: field.allowFiltering
                        },
                        showColumnLines: true
                    })
                }
                return $fieldElement
            },
            _renderAreaFields: function($container, area) {
                var that = this,
                    dataSource = that._dataSource,
                    fields = dataSource ? dataSource.getAreaFields(area, true) : [];
                $container.empty();
                each(fields, function() {
                    that._renderField(this).appendTo($container)
                })
            },
            _renderArea: function(container, area) {
                var that = this,
                    $areaContainer = $(DIV).addClass("dx-area").appendTo(container),
                    caption = that.option("texts." + area + "Fields"),
                    $fieldsContainer,
                    $fieldsContent,
                    render;
                $("<span>").addClass("dx-area-icon").addClass("dx-area-icon-" + area).appendTo($areaContainer);
                $("<span>").html("&nbsp;").appendTo($areaContainer);
                $("<span>").addClass("dx-area-caption").text(caption).appendTo($areaContainer);
                $fieldsContainer = $(DIV).addClass("dx-area-fields").height(0).appendTo($areaContainer);
                if (area !== "all") {
                    $fieldsContent = $(DIV).addClass("dx-area-field-container").appendTo($fieldsContainer);
                    render = function() {
                        that._renderAreaFields($fieldsContent, area)
                    };
                    that._dataChangedHandlers.push(render);
                    render();
                    $fieldsContainer.attr("group", area).dxScrollable()
                }
                else {
                    $fieldsContainer.addClass("dx-treeview-border-visible");
                    that._renderFieldsTreeView($fieldsContainer)
                }
            },
            updateDimensions: function() {
                var $element = this.element(),
                    $container = $element.children(".dx-pivotgridfieldchooser-container"),
                    $cols = $element.find(".dx-col"),
                    $areaElements = $element.find(".dx-area-fields"),
                    $scrollableElements = $element.find(".dx-area .dx-scrollable"),
                    areaHeight;
                $areaElements.height(0);
                if (this.option("layout") === 0) {
                    areaHeight = Math.floor(($element.height() - $container.height()) / 3);
                    $areaElements.height(areaHeight);
                    $areaElements.eq(0).height($cols.eq(1).height() - $cols.eq(0).height() + areaHeight)
                }
                else if (this.option("layout") === 1) {
                    areaHeight = Math.floor(($element.height() - $container.height()) / 4);
                    $areaElements.height(areaHeight);
                    $areaElements.eq(0).height($cols.eq(1).height() - $cols.eq(0).height() + areaHeight)
                }
                else {
                    areaHeight = Math.floor(($element.height() - $container.height()) / 4);
                    $areaElements.height(areaHeight);
                    $areaElements.eq(0).height(areaHeight * 2)
                }
                $scrollableElements.dxScrollable("update")
            },
            _visibilityChanged: function(visible) {
                if (visible)
                    this.updateDimensions()
            }
        }))
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.export.js */
    (function($, DX) {
        var ui = DX.ui,
            Class = DevExpress.require("/class"),
            utils = DevExpress.require("/utils/utils.common"),
            formatHelper = DX.require("/utils/utils.formatHelper"),
            pivotGrid = DX.ui.dxPivotGrid,
            emptyCell = {
                text: '',
                value: undefined,
                colspan: 1,
                rowspan: 1
            },
            DEFAULT_DATA_TYPE = "string";
        pivotGrid.include({
            exportToExcel: function() {
                this._clientExporter && this._clientExporter.exportTo({
                    fileName: this.option("export.fileName"),
                    proxyUrl: this.option("export.proxyUrl"),
                    format: "EXCEL",
                    component: this
                })
            },
            _getLength: function(items) {
                var cellIndex,
                    cellCount = 0;
                for (cellIndex in items[0])
                    cellCount += items[0][cellIndex].colspan ? items[0][cellIndex].colspan : 1;
                return cellCount
            },
            _defaultSetter: function(value) {
                value = parseInt(value, 10);
                return !value ? 1 : value
            },
            _makeRowOffset: function(resultItems) {
                var offset = 0,
                    rowIndex = resultItems.length - 1,
                    row = resultItems[rowIndex],
                    cellIndex = row.length;
                $.each(resultItems, function(rowIndex) {
                    if (this[cellIndex] && this[cellIndex].rowspan + rowIndex > resultItems.length - 1)
                        offset = Math.max.apply(this, [this[cellIndex].colspan, offset])
                });
                for (var i = 0; i < offset; i++)
                    row.push(this._cloneItem(resultItems[resultItems.length - 2][cellIndex && cellIndex - 1 || 0]));
                if (offset > 0)
                    this._makeRowOffset(resultItems)
            },
            _cloneItem: function(item) {
                return $.extend({}, item, emptyCell)
            },
            _prepareItems: function(cols, items) {
                var i,
                    row,
                    cellIndex,
                    rowIndex,
                    resultItems = [];
                for (rowIndex in items) {
                    row = [];
                    resultItems.push(row);
                    do {
                        this._makeRowOffset(resultItems);
                        cellIndex = row.length;
                        row.push(items[rowIndex].shift());
                        if (row[row.length - 1]) {
                            row[row.length - 1].colspan = this._defaultSetter(row[row.length - 1].colspan);
                            row[row.length - 1].rowspan = this._defaultSetter(row[row.length - 1].rowspan)
                        }
                        else
                            row[row.length - 1] = $({}, emptyCell);
                        for (i = 1; i < row[cellIndex].colspan; i++)
                            row.push(this._cloneItem(row[row.length - 1]))
                    } while (items[rowIndex].length);
                    while (row.length < cols)
                        row.push(this._cloneItem(row[row.length - 1]))
                }
                return resultItems
            },
            _getAllItems: function(columnsInfo, rowsInfoItems, cellsInfo) {
                var cellIndex,
                    rowIndex,
                    sourceItems = columnsInfo.concat(cellsInfo),
                    rowsLength = this._getLength(rowsInfoItems),
                    colsLength = this._getLength(columnsInfo),
                    headerRowsCount = columnsInfo.length;
                for (rowIndex = 0; rowIndex < rowsInfoItems.length; rowIndex++)
                    for (cellIndex = rowsInfoItems[rowIndex].length - 1; cellIndex >= 0; cellIndex--) {
                        if (!utils.isDefined(sourceItems[rowIndex + headerRowsCount]))
                            sourceItems[rowIndex + headerRowsCount] = [];
                        sourceItems[rowIndex + headerRowsCount].splice(0, 0, $.extend({}, rowsInfoItems[rowIndex][cellIndex]))
                    }
                sourceItems[0].splice(0, 0, $.extend({}, emptyCell, {
                    alignment: this._options.rtlEnabled ? "right" : "left",
                    colspan: rowsLength,
                    rowspan: headerRowsCount
                }));
                return this._prepareItems(rowsLength + colsLength, sourceItems)
            },
            getDataProvider: function() {
                var that = this,
                    dataController = this._dataController,
                    items = $.Deferred();
                dataController.beginLoading();
                setTimeout(function() {
                    var columnsInfo = $.extend(true, [], dataController.getColumnsInfo(true)),
                        rowsInfoItems = $.extend(true, [], dataController.getRowsInfo(true)),
                        cellsInfo = dataController.getCellsInfo(true);
                    items.resolve(that._getAllItems(columnsInfo, rowsInfoItems, cellsInfo));
                    dataController.endLoading()
                });
                return new ui.dxPivotGrid.DataProvider({items: items})
            }
        });
        function getCellDataType(cell) {
            if (cell.dataType)
                return cell.dataType;
            else if (cell.format) {
                if (formatHelper.format(1, cell.format))
                    return "number";
                if (formatHelper.format(new Date, cell.format))
                    return "date"
            }
            return DEFAULT_DATA_TYPE
        }
        pivotGrid.DataProvider = Class.inherit({
            _getCellParam: function(rowIndex, cellIndex, param) {
                var items = this._options.items,
                    item = items[rowIndex] && items[rowIndex][cellIndex];
                return item && item[param]
            },
            ctor: function(options) {
                this._options = options
            },
            ready: function() {
                var options = this._options;
                return $.when(options.items).done(function(items) {
                        var cellItem,
                            headerSize = items[0][0].rowspan,
                            columns = items[headerSize - 1];
                        $.each(columns, function(columnIndex, column) {
                            column.width = 100;
                            column.alignment = column.alignment || "center";
                            cellItem = items[headerSize] && items[headerSize][columnIndex];
                            if (cellItem) {
                                column.dataType = getCellDataType(cellItem);
                                column.format = cellItem.format;
                                column.precision = cellItem.precision
                            }
                        });
                        options.columns = columns;
                        options.items = items
                    })
            },
            getColumns: function() {
                return this._options.columns
            },
            getRowsCount: function() {
                return this._options.items.length
            },
            isGroupRow: function() {
                return false
            },
            isHeadersVisible: function() {
                return false
            },
            isTotalCell: function() {
                return false
            },
            getGroupLevel: function() {
                return 0
            },
            getCellMerging: function(rowIndex, cellIndex) {
                var items = this._options.items,
                    item = items[rowIndex] && items[rowIndex][cellIndex];
                return item ? {
                        colspan: item.colspan - 1,
                        rowspan: item.rowspan - 1
                    } : {
                        colspan: 0,
                        rowspan: 0
                    }
            },
            getFrozenArea: function() {
                var items = this._options.items;
                return {
                        x: items[0][0].colspan,
                        y: items[0][0].rowspan
                    }
            },
            getCellType: function(rowIndex, cellIndex) {
                var column = this._options.columns[cellIndex],
                    dataType = column && column.dataType;
                return dataType || DEFAULT_DATA_TYPE
            },
            getCellValue: function(rowIndex, cellIndex) {
                return this._getCellParam(rowIndex, cellIndex, "value", "")
            },
            getCellText: function(rowIndex, cellIndex) {
                return this._getCellParam(rowIndex, cellIndex, "text")
            }
        })
    })(jQuery, DevExpress);
    /*! Module widgets-web, file ui.pivotGrid.summaryDisplayModes.js */
    (function($, DX, NULL) {
        var pivotGrid = DX.ui.dxPivotGrid,
            foreachTree = pivotGrid.foreachTree,
            commonUtils = DX.require("/utils/utils.common"),
            isDefined = commonUtils.isDefined,
            findField = pivotGrid.findField,
            COLUMN = "column",
            ROW = "row",
            percentOfGrandTotal = function(e, dimension) {
                var parent = e.grandTotal(dimension);
                if (isDefined(e.value()))
                    return e.value() / parent.value();
                return NULL
            },
            percentOfParent = function(e, dimension) {
                var parent = e.parent(dimension),
                    parentValue = parent ? parent.value() : e.value();
                if (isDefined(e.value()))
                    return e.value() / parentValue;
                return NULL
            },
            createAbsoluteVariationExp = function(allowGrossGroup) {
                return function(e) {
                        var prevCell = e.prev(COLUMN, allowGrossGroup),
                            prevValue = prevCell && prevCell.value();
                        if (isDefined(prevValue) && isDefined(e.value()))
                            return e.value() - prevValue;
                        return NULL
                    }
            },
            createPercentVariationExp = function(allowGrossGroup) {
                var absoluteExp = createAbsoluteVariationExp(allowGrossGroup);
                return function(e) {
                        var absVar = absoluteExp(e);
                        return absVar !== NULL ? absVar / e.value() : NULL
                    }
            },
            summaryDictionary = {
                percentOfColumnTotal: function(e) {
                    return percentOfParent(e, ROW)
                },
                percentOfRowTotal: function(e) {
                    return percentOfParent(e, COLUMN)
                },
                percentOfColumnGrandTotal: function(e) {
                    return percentOfGrandTotal(e, ROW)
                },
                percentOfRowGrandTotal: function(e) {
                    return percentOfGrandTotal(e, COLUMN)
                },
                percentOfGrandTotal: function(e) {
                    return percentOfGrandTotal(e)
                }
            },
            getPrevCellCrossGroup = function(cell, direction) {
                if (!cell || !cell.parent(direction))
                    return;
                var prevCell = cell.prev(direction);
                if (!prevCell)
                    prevCell = getPrevCellCrossGroup(cell.parent(direction), direction);
                return prevCell
            },
            createRunningTotalExpr = function(getValue, allowGrossGroupCalculation, direction) {
                direction = direction === COLUMN ? ROW : COLUMN;
                return function(e) {
                        var prevCell = allowGrossGroupCalculation ? getPrevCellCrossGroup(e, direction) : e.prev(direction, false),
                            value = getValue(e);
                        return (prevCell && prevCell.value(true) || 0) + (value || 0)
                    }
            },
            defaultExpr = function(e) {
                return e.value()
            };
        function getFieldPos(descriptions, field) {
            var fieldIndex,
                allFields,
                fieldParams = {index: -1};
            if (!commonUtils.isObject(field)) {
                allFields = descriptions.columns.concat(descriptions.rows).concat(descriptions.values);
                fieldIndex = findField(allFields, field);
                field = allFields[fieldIndex]
            }
            if (field) {
                fieldParams.area = field.area;
                fieldParams.index = $.inArray(field, descriptions[field.area === "data" ? "values" : field.area + "s"])
            }
            return fieldParams
        }
        function getPathFieldName(dimension) {
            return dimension === ROW ? "_rowPath" : "_columnPath"
        }
        var SummaryCell = function(columnPath, rowPath, data, descriptions, fieldIndex) {
                this._columnPath = columnPath;
                this._rowPath = rowPath;
                this._fieldIndex = fieldIndex;
                this._data = data;
                this._descriptions = descriptions;
                var cell = data.values && data.values[rowPath[0].index] && data.values[rowPath[0].index][columnPath[0].index];
                if (cell) {
                    cell.orginalCell = cell.orginalCell || cell.slice();
                    this._cell = cell
                }
            };
        SummaryCell.prototype = $.extend(SummaryCell.prototype, {
            _getPath: function(dimension) {
                return this[getPathFieldName(dimension)]
            },
            _getDimension: function(dimension) {
                dimension = dimension === ROW ? "rows" : "columns";
                return this._descriptions[dimension]
            },
            _getData: function(dimension) {
                dimension = dimension === ROW ? "rows" : "columns";
                return this._data[dimension]
            },
            _createCell: function(config) {
                var that = this;
                return new SummaryCell(config._columnPath || that._columnPath, config._rowPath || that._rowPath, that._data, that._descriptions, that._fieldIndex)
            },
            parent: function(direction) {
                var path = this._getPath(direction).slice(),
                    config = {};
                path.shift();
                if (path.length) {
                    config[getPathFieldName(direction)] = path;
                    return this._createCell(config)
                }
                return NULL
            },
            children: function(direction) {
                var path = this._getPath(direction).slice(),
                    item = path[0],
                    result = [],
                    cellConfig = {};
                if (item.children)
                    for (var i = 0; i < item.children.length; i++) {
                        cellConfig[getPathFieldName(direction)] = [item.children[i]].concat(path.slice());
                        result.push(this._createCell(cellConfig))
                    }
                return result
            },
            grandTotal: function(direction) {
                var config = {},
                    rowPath = this._rowPath,
                    columnPath = this._columnPath,
                    dimensionPath = this._getPath(direction),
                    pathFieldName = getPathFieldName(direction);
                if (!direction) {
                    config._rowPath = [rowPath[rowPath.length - 1]];
                    config._columnPath = [columnPath[columnPath.length - 1]]
                }
                else
                    config[pathFieldName] = [dimensionPath[dimensionPath.length - 1]];
                return this._createCell(config)
            },
            next: function(direction, allowGrossGroup) {
                var currentPath = this._getPath(direction),
                    item = currentPath[0],
                    parent = this.parent(direction),
                    siblings,
                    index;
                if (parent) {
                    index = $.inArray(item, currentPath[1].children);
                    siblings = parent.children(direction);
                    if (siblings[index + 1])
                        return siblings[index + 1]
                }
                if (allowGrossGroup && parent) {
                    do {
                        parent = parent.next(direction, allowGrossGroup);
                        siblings = parent ? parent.children(direction) : []
                    } while (parent && !siblings.length);
                    return siblings[0] || NULL
                }
                return NULL
            },
            prev: function(direction, allowGrossGroup) {
                var currentPath = this._getPath(direction),
                    item = currentPath[0],
                    parent = this.parent(direction),
                    siblings,
                    index;
                if (parent) {
                    index = $.inArray(item, currentPath[1].children);
                    siblings = parent.children(direction);
                    if (siblings[index - 1])
                        return siblings[index - 1]
                }
                if (allowGrossGroup && parent) {
                    do {
                        parent = parent.prev(direction, allowGrossGroup);
                        siblings = parent ? parent.children(direction) : []
                    } while (parent && !siblings.length);
                    return siblings[siblings.length - 1] || NULL
                }
                return NULL
            },
            cell: function() {
                return this._cell
            },
            field: function(area) {
                var path = this._getPath(area),
                    descriptions = this._getDimension(area),
                    field = descriptions[path.length - 2];
                return field || NULL
            },
            child: function(direction, fieldValue) {
                var children = this.children(direction),
                    childLevelField;
                for (var i = 0; i < children.length; i++) {
                    childLevelField = childLevelField || children[i].field(direction);
                    if (children[i].value(childLevelField) === fieldValue)
                        return children[i]
                }
                return NULL
            },
            slice: function(field, value) {
                var that = this,
                    config = {},
                    fieldPos = getFieldPos(this._descriptions, field),
                    area = fieldPos.area,
                    fieldIndex = fieldPos.index,
                    childItems,
                    path,
                    currentValue,
                    level,
                    sliceCell = NULL,
                    newPath = [];
                if (area === ROW || area === COLUMN) {
                    path = this._getPath(area).slice();
                    level = fieldIndex !== -1 && path.length - 2 - fieldIndex;
                    if (path[level]) {
                        newPath[path.length - 1] = path[path.length - 1];
                        for (var i = level; i >= 0; i--) {
                            if (path[i + 1]) {
                                childItems = path[i + 1].children || [];
                                currentValue = i === level ? value : path[i].value;
                                path[i] = undefined;
                                for (var childIndex = 0; childIndex < childItems.length; childIndex++)
                                    if (childItems[childIndex].value === currentValue) {
                                        path[i] = childItems[childIndex];
                                        break
                                    }
                            }
                            if (path[i] === undefined)
                                return sliceCell
                        }
                        config[getPathFieldName(area)] = path;
                        sliceCell = that._createCell(config)
                    }
                }
                return sliceCell
            },
            value: function() {
                var cell = this._cell,
                    fieldIndex = this._fieldIndex,
                    args = arguments,
                    fistArgIsBoolean = args[0] === true || args[0] === false,
                    path,
                    field = !fistArgIsBoolean ? args[0] : NULL,
                    needCalculatedValue = fistArgIsBoolean && args[0] || args[1],
                    level;
                if (field) {
                    var fieldPos = getFieldPos(this._descriptions, field);
                    fieldIndex = fieldPos.index;
                    if (fieldPos.area !== "data") {
                        path = this._getPath(fieldPos.area);
                        level = fieldIndex !== -1 && path.length - 2 - fieldIndex;
                        return path[level] && path[level].value
                    }
                }
                if (cell && cell.orginalCell)
                    return needCalculatedValue ? cell[fieldIndex] : cell.orginalCell[fieldIndex];
                return NULL
            }
        });
        function getExpression(field) {
            var summaryDisplayMode = field.summaryDisplayMode,
                crossGroupCalculation = field.allowCrossGroupCalculation,
                expression = NULL;
            if (commonUtils.isFunction(field.calculateSummaryValue))
                expression = field.calculateSummaryValue;
            else if (summaryDisplayMode) {
                if (summaryDisplayMode === "absoluteVariation")
                    expression = createAbsoluteVariationExp(crossGroupCalculation);
                else if (summaryDisplayMode === "percentVariation")
                    expression = createPercentVariationExp(crossGroupCalculation);
                else
                    expression = summaryDictionary[summaryDisplayMode];
                if (expression && !field.format && summaryDisplayMode.indexOf("percent") !== -1)
                    pivotGrid.setFieldProperty(field, "format", "percent")
            }
            if (field.runningTotal) {
                expression = expression || defaultExpr;
                return createRunningTotalExpr(expression, crossGroupCalculation, field.runningTotal)
            }
            return expression
        }
        pivotGrid.applyDisplaySummaryMode = function(descriptions, data) {
            var expressions = [],
                columnElements = [{
                        index: data.grandTotalColumnIndex,
                        children: data.columns
                    }],
                rowElements = [{
                        index: data.grandTotalRowIndex,
                        children: data.rows
                    }],
                valueFields = descriptions.values;
            foreachTree(rowElements, function(rowPath) {
                var rowItem = rowPath[0];
                rowItem.isEmpty = true;
                foreachTree(columnElements, function(columnPath) {
                    var columnItem = columnPath[0],
                        expression,
                        expressionArg,
                        cell,
                        field,
                        isEmptyCell = false,
                        value;
                    columnItem.isEmpty = columnItem.isEmpty || [];
                    for (var i = 0; i < valueFields.length; i++) {
                        field = valueFields[i];
                        expression = expressions[i] = expressions[i] || getExpression(field);
                        if (expression) {
                            expressionArg = new SummaryCell(columnPath, rowPath, data, descriptions, i);
                            cell = expressionArg.cell();
                            if (cell) {
                                value = cell[i] = expression(expressionArg);
                                isEmptyCell = value === null || value === undefined
                            }
                            else
                                isEmptyCell = true
                        }
                        if (columnItem.isEmpty[i] === undefined)
                            columnItem.isEmpty[i] = true;
                        if (!isEmptyCell) {
                            columnItem.isEmpty[i] = false;
                            rowItem.isEmpty = false
                        }
                    }
                }, false)
            }, false);
            data.isEmptyGrandTotalRow = rowElements[0].isEmpty;
            data.isEmptyGrandTotalColumn = columnElements[0].isEmpty
        };
        pivotGrid.Cell = SummaryCell;
        pivotGrid.summaryDictionary = summaryDictionary;
        pivotGrid.getExpression = getExpression
    })(jQuery, DevExpress, null);
    /*! Module widgets-web, file ui.scheduler.publisherMixin.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.publisherMixin", ["jquery"], function($) {
        var publisherMixin = {
                notifyObserver: function(subject, args) {
                    var observer = this.option("observer");
                    if (observer)
                        observer.fire(subject, args)
                },
                invoke: function() {
                    var observer = this.option("observer");
                    if (observer)
                        return observer.fire.apply(observer, arguments)
                }
            };
        return publisherMixin
    });
    /*! Module widgets-web, file ui.scheduler.appointmentTooltip.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointmentTooltip", ["jquery", "/ui/ui.tooltip", "/ui/widgets/ui.button", "/ui/templates/ui.template.function", "/ui/templates/ui.template.dynamic", "/ui/templates/ui.template.move"], function($, tooltip, Button, FunctionTempalte, DynamicTemplate, MoveTemplate) {
        var APPOINTMENT_TOOLTIP_CLASS = "dx-scheduler-appointment-tooltip",
            APPOINTMENT_TOOLTIP_TITLE_CLASS = "dx-scheduler-appointment-tooltip-title",
            APPOINTMENT_TOOLTIP_DATE_CLASS = "dx-scheduler-appointment-tooltip-date",
            APPOINTMENT_TOOLTIP_BUTTONS_CLASS = "dx-scheduler-appointment-tooltip-buttons";
        var appointmentTooltip = {
                show: function(appointmentData, singleAppointmentData, $appointment, instance) {
                    this.instance = instance;
                    var isAllDay = instance.appointmentTakesAllDay(appointmentData);
                    this._initDynamicTemplate(appointmentData, singleAppointmentData);
                    var template = instance._getTemplateByOption("appointmentTooltipTemplate");
                    this.hide();
                    this._$tooltip = $("<div>").appendTo(instance.element());
                    this._tooltip = instance._createComponent(this._$tooltip, "dxTooltip", {
                        _templates: instance.option("_templates"),
                        templateProvider: instance.option("templateProvider"),
                        visible: true,
                        target: $appointment,
                        rtlEnabled: instance.option("rtlEnabled"),
                        contentTemplate: new DynamicTemplate(function(container) {
                            return new MoveTemplate(template.render(appointmentData, container))
                        }),
                        position: {
                            my: "bottom",
                            at: "top",
                            of: $appointment,
                            boundary: isAllDay ? instance.element() : instance.getWorkSpaceScrollableContainer(),
                            collision: "fit flipfit"
                        }
                    })
                },
                hide: function() {
                    if (!this._$tooltip)
                        return;
                    this._$tooltip.remove();
                    delete this._$tooltip;
                    delete this._tooltip;
                    tooltip.hide()
                },
                _initDynamicTemplate: function(appointmentData, singleAppointmentData) {
                    var that = this;
                    this.instance._dynamicTemplates["appointmentTooltip"] = new FunctionTempalte(function(data, index, $container) {
                        var $tooltip = that._tooltipContent(appointmentData, singleAppointmentData);
                        $tooltip.addClass($container.attr("class"));
                        $container.replaceWith($tooltip);
                        return $container
                    })
                },
                _tooltipContent: function(appointmentData, singleAppointmentData) {
                    var $tooltip = $("<div>").addClass(APPOINTMENT_TOOLTIP_CLASS);
                    var isAllDay = this.instance.appointmentTakesAllDay(appointmentData),
                        startDate = this.instance.fire("getField", "startDate", appointmentData),
                        endDate = this.instance.fire("getField", "endDate", appointmentData),
                        text = this.instance.fire("getField", "text", appointmentData);
                    $("<div>").text(text).addClass(APPOINTMENT_TOOLTIP_TITLE_CLASS).appendTo($tooltip);
                    $("<div>").addClass(APPOINTMENT_TOOLTIP_DATE_CLASS).text(this._formatTooltipDate(startDate, endDate, isAllDay)).appendTo($tooltip);
                    var $buttons = $("<div>").addClass(APPOINTMENT_TOOLTIP_BUTTONS_CLASS).appendTo($tooltip);
                    if (this.instance._editing.allowDeleting)
                        this._getDeleteButton(appointmentData, singleAppointmentData).appendTo($buttons);
                    this._getOpenButton(appointmentData, singleAppointmentData).appendTo($buttons);
                    return $tooltip
                },
                _formatTooltipDate: function(startDate, endDate, isAllDay) {
                    var formatType = this.instance.option("currentView") === "month" ? "DATETIME" : "TIME",
                        formattedString = "";
                    if (isAllDay)
                        formatType = "DATE";
                    this.instance.fire("formatDates", {
                        startDate: startDate,
                        endDate: endDate,
                        formatType: formatType,
                        callback: function(result) {
                            formattedString = result
                        }
                    });
                    return formattedString
                },
                _getDeleteButton: function(appointmentData, singleAppointmentData) {
                    var that = this;
                    return new Button($("<div>"), {
                            icon: "trash",
                            onClick: function() {
                                var startDate = that.instance.fire("getField", "startDate", singleAppointmentData);
                                that.instance._checkRecurringAppointment(appointmentData, singleAppointmentData, startDate, function() {
                                    that.instance.deleteAppointment(appointmentData)
                                }, true);
                                that.hide()
                            }
                        }).element()
                },
                _getOpenButton: function(appointmentData, singleAppointmentData) {
                    var that = this,
                        allowUpdating = that.instance._editing.allowUpdating;
                    return new Button($("<div>"), {
                            icon: allowUpdating ? "edit" : "",
                            text: Globalize.localize("dxScheduler-openAppointment"),
                            onClick: function() {
                                that.instance.showAppointmentPopup(appointmentData, false, singleAppointmentData)
                            }
                        }).element()
                }
            };
        return appointmentTooltip
    });
    /*! Module widgets-web, file ui.scheduler.appointmentModel.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointmentModel", ["jquery", "/class", "/utils/utils.recurrence", "/utils/utils.date", "/utils/utils.common", "/utils/utils.array"], function($, Class, recurrenceUtils, dateUtils, commonUtils, arrayUtils) {
        var FilterMaker = Class.inherit({
                ctor: function(dataExpressions) {
                    this._filterRegistry = null;
                    this._dataExpressions = dataExpressions
                },
                make: function(type, args) {
                    if (!this._filterRegistry)
                        this._filterRegistry = {};
                    this._make[type].apply(this, args)
                },
                _make: {
                    date: function(min, max) {
                        var startDate = this._dataExpressions.startDateExpr,
                            endDate = this._dataExpressions.endDateExpr,
                            recurrenceRule = this._dataExpressions.recurrenceRuleExpr;
                        this._filterRegistry.date = [[[[startDate, ">=", min], [endDate, "<=", max]], "or", [[startDate, "<=", min], [endDate, "<=", max], [endDate, ">", min]], "or", [[startDate, ">=", min], [startDate, "<", max], [endDate, ">=", max]], "or", [[startDate, "<=", min], [endDate, ">=", max]]], "or", [recurrenceRule, "startswith", "freq"]];
                        if (!recurrenceRule)
                            this._filterRegistry.date.splice(1, 2)
                    },
                    user: function(userFilter) {
                        this._filterRegistry.user = userFilter
                    }
                },
                combine: function() {
                    var filter = [];
                    this._filterRegistry.date && filter.push(this._filterRegistry.date);
                    this._filterRegistry.user && filter.push(this._filterRegistry.user);
                    return filter
                }
            });
        var AppointmentModel = Class.inherit({
                _createFilter: function(min, max) {
                    this._filterMaker.make("date", [min, max]);
                    this._filterMaker.make("user", [this._dataSource.filter()]);
                    this._dataSource.filter(this._filterMaker.combine())
                },
                _getStoreKey: function(target) {
                    var store = this._dataSource.store();
                    return store.keyOf(target)
                },
                _filterAppointmentByResources: function(appointment, resources) {
                    var result = false;
                    function checkAppointmentResourceValues() {
                        var appointmentResourceValues = arrayUtils.wrapToArray(appointment[resourceName]),
                            resourceData = $.map(resources[i].items, function(item) {
                                return item.id
                            });
                        for (var j = 0, itemDataCount = appointmentResourceValues.length; j < itemDataCount; j++)
                            if ($.inArray(appointmentResourceValues[j], resourceData) > -1)
                                return true;
                        return false
                    }
                    for (var i = 0, len = resources.length; i < len; i++) {
                        var resourceName = resources[i].name;
                        if (!appointment.hasOwnProperty(resourceName))
                            return false;
                        result = checkAppointmentResourceValues();
                        if (!result)
                            return false
                    }
                    return result
                },
                _filterAppointmentByRRule: function(appointment, min, max, startDayHour, endDayHour) {
                    var rrule = appointment.rrule,
                        recurrenceException = appointment.recurrenceException,
                        allDay = appointment.allDay,
                        result = true,
                        appointmentStartDate = appointment.startDate,
                        appointmentEndDate = appointment.endDate;
                    if (allDay || this._appointmentPartInInterval(appointmentStartDate, appointmentEndDate, startDayHour, endDayHour)) {
                        var trimedDates = this._trimDates(min, max);
                        min = trimedDates.min,
                        max = new Date(trimedDates.max.getTime() - 60000)
                    }
                    if (rrule && !recurrenceUtils.getRecurrenceRule(rrule).isValid)
                        result = appointmentEndDate > min && appointmentStartDate <= max;
                    if (result && recurrenceUtils.getRecurrenceRule(rrule).isValid)
                        result = recurrenceUtils.dateInRecurrenceRange(rrule, appointmentStartDate, min, max, recurrenceException);
                    return result
                },
                _appointmentPartInInterval: function(startDate, endDate, startDayHour, endDayHour) {
                    var apptStartDayHour = startDate.getHours(),
                        apptEndDayHour = endDate.getHours();
                    return apptStartDayHour <= startDayHour && apptEndDayHour <= endDayHour && apptEndDayHour >= startDayHour || apptEndDayHour >= endDayHour && apptStartDayHour <= endDayHour && apptStartDayHour >= startDayHour
                },
                _createCombinedFilter: function(filterOptions) {
                    var dataAccessors = this._dataAccessors,
                        startDayHour = filterOptions.startDayHour,
                        endDayHour = filterOptions.endDayHour,
                        min = dateUtils.makeDate(filterOptions.min),
                        max = dateUtils.makeDate(filterOptions.max),
                        resources = filterOptions.resources,
                        that = this;
                    return [[function(appointment) {
                                    var result = true,
                                        startDate = dateUtils.makeDate(dataAccessors.getter.startDate(appointment)),
                                        endDate = dateUtils.makeDate(dataAccessors.getter.endDate(appointment)),
                                        appointmentTakesAllDay = that.appointmentTakesAllDay(appointment, startDayHour, endDayHour),
                                        isAllDay = dataAccessors.getter.allDay(appointment),
                                        apptStartHour = startDate.getHours(),
                                        hiddenInterval = (24 - endDayHour + startDayHour) * 3600000,
                                        apptDuration = endDate.getTime() - startDate.getTime(),
                                        delta = (hiddenInterval - apptDuration) / (1000 * 60 * 60),
                                        useRecurrence = commonUtils.isDefined(dataAccessors.getter.recurrenceRule),
                                        rrule;
                                    if (useRecurrence)
                                        rrule = dataAccessors.getter.recurrenceRule(appointment);
                                    if (resources && resources.length)
                                        result = that._filterAppointmentByResources(appointment, resources);
                                    if (appointmentTakesAllDay && filterOptions.allDay === false)
                                        result = false;
                                    if (result && useRecurrence)
                                        result = that._filterAppointmentByRRule({
                                            startDate: startDate,
                                            endDate: endDate,
                                            rrule: rrule,
                                            recurrenceException: dataAccessors.getter.recurrenceException(appointment),
                                            allDay: appointmentTakesAllDay
                                        }, min, max, startDayHour, endDayHour);
                                    if (result && startDayHour !== undefined)
                                        result = startDate.getHours() >= startDayHour || endDate.getHours() >= startDayHour || appointmentTakesAllDay;
                                    if (result && endDayHour !== undefined) {
                                        result = startDate.getHours() < endDayHour || appointmentTakesAllDay && startDate <= max;
                                        if (apptDuration < hiddenInterval)
                                            if (apptStartHour > endDayHour && delta <= apptStartHour - endDayHour)
                                                result = false
                                    }
                                    if (result && useRecurrence && !rrule)
                                        if (endDate.getTime() < min.getTime() && !isAllDay)
                                            result = false;
                                    return result
                                }]]
                },
                ctor: function(dataSource, dataExpressions, dataAccessors) {
                    this.setDataSource(dataSource);
                    this._filterMaker = new FilterMaker(dataExpressions);
                    this._dataAccessors = dataAccessors
                },
                setDataSource: function(dataSource) {
                    this._dataSource = dataSource
                },
                filterByDate: function(min, max) {
                    if (!this._dataSource)
                        return;
                    var trimedDates = this._trimDates(min, max);
                    if (!this._filterMaker._filterRegistry)
                        this._createFilter(trimedDates.min, trimedDates.max);
                    else {
                        this._filterMaker.make("date", [trimedDates.min, trimedDates.max]);
                        if (this._dataSource.filter() && this._dataSource.filter().length > 1)
                            this._filterMaker.make("user", [this._dataSource.filter()[1]]);
                        this._dataSource.filter(this._filterMaker.combine())
                    }
                },
                filterLoadedAppointments: function(filterOptions) {
                    var combinedFilter = this._createCombinedFilter(filterOptions);
                    if (this._filterMaker._filterRegistry) {
                        var trimedDates = this._trimDates(filterOptions.min, filterOptions.max);
                        this._filterMaker.make("date", [trimedDates.min, trimedDates.max]);
                        var dateFilter = this.customizeDateFilter(this._filterMaker.combine());
                        combinedFilter.push([dateFilter])
                    }
                    return DevExpress.data.query(this._dataSource.items()).filter(combinedFilter).toArray()
                },
                _trimDates: function(min, max) {
                    var minCopy = dateUtils.trimTime(new Date(min)),
                        maxCopy = dateUtils.trimTime(new Date(max));
                    maxCopy.setDate(maxCopy.getDate() + 1);
                    return {
                            min: minCopy,
                            max: maxCopy
                        }
                },
                hasAllDayAppointments: function(items, startDayHour, endDayHour) {
                    if (!items)
                        return false;
                    var that = this;
                    var result = false;
                    $.each(items, function(index, item) {
                        if (that.appointmentTakesAllDay(item, startDayHour, endDayHour)) {
                            result = true;
                            return false
                        }
                    });
                    return result
                },
                appointmentTakesAllDay: function(appointment, startDayHour, endDayHour) {
                    var dataAccessors = this._dataAccessors,
                        startDate = dataAccessors.getter.startDate(appointment),
                        endDate = dataAccessors.getter.endDate(appointment),
                        allDay = dataAccessors.getter.allDay(appointment);
                    return allDay || this._appointmentHasAllDayDuration(startDate, endDate, startDayHour, endDayHour)
                },
                _appointmentHasAllDayDuration: function(startDate, endDate, startDayHour, endDayHour) {
                    startDate = new Date(startDate);
                    endDate = new Date(endDate);
                    var etalonDayDurationInHours = endDayHour - startDayHour,
                        appointmentDurationInHours = (endDate.getTime() - startDate.getTime()) / 3600000;
                    return appointmentDurationInHours >= etalonDayDurationInHours
                },
                customizeDateFilter: function(dateFilter) {
                    var currentFilter = $.extend(true, [], dateFilter);
                    return $.proxy(function(appointment) {
                            appointment = $.extend(true, {}, appointment);
                            if ($.isFunction(this._dataSource._mapFunc))
                                try {
                                    appointment = this._dataSource._mapFunc(appointment)
                                }
                                catch(e) {}
                            var startDate = this._dataAccessors.getter.startDate(appointment),
                                endDate = this._dataAccessors.getter.endDate(appointment);
                            this._dataAccessors.setter.startDate(appointment, dateUtils.makeDate(startDate));
                            this._dataAccessors.setter.endDate(appointment, dateUtils.makeDate(endDate));
                            return DevExpress.data.query([appointment]).filter(currentFilter).toArray().length > 0
                        }, this)
                },
                add: function(data) {
                    return this._dataSource.store().insert(data).done($.proxy(function() {
                            this._dataSource.load()
                        }, this))
                },
                update: function(target, data) {
                    var key = this._getStoreKey(target);
                    return this._dataSource.store().update(key, data).done($.proxy(function() {
                            this._dataSource.load()
                        }, this))
                },
                remove: function(target) {
                    var key = this._getStoreKey(target);
                    return this._dataSource.store().remove(key).done($.proxy(function() {
                            this._dataSource.load()
                        }, this))
                }
            });
        return AppointmentModel
    });
    /*! Module widgets-web, file ui.scheduler.resourceManager.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.resourceManager", ["jquery", "/class", "/utils/utils.array", "/utils/utils.common"], function($, Class, arrayUtils, commonUtils) {
        var data = DevExpress.data,
            dataUtils = data.utils;
        var DEFAULT_VALUE_EXPR = "id",
            DEFAULT_DISPLAY_EXPR = "text";
        var ResourceManager = Class.inherit({
                _wrapDataSource: function(dataSource) {
                    var store;
                    if (dataSource instanceof data.DataSource)
                        store = dataSource.store();
                    else
                        store = dataUtils.normalizeDataSourceOptions(dataSource).store;
                    return new data.DataSource({
                            store: store,
                            pageSize: 0
                        })
                },
                _mapResourceData: function(resource, data) {
                    var valueGetter = dataUtils.compileGetter(resource.valueExpr || DEFAULT_VALUE_EXPR),
                        displayGetter = dataUtils.compileGetter(resource.displayExpr || DEFAULT_DISPLAY_EXPR);
                    return $.map(data, function(item) {
                            return {
                                    id: valueGetter(item),
                                    text: displayGetter(item)
                                }
                        })
                },
                _isMultipleResource: function(resourceField) {
                    var result = false;
                    $.each(this.getResources(), function(_, resource) {
                        if (resource.field === resourceField) {
                            result = resource.allowMultiple;
                            return false
                        }
                    });
                    return result
                },
                ctor: function(resources) {
                    this.setResources(resources)
                },
                setResources: function(resources) {
                    this._resources = resources;
                    this._resourceFields = $.map(resources || [], function(resource) {
                        return resource.field
                    })
                },
                getResources: function() {
                    return this._resources || []
                },
                getEditors: function() {
                    var result = [],
                        that = this;
                    $.each(this.getResources(), function(i, resource) {
                        result.push({
                            editorOptions: {
                                dataSource: that._wrapDataSource(resource.dataSource),
                                displayExpr: resource.displayExpr || DEFAULT_DISPLAY_EXPR,
                                valueExpr: resource.valueExpr || DEFAULT_VALUE_EXPR
                            },
                            dataField: resource.field,
                            editorType: resource.allowMultiple ? "dxTagBox" : "dxSelectBox",
                            label: {text: resource.label || resource.field}
                        })
                    });
                    return result
                },
                getResourceDataByValue: function(field, value) {
                    var result = $.Deferred(),
                        that = this;
                    $.each(this.getResources(), function(_, resource) {
                        if (resource.field === field) {
                            var dataSource = that._wrapDataSource(resource.dataSource),
                                valueExpr = resource.valueExpr || DEFAULT_VALUE_EXPR;
                            dataSource.filter(valueExpr, value);
                            dataSource.load().done(function(data) {
                                var filteredData = DevExpress.data.query(data).filter(valueExpr, value).toArray();
                                result.resolve(filteredData[0])
                            }).fail(function() {
                                result.reject()
                            });
                            return false
                        }
                    });
                    return result.promise()
                },
                getResourcesFromItem: function(itemData, wrapOnlyMultipleResources) {
                    var that = this,
                        result = null;
                    if (!commonUtils.isDefined(wrapOnlyMultipleResources))
                        wrapOnlyMultipleResources = false;
                    $.each(itemData, function(name) {
                        if ($.inArray(name, that._resourceFields) > -1) {
                            if (!result)
                                result = {};
                            if (!wrapOnlyMultipleResources || wrapOnlyMultipleResources && that._isMultipleResource(name))
                                result[name] = arrayUtils.wrapToArray(itemData[name]);
                            else
                                result[name] = itemData[name]
                        }
                    });
                    return result
                },
                getResourcesValueByFields: function(groups) {
                    var result = $.Deferred(),
                        that = this,
                        deferreds = [];
                    $.each(this.getResourcesByFields(groups), function(i, resource) {
                        var deferred = $.Deferred();
                        deferreds.push(deferred);
                        that._wrapDataSource(resource.dataSource).load().done(function(data) {
                            deferred.resolve({
                                name: resource.field,
                                items: that._mapResourceData(resource, data)
                            })
                        }).fail(function() {
                            deferred.reject()
                        })
                    });
                    $.when.apply(null, deferreds).done(function() {
                        result.resolve(Array.prototype.slice.call(arguments))
                    }).fail(function() {
                        result.reject()
                    });
                    return result.promise()
                },
                getResourceColor: function(field, value) {
                    var result = $.Deferred(),
                        color;
                    this.getResourceDataByValue(field, value).done(function(data) {
                        if (data)
                            color = data.color;
                        result.resolve(color)
                    }).fail(function() {
                        result.reject()
                    });
                    return result.promise()
                },
                getResourcesByFields: function(fields) {
                    return $.grep(this.getResources(), function(resource) {
                            return $.inArray(resource.field, fields) > -1
                        })
                },
                getResourceForPainting: function(groups) {
                    var resources = this.getResources(),
                        result;
                    $.each(resources, function(index, resource) {
                        if (resource.useColorAsDefault || resource.mainColor) {
                            result = resource;
                            return false
                        }
                    });
                    if (!result) {
                        if ($.isArray(groups) && groups.length)
                            resources = this.getResourcesByFields(groups);
                        result = resources[resources.length - 1]
                    }
                    return result
                }
            });
        return ResourceManager
    });
    /*! Module widgets-web, file ui.scheduler.recurrenceEditor.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.recurrenceEditor", ["jquery", "/class", "/utils/utils.recurrence", "/utils/utils.dom", "/utils/utils.common", "/componentRegistrator", "/ui/ui.editor", "/ui/widgets/ui.checkBox", "/ui/widgets/ui.radioGroup", "/ui/widgets/ui.switch", "/ui/widgets/ui.numberBox", "/ui/widgets/ui.selectBox", "/ui/widgets/date/ui.dateBox", "/ui/widgets/scheduler/ui.scheduler.publisherMixin", "/utils/utils.date"], function($, Class, recurrenceUtils, domUtils, commonUtils, registerComponent, Editor, CheckBox, RadioGroup, Switch, NumberBox, SelectBox, DateBox, publisherMixin, dateUtils) {
        var RECURRENCE_EDITOR = "dx-recurrence-editor",
            LABEL_POSTFIX = "-label",
            RECURRENCE_EDITOR_CONTAINER = "dx-recurrence-editor-container",
            SWITCH_EDITOR = "dx-recurrence-switch",
            SWITCH_REPEAT_END_EDITOR = "dx-recurrence-switch-repeat-end",
            FREQUENCY_EDITOR = "dx-recurrence-radiogroup-freq",
            INTERVAL_EDITOR = "dx-recurrence-numberbox-interval",
            INTERVAL_EDITOR_FIELD = "dx-recurrence-interval-field",
            REPEAT_END_EDITOR = "dx-recurrence-repeat-end",
            REPEAT_END_EDITOR_FIELD = "dx-recurrence-repeat-end-field",
            REPEAT_END_EDITOR_CONTAINER = "dx-recurrence-repeat-end-container",
            REPEAT_TYPE_EDITOR = "dx-recurrence-radiogroup-repeat-type",
            REPEAT_COUNT_EDITOR = "dx-recurrence-numberbox-repeat-count",
            REPEAT_UNTIL_DATE_EDITOR = "dx-recurrence-datebox-until-date",
            REPEAT_ON_EDITOR = "dx-recurrence-repeat-on",
            REPEAT_ON_WEEK_EDITOR = "dx-recurrence-repeat-on-week",
            DAY_OF_WEEK = "dx-recurrence-checkbox-day-of-week",
            REPEAT_ON_MONTH_EDITOR = "dx-recurrence-repeat-on-month",
            DAY_OF_MONTH = "dx-recurrence-numberbox-day-of-month",
            REPEAT_ON_YEAR_EDITOR = "dx-recurrence-repeat-on-year",
            MONTH_OF_YEAR = "dx-recurrence-selectbox-month-of-year",
            FIELD_CLASS = "dx-field",
            FIELD_LABEL_CLASS = "dx-field-label",
            FIELD_VALUE_CLASS = "dx-field-value",
            frequencies = [{
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceDaily")
                    },
                    value: "DAILY"
                }, {
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceWeekly")
                    },
                    value: "WEEKLY"
                }, {
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceMonthly")
                    },
                    value: "MONTHLY"
                }, {
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceYearly")
                    },
                    value: "YEARLY"
                }],
            repeatEndTypes = [{
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceRepeatCount")
                    },
                    value: "count"
                }, {
                    text: function() {
                        return Globalize.localize("dxScheduler-recurrenceRepeatOnDate")
                    },
                    value: "until"
                }],
            days = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
        var RecurrenceRule = Class.inherit({
                ctor: function(recurrence) {
                    this._recurrenceRule = recurrenceUtils.getRecurrenceRule(recurrence).rule
                },
                makeRules: function(string) {
                    var that = this;
                    that._recurrenceRule = recurrenceUtils.getRecurrenceRule(string).rule
                },
                makeRule: function(field, value) {
                    if (!value) {
                        delete this._recurrenceRule[field];
                        return
                    }
                    if (commonUtils.isDefined(field)) {
                        if (field === "until")
                            delete this._recurrenceRule.count;
                        if (field === "count")
                            delete this._recurrenceRule.until;
                        this._recurrenceRule[field] = value
                    }
                },
                repeatableRule: function() {
                    var rules = this._recurrenceRule;
                    if ("count" in rules)
                        return "count";
                    if ("until" in rules)
                        return "until";
                    return null
                },
                recurrenceString: function() {
                    return recurrenceUtils.getRecurrenceString(this._recurrenceRule)
                },
                rules: function() {
                    return this._recurrenceRule
                },
                daysFromByDayRule: function() {
                    return recurrenceUtils.daysFromByDayRule(this._recurrenceRule)
                }
            });
        var SchedulerRecurrenceEditor = Editor.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            value: null,
                            onValueChanged: null,
                            startDate: new Date
                        })
                },
                _createComponent: function(element, name, config) {
                    config = config || {};
                    this._extendConfig(config, {readOnly: this.option("readOnly")});
                    return this.callBase(element, name, config)
                },
                _init: function() {
                    this.callBase();
                    this._recurrenceRule = new RecurrenceRule(this.option("value"))
                },
                _render: function() {
                    this.callBase();
                    this.element().addClass(RECURRENCE_EDITOR);
                    this._renderSwitch();
                    this._$container = $("<div>").addClass(RECURRENCE_EDITOR_CONTAINER).appendTo(this.element());
                    this._renderEditors();
                    this._renderContainerVisibility(!!this.option("value"))
                },
                _renderSwitch: function() {
                    var $switchEditor = $("<div>").addClass(SWITCH_EDITOR);
                    this._switchEditor = this._createComponent($switchEditor, Switch, {
                        value: !!this.option("value"),
                        onValueChanged: $.proxy(this._switchValueChangeHandler, this)
                    });
                    this.element().append($switchEditor)
                },
                _switchValueChangeHandler: function(args) {
                    var value = args.value;
                    this._renderContainerVisibility(value);
                    if (!this.option("value") && value)
                        this._handleDefaults();
                    else if (!value) {
                        this._recurrenceRule.makeRules("");
                        this.option("value", "")
                    }
                },
                _renderContainerVisibility: function(value) {
                    if (value) {
                        this._$container.show();
                        this.notifyObserver("recurrenceEditorVisibylityChanged", {visible: true});
                        domUtils.triggerShownEvent(this._$container)
                    }
                    else {
                        this._$container.hide();
                        this.notifyObserver("recurrenceEditorVisibylityChanged", {visible: false})
                    }
                },
                _handleDefaults: function() {
                    this._recurrenceRule.makeRule("freq", "DAILY");
                    this._changeEditorValue()
                },
                _changeEditorValue: function() {
                    this.option("value", this._recurrenceRule.recurrenceString() || "")
                },
                _renderEditors: function() {
                    this._renderFreqEditor();
                    this._renderIntervalEditor();
                    this._renderRepeatOnEditor();
                    this._renderRepeatEndSwitch();
                    this._renderRepeatEndEditor();
                    this._renderRepeatEndVisibility(!!this._recurrenceRule.repeatableRule())
                },
                _renderFreqEditor: function() {
                    var freq = this._recurrenceRule.rules().freq || "DAILY";
                    var $freqEditor = $("<div>").addClass(FREQUENCY_EDITOR).addClass(FIELD_VALUE_CLASS);
                    this._freqEditor = this._createComponent($freqEditor, RadioGroup, {
                        field: "freq",
                        items: frequencies,
                        value: freq,
                        valueExpr: "value",
                        displayExpr: "text",
                        layout: "horizontal",
                        onValueChanged: $.proxy(this._valueChangedHandler, this)
                    });
                    var $field = $("<div>").addClass(FIELD_CLASS).append($freqEditor);
                    this._$container.append($field)
                },
                _renderIntervalEditor: function() {
                    var freq = this._recurrenceRule.rules().freq || "DAILY";
                    var $intervalEditor = $("<div>").addClass(INTERVAL_EDITOR).addClass(FIELD_VALUE_CLASS);
                    var $intervalEditorLabel = $("<div>").text(Globalize.localize("dxScheduler-recurrenceEvery") + ":").addClass(INTERVAL_EDITOR + LABEL_POSTFIX).addClass(FIELD_LABEL_CLASS);
                    this._$intervalTypeLabel = $("<div>").text(Globalize.localize("dxScheduler-recurrenceRepeat" + freq.charAt(0).toUpperCase() + freq.substr(1).toLowerCase())).addClass(REPEAT_TYPE_EDITOR + LABEL_POSTFIX);
                    var interval = this._recurrenceRule.rules().interval || 1;
                    this._intervalEditor = this._createComponent($intervalEditor, NumberBox, {
                        field: "interval",
                        min: 1,
                        value: interval,
                        showSpinButtons: true,
                        useTouchSpinButtons: false,
                        onValueChanged: $.proxy(this._valueChangedHandler, this)
                    });
                    var $field = $("<div>").addClass(FIELD_CLASS).addClass(INTERVAL_EDITOR_FIELD).append($intervalEditorLabel, $intervalEditor, this._$intervalTypeLabel);
                    this._$container.append($field);
                    this._setAriaDescribedBy(this._intervalEditor, $intervalEditorLabel)
                },
                _renderRepeatOnEditor: function() {
                    var freq = this._recurrenceRule.rules().freq;
                    if (!commonUtils.isDefined(this._$repeatOnEditor))
                        this._$repeatOnEditor = $("<div>").addClass(REPEAT_ON_EDITOR).addClass(FIELD_CLASS).appendTo(this._$container);
                    if (!freq || freq === "DAILY") {
                        this._clearRepeatOnEditor();
                        this._clearRepeatOnLabel();
                        return
                    }
                    if (!commonUtils.isDefined(this._$repeatOnLabel))
                        this._renderRepeatOnLabel(this._$repeatOnEditor);
                    if (freq === "WEEKLY" && !this._$repeatOnWeek) {
                        this._renderRepeatOnWeekEditor();
                        return
                    }
                    if (freq === "MONTHLY" && !this._$repeatOnMonth) {
                        this._renderRepeatOnMonthEditor();
                        return
                    }
                    if (freq === "YEARLY" && !this._$repeatOnYear) {
                        this._renderRepeatOnYearEditor();
                        return
                    }
                },
                _renderRepeatOnLabel: function($element) {
                    this._$repeatOnLabel = $("<div>").text(Globalize.localize("dxScheduler-recurrenceOn") + ":").addClass(REPEAT_ON_EDITOR + LABEL_POSTFIX).addClass(FIELD_LABEL_CLASS);
                    $element.append(this._$repeatOnLabel)
                },
                _clearRepeatOnEditor: function() {
                    if (commonUtils.isDefined(this._$repeatOnWeek)) {
                        this._$repeatOnWeek.detach();
                        this._$repeatOnWeek.remove();
                        delete this._$repeatOnWeek
                    }
                    if (commonUtils.isDefined(this._$repeatOnMonth)) {
                        this._$repeatOnMonth.detach();
                        this._$repeatOnMonth.remove();
                        delete this._$repeatOnMonth
                    }
                    if (commonUtils.isDefined(this._$repeatOnYear)) {
                        this._$repeatOnYear.detach();
                        this._$repeatOnYear.remove();
                        delete this._$repeatOnYear
                    }
                },
                _clearRepeatOnEditorValues: function() {
                    this._recurrenceRule.makeRule("bymonth", "");
                    this._recurrenceRule.makeRule("bymonthday", "");
                    this._recurrenceRule.makeRule("byday", "")
                },
                _clearRepeatOnLabel: function() {
                    if (commonUtils.isDefined(this._$repeatOnLabel)) {
                        this._$repeatOnLabel.detach();
                        this._$repeatOnLabel.remove();
                        delete this._$repeatOnLabel
                    }
                },
                _renderRepeatOnWeekEditor: function() {
                    this._clearRepeatOnEditor();
                    this._$repeatOnWeek = $("<div>").addClass(REPEAT_ON_WEEK_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo(this._$repeatOnEditor);
                    var localDaysNames = Globalize.culture().calendar.days.namesShort,
                        daysFromRules = this._daysOfWeekByRules();
                    this._daysOfWeek = [];
                    for (var i = 0; i < 7; i++) {
                        var checkBoxText = localDaysNames[i].toUpperCase(),
                            dayName = days[i];
                        var $day = $("<div>").addClass(DAY_OF_WEEK),
                            day = this._createComponent($day, CheckBox, {
                                text: checkBoxText,
                                value: $.inArray(dayName, daysFromRules) > -1 ? true : false,
                                onValueChanged: $.proxy(this._repeatByDayValueChangeHandler, this)
                            });
                        this._daysOfWeek[i] = day;
                        this._$repeatOnWeek.append($day)
                    }
                },
                _daysOfWeekByRules: function() {
                    var daysByRule = this._recurrenceRule.daysFromByDayRule();
                    if (!daysByRule.length)
                        daysByRule = [days[this.option("startDate").getDay()]];
                    return daysByRule
                },
                _repeatByDayValueChangeHandler: function() {
                    var byDayRule = "";
                    $.each(this._daysOfWeek, function(index, day) {
                        if (day.option("value")) {
                            var dayName = days[index];
                            if (!byDayRule)
                                byDayRule = dayName;
                            else
                                byDayRule = byDayRule + "," + dayName
                        }
                    });
                    this._recurrenceRule.makeRule("byday", byDayRule);
                    this._changeEditorValue()
                },
                _renderRepeatOnMonthEditor: function() {
                    this._clearRepeatOnEditor();
                    this._$repeatOnMonth = $("<div>").addClass(REPEAT_ON_MONTH_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo(this._$repeatOnEditor);
                    this._renderDayOfMonthEditor(this._$repeatOnMonth)
                },
                _renderRepeatOnYearEditor: function() {
                    this._clearRepeatOnEditor();
                    this._$repeatOnYear = $("<div>").addClass(REPEAT_ON_YEAR_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo(this._$repeatOnEditor);
                    var months = [],
                        monthsNames = Globalize.culture().calendar.months.names;
                    for (var i = 0; i < 12; i++)
                        months[i] = {
                            value: String(i + 1),
                            text: monthsNames[i]
                        };
                    var bymonth = this._monthOfYearByRules();
                    var $monthOfYear = $("<div>").addClass(MONTH_OF_YEAR).appendTo(this._$repeatOnYear);
                    var monthChanged = function(args) {
                            this._valueChangedHandler.call(this, args);
                            var monthValue = parseInt(args.component.option("value"));
                            if (this._dayEditor && monthValue) {
                                var maxAllowedDay = new Date((new Date).getFullYear(), parseInt(monthValue), 0).getDate();
                                if (monthValue === 2)
                                    maxAllowedDay = 29;
                                this._dayEditor.option("max", maxAllowedDay)
                            }
                        };
                    this._monthEditor = this._createComponent($monthOfYear, SelectBox, {
                        field: "bymonth",
                        items: months,
                        value: bymonth,
                        displayExpr: "text",
                        valueExpr: "value",
                        onValueChanged: $.proxy(monthChanged, this)
                    });
                    this._renderDayOfMonthEditor(this._$repeatOnYear)
                },
                _monthOfYearByRules: function() {
                    var monthByRule = this._recurrenceRule.rules().bymonth;
                    if (!monthByRule)
                        monthByRule = this.option("startDate").getMonth();
                    return monthByRule
                },
                _renderDayOfMonthEditor: function($element) {
                    var bymonthday = this._dayOfMonthByRules();
                    var $dayEditor = $("<div>").addClass(DAY_OF_MONTH);
                    this._dayEditor = this._createComponent($dayEditor, NumberBox, {
                        field: "bymonthday",
                        min: 1,
                        max: 31,
                        showSpinButtons: true,
                        useTouchSpinButtons: false,
                        value: bymonthday,
                        onValueChanged: $.proxy(this._valueChangedHandler, this)
                    });
                    $element.append($dayEditor)
                },
                _dayOfMonthByRules: function() {
                    var dayByRule = this._recurrenceRule.rules().bymonthday;
                    if (!dayByRule)
                        dayByRule = this.option("startDate").getDate();
                    return dayByRule
                },
                _setAriaDescribedBy: function(editor, $label) {
                    var labelId = "label-" + new DevExpress.data.Guid;
                    editor.setAria("describedby", labelId);
                    editor.setAria("id", labelId, $label)
                },
                _renderRepeatEndSwitch: function() {
                    var that = this;
                    var $switchEndEditor = $("<div>").addClass(SWITCH_REPEAT_END_EDITOR).addClass(FIELD_VALUE_CLASS),
                        $switchEndLabel = $("<div>").text(Globalize.localize("dxScheduler-recurrenceEnd") + ":").addClass(INTERVAL_EDITOR + LABEL_POSTFIX).addClass(FIELD_LABEL_CLASS);
                    this._switchEndEditor = this._createComponent($switchEndEditor, Switch, {
                        value: that._recurrenceRule.repeatableRule() ? true : false,
                        onValueChanged: $.proxy(this._repeatEndSwitchValueChangeHandler, this)
                    });
                    $("<div>").addClass(FIELD_CLASS).addClass(REPEAT_END_EDITOR_FIELD).append($switchEndLabel, $switchEndEditor).appendTo(this._$container);
                    this._setAriaDescribedBy(this._switchEndEditor, $switchEndLabel)
                },
                _repeatEndSwitchValueChangeHandler: function(args) {
                    var value = args.value;
                    this._renderRepeatEndVisibility(value);
                    if (!this._recurrenceRule.rules().count && !this._recurrenceRule.rules().until && value)
                        this._handleRepeatEndDefaults();
                    else if (!value) {
                        this._recurrenceRule.makeRule("count", "");
                        this._recurrenceRule.makeRule("until", "");
                        this._changeEditorValue()
                    }
                },
                _renderRepeatEndVisibility: function(value) {
                    if (!value)
                        this._$repeatEndEditor.hide();
                    else
                        this._$repeatEndEditor.show()
                },
                _handleRepeatEndDefaults: function() {
                    this._recurrenceRule.makeRule("count", 1);
                    this._changeEditorValue()
                },
                _renderRepeatEndEditor: function(rule) {
                    rule = commonUtils.isDefined(rule) ? rule : this._recurrenceRule.repeatableRule();
                    if (!rule)
                        rule = "count";
                    if (!commonUtils.isDefined(this._$repeatEndEditor)) {
                        this._$repeatEndEditor = $("<div>").addClass(REPEAT_END_EDITOR_CONTAINER).addClass(FIELD_CLASS).appendTo(this._$container);
                        this._renderRepeatEndTypeEditor()
                    }
                },
                _renderRepeatEndTypeEditor: function() {
                    var repeatType = this._recurrenceRule.repeatableRule() || "count",
                        that = this;
                    this._$repeatTypeEditor = $("<div>").addClass(REPEAT_TYPE_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo(this._$repeatEndEditor);
                    this._repeatTypeEditor = this._createComponent(this._$repeatTypeEditor, RadioGroup, {
                        items: repeatEndTypes,
                        value: repeatType,
                        displayExpr: "text",
                        valueExpr: "value",
                        itemTemplate: function(itemData) {
                            if (itemData.value === "count")
                                return that._renderRepeatCountEditor();
                            else
                                return that._renderRepeatUntilEditor()
                        },
                        layout: "vertical",
                        onValueChanged: $.proxy(this._repeatTypeValueChangedHandler, this)
                    });
                    this._disableRepeatEndParts(repeatType)
                },
                _repeatTypeValueChangedHandler: function(args) {
                    var value = args.value;
                    this._disableRepeatEndParts(value);
                    if (value === "until")
                        this._recurrenceRule.makeRule(value, this._repeatUntilDate.option("value"));
                    else if (value === "count")
                        this._recurrenceRule.makeRule(value, this._repeatCountEditor.option("value"));
                    this._changeEditorValue()
                },
                _disableRepeatEndParts: function(value) {
                    if (value === "until") {
                        this._repeatCountEditor.option("disabled", true);
                        this._repeatUntilDate.option("disabled", false)
                    }
                    else if (value === "count") {
                        this._repeatCountEditor.option("disabled", false);
                        this._repeatUntilDate.option("disabled", true)
                    }
                },
                _renderRepeatCountEditor: function() {
                    var repeatCount = this._recurrenceRule.rules().count || 1,
                        $editorTemplate = $("<div>");
                    $("<div>").text(Globalize.localize("dxScheduler-recurrenceAfter") + ":").addClass(REPEAT_END_EDITOR + LABEL_POSTFIX).appendTo($editorTemplate);
                    this._$repeatCountEditor = $("<div>").addClass(REPEAT_COUNT_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo($editorTemplate);
                    $("<div>").text(Globalize.localize("dxScheduler-recurrenceRepeatCount")).addClass(REPEAT_END_EDITOR + LABEL_POSTFIX).appendTo($editorTemplate);
                    this._repeatCountEditor = this._createComponent(this._$repeatCountEditor, NumberBox, {
                        field: "count",
                        min: 1,
                        showSpinButtons: true,
                        useTouchSpinButtons: false,
                        value: repeatCount,
                        onValueChanged: $.proxy(this._repeatCountValueChangeHandler, this)
                    });
                    return $editorTemplate
                },
                _repeatCountValueChangeHandler: function(args) {
                    if (this._recurrenceRule.repeatableRule() !== "count")
                        return;
                    var value = args.value;
                    this._recurrenceRule.makeRule("count", value);
                    this._changeEditorValue()
                },
                _formatUntilDate: function(date) {
                    var result = dateUtils.trimTime(date);
                    result.setDate(result.getDate() + 1);
                    return new Date(result.getTime() - 1)
                },
                _renderRepeatUntilEditor: function() {
                    var repeatUntil = this._recurrenceRule.rules().until || this._formatUntilDate(new Date),
                        $editorTemplate = $("<div>");
                    $("<div>").text(Globalize.localize("dxScheduler-recurrenceOn") + ":").addClass(REPEAT_END_EDITOR + LABEL_POSTFIX).appendTo($editorTemplate);
                    this._$repeatDateEditor = $("<div>").addClass(REPEAT_UNTIL_DATE_EDITOR).addClass(FIELD_VALUE_CLASS).appendTo($editorTemplate);
                    this._repeatUntilDate = this._createComponent(this._$repeatDateEditor, DateBox, {
                        field: "until",
                        value: repeatUntil,
                        format: "date",
                        onValueChanged: $.proxy(this._repeatUntilValueChangeHandler, this)
                    });
                    return $editorTemplate
                },
                _repeatUntilValueChangeHandler: function(args) {
                    if (this._recurrenceRule.repeatableRule() !== "until")
                        return;
                    var untilDate = this._formatUntilDate(new Date(args.value));
                    this._repeatUntilDate.option("value", untilDate);
                    this._recurrenceRule.makeRule("until", untilDate);
                    this._changeEditorValue()
                },
                _valueChangedHandler: function(args) {
                    var value = args.component.option("value"),
                        field = args.component.option("field");
                    if (field === "freq")
                        this._clearRepeatOnEditorValues();
                    this._recurrenceRule.makeRule(field, value);
                    this._makeRepeatOnRule(field, value);
                    this._changeEditorValue()
                },
                _makeRepeatOnRule: function(field, value) {
                    if (field !== "freq" || value === "DAILY")
                        return;
                    if (value === "WEEKLY")
                        this._recurrenceRule.makeRule("byday", this._daysOfWeekByRules());
                    if (value === "MONTHLY")
                        this._recurrenceRule.makeRule("bymonthday", this._dayOfMonthByRules());
                    if (value === "YEARLY") {
                        this._recurrenceRule.makeRule("bymonthday", this._dayOfMonthByRules());
                        this._recurrenceRule.makeRule("bymonth", this._monthOfYearByRules())
                    }
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"value":
                            this._recurrenceRule.makeRules(args.value);
                            this._switchEditor.option("value", !!args.value);
                            this._switchEndEditor.option("value", !!this._recurrenceRule.repeatableRule());
                            this._repeatTypeEditor.option("value", this._recurrenceRule.repeatableRule() || "count");
                            this._renderRepeatEndEditor();
                            this._renderRepeatOnEditor();
                            this._changeEditorsValues(this._recurrenceRule.rules());
                            this.callBase(args);
                            break;
                        case"startDate":
                            this._clearRepeatOnEditor();
                            this._renderRepeatOnEditor();
                            this._makeRepeatOnRule("freq", this._recurrenceRule.rules().freq);
                            if (commonUtils.isDefined(this._recurrenceRule.recurrenceString()))
                                this._changeEditorValue();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _changeEditorsValues: function(rules) {
                    this._freqEditor.option("value", rules.freq);
                    this._changeRepeatTypeLabel();
                    this._intervalEditor.option("value", rules.interval);
                    this._changeRepeatCountValue();
                    this._changeRepeatUntilValue();
                    this._changeCheckBoxesValue();
                    this._changeDayOfMonthValue();
                    this._changeMonthOfYearValue()
                },
                _changeRepeatTypeLabel: function() {
                    var $labels = this.element().find("." + REPEAT_TYPE_EDITOR + LABEL_POSTFIX);
                    if (!$labels.length)
                        return;
                    var freq = this._recurrenceRule.rules().freq || "DAILY";
                    $.each($labels, function(_, $label) {
                        $($label).text(Globalize.localize("dxScheduler-recurrenceRepeat" + freq.charAt(0).toUpperCase() + freq.substr(1).toLowerCase()))
                    })
                },
                _changeRepeatCountValue: function() {
                    if (!this._$repeatCountEditor)
                        return;
                    var count = this._recurrenceRule.rules().count || 1;
                    this._repeatCountEditor.option("value", count)
                },
                _changeRepeatUntilValue: function() {
                    if (!this._$repeatDateEditor)
                        return;
                    var date = this._recurrenceRule.rules().until || this._formatUntilDate(new Date);
                    this._repeatUntilDate.option("value", date)
                },
                _changeCheckBoxesValue: function() {
                    if (!this._$repeatOnWeek)
                        return;
                    var daysByRule = this._daysOfWeekByRules();
                    $.each(this._daysOfWeek, function(index, day) {
                        var dayName = days[index];
                        day.option("value", $.inArray(dayName, daysByRule) > -1)
                    })
                },
                _changeDayOfMonthValue: function() {
                    if (!this._$repeatOnMonth && !this._$repeatOnYear)
                        return;
                    var day = this._dayOfMonthByRules() || 1;
                    this._dayEditor.option("value", day)
                },
                _changeMonthOfYearValue: function() {
                    if (!this._$repeatOnYear)
                        return;
                    var month = this._monthOfYearByRules() || 1;
                    this._monthEditor.option("value", month)
                },
                toggle: function() {
                    this._switchEditor.element().trigger("dxclick")
                },
                setAria: function() {
                    if (this._switchEditor)
                        this._switchEditor.setAria(arguments[0], arguments[1])
                }
            }).include(publisherMixin);
        registerComponent("dxSchedulerRecurrenceEditor", {}, SchedulerRecurrenceEditor);
        return SchedulerRecurrenceEditor
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.recurrenceEditor"]);
    /*! Module widgets-web, file ui.scheduler.navigator.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.navigator", ["jquery", "/ui/ui.errors", "/utils/utils.date", "/componentRegistrator", "/devices", "/ui/ui.widget", "/ui/widgets/ui.button", "/ui/widgets/date/ui.calendar", "/ui/widgets/scheduler/ui.scheduler.publisherMixin"], function($, errors, dateUtils, registerComponent, devices, Widget, Button, Calendar, publisherMixin) {
        var ELEMENT_CLASS = "dx-scheduler-navigator",
            CALENDAR_CLASS = "dx-scheduler-navigator-calendar",
            NEXT_BUTTON_CLASS = "dx-scheduler-navigator-next",
            CAPTION_BUTTON_CLASS = "dx-scheduler-navigator-caption",
            PREVIOUS_BUTTON_CLASS = "dx-scheduler-navigator-previous";
        var getWeekCaption = function(date, shift, rejectWeekend) {
                var firstWeekDate = dateUtils.getFirstWeekDate(date, shift ? this.option("firstDayOfWeek") || 1 : this.option("firstDayOfWeek")),
                    format = this.option("_useShortDateFormat") ? "d MMM yyyy" : "d MMMM yyyy",
                    weekendDuration = 2;
                if (rejectWeekend)
                    firstWeekDate = dateUtils.normalizeDateByWeek(firstWeekDate, date);
                if (this.option("firstDayOfWeek") >= 6 && rejectWeekend)
                    firstWeekDate.setDate(firstWeekDate.getDate() + (7 - this.option("firstDayOfWeek") + 1));
                var lastWeekDate = new Date(firstWeekDate);
                shift = shift || 6;
                lastWeekDate = new Date(lastWeekDate.setDate(lastWeekDate.getDate() + shift));
                if (lastWeekDate.getDay() % 6 === 0 && rejectWeekend)
                    lastWeekDate.setDate(lastWeekDate.getDate() + weekendDuration);
                return Globalize.format(firstWeekDate, " d") + "-" + Globalize.format(lastWeekDate, format)
            };
        var dateGetter = function(date, offset) {
                return new Date(date[this.setter](date[this.getter]() + offset))
            };
        var CONFIG = {
                day: {
                    duration: 1,
                    setter: "setDate",
                    getter: "getDate",
                    getDate: dateGetter,
                    getCaption: function(date) {
                        return Globalize.format(date, "d MMMM yyyy")
                    }
                },
                week: {
                    duration: 7,
                    setter: "setDate",
                    getter: "getDate",
                    getDate: dateGetter,
                    getCaption: getWeekCaption
                },
                workWeek: {
                    duration: 7,
                    setter: "setDate",
                    getter: "getDate",
                    getDate: dateGetter,
                    getCaption: function(date) {
                        return getWeekCaption.call(this, date, 4, true)
                    }
                },
                month: {
                    duration: 1,
                    setter: "setMonth",
                    getter: "getMonth",
                    getDate: function(date, offset) {
                        var currentDate = date.getDate();
                        date.setDate(1);
                        date = dateGetter.call(this, date, offset);
                        var lastDate = dateUtils.getLastMonthDay(date);
                        date.setDate(currentDate < lastDate ? currentDate : lastDate);
                        return date
                    },
                    getCaption: function(date) {
                        return Globalize.format(date, "MMMM yyyy")
                    }
                }
            };
        var SchedulerNavigator = Widget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            date: new Date,
                            step: "day",
                            min: undefined,
                            max: undefined,
                            firstDayOfWeek: undefined,
                            _useShortDateFormat: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return !devices.real().generic || devices.isSimulator()
                                },
                                options: {_useShortDateFormat: true}
                            }])
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"step":
                        case"date":
                            this._updateButtonsState();
                            this._renderCaption();
                            this._setCalendarOption("value", this.option("date"));
                            break;
                        case"min":
                        case"max":
                            this._updateButtonsState();
                            this._setCalendarOption(args.name, args.value);
                            break;
                        case"firstDayOfWeek":
                            this._setCalendarOption(args.name, args.value);
                            break;
                        case"tabIndex":
                        case"focusStateEnabled":
                            this._next.option(args.name, args.value);
                            this._caption.option(args.name, args.value);
                            this._prev.option(args.name, args.value);
                            this._setCalendarOption(args.name, args.value);
                            this.callBase(args);
                            break;
                        case"_useShortDateFormat":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _init: function() {
                    this.callBase();
                    this.element().addClass(ELEMENT_CLASS);
                    this._initButtons()
                },
                _initButtons: function() {
                    var $next = $("<div>").addClass(NEXT_BUTTON_CLASS);
                    this._next = this._createComponent($next, Button, {
                        icon: "chevronnext",
                        onClick: $.proxy(this._updateCurrentDate, this, 1),
                        focusStateEnabled: this.option("focusStateEnabled"),
                        tabIndex: this.option("tabIndex"),
                        _templates: {}
                    });
                    var $caption = $("<div>").addClass(CAPTION_BUTTON_CLASS);
                    this._caption = this._createComponent($caption, Button, {
                        focusStateEnabled: this.option("focusStateEnabled"),
                        tabIndex: this.option("tabIndex"),
                        _templates: {}
                    });
                    var $prev = $("<div>").addClass(PREVIOUS_BUTTON_CLASS);
                    this._prev = this._createComponent($prev, Button, {
                        icon: "chevronprev",
                        onClick: $.proxy(this._updateCurrentDate, this, -1),
                        focusStateEnabled: this.option("focusStateEnabled"),
                        tabIndex: this.option("tabIndex"),
                        _templates: {}
                    });
                    this.setAria("label", "Next period", $next);
                    this.setAria("label", "Previous period", $prev);
                    this._updateButtonsState();
                    this.element().append($prev, $caption, $next)
                },
                _updateButtonsState: function() {
                    var stepConfig = this._getConfig(),
                        date = this.option("date"),
                        min = this.option("min"),
                        max = this.option("max");
                    this._prev.option("disabled", min && date[stepConfig.getter]() === min[stepConfig.getter]());
                    this._next.option("disabled", max && date[stepConfig.getter]() === max[stepConfig.getter]())
                },
                _updateCurrentDate: function(direction) {
                    var stepConfig = this._getConfig(),
                        offset = stepConfig.duration * direction,
                        date = stepConfig.getDate(new Date(this.option("date")), offset);
                    date = dateUtils.normalizeDate(date, this.option("min"), this.option("max"));
                    this.notifyObserver("currentDateUpdated", date)
                },
                _renderFocusTarget: $.noop,
                _render: function() {
                    this.callBase();
                    this._renderPopover();
                    this._renderCaption();
                    this._renderCaptionKeys()
                },
                _renderPopover: function() {
                    this._popover = this._createComponent("<div>", "dxPopover", {
                        target: this._caption.element(),
                        onContentReady: $.proxy(this._popoverContentReadyHandler, this)
                    });
                    this._popover.element().appendTo(this.element())
                },
                _popoverContentReadyHandler: function() {
                    this._calendar = this._createComponent($("<div>"), Calendar, this._calendarOptions());
                    this._calendar.element().addClass(CALENDAR_CLASS);
                    this._popover.content().append(this._calendar.element())
                },
                _calendarOptions: function() {
                    return {
                            min: this.option("min"),
                            max: this.option("max"),
                            firstDayOfWeek: this.option("firstDayOfWeek"),
                            value: this.option("date"),
                            focusStateEnabled: this.option("focusStateEnabled"),
                            onValueChanged: $.proxy(function(e) {
                                if (!this.option("visible"))
                                    return;
                                this.notifyObserver("currentDateUpdated", e.value);
                                this._popover.hide()
                            }, this),
                            hasFocus: function() {
                                return true
                            },
                            tabIndex: null,
                            _keyboardProcessor: this._calendarKeyboardProcessor
                        }
                },
                _renderCaption: function() {
                    var date = this.option("date"),
                        caption = this._getConfig().getCaption.call(this, date);
                    this._caption.option({
                        text: caption,
                        onClick: $.proxy(function() {
                            this._popover.toggle()
                        }, this)
                    })
                },
                _renderCaptionKeys: function() {
                    if (!this.option("focusStateEnabled") || this.option("disabled"))
                        return;
                    this._calendarKeyboardProcessor = this._caption._keyboardProcessor.attachChildProcessor();
                    this._setCalendarOption("_keyboardProcessor", this._calendarKeyboardProcessor);
                    var keyboardHandler = $.proxy(function(e) {
                            if (this._popover.content().is(":hidden"))
                                this._popover.show();
                            else
                                return true
                        }, this);
                    this._caption.registerKeyHandler("enter", keyboardHandler);
                    this._caption.registerKeyHandler("space", keyboardHandler)
                },
                _setCalendarOption: function(name, value) {
                    if (this._calendar)
                        this._calendar.option(name, value)
                },
                _getConfig: function() {
                    var step = this.option("step"),
                        config = CONFIG[step];
                    if (!config)
                        throw errors.Error("E1033", step);
                    return config
                }
            }).include(publisherMixin);
        registerComponent("dxSchedulerNavigator", {}, SchedulerNavigator);
        return SchedulerNavigator
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.navigator"]);
    /*! Module widgets-web, file ui.scheduler.header.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.header", ["jquery", "/utils/utils.common", "/utils/utils.inflector", "/componentRegistrator", "/ui/ui.widget", "/ui/widgets/scheduler/ui.scheduler.publisherMixin", "/ui/widgets/scheduler/ui.scheduler.navigator"], function($, commonUtils, inflector, registerComponent, Widget, publisherMixin, SchedulerNavigator) {
        var camelize = inflector.camelize;
        var COMPONENT_CLASS = "dx-scheduler-header",
            VIEW_SWITCHER_CLASS = "dx-scheduler-view-switcher",
            VIEW_SWITCHER_LABEL_CLASS = "dx-scheduler-view-switcher-label";
        var STEP_MAP = {
                day: "day",
                week: "week",
                workWeek: "workWeek",
                month: "month",
                timelineDay: "day",
                timelineWeek: "week",
                timelineWorkWeek: "workWeek",
                timelineMonth: "month"
            };
        var SchedulerHeader = Widget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            views: [],
                            currentView: "day",
                            firstDayOfWeek: undefined,
                            currentDate: new Date,
                            min: undefined,
                            max: undefined,
                            useDropDownViewSwitcher: false
                        })
                },
                _optionChanged: function(args) {
                    var value = args.value;
                    switch (args.name) {
                        case"views":
                            this._viewSwitcher.option("items", value);
                            break;
                        case"currentView":
                            this._viewSwitcher.option("selectedItem", value);
                            this._navigator.option("step", STEP_MAP[value]);
                            this._changeViewSwitcherLabelText();
                            break;
                        case"currentDate":
                            this._navigator.option("date", value);
                            break;
                        case"min":
                        case"max":
                        case"firstDayOfWeek":
                            this._navigator.option(args.name, value);
                            break;
                        case"tabIndex":
                        case"focusStateEnabled":
                            this._viewSwitcher.option(args.name, value);
                            this._navigator.option(args.name, value);
                            this.callBase(args);
                            break;
                        case"useDropDownViewSwitcher":
                            this._refreshViewSwitcher();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _init: function() {
                    this.callBase();
                    this.element().addClass(COMPONENT_CLASS)
                },
                _render: function() {
                    this.callBase();
                    this._renderNavigator();
                    this._renderViewSwitcher()
                },
                _renderNavigator: function() {
                    this._navigator = this._createComponent("<div>", SchedulerNavigator, {
                        min: this.option("min"),
                        max: this.option("max"),
                        date: this.option("currentDate"),
                        step: STEP_MAP[this.option("currentView")],
                        firstDayOfWeek: this.option("firstDayOfWeek"),
                        tabIndex: this.option("tabIndex"),
                        focusStateEnabled: this.option("focusStateEnabled"),
                        observer: this.option("observer")
                    });
                    this._navigator.element().appendTo(this.element())
                },
                _renderViewSwitcher: function() {
                    var $viewSwitcher = $("<div>").addClass(VIEW_SWITCHER_CLASS).appendTo(this.element());
                    if (!this.option("useDropDownViewSwitcher"))
                        this._renderViewSwitcherTabs($viewSwitcher);
                    else
                        this._renderViewSwitcherDropDownMenu($viewSwitcher)
                },
                _renderViewSwitcherTabs: function($element) {
                    this._viewSwitcher = this._createComponent($element, "dxTabs", {
                        selectionRequired: true,
                        scrollingEnabled: false,
                        onSelectionChanged: $.proxy(this._updateCurrentView, this),
                        items: this.option("views"),
                        itemTemplate: function(item) {
                            return $("<span>").addClass("dx-tab-text").text(Globalize.localize("dxScheduler-switcher" + camelize(item, true)))
                        },
                        selectedItem: this.option("currentView"),
                        tabIndex: this.option("tabIndex"),
                        focusStateEnabled: this.option("focusStateEnabled")
                    })
                },
                _refreshViewSwitcher: function() {
                    this._viewSwitcher._dispose();
                    this._viewSwitcher.element().remove();
                    delete this._viewSwitcher;
                    this._removeViewSwitcherLabel();
                    this._renderViewSwitcher()
                },
                _removeViewSwitcherLabel: function() {
                    if (commonUtils.isDefined(this._$viewSwitcherLabel)) {
                        this._$viewSwitcherLabel.detach();
                        this._$viewSwitcherLabel.remove();
                        delete this._$viewSwitcherLabel
                    }
                },
                _renderViewSwitcherDropDownMenu: function($element) {
                    this._$viewSwitcherLabel = $("<div>").addClass(VIEW_SWITCHER_LABEL_CLASS).appendTo(this.element());
                    this._changeViewSwitcherLabelText();
                    this._viewSwitcher = this._createComponent($element, "dxDropDownMenu", {
                        onItemClick: $.proxy(this._updateCurrentView, this),
                        items: this.option("views"),
                        itemTemplate: function(item) {
                            return $("<span>").addClass("dx-dropdownmenu-item-text").text(Globalize.localize("dxScheduler-switcher" + camelize(item, true)))
                        }
                    })
                },
                _changeViewSwitcherLabelText: function() {
                    if (!commonUtils.isDefined(this._$viewSwitcherLabel))
                        return;
                    var currentViewText = Globalize.localize("dxScheduler-switcher" + camelize(this.option("currentView"), true));
                    this._$viewSwitcherLabel.text(currentViewText)
                },
                _updateCurrentView: function(e) {
                    var selectedItem = e.itemData || e.component.option("selectedItem");
                    this.notifyObserver("currentViewUpdated", selectedItem)
                },
                _renderFocusTarget: $.noop
            }).include(publisherMixin);
        registerComponent("dxSchedulerHeader", {}, SchedulerHeader);
        return SchedulerHeader
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.header"]);
    /*! Module widgets-web, file ui.scheduler.workSpace.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.workSpace", ["jquery", "/ui/uiNamespace", "/utils/utils.date", "/ui/ui.widget", "/utils/utils.common", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.publisherMixin", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer"], function($, ui, dateUtils, Widget, commonUtils, registerComponent, publisherMixin, eventUtils, pointerEvents) {
        var abstract = Widget.abstract,
            toMs = dateUtils.dateToMilliseconds;
        var COMPONENT_CLASS = "dx-scheduler-work-space",
            GROUPED_WORKSPACE_CLASS = "dx-scheduler-work-space-grouped",
            WORKSPACE_WITH_BOTH_SCROLLS_CLASS = "dx-scheduler-work-space-both-scrollbar",
            TIME_PANEL_CLASS = "dx-scheduler-time-panel",
            TIME_PANEL_CELL_CLASS = "dx-scheduler-time-panel-cell",
            TIME_PANEL_ROW_CLASS = "dx-scheduler-time-panel-row",
            ALL_DAY_PANEL_CLASS = "dx-scheduler-all-day-panel",
            ALL_DAY_TABLE_CLASS = "dx-scheduler-all-day-table",
            FIXED_CONTAINER_CLASS = "dx-scheduler-fixed-appointments",
            ALL_DAY_CONTAINER_CLASS = "dx-scheduler-all-day-appointments",
            ALL_DAY_TITLE_CLASS = "dx-scheduler-all-day-title",
            ALL_DAY_TITLE_HIDDEN_CLASS = "dx-scheduler-all-day-title-hidden",
            ALL_DAY_TABLE_CELL_CLASS = "dx-scheduler-all-day-table-cell",
            ALL_DAY_TABLE_ROW_CLASS = "dx-scheduler-all-day-table-row",
            WORKSPACE_WITH_ALL_DAY_CLASS = "dx-scheduler-work-space-all-day",
            WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS = "dx-scheduler-work-space-all-day-collapsed",
            HEADER_PANEL_CLASS = "dx-scheduler-header-panel",
            HEADER_PANEL_CELL_CLASS = "dx-scheduler-header-panel-cell",
            HEADER_ROW_CLASS = "dx-scheduler-header-row",
            GROUP_ROW_CLASS = "dx-scheduler-group-row",
            GROUP_HEADER_CLASS = "dx-scheduler-group-header",
            GROUP_HEADER_CONTENT_CLASS = "dx-scheduler-group-header-content",
            DATE_TABLE_CLASS = "dx-scheduler-date-table",
            DATE_TABLE_CELL_CLASS = "dx-scheduler-date-table-cell",
            DATE_TABLE_ROW_CLASS = "dx-scheduler-date-table-row",
            DATE_TABLE_CURRENT_DATE_CLASS = "dx-scheduler-date-table-current-date",
            DATE_TABLE_OTHER_MONTH_DATE_CLASS = "dx-scheduler-date-table-other-month",
            DATE_TABLE_DROPPABLE_CELL_CLASS = "dx-scheduler-date-table-droppable-cell",
            SCHEDULER_HEADER_SCROLLABLE_CLASS = "dx-scheduler-header-scrollable",
            SCHEDULER_SIDEBAR_SCROLLABLE_CLASS = "dx-scheduler-sidebar-scrollable",
            SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS = "dx-scheduler-date-table-scrollable",
            SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME = eventUtils.addNamespace(pointerEvents.down, "dxSchedulerWorkSpace"),
            SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME = eventUtils.addNamespace("dxdragenter", "dxSchedulerDateTable"),
            SCHEDULER_CELL_DXDROP_EVENT_NAME = eventUtils.addNamespace("dxdrop", "dxSchedulerDateTable"),
            SCHEDULER_CELL_DXCLICK_EVENT_NAME = eventUtils.addNamespace("dxclick", "dxSchedulerDateTable"),
            CELL_DATA = "dxCellData";
        var SchedulerWorkSpace = Widget.inherit({
                _supportedKeys: function() {
                    var isRTL = this.option("rtlEnabled");
                    var click = function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            if (this._$focusedCell && this._$focusedCell.length)
                                this._showAddAppointmentPopup(this._$focusedCell)
                        };
                    return $.extend(this.callBase(), {
                            enter: click,
                            space: click,
                            downArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                var cellIndex = this._getFocusedCell().index(),
                                    $row = this._getFocusedCell().parent(),
                                    $cell = $row.next().children().eq(cellIndex);
                                this._moveToCell($cell)
                            },
                            upArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                var cellIndex = this._getFocusedCell().index(),
                                    $row = this._getFocusedCell().parent(),
                                    $cell = $row.prev().children().eq(cellIndex);
                                this._moveToCell($cell)
                            },
                            rightArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                var $cell = isRTL ? this._getFocusedCell().prev() : this._getFocusedCell().next();
                                this._moveToCell($cell)
                            },
                            leftArrow: function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                var $cell = isRTL ? this._getFocusedCell().next() : this._getFocusedCell().prev();
                                this._moveToCell($cell)
                            }
                        })
                },
                _getFocusedCell: function() {
                    return this._$focusedCell || this._$dateTable.find("." + DATE_TABLE_CELL_CLASS).eq(0)
                },
                _moveToCell: function($cell) {
                    this._setFocusedCell($cell);
                    this._dateTableScrollable.scrollToElement($cell)
                },
                _setFocusedCell: function($cell) {
                    if (!$cell.length)
                        return;
                    this._releaseFocusedCell();
                    this._toggleFocusClass(true, $cell);
                    if (commonUtils.isDefined(this._$focusedCell))
                        this.setAria("label", undefined, this._$focusedCell);
                    this._$focusedCell = $cell;
                    this.setAria("label", "Add appointment", this._$focusedCell)
                },
                _releaseFocusedCell: function() {
                    if (commonUtils.isDefined(this._$focusedCell))
                        this._toggleFocusClass(false, this._$focusedCell)
                },
                _focusInHandler: function(e) {
                    if ($(e.target).is(this._focusTarget()) && this._isCellClick !== false) {
                        delete this._isCellClick;
                        this.callBase.apply(this, arguments);
                        var $cell = this._getFocusedCell();
                        this._setFocusedCell($cell)
                    }
                },
                _focusOutHandler: function(e) {
                    this.callBase.apply(this, arguments);
                    this._releaseFocusedCell()
                },
                _focusTarget: function() {
                    return this.element()
                },
                _activeStateUnit: "." + DATE_TABLE_CELL_CLASS + ", ." + ALL_DAY_TABLE_CELL_CLASS,
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            currentDate: new Date,
                            firstDayOfWeek: undefined,
                            startDayHour: 0,
                            endDayHour: 24,
                            hoursInterval: 0.5,
                            activeStateEnabled: true,
                            hoverStateEnabled: true,
                            groups: [],
                            showAllDayPanel: true,
                            allDayExpanded: false,
                            onCellClick: null,
                            horizontalScrollingEnabled: false
                        })
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"startDayHour":
                        case"endDayHour":
                        case"hoursInterval":
                        case"firstDayOfWeek":
                        case"currentDate":
                        case"groups":
                            this._cleanView();
                            this._toggleGroupedClass();
                            this._renderView();
                            break;
                        case"showAllDayPanel":
                            this._toggleAllDayVisibility();
                            break;
                        case"allDayExpanded":
                            this._changeAllDayVisibility();
                            this.notifyObserver("allDayPanelToggled");
                            this._attachTablesEvents();
                            break;
                        case"onCellClick":
                            this._createCellClickAction();
                            break;
                        case"horizontalScrollingEnabled":
                            this._toggleHorizontalScrollClass();
                            break;
                        case"width":
                            this.callBase(args);
                            this._dimensionChanged();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _init: function() {
                    this.callBase();
                    this._toggleHorizontalScrollClass();
                    this.element().addClass(COMPONENT_CLASS).addClass(this._getElementClass());
                    this._initWorkSpaceUnits();
                    this._initDateTableScrollable();
                    this._createWorkSpaceElements()
                },
                _toggleHorizontalScrollClass: function() {
                    this.element().toggleClass(WORKSPACE_WITH_BOTH_SCROLLS_CLASS, this.option("horizontalScrollingEnabled"))
                },
                _initWorkSpaceUnits: function() {
                    this._$headerPanel = $("<table>").addClass(HEADER_PANEL_CLASS);
                    this._$thead = $("<thead>").appendTo(this._$headerPanel);
                    this._$fixedContainer = $("<div>").addClass(FIXED_CONTAINER_CLASS);
                    this._$allDayContainer = $("<div>").addClass(ALL_DAY_CONTAINER_CLASS);
                    this._$allDayTitle = $("<div>").addClass(ALL_DAY_TITLE_CLASS).text(Globalize.localize("dxScheduler-allDay")).appendTo(this.element());
                    this._$allDayTable = $("<table>").addClass(ALL_DAY_TABLE_CLASS);
                    this._$allDayPanel = $("<div>").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);
                    this._$timePanel = $("<table>").addClass(TIME_PANEL_CLASS);
                    this._$dateTable = $("<table>").addClass(DATE_TABLE_CLASS)
                },
                _initDateTableScrollable: function() {
                    var $dateTableScrollable = $("<div>").addClass(SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS);
                    this._dateTableScrollable = this._createComponent($dateTableScrollable, "dxScrollable", this._dateTableScrollableConfig())
                },
                _dateTableScrollableConfig: function() {
                    var config = {
                            useKeyboard: false,
                            useNative: false,
                            bounceEnabled: false
                        };
                    if (this.option("horizontalScrollingEnabled")) {
                        config.direction = "both";
                        config.onScroll = $.proxy(function(e) {
                            this._sidebarScrollable.scrollTo({top: e.scrollOffset.top});
                            this._headerScrollable.scrollTo({left: e.scrollOffset.left})
                        }, this);
                        config.onEnd = $.proxy(function(e) {
                            this.notifyObserver("updateResizableArea", {})
                        }, this)
                    }
                    return config
                },
                _createWorkSpaceElements: function() {
                    if (this.option("horizontalScrollingEnabled"))
                        this._createWorkSpaceScrollableElements();
                    else
                        this._createWorkSpaceStaticElements()
                },
                _createWorkSpaceStaticElements: function() {
                    this._dateTableScrollable.content().append(this._$timePanel, this._$dateTable);
                    this.element().append(this._$fixedContainer, this._$headerPanel, this._$allDayContainer, this._$allDayPanel, this._dateTableScrollable.element())
                },
                _createWorkSpaceScrollableElements: function() {
                    this.element().append(this._$fixedContainer);
                    this._createHeaderScrollable();
                    this._createSidebarScrollable();
                    this.element().append(this._dateTableScrollable.element());
                    this._headerScrollable.content().append(this._$headerPanel, this._$allDayContainer, this._$allDayPanel);
                    this._dateTableScrollable.content().append(this._$dateTable);
                    this._sidebarScrollable.content().append(this._$timePanel)
                },
                _createHeaderScrollable: function() {
                    var $headerScrollable = $("<div>").addClass(SCHEDULER_HEADER_SCROLLABLE_CLASS).appendTo(this.element());
                    this._headerScrollable = this._createComponent($headerScrollable, "dxScrollable", {
                        useKeyboard: false,
                        showScrollbar: false,
                        direction: "horizontal",
                        useNative: false,
                        bounceEnabled: false,
                        onScroll: $.proxy(function(e) {
                            this._dateTableScrollable.scrollTo({left: e.scrollOffset.left})
                        }, this)
                    })
                },
                _createSidebarScrollable: function() {
                    var $timePanelScrollable = $("<div>").addClass(SCHEDULER_SIDEBAR_SCROLLABLE_CLASS).appendTo(this.element());
                    this._sidebarScrollable = this._createComponent($timePanelScrollable, "dxScrollable", {
                        useKeyboard: false,
                        showScrollbar: false,
                        direction: "vertical",
                        useNative: false,
                        bounceEnabled: false,
                        onScroll: $.proxy(function(e) {
                            this._dateTableScrollable.scrollTo({top: e.scrollOffset.top})
                        }, this)
                    })
                },
                _visibilityChanged: function(visible) {
                    if (visible && this.option("horizontalScrollingEnabled"))
                        this._setTablesWidth()
                },
                _setTablesWidth: function() {
                    var cellWidth = 75,
                        minWidth = this._getWorkSpaceMinWidth(),
                        $headerCells = this._$headerPanel.find("tr").last().find("th");
                    var width = cellWidth * $headerCells.length;
                    if (width < minWidth)
                        width = minWidth;
                    this._$headerPanel.width(width);
                    this._$dateTable.width(width);
                    this._$allDayTable.width(width)
                },
                _getWorkSpaceMinWidth: function() {
                    var minWidth = this._getWorkSpaceWidth(),
                        workspaceContainerWidth = this.element().outerWidth() - this.getTimePanelWidth();
                    if (minWidth < workspaceContainerWidth)
                        minWidth = workspaceContainerWidth;
                    return minWidth
                },
                _dimensionChanged: function(e) {
                    if (this.option("horizontalScrollingEnabled"))
                        this._setTablesWidth()
                },
                _getElementClass: $.noop,
                _getRowCount: $.noop,
                _getCellCount: $.noop,
                _render: function() {
                    this.callBase();
                    this._toggleGroupedClass();
                    this._renderView();
                    this._attachEvents()
                },
                _toggleGroupedClass: function() {
                    this.element().toggleClass(GROUPED_WORKSPACE_CLASS, this._getGroupCount() > 0)
                },
                _renderView: function() {
                    this._setFirstViewDate();
                    this._renderGroupHeader();
                    this._renderDateHeader();
                    this._renderAllDayPanel();
                    this._renderTimePanel();
                    this._renderDateTable()
                },
                _setFirstViewDate: function() {
                    this._firstViewDate = dateUtils.getFirstWeekDate(this.option("currentDate"), this._firstDayOfWeek());
                    this._setStartDayHour(this._firstViewDate)
                },
                _setStartDayHour: function(date) {
                    if (commonUtils.isDefined(this.option("startDayHour")))
                        date.setHours(this.option("startDayHour"))
                },
                _firstDayOfWeek: function() {
                    return this.option("firstDayOfWeek")
                },
                _attachEvents: function() {
                    var that = this,
                        pointerDownAction = this._createAction(function(e) {
                            that._pointerDownHandler(e.jQueryEvent)
                        });
                    this._createCellClickAction();
                    var cellSelector = "." + DATE_TABLE_CELL_CLASS + ",." + ALL_DAY_TABLE_CELL_CLASS;
                    this.element().off(SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME).off(SCHEDULER_CELL_DXCLICK_EVENT_NAME).on(SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME, function(e) {
                        if (eventUtils.isMouseEvent(e) && e.which > 1) {
                            e.preventDefault();
                            return
                        }
                        pointerDownAction({jQueryEvent: e})
                    }).on(SCHEDULER_CELL_DXCLICK_EVENT_NAME, cellSelector, function(e) {
                        var $cell = $(e.target);
                        that._cellClickAction({
                            jQueryEvent: e,
                            cellElement: $cell,
                            cellData: that.getCellData($cell)
                        })
                    })
                },
                _createCellClickAction: function() {
                    var that = this;
                    this._cellClickAction = this._createActionByOption("onCellClick", {afterExecute: function(e) {
                            that._clickHandler(e.args[0].jQueryEvent)
                        }})
                },
                _clickHandler: function(e) {
                    var $target = $(e.target);
                    if (this._showPopup && this._hasFocusClass($target)) {
                        delete this._showPopup;
                        this._showAddAppointmentPopup($target)
                    }
                },
                _pointerDownHandler: function(e) {
                    var $target = $(e.target);
                    if (!$target.hasClass(DATE_TABLE_CELL_CLASS) && !$target.hasClass(ALL_DAY_TABLE_CELL_CLASS)) {
                        this._isCellClick = false;
                        return
                    }
                    this._isCellClick = true;
                    if (this._hasFocusClass($target))
                        this._showPopup = true;
                    else
                        this._setFocusedCell($target)
                },
                _showAddAppointmentPopup: function($cell) {
                    var cellData = this.getCellData($cell),
                        args = $.extend(cellData, cellData.groups);
                    delete args.groups;
                    this.notifyObserver("showAddAppointmentPopup", args)
                },
                _getGroupHeaderContainer: function() {
                    return this._$thead
                },
                _getDateHeaderContainer: function() {
                    return this._$thead
                },
                _renderGroupHeader: function() {
                    var $container = this._getGroupHeaderContainer();
                    var groupCount = this._getGroupCount();
                    if (groupCount) {
                        var groupRows = this._makeGroupRows(this.option("groups"));
                        this._attachGroupCountAttr(groupRows.length);
                        $container.append(groupRows)
                    }
                },
                _attachGroupCountAttr: function(groupRowCount) {
                    this.element().attr("dx-group-row-count", groupRowCount)
                },
                _makeGroupRows: function(groups) {
                    var repeatCount = 1,
                        groupCount = groups.length,
                        cellCount = this._getCellCount() || 1,
                        rows = [];
                    for (var i = 0; i < groupCount; i++) {
                        if (i > 0)
                            repeatCount = groups[i - 1].items.length * repeatCount;
                        var cells = this._makeGroupRowCells(groups[i].items, repeatCount);
                        rows.push($("<tr>").addClass(GROUP_ROW_CLASS).append(cells))
                    }
                    var maxCellCount = rows[groupCount - 1].find("th").length;
                    for (var j = 0; j < groupCount; j++) {
                        var $cell = rows[j].find("th"),
                            colspan = maxCellCount / $cell.length * cellCount;
                        if (colspan > 1)
                            $cell.attr("colspan", colspan)
                    }
                    return rows
                },
                _makeGroupRowCells: function(items, repeatCount) {
                    var cells = [],
                        itemCount = items.length;
                    for (var i = 0; i < repeatCount; i++)
                        for (var j = 0; j < itemCount; j++)
                            cells.push($("<th>").addClass(GROUP_HEADER_CLASS).html("<div class='" + GROUP_HEADER_CONTENT_CLASS + "'><div>" + items[j].text + "</div></div>"));
                    return cells
                },
                _renderDateHeader: function() {
                    var $container = this._getDateHeaderContainer(),
                        $headerRow = $("<tr>").addClass(HEADER_ROW_CLASS),
                        count = this._getCellCount(),
                        repeatCount = this._calculateHeaderCellRepeatCount();
                    for (var j = 0; j < repeatCount; j++)
                        for (var i = 0; i < count; i++) {
                            var text = this._getHeaderText(i),
                                $cell = $("<th>").text(text).addClass(HEADER_PANEL_CELL_CLASS).attr("title", text);
                            $headerRow.append($cell)
                        }
                    $container.append($headerRow);
                    return $headerRow
                },
                _calculateHeaderCellRepeatCount: function() {
                    return this._getGroupCount() || 1
                },
                _renderAllDayPanel: function() {
                    var cellCount = this._getCellCount() * (this._getGroupCount() || 1);
                    this._renderTableBody({
                        container: this._$allDayTable,
                        rowCount: 1,
                        cellCount: cellCount,
                        cellClass: ALL_DAY_TABLE_CELL_CLASS,
                        rowClass: ALL_DAY_TABLE_ROW_CLASS,
                        dataGenerator: $.proxy(this._setAllDayCellData, this)
                    });
                    this._toggleAllDayVisibility()
                },
                _setAllDayCellData: function($cell, rowIndex, cellIndex) {
                    var startDate = this._getDateByCellIndexes(rowIndex, cellIndex);
                    startDate = dateUtils.trimTime(startDate);
                    var data = {
                            startDate: startDate,
                            endDate: new Date(startDate.getTime() + 24 * 60 * 60000),
                            allDay: true
                        };
                    var groups = this._getCellGroups(this._getGroupIndex(rowIndex, cellIndex));
                    if (groups.length)
                        data.groups = {};
                    for (var i = 0; i < groups.length; i++)
                        data.groups[groups[i].name] = groups[i].id;
                    $cell.data(CELL_DATA, data)
                },
                _toggleAllDayVisibility: function() {
                    var showAllDayPanel = this.option("showAllDayPanel");
                    this._$allDayPanel.toggle(showAllDayPanel);
                    this._$allDayTitle.toggleClass(ALL_DAY_TITLE_HIDDEN_CLASS, !showAllDayPanel);
                    this.element().toggleClass(WORKSPACE_WITH_ALL_DAY_CLASS, showAllDayPanel);
                    this._changeAllDayVisibility()
                },
                _changeAllDayVisibility: function() {
                    this.element().toggleClass(WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS, !this.option("allDayExpanded") && this.option("showAllDayPanel"))
                },
                _renderTimePanel: function() {
                    var rowCount = 0.5 * this._getCellCountInDay();
                    this._renderTableBody({
                        container: this._$timePanel,
                        rowCount: rowCount,
                        cellCount: 1,
                        cellClass: TIME_PANEL_CELL_CLASS,
                        rowClass: TIME_PANEL_ROW_CLASS,
                        dataGenerator: $.proxy(this._setTimePanelText, this)
                    })
                },
                _getCellCountInDay: function() {
                    return Math.floor(this._calculateDayDuration() / this.option("hoursInterval"))
                },
                _calculateDayDuration: function() {
                    return this.option("endDayHour") - this.option("startDayHour")
                },
                _setTimePanelText: function($td, i) {
                    $td.text(this._getTimeText(i))
                },
                _getTimeText: function(i) {
                    var startDayHour = this.option("startDayHour"),
                        timeCellDuration = this.getCellDuration() * 2,
                        date = new Date(new Date(1970, 0).getTime() + timeCellDuration * i + startDayHour * 3600000);
                    return Globalize.format(date, "t")
                },
                _renderDateTable: function() {
                    var groupCount = this._getGroupCount() || 1;
                    this._renderTableBody({
                        container: this._$dateTable,
                        rowCount: this._getTotalRowCount(groupCount),
                        cellCount: this._getTotalCellCount(groupCount),
                        cellClass: DATE_TABLE_CELL_CLASS,
                        rowClass: DATE_TABLE_ROW_CLASS,
                        dataGenerator: $.proxy(this._setCellData, this)
                    });
                    this._attachTablesEvents()
                },
                _getTotalCellCount: function(groupCount) {
                    return this._getCellCount() * groupCount
                },
                _getTotalRowCount: function(groupCount) {
                    return this._getRowCount()
                },
                _setCellData: function($cell, rowIndex, cellIndex) {
                    var startDate = this._getDateByCellIndexes(rowIndex, cellIndex),
                        endDate = this.calculateEndDate(startDate),
                        data = {
                            startDate: startDate,
                            endDate: endDate,
                            allDay: this._getTableAllDay()
                        };
                    $cell.toggleClass(DATE_TABLE_CURRENT_DATE_CLASS, this._isCurrentDate(startDate)).toggleClass(DATE_TABLE_OTHER_MONTH_DATE_CLASS, this._isOtherMonth(startDate));
                    var groups = this._getCellGroups(this._getGroupIndex(rowIndex, cellIndex));
                    if (groups.length)
                        data.groups = {};
                    for (var i = 0; i < groups.length; i++)
                        data.groups[groups[i].name] = groups[i].id;
                    $cell.data(CELL_DATA, data)
                },
                _getGroupIndex: function(rowIndex, cellIndex) {
                    return Math.floor(cellIndex / this._getCellCount())
                },
                _getTableAllDay: function() {
                    return false
                },
                _isCurrentDate: function(cellDate) {
                    var today = new Date;
                    return dateUtils.sameMonthAndYear(cellDate, today) && cellDate.getDate() === today.getDate()
                },
                _isOtherMonth: function(cellDate) {
                    return cellDate.getMonth() !== this.option("currentDate").getMonth()
                },
                calculateEndDate: function(startDate) {
                    return new Date(startDate.getTime() + this._getInterval())
                },
                _getGroupCount: function() {
                    var groups = this.option("groups"),
                        result = 0;
                    for (var i = 0, len = groups.length; i < len; i++)
                        if (!i)
                            result = groups[i].items.length;
                        else
                            result *= groups[i].items.length;
                    return result
                },
                _getPathToLeaf: function(leafIndex) {
                    var tree = this._createGroupTree(this.option("groups")[0], 0);
                    function findLeafByIndex(data, index) {
                        for (var i = 0; i < data.length; i++)
                            if (data[i].leafIndex === index)
                                return data[i];
                            else {
                                var leaf = findLeafByIndex(data[i].children, index);
                                if (leaf)
                                    return leaf
                            }
                    }
                    function makeBranch(leaf, result) {
                        result = result || [];
                        result.push(leaf.value);
                        if (leaf.parent)
                            makeBranch(leaf.parent, result);
                        return result
                    }
                    var leaf = findLeafByIndex(tree, leafIndex);
                    return makeBranch(leaf).reverse()
                },
                _getCellGroups: function(groupIndex) {
                    var result = [];
                    if (this._getGroupCount()) {
                        var groups = this.option("groups");
                        if (groupIndex < 0)
                            return;
                        var path = this._getPathToLeaf(groupIndex);
                        for (var i = 0; i < groups.length; i++)
                            result.push({
                                name: groups[i].name,
                                id: path[i]
                            })
                    }
                    return result
                },
                _attachTablesEvents: function() {
                    this._attachTableEvents(this._getDateTable());
                    this._attachTableEvents(this._getAllDayTable())
                },
                _attachTableEvents: function($table) {
                    var that = this,
                        cellHeight,
                        cellWidth;
                    $table.off(SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME).off(SCHEDULER_CELL_DXDROP_EVENT_NAME).on(SCHEDULER_CELL_DXDRAGENTER_EVENT_NAME, "td", {itemSizeFunc: function($element) {
                            if (!cellHeight)
                                cellHeight = $element.height();
                            if (!cellWidth)
                                cellWidth = $element.width();
                            return {
                                    width: cellWidth,
                                    height: cellHeight
                                }
                        }}, function(e) {
                        if (that._$currentTableTarget)
                            that._$currentTableTarget.removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);
                        that._$currentTableTarget = $(e.target);
                        that._$currentTableTarget.addClass(DATE_TABLE_DROPPABLE_CELL_CLASS)
                    }).on(SCHEDULER_CELL_DXDROP_EVENT_NAME, "td", function(e) {
                        $(e.target).removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);
                        cellHeight = 0;
                        cellWidth = 0
                    })
                },
                _getDateTables: function() {
                    return this._$dateTable.add(this._$allDayTable)
                },
                _getDateTable: function() {
                    return this._$dateTable
                },
                _getAllDayTable: function() {
                    return this._$allDayTable
                },
                _getInterval: function() {
                    return this.option("hoursInterval") * 3600000
                },
                _getHeaderText: function(headerIndex) {
                    return Globalize.format(this._getDateByIndex(headerIndex), this._getFormat())
                },
                _getDateByIndex: abstract,
                _getFormat: abstract,
                _getCellText: function(rowIndex, cellIndex) {
                    return ""
                },
                _calculateCellIndex: function(rowIndex, cellIndex) {
                    cellIndex = cellIndex % this._getCellCount();
                    return this._getRowCount() * cellIndex + rowIndex
                },
                _renderTableBody: function(options) {
                    var rows = [];
                    for (var i = 0; i < options.rowCount; i++) {
                        var $row = $("<tr>");
                        if (options.rowClass)
                            $row.addClass(options.rowClass);
                        for (var j = 0; j < options.cellCount; j++) {
                            var $td = $("<td>").text(this._getCellText(i, j));
                            if (options.cellClass)
                                $td.addClass(options.cellClass);
                            if ($.isFunction(options.dataGenerator))
                                options.dataGenerator($td, i, j);
                            $row.append($td)
                        }
                        rows.push($row)
                    }
                    options.container.append($("<tbody>").append(rows))
                },
                _cleanView: function() {
                    this._$thead.empty();
                    this._$dateTable.empty();
                    this._$timePanel.empty();
                    this._$allDayTable.empty()
                },
                getWorkArea: function() {
                    return this._dateTableScrollable.content()
                },
                getScrollable: function() {
                    return this._dateTableScrollable
                },
                getScrollableScrollTop: function() {
                    return this._dateTableScrollable.scrollTop()
                },
                getScrollableScrollLeft: function() {
                    return this._dateTableScrollable.scrollLeft()
                },
                getScrollableContainer: function() {
                    return this._dateTableScrollable._container()
                },
                getHeaderPanelHeight: function() {
                    return this._$headerPanel.outerHeight(true)
                },
                getTimePanelWidth: function() {
                    return this._$timePanel.outerWidth()
                },
                _getCellCoordinatesByIndex: function(index) {
                    var cellIndex = Math.floor(index / this._getRowCount()),
                        rowIndex = index - this._getRowCount() * cellIndex;
                    return {
                            cellIndex: cellIndex,
                            rowIndex: rowIndex
                        }
                },
                _createGroupTree: function(group, groupIndex) {
                    var leafIndex = 0;
                    function make(group, groupIndex, result, parent) {
                        result = result || [];
                        for (var i = 0; i < group.items.length; i++) {
                            var resultItem = {
                                    name: group.name,
                                    value: group.items[i].id,
                                    children: [],
                                    parent: parent ? parent : null
                                };
                            result.push(resultItem);
                            var nextGroupIndex = groupIndex + 1;
                            if (this.option("groups")[nextGroupIndex])
                                make.call(this, this.option("groups")[nextGroupIndex], nextGroupIndex, resultItem.children, resultItem);
                            if (!resultItem.children.length) {
                                resultItem.leafIndex = leafIndex;
                                leafIndex++
                            }
                        }
                        return result
                    }
                    return make.call(this, group, groupIndex)
                },
                _hasGroupItem: function(groups, groupName, itemValue) {
                    var group = groups[groupName];
                    if (group)
                        if ($.inArray(itemValue, group) > -1)
                            return true;
                    return false
                },
                _grep: function(tree, groups, result) {
                    result = result || [];
                    for (var i = 0; i < tree.length; i++) {
                        if (!this._hasGroupItem(groups, tree[i].name, tree[i].value))
                            continue;
                        if (commonUtils.isDefined(tree[i].leafIndex))
                            result.push(tree[i].leafIndex);
                        if (tree[i].children)
                            this._grep(tree[i].children, groups, result)
                    }
                    return result
                },
                _getDateByCellIndexes: function(rowIndex, cellIndex) {
                    var firstViewDate = this.getFirstViewDate(),
                        currentDate = new Date(firstViewDate.getTime() + this._getMillisecondsOffset(rowIndex, cellIndex));
                    currentDate.setTime(currentDate.getTime() + dateUtils.getTimezonesDifference(firstViewDate, currentDate));
                    return currentDate
                },
                _getMillisecondsOffset: function(rowIndex, cellIndex) {
                    return this._getInterval() * this._calculateCellIndex(rowIndex, cellIndex) + this._calculateHiddenInterval(rowIndex, cellIndex)
                },
                _calculateHiddenInterval: function(rowIndex, cellIndex) {
                    var dayCount = cellIndex % this._getCellCount();
                    return dayCount * this._getHiddenInterval()
                },
                _getHiddenInterval: function() {
                    return toMs("day") - this.option("hoursInterval") * this._getCellCountInDay() * toMs("hour")
                },
                _getIntervalBetween: function(currentDate, allDay) {
                    var startDayTime = this.option("startDayHour") * toMs("hour"),
                        firstViewDate = this.getFirstViewDate(),
                        timeZoneOffset = dateUtils.getTimezonesDifference(firstViewDate, currentDate),
                        fullInterval = currentDate.getTime() - firstViewDate.getTime() - timeZoneOffset,
                        days = Math.floor((fullInterval + startDayTime) / toMs("day")),
                        result = days * toMs("day");
                    if (!allDay)
                        result = fullInterval - days * this._getHiddenInterval();
                    return result
                },
                _getGroupIndexes: function(groups) {
                    var indexes = [];
                    if (groups && this.option("groups").length) {
                        var tree = this._createGroupTree(this.option("groups")[0], 0);
                        indexes = this._grep(tree, groups)
                    }
                    return indexes
                },
                _updateIndex: function(index) {
                    return index * this._getRowCount()
                },
                _getDroppableCell: function() {
                    return this._getDateTables().find("." + DATE_TABLE_DROPPABLE_CELL_CLASS)
                },
                _getWorkSpaceWidth: function() {
                    if (this.option("horizontalScrollingEnabled"))
                        return this._$dateTable.outerWidth();
                    return this.element().outerWidth() - this.getTimePanelWidth()
                },
                _getCellPositionByIndex: function(index, groupIndex) {
                    var cellCoordinates = this._getCellCoordinatesByIndex(index),
                        $cell = this._getCellByCoordinates(cellCoordinates, groupIndex);
                    return this._getCellPosition($cell)
                },
                _getCellPosition: function($cell) {
                    var isRtl = this.option("rtlEnabled"),
                        position = $cell.position();
                    if (isRtl)
                        position.left += $cell.outerWidth();
                    return position
                },
                _getCellByCoordinates: function(cellCoordinates, groupIndex) {
                    return this._$dateTable.find("tr").eq(cellCoordinates.rowIndex).find("td").eq(cellCoordinates.cellIndex + groupIndex * this._getCellCount())
                },
                _getCells: function(allDay) {
                    var cellClass = allDay ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS;
                    return this.element().find("." + cellClass)
                },
                _getGroupHeaderCellsContent: function() {
                    return this.element().find("." + GROUP_HEADER_CONTENT_CLASS)
                },
                _getScrollCoordinates: function(hours, minutes, date) {
                    var currentDate = date || new Date(this.option("currentDate")),
                        startDayHour = this.option("startDayHour"),
                        endDayHour = this.option("endDayHour");
                    if (hours < startDayHour)
                        hours = startDayHour;
                    if (hours >= endDayHour)
                        hours = endDayHour - 1;
                    currentDate.setHours(hours);
                    currentDate.setMinutes(minutes);
                    return this.getCoordinatesByDate(currentDate)
                },
                supportAllDayRow: function() {
                    return true
                },
                getCellData: function($cell) {
                    return $.extend(true, {}, $cell.data(CELL_DATA))
                },
                getCoordinatesByDate: function(date, groupIndex, inAllDayRow) {
                    groupIndex = groupIndex || 0;
                    var index = this.getCellIndexByDate(date, inAllDayRow),
                        position = this._getCellPositionByIndex(index, groupIndex),
                        shift = this.getPositionShift(inAllDayRow ? 0 : this.getTimeShift(date));
                    return {
                            top: position.top + shift.top,
                            left: position.left + shift.left,
                            max: this.getMaxAllowedPosition()[groupIndex],
                            groupIndex: groupIndex
                        }
                },
                getCellIndexByDate: function(date, inAllDayRow) {
                    var timeInterval = inAllDayRow ? 24 * 60 * 60 * 1000 : this._getInterval(),
                        dateTimeStamp = this._getIntervalBetween(date, inAllDayRow);
                    var index = Math.floor(dateTimeStamp / timeInterval);
                    if (inAllDayRow)
                        index = this._updateIndex(index);
                    if (index < 0)
                        index = 0;
                    return index
                },
                getPositionShift: function(timeShift) {
                    return {
                            top: timeShift * this.getCellHeight(),
                            left: 0
                        }
                },
                getTimeShift: function(date) {
                    var cellDuration = this.getCellDuration(),
                        currentDayStart = new Date(date);
                    currentDayStart.setMinutes(0);
                    currentDayStart.setHours(this.option("startDayHour"));
                    return (date.getTime() - currentDayStart.getTime()) % cellDuration / cellDuration
                },
                getCoordinatesByDateInGroup: function(date, groups, inAllDayRow) {
                    var indexes = this._getGroupIndexes(groups),
                        result = [];
                    if (indexes.length)
                        for (var i = 0; i < indexes.length; i++)
                            result.push(this.getCoordinatesByDate(date, indexes[i], inAllDayRow));
                    else
                        result.push(this.getCoordinatesByDate(date, 0, inAllDayRow));
                    return result
                },
                getDroppableCellIndex: function() {
                    var $droppableCell = this._getDroppableCell(),
                        $row = $droppableCell.parent(),
                        rowIndex = $row.index();
                    return rowIndex * $row.find("td").length + $droppableCell.index()
                },
                getDataByDroppableCell: function() {
                    var cellData = this.getCellData(this._getDroppableCell());
                    return {
                            date: cellData.startDate,
                            allDay: cellData.allDay,
                            groups: cellData.groups
                        }
                },
                getDateRange: function() {
                    return [this.getFirstViewDate(), this.getLastViewDate()]
                },
                getCellWidth: function() {
                    return this._getCells().first().outerWidth()
                },
                getCellHeight: function() {
                    return this._getCells().first().outerHeight()
                },
                getAllDayHeight: function() {
                    return this.option("showAllDayPanel") ? this._getCells(true).first().outerHeight() : 0
                },
                getMaxAllowedPosition: function() {
                    var result = [],
                        isRtl = this.option("rtlEnabled");
                    this._$dateTable.find("tr").first().find("td:nth-child(" + this._getCellCount() + "n)").each(function(_, cell) {
                        var maxPosition = $(cell).position().left;
                        if (!isRtl)
                            maxPosition += $(cell).outerWidth();
                        result.push(Math.floor(maxPosition))
                    });
                    return result
                },
                getFixedContainer: function() {
                    return this._$fixedContainer
                },
                getAllDayContainer: function() {
                    return this._$allDayContainer
                },
                getCellIndexByCoordinates: function(coordinates, allDay) {
                    var cellCount = this._getTotalCellCount(this._getGroupCount() || 1),
                        timePanelWidth = this.getTimePanelWidth(),
                        cellWidth = Math.floor(this._getWorkSpaceWidth() / cellCount),
                        leftOffset = this.option("rtlEnabled") || this.option("horizontalScrollingEnabled") ? 0 : timePanelWidth,
                        topIndex = Math.floor(coordinates.top / (allDay ? this.getAllDayHeight() : this.getCellHeight())),
                        leftIndex = Math.floor((coordinates.left + 5 - leftOffset) / cellWidth);
                    if (this.option("rtlEnabled"))
                        leftIndex = cellCount - leftIndex - 1;
                    return cellCount * topIndex + leftIndex
                },
                getFirstViewDate: function() {
                    return this._firstViewDate
                },
                getLastViewDate: function() {
                    var dateOfLastViewCell = this._getDateByCellIndexes(this._getRowCount() - 1, this._getCellCount() - 1);
                    return new Date(dateOfLastViewCell.getTime() + this.getCellDuration() - 60000)
                },
                getCellDuration: function() {
                    return 3600000 * this.option("hoursInterval")
                },
                getGroupBounds: function(coordinates) {
                    var cellIndex = this.getCellIndexByCoordinates(coordinates),
                        cellCount = this._getCellCount(),
                        groupIndex = Math.floor(cellIndex / cellCount),
                        $cells = this._getCells(),
                        cellWidth = this.getCellWidth(),
                        startCellIndex = groupIndex * cellCount,
                        startOffset = $cells.eq(startCellIndex).offset().left - cellWidth / 2,
                        endOffset = $cells.eq(startCellIndex + cellCount - 1).offset().left + cellWidth + cellWidth / 2;
                    var result = {
                            left: startOffset,
                            right: endOffset
                        };
                    if (this.option("rtlEnabled")) {
                        result.left = endOffset - cellWidth * 2;
                        result.right = startOffset + cellWidth * 2
                    }
                    return result
                },
                getCellDataByCoordinates: function(coordinates, allDay) {
                    var $cells = this._getCells(allDay),
                        cellIndex = this.getCellIndexByCoordinates(coordinates, allDay),
                        $cell = $cells.eq(cellIndex);
                    return this.getCellData($cell)
                },
                getVisibleBounds: function() {
                    var result = {},
                        $scrollable = this.getScrollable().element(),
                        cellHeight = this.getCellHeight(),
                        scrolledCellCount = this.getScrollableScrollTop() / cellHeight,
                        totalCellCount = scrolledCellCount + $scrollable.height() / cellHeight;
                    result.top = {
                        hours: Math.floor(scrolledCellCount * this.option("hoursInterval")) + this.option("startDayHour"),
                        minutes: scrolledCellCount % 2 ? 30 : 0
                    };
                    result.bottom = {
                        hours: Math.floor(totalCellCount * this.option("hoursInterval")) + this.option("startDayHour"),
                        minutes: Math.floor(totalCellCount) % 2 ? 30 : 0
                    };
                    return result
                },
                updateScrollPosition: function(date) {
                    var bounds = this.getVisibleBounds(),
                        startDateHour = date.getHours(),
                        startDateMinutes = date.getMinutes();
                    if (this.needUpdateScrollPosition(startDateHour, startDateMinutes, bounds))
                        this.scrollToTime(startDateHour, startDateMinutes, date)
                },
                needUpdateScrollPosition: function(hours, minutes, bounds) {
                    var isUpdateNeeded = false;
                    if (hours < bounds.top.hours || hours > bounds.bottom.hours)
                        isUpdateNeeded = true;
                    if (hours === bounds.top.hours && minutes < bounds.top.minutes)
                        isUpdateNeeded = true;
                    if (hours === bounds.bottom.hours && minutes > bounds.top.minutes)
                        isUpdateNeeded = true;
                    return isUpdateNeeded
                },
                getGroupWidth: function(groupIndex) {
                    var result = this._getCellCount() * this.getCellWidth(),
                        position = this.getMaxAllowedPosition(),
                        currentPosition = position[groupIndex];
                    if (position.length && currentPosition)
                        if (this.option("rtlEnabled"))
                            result = currentPosition - position[groupIndex + 1];
                        else if (groupIndex === 0)
                            result = currentPosition;
                        else
                            result = currentPosition - position[groupIndex - 1];
                    return result
                },
                restoreScrollTop: function() {
                    this.element().scrollTop(0)
                },
                scrollToTime: function(hours, minutes, date) {
                    var coordinates = this._getScrollCoordinates(hours, minutes, date),
                        scrollable = this.getScrollable();
                    scrollable.scrollBy(coordinates.top - scrollable.scrollTop())
                },
                getDistanceBetweenCells: function(startIndex, endIndex) {
                    var result = 0;
                    this.element().find("." + DATE_TABLE_ROW_CLASS).first().find("." + DATE_TABLE_CELL_CLASS).each(function(index) {
                        if (index < startIndex || index > endIndex)
                            return true;
                        result += $(this).outerWidth()
                    });
                    return result
                }
            }).include(publisherMixin);
        registerComponent("dxSchedulerWorkSpace", {}, SchedulerWorkSpace);
        return SchedulerWorkSpace
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.workSpace"]);
    /*! Module widgets-web, file ui.scheduler.workSpaceDay.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.workSpaceDay", ["jquery", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.workSpace", "/utils/utils.common"], function($, registerComponent, SchedulerWorkSpace, commonUtils) {
        var DAY_CLASS = "dx-scheduler-work-space-day";
        var SchedulerWorkSpaceDay = SchedulerWorkSpace.inherit({
                _getElementClass: function() {
                    return DAY_CLASS
                },
                _getRowCount: function() {
                    return this._getCellCountInDay()
                },
                _getCellCount: function() {
                    return 1
                },
                _setFirstViewDate: function() {
                    this._firstViewDate = this.option("currentDate");
                    if (commonUtils.isDefined(this.option("startDayHour")))
                        this._firstViewDate.setHours(this.option("startDayHour"))
                },
                _getDateByIndex: function() {
                    return this._firstViewDate
                },
                _getFormat: function() {
                    return "D"
                },
                _renderDateHeader: $.noop
            });
        registerComponent("dxSchedulerWorkSpaceDay", {}, SchedulerWorkSpaceDay);
        return SchedulerWorkSpaceDay
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.workSpaceDay"]);
    /*! Module widgets-web, file ui.scheduler.workSpaceWeek.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.workSpaceWeek", ["jquery", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.workSpace"], function($, registerComponent, SchedulerWorkSpace) {
        var WEEK_CLASS = "dx-scheduler-work-space-week";
        var SchedulerWorkSpaceWeek = SchedulerWorkSpace.inherit({
                _getElementClass: function() {
                    return WEEK_CLASS
                },
                _getRowCount: function() {
                    return this._getCellCountInDay()
                },
                _getCellCount: function() {
                    return 7
                },
                _getDateByIndex: function(headerIndex) {
                    var resultDate = new Date(this._firstViewDate);
                    resultDate.setDate(this._firstViewDate.getDate() + headerIndex);
                    return resultDate
                },
                _getFormat: function() {
                    return "ddd d"
                }
            });
        registerComponent("dxSchedulerWorkSpaceWeek", {}, SchedulerWorkSpaceWeek);
        return SchedulerWorkSpaceWeek
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.workSpaceWeek"]);
    /*! Module widgets-web, file ui.scheduler.workSpaceWorkWeek.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.workSpaceWorkWeek", ["jquery", "/componentRegistrator", "/utils/utils.date", "/utils/utils.common", "/ui/widgets/scheduler/ui.scheduler.workSpaceWeek"], function($, registerComponent, dateUtils, commonUtils, SchedulerWorkSpaceWeek) {
        var WORK_WEEK_CLASS = "dx-scheduler-work-space-work-week";
        var weekendCounter = 0;
        var SchedulerWorkSpaceWorkWeek = SchedulerWorkSpaceWeek.inherit({
                _getElementClass: function() {
                    return WORK_WEEK_CLASS
                },
                _getCellCount: function() {
                    return 5
                },
                _firstDayOfWeek: function() {
                    return this.option("firstDayOfWeek") || 1
                },
                _getDateByIndex: function(headerIndex) {
                    var resultDate = new Date(this._firstViewDate);
                    resultDate.setDate(this._firstViewDate.getDate() + headerIndex + weekendCounter);
                    var day = resultDate.getDay();
                    if (day % 6 === 0) {
                        weekendCounter = Math.floor(day / 6 + 1);
                        resultDate.setDate(resultDate.getDate() + weekendCounter)
                    }
                    return resultDate
                },
                _renderView: function() {
                    weekendCounter = 0;
                    this.callBase()
                },
                _setFirstViewDate: function() {
                    this._firstViewDate = dateUtils.getFirstWeekDate(this.option("currentDate"), this._firstDayOfWeek());
                    this._firstViewDate = dateUtils.normalizeDateByWeek(this._firstViewDate, this.option("currentDate"));
                    this._setStartDayHour(this._firstViewDate)
                }
            });
        registerComponent("dxSchedulerWorkSpaceWorkWeek", {}, SchedulerWorkSpaceWorkWeek);
        return SchedulerWorkSpaceWorkWeek
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.workSpaceWorkWeek"]);
    /*! Module widgets-web, file ui.scheduler.workSpaceMonth.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.workSpaceMonth", ["jquery", "/utils/utils.date", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.workSpace"], function($, dateUtils, registerComponent, SchedulerWorkSpace) {
        var MONTH_CLASS = "dx-scheduler-work-space-month";
        var DAYS_IN_WEEK = 7,
            DAY_IN_MILLISECONDS = 86400000;
        var SchedulerWorkSpaceMonth = SchedulerWorkSpace.inherit({
                _getElementClass: function() {
                    return MONTH_CLASS
                },
                _getRowCount: function() {
                    return 6
                },
                _getCellCount: function() {
                    return DAYS_IN_WEEK
                },
                _getDateByIndex: function(headerIndex) {
                    var resultDate = new Date(this._firstViewDate);
                    resultDate.setDate(this._firstViewDate.getDate() + headerIndex);
                    return resultDate
                },
                _getFormat: function() {
                    return "ddd"
                },
                _calculateCellIndex: function(rowIndex, cellIndex) {
                    cellIndex = cellIndex % this._getCellCount();
                    return rowIndex * this._getCellCount() + cellIndex
                },
                _getInterval: function() {
                    return DAY_IN_MILLISECONDS
                },
                _getIntervalBetween: function(currentDate) {
                    var firstViewDate = this.getFirstViewDate(),
                        timeZoneOffset = dateUtils.getTimezonesDifference(firstViewDate, currentDate);
                    return currentDate.getTime() - (firstViewDate.getTime() - this.option("startDayHour") * 3600000) - timeZoneOffset
                },
                _getDateByCellIndexes: function(rowIndex, cellIndex) {
                    var date = this.callBase(rowIndex, cellIndex);
                    this._setStartDayHour(date);
                    return date
                },
                _calculateHiddenInterval: function() {
                    return 0
                },
                _getCellCoordinatesByIndex: function(index) {
                    var rowIndex = Math.floor(index / this._getCellCount()),
                        cellIndex = index - this._getCellCount() * rowIndex;
                    return {
                            rowIndex: rowIndex,
                            cellIndex: cellIndex
                        }
                },
                _renderTimePanel: $.noop,
                _renderAllDayPanel: $.noop,
                _getTableAllDay: $.noop,
                _toggleAllDayVisibility: $.noop,
                _changeAllDayVisibility: $.noop,
                _setFirstViewDate: function() {
                    var firstMonthDate = dateUtils.getFirstMonthDate(this.option("currentDate"));
                    this._firstViewDate = dateUtils.getFirstWeekDate(firstMonthDate, this.option("firstDayOfWeek"));
                    if (this.option("startDayHour"))
                        this._firstViewDate.setHours(this.option("startDayHour"))
                },
                _getDate: function(week, day) {
                    var result = new Date(this._firstViewDate);
                    result.setDate(result.getDate() + week * DAYS_IN_WEEK + day);
                    return result
                },
                _getCellText: function(rowIndex, cellIndex) {
                    cellIndex = cellIndex % this._getCellCount();
                    var date = this._getDate(rowIndex, cellIndex);
                    return Globalize.format(date, "dd")
                },
                _updateIndex: function(index) {
                    return index
                },
                getCellDuration: function() {
                    return this._calculateDayDuration() * 3600000
                },
                getTimePanelWidth: function() {
                    return 0
                },
                getPositionShift: function() {
                    return {
                            top: 0,
                            left: 0
                        }
                },
                getCoordinatesByDates: function(startDate, endDate) {
                    var result = [],
                        date = new Date(startDate);
                    while (date <= endDate) {
                        result.push(this.getCoordinatesByDate(date));
                        date.setDate(date.getDate() + 7);
                        date = dateUtils.getFirstWeekDate(date, this.option("firstDayOfWeek"))
                    }
                    return result
                },
                getCellCountToLastViewDate: function(date) {
                    var firstDateTime = dateUtils.makeDate(date).getTime(),
                        lastDateTime = this.getLastViewDate().getTime(),
                        dayDurationInMs = this.getCellDuration();
                    return Math.ceil((lastDateTime - firstDateTime) / dayDurationInMs)
                },
                supportAllDayRow: function() {
                    return false
                },
                calculateEndDate: function(startDate) {
                    var startDateCopy = new Date(startDate);
                    return new Date(startDateCopy.setHours(this.option("endDayHour")))
                },
                _getCellPositionByIndex: function(index, groupIndex) {
                    var position = this.callBase(index, groupIndex),
                        rowIndex = this._getCellCoordinatesByIndex(index).rowIndex,
                        calculatedTopOffset = this.getCellHeight() * rowIndex;
                    if (calculatedTopOffset)
                        position.top = calculatedTopOffset;
                    return position
                },
                scrollToTime: $.noop
            });
        registerComponent("dxSchedulerWorkSpaceMonth", {}, SchedulerWorkSpaceMonth);
        return SchedulerWorkSpaceMonth
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.workSpaceMonth"]);
    /*! Module widgets-web, file ui.scheduler.timeline.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.timeline", ["jquery", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.workSpace", "/utils/utils.date"], function($, registerComponent, SchedulerWorkSpace, dateUtils) {
        var TIMELINE_CLASS = "dx-scheduler-timeline",
            GROUP_TABLE_CLASS = "dx-scheduler-group-table";
        var HORIZONTAL = "horizontal",
            toMs = dateUtils.dateToMilliseconds;
        var SchedulerTimeline = SchedulerWorkSpace.inherit({
                _init: function() {
                    this.callBase();
                    this.element().addClass(TIMELINE_CLASS);
                    this._$sidebarTable = $("<table>").addClass(GROUP_TABLE_CLASS)
                },
                _getRowCount: function() {
                    return 1
                },
                _getCellCount: function() {
                    return this._getCellCountInDay()
                },
                _getTotalCellCount: function(groupCount) {
                    return this._getCellCount()
                },
                _getTotalRowCount: function(groupCount) {
                    return this._getRowCount() * groupCount
                },
                _getDateByIndex: function(index) {
                    var resultDate = new Date(this._firstViewDate),
                        dayIndex = Math.floor(index / this._getCellCountInDay());
                    resultDate.setTime(this._firstViewDate.getTime() + this._calculateCellIndex(0, index) * this._getInterval() + dayIndex * this._getHiddenInterval());
                    return resultDate
                },
                _getFormat: function() {
                    return "t"
                },
                _calculateHiddenInterval: function(rowIndex, cellIndex) {
                    var dayIndex = Math.floor(cellIndex / this._getCellCountInDay());
                    return dayIndex * this._getHiddenInterval()
                },
                _createWorkSpaceElements: function() {
                    this._createWorkSpaceScrollableElements()
                },
                _dateTableScrollableConfig: function() {
                    var that = this,
                        config = this.callBase(),
                        timelineConfig = {
                            direction: HORIZONTAL,
                            onScroll: function(e) {
                                that._headerScrollable.scrollTo({left: e.scrollOffset.left})
                            }
                        };
                    return $.extend(config, timelineConfig)
                },
                _renderTimePanel: $.noop,
                _renderAllDayPanel: $.noop,
                _getTableAllDay: function() {
                    return false
                },
                _toggleAllDayVisibility: $.noop,
                _changeAllDayVisibility: $.noop,
                supportAllDayRow: function() {
                    return false
                },
                _getGroupHeaderContainer: function() {
                    return this._$sidebarTable
                },
                _renderView: function() {
                    this.callBase();
                    this._$sidebarTable.appendTo(this._sidebarScrollable.content());
                    this._setGroupHeaderCellsHeight()
                },
                _cleanView: function() {
                    this.callBase();
                    this._$sidebarTable.empty()
                },
                _visibilityChanged: function(visible) {
                    this.callBase(visible);
                    this._setGroupHeaderCellsHeight()
                },
                _makeGroupRows: function(groups) {
                    var repeatCount = 1,
                        arr = [],
                        i;
                    for (i = 0; i < groups.length; i++) {
                        if (i > 0)
                            repeatCount = groups[i - 1].items.length * repeatCount;
                        var cells = this._makeGroupRowCells(groups[i].items, repeatCount);
                        arr.push(cells)
                    }
                    var rows = [],
                        groupCount = arr.length,
                        maxCellCount = arr[groupCount - 1].length;
                    for (i = 0; i < maxCellCount; i++)
                        rows.push($("<tr>").addClass("dx-scheduler-group-row"));
                    for (i = groupCount - 1; i >= 0; i--) {
                        var currentColumnLength = arr[i].length,
                            rowspan = maxCellCount / currentColumnLength;
                        for (var j = 0; j < currentColumnLength; j++) {
                            var currentRowIndex = j * rowspan,
                                row = rows[currentRowIndex];
                            row.prepend(arr[i][j].attr("rowspan", rowspan))
                        }
                    }
                    return rows
                },
                _setGroupHeaderCellsHeight: function() {
                    var cellHeight = this.getCellHeight() - 1;
                    this._getGroupHeaderCellsContent().css("height", cellHeight)
                },
                _attachGroupCountAttr: function() {
                    this.element().attr("dx-group-column-count", this.option("groups").length)
                },
                _getCellCoordinatesByIndex: function(index) {
                    return {
                            cellIndex: index % this._getCellCount(),
                            rowIndex: 0
                        }
                },
                _getCellByCoordinates: function(cellCoordinates, groupIndex) {
                    return this._$dateTable.find("tr").eq(cellCoordinates.rowIndex + groupIndex).find("td").eq(cellCoordinates.cellIndex)
                },
                _calculateCellIndex: function(rowIndex, cellIndex) {
                    return cellIndex
                },
                _getGroupIndex: function(rowIndex, cellIndex) {
                    return rowIndex
                },
                _getWorkSpaceWidth: function() {
                    return this._$dateTable.outerWidth(true)
                },
                _calculateHeaderCellRepeatCount: function() {
                    return 1
                },
                _getIntervalBetween: function(currentDate, allDay) {
                    var startDayHour = this.option("startDayHour"),
                        endDayHour = this.option("endDayHour"),
                        firstViewDate = this.getFirstViewDate(),
                        firstViewDateTime = firstViewDate.getTime(),
                        hiddenInterval = (24 - endDayHour + startDayHour) * toMs("hour"),
                        timeZoneOffset = dateUtils.getTimezonesDifference(firstViewDate, currentDate),
                        apptStart = currentDate.getTime(),
                        fullInterval = apptStart - firstViewDateTime - timeZoneOffset,
                        fullDays = Math.floor(fullInterval / toMs("day")),
                        tailDuration = fullInterval - fullDays * toMs("day"),
                        tailDelta = 0,
                        cellCount = this._getCellCountInDay() * fullDays,
                        gapBeforeAppt = apptStart - dateUtils.trimTime(new Date(currentDate)).getTime(),
                        result = cellCount * this.option("hoursInterval") * toMs("hour");
                    if (!allDay) {
                        if (currentDate.getHours() < startDayHour)
                            tailDelta = tailDuration - hiddenInterval + gapBeforeAppt;
                        else if (currentDate.getHours() >= startDayHour && currentDate.getHours() < endDayHour)
                            tailDelta = tailDuration;
                        else if (currentDate.getHours() >= startDayHour && currentDate.getHours() >= endDayHour)
                            tailDelta = tailDuration - (gapBeforeAppt - endDayHour * toMs("hour"));
                        else if (!fullDays)
                            result = fullInterval;
                        result += tailDelta
                    }
                    return result
                },
                getAllDayContainer: function() {
                    return null
                },
                getTimePanelWidth: function() {
                    return 0
                },
                getPositionShift: function(timeShift) {
                    var positionShift = this.callBase(timeShift),
                        left = this.getCellWidth() * timeShift;
                    if (this.option("rtlEnabled"))
                        left *= -1;
                    left += positionShift.left;
                    return {
                            top: 0,
                            left: left
                        }
                },
                getVisibleBounds: function() {
                    var result = {},
                        $scrollable = this.getScrollable().element(),
                        cellWidth = this.getCellWidth(),
                        scrolledCellCount = this.getScrollableScrollLeft() / cellWidth,
                        totalCellCount = scrolledCellCount + $scrollable.width() / cellWidth,
                        leftDate = this._getDateByIndex(totalCellCount),
                        rightDate = this._getDateByIndex(scrolledCellCount);
                    result.right = {
                        hours: rightDate.getHours(),
                        minutes: rightDate.getMinutes() >= 30 ? 30 : 0
                    };
                    result.left = {
                        hours: leftDate.getHours(),
                        minutes: leftDate.getMinutes() >= 30 ? 30 : 0
                    };
                    return result
                },
                needUpdateScrollPosition: function(hours, minutes, bounds) {
                    var isUpdateNeeded = false;
                    if (hours < bounds.right.hours || hours > bounds.left.hours)
                        isUpdateNeeded = true;
                    if (hours === bounds.right.hours && minutes < bounds.right.minutes)
                        isUpdateNeeded = true;
                    if (hours === bounds.left.hours && minutes > bounds.right.minutes)
                        isUpdateNeeded = true;
                    return isUpdateNeeded
                },
                scrollToTime: function(hours, minutes, date) {
                    var coordinates = this._getScrollCoordinates(hours, minutes, date),
                        scrollable = this.getScrollable();
                    scrollable.scrollBy({
                        left: coordinates.left - scrollable.scrollLeft(),
                        top: 0
                    })
                }
            });
        registerComponent("dxSchedulerTimeline", {}, SchedulerTimeline);
        return SchedulerTimeline
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.timeline"]);
    /*! Module widgets-web, file ui.scheduler.timelineDay.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.timelineDay", ["jquery", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.timeline", "/utils/utils.common"], function($, registerComponent, SchedulerTimeline, commonUtils) {
        var TIMELINE_CLASS = "dx-scheduler-timeline-day";
        var SchedulerTimelineDay = SchedulerTimeline.inherit({
                _getElementClass: function() {
                    return TIMELINE_CLASS
                },
                _setFirstViewDate: function() {
                    this._firstViewDate = this.option("currentDate");
                    if (commonUtils.isDefined(this.option("startDayHour")))
                        this._firstViewDate.setHours(this.option("startDayHour"))
                }
            });
        registerComponent("dxSchedulerTimelineDay", {}, SchedulerTimelineDay);
        return SchedulerTimelineDay
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.timelineDay"]);
    /*! Module widgets-web, file ui.scheduler.timelineWeek.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.timelineWeek", ["jquery", "/componentRegistrator", "/ui/widgets/scheduler/ui.scheduler.timeline"], function($, registerComponent, SchedulerTimeline) {
        var TIMELINE_CLASS = "dx-scheduler-timeline-week",
            HEADER_PANEL_CELL_CLASS = "dx-scheduler-header-panel-cell",
            HEADER_ROW_CLASS = "dx-scheduler-header-row",
            CELL_WIDTH = 200;
        var SchedulerTimelineWeek = SchedulerTimeline.inherit({
                _getElementClass: function() {
                    return TIMELINE_CLASS
                },
                _getCellCount: function() {
                    return this.callBase() * this._getWeekDuration()
                },
                _renderDateHeader: function() {
                    var $headerRow = this.callBase(),
                        firstViewDate = new Date(this._firstViewDate),
                        $cells = [],
                        colspan = this._getCellCountInDay(),
                        headerCellWidth = colspan * CELL_WIDTH;
                    for (var i = 0; i < this._getWeekDuration(); i++) {
                        $cells.push($("<th>").addClass(HEADER_PANEL_CELL_CLASS).text(Globalize.format(firstViewDate, "ddd d")).attr("colspan", colspan).width(headerCellWidth));
                        firstViewDate.setDate(firstViewDate.getDate() + 1)
                    }
                    var $row = $("<tr>").addClass(HEADER_ROW_CLASS).append($cells);
                    $headerRow.before($row)
                },
                _getWeekDuration: function() {
                    return 7
                }
            });
        registerComponent("dxSchedulerTimelineWeek", {}, SchedulerTimelineWeek);
        return SchedulerTimelineWeek
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.timelineWeek"]);
    /*! Module widgets-web, file ui.scheduler.timelineWorkWeek.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.timelineWorkWeek", ["jquery", "/componentRegistrator", "/utils/utils.date", "/ui/widgets/scheduler/ui.scheduler.timelineWeek"], function($, registerComponent, dateUtils, SchedulerTimelineWeek) {
        var TIMELINE_CLASS = "dx-scheduler-timeline-work-week";
        var SchedulerTimelineWorkWeek = SchedulerTimelineWeek.inherit({
                _getElementClass: function() {
                    return TIMELINE_CLASS
                },
                _getWeekDuration: function() {
                    return 5
                },
                _firstDayOfWeek: function() {
                    return this.option("firstDayOfWeek") || 1
                },
                _setFirstViewDate: function() {
                    this._firstViewDate = dateUtils.getFirstWeekDate(this.option("currentDate"), this._firstDayOfWeek());
                    this._firstViewDate = dateUtils.normalizeDateByWeek(this._firstViewDate, this.option("currentDate"));
                    this._setStartDayHour(this._firstViewDate)
                }
            });
        registerComponent("dxSchedulerTimelineWorkWeek", {}, SchedulerTimelineWorkWeek);
        return SchedulerTimelineWorkWeek
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.timelineWorkWeek"]);
    /*! Module widgets-web, file ui.scheduler.appointment.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointment", ["jquery", "/ui/uiNamespace", "/utils/utils.translator", "/utils/utils.array", "/utils/utils.recurrence", "/utils/utils.date", "/utils/utils.common", "/componentRegistrator", "/ui/ui.tooltip", "/ui/widgets/scheduler/ui.scheduler.publisherMixin", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer", "/domComponent"], function($, ui, translator, array, recurrenceUtils, dateUtils, commonUtils, registerComponent, tooltip, publisherMixin, eventUtils, pointerEvents, DOMComponent) {
        var REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME = eventUtils.addNamespace(pointerEvents.enter, "dxSchedulerAppointment"),
            REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME = eventUtils.addNamespace(pointerEvents.leave, "dxSchedulerAppointment");
        var EMPTY_APPOINTMENT_CLASS = "dx-scheduler-appointment-empty",
            EMPTY_APPOINTMENT_MAX_WIDTH = 40,
            APPOINTMENT_ALL_DAY_ITEM_CLASS = "dx-scheduler-all-day-appointment",
            DIRECTION_APPOINTMENT_CLASSES = {
                horizontal: "dx-scheduler-appointment-horizontal",
                vertical: "dx-scheduler-appointment-vertical"
            },
            RECURRENCE_APPOINTMENT_CLASS = "dx-scheduler-appointment-recurrence",
            COMPACT_APPOINTMENT_CLASS = "dx-scheduler-appointment-compact",
            REDUCED_APPOINTMENT_CLASS = "dx-scheduler-appointment-reduced",
            REDUCED_APPOINTMENT_ICON = "dx-scheduler-appointment-reduced-icon",
            REDUCED_APPOINTMENT_PARTS_CLASSES = {
                head: "dx-scheduler-appointment-head",
                body: "dx-scheduler-appointment-body",
                tail: "dx-scheduler-appointment-tail"
            };
        var Appointment = DOMComponent.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            data: {},
                            geometry: {
                                top: 0,
                                left: 0,
                                width: 0,
                                height: 0
                            },
                            allowDrag: true,
                            allowResize: true,
                            reduced: null,
                            isCompact: false,
                            sortedIndex: undefined,
                            direction: "vertical",
                            resizableConfig: {}
                        })
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"data":
                        case"geometry":
                        case"allowDrag":
                        case"allowResize":
                        case"reduced":
                        case"sortedIndex":
                        case"isCompact":
                        case"direction":
                        case"resizableConfig":
                            this._invalidate();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _render: function() {
                    this.callBase();
                    this._renderAppointmentGeometry();
                    this._renderEmptyClass();
                    this._renderCompactClass();
                    this._renderReducedAppointment();
                    this._renderAllDayClass();
                    this._renderDirection();
                    this.element().attr("title", this.invoke("getField", "text", this.option("data")));
                    this.element().attr("role", "button");
                    this._renderRecurrenceClass();
                    this._renderSortedTabIndex();
                    this._renderResizable()
                },
                _renderAppointmentGeometry: function() {
                    var geometry = this.option("geometry"),
                        $element = this.element();
                    translator.move($element, {
                        top: geometry.top,
                        left: geometry.left
                    });
                    $element.css({
                        width: geometry.width,
                        height: geometry.height
                    })
                },
                _renderEmptyClass: function() {
                    var geometry = this.option("geometry");
                    if (geometry.width < EMPTY_APPOINTMENT_MAX_WIDTH)
                        this.element().addClass(EMPTY_APPOINTMENT_CLASS)
                },
                _renderReducedAppointment: function() {
                    var reducedPart = this.option("reduced");
                    if (!reducedPart)
                        return;
                    this.element().toggleClass(REDUCED_APPOINTMENT_CLASS, true).toggleClass(REDUCED_APPOINTMENT_PARTS_CLASSES[reducedPart], true);
                    this._renderAppointmentReducedIcon()
                },
                _renderAppointmentReducedIcon: function() {
                    var $icon = $("<div>").addClass(REDUCED_APPOINTMENT_ICON).appendTo(this.element()),
                        endDate = this._getEndDate();
                    $icon.off(REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME).on(REDUCED_APPOINTMENT_POINTERENTER_EVENT_NAME, function() {
                        tooltip.show({
                            target: $icon,
                            content: Globalize.localize("dxScheduler-editorLabelEndDate") + ": " + Globalize.format(endDate, "d MMMM yyyy")
                        })
                    }).off(REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME).on(REDUCED_APPOINTMENT_POINTERLEAVE_EVENT_NAME, function() {
                        tooltip.hide()
                    })
                },
                _getEndDate: function() {
                    var result = this.invoke("getField", "endDate", this.option("data"));
                    if (result)
                        return dateUtils.makeDate(result);
                    return result
                },
                _renderAllDayClass: function() {
                    this.element().toggleClass(APPOINTMENT_ALL_DAY_ITEM_CLASS, !!this.option("allDay"))
                },
                _renderRecurrenceClass: function() {
                    var rule = this.invoke("getField", "recurrenceRule", this.option("data"));
                    if (recurrenceUtils.getRecurrenceRule(rule).isValid)
                        this.element().addClass(RECURRENCE_APPOINTMENT_CLASS)
                },
                _renderSortedTabIndex: function() {
                    var sortedIndex = this.option("sortedIndex");
                    this.element().attr("sortedIndex", sortedIndex);
                    this.element().attr("tabIndex", sortedIndex === 0 ? 0 : -1)
                },
                _renderCompactClass: function() {
                    this.element().toggleClass(COMPACT_APPOINTMENT_CLASS, !!this.option("isCompact"))
                },
                _renderDirection: function() {
                    this.element().addClass(DIRECTION_APPOINTMENT_CLASSES[this.option("direction")])
                },
                _renderResizable: function() {
                    if (!this.option("allowResize") || this.option("isCompact"))
                        return;
                    this._createComponent(this.element(), "dxResizable", this.option("resizableConfig"))
                }
            }).include(publisherMixin);
        registerComponent("dxSchedulerAppointment", {}, Appointment);
        return Appointment
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.appointment"]);
    /*! Module widgets-web, file ui.scheduler.appointments.strategy.base.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointments.strategy.base", ["jquery", "/class", "/ui/ui.errors", "/utils/utils.date"], function($, Class, errors, dateUtils) {
        var abstract = Class.abstract;
        var APPOINTMENT_DEFAULT_SIZE = 20,
            COMPACT_APPOINTMENT_DEFAULT_SIZE = 15,
            COMPACT_APPOINTMENT_DEFAULT_OFFSET = 3;
        var BaseRenderingStrategy = Class.inherit({
                ctor: function(instance) {
                    this.instance = instance
                },
                getAppointmentDefaultSize: function() {
                    return APPOINTMENT_DEFAULT_SIZE
                },
                resizableConfig: abstract,
                getHorizontalResizableHandles: function(skippedDirection) {
                    var rtlEnabled = this._isRtl();
                    if (!skippedDirection)
                        return "right left";
                    if (skippedDirection === "increase")
                        return rtlEnabled ? "right" : "left";
                    return rtlEnabled ? "left" : "right"
                },
                getDeltaTime: abstract,
                getAppointmentGeometry: function(coordinates) {
                    return this.applyCellBorder(coordinates)
                },
                createTaskPositionMap: function(items) {
                    var length = items.length;
                    if (!length)
                        return;
                    this._defaultWidth = this.instance._cellWidth;
                    this._defaultHeight = this.instance._cellHeight;
                    this._allDayHeight = this.instance._allDayCellHeight;
                    var map = [];
                    for (var i = 0; i < length; i++) {
                        var coordinates = this._getItemPosition(items[i]);
                        if (this._isRtl())
                            coordinates = this._correctRtlCoordinates(coordinates);
                        map.push(coordinates)
                    }
                    var positionArray = this._getSortedPositions(map),
                        resultPositions = this._getResultPositions(positionArray);
                    return this._getExtendedPositionMap(map, resultPositions)
                },
                applyCellBorder: function(config) {
                    var cellBorderSize = 1;
                    config.left += cellBorderSize;
                    config.top += cellBorderSize;
                    config.width -= cellBorderSize;
                    config.height -= cellBorderSize;
                    return config
                },
                _getDeltaWidth: function(args, initialSize) {
                    var cellWidth = this._defaultWidth || this.getAppointmentDefaultSize(),
                        initialWidth = initialSize.width;
                    return Math.round((args.width - initialWidth) / cellWidth)
                },
                _correctRtlCoordinates: function(coordinates) {
                    var width = coordinates[0].width || this._getAppointmentMaxWidth();
                    if (!coordinates[0].appointmentReduced)
                        coordinates[0].left -= width;
                    this._correctRtlCoordinatesParts(coordinates, width);
                    return coordinates
                },
                _correctRtlCoordinatesParts: $.noop,
                _getAppointmentMaxWidth: function() {
                    return this._defaultWidth
                },
                _getItemPosition: function(item) {
                    var height = this.calculateAppointmentHeight(item),
                        width = this.calculateAppointmentWidth(item),
                        sourceAppointmentWidth = width,
                        position = this._getAppointmentCoordinates(item),
                        allDay = this.isAllDay(item),
                        result = [],
                        startDate = this.instance.invoke("getField", "startDate", item);
                    for (var j = 0; j < position.length; j++) {
                        var resultWidth = width,
                            appointmentReduced = null,
                            multiWeekAppointmentParts = [];
                        if (this._needVerifyItemSize() || allDay) {
                            var currentMaxAllowedPosition = position[j].max;
                            if (this.isAppointmentGreaterThan(currentMaxAllowedPosition, {
                                left: position[j].left,
                                width: sourceAppointmentWidth
                            })) {
                                appointmentReduced = "head";
                                resultWidth = this._reduceMultiWeekAppointment(width, {
                                    left: position[j].left,
                                    right: currentMaxAllowedPosition
                                });
                                multiWeekAppointmentParts = this._getMultiWeekAppointmentParts({
                                    sourceAppointmentWidth: sourceAppointmentWidth,
                                    reducedWidth: resultWidth,
                                    height: height
                                }, position[j], startDate, j);
                                if (this._isRtl())
                                    position[j].left = currentMaxAllowedPosition
                            }
                        }
                        $.extend(position[j], {
                            height: height,
                            width: resultWidth,
                            allDay: allDay,
                            appointmentReduced: appointmentReduced
                        });
                        if (multiWeekAppointmentParts.length) {
                            multiWeekAppointmentParts.unshift(position[j]);
                            result = $.merge(result, multiWeekAppointmentParts)
                        }
                        else
                            result.push(position[j])
                    }
                    return result
                },
                _getAppointmentCoordinates: function(itemData) {
                    var coordinates = [{
                                top: 0,
                                left: 0
                            }],
                        startDate = this._startDate(itemData);
                    this.instance.notifyObserver("needCoordinates", {
                        startDate: startDate,
                        appointmentData: itemData,
                        callback: function(value) {
                            coordinates = value
                        }
                    });
                    return coordinates
                },
                _needVerifyItemSize: function() {
                    return false
                },
                _isRtl: function() {
                    return this.instance.option("rtlEnabled")
                },
                _getMultiWeekAppointmentParts: function() {
                    return []
                },
                _reduceMultiWeekAppointment: function(sourceAppointmentWidth, bound) {
                    if (this._isRtl())
                        sourceAppointmentWidth = Math.floor(bound.left - bound.right);
                    else
                        sourceAppointmentWidth = bound.right - Math.floor(bound.left);
                    return sourceAppointmentWidth
                },
                calculateAppointmentHeight: function() {
                    return 0
                },
                calculateAppointmentWidth: function() {
                    return 0
                },
                isAppointmentGreaterThan: function(etalon, comparisonParameters) {
                    var result = comparisonParameters.left + comparisonParameters.width - etalon;
                    if (this._isRtl())
                        result = etalon + comparisonParameters.width - comparisonParameters.left;
                    return result > this._defaultWidth / 2
                },
                isAllDay: function() {
                    return false
                },
                _getSortedPositions: function(arr) {
                    var result = [],
                        __tmpIndex = 0;
                    for (var i = 0, arrLength = arr.length; i < arrLength; i++)
                        for (var j = 0, itemLength = arr[i].length; j < itemLength; j++) {
                            var item = arr[i][j];
                            var start = {
                                    i: i,
                                    j: j,
                                    top: item.top,
                                    left: item.left,
                                    isStart: true,
                                    allDay: item.allDay,
                                    __tmpIndex: __tmpIndex
                                };
                            __tmpIndex++;
                            var end = {
                                    i: i,
                                    j: j,
                                    top: item.top + item.height,
                                    left: item.left + item.width,
                                    isStart: false,
                                    allDay: item.allDay,
                                    __tmpIndex: __tmpIndex
                                };
                            result.push(start, end);
                            __tmpIndex++
                        }
                    result.sort($.proxy(function(a, b) {
                        return this._sortCondition(a, b)
                    }, this));
                    return result
                },
                _fixUnstableSorting: function(comparisonResult, a, b) {
                    if (comparisonResult === 0) {
                        if (a.__tmpIndex < b.__tmpIndex)
                            return -1;
                        if (a.__tmpIndex > b.__tmpIndex)
                            return 1
                    }
                    return comparisonResult
                },
                _sortCondition: abstract,
                _rowCondition: function(a, b) {
                    var columnCondition = this._normalizeCondition(a.left, b.left),
                        rowCondition = this._normalizeCondition(a.top, b.top);
                    return columnCondition ? columnCondition : rowCondition ? rowCondition : a.isStart - b.isStart
                },
                _columnCondition: function(a, b) {
                    var columnCondition = this._normalizeCondition(a.left, b.left),
                        rowCondition = this._normalizeCondition(a.top, b.top);
                    return rowCondition ? rowCondition : columnCondition ? columnCondition : a.isStart - b.isStart
                },
                _normalizeCondition: function(first, second) {
                    var result = first - second;
                    return Math.abs(result) > 1.001 ? result : 0
                },
                _getResultPositions: function(sortedArray) {
                    var stack = [],
                        indexes = [],
                        result = [],
                        intersectPositions = [],
                        intersectPositionCount = 0,
                        sortedIndex = 0,
                        position;
                    for (var i = 0; i < sortedArray.length; i++) {
                        var current = sortedArray[i],
                            j;
                        if (current.isStart) {
                            position = undefined;
                            for (j = 0; j < indexes.length; j++)
                                if (!indexes[j]) {
                                    position = j;
                                    indexes[j] = true;
                                    break
                                }
                            if (position === undefined) {
                                position = indexes.length;
                                indexes.push(true);
                                for (j = 0; j < stack.length; j++)
                                    stack[j].count++
                            }
                            stack.push({
                                index: position,
                                count: indexes.length,
                                i: current.i,
                                j: current.j,
                                sortedIndex: sortedIndex++
                            });
                            if (intersectPositionCount < indexes.length)
                                intersectPositionCount = indexes.length
                        }
                        else {
                            var removeIndex = this._findIndexByKey(stack, "i", "j", current.i, current.j),
                                resultItem = stack[removeIndex];
                            stack.splice(removeIndex, 1);
                            indexes[resultItem.index] = false;
                            intersectPositions.push(resultItem);
                            if (!stack.length) {
                                indexes = [];
                                for (var k = 0; k < intersectPositions.length; k++)
                                    intersectPositions[k].count = intersectPositionCount;
                                intersectPositions = [];
                                intersectPositionCount = 0
                            }
                            result.push(resultItem)
                        }
                    }
                    return result.sort(function(a, b) {
                            var columnCondition = a.j - b.j,
                                rowCondition = a.i - b.i;
                            return rowCondition ? rowCondition : columnCondition
                        })
                },
                _findIndexByKey: function(arr, ikey, jkey, ivalue, jvalue) {
                    var result = 0;
                    for (var i = 0, len = arr.length; i < len; i++)
                        if (arr[i][ikey] === ivalue && arr[i][jkey] === jvalue) {
                            result = i;
                            break
                        }
                    return result
                },
                _getExtendedPositionMap: function(map, positions) {
                    var positionCounter = 0;
                    for (var i = 0, mapLength = map.length; i < mapLength; i++)
                        for (var j = 0, itemLength = map[i].length; j < itemLength; j++) {
                            map[i][j].index = positions[positionCounter].index;
                            map[i][j].sortedIndex = positions[positionCounter].sortedIndex;
                            map[i][j].count = positions[positionCounter++].count;
                            map[i][j].virtualIndex = map[i][j].top + "-" + map[i][j].left
                        }
                    return map
                },
                _startDate: function(appointment, skipNormalize) {
                    var startDate = this.instance._getStartDate(appointment, skipNormalize),
                        text = this.instance.invoke("getField", "text", appointment);
                    if (isNaN(startDate.getTime()))
                        throw errors.Error("E1032", text);
                    return startDate
                },
                _endDate: function(appointment) {
                    var endDate = this.instance._getEndDate(appointment),
                        realStartDate = this._startDate(appointment, true),
                        viewStartDate = this._startDate(appointment);
                    if (!endDate || realStartDate >= endDate) {
                        endDate = new Date(realStartDate.getTime() + this.instance.option("appointmentDurationInMinutes") * 60000);
                        this.instance.invoke("setField", "endDate", appointment, endDate)
                    }
                    if (viewStartDate >= endDate) {
                        var duration = endDate.getTime() - realStartDate.getTime();
                        endDate = new Date(viewStartDate.getTime() + duration)
                    }
                    return endDate
                },
                _getMaxNeighborAppointmentCount: function() {
                    var outerAppointmentWidth = this.getCompactAppointmentDefaultSize() + this.getCompactAppointmentDefaultOffset();
                    return Math.floor(this.getCompactAppointmentGroupMaxWidth() / outerAppointmentWidth)
                },
                _markAppointmentAsVirtual: function(coordinates, isAllDay) {
                    var countFullWidthAppointmentInCell = 2;
                    if (coordinates.count - countFullWidthAppointmentInCell > this._getMaxNeighborAppointmentCount())
                        coordinates.virtual = {
                            top: coordinates.top,
                            left: coordinates.left,
                            index: coordinates.virtualIndex,
                            isAllDay: isAllDay
                        }
                },
                getCompactAppointmentGroupMaxWidth: function() {
                    var widthInPercents = 75;
                    return widthInPercents * this.getDefaultCellWidth() / 100
                },
                getDefaultCellWidth: function() {
                    return this._defaultWidth
                },
                getCompactAppointmentDefaultSize: function() {
                    return COMPACT_APPOINTMENT_DEFAULT_SIZE
                },
                getCompactAppointmentDefaultOffset: function() {
                    return COMPACT_APPOINTMENT_DEFAULT_OFFSET
                }
            });
        return BaseRenderingStrategy
    });
    /*! Module widgets-web, file ui.scheduler.appointments.strategy.horizontal.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointments.strategy.horizontal", ["jquery", "/ui/widgets/scheduler/ui.scheduler.appointments.strategy.base", "/utils/utils.date"], function($, BaseAppointmentsStrategy, dateUtils) {
        var MAX_APPOINTMENT_HEIGHT = 100,
            BOTTOM_CELL_GAP = 20,
            toMs = dateUtils.dateToMilliseconds;
        var HorizontalRenderingStrategy = BaseAppointmentsStrategy.inherit({
                resizableConfig: function(appointmentData, skippedDirection) {
                    return {
                            minWidth: this._defaultWidth,
                            minHeight: 0,
                            step: this._defaultWidth,
                            handles: this.getHorizontalResizableHandles(skippedDirection)
                        }
                },
                _needVerifyItemSize: function() {
                    return true
                },
                calculateAppointmentWidth: function(appointment) {
                    var cellWidth = this._defaultWidth || this.getAppointmentDefaultSize(),
                        allDay = this.instance.invoke("getField", "allDay", appointment),
                        minWidth = this.getAppointmentDefaultSize(),
                        durationInCells = 0,
                        width;
                    var dayDuration = toMs("day"),
                        startDate = this._startDate(appointment),
                        endDate = this._endDate(appointment),
                        appointmentDuration = endDate.getTime() - startDate.getTime();
                    if (allDay) {
                        var ceilQuantityOfDays = Math.ceil(appointmentDuration / dayDuration);
                        durationInCells = ceilQuantityOfDays * (this.instance.option("dayDuration") * 60 / this.instance.option("appointmentDurationInMinutes"))
                    }
                    else {
                        var floorQuantityOfDays = Math.floor(appointmentDuration / dayDuration),
                            tailDuration = appointmentDuration % dayDuration,
                            visibleDayDuration = this.instance.option("dayDuration") * toMs("hour");
                        if (tailDuration > visibleDayDuration)
                            tailDuration = visibleDayDuration;
                        var cellDuration = this.instance.option("appointmentDurationInMinutes") * toMs("minute");
                        durationInCells = (floorQuantityOfDays * visibleDayDuration + tailDuration) / cellDuration
                    }
                    width = durationInCells * cellWidth;
                    if (width < minWidth)
                        width = minWidth;
                    return width
                },
                getAppointmentGeometry: function(coordinates) {
                    var result = this._customizeAppointmentGeometry(coordinates);
                    return this.callBase(result)
                },
                _customizeAppointmentGeometry: function(coordinates) {
                    var cellHeight = (this._defaultHeight || this.getAppointmentDefaultSize()) - BOTTOM_CELL_GAP,
                        height = cellHeight / coordinates.count;
                    if (height > MAX_APPOINTMENT_HEIGHT)
                        height = MAX_APPOINTMENT_HEIGHT;
                    var top = coordinates.top + coordinates.index * height;
                    return {
                            height: height,
                            width: coordinates.width,
                            top: top,
                            left: coordinates.left
                        }
                },
                _correctRtlCoordinatesParts: function(coordinates, width) {
                    for (var i = 1; i < coordinates.length; i++)
                        coordinates[i].left -= width;
                    return coordinates
                },
                _sortCondition: function(a, b) {
                    var result = this._columnCondition(a, b);
                    return this._fixUnstableSorting(result, a, b)
                },
                _getMaxAppointmentWidth: function(startDate) {
                    var result;
                    this.instance.notifyObserver("getMaxAppointmentWidth", {
                        date: startDate,
                        callback: function(width) {
                            result = width
                        }
                    });
                    return result
                },
                getDeltaTime: function(args, initialSize) {
                    var deltaWidth = this._getDeltaWidth(args, initialSize);
                    return this.instance.option("appointmentDurationInMinutes") * toMs("minute") * deltaWidth
                },
                isAllDay: function(appointmentData) {
                    return this.instance.invoke("getField", "allDay", appointmentData)
                }
            });
        return HorizontalRenderingStrategy
    });
    /*! Module widgets-web, file ui.scheduler.appointments.strategy.horizontalMonth.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointments.strategy.horizontalMonth", ["jquery", "/ui/widgets/scheduler/ui.scheduler.appointments.strategy.horizontal", "/utils/utils.date"], function($, HorizontalAppointmentsStrategy, dateUtils) {
        var MONTH_APPOINTMENT_HEIGHT_RATIO = 0.6;
        var HorizontalMonthRenderingStrategy = HorizontalAppointmentsStrategy.inherit({
                _skipResizingForReducedAppointments: function(appointmentReduced) {
                    var result = true;
                    if (appointmentReduced === "head")
                        result = "increase";
                    else if (appointmentReduced === "tail")
                        result = "decrease";
                    return result
                },
                _getMultiWeekAppointmentParts: function(appointmentGeometry, appointmentSettings, startDate, groupIndex) {
                    var deltaWidth = appointmentGeometry.sourceAppointmentWidth - appointmentGeometry.reducedWidth,
                        height = appointmentGeometry.height,
                        fullWeekAppointmentWidth = this._getFullWeekAppointmentWidth(groupIndex),
                        maxAppointmentWidth = this._getMaxAppointmentWidth(startDate),
                        longPartCount = Math.floor(deltaWidth / fullWeekAppointmentWidth),
                        tailWidth = deltaWidth % fullWeekAppointmentWidth,
                        result = [],
                        totalWidth = appointmentGeometry.reducedWidth + tailWidth,
                        currentPartTop = appointmentSettings.top + this._defaultHeight,
                        left = this._calculateMultiWeekAppointmentLeftOffset(appointmentSettings.max, fullWeekAppointmentWidth);
                    for (var i = 0; i < longPartCount; i++) {
                        if (totalWidth > maxAppointmentWidth)
                            break;
                        result.push($.extend(true, {}, appointmentSettings, {
                            top: currentPartTop,
                            left: left,
                            height: height,
                            width: fullWeekAppointmentWidth,
                            appointmentReduced: "body"
                        }));
                        currentPartTop += this._defaultHeight;
                        totalWidth += fullWeekAppointmentWidth
                    }
                    if (tailWidth) {
                        if (this._isRtl())
                            left = left + (fullWeekAppointmentWidth - tailWidth);
                        result.push($.extend(true, {}, appointmentSettings, {
                            top: currentPartTop,
                            left: left,
                            height: height,
                            width: tailWidth,
                            appointmentReduced: "tail"
                        }))
                    }
                    return result
                },
                _calculateMultiWeekAppointmentLeftOffset: function(max, width) {
                    return this._isRtl() ? max : max - width
                },
                _correctRtlCoordinatesParts: $.noop,
                _getFullWeekAppointmentWidth: function(groupIndex) {
                    this.instance.notifyObserver("getFullWeekAppointmentWidth", {
                        groupIndex: groupIndex,
                        callback: $.proxy(function(width) {
                            this._maxFullWeekAppointmentWidth = width
                        }, this)
                    });
                    return this._maxFullWeekAppointmentWidth
                },
                _customizeAppointmentGeometry: function(coordinates) {
                    var maxHeight = this._defaultHeight || this.getAppointmentDefaultSize(),
                        index = coordinates.index,
                        height = MONTH_APPOINTMENT_HEIGHT_RATIO * maxHeight / 2,
                        top = (1 - MONTH_APPOINTMENT_HEIGHT_RATIO) * maxHeight + coordinates.top + index * height,
                        width = coordinates.width,
                        left = coordinates.left,
                        compactAppointmentDefaultSize,
                        compactAppointmentDefaultOffset;
                    if (index > 1) {
                        compactAppointmentDefaultSize = this.getCompactAppointmentDefaultSize();
                        compactAppointmentDefaultOffset = this.getCompactAppointmentDefaultOffset();
                        top = coordinates.top + compactAppointmentDefaultOffset;
                        left = coordinates.left + (index - 2) * (compactAppointmentDefaultSize + compactAppointmentDefaultOffset) + compactAppointmentDefaultOffset;
                        height = compactAppointmentDefaultSize,
                        width = compactAppointmentDefaultSize;
                        coordinates.isCompact = true;
                        this._markAppointmentAsVirtual(coordinates)
                    }
                    return {
                            height: height,
                            width: width,
                            top: top,
                            left: left
                        }
                },
                getAppointmentGeometry: function(coordinates) {
                    if (coordinates.appointmentReduced)
                        coordinates.skipResizing = this._skipResizingForReducedAppointments(coordinates.appointmentReduced);
                    return this.callBase(coordinates)
                },
                calculateAppointmentWidth: function(appointment) {
                    var startDate = new Date(this._startDate(appointment)),
                        endDate = this._endDate(appointment),
                        cellWidth = this._defaultWidth || this.getAppointmentDefaultSize();
                    startDate = dateUtils.trimTime(startDate);
                    var durationInHours = (endDate.getTime() - startDate.getTime()) / 3600000;
                    return Math.ceil(durationInHours / 24) * cellWidth
                },
                getDeltaTime: function(args, initialSize) {
                    var deltaWidth = this._getDeltaWidth(args, initialSize);
                    return 24 * 60 * 60000 * deltaWidth
                },
                isAllDay: function() {
                    return false
                }
            });
        return HorizontalMonthRenderingStrategy
    });
    /*! Module widgets-web, file ui.scheduler.appointments.strategy.vertical.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointments.strategy.vertical", ["jquery", "/ui/widgets/scheduler/ui.scheduler.appointments.strategy.base", "/utils/utils.date"], function($, BaseAppointmentsStrategy, dateUtils) {
        var WEEK_APPOINTMENT_DEFAULT_OFFSET = 15;
        var VerticalRenderingStrategy = BaseAppointmentsStrategy.inherit({
                resizableConfig: function(appointmentData, skippedDirection) {
                    if (this.isAllDay(appointmentData))
                        return {
                                minWidth: this._defaultWidth,
                                minHeight: 0,
                                step: this._defaultWidth,
                                handles: this.getHorizontalResizableHandles(skippedDirection)
                            };
                    return {
                            minHeight: this._defaultHeight,
                            step: this._defaultHeight,
                            handles: "top bottom"
                        }
                },
                getDeltaTime: function(args, initialSize, appointment) {
                    var deltaTime = 0;
                    if (this.isAllDay(appointment))
                        deltaTime = this._getDeltaWidth(args, initialSize) * 24 * 60 * 60000;
                    else {
                        var deltaHeight = args.height - initialSize.height;
                        if (deltaHeight < 0)
                            deltaHeight = this._correctOnePxGap(deltaHeight);
                        deltaTime = 60000 * deltaHeight / this._defaultHeight * this.instance.option("appointmentDurationInMinutes")
                    }
                    return deltaTime
                },
                getAppointmentGeometry: function(coordinates) {
                    var result,
                        allDay = coordinates.allDay;
                    if (allDay)
                        result = this._getAllDayAppointmentGeometry(coordinates);
                    else
                        result = this._getSimpleAppointmentGeometry(coordinates);
                    return this.callBase(result)
                },
                _correctOnePxGap: function(deltaHeight) {
                    if (Math.abs(deltaHeight) % this._defaultHeight)
                        deltaHeight--;
                    return deltaHeight
                },
                _getMinuteHeight: function() {
                    return this._defaultHeight / this.instance.option("appointmentDurationInMinutes")
                },
                _getAllDayAppointmentGeometry: function(coordinates) {
                    var maxHeight = this._allDayHeight || this.getAppointmentDefaultSize(),
                        index = coordinates.index,
                        count = coordinates.count,
                        height = maxHeight / (count > 3 ? 3 : count),
                        width = coordinates.width,
                        top = coordinates.top + index * height,
                        left = coordinates.left,
                        compactAppointmentDefaultSize = this.getCompactAppointmentDefaultSize();
                    if (!this.instance.option("allowResize") || !this.instance.option("allowAllDayResize"))
                        coordinates.skipResizing = true;
                    if (count > 3)
                        if (index > 1) {
                            top = coordinates.top;
                            left = coordinates.left + (index - 2) * compactAppointmentDefaultSize;
                            height = compactAppointmentDefaultSize,
                            width = compactAppointmentDefaultSize;
                            coordinates.isCompact = true;
                            this._markAppointmentAsVirtual(coordinates, true)
                        }
                        else
                            top += height;
                    return {
                            height: height,
                            width: width,
                            top: top,
                            left: left
                        }
                },
                _getSimpleAppointmentGeometry: function(coordinates) {
                    var width = this._getAppointmentMaxWidth() / coordinates.count,
                        height = coordinates.height,
                        top = coordinates.top,
                        left = coordinates.left + coordinates.index * width;
                    return {
                            height: height,
                            width: width,
                            top: top,
                            left: left
                        }
                },
                isAllDay: function(appointmentData) {
                    var appointmentTakesAllDay = false,
                        startDate = this.instance.invoke("getField", "startDate", appointmentData),
                        endDate = this.instance.invoke("getField", "endDate", appointmentData),
                        allDay = this.instance.invoke("getField", "allDay", appointmentData);
                    this.instance.notifyObserver("appointmentTakesAllDay", {
                        startDate: startDate,
                        endDate: endDate,
                        callback: function(result) {
                            appointmentTakesAllDay = result
                        }
                    });
                    return allDay || appointmentTakesAllDay
                },
                _getAppointmentMaxWidth: function() {
                    return this._defaultWidth - WEEK_APPOINTMENT_DEFAULT_OFFSET || this.getAppointmentDefaultSize()
                },
                calculateAppointmentWidth: function(appointment) {
                    if (!this.isAllDay(appointment))
                        return 0;
                    var startDate = new Date(this._startDate(appointment)),
                        endDate = this._endDate(appointment),
                        cellWidth = this._defaultWidth || this.getAppointmentDefaultSize();
                    startDate = dateUtils.trimTime(startDate);
                    var durationInHours = (endDate.getTime() - startDate.getTime()) / 3600000;
                    var width = Math.ceil(durationInHours / 24) * cellWidth;
                    return width
                },
                calculateAppointmentHeight: function(appointment) {
                    if (this.isAllDay(appointment))
                        return 0;
                    var startDate = this._startDate(appointment),
                        endDate = this._endDate(appointment);
                    var durationInMinutes = (endDate.getTime() - startDate.getTime()) / 60000,
                        minHeight = this.getAppointmentDefaultSize();
                    var height = Math.round(durationInMinutes * this._getMinuteHeight());
                    if (height < minHeight)
                        height = minHeight;
                    return height
                },
                _sortCondition: function(a, b) {
                    var allDayCondition = a.allDay - b.allDay,
                        result = allDayCondition ? allDayCondition : this._rowCondition(a, b);
                    return this._fixUnstableSorting(result, a, b)
                }
            });
        return VerticalRenderingStrategy
    });
    /*! Module widgets-web, file ui.scheduler.appointments.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointments", ["jquery", "/ui/uiNamespace", "/utils/utils.translator", "/utils/utils.array", "/utils/utils.date", "/utils/utils.common", "/componentRegistrator", "/ui/ui.tooltip", "/ui/widgets/scheduler/ui.scheduler.publisherMixin", "/ui/widgets/scheduler/ui.scheduler.appointment", "/ui/widgets/scheduler/ui.scheduler.appointments.strategy.vertical", "/ui/widgets/scheduler/ui.scheduler.appointments.strategy.horizontal", "/ui/widgets/scheduler/ui.scheduler.appointments.strategy.horizontalMonth", "/ui/events/ui.events.utils", "/ui/events/pointer/ui.events.pointer", "/ui/templates/ui.template.function"], function($, ui, translator, array, dateUtils, commonUtils, registerComponent, tooltip, publisherMixin, Appointment, VerticalAppointmentsStrategy, HorizontalAppointmentsStrategy, HorizontalMonthAppointmentsStrategy, eventUtils, pointerEvents, FunctionTemplate) {
        var CollectionWidget = ui.CollectionWidget;
        var COMPONENT_CLASS = "dx-scheduler-scrollable-appointments",
            APPOINTMENT_ITEM_CLASS = "dx-scheduler-appointment",
            DBLCLICK_EVENT_NAME = eventUtils.addNamespace("dxdblclick", "dxSchedulerAppointment");
        var RENDERING_STRATEGIES = {
                horizontal: HorizontalAppointmentsStrategy,
                horizontalMonth: HorizontalMonthAppointmentsStrategy,
                vertical: VerticalAppointmentsStrategy
            };
        var SchedulerAppointments = CollectionWidget.inherit({
                _supportedKeys: function(e) {
                    var parent = this.callBase();
                    var tabHandler = function(e) {
                            var appointments = this._getAccessAppointments(),
                                focusedAppointment = appointments.filter(".dx-state-focused"),
                                index = focusedAppointment.attr("sortedIndex"),
                                lastIndex = appointments.length - 1;
                            if (index > 0 && e.shiftKey || index < lastIndex && !e.shiftKey) {
                                e.preventDefault();
                                e.shiftKey ? index-- : index++;
                                var $nextAppointment = this._getAppointmentByIndex(index);
                                this._resetTabIndex($nextAppointment);
                                $nextAppointment.focus()
                            }
                        };
                    return $.extend(parent, {
                            escape: $.proxy(function() {
                                this.moveAppointmentBack();
                                this._escPressed = true
                            }, this),
                            del: $.proxy(function(e) {
                                if (this.option("allowDelete")) {
                                    e.preventDefault();
                                    var data = this._getItemData(e.target);
                                    this.notifyObserver("deleteAppointment", {
                                        data: data,
                                        target: e.target
                                    });
                                    this.notifyObserver("hideAppointmentTooltip")
                                }
                            }),
                            tab: tabHandler
                        })
                },
                _getAppointmentByIndex: function(index) {
                    var appointments = this._getAccessAppointments();
                    return appointments.filter("[sortedIndex =" + index + "]").eq(0)
                },
                _getAccessAppointments: function() {
                    return this._itemElements().filter(":visible").not(".dx-state-disabled")
                },
                _resetTabIndex: function($appointment) {
                    this._focusTarget().attr("tabindex", -1);
                    $appointment.attr("tabindex", this.option("tabIndex"))
                },
                _moveFocus: $.noop,
                _focusTarget: function() {
                    return this._itemElements()
                },
                _renderFocusTarget: function() {
                    var $appointment = this._getAppointmentByIndex(0);
                    this._resetTabIndex($appointment)
                },
                _focusInHandler: function(e) {
                    if (this._targetIsDisabled(e)) {
                        e.stopPropagation();
                        return
                    }
                    this.callBase.apply(this, arguments);
                    this._$currentAppointment = $(e.target);
                    this.option("focusedElement", $(e.target));
                    var that = this;
                    setTimeout(function() {
                        that.notifyObserver("appointmentFocused")
                    })
                },
                _targetIsDisabled: function(e) {
                    return $(e.currentTarget).is(".dx-state-disabled, .dx-state-disabled *")
                },
                _focusOutHandler: function(e) {
                    var $appointment = this._getAppointmentByIndex(0);
                    this.option("focusedElement", $appointment);
                    this.callBase.apply(this, arguments)
                },
                _eventBindingTarget: function() {
                    return this._itemContainer()
                },
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            noDataText: null,
                            activeStateEnabled: true,
                            hoverStateEnabled: true,
                            tabIndex: 0,
                            appointmentDurationInMinutes: 30,
                            fixedContainer: null,
                            allDayContainer: null,
                            renderingStrategy: "vertical",
                            allowDrag: true,
                            allowResize: true,
                            allowAllDayResize: true,
                            onAppointmentDblClick: null,
                            dayDuration: 24
                        })
                },
                _optionChanged: function(args) {
                    switch (args.name) {
                        case"renderingStrategy":
                            this._initRenderingStrategy();
                            break;
                        case"fixedContainer":
                        case"allDayContainer":
                        case"onAppointmentDblClick":
                            break;
                        case"allowDrag":
                        case"allowResize":
                        case"allowAllDayResize":
                        case"dayDuration":
                        case"appointmentDurationInMinutes":
                            this.repaint();
                            break;
                        case"focusedElement":
                            this._resetTabIndex($(args.value));
                            this.callBase(args);
                            break;
                        case"allowDelete":
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _itemClass: function() {
                    return APPOINTMENT_ITEM_CLASS
                },
                _itemContainer: function() {
                    var $container = this.callBase(),
                        $result = $container,
                        $allDayContainer = this.option("allDayContainer");
                    if ($allDayContainer)
                        $result = $container.add($allDayContainer);
                    return $result
                },
                _cleanItemContainer: function() {
                    this.callBase();
                    var $allDayContainer = this.option("allDayContainer");
                    if ($allDayContainer)
                        $allDayContainer.empty();
                    this._virtualAppointments = {}
                },
                _clean: function() {
                    this.callBase();
                    delete this._$currentAppointment;
                    delete this._initialSize;
                    delete this._initialCoordinates
                },
                _init: function() {
                    this.callBase();
                    this._initRenderingStrategy();
                    this.element().addClass(COMPONENT_CLASS);
                    this._preventSingleAppointmentClick = false;
                    this._initDynamicTemplates()
                },
                _initRenderingStrategy: function() {
                    var Strategy = RENDERING_STRATEGIES[this.option("renderingStrategy")];
                    this._renderingStrategy = new Strategy(this)
                },
                _initDynamicTemplates: function() {
                    this._dynamicTemplates["item"] = new FunctionTemplate($.proxy(function(itemData) {
                        var text = this.invoke("getField", "text", itemData),
                            startDate = dateUtils.makeDate(this.invoke("getField", "startDate", itemData)),
                            endDate = dateUtils.makeDate(this.invoke("getField", "endDate", itemData)),
                            rrule = this.invoke("getField", "recurrenceRule", itemData),
                            $text = $("<div>").text(text),
                            $contentDetails = $("<div>").addClass("dx-scheduler-appointment-content-details");
                        $("<div>").addClass("dx-scheduler-appointment-content-date").text(Globalize.format(startDate, "t")).appendTo($contentDetails),
                        $("<div>").addClass("dx-scheduler-appointment-content-date").text(" - ").appendTo($contentDetails),
                        $("<div>").addClass("dx-scheduler-appointment-content-date").text(Globalize.format(endDate, "t")).appendTo($contentDetails);
                        if (rrule)
                            $("<span>").addClass("dx-scheduler-appointment-recurrence-icon dx-icon-repeat").appendTo($contentDetails);
                        return [$text, $contentDetails]
                    }, this))
                },
                _executeItemRenderAction: function(index, itemData, itemElement) {
                    var action = this._getItemRenderAction();
                    if (action)
                        action({
                            appointmentElement: itemElement,
                            appointmentData: itemData
                        })
                },
                _getStartDate: function(appointment, skipNormalize) {
                    var startDate = this.invoke("getField", "startDate", appointment);
                    startDate = dateUtils.makeDate(startDate);
                    !skipNormalize && this.notifyObserver("updateAppointmentStartDate", {
                        startDate: startDate,
                        appointment: appointment,
                        callback: function(result) {
                            startDate = result
                        }
                    });
                    return startDate
                },
                _getEndDate: function(appointment) {
                    var endDate = this.invoke("getField", "endDate", appointment);
                    if (endDate) {
                        endDate = dateUtils.makeDate(endDate);
                        this.notifyObserver("updateAppointmentEndDate", {
                            endDate: endDate,
                            callback: function(result) {
                                endDate = result
                            }
                        })
                    }
                    return endDate
                },
                _itemClickHandler: function(e) {
                    this.callBase(e, {}, {afterExecute: $.proxy(function(e) {
                            this._processItemClick(e.args[0].jQueryEvent)
                        }, this)})
                },
                _processItemClick: function(e) {
                    var $target = $(e.currentTarget),
                        data = this._getItemData($target);
                    if (this._targetIsDisabled(e)) {
                        e.stopPropagation();
                        return
                    }
                    this._normalizeAppointmentDates(data);
                    if (e.type === "keydown" || eventUtils.isFakeClickEvent(e)) {
                        this.notifyObserver("showEditAppointmentPopup", {
                            data: data,
                            target: $target
                        });
                        return
                    }
                    this._appointmentClickTimeout = setTimeout($.proxy(function() {
                        if (!this._preventSingleAppointmentClick)
                            this.notifyObserver("showAppointmentTooltip", {
                                data: data,
                                target: $target
                            });
                        this._preventSingleAppointmentClick = false
                    }, this), 300)
                },
                _normalizeAppointmentDates: function(appointmentData) {
                    var startDate = dateUtils.makeDate(this.invoke("getField", "startDate", appointmentData)),
                        endDate = dateUtils.makeDate(this.invoke("getField", "endDate", appointmentData));
                    this.invoke("setField", "startDate", appointmentData, startDate);
                    this.invoke("setField", "endDate", appointmentData, endDate)
                },
                _extendActionArgs: function() {
                    var args = this.callBase.apply(this, arguments);
                    return this._mapAppointmentFields(args)
                },
                _mapAppointmentFields: function(args) {
                    return {
                            appointmentData: args.itemData,
                            appointmentElement: args.itemElement
                        }
                },
                _render: function() {
                    this.callBase.apply(this, arguments);
                    this._attachAppointmentDblClick()
                },
                _attachAppointmentDblClick: function() {
                    var that = this,
                        itemSelector = that._itemSelector();
                    this._itemContainer().off(DBLCLICK_EVENT_NAME, itemSelector).on(DBLCLICK_EVENT_NAME, itemSelector, function(e) {
                        that._itemJQueryEventHandler(e, "onAppointmentDblClick", {}, {afterExecute: function(e) {
                                that._dblClickHandler(e.args[0].jQueryEvent)
                            }})
                    })
                },
                _dblClickHandler: function(e) {
                    var $targetAppointment = $(e.currentTarget),
                        appointmentData = this._getItemData($targetAppointment);
                    clearTimeout(this._appointmentClickTimeout);
                    this._preventSingleAppointmentClick = true;
                    this.notifyObserver("showEditAppointmentPopup", {
                        data: appointmentData,
                        target: $targetAppointment
                    })
                },
                _renderItems: function(items) {
                    if (this._isContainerInvisible())
                        return;
                    this.notifyObserver("getCellDimensions", {callback: $.proxy(function(width, height, allDayHeight) {
                            this._cellWidth = width;
                            this._cellHeight = height;
                            this._allDayCellHeight = allDayHeight
                        }, this)});
                    this._positionMap = this._renderingStrategy.createTaskPositionMap(items);
                    this.callBase(items)
                },
                _isContainerInvisible: function() {
                    var isContainerInvisible = false;
                    this.notifyObserver("checkContainerVisibility", {callback: function(result) {
                            isContainerInvisible = result
                        }});
                    return isContainerInvisible
                },
                _renderItem: function(index, itemData) {
                    var allDay = this._renderingStrategy.isAllDay(itemData),
                        $container = this._getAppointmentContainer(allDay);
                    this.callBase(index, itemData, $container)
                },
                _getAppointmentContainer: function(allDay) {
                    var $allDayContainer = this.option("allDayContainer"),
                        $container = this.itemsContainer().not($allDayContainer);
                    if (allDay && $allDayContainer)
                        $container = $allDayContainer;
                    return $container
                },
                _postprocessRenderItem: function(args) {
                    var $appointment = args.itemElement,
                        itemData = args.itemData,
                        itemSettings = this._positionMap[args.itemIndex];
                    this._applyResourceDataAttr($appointment);
                    this._renderAppointmentClones($appointment, itemData, itemSettings);
                    this._renderAppointment($appointment, itemSettings[0])
                },
                _applyResourceDataAttr: function($appointment) {
                    this.notifyObserver("getResourcesFromItem", {
                        itemData: this._getItemData($appointment),
                        callback: function(resources) {
                            if (resources)
                                $.each(resources, function(name, values) {
                                    var attr = "data-" + name.toLowerCase() + "-";
                                    for (var i = 0; i < values.length; i++)
                                        $appointment.attr(attr + values[i], true)
                                })
                        }
                    })
                },
                _renderAppointmentClones: function($appointment, itemData, coordinates) {
                    var coordinateCount = coordinates.length;
                    if (coordinateCount > 1)
                        for (var i = coordinateCount - 1; i > 0; i--) {
                            var $clone = $appointment.clone(true);
                            $appointment.after($clone);
                            translator.clearCache($clone);
                            this._renderAppointment($clone, coordinates[i]);
                            this._executeItemRenderAction(0, itemData, $clone)
                        }
                },
                _renderAppointment: function($appointment, settings) {
                    var appointmentData = this._getItemData($appointment),
                        geometry = this._renderingStrategy.getAppointmentGeometry(settings),
                        allowResize = !settings.isCompact && this.option("allowResize") && (!commonUtils.isDefined(settings.skipResizing) || commonUtils.isString(settings.skipResizing)),
                        allowDrag = this.option("allowDrag"),
                        allDay = this._renderingStrategy.isAllDay(appointmentData),
                        direction = this.option("renderingStrategy") === "vertical" && !allDay ? "vertical" : "horizontal";
                    this._createComponent($appointment, "dxSchedulerAppointment", {
                        observer: this.option("observer"),
                        data: appointmentData,
                        geometry: geometry,
                        direction: direction,
                        allowResize: allowResize,
                        allowDrag: allowDrag,
                        allDay: allDay,
                        reduced: settings.appointmentReduced,
                        isCompact: settings.isCompact,
                        sortedIndex: settings.sortedIndex,
                        cellWidth: this._cellWidth,
                        cellHeight: this._cellHeight,
                        resizableConfig: this._resizableConfig(appointmentData, settings)
                    });
                    var deferredColor = this._paintAppointment($appointment, settings.groupIndex);
                    if (settings.virtual)
                        deferredColor.done($.proxy(function(color) {
                            this._processVirtualAppointment(settings, $appointment, appointmentData, color)
                        }, this));
                    this._renderDraggable($appointment)
                },
                _resizableConfig: function(appointmentData, itemSetting) {
                    var skippedResizableDirection = itemSetting.skipResizing ? itemSetting.skipResizing : null,
                        config = this._renderingStrategy.resizableConfig(appointmentData, skippedResizableDirection);
                    return $.extend(config, {
                            area: this._calculateResizableArea(itemSetting, appointmentData),
                            onResizeStart: $.proxy(function(e) {
                                this._$currentAppointment = $(e.element);
                                this._initialSize = {
                                    width: e.width,
                                    height: e.height
                                };
                                this._initialCoordinates = translator.locate(e.element)
                            }, this),
                            onResizeEnd: $.proxy(function(e) {
                                if (this._escPressed) {
                                    e.jQueryEvent.cancel = true;
                                    return
                                }
                                this._resizeEndHandler(e)
                            }, this)
                        })
                },
                _calculateResizableArea: function(itemSetting, appointmentData) {
                    var area = this.element().closest(".dx-scrollable-content"),
                        allDay = this._renderingStrategy.isAllDay(appointmentData);
                    this.notifyObserver("getResizableAppointmentArea", {
                        coordinates: {
                            left: itemSetting.left,
                            top: 0
                        },
                        allDay: allDay,
                        callback: function(result) {
                            if (result)
                                area = result
                        }
                    });
                    return area
                },
                _resizeEndHandler: function(e) {
                    var itemData = this._getItemData(e.element),
                        startDate = this._getStartDate(itemData),
                        endDate = this._getEndDate(itemData);
                    var dateRange = this._getDateRange(e, startDate, endDate);
                    var updatedDates = {};
                    this.invoke("setField", "startDate", updatedDates, new Date(dateRange[0]));
                    this.invoke("setField", "endDate", updatedDates, new Date(dateRange[1]));
                    var data = $.extend({}, itemData, updatedDates);
                    this.notifyObserver("updateAppointmentAfterResize", {
                        target: itemData,
                        data: data,
                        $appointment: e.element
                    })
                },
                _getDateRange: function(e, startDate, endDate) {
                    var itemData = this._getItemData(e.element),
                        deltaTime = this._renderingStrategy.getDeltaTime(e, this._initialSize, itemData),
                        renderingStrategy = this.option("renderingStrategy"),
                        cond = false;
                    if (renderingStrategy !== "vertical" || this._renderingStrategy.isAllDay(itemData))
                        cond = this.option("rtlEnabled") ? e.handles.right : e.handles.left;
                    else
                        cond = e.handles.top;
                    var startTime = cond ? startDate.getTime() - deltaTime : startDate.getTime(),
                        endTime = cond ? endDate.getTime() : endDate.getTime() + deltaTime;
                    return [startTime, endTime]
                },
                _paintAppointment: function($appointment, groupIndex) {
                    var res = $.Deferred();
                    this.notifyObserver("getAppointmentColor", {
                        itemData: this._getItemData($appointment),
                        groupIndex: groupIndex,
                        callback: function(d) {
                            d.done(function(color) {
                                if (color)
                                    $appointment.css("background-color", color);
                                res.resolve(color)
                            })
                        }
                    });
                    return res.promise()
                },
                _renderDraggable: function($appointment) {
                    if (!this.option("allowDrag"))
                        return;
                    var that = this,
                        appointmentData = that._getItemData($appointment),
                        isAllDay = this._renderingStrategy.isAllDay(appointmentData),
                        $fixedContainer = this.option("fixedContainer"),
                        draggableArea;
                    this.notifyObserver("getDraggableAppointmentArea", {callback: function(result) {
                            if (result)
                                draggableArea = result
                        }});
                    this._createComponent($appointment, "dxDraggable", {
                        area: draggableArea,
                        boundOffset: that._calculateBoundOffset(),
                        onDragStart: function(args) {
                            var e = args.jQueryEvent;
                            that._skipDraggableRestriction(e);
                            that.notifyObserver("hideAppointmentTooltip");
                            that.notifyObserver("getDragEventTargetElements", {callback: function(result) {
                                    if (result)
                                        e.targetElements = result
                                }});
                            $fixedContainer.append($appointment);
                            that._$currentAppointment = $(args.element);
                            that._initialSize = {
                                width: args.width,
                                height: args.height
                            };
                            that._initialCoordinates = translator.locate(args.element)
                        },
                        onDrag: function(args) {
                            var coordinates = translator.locate(args.element);
                            that.notifyObserver("correctAppointmentCoordinates", {
                                coordinates: coordinates,
                                allDay: isAllDay,
                                callback: function(result) {
                                    if (result)
                                        coordinates = result
                                }
                            });
                            translator.move($appointment, coordinates)
                        },
                        onDragEnd: function(args) {
                            var $container = that._getAppointmentContainer(isAllDay);
                            $container.append($appointment);
                            if (this._escPressed) {
                                args.jQueryEvent.cancel = true;
                                return
                            }
                            that._dragEndHandler(args)
                        }
                    })
                },
                _calculateBoundOffset: function() {
                    var result = {top: 0};
                    this.notifyObserver("getBoundOffset", {callback: function(offset) {
                            result = offset
                        }});
                    return result
                },
                _skipDraggableRestriction: function(e) {
                    if (this.option("rtlEnabled"))
                        e.maxLeftOffset = null;
                    else
                        e.maxRightOffset = null;
                    e.maxBottomOffset = null
                },
                _dragEndHandler: function(e) {
                    var itemData = this._getItemData(e.element),
                        coordinates = this._initialCoordinates;
                    this._normalizeAppointmentDates(itemData);
                    this.notifyObserver("updateAppointmentAfterDrag", {
                        data: itemData,
                        $appointment: e.element,
                        coordinates: coordinates
                    })
                },
                _virtualAppointments: {},
                _processVirtualAppointment: function(appointmentSetting, $appointment, appointmentData, color) {
                    var virtualAppointment = appointmentSetting.virtual,
                        virtualGroupIndex = virtualAppointment.index;
                    if (!commonUtils.isDefined(this._virtualAppointments[virtualGroupIndex]))
                        this._virtualAppointments[virtualGroupIndex] = {
                            coordinates: {
                                top: virtualAppointment.top,
                                left: virtualAppointment.left
                            },
                            items: {
                                data: [],
                                colors: []
                            },
                            isAllDay: virtualAppointment.isAllDay,
                            buttonColor: color
                        };
                    this._virtualAppointments[virtualGroupIndex].items.data.push(appointmentData);
                    this._virtualAppointments[virtualGroupIndex].items.colors.push(color);
                    $appointment.remove()
                },
                _renderContentImpl: function() {
                    this.callBase();
                    this._renderDropDownAppointments()
                },
                _renderDropDownAppointments: function() {
                    var buttonWidth = this._renderingStrategy.getCompactAppointmentGroupMaxWidth(),
                        rtlOffset = 0,
                        that = this;
                    if (this.option("rtlEnabled"))
                        rtlOffset = buttonWidth;
                    $.each(this._virtualAppointments, $.proxy(function(groupIndex, appointment) {
                        var virtualGroup = this._virtualAppointments[groupIndex],
                            virtualItems = virtualGroup.items,
                            virtualCoordinates = virtualGroup.coordinates,
                            $container = virtualGroup.isAllDay ? this.option("allDayContainer") : this.element(),
                            left = virtualCoordinates.left;
                        this.notifyObserver("renderDropDownAppointments", {
                            $container: $container,
                            coordinates: {
                                top: virtualCoordinates.top,
                                left: left + rtlOffset
                            },
                            items: virtualItems,
                            buttonColor: virtualGroup.buttonColor,
                            itemTemplate: this.option("itemTemplate"),
                            buttonWidth: buttonWidth,
                            onAppointmentClick: function(args) {
                                var mappedAppointmentFields = that._mapAppointmentFields(args);
                                that._itemJQueryEventHandler(args.jQueryEvent, "onItemClick", mappedAppointmentFields)
                            }
                        })
                    }, this))
                },
                updateDraggablesBoundOffsets: function() {
                    if (this.option("allowDrag"))
                        this.element().find("." + APPOINTMENT_ITEM_CLASS).each($.proxy(function(_, appointmentElement) {
                            var $appointment = $(appointmentElement),
                                appointmentData = this._getItemData($appointment);
                            if (!this._renderingStrategy.isAllDay(appointmentData))
                                $appointment.dxDraggable("instance").option("boundOffset", this._calculateBoundOffset())
                        }, this))
                },
                moveAppointmentBack: function() {
                    var $appointment = this._$currentAppointment,
                        size = this._initialSize,
                        coords = this._initialCoordinates;
                    if ($appointment) {
                        if (coords) {
                            translator.move($appointment, coords);
                            delete this._initialSize
                        }
                        if (size) {
                            $appointment.outerWidth(size.width);
                            $appointment.outerHeight(size.height);
                            delete this._initialCoordinates
                        }
                    }
                },
                focus: function() {
                    var $appointment = this._$currentAppointment;
                    if ($appointment) {
                        this.option("focusedElement", $appointment);
                        this.option("focusedElement").focus()
                    }
                }
            }).include(publisherMixin);
        registerComponent("dxSchedulerAppointments", {}, SchedulerAppointments);
        return SchedulerAppointments
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler.appointments"]);
    /*! Module widgets-web, file ui.scheduler.appointments.dropDown.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.appointments.dropDown", ["jquery", "/class", "/utils/utils.translator", "/utils/utils.common", "/ui/widgets/ui.button"], function($, Class, translator, commonUtils, Button) {
        var DROPDOWN_APPOINTMENTS_CLASS = "dx-scheduler-dropdown-appointments",
            DROPDOWN_APPOINTMENTS_CONTENT_CLASS = "dx-scheduler-dropdown-appointments-content",
            DROPDOWN_APPOINTMENT_CLASS = "dx-scheduler-dropdown-appointment",
            DROPDOWN_APPOINTMENT_TITLE_CLASS = "dx-scheduler-dropdown-appointment-title",
            DROPDOWN_APPOINTMENT_DATE_CLASS = "dx-scheduler-dropdown-appointment-date",
            DROPDOWN_APPOINTMENT_REMOVE_BUTTON_CLASS = "dx-scheduler-dropdown-appointment-remove-button",
            DROPDOWN_APPOINTMENT_EDIT_BUTTON_CLASS = "dx-scheduler-dropdown-appointment-edit-button",
            DROPDOWN_APPOINTMENT_INFO_BLOCK_CLASS = "dx-scheduler-dropdown-appointment-info-block",
            DROPDOWN_APPOINTMENT_BUTTONS_BLOCK_CLASS = "dx-scheduler-dropdown-appointment-buttons-block";
        var dropDownAppointments = Class.inherit({
                render: function(options, instance) {
                    var coordinates = options.coordinates,
                        items = options.items;
                    this.instance = instance;
                    var $menu = $("<div>").addClass(DROPDOWN_APPOINTMENTS_CLASS).appendTo(options.$container);
                    this._createDropDownMenu({
                        $element: $menu,
                        items: items,
                        itemTemplate: options.itemTemplate,
                        buttonWidth: options.buttonWidth,
                        onAppointmentClick: options.onAppointmentClick
                    });
                    this._paintMenuButton($menu, options.buttonColor, items);
                    this._applyInnerShadow($menu, options.buttonWidth);
                    translator.move($menu, {
                        top: coordinates.top,
                        left: coordinates.left
                    });
                    return $menu
                },
                repaintExisting: function($container) {
                    var appointmentnsSelector = ["", DROPDOWN_APPOINTMENTS_CLASS, "dx-dropdownmenu"].join(".");
                    $container.find(appointmentnsSelector).each(function() {
                        $(this).dxDropDownMenu("instance").repaint()
                    })
                },
                _paintMenuButton: function($menu, color, menuItems) {
                    var paintButton = true,
                        itemsColors = menuItems.colors,
                        itemColorCount = itemsColors.length,
                        currentItemColor;
                    if (itemColorCount) {
                        currentItemColor = itemsColors[0];
                        for (var i = 1; i < itemColorCount; i++) {
                            if (currentItemColor !== itemsColors[i]) {
                                paintButton = false;
                                break
                            }
                            currentItemColor = itemsColors[i]
                        }
                    }
                    if (color && paintButton)
                        $menu.css("background-color", color)
                },
                _createButtonTemplate: function(appointmentCount) {
                    return $("<div />").html([$("<span />").text(appointmentCount), $("<span />").text("...")]).addClass(DROPDOWN_APPOINTMENTS_CONTENT_CLASS)
                },
                _applyInnerShadow: function($element) {
                    $element.css("box-shadow", "inset " + $element.outerWidth() + "px 0 0 0 rgba(0, 0, 0, 0.3)")
                },
                _createDropDownMenu: function(config) {
                    var $element = config.$element,
                        items = config.items,
                        onAppointmentClick = config.onAppointmentClick,
                        itemTemplate;
                    if (!$element.data("dxDropDownMenu")) {
                        itemTemplate = $.proxy(function(appointmentData, index, appointmentElement) {
                            this._createDropDownAppointmentTemplate(appointmentData, appointmentElement, items.colors[index])
                        }, this);
                        var instance = this.instance;
                        this.instance._createComponent($element, "dxDropDownMenu", {
                            buttonIcon: null,
                            usePopover: true,
                            popupHeight: 200,
                            items: items.data,
                            buttonTemplate: this._createButtonTemplate(items.data.length),
                            buttonWidth: config.buttonWidth,
                            onItemClick: function(args) {
                                args.component.open();
                                if ($.isFunction(onAppointmentClick))
                                    onAppointmentClick.call(instance._appointments, args)
                            },
                            activeStateEnabled: false,
                            focusStateEnabled: false,
                            itemTemplate: itemTemplate
                        })
                    }
                },
                _createDropDownAppointmentTemplate: function(appointmentData, appointmentElement, color) {
                    var dateString = "",
                        appointmentMarkup = [],
                        borderSide = "left",
                        $title,
                        $date,
                        $infoBlock,
                        text = this.instance.fire("getField", "text", appointmentData);
                    appointmentElement.addClass(DROPDOWN_APPOINTMENT_CLASS);
                    if (this.instance.option("rtlEnabled"))
                        borderSide = "right";
                    if (color)
                        appointmentElement.css("border-" + borderSide + "-color", color);
                    this.instance.fire("normalizeAppointmentDates", {
                        appointmentData: appointmentData,
                        callback: function(result) {
                            appointmentData = result
                        }
                    });
                    var startDate = this.instance.fire("getField", "startDate", appointmentData),
                        endDate = this.instance.fire("getField", "endDate", appointmentData);
                    this.instance.fire("formatDates", {
                        startDate: startDate,
                        endDate: endDate,
                        formatType: "DATETIME",
                        callback: function(result) {
                            dateString = result
                        }
                    });
                    $infoBlock = $("<div />").addClass(DROPDOWN_APPOINTMENT_INFO_BLOCK_CLASS);
                    $title = $("<div>").addClass(DROPDOWN_APPOINTMENT_TITLE_CLASS).text(text);
                    $date = $("<div>").addClass(DROPDOWN_APPOINTMENT_DATE_CLASS).text(dateString);
                    $infoBlock.append([$title, $date]);
                    appointmentMarkup.push($infoBlock);
                    appointmentMarkup.push(this._createButtons(appointmentData));
                    appointmentElement.append(appointmentMarkup)
                },
                _createButtons: function(appointmentData) {
                    var editing = this.instance.option("editing"),
                        allowDeleting = false,
                        allowUpdating = false;
                    if (!editing)
                        return "";
                    if (editing === true) {
                        allowDeleting = true;
                        allowUpdating = true
                    }
                    if (commonUtils.isObject(editing)) {
                        allowDeleting = editing.allowDeleting;
                        allowUpdating = editing.allowUpdating
                    }
                    var $container = $("<div />").addClass(DROPDOWN_APPOINTMENT_BUTTONS_BLOCK_CLASS),
                        $removeButton = $("<div>").addClass(DROPDOWN_APPOINTMENT_REMOVE_BUTTON_CLASS),
                        $editButton = $("<div>").addClass(DROPDOWN_APPOINTMENT_EDIT_BUTTON_CLASS);
                    if (allowDeleting) {
                        $container.append($removeButton);
                        this.instance._createComponent($removeButton, Button, {
                            icon: "trash",
                            height: 25,
                            width: 25,
                            onClick: $.proxy(function(e) {
                                e.jQueryEvent.stopPropagation();
                                this.instance.deleteAppointment(appointmentData)
                            }, this)
                        })
                    }
                    if (allowUpdating) {
                        $container.append($editButton);
                        this.instance._createComponent($editButton, Button, {
                            icon: "edit",
                            height: 25,
                            width: 25,
                            onClick: $.proxy(function(e) {
                                e.jQueryEvent.stopPropagation();
                                this.instance.fire("showEditAppointmentPopup", {data: appointmentData})
                            }, this)
                        })
                    }
                    return $container
                }
            });
        return dropDownAppointments
    });
    /*! Module widgets-web, file ui.scheduler.subscribes.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler.subscribes", ["jquery", "/utils/utils.array", "/utils/utils.recurrence", "/utils/utils.date", "/utils/utils.translator", "/utils/utils.common"], function($, array, recurrenceUtils, dateUtils, translator, commonUtils) {
        var subscribes = {
                currentViewUpdated: function(currentView) {
                    this.option("currentView", currentView)
                },
                currentDateUpdated: function(date) {
                    this.option("currentDate", date)
                },
                needCoordinates: function(options) {
                    var appointmentData = options.appointmentData,
                        startDate = options.startDate,
                        recurrenceRule = this.fire("getField", "recurrenceRule", appointmentData),
                        recurrenceException = this.fire("getField", "recurrenceException", appointmentData),
                        dateRange = this._workSpace.getDateRange(),
                        startViewDate = this.appointmentTakesAllDay(appointmentData) ? dateUtils.trimTime(new Date(dateRange[0])) : dateRange[0],
                        dates = recurrenceUtils.getDatesByRecurrence(recurrenceRule, startDate, startViewDate, dateRange[1], recurrenceException);
                    if (!dates.length)
                        dates.push(startDate);
                    var itemResources = this._resourcesManager.getResourcesFromItem(appointmentData),
                        allDay = this.appointmentTakesAllDay(appointmentData) && this._workSpace.supportAllDayRow();
                    options.callback(this._getCoordinates(dates, itemResources, allDay))
                },
                showAppointmentTooltip: function(options) {
                    var appointmentData = options.data,
                        $appointment = $(options.target),
                        singleAppointmentData = this._getSingleAppointmentData(appointmentData, options, $appointment);
                    this.showAppointmentTooltip(appointmentData, singleAppointmentData, options.target)
                },
                hideAppointmentTooltip: function() {
                    this._hideTooltip()
                },
                showAddAppointmentPopup: function(appointmentData) {
                    var processedData = {};
                    $.each(["startDate", "endDate", "allDay"], $.proxy(function(_, field) {
                        if (appointmentData[field] !== undefined) {
                            this.fire("setField", field, processedData, appointmentData[field]);
                            delete appointmentData[field]
                        }
                    }, this));
                    this.showAppointmentPopup($.extend(processedData, appointmentData), true)
                },
                showEditAppointmentPopup: function(options) {
                    var appointmentData = options.data,
                        $appointment = $(options.target),
                        singleAppointmentData = this._getSingleAppointmentData(appointmentData, options, $appointment),
                        startDate = this.fire("getField", "startDate", singleAppointmentData);
                    this.showAppointmentPopup(appointmentData, false, singleAppointmentData, startDate)
                },
                updateAppointmentAfterResize: function(options) {
                    var targetAppointment = options.target,
                        $appointment = options.$appointment,
                        singleAppointment = this._getSingleAppointmentData(targetAppointment, options, $appointment),
                        startDate = this.fire("getField", "startDate", singleAppointment);
                    this._checkRecurringAppointment(targetAppointment, singleAppointment, startDate, $.proxy(function() {
                        this._updateAppointment(targetAppointment, options.data, function() {
                            this._appointments.moveAppointmentBack()
                        })
                    }, this))
                },
                updateAppointmentAfterDrag: function(options) {
                    var target = options.data,
                        updatedData = this._getUpdatedData(options),
                        newCellIndex = this._workSpace.getDroppableCellIndex(),
                        oldCellIndex = this._workSpace.getCellIndexByCoordinates(options.coordinates),
                        becomeAllDay = this.fire("getField", "allDay", updatedData),
                        wasAllDay = this.fire("getField", "allDay", target);
                    var appointment = $.extend({}, target, updatedData);
                    var movedToAllDay = this._workSpace.supportAllDayRow() && becomeAllDay,
                        cellData = this._workSpace.getCellDataByCoordinates(options.coordinates, movedToAllDay),
                        movedBetweenAllDayAndSimple = this._workSpace.supportAllDayRow() && (wasAllDay && !becomeAllDay || !wasAllDay && becomeAllDay);
                    if (newCellIndex !== oldCellIndex || movedBetweenAllDayAndSimple)
                        this._checkRecurringAppointment(target, appointment, cellData.startDate, $.proxy(function() {
                            this._updateAppointment(target, appointment, function() {
                                this._appointments.moveAppointmentBack()
                            })
                        }, this));
                    else
                        this._appointments.moveAppointmentBack()
                },
                deleteAppointment: function(options) {
                    var appointmentData = options.data,
                        $appointment = $(options.target),
                        singleAppointmentData = this._getSingleAppointmentData(appointmentData, options, $appointment),
                        startDate = this.fire("getField", "startDate", singleAppointmentData);
                    this._checkRecurringAppointment(appointmentData, singleAppointmentData, startDate, $.proxy(function() {
                        this.deleteAppointment(appointmentData)
                    }, this), true)
                },
                getAppointmentColor: function(options) {
                    var resourceForPainting = this._resourcesManager.getResourceForPainting(this.option("groups")),
                        response = $.Deferred().resolve().promise();
                    if (resourceForPainting) {
                        var field = resourceForPainting.field,
                            groupIndex = options.groupIndex,
                            groups = this._workSpace._getCellGroups(groupIndex),
                            resourceValues = array.wrapToArray(options.itemData[field]),
                            groupId = resourceValues.length ? resourceValues[0] : undefined;
                        for (var i = 0; i < groups.length; i++)
                            if (groups[i].name === field)
                                groupId = groups[i].id;
                        response = this._resourcesManager.getResourceColor(field, groupId)
                    }
                    options.callback(response)
                },
                getResourcesFromItem: function(options) {
                    options.callback(this._resourcesManager.getResourcesFromItem(options.itemData))
                },
                getCellDimensions: function(options) {
                    if (this._workSpace)
                        options.callback(this._workSpace.getCellWidth(), this._workSpace.getCellHeight(), this._workSpace.getAllDayHeight())
                },
                getBoundOffset: function(options) {
                    options.callback({top: -this.getWorkSpaceAllDayHeight()})
                },
                appointmentTakesAllDay: function(options) {
                    var appointment = {};
                    this.fire("setField", "startDate", appointment, options.startDate);
                    this.fire("setField", "endDate", appointment, options.endDate);
                    options.callback(this.appointmentTakesAllDay(appointment))
                },
                checkContainerVisibility: function(options) {
                    options.callback(this.element().is(":hidden"))
                },
                appointmentFocused: function() {
                    this._workSpace.restoreScrollTop()
                },
                getResizableAppointmentArea: function(options) {
                    var area,
                        allDay = options.allDay;
                    if (this.option("groups") && this.option("groups").length && (allDay || this.option("currentView") === "month")) {
                        var groupBounds = this._workSpace.getGroupBounds(options.coordinates);
                        area = {
                            left: groupBounds.left,
                            right: groupBounds.right,
                            top: 0,
                            bottom: 0
                        }
                    }
                    options.callback(area)
                },
                getDraggableAppointmentArea: function(options) {
                    options.callback(this.getWorkSpaceScrollableContainer())
                },
                getDragEventTargetElements: function(options) {
                    options.callback(this.element)
                },
                correctAppointmentCoordinates: function(options) {
                    var updatedCoordinates,
                        isAllDay = options.allDay;
                    var scrollTop = !isAllDay ? this.getWorkSpaceScrollableScrollTop() : 0,
                        headerHeight = this.getWorkSpaceHeaderPanelHeight(),
                        scrollLeft = this.getWorkSpaceScrollableScrollLeft(),
                        tableHorizontalOffset = this.getWorkSpaceDateTableOffset(),
                        allDayPanelVerticalOffset = !isAllDay ? this.getWorkSpaceAllDayHeight() : 0;
                    updatedCoordinates = {
                        top: options.coordinates.top - scrollTop + allDayPanelVerticalOffset + headerHeight,
                        left: options.coordinates.left - scrollLeft - tableHorizontalOffset
                    };
                    options.callback(updatedCoordinates)
                },
                allDayPanelToggled: function() {
                    this._appointments.updateDraggablesBoundOffsets()
                },
                normalizeAppointmentDates: function(options) {
                    var appointmentData = options.appointmentData,
                        startDate = dateUtils.makeDate(this.fire("getField", "startDate", appointmentData)),
                        endDate = dateUtils.makeDate(this.fire("getField", "endDate", appointmentData));
                    this.fire("setField", "startDate", appointmentData, startDate);
                    this.fire("setField", "endDate", appointmentData, endDate);
                    options.callback(appointmentData)
                },
                formatDates: function(options) {
                    var startDate = options.startDate,
                        endDate = options.endDate,
                        formatType = options.formatType;
                    var formatTypes = {
                            DATETIME: function() {
                                var dateTimeFormat = "MMMM d h:mm tt",
                                    startDateString = Globalize.format(startDate, dateTimeFormat) + " - ";
                                var endDateString = startDate.getDate() === endDate.getDate() ? Globalize.format(endDate, "t") : Globalize.format(endDate, dateTimeFormat);
                                return startDateString + endDateString
                            },
                            TIME: function() {
                                return Globalize.format(startDate, "t") + " - " + Globalize.format(endDate, "t")
                            },
                            DATE: function() {
                                var dateTimeFormat = "d MMMM",
                                    startDateString = Globalize.format(startDate, dateTimeFormat),
                                    isDurationMoreThanDay = endDate.getTime() - startDate.getTime() > 24 * 3600000;
                                var endDateString = isDurationMoreThanDay || endDate.getDate() !== startDate.getDate() ? " - " + Globalize.format(endDate, dateTimeFormat) : "";
                                return startDateString + endDateString
                            }
                        };
                    options.callback(formatTypes[formatType]())
                },
                getFullWeekAppointmentWidth: function(options) {
                    var groupIndex = options.groupIndex,
                        groupWidth = this._workSpace.getGroupWidth(groupIndex);
                    options.callback(groupWidth)
                },
                getMaxAppointmentWidth: function(options) {
                    var cellCountToLastViewDate = this._workSpace.getCellCountToLastViewDate(options.date);
                    options.callback(cellCountToLastViewDate * this._workSpace.getCellWidth())
                },
                updateAppointmentStartDate: function(options) {
                    var appointment = options.appointment,
                        firstViewDate = this._workSpace.getFirstViewDate(),
                        startDate = new Date(options.startDate),
                        updatedStartDate;
                    if (this.appointmentTakesAllDay(appointment))
                        updatedStartDate = dateUtils.normalizeDate(startDate, firstViewDate);
                    else {
                        startDate.setHours(this.option("startDayHour"));
                        startDate.setMinutes(0);
                        updatedStartDate = dateUtils.normalizeDate(options.startDate, new Date(startDate))
                    }
                    options.callback(updatedStartDate)
                },
                updateAppointmentEndDate: function(options) {
                    var endDate = new Date(options.endDate),
                        updatedEndDate = endDate;
                    if (endDate.getHours() >= this.option("endDayHour")) {
                        updatedEndDate.setHours(this.option("endDayHour"));
                        updatedEndDate.setMinutes(0)
                    }
                    options.callback(updatedEndDate)
                },
                renderDropDownAppointments: function(options) {
                    this._dropDownAppointments.render(options, this)
                },
                getGroupCount: function(options) {
                    var groupCount = this._workSpace._getGroupCount();
                    options.callback(groupCount)
                },
                updateResizableArea: function() {
                    var $allResizableElements = this.element().find(".dx-scheduler-appointment.dx-resizable");
                    var horizontalResizables = $.grep($allResizableElements, function(el) {
                            var $el = $(el),
                                resizableInst = $el.dxResizable("instance"),
                                area = resizableInst.option("area");
                            return $.inArray(resizableInst.option("handles"), ["right left", "left right"]) > -1 && $.isPlainObject(area)
                        });
                    $.each(horizontalResizables, $.proxy(function(_, el) {
                        var $el = $(el),
                            position = translator.locate($el),
                            appointmentData = this._appointments._getItemData($el);
                        var area = this._appointments._calculateResizableArea({left: position.left}, appointmentData);
                        $el.dxResizable("instance").option("area", area)
                    }, this))
                },
                recurrenceEditorVisibylityChanged: function(options) {
                    this.recurrenceEditorVisibylityChanged(options.visible)
                },
                getField: function(field, obj) {
                    if (!commonUtils.isDefined(this._dataAccessors.getter[field]))
                        return;
                    return this._dataAccessors.getter[field](obj)
                },
                setField: function(field, obj, value) {
                    if (!commonUtils.isDefined(this._dataAccessors.setter[field]))
                        return;
                    return this._dataAccessors.setter[field](obj, value)
                },
                prerenderFilter: function() {
                    var dateRange = this.getWorkSpace().getDateRange(),
                        allDay;
                    if (!this.option("showAllDayPanel") && this._workSpace.supportAllDayRow())
                        allDay = false;
                    return this._appointmentModel.filterLoadedAppointments({
                            startDayHour: this.option("startDayHour"),
                            endDayHour: this.option("endDayHour"),
                            min: dateRange[0],
                            max: dateRange[1],
                            resources: this._loadedResources,
                            allDay: allDay
                        })
                }
            };
        return subscribes
    });
    /*! Module widgets-web, file ui.scheduler.js */
    DevExpress.define("/ui/widgets/scheduler/ui.scheduler", ["jquery", "/ui/uiNamespace", "/utils/utils.translator", "/ui/ui.errors", "/ui/ui.dialog", "/utils/utils.recurrence", "/utils/utils.dom", "/utils/utils.date", "/utils/utils.common", "/devices", "/componentRegistrator", "/ui/ui.widget", "/ui/widgets/scheduler/ui.scheduler.subscribes", "/ui/templates/ui.template.function", "/ui/templates/ui.template.dynamic", "/ui/templates/ui.template.move", "/ui/widgets/scheduler/ui.scheduler.appointmentTooltip", "/ui/widgets/scheduler/ui.scheduler.recurrenceEditor", "/ui/widgets/scheduler/ui.scheduler.header", "/ui/widgets/scheduler/ui.scheduler.workSpaceDay", "/ui/widgets/scheduler/ui.scheduler.workSpaceWeek", "/ui/widgets/scheduler/ui.scheduler.workSpaceWorkWeek", "/ui/widgets/scheduler/ui.scheduler.workSpaceMonth", "/ui/widgets/scheduler/ui.scheduler.timelineDay", "/ui/widgets/scheduler/ui.scheduler.timelineWeek", "/ui/widgets/scheduler/ui.scheduler.timelineWorkWeek", "/ui/widgets/scheduler/ui.scheduler.resourceManager", "/ui/widgets/scheduler/ui.scheduler.appointmentModel", "/ui/widgets/scheduler/ui.scheduler.appointments", "/ui/widgets/scheduler/ui.scheduler.appointments.dropDown", "/ui/ui.dataHelper", "/ui/ui.loading"], function($, ui, translator, errors, dialog, recurrenceUtils, domUtils, dateUtils, commonUtils, devices, registerComponent, Widget, subscribes, FunctionTemplate, DynamicTemplate, MoveTemplate, appointmentTooltip, SchedulerRecurrenceEditor, SchedulerHeader, SchedulerWorkSpaceDay, SchedulerWorkSpaceWeek, SchedulerWorkSpaceWorkWeek, SchedulerWorkSpaceMonth, SchedulerTimelineDay, SchedulerTimelineWeek, SchedulerTimelineWorkWeek, SchedulerResourceManager, SchedulerAppointmentModel, SchedulerAppointments, DropDownAppointments, DataHelperMixin, loading) {
        var WIDGET_CLASS = "dx-scheduler",
            WIDGET_READONLY_CLASS = "dx-scheduler-readonly",
            APPOINTMENT_POPUP_CLASS = "dx-scheduler-appointment-popup",
            RECURRENCE_EDITOR_ITEM_CLASS = "dx-scheduler-recurrence-rule-item",
            RECURRENCE_EDITOR_OPENED_ITEM_CLASS = "dx-scheduler-recurrence-rule-item-opened",
            APPOINTEMENT_POPUP_WIDTH = 610;
        var VIEWS_CONFIG = {
                day: {
                    workSpace: SchedulerWorkSpaceDay,
                    renderingStrategy: "vertical"
                },
                week: {
                    workSpace: SchedulerWorkSpaceWeek,
                    renderingStrategy: "vertical"
                },
                workWeek: {
                    workSpace: SchedulerWorkSpaceWorkWeek,
                    renderingStrategy: "vertical"
                },
                month: {
                    workSpace: SchedulerWorkSpaceMonth,
                    renderingStrategy: "horizontalMonth"
                },
                timelineDay: {
                    workSpace: SchedulerTimelineDay,
                    renderingStrategy: "horizontal"
                },
                timelineWeek: {
                    workSpace: SchedulerTimelineWeek,
                    renderingStrategy: "horizontal"
                },
                timelineWorkWeek: {
                    workSpace: SchedulerTimelineWorkWeek,
                    renderingStrategy: "horizontal"
                }
            };
        var Scheduler = Widget.inherit({
                _getDefaultOptions: function() {
                    return $.extend(this.callBase(), {
                            views: ["day", "week"],
                            currentView: "day",
                            currentDate: dateUtils.trimTime(new Date),
                            min: undefined,
                            max: undefined,
                            firstDayOfWeek: undefined,
                            groups: [],
                            resources: [],
                            dataSource: null,
                            appointmentTemplate: "item",
                            startDayHour: 0,
                            endDayHour: 24,
                            editing: {
                                allowAdding: true,
                                allowDeleting: true,
                                allowDragging: true,
                                allowResizing: true,
                                allowUpdating: true
                            },
                            showAllDayPanel: true,
                            recurrenceEditMode: "dialog",
                            cellDuration: 30,
                            onAppointmentRendered: null,
                            onAppointmentClick: null,
                            onAppointmentDblClick: null,
                            onCellClick: null,
                            onAppointmentAdding: null,
                            onAppointmentAdded: null,
                            onAppointmentUpdating: null,
                            onAppointmentUpdated: null,
                            onAppointmentDeleting: null,
                            onAppointmentDeleted: null,
                            onAppointmentFormCreated: null,
                            appointmentTooltipTemplate: "appointmentTooltip",
                            appointmentPopupTemplate: "appointmentPopup",
                            horizontalScrollingEnabled: false,
                            useDropDownViewSwitcher: false,
                            startDateExpr: "startDate",
                            endDateExpr: "endDate",
                            textExpr: "text",
                            descriptionExpr: "description",
                            allDayExpr: "allDay",
                            recurrenceRuleExpr: "recurrenceRule",
                            recurrenceExceptionExpr: "recurrenceException",
                            remoteFiltering: false
                        })
                },
                _defaultOptionsRules: function() {
                    return this.callBase().concat([{
                                device: function(device) {
                                    return devices.real().generic && !devices.isSimulator()
                                },
                                options: {focusStateEnabled: true}
                            }, {
                                device: function(device) {
                                    return !devices.current().generic
                                },
                                options: {
                                    useDropDownViewSwitcher: true,
                                    editing: {
                                        allowDragging: false,
                                        allowResizing: false
                                    }
                                }
                            }])
                },
                _optionChanged: function(args) {
                    var value = args.value,
                        name = args.name;
                    switch (args.name) {
                        case"firstDayOfWeek":
                            this._workSpace.option(name, value);
                            this._header.option(name, value);
                            break;
                        case"currentDate":
                            value = dateUtils.trimTime(dateUtils.makeDate(value));
                            this._workSpace.option(name, value);
                            this._header.option(name, value);
                            this._appointments.option("items", []);
                            this._filterAppointmentsByDate();
                            this._reloadDataSource();
                            break;
                        case"dataSource":
                            this._initDataSource();
                            this._customizeStoreLoadOptions();
                            this._appointmentModel.setDataSource(this._dataSource);
                            this._loadResources().done($.proxy(function(resources) {
                                this._filterAppointmentsByDate();
                                this._workSpace.option("showAllDayPanel", this.option("showAllDayPanel"));
                                this._reloadDataSource()
                            }, this));
                            break;
                        case"min":
                        case"max":
                            this._header.option(name, dateUtils.makeDate(value));
                            this._workSpace.option(name, dateUtils.makeDate(value));
                            break;
                        case"views":
                        case"useDropDownViewSwitcher":
                            this._header.option(name, value);
                            break;
                        case"currentView":
                            this._appointments.option("items", []);
                            this._header.option(name, value);
                            this._loadResources().done($.proxy(function(resources) {
                                this._refreshWorkSpace(resources);
                                this._filterAppointmentsByDate();
                                this._appointments.option("renderingStrategy", this._getAppointmentsRenderingStrategy());
                                this._appointments.option("allowAllDayResize", value !== "day");
                                this._reloadDataSource()
                            }, this));
                            break;
                        case"appointmentTemplate":
                            this._appointments.option("itemTemplate", value);
                            break;
                        case"groups":
                            this._loadResources().done($.proxy(function(resources) {
                                this._workSpace.option(name, resources);
                                this._filterAppointmentsByDate();
                                this._reloadDataSource()
                            }, this));
                            break;
                        case"resources":
                            this._resourcesManager.setResources(value);
                            this._loadResources().done($.proxy(function(resources) {
                                this._workSpace.option("groups", resources);
                                this._filterAppointmentsByDate();
                                this._reloadDataSource()
                            }, this));
                            break;
                        case"startDayHour":
                        case"endDayHour":
                            this._appointments.option("items", []);
                            this._workSpace.option(name, value);
                            this._appointments.option("dayDuration", this._getDayDuration());
                            this._filterAppointmentsByDate();
                            this._reloadDataSource();
                            break;
                        case"onAppointmentAdding":
                        case"onAppointmentAdded":
                        case"onAppointmentUpdating":
                        case"onAppointmentUpdated":
                        case"onAppointmentDeleting":
                        case"onAppointmentDeleted":
                        case"onAppointmentFormCreated":
                            this._actions[name] = this._createActionByOption(name);
                            break;
                        case"onAppointmentRendered":
                            this._appointments.option("onItemRendered", this._getAppointmentRenderedAction());
                            break;
                        case"onAppointmentClick":
                            this._appointments.option("onItemClick", this._createActionByOption(name));
                            break;
                        case"onAppointmentDblClick":
                            this._appointments.option(name, this._createActionByOption(name));
                            break;
                        case"accessKey":
                        case"onCellClick":
                            this._workSpace.option(name, value);
                            break;
                        case"horizontalScrollingEnabled":
                            this._loadResources().done($.proxy(function(resources) {
                                this._refreshWorkSpace(resources);
                                this._appointments.repaint()
                            }, this));
                            break;
                        case"cellDuration":
                            this._workSpace.option("hoursInterval", value / 60);
                            this._appointments.option("appointmentDurationInMinutes", value);
                            break;
                        case"tabIndex":
                        case"focusStateEnabled":
                            this._header.option(name, value);
                            this._workSpace.option(name, value);
                            this._appointments.option(name, value);
                            this.callBase(args);
                            break;
                        case"width":
                            this._header.option(name, value);
                            if (this.option("horizontalScrollingEnabled"))
                                this._workSpace.option("width", value);
                            this.callBase(args);
                            this._dimensionChanged();
                            break;
                        case"height":
                            this.callBase(args);
                            this._dimensionChanged();
                            break;
                        case"editing":
                            this._initEditing();
                            var editing = this._editing;
                            this._bringEditingModeToAppointments(editing);
                            if (this._appointmentForm)
                                this._appointmentForm.option("readOnly", !this._editing.allowUpdating);
                            this._hideTooltip();
                            break;
                        case"showAllDayPanel":
                            this._loadResources().done($.proxy(function(resources) {
                                this._filterAppointmentsByDate();
                                this._workSpace.option("allDayExpanded", value);
                                this._workSpace.option(name, value);
                                this._reloadDataSource()
                            }, this));
                            break;
                        case"appointmentTooltipTemplate":
                        case"appointmentPopupTemplate":
                        case"recurrenceEditMode":
                        case"remoteFiltering":
                            break;
                        case"startDateExpr":
                        case"endDateExpr":
                        case"textExpr":
                        case"descriptionExpr":
                        case"allDayExpr":
                        case"recurrenceRuleExpr":
                        case"recurrenceExceptionExpr":
                            this._updateExpression(name, value);
                            if (this._useDynamicTemplate())
                                this._appointments.repaint();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _bringEditingModeToAppointments: function(editing) {
                    this._appointments.option({
                        allowDrag: editing.allowDragging,
                        allowResize: editing.allowResizing,
                        allowDelete: editing.allowUpdating && editing.allowDeleting,
                        allowAllDayResize: editing.allowResizing && this.option("currentView") !== "day"
                    });
                    this._dropDownAppointments.repaintExisting(this.element())
                },
                _isAllDayExpanded: function(items) {
                    return this.option("showAllDayPanel") && this._appointmentModel.hasAllDayAppointments(items, this.option("startDayHour"), this.option("endDayHour"))
                },
                _filterAppointmentsByDate: function() {
                    var dateRange = this._workSpace.getDateRange();
                    this._appointmentModel.filterByDate(dateRange[0], dateRange[1])
                },
                _loadResources: function() {
                    var groups = this.option("groups"),
                        result = $.Deferred();
                    this._resourcesManager.getResourcesValueByFields(groups).done($.proxy(function(resources) {
                        result.resolve(resources);
                        this._loadedResources = resources
                    }, this));
                    return result.promise()
                },
                _reloadDataSource: function() {
                    if (this._dataSource) {
                        loading.show({
                            container: this.element(),
                            position: {of: this.element()}
                        });
                        this._dataSource.load().done(function() {
                            loading.hide()
                        }).fail(function() {
                            loading.hide()
                        })
                    }
                },
                _dimensionChanged: function() {
                    this._appointments && this._appointments.repaint();
                    this._hideTooltip()
                },
                _visibilityChanged: function(visible) {
                    visible && this._dimensionChanged()
                },
                _dataSourceOptions: function() {
                    return {paginate: false}
                },
                _init: function() {
                    this.callBase();
                    this._initExpressions({
                        startDate: this.option("startDateExpr"),
                        endDate: this.option("endDateExpr"),
                        allDay: this.option("allDayExpr"),
                        text: this.option("textExpr"),
                        description: this.option("descriptionExpr"),
                        recurrenceRule: this.option("recurrenceRuleExpr"),
                        recurrenceException: this.option("recurrenceExceptionExpr")
                    });
                    this._initDataSource();
                    this._loadedResources = [];
                    this._proxiedCustomizeStoreLoadOptionsHandler = $.proxy(this._customizeStoreLoadOptionsHandler, this);
                    this._customizeStoreLoadOptions();
                    this.element().addClass(WIDGET_CLASS);
                    this._initEditing();
                    this._appointmentModel = new SchedulerAppointmentModel(this._dataSource, {
                        startDateExpr: this.option("startDateExpr"),
                        endDateExpr: this.option("endDateExpr"),
                        allDayExpr: this.option("allDayExpr"),
                        recurrenceRuleExpr: this.option("recurrenceRuleExpr"),
                        recurrenceExceptionExpr: this.option("recurrenceExceptionExpr")
                    }, this._dataAccessors);
                    this._resourcesManager = new SchedulerResourceManager(this.option("resources"));
                    this._initActions();
                    this._dropDownAppointments = new DropDownAppointments;
                    this._subscribes = subscribes
                },
                _dataSourceChangedHandler: function() {
                    var filteredItems = this.fire("prerenderFilter");
                    this._workSpace.option("allDayExpanded", this._isAllDayExpanded(filteredItems));
                    this._appointments.option("renderingStrategy", this._getAppointmentsRenderingStrategy());
                    this._setAppointmentsData(filteredItems)
                },
                _initExpressions: function(fields) {
                    var dataUtils = DevExpress.data.utils;
                    if (!this._dataAccessors)
                        this._dataAccessors = {
                            getter: {},
                            setter: {}
                        };
                    $.each(fields, $.proxy(function(name, value) {
                        if (!!value) {
                            this._dataAccessors.getter[name] = dataUtils.compileGetter(value);
                            this._dataAccessors.setter[name] = dataUtils.compileSetter(value)
                        }
                        else {
                            delete this._dataAccessors.getter[name];
                            delete this._dataAccessors.setter[name]
                        }
                    }, this))
                },
                _updateExpression: function(name, value) {
                    var exprObj = {};
                    exprObj[name.replace("Expr", "")] = value;
                    this._initExpressions(exprObj)
                },
                _initEditing: function() {
                    var editing = this.option("editing");
                    this._editing = {
                        allowAdding: !!editing,
                        allowUpdating: !!editing,
                        allowDeleting: !!editing,
                        allowResizing: !!editing,
                        allowDragging: !!editing
                    };
                    if (commonUtils.isObject(editing))
                        this._editing = $.extend(this._editing, editing);
                    this._editing.allowDragging = this._editing.allowDragging && this._editing.allowUpdating;
                    this._editing.allowResizing = this._editing.allowResizing && this._editing.allowUpdating;
                    this.element().toggleClass(WIDGET_READONLY_CLASS, this._isReadOnly())
                },
                _isReadOnly: function() {
                    var result = true,
                        editing = this._editing;
                    for (var prop in editing)
                        if (editing.hasOwnProperty(prop))
                            result = result && !editing[prop];
                    return result
                },
                _customizeStoreLoadOptions: function() {
                    this._dataSource && this._dataSource.on("customizeStoreLoadOptions", this._proxiedCustomizeStoreLoadOptionsHandler)
                },
                _dispose: function() {
                    this._dataSource && this._dataSource.off("customizeStoreLoadOptions", this._proxiedCustomizeStoreLoadOptionsHandler);
                    this.callBase()
                },
                _customizeStoreLoadOptionsHandler: function(options) {
                    if (!this.option("remoteFiltering"))
                        options.storeLoadOptions.filter[0] = [this._appointmentModel.customizeDateFilter(options.storeLoadOptions.filter[0])];
                    options.storeLoadOptions.dxScheduler = {
                        startDate: this._workSpace.getFirstViewDate(),
                        endDate: this._workSpace.getLastViewDate(),
                        resources: this.option("resources")
                    }
                },
                _initActions: function() {
                    this._actions = {
                        onAppointmentAdding: this._createActionByOption("onAppointmentAdding"),
                        onAppointmentAdded: this._createActionByOption("onAppointmentAdded"),
                        onAppointmentUpdating: this._createActionByOption("onAppointmentUpdating"),
                        onAppointmentUpdated: this._createActionByOption("onAppointmentUpdated"),
                        onAppointmentDeleting: this._createActionByOption("onAppointmentDeleting"),
                        onAppointmentDeleted: this._createActionByOption("onAppointmentDeleted"),
                        onAppointmentFormCreated: this._createActionByOption("onAppointmentFormCreated")
                    }
                },
                _getAppointmentRenderedAction: function() {
                    return this._createActionByOption("onAppointmentRendered", {excludeValidators: ["designMode", "disabled", "readOnly"]})
                },
                _defaultAppointmentFormEditors: function(allDay) {
                    var that = this;
                    return [{
                                dataField: that.option("textExpr"),
                                editorType: "dxTextBox",
                                label: {text: Globalize.localize("dxScheduler-editorLabelTitle")}
                            }, {
                                dataField: that.option("allDayExpr"),
                                editorType: "dxSwitch",
                                label: {text: Globalize.localize("dxScheduler-allDay")},
                                editorOptions: {onValueChanged: function(args) {
                                        var value = args.value,
                                            startDateEditor = that._appointmentForm.getEditor(that.option("startDateExpr")),
                                            endDateEditor = that._appointmentForm.getEditor(that.option("endDateExpr")),
                                            startDate;
                                        if (startDateEditor && endDateEditor) {
                                            startDateEditor.option("format", value ? "date" : "datetime");
                                            endDateEditor.option("format", value ? "date" : "datetime");
                                            startDate = new Date(startDateEditor.option("value"));
                                            if (value) {
                                                startDateEditor.option("value", that._getAllDayStartDate(startDate));
                                                endDateEditor.option("value", that._getAllDayEndDate(startDate))
                                            }
                                            else if (startDateEditor.option("value")) {
                                                startDate.setHours(that.option("startDayHour"));
                                                startDateEditor.option("value", startDate);
                                                endDateEditor.option("value", that._workSpace.calculateEndDate(startDateEditor.option("value")))
                                            }
                                        }
                                    }}
                            }, {
                                dataField: that.option("startDateExpr"),
                                editorType: "dxDateBox",
                                label: {text: Globalize.localize("dxScheduler-editorLabelStartDate")},
                                editorOptions: {
                                    format: allDay ? "date" : "datetime",
                                    onValueChanged: function(args) {
                                        var value = args.value,
                                            previousValue = args.previousValue,
                                            endDateEditor = that._appointmentForm.getEditor(that.option("endDateExpr")),
                                            endValue = endDateEditor.option("value");
                                        that._validateAppointmentFormDate(args.component, value, previousValue);
                                        if (endValue <= value) {
                                            var duration = endValue.getTime() - previousValue.getTime();
                                            endDateEditor.option("value", new Date(value.getTime() + duration))
                                        }
                                    }
                                }
                            }, {
                                dataField: that.option("endDateExpr"),
                                editorType: "dxDateBox",
                                label: {text: Globalize.localize("dxScheduler-editorLabelEndDate")},
                                editorOptions: {
                                    format: allDay ? "date" : "datetime",
                                    onValueChanged: function(args) {
                                        var value = args.value,
                                            previousValue = args.previousValue,
                                            startDateEditor = that._appointmentForm.getEditor(that.option("startDateExpr")),
                                            startValue = startDateEditor.option("value");
                                        that._validateAppointmentFormDate(args.component, value, previousValue);
                                        if (value && startValue >= value) {
                                            var duration = previousValue.getTime() - startValue.getTime();
                                            startDateEditor.option("value", new Date(value.getTime() - duration))
                                        }
                                    }
                                }
                            }, {
                                dataField: that.option("descriptionExpr"),
                                editorType: "dxTextArea",
                                label: {text: Globalize.localize("dxScheduler-editorLabelDescription")}
                            }, {
                                dataField: that.option("recurrenceRuleExpr"),
                                editorType: "dxSchedulerRecurrenceEditor",
                                editorOptions: {
                                    observer: that,
                                    onContentReady: function(args) {
                                        var $editorField = args.element.closest(".dx-field-item"),
                                            $editorLabel = $editorField.find(".dx-field-item-label");
                                        $editorLabel.off("dxclick").on("dxclick", function() {
                                            args.component.toggle()
                                        })
                                    }
                                },
                                cssClass: RECURRENCE_EDITOR_ITEM_CLASS,
                                label: {text: Globalize.localize("dxScheduler-editorLabelRecurrence")}
                            }]
                },
                _getAllDayStartDate: function(startDate) {
                    startDate.setHours(0);
                    startDate.setMinutes(0);
                    return startDate
                },
                _getAllDayEndDate: function(startDate) {
                    var endDate = new Date(startDate);
                    endDate.setDate(startDate.getDate() + 1);
                    return endDate
                },
                _validateAppointmentFormDate: function(editor, value, previousValue) {
                    var isCorrectDate = !!value;
                    if (!isCorrectDate)
                        editor.option("value", previousValue)
                },
                _renderFocusTarget: $.noop,
                _render: function() {
                    this.callBase();
                    this._renderHeader();
                    this._appointments = this._createComponent("<div>", SchedulerAppointments, this._appointmentsConfig());
                    this._loadResources().done($.proxy(function(resources) {
                        this._renderWorkSpace(resources);
                        var $fixedContainer = this._workSpace.getFixedContainer(),
                            $allDayContainer = this._workSpace.getAllDayContainer();
                        this._appointments.option({
                            fixedContainer: $fixedContainer,
                            allDayContainer: $allDayContainer
                        });
                        this._filterAppointmentsByDate();
                        this._reloadDataSource()
                    }, this))
                },
                _setAppointmentsData: function(items) {
                    if (items)
                        this._appointments.option("items", items)
                },
                _renderHeader: function() {
                    this._header = this._createComponent("<div>", SchedulerHeader, this._headerConfig());
                    this.element().append(this._header.element())
                },
                _headerConfig: function() {
                    return {
                            observer: this,
                            min: dateUtils.makeDate(this.option("min")),
                            max: dateUtils.makeDate(this.option("max")),
                            views: this.option("views"),
                            firstDayOfWeek: this.option("firstDayOfWeek"),
                            currentView: this.option("currentView"),
                            currentDate: dateUtils.trimTime(dateUtils.makeDate(this.option("currentDate"))),
                            tabIndex: this.option("tabIndex"),
                            focusStateEnabled: this.option("focusStateEnabled"),
                            width: this.option("width"),
                            rtlEnabled: this.option("rtlEnabled"),
                            useDropDownViewSwitcher: this.option("useDropDownViewSwitcher")
                        }
                },
                _useDynamicTemplate: function() {
                    var hash = {
                            startDateExpr: "startDate",
                            endDateExpr: "endDate",
                            textExpr: "text"
                        };
                    var result = false;
                    $.each(hash, $.proxy(function(name, value) {
                        if (this.option(name) !== value) {
                            result = true;
                            return false
                        }
                    }, this));
                    return result
                },
                _appointmentsConfig: function() {
                    var editing = this._editing,
                        that = this;
                    var config = {
                            observer: this,
                            renderingStrategy: this._getAppointmentsRenderingStrategy(),
                            onItemRendered: this._getAppointmentRenderedAction(),
                            onItemClick: this._createActionByOption("onAppointmentClick"),
                            onAppointmentDblClick: this._createActionByOption("onAppointmentDblClick"),
                            tabIndex: this.option("tabIndex"),
                            focusStateEnabled: this.option("focusStateEnabled"),
                            appointmentDurationInMinutes: this.option("cellDuration"),
                            allowDrag: editing.allowDragging,
                            allowDelete: editing.allowUpdating && editing.allowDeleting,
                            allowResize: editing.allowResizing,
                            allowAllDayResize: editing.allowResizing && this.option("currentView") !== "day",
                            rtlEnabled: this.option("rtlEnabled"),
                            onContentReady: function() {
                                that._workSpace && that._workSpace.option("allDayExpanded", that._isAllDayExpanded(that._appointments.option("items")))
                            },
                            dayDuration: this._getDayDuration()
                        };
                    if (!this._useDynamicTemplate() || this.option("appointmentTemplate") !== "item")
                        config.itemTemplate = this._getTemplateByOption("appointmentTemplate");
                    return config
                },
                _getAppointmentsRenderingStrategy: function() {
                    return VIEWS_CONFIG[this.option("currentView")].renderingStrategy
                },
                _getDayDuration: function() {
                    return this.option("endDayHour") - this.option("startDayHour")
                },
                _renderWorkSpace: function(groups) {
                    this._workSpace = this._createComponent("<div>", VIEWS_CONFIG[this.option("currentView")].workSpace, this._workSpaceConfig(groups));
                    this._workSpace.getWorkArea().append(this._appointments.element());
                    this.element().append(this._workSpace.element());
                    domUtils.triggerShownEvent(this._workSpace.element())
                },
                _workSpaceConfig: function(groups) {
                    return {
                            observer: this,
                            min: dateUtils.makeDate(this.option("min")),
                            max: dateUtils.makeDate(this.option("max")),
                            currentDate: dateUtils.trimTime(dateUtils.makeDate(this.option("currentDate"))),
                            firstDayOfWeek: this.option("firstDayOfWeek"),
                            groups: groups,
                            startDayHour: this.option("startDayHour"),
                            endDayHour: this.option("endDayHour"),
                            tabIndex: this.option("tabIndex"),
                            accessKey: this.option("accessKey"),
                            focusStateEnabled: this.option("focusStateEnabled"),
                            hoursInterval: this.option("cellDuration") / 60,
                            showAllDayPanel: this.option("showAllDayPanel"),
                            allDayExpanded: this._isAllDayExpanded(this._appointments.option("items")),
                            onCellClick: this._createActionByOption("onCellClick"),
                            horizontalScrollingEnabled: this.option("horizontalScrollingEnabled")
                        }
                },
                _refreshWorkSpace: function(groups) {
                    this._appointments.element().detach();
                    this._workSpace._dispose();
                    this._workSpace.element().remove();
                    delete this._workSpace;
                    this._renderWorkSpace(groups);
                    this._appointments.option({
                        fixedContainer: this._workSpace.getFixedContainer(),
                        allDayContainer: this._workSpace.getAllDayContainer()
                    })
                },
                getWorkSpaceScrollable: function() {
                    return this._workSpace.getScrollable()
                },
                getWorkSpaceScrollableScrollTop: function() {
                    return this._workSpace.getScrollableScrollTop()
                },
                getWorkSpaceScrollableScrollLeft: function() {
                    return this._workSpace.getScrollableScrollLeft()
                },
                getWorkSpaceScrollableContainer: function() {
                    return this._workSpace.getScrollableContainer()
                },
                getWorkSpaceAllDayHeight: function() {
                    return this._workSpace.getAllDayHeight()
                },
                getWorkSpaceHeaderPanelHeight: function() {
                    return this._workSpace.getHeaderPanelHeight()
                },
                getWorkSpaceDateTableOffset: function() {
                    return !this.option("horizontalScrollingEnabled") || this.option("rtlEnabled") ? this._workSpace.getTimePanelWidth() : 0
                },
                getWorkSpace: function() {
                    return this._workSpace
                },
                getHeader: function() {
                    return this._header
                },
                _createPopup: function(appointmentData) {
                    if (this._$popup)
                        this._popup.element().remove();
                    this._$popup = $("<div>").addClass(APPOINTMENT_POPUP_CLASS).appendTo(this.element());
                    this._initDynamicPopupTemplate(appointmentData);
                    this._popup = this._createComponent(this._$popup, "dxPopup", this._popupConfig(appointmentData))
                },
                _popupContent: function(appointmentData) {
                    var $popupContent = this._popup.content();
                    this._createAppointmentForm(appointmentData, $popupContent);
                    return $popupContent
                },
                _createAppointmentForm: function(appointmentData, $content) {
                    var allDay = this.fire("getField", "allDay", appointmentData),
                        editors = this._defaultAppointmentFormEditors(allDay),
                        resources = this.option("resources");
                    if (!this.option("recurrenceRuleExpr"))
                        editors.splice(5, 1);
                    if (resources && resources.length) {
                        this._resourcesManager.setResources(this.option("resources"));
                        editors = editors.concat(this._resourcesManager.getEditors())
                    }
                    $.each(this._resourcesManager.getResourcesFromItem(appointmentData, true) || {}, function(resourceName, resourceValue) {
                        appointmentData[resourceName] = resourceValue
                    });
                    this._appointmentForm = this._createComponent($content, "dxForm", {
                        items: editors,
                        readOnly: this._editAppointmentData ? !this._editing.allowUpdating : false,
                        showValidationSummary: true,
                        scrollingEnabled: true,
                        formData: $.extend(true, {}, appointmentData)
                    });
                    var recurrentEditor = this._appointmentForm.getEditor(this.option("recurrenceRuleExpr"));
                    if (recurrentEditor) {
                        var startDate = this.fire("getField", "startDate", appointmentData);
                        recurrentEditor.option("startDate", dateUtils.makeDate(startDate))
                    }
                    this._actions["onAppointmentFormCreated"]({
                        form: this._appointmentForm,
                        appointmentData: appointmentData
                    })
                },
                _initDynamicPopupTemplate: function(appointmentData) {
                    var that = this;
                    this._dynamicTemplates["appointmentPopup"] = new FunctionTemplate(function(data, index, $container) {
                        var $popupContent = that._popupContent(appointmentData);
                        $container.append($popupContent);
                        return $container
                    })
                },
                _popupConfig: function(appointmentData) {
                    var template = this._getTemplateByOption("appointmentPopupTemplate");
                    return {
                            _templates: this.option("_templates"),
                            templateProvider: this.option("templateProvider"),
                            width: APPOINTEMENT_POPUP_WIDTH,
                            onHiding: $.proxy(function() {
                                this.focus()
                            }, this),
                            contentTemplate: new DynamicTemplate(function(container) {
                                return new MoveTemplate(template.render(appointmentData, container))
                            }),
                            defaultOptionsRules: [{
                                    device: function(device) {
                                        return !devices.current().generic
                                    },
                                    options: {fullScreen: true}
                                }]
                        }
                },
                _getPopupButtons: function() {
                    return [{
                                shortcut: "done",
                                location: "after",
                                onClick: $.proxy(this._doneButtonClickHandler, this)
                            }, {
                                shortcut: "cancel",
                                location: "after"
                            }]
                },
                _doneButtonClickHandler: function(args) {
                    var validation = this._appointmentForm.validate();
                    args.cancel = true;
                    if (validation && !validation.isValid)
                        return;
                    this._saveChanges(args);
                    var startDate = this.fire("getField", "startDate", this._appointmentForm.option("formData"));
                    this._workSpace.updateScrollPosition(startDate)
                },
                _saveChanges: function() {
                    var formData = this._appointmentForm.option("formData"),
                        oldData = this._editAppointmentData,
                        recData = this._updatedRecAppointment;
                    if (oldData && !recData)
                        this.updateAppointment(oldData, formData);
                    else {
                        recData && this.updateAppointment(oldData, recData);
                        delete this._updatedRecAppointment;
                        this.addAppointment(formData)
                    }
                },
                _checkRecurringAppointment: function(targetAppointment, singleAppointment, exceptionDate, callback, isDeleted, isPopupEditing) {
                    delete this._updatedRecAppointment;
                    var recurrenceRule = this.fire("getField", "recurrenceRule", targetAppointment);
                    if (!recurrenceUtils.getRecurrenceRule(recurrenceRule).isValid || !this._editing.allowUpdating) {
                        callback();
                        return
                    }
                    var editMode = this.option("recurrenceEditMode");
                    switch (editMode) {
                        case"series":
                            callback();
                            break;
                        case"occurrence":
                            this._singleAppointmentChangesHandler(targetAppointment, singleAppointment, exceptionDate, isDeleted, isPopupEditing);
                            break;
                        default:
                            this._showRecurrenceChangeConfirm(isDeleted).done($.proxy(function(result) {
                                result && callback();
                                !result && this._singleAppointmentChangesHandler(targetAppointment, singleAppointment, exceptionDate, isDeleted, isPopupEditing)
                            }, this)).fail($.proxy(function() {
                                this._appointments.moveAppointmentBack()
                            }, this))
                    }
                },
                _singleAppointmentChangesHandler: function(targetAppointment, singleAppointment, exceptionDate, isDeleted, isPopupEditing) {
                    this.fire("setField", "recurrenceRule", singleAppointment, "");
                    this.fire("setField", "recurrenceException", singleAppointment, "");
                    if (!isDeleted && !isPopupEditing)
                        this.addAppointment(singleAppointment);
                    var recurrenceException = this._getRecurrenceException(exceptionDate, targetAppointment),
                        updatedAppointment = $.extend({}, targetAppointment, {recurrenceException: recurrenceException});
                    if (isPopupEditing) {
                        this._updatedRecAppointment = updatedAppointment;
                        this._showAppointmentPopup(singleAppointment, true);
                        this._editAppointmentData = targetAppointment
                    }
                    else
                        this._updateAppointment(targetAppointment, updatedAppointment)
                },
                _getRecurrenceException: function(exceptionDate, targetAppointment) {
                    var startDate = this.fire("getField", "startDate", targetAppointment),
                        exceptionByDate = this._getRecurrenceExceptionDate(exceptionDate, startDate),
                        recurrenceException = this.fire("getField", "recurrenceException", targetAppointment);
                    return recurrenceException ? recurrenceException + "," + exceptionByDate : exceptionByDate
                },
                _getRecurrenceExceptionDate: function(exceptionDate, targetStartDate) {
                    exceptionDate.setHours(targetStartDate.getHours());
                    exceptionDate.setMinutes(targetStartDate.getMinutes());
                    exceptionDate.setSeconds(targetStartDate.getSeconds());
                    return Globalize.format(exceptionDate, "yyyyMMddTHHmmss")
                },
                _showRecurrenceChangeConfirm: function(isDeleted) {
                    var message = Globalize.localize(isDeleted ? "dxScheduler-confirmRecurrenceDeleteMessage" : "dxScheduler-confirmRecurrenceEditMessage"),
                        seriesText = Globalize.localize(isDeleted ? "dxScheduler-confirmRecurrenceDeleteSeries" : "dxScheduler-confirmRecurrenceEditSeries"),
                        occurrenceText = Globalize.localize(isDeleted ? "dxScheduler-confirmRecurrenceDeleteOccurrence" : "dxScheduler-confirmRecurrenceEditOccurrence");
                    return dialog.custom({
                            message: message,
                            showCloseButton: true,
                            showTitle: true,
                            buttons: [{
                                    text: seriesText,
                                    onClick: function() {
                                        return true
                                    }
                                }, {
                                    text: occurrenceText,
                                    onClick: function() {
                                        return false
                                    }
                                }]
                        }).show()
                },
                _getUpdatedData: function(options) {
                    var target = options.data || options,
                        cellData = this.getTargetCellData(),
                        targetAllDay = this.fire("getField", "allDay", target),
                        targetStartDate = dateUtils.makeDate(this.fire("getField", "startDate", target)),
                        targetEndDate = dateUtils.makeDate(this.fire("getField", "endDate", target)),
                        allDay = cellData.allDay,
                        date = cellData.date || targetStartDate,
                        groups = cellData.groups,
                        duration = targetEndDate.getTime() - targetStartDate.getTime();
                    var updatedData = {};
                    this.fire("setField", "allDay", updatedData, allDay);
                    this.fire("setField", "startDate", updatedData, date);
                    var endDate = new Date(date.getTime() + duration);
                    if (this.appointmentTakesAllDay(target) && !updatedData.allDay && this._workSpace.supportAllDayRow())
                        endDate = this._workSpace.calculateEndDate(date);
                    if (targetAllDay && !this._workSpace.supportAllDayRow()) {
                        var dateCopy = new Date(date);
                        dateCopy.setHours(0);
                        endDate = new Date(dateCopy.getTime() + duration);
                        if (endDate.getHours() !== 0)
                            endDate.setHours(this.option("endDayHour"))
                    }
                    this.fire("setField", "endDate", updatedData, endDate);
                    for (var name in groups)
                        if (groups.hasOwnProperty(name))
                            updatedData[name] = groups[name];
                    return updatedData
                },
                _getCoordinates: function(dates, resources, allDay) {
                    var result = [];
                    for (var i = 0; i < dates.length; i++)
                        result = result.concat(this._workSpace.getCoordinatesByDateInGroup(dates[i], resources, allDay));
                    return result
                },
                _getSingleAppointmentData: function(appointmentData, options, $appointment) {
                    var target = appointmentData,
                        updatedData = this._getUpdatedData(options),
                        appointment = $.extend({}, target, updatedData),
                        allDay = this.fire("getField", "allDay", target),
                        allowAllDay = this._workSpace.supportAllDayRow() && allDay,
                        startDate = this.fire("getField", "startDate", appointment),
                        endDate = this.fire("getField", "endDate", appointment),
                        appointmentDuration = endDate.getTime() - startDate.getTime(),
                        updatedStartDate;
                    if (commonUtils.isDefined($appointment)) {
                        var coordinates = translator.locate($appointment),
                            cellData = this._workSpace.getCellDataByCoordinates(coordinates, allowAllDay);
                        updatedStartDate = cellData.startDate
                    }
                    else
                        updatedStartDate = appointmentData.startDate;
                    this.fire("setField", "startDate", appointment, updatedStartDate);
                    this.fire("setField", "endDate", appointment, new Date(updatedStartDate.getTime() + appointmentDuration));
                    return appointment
                },
                subscribe: function(subject, action) {
                    this._subscribes[subject] = subscribes[subject] = action
                },
                fire: function(subject) {
                    var callback = this._subscribes[subject],
                        args = Array.prototype.slice.call(arguments);
                    if (!$.isFunction(callback))
                        throw errors.Error("E1031", subject);
                    return callback.apply(this, args.slice(1))
                },
                getTargetCellData: function() {
                    return this._workSpace.getDataByDroppableCell()
                },
                showAppointmentTooltip: function(appointmentData, singleAppointmentData, $appointment) {
                    appointmentTooltip.show(appointmentData, singleAppointmentData, $appointment, this)
                },
                _hideTooltip: function() {
                    appointmentTooltip.hide()
                },
                _updateAppointment: function(target, appointment, onUpdatePrevented) {
                    var updatingOptions = {
                            newData: appointment,
                            oldData: target,
                            cancel: false
                        };
                    this._actions["onAppointmentUpdating"](updatingOptions);
                    this._processActionResult(updatingOptions, function(canceled) {
                        if (!canceled) {
                            this._expandAllDayPanel(appointment);
                            this._appointmentModel.update(target, appointment).always($.proxy(function(e) {
                                this._executeActionWhenOperationIsCompleted(this._actions["onAppointmentUpdated"], appointment, e)
                            }, this))
                        }
                        else if ($.isFunction(onUpdatePrevented))
                            onUpdatePrevented.call(this)
                    })
                },
                _processActionResult: function(actionOptions, callback) {
                    $.when(actionOptions.cancel).then($.proxy(callback, this))
                },
                _expandAllDayPanel: function(appointment) {
                    if (!this._isAllDayExpanded(this._appointments.option("items")) && this.appointmentTakesAllDay(appointment))
                        this._workSpace.option("allDayExpanded", true)
                },
                _executeActionWhenOperationIsCompleted: function(action, appointment, e) {
                    var options = {appointmentData: appointment},
                        isError = e && e.name === "Error";
                    if (isError)
                        options.error = e;
                    else if (this._popup && this._popup.option("visible"))
                        this._popup.hide();
                    action(options)
                },
                _showAppointmentPopup: function(appointmentData, showButtons) {
                    this._createPopup(appointmentData);
                    var buttons = [],
                        showCloseButton = true;
                    if (!commonUtils.isDefined(showButtons) || showButtons) {
                        buttons = this._getPopupButtons();
                        showCloseButton = this._popup.initialOption("showCloseButton")
                    }
                    this._popup.option({
                        buttons: buttons,
                        showCloseButton: showCloseButton
                    });
                    this._popup.show()
                },
                getAppointmentPopup: function() {
                    return this._popup
                },
                getAppointmentDetailsForm: function() {
                    return this._appointmentForm
                },
                getAppointmentsInstance: function() {
                    return this._appointments
                },
                getAppointmentResourceData: function(field, value) {
                    return this._resourcesManager.getResourceDataByValue(field, value)
                },
                getActions: function() {
                    return this._actions
                },
                appointmentTakesAllDay: function(appointment) {
                    return this._appointmentModel.appointmentTakesAllDay(appointment, this.option("startDayHour"), this.option("endDayHour"))
                },
                recurrenceEditorVisibylityChanged: function(visible) {
                    if (this._appointmentForm)
                        this._appointmentForm.element().find("." + RECURRENCE_EDITOR_ITEM_CLASS).toggleClass(RECURRENCE_EDITOR_OPENED_ITEM_CLASS, visible)
                },
                showAppointmentPopup: function(appointmentData, createNewAppointment, currentAppointmentData) {
                    var singleAppointment = !currentAppointmentData && appointmentData.length ? this._getSingleAppointmentData(appointmentData, appointmentData) : currentAppointmentData;
                    var startDate;
                    if (currentAppointmentData)
                        startDate = this.fire("getField", "startDate", currentAppointmentData);
                    else
                        startDate = this.fire("getField", "startDate", appointmentData);
                    this._checkRecurringAppointment(appointmentData, singleAppointment, startDate, $.proxy(function() {
                        var editing = this._editing;
                        if (createNewAppointment) {
                            delete this._editAppointmentData;
                            editing.allowAdding && this._showAppointmentPopup(appointmentData)
                        }
                        else {
                            this._editAppointmentData = appointmentData;
                            this._showAppointmentPopup(appointmentData, editing.allowUpdating)
                        }
                    }, this), false, true)
                },
                scrollToTime: function(hours, minutes, date) {
                    this._workSpace.scrollToTime(hours, minutes, date)
                },
                addAppointment: function(appointment) {
                    var text = this.fire("getField", "text", appointment);
                    if (!text)
                        this.fire("setField", "text", appointment, "");
                    var addingOptions = {
                            appointmentData: appointment,
                            cancel: false
                        };
                    this._actions["onAppointmentAdding"](addingOptions);
                    this._processActionResult(addingOptions, function(canceled) {
                        if (!canceled) {
                            this._expandAllDayPanel(appointment);
                            this._appointmentModel.add(appointment).always($.proxy(function(e) {
                                this._executeActionWhenOperationIsCompleted(this._actions["onAppointmentAdded"], appointment, e)
                            }, this))
                        }
                    })
                },
                updateAppointment: function(target, appointment) {
                    this._updateAppointment(target, appointment)
                },
                deleteAppointment: function(appointment) {
                    var deletingOptions = {
                            appointmentData: appointment,
                            cancel: false
                        };
                    this._actions["onAppointmentDeleting"](deletingOptions);
                    this._processActionResult(deletingOptions, function(canceled) {
                        if (!canceled)
                            this._appointmentModel.remove(appointment).always($.proxy(function(e) {
                                this._executeActionWhenOperationIsCompleted(this._actions["onAppointmentDeleted"], appointment, e)
                            }, this))
                    })
                },
                focus: function() {
                    if (this._editAppointmentData)
                        this._appointments.focus();
                    else
                        this._workSpace.focus()
                }
            }).include(DataHelperMixin);
        registerComponent("dxScheduler", ui, Scheduler);
        return Scheduler
    });
    DevExpress.require(["/ui/widgets/scheduler/ui.scheduler"]);
    /*! Module widgets-web, file clientExporter.js */
    (function(DX, $) {
        var Component = DX.require("/component"),
            commonUtils = DX.require("/utils/utils.common");
        DX.dxClientExporter = Component.inherit({
            _getDocumentCreator: function(exportableComponent, options) {
                if (options.format === "EXCEL")
                    return new DX.dxClientExporter.ExcelCreator(exportableComponent.getDataProvider(), $.extend({rtlEnabled: exportableComponent.option("rtlEnabled")}, options))
            },
            exportTo: function(options) {
                var that = this,
                    eventArgs,
                    exportingAction = this.option("exportingAction"),
                    exportedAction = this.option("exportedAction"),
                    fileSavingAction = this.option("fileSavingAction"),
                    documentCreator,
                    exportableComponent = options.component;
                if (exportableComponent) {
                    eventArgs = {
                        fileName: options.fileName,
                        format: options.format,
                        cancel: false
                    };
                    commonUtils.isDefined(exportingAction) && exportingAction(eventArgs);
                    if (!eventArgs.cancel) {
                        documentCreator = that._getDocumentCreator(exportableComponent, options);
                        documentCreator.ready().done(function() {
                            var fileData = documentCreator.getData(commonUtils.isFunction(window.Blob)),
                                saveFile = function(data) {
                                    commonUtils.isDefined(exportedAction) && exportedAction();
                                    if (commonUtils.isDefined(fileSavingAction)) {
                                        eventArgs.data = data;
                                        fileSavingAction(eventArgs)
                                    }
                                    if (!eventArgs.cancel)
                                        DX.dxClientExporter.fileSaver.saveAs(eventArgs.fileName, options.format, data, options.proxyUrl)
                                };
                            fileData && fileData.then ? fileData.then(saveFile) : saveFile(fileData)
                        })
                    }
                }
            }
        })
    })(DevExpress, jQuery);
    /*! Module widgets-web, file excelCreator.js */
    (function($, DX) {
        var stringUtils = DX.require("/utils/utils.string"),
            commonUtils = DX.require("/utils/utils.common"),
            defaultDateTimeFormat = DX.require("/utils/utils.formatHelper").defaultDateTimeFormat,
            Class = DX.require("/class"),
            exporter = DX.dxClientExporter,
            XML_TAG = "<?xml version=\"1.0\" encoding=\"utf-8\"?>",
            GROUP_SHEET_PR_XML = "<sheetPr><outlinePr summaryBelow=\"0\"/></sheetPr>",
            SINGLE_SHEET_PR_XML = "<sheetPr/>",
            BASE_STYLE_XML = "<fonts count=\"2\"><font><sz val=\"11\"/><color theme=\"1\"/><name val=\"Calibri\"/><family val=\"2\"/><scheme val=\"minor\"/></font><font><b/><sz val=\"11\"/><color theme=\"1\"/><name val=\"Calibri\"/><family val=\"2\"/><scheme val=\"minor\"/></font></fonts><fills count=\"1\"><fill><patternFill patternType=\"none\"/></fill></fills><borders count=\"1\"><border><left style=\"thin\"><color rgb=\"FFD3D3D3\"/></left><right style=\"thin\"><color rgb=\"FFD3D3D3\"/></right><top style=\"thin\"><color rgb=\"FFD3D3D3\"/></top><bottom style=\"thin\"><color rgb=\"FFD3D3D3\"/></bottom></border></borders><cellStyleXfs count=\"1\"><xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\"/></cellStyleXfs>",
            OPEN_XML_FORMAT_URL = "http://schemas.openxmlformats.org",
            RELATIONSHIP_PART_NAME = "rels",
            XL_FOLDER_NAME = "xl",
            WORKBOOK_FILE_NAME = "workbook.xml",
            CONTENTTYPES_FILE_NAME = "[Content_Types].xml",
            SHAREDSTRING_FILE_NAME = "sharedStrings.xml",
            STYLE_FILE_NAME = "styles.xml",
            WORKSHEETS_FOLDER = "worksheets",
            WORKSHEET_FILE_NAME = "sheet1.xml",
            UNSUPPORTED_DEFINED_DATE_FORMATS = ["quarter", "quarterAndYear", "millisecond"],
            DEFAULT_DATE_FORMAT = "shortDate",
            DEFINED_NUMBER_FORMTATS = {
                thousands: "#,##0{0},&quot;K&quot;",
                millions: "#,##0{0},,&quot;M&quot;",
                billions: "#,##0{0},,,&quot;B&quot;",
                trillions: "#,##0{0},,,,&quot;T&quot;",
                percent: "0{0}%",
                decimal: "#{0}",
                fixedPoint: "#,##0{0}",
                exponential: "0{0}E+00",
                currency: " "
            },
            EXCEL_START_TIME = Date.UTC(1899, 11, 30),
            DAYS_COUNT_BEFORE_29_FEB_1900 = 60,
            BOLD_STYLES_COUNT = 4,
            MAX_DIGIT_WIDTH_IN_PIXELS = 7,
            CUSTOM_FORMAT_START_INDEX = 165;
        exporter.excelFormatConverter = {
            _applyPrecision: function(format, precision) {
                var result,
                    i;
                if (precision > 0) {
                    result = format !== "decimal" ? "." : "";
                    for (i = 0; i < precision; i++)
                        result = result + "0";
                    return result
                }
                return ""
            },
            _getCurrencyFormat: function() {
                var currency = Globalize.cultures[Globalize.cultureSelector].numberFormat.currency,
                    i,
                    result,
                    symbol,
                    encodeSymbols;
                if (commonUtils.isArray(currency.pattern)) {
                    encodeSymbols = {
                        n: "#,##0{0}",
                        "'": "\\'",
                        "\\(": "\\(",
                        "\\)": "\\)",
                        " ": "\\ ",
                        "\"": "&quot;",
                        "\\$": currency.symbol
                    };
                    result = currency.pattern.slice();
                    for (symbol in encodeSymbols)
                        if (encodeSymbols.hasOwnProperty(symbol))
                            for (i = 0; i < result.length; i++)
                                result[i] = result[i].replace(new RegExp(symbol, "g"), encodeSymbols[symbol]);
                    return result.length === 2 ? result[1] + "_);" + result[0] : result[0]
                }
            },
            _convertDateFormat: function(format) {
                if (!defaultDateTimeFormat[format.toLowerCase()] || $.inArray(format, UNSUPPORTED_DEFINED_DATE_FORMATS) !== -1)
                    format = DEFAULT_DATE_FORMAT;
                var datePatterns = Globalize.cultures[Globalize.cultureSelector].calendar.patterns,
                    pattern = defaultDateTimeFormat[format.toLowerCase()];
                if (commonUtils.isDefined(datePatterns[pattern]))
                    pattern = datePatterns[pattern];
                return pattern.replace(/\//g, "\\/").replace(/ /g, "\\ ").replace(/,/g, "\\,").replace(/:/g, "\\:").replace(/tt/g, "AM/PM").replace(/N/g, "#\\,###")
            },
            _convertNumberFormat: function(format, precision) {
                var result,
                    excelFormat = format === "currency" ? this._getCurrencyFormat() : DEFINED_NUMBER_FORMTATS[format];
                if (excelFormat)
                    result = stringUtils.format(excelFormat, this._applyPrecision(format, precision));
                return result
            },
            convertFormat: function(format, precision, type) {
                if (commonUtils.isDefined(format))
                    if (type === "date")
                        return exporter.excelFormatConverter._convertDateFormat(format);
                    else if (DEFINED_NUMBER_FORMTATS[format])
                        return exporter.excelFormatConverter._convertNumberFormat(format, precision)
            }
        };
        exporter.ExcelCreator = Class.inherit({
            _getXMLTag: function(tagName, attributes, content) {
                var result = "<" + tagName,
                    i,
                    length = attributes.length,
                    attr;
                for (i = 0; i < length; i++) {
                    attr = attributes[i];
                    result = result + " " + attr.name + "=\"" + attr.value + "\""
                }
                return commonUtils.isDefined(content) ? result + ">" + content + "</" + tagName + ">" : result + " />"
            },
            _getDataProviderRowIndex: function(dpRowIndex) {
                return dpRowIndex - !!this._dataProvider.isHeadersVisible()
            },
            _getExcelRowIndex: function(exRowIndex) {
                return exRowIndex + !!this._dataProvider.isHeadersVisible()
            },
            _getCellIndex: function(rowIndex, cellIndex) {
                var sheetIndex = '',
                    max = 26,
                    charCode;
                if (this._maxIndex[0] < Number(rowIndex))
                    this._maxIndex[0] = Number(rowIndex);
                if (this._maxIndex[1] < Number(cellIndex))
                    this._maxIndex[1] = Number(cellIndex);
                while (true) {
                    charCode = 65 + (cellIndex >= max ? cellIndex % max : Math.ceil(cellIndex));
                    sheetIndex = String.fromCharCode(charCode) + sheetIndex;
                    if (cellIndex >= max)
                        cellIndex = Math.floor(cellIndex / max) - 1;
                    else
                        break
                }
                return sheetIndex + rowIndex
            },
            _getDataType: function(dataType) {
                var validTypes = {
                        boolean: "b",
                        date: "d",
                        number: "n",
                        string: "s"
                    };
                return commonUtils.isDefined(validTypes[dataType]) ? validTypes[dataType] : "s"
            },
            _appendFormat: function(format, precision, dataType) {
                format = exporter.excelFormatConverter.convertFormat(format, precision, dataType);
                if (format) {
                    if ($.inArray(format, this._styleFormat) === -1)
                        this._styleFormat.push(format);
                    return $.inArray(format, this._styleFormat) + 1
                }
            },
            _appendString: function(value) {
                if (commonUtils.isDefined(value)) {
                    value = String(value);
                    if (value.length) {
                        value = stringUtils.encodeHtml(value);
                        if (this._stringHash[value] === undefined) {
                            this._stringHash[value] = this._stringArray.length;
                            this._stringArray.push(value)
                        }
                        return this._stringHash[value]
                    }
                }
            },
            _getExcelDateValue: function(date) {
                var days,
                    totalTime;
                if (commonUtils.isDate(date)) {
                    days = Math.floor((Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - EXCEL_START_TIME) / (1000 * 60 * 60 * 24));
                    if (days < DAYS_COUNT_BEFORE_29_FEB_1900)
                        days--;
                    totalTime = (date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds()) / (24 * 3600);
                    return days + totalTime
                }
            },
            _prepareValue: function(rowIndex, cellIndex) {
                var value = this._dataProvider.getCellValue(rowIndex, cellIndex),
                    text = this._dataProvider.getCellText && this._dataProvider.getCellText(rowIndex, cellIndex),
                    type = this._getDataType(this._dataProvider.getCellType(rowIndex, cellIndex)) || "string",
                    formatID = this._styleArray[cellIndex + BOLD_STYLES_COUNT].formatID,
                    format = commonUtils.isNumber(formatID) ? this._styleFormat[formatID - 1] : null;
                if (!commonUtils.isDefined(value) && commonUtils.isDefined(text)) {
                    value = text;
                    type = "s";
                    format = null
                }
                if (type === "d" && !commonUtils.isDate(value))
                    type = "s";
                switch (type) {
                    case"s":
                        value = this._appendString(value);
                        break;
                    case"d":
                        value = this._getExcelDateValue(value, format);
                        type = "n";
                        break
                }
                return {
                        value: value,
                        type: type
                    }
            },
            _getHeadersArray: function() {
                var i,
                    columns = this._dataProvider.getColumns(),
                    result = [];
                for (i = 0; i !== columns.length; i++)
                    result.push({
                        style: 0,
                        type: "s",
                        value: this._appendString(columns[i].caption)
                    });
                return result
            },
            _getDataArray: function() {
                var rowIndex,
                    cellIndex,
                    cellsArray,
                    cellData,
                    result = [],
                    rowsLength = this._dataProvider.getRowsCount(),
                    cellsLength,
                    type,
                    styleID,
                    columns = this._dataProvider.getColumns();
                for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
                    cellsArray = [];
                    cellsLength = columns.length;
                    for (cellIndex = 0; cellIndex !== cellsLength; cellIndex++) {
                        cellData = this._prepareValue(rowIndex, cellIndex);
                        type = cellData.type;
                        if (!this._dataProvider.isGroupRow(rowIndex) && commonUtils.isDefined(this._styleArray[cellIndex + BOLD_STYLES_COUNT].formatID) && cellData.type !== "s")
                            type = "n";
                        styleID = cellIndex + BOLD_STYLES_COUNT;
                        if (this._dataProvider.isGroupRow(rowIndex))
                            styleID = BOLD_STYLES_COUNT - 1;
                        if (this._dataProvider.isTotalCell(rowIndex, cellIndex))
                            styleID = this._getBoldStyleID(columns[cellIndex].alignment);
                        cellsArray.push({
                            style: styleID,
                            value: cellData.value,
                            type: type
                        })
                    }
                    if (rowIndex && !this._needSheetPr && this._dataProvider.getGroupLevel(this._getDataProviderRowIndex(rowIndex)) > 0)
                        this._needSheetPr = true;
                    result.push(cellsArray)
                }
                return result
            },
            _getBoldStyleID: function(alignment) {
                for (var i = 0; i < BOLD_STYLES_COUNT - 1; i++)
                    if (this._styleArray[i].alignment === alignment)
                        return i
            },
            _culculateWidth: function(pixelsWidth) {
                pixelsWidth = parseInt(pixelsWidth, 10);
                if (!pixelsWidth || pixelsWidth < 5)
                    pixelsWidth = 100;
                return Math.min(255, Math.floor((pixelsWidth - 5) / MAX_DIGIT_WIDTH_IN_PIXELS * 100 + 0.5) / 100)
            },
            _prepareStyleData: function() {
                var i,
                    column,
                    wrapText = Number(!!this._options.wrapTextEnabled),
                    alignments = ["center", "left", "right"],
                    columns = this._dataProvider.getColumns();
                for (i = 0; i < alignments.length; i++)
                    this._styleArray.push({
                        bold: true,
                        alignment: alignments[i],
                        wrapText: 1
                    });
                this._styleArray.push({
                    bold: true,
                    alignment: commonUtils.getDefaultAlignment(this._rtlEnabled),
                    wrapText: 0
                });
                for (i = 0; i < columns.length; i++) {
                    column = columns[i];
                    this._styleArray.push({
                        alignment: commonUtils.isDefined(column.alignment) ? column.alignment : "left",
                        formatID: this._appendFormat(column.format, column.precision, column.dataType),
                        wrapText: wrapText
                    });
                    this._colsArray.push(this._culculateWidth(column.width))
                }
            },
            _prepareCellData: function() {
                if (this._dataProvider.isHeadersVisible())
                    this._cellsArray.push(this._getHeadersArray());
                this._cellsArray = this._cellsArray.concat(this._getDataArray())
            },
            _createXMLRelationships: function(xmlRelationships) {
                return this._getXMLTag("Relationships", [{
                            name: "xmlns",
                            value: OPEN_XML_FORMAT_URL + "/package/2006/relationships"
                        }], xmlRelationships)
            },
            _createXMLRelationship: function(id, type, target) {
                return this._getXMLTag("Relationship", [{
                            name: "Id",
                            value: "rId" + id
                        }, {
                            name: "Type",
                            value: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships/" + type
                        }, {
                            name: "Target",
                            value: target
                        }])
            },
            _getWorkbookContent: function() {
                var content = "<bookViews><workbookView xWindow=\"0\" yWindow=\"0\" windowWidth=\"0\" windowHeight=\"0\"/></bookViews><sheets><sheet name=\"Sheet\" sheetId=\"1\" r:id=\"rId1\" /></sheets><definedNames><definedName name=\"_xlnm.Print_Titles\" localSheetId=\"0\">Sheet!$1:$1</definedName><definedName name=\"_xlnm._FilterDatabase\" hidden=\"0\" localSheetId=\"0\">Sheet!$A$1:$F$6332</definedName></definedNames>";
                return XML_TAG + this._getXMLTag("workbook", [{
                            name: "xmlns:r",
                            value: OPEN_XML_FORMAT_URL + "/officeDocument/2006/relationships"
                        }, {
                            name: "xmlns",
                            value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
                        }], content)
            },
            _getContentTypesContent: function() {
                return XML_TAG + "<Types xmlns=\"" + OPEN_XML_FORMAT_URL + "/package/2006/content-types\"><Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\" /><Default Extension=\"xml\" ContentType=\"application/xml\" /><Override PartName=\"/xl/worksheets/sheet1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\" /><Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\" /><Override PartName=\"/xl/sharedStrings.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\" /><Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\" /></Types>"
            },
            _generateStylesXML: function() {
                var xlFolder = this._zip.folder(XL_FOLDER_NAME),
                    styleIndex,
                    stylesLength = this._styleArray.length,
                    style,
                    xmlStyles = [],
                    formatIndex,
                    XML = "";
                for (formatIndex = 0; formatIndex < this._styleFormat.length; formatIndex++)
                    this._styleFormat[formatIndex] = this._getXMLTag("numFmt", [{
                            name: "numFmtId",
                            value: Number(formatIndex) + CUSTOM_FORMAT_START_INDEX
                        }, {
                            name: "formatCode",
                            value: this._styleFormat[formatIndex]
                        }]);
                XML = XML + this._getXMLTag("numFmts", [{
                        name: "count",
                        value: this._styleFormat.length
                    }], this._styleFormat.join("")) + BASE_STYLE_XML;
                for (styleIndex = 0; styleIndex < stylesLength; styleIndex++) {
                    style = this._styleArray[styleIndex];
                    xmlStyles.push(this._getXMLTag("xf", [{
                            name: "xfId",
                            value: 0
                        }, {
                            name: "applyAlignment",
                            value: 1
                        }, {
                            name: "fontId",
                            value: Number(!!style.bold)
                        }, {
                            name: "applyNumberFormat",
                            value: commonUtils.isDefined(style.formatID) ? 1 : 0
                        }, {
                            name: "numFmtId",
                            value: commonUtils.isDefined(style.formatID) ? Number(style.formatID) + CUSTOM_FORMAT_START_INDEX - 1 : 0
                        }], this._getXMLTag("alignment", [{
                            name: "horizontal",
                            value: style.alignment
                        }, {
                            name: "vertical",
                            value: "top"
                        }, {
                            name: "wrapText",
                            value: style.wrapText
                        }])))
                }
                XML = XML + this._getXMLTag("cellXfs", [{
                        name: "count",
                        value: xmlStyles.length
                    }], xmlStyles.join(""));
                XML = XML + this._getXMLTag("cellStyles", [{
                        name: "count",
                        value: 1
                    }], this._getXMLTag("cellStyle", [{
                        name: "name",
                        value: "Normal"
                    }, {
                        name: "xfId",
                        value: 0
                    }, {
                        name: "builtinId",
                        value: 0
                    }]));
                XML = XML_TAG + this._getXMLTag("styleSheet", [{
                        name: "xmlns",
                        value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
                    }], XML);
                xlFolder.file(STYLE_FILE_NAME, XML);
                this._styleArray = []
            },
            _generateStringsXML: function() {
                var xlFolder = this._zip.folder(XL_FOLDER_NAME),
                    stringIndex,
                    stringsLength = this._stringArray.length,
                    sharedStringXml = XML_TAG;
                for (stringIndex = 0; stringIndex < stringsLength; stringIndex++)
                    this._stringArray[stringIndex] = this._getXMLTag("si", [], this._getXMLTag("t", [], this._stringArray[stringIndex]));
                sharedStringXml = sharedStringXml + this._getXMLTag("sst", [{
                        name: "xmlns",
                        value: OPEN_XML_FORMAT_URL + "/spreadsheetml/2006/main"
                    }, {
                        name: "count",
                        value: this._stringArray.length
                    }, {
                        name: "uniqueCount",
                        value: this._stringArray.length
                    }], this._stringArray.join(""));
                xlFolder.file(SHAREDSTRING_FILE_NAME, sharedStringXml);
                this._stringArray = []
            },
            _getPaneXML: function() {
                var attributes = [{
                            name: "activePane",
                            value: "bottomLeft"
                        }, {
                            name: "state",
                            value: "frozen"
                        }],
                    frozenArea = commonUtils.isDefined(this._dataProvider.getFrozenArea) ? this._dataProvider.getFrozenArea() : {
                        x: 0,
                        y: Number(this._dataProvider.isHeadersVisible())
                    };
                if (!(frozenArea.x || frozenArea.y))
                    return "";
                if (frozenArea.x)
                    attributes.push({
                        name: "xSplit",
                        value: frozenArea.x
                    });
                if (frozenArea.y)
                    attributes.push({
                        name: "ySplit",
                        value: frozenArea.y
                    });
                attributes.push({
                    name: "topLeftCell",
                    value: this._getCellIndex(frozenArea.y + 1, frozenArea.x)
                });
                return this._getXMLTag("pane", attributes)
            },
            _generateWorksheetXML: function() {
                var colIndex,
                    rowIndex,
                    cellData,
                    xmlCells,
                    maxCellIndex,
                    counter = 0,
                    xmlRows = [],
                    rowsLength = this._cellsArray.length,
                    cellsLength,
                    colsLength = this._colsArray.length,
                    rSpans = "1:" + colsLength,
                    xmlResult = [["<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">", this._needSheetPr ? GROUP_SHEET_PR_XML : SINGLE_SHEET_PR_XML, "<dimension ref=\"A1:", this._getCellIndex(this._maxIndex[0], this._maxIndex[1]) + "\"/><sheetViews><sheetView " + (this._rtlEnabled ? "rightToLeft=\"1\" " : "") + "tabSelected=\"1\" workbookViewId=\"0\">" + this._getPaneXML() + "</sheetView></sheetViews><sheetFormatPr defaultRowHeight=\"15\" outlineLevelRow=\"", this._dataProvider.getRowsCount() > 0 ? this._dataProvider.getGroupLevel(0) : 0, "\" x14ac:dyDescent=\"0.25\"/>"].join("")];
                for (colIndex = 0; colIndex < colsLength; colIndex++)
                    this._colsArray[colIndex] = this._getXMLTag("col", [{
                            name: "width",
                            value: this._colsArray[colIndex]
                        }, {
                            name: "min",
                            value: Number(colIndex) + 1
                        }, {
                            name: "max",
                            value: Number(colIndex) + 1
                        }]);
                xmlResult.push(this._getXMLTag("cols", [], this._colsArray.join("")) + "<sheetData>");
                for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
                    xmlCells = [];
                    cellsLength = this._cellsArray[rowIndex].length;
                    for (colIndex = 0; colIndex < cellsLength; colIndex++) {
                        rowIndex = Number(rowIndex);
                        cellData = this._cellsArray[rowIndex][colIndex];
                        xmlCells.push(this._getXMLTag("c", [{
                                name: "r",
                                value: this._getCellIndex(rowIndex + 1, colIndex)
                            }, {
                                name: "s",
                                value: cellData.style
                            }, {
                                name: "t",
                                value: cellData.type
                            }], commonUtils.isDefined(cellData.value) ? this._getXMLTag("v", [], cellData.value) : null))
                    }
                    xmlRows.push(this._getXMLTag("row", [{
                            name: "r",
                            value: Number(rowIndex) + 1
                        }, {
                            name: "spans",
                            value: rSpans
                        }, {
                            name: "outlineLevel",
                            value: !Number(rowIndex) ? 0 : this._dataProvider.getGroupLevel(this._getDataProviderRowIndex(rowIndex))
                        }, {
                            name: "x14ac:dyDescent",
                            value: "0.25"
                        }], xmlCells.join("")));
                    this._cellsArray[rowIndex] = null;
                    if (counter++ > 10000) {
                        xmlResult.push(xmlRows.join(""));
                        xmlRows = [];
                        counter = 0
                    }
                }
                xmlResult.push(xmlRows.join(""));
                xmlRows = [];
                maxCellIndex = this._getCellIndex(this._maxIndex[0], this._maxIndex[1]);
                xmlResult.push("</sheetData>" + this._generateMergingXML() + (this._options.autoFilterEnabled ? "<autoFilter ref=\"A1:" + maxCellIndex + "\" />" : "") + "<ignoredErrors><ignoredError sqref=\"A1:" + maxCellIndex + "\" numberStoredAsText=\"1\" /></ignoredErrors></worksheet>");
                this._zip.folder(XL_FOLDER_NAME).folder(WORKSHEETS_FOLDER).file(WORKSHEET_FILE_NAME, xmlResult.join(""));
                this._colsArray = [];
                this._cellsArray = [];
                xmlResult = []
            },
            _generateMergingXML: function() {
                var k,
                    l,
                    cellIndex,
                    rowIndex,
                    rowsLength = this._dataProvider.getRowsCount(),
                    columnsLength = this._dataProvider.getColumns().length,
                    usedArea = [],
                    mergeArray = [],
                    mergeArrayLength,
                    mergeIndex,
                    mergeXML = '';
                if (!commonUtils.isDefined(this._dataProvider.getCellMerging))
                    return "";
                for (rowIndex = 0; rowIndex < rowsLength; rowIndex++)
                    for (cellIndex = 0; cellIndex !== columnsLength; cellIndex++)
                        if (!commonUtils.isDefined(usedArea[rowIndex]) || !commonUtils.isDefined(usedArea[rowIndex][cellIndex])) {
                            var cellMerge = this._dataProvider.getCellMerging(rowIndex, cellIndex);
                            if (cellMerge.colspan || cellMerge.rowspan) {
                                mergeArray.push({
                                    start: this._getCellIndex(rowIndex + 1, cellIndex),
                                    end: this._getCellIndex(rowIndex + 1 + (cellMerge.rowspan || 0), cellIndex + (cellMerge.colspan || 0))
                                });
                                for (k = rowIndex; k <= rowIndex + cellMerge.rowspan || 0; k++)
                                    for (l = cellIndex; l <= cellIndex + cellMerge.colspan || 0; l++) {
                                        if (!commonUtils.isDefined(usedArea[k]))
                                            usedArea[k] = [];
                                        usedArea[k][l] = true
                                    }
                            }
                        }
                mergeArrayLength = mergeArray.length;
                for (mergeIndex = 0; mergeIndex < mergeArrayLength; mergeIndex++)
                    mergeXML = mergeXML + this._getXMLTag("mergeCell", [{
                            name: "ref",
                            value: mergeArray[mergeIndex].start + ":" + mergeArray[mergeIndex].end
                        }]);
                return mergeXML.length ? this._getXMLTag("mergeCells", [{
                            name: "count",
                            value: mergeArrayLength
                        }], mergeXML) : ""
            },
            _generateCommonXML: function() {
                var relsFileContent = XML_TAG + this._createXMLRelationships(this._createXMLRelationship(1, "officeDocument", "xl/" + WORKBOOK_FILE_NAME)),
                    xmlRelationships,
                    xlFolder = this._zip.folder(XL_FOLDER_NAME),
                    relsXML = XML_TAG;
                this._zip.folder("_" + RELATIONSHIP_PART_NAME).file("." + RELATIONSHIP_PART_NAME, relsFileContent);
                xmlRelationships = this._createXMLRelationship(1, "worksheet", "worksheets/" + WORKSHEET_FILE_NAME) + this._createXMLRelationship(2, "styles", STYLE_FILE_NAME) + this._createXMLRelationship(3, "sharedStrings", SHAREDSTRING_FILE_NAME);
                relsXML = relsXML + this._createXMLRelationships(xmlRelationships);
                xlFolder.folder("_" + RELATIONSHIP_PART_NAME).file(WORKBOOK_FILE_NAME + ".rels", relsXML);
                xlFolder.file(WORKBOOK_FILE_NAME, this._getWorkbookContent());
                this._zip.file(CONTENTTYPES_FILE_NAME, this._getContentTypesContent())
            },
            _generateContent: function() {
                this._prepareStyleData();
                this._prepareCellData();
                this._generateWorkXML();
                this._generateCommonXML()
            },
            _generateWorkXML: function() {
                this._generateStylesXML();
                this._generateStringsXML();
                this._generateWorksheetXML()
            },
            ctor: function(dataProvider, options) {
                this._rtlEnabled = options && !!options.rtlEnabled;
                this._options = options;
                this._maxIndex = [1, 2];
                this._stringArray = [];
                this._stringHash = {};
                this._styleArray = [];
                this._colsArray = [];
                this._cellsArray = [];
                this._styleFormat = [];
                this._needSheetPr = false;
                this._dataProvider = dataProvider;
                this._zip = new JSZip
            },
            ready: function() {
                return this._dataProvider.ready()
            },
            getData: function(isBlob) {
                this._generateContent();
                return this._zip.generateAsync ? this._zip.generateAsync({
                        type: isBlob ? "blob" : "base64",
                        compression: "DEFLATE",
                        mimeType: exporter.MIME_TYPES["EXCEL"]
                    }) : this._zip.generate({
                        type: isBlob ? "blob" : "base64",
                        compression: "DEFLATE",
                        mimeType: exporter.MIME_TYPES["EXCEL"]
                    })
            }
        });
        exporter.__internals = {
            CONTENTTYPES_FILE_NAME: CONTENTTYPES_FILE_NAME,
            RELATIONSHIP_PART_NAME: RELATIONSHIP_PART_NAME,
            XL_FOLDER_NAME: XL_FOLDER_NAME,
            WORKBOOK_FILE_NAME: WORKBOOK_FILE_NAME,
            STYLE_FILE_NAME: STYLE_FILE_NAME,
            WORKSHEET_FILE_NAME: WORKSHEET_FILE_NAME,
            WORKSHEETS_FOLDER: WORKSHEETS_FOLDER,
            SHAREDSTRING_FILE_NAME: SHAREDSTRING_FILE_NAME,
            GROUP_SHEET_PR_XML: GROUP_SHEET_PR_XML,
            SINGLE_SHEET_PR_XML: SINGLE_SHEET_PR_XML
        }
    })(jQuery, DevExpress);
    /*! Module widgets-web, file fileSaver.js */
    (function(DX, $) {
        var errors = DevExpress.require("/ui/ui.errors"),
            browser = DX.require("/utils/utils.browser"),
            commonUtils = DX.require("/utils/utils.common"),
            exporter = DX.dxClientExporter,
            FILE_EXTESIONS = {
                EXCEL: "xlsx",
                CSS: "css"
            };
        exporter.MIME_TYPES = {
            CSS: "text/css",
            EXCEL: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        };
        exporter.fileSaver = {
            _getDataUri: function(format, data) {
                return "data:" + exporter.MIME_TYPES[format] + ";base64," + data
            },
            _linkDownloader: function(fileName, href, callback) {
                var exportLinkElement = document.createElement('a'),
                    attributes = {
                        download: fileName,
                        href: href
                    };
                if (commonUtils.isDefined(callback))
                    attributes["onclick"] = callback;
                document.body.appendChild(exportLinkElement);
                $(exportLinkElement).css({display: "none"}).text("load").attr(attributes)[0].click();
                return exportLinkElement
            },
            _formDownloader: function(proxyUrl, fileName, contentType, data, callback) {
                var formAttributes = {
                        method: "post",
                        action: proxyUrl,
                        enctype: "multipart/form-data"
                    },
                    exportForm = $("<form>").css({display: "none"}).attr(formAttributes);
                if (commonUtils.isDefined(callback))
                    exportForm.submit(callback);
                exportForm.append("<input type=\"hidden\" name=\"fileName\" value=\"" + fileName + "\" />");
                exportForm.append("<input type=\"hidden\" name=\"contentType\" value=\"" + contentType + "\" />");
                exportForm.append("<input type=\"hidden\" name=\"data\" value=\"" + data + "\" />");
                exportForm.appendTo("body");
                exportForm.submit();
                if (exportForm.submit())
                    exportForm.remove();
                return exportForm
            },
            _saveByProxy: function(proxyUrl, fileName, format, data, callback) {
                return this._formDownloader(proxyUrl, fileName, exporter.MIME_TYPES[format], data, callback)
            },
            _winJSBlobSave: function(blob, fileName, format) {
                var savePicker = new Windows.Storage.Pickers.FileSavePicker;
                savePicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.documentsLibrary;
                savePicker.fileTypeChoices.insert(exporter.MIME_TYPES[format], ["." + FILE_EXTESIONS[format]]);
                savePicker.suggestedFileName = fileName;
                savePicker.pickSaveFileAsync().then(function(file) {
                    if (file)
                        file.openAsync(Windows.Storage.FileAccessMode.readWrite).then(function(outputStream) {
                            var inputStream = blob.msDetachStream();
                            Windows.Storage.Streams.RandomAccessStream.copyAsync(inputStream, outputStream).then(function() {
                                outputStream.flushAsync().done(function() {
                                    inputStream.close();
                                    outputStream.close()
                                })
                            })
                        })
                })
            },
            _saveBlobAs: function(fileName, format, data, linkClick) {
                this._blobSaved = false;
                if (commonUtils.isDefined(navigator.msSaveOrOpenBlob)) {
                    navigator.msSaveOrOpenBlob(data, fileName);
                    this._blobSaved = true
                }
                else if (commonUtils.isDefined(window.WinJS)) {
                    this._winJSBlobSave(data, fileName, format);
                    this._blobSaved = true
                }
                else {
                    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL;
                    linkClick = commonUtils.isDefined(linkClick) ? linkClick : function() {
                        var link = $('#dxExportLink');
                        URL.revokeObjectURL(link.attr('href'));
                        link.remove();
                        exporter.blobSaved = true
                    };
                    if (commonUtils.isDefined(URL))
                        return this._linkDownloader(fileName, URL.createObjectURL(data), linkClick)
                }
            },
            saveAs: function(fileName, format, data, proxyURL, linkClick) {
                fileName += "." + FILE_EXTESIONS[format];
                if (commonUtils.isFunction(window.Blob))
                    this._saveBlobAs(fileName, format, data);
                else if (commonUtils.isDefined(proxyURL) && !commonUtils.isDefined(navigator.userAgent.match(/iPad/i)))
                    this._saveByProxy(proxyURL, fileName, format, data);
                else {
                    if (!commonUtils.isDefined(navigator.userAgent.match(/iPad/i)))
                        errors.log("E1034");
                    if (browser.msie && parseInt(browser.version) < 10)
                        return;
                    this._linkDownloader(fileName, this._getDataUri(format, data), linkClick)
                }
            }
        }
    })(DevExpress, jQuery);
    DevExpress.MOD_WIDGETS_WEB = true
}